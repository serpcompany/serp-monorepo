[
  {
    "owner": "dioxuslabs",
    "repo": "dioxus",
    "content": "TITLE: Putting it All Together: A Simple Counter App\nDESCRIPTION: This Rust code demonstrates a complete Dioxus application with components, RSX, and hooks to create a simple counter. It initializes a signal `count` using `use_signal`. It includes buttons to increment and decrement the counter, which update the display in real-time. The `dioxus::launch` method is used to start the application.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/dioxus/README.md#_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\nuse dioxus::prelude::*;\n\nfn main() {\n    dioxus::launch(App);\n}\n\n#[component]\nfn App() -> Element {\n    let mut count = use_signal(|| 0);\n\n    rsx! {\n        div { \"Count: {count}\" }\n        button { onclick: move |_| count += 1, \"Increment\" }\n        button { onclick: move |_| count -= 1, \"Decrement\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Signals with Async Code in Dioxus (Correct)\nDESCRIPTION: This snippet shows the correct approach to using Dioxus signals with async code, avoiding panics by cloning the signal value before the `await` point and setting the signal to the new value afterward. It requires `use dioxus::prelude::*;` and ensures proper borrow management in async contexts.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/signals/docs/signals.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n# async fn sleep(delay: u32) {}\nasync fn double_me_async(value: u32) -> u32 {\n    sleep(100).await;\n    value * 2\n}\nlet mut signal = use_signal(|| 0);\n\nuse_future(move || async move {\n    // Clone the value out of the signal\n    let current_value = signal();\n    // Run the async work\n    let new_value = double_me_async(current_value).await;\n    // Set the signal to the new value\n    signal.set(new_value);\n});\n\nrsx! {\n    // This read will not panic because the write is never held over an await point\n    \"{signal}\"\n};\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing to a Signal in Dioxus\nDESCRIPTION: This snippet demonstrates how to read and write to a Dioxus signal using the `read()` and `write()` methods. It emphasizes the importance of dropping the read before writing to avoid runtime panics. It utilizes `use dioxus::prelude::*;` for access to signal-related functions.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/signals/docs/signals.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nlet mut signal = use_signal(|| 0);\n\n{\n    // This will read the value (we use a block to make sure the read is dropped before the write. You can read more about this in the next section)\n    let read = signal.read();\n    // Just like refcell, read you can deref the read to get the inner &T reference\n    match &*read {\n        &0 => println!(\"read is 0\"),\n        &1 => println!(\"read is 1\"),\n        _ => println!(\"read is something else ({read})\"),\n    }\n}\n\n// This will write to the value\nlet mut write = signal.write();\n// Again, we can deref the write to get the inner &mut T reference\n*write += 1;\n```\n\n----------------------------------------\n\nTITLE: Launching a Dioxus App with a Simple Component in Rust\nDESCRIPTION: This code snippet demonstrates how to launch a Dioxus application with a basic component that renders \"hello world!\". It utilizes the `dioxus::launch` function to start the application and defines a component named `App` using the `rsx!` macro to generate the UI element. No external dependencies are explicitly required beyond the `dioxus::prelude` module.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/dioxus-lib/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\n\nfn main() {\n    dioxus::launch(App);\n}\n\n// The #[component] attribute streamlines component creation.\n// It's not required, but highly recommended. For example, UpperCamelCase components will not generate a warning.\n#[component]\nfn App() -> Element {\n    rsx! { \"hello world!\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Local Subscriptions with Dioxus Signals in Rust\nDESCRIPTION: Illustrates how Dioxus Signals implements local subscriptions. Components only re-render when they read from a Signal. Reading from a Signal in a future or event handler will not cause the component to subscribe. This example demonstrates how to update a signal within an event handler and how the signal only reruns components that read it.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/signals/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\nuse dioxus_signals::*;\n\n#[component]\nfn App() -> Element {\n    // Because signal is never read in this component, this component will not rerun when the signal changes\n    let mut signal = use_signal(|| 0);\n\n    rsx! {\n        button {\n            onclick: move |_| {\n                signal += 1;\n            },\n            \"Increase\"\n        }\n        for id in 0..10 {\n            Child {\n                signal,\n            }\n        }\n    }\n}\n\n#[derive(Props, Clone, PartialEq)]\nstruct ChildProps {\n    signal: Signal<usize>,\n}\n\nfn Child(props: ChildProps) -> Element {\n    // This component does read from the signal, so when the signal changes it will rerun\n    rsx! {\n        \"{props.signal}\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Default Props in Dioxus\nDESCRIPTION: This example demonstrates how to use the `#[props(default)]` attribute to define default values for props in a Dioxus component. If the prop is not explicitly set when the component is used, the default value will be used. It showcases defining default values using the `Default` trait and explicit default values.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/props.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[derive(Props, PartialEq, Clone)]\nstruct ButtonProps {\n    // The default attributes makes your field optional in the component and uses the default value if it is not set.\n    #[props(default)]\n    text: String,\n\n    /// You can also set an explicit default value instead of using the `Default` implementation.\n    #[props(default = \"red\".to_string())]\n    color: String,\n}\n\nfn Button(props: ButtonProps) -> Element {\n    rsx! {\n        button {\n            color: props.color,\n            \"{props.text}\"\n        }\n    }\n}\n\nrsx! {\n    // You can skip setting props that have a default value when you use the component.\n    Button {}\n};\n```\n\n----------------------------------------\n\nTITLE: Launching a Dioxus App with a Root Component\nDESCRIPTION: This Rust code demonstrates how to launch a Dioxus application. It imports the necessary modules from the `dioxus::prelude` crate. The `main` function calls `dioxus::launch` with the `App` component as the root. The `App` component is defined using the `#[component]` attribute, which simplifies component creation. The `App` component returns an `Element` containing the text \"hello world!\".\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/dioxus/README.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nuse dioxus::prelude::*;\n\nfn main() {\n    dioxus::launch(App);\n}\n\n// The #[component] attribute streamlines component creation.\n// It's not required, but highly recommended. It will lint incorrect component definitions and help you create props structs.\n#[component]\nfn App() -> Element {\n    rsx! { \"hello world!\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ReadOnlySignal for Reactive Props in Dioxus\nDESCRIPTION: This example demonstrates how to use `ReadOnlySignal` to make a prop reactive.  By wrapping the `count` prop in `ReadOnlySignal`, the `use_memo` hook will automatically re-run when the `count` changes.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/props.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn Counter(count: ReadOnlySignal<i32>) -> Element {\n    // Since we made count reactive, the memo will automatically rerun when count changes.\n    let doubled_count = use_memo(move || count() * 2);\n    rsx! {\n        div {\n            \"Count: {count}\"\n            \"Doubled Count: {doubled_count}\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dioxus App Example in Rust\nDESCRIPTION: This snippet demonstrates a basic Dioxus application with a counter. It uses the `use_signal` hook for state management and defines a component that renders a heading and two buttons to increment and decrement the counter.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn app() -> Element {\n    let mut count = use_signal(|| 0);\n\n    rsx! {\n        h1 { \"High-Five counter: {count}\" }\n        button { onclick: move |_| count += 1, \"Up high!\" }\n        button { onclick: move |_| count -= 1, \"Down low!\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Props with Derive Macro in Dioxus\nDESCRIPTION: This example demonstrates how to define props for a Dioxus component using the `#[derive(Props)]` macro. It shows how to define the `ButtonProps` struct with `text` and `color` fields, and how to use those props within the `Button` component. It also illustrates how to pass props to the component using `rsx!`.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/props.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[derive(Props, PartialEq, Clone)]\nstruct ButtonProps {\n    /// The text of the button\n    text: String,\n\n    /// The color of the button\n    color: String,\n}\n\nfn Button(props: ButtonProps) -> Element {\n    rsx! {\n        button {\n            color: props.color,\n            \"{props.text}\"\n        }\n    }\n}\n\nrsx! {\n    // Any fields you defined on the props struct will be turned into props for the component.\n    Button {\n        text: \"Click me!\",\n        color: \"red\",\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Using Optional Props in Dioxus\nDESCRIPTION: This example demonstrates how to define optional props in Dioxus using `Option<T>`. Any field with the type `Option<T>` is automatically optional with a default value of `None`.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/props.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[derive(Props, PartialEq, Clone)]\nstruct ButtonProps {\n    // Since the `text` field is optional, you don't need to set it when you use the component.\n    text: Option<String>,\n}\n\nfn Button(props: ButtonProps) -> Element {\n    rsx! {\n        button { {props.text.unwrap_or(\"button\".to_string())} }\n    }\n}\n\nrsx! {\n    Button {}\n};\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Memo in Dioxus\nDESCRIPTION: This snippet demonstrates how to create and use a memo in a Dioxus component. The memo `double` calculates two times the value of the `count` signal. When the `count` signal is updated by clicking the button, the memo automatically re-calculates. The component re-renders only if the value of `double` changes.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/derived_state.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\nuse dioxus_signals::*;\n\nfn App() -> Element {\n    let mut count = use_signal(|| 0);\n    // the double memo will always be equal to two times the value of count, even after count changes\n    let double = use_memo(move || count * 2);\n\n    rsx! {\n        \"{double}\"\n        button {\n            // When count changes, the memo will rerun and double will be updated\n            // memos rerun any time you write to a signal they read. They will only rerun values/component that depend on them if the value of the memo changes\n            onclick: move |_| count += 1,\n            \"Increment\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dioxus vs Leptos DSL Comparison\nDESCRIPTION: This snippet compares the Domain Specific Language (DSL) used by Dioxus and Leptos for building user interfaces. It showcases how Dioxus uses a custom Rust-like DSL, while Leptos uses an HTML-like syntax. The example demonstrates how to create a simple div element with a class, a boolean attribute, and a dynamic text value using both DSLs.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/README.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n// dioxus\nrsx! {\n  div {\n    class: \"my-class\",\n    enabled: true,\n    \"Hello, {name}\"\n  }\n}\n\n// leptos\nview! {\n  <div class=\"my-class\" enabled={true}>\n    \"Hello \"\n    {name}\n  </div>\n}\n```\n\n----------------------------------------\n\nTITLE: Memos with Async - Cloning Values\nDESCRIPTION: This snippet demonstrates the correct way to use memos with async code by cloning the necessary values before the await point, preventing panics. It advises cloning the value of the memo to prevent panics when working with async functions. Dependencies: `dioxus::prelude::*`.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/signals/docs/memo.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n# async fn sleep(delay: u32) {}\nasync fn double_me_async(value: u32) -> u32 {\n    sleep(100).await;\n    value * 2\n}\nlet mut signal = use_signal(|| 0);\nlet halved = use_memo(move || signal() / 2);\n\nlet doubled = use_resource(move || async move {\n    // Calling the memo will clone the inner value\n    let halved = halved();\n    double_me_async(halved).await;\n});\n\nrsx!{\n    \"{doubled:?}\"\n    button {\n        onclick: move |_| {\n            signal += 1;\n        },\n        \"Increment\"\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Using Children Props in Dioxus (Usage)\nDESCRIPTION: This example demonstrates how to use a component that accepts `children` props. The RSX is placed inside the component's tag.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/props.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n# #[derive(PartialEq, Clone, Props)]\n# struct ClickableProps {\n#     href: String,\n#     children: Element,\n# }\n#\n# fn Clickable(props: ClickableProps) -> Element {\n#     rsx! {\n#         a {\n#             href: \"{props.href}\",\n#             class: \"fancy-button\",\n#             {props.children}\n#         }\n#     }\n# }\nrsx! {\n    Clickable {\n        href: \"https://www.youtube.com/watch?v=C-M2hs3sXGo\",\n        \"How to \"\n        i { \"not\" }\n        \" be seen\"\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Derived State with use_memo in Dioxus (Rust)\nDESCRIPTION: This example demonstrates how to derive state from other state using the `use_memo` hook in Dioxus. The `double_count` value is automatically updated whenever the `count` signal changes, showcasing the reactivity system.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core/docs/reactivity.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\n\nlet mut count = use_signal(|| 0);\nlet double_count = use_memo(move || count() * 2);\n\n// Now whenever we read double_count, we know it is always twice the value of count\nprintln!(\"{}\", double_count); // Prints \"2\"\n\n// After we write to count, the reactive context will rerun and double_count will be updated automatically\ncount += 1;\n\nprintln!(\"{}\", double_count); // Prints \"4\"\n```\n\n----------------------------------------\n\nTITLE: Using Context for State Management in Dioxus (Rust)\nDESCRIPTION: Illustrates using the use_context hook to pass state from a parent component (ParentComponent) to its children. The parent component provides a MyState struct using use_context_provider. The child (IncrementButton) retrieves this state with use_context and increments it when clicked. This approach is useful for state that's global to part of the app.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/moving_state_around.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[derive(Clone, Copy)]\nstruct MyState {\n    count: Signal<i32>\n}\n\nfn ParentComponent() -> Element {\n    // Use context provider provides an unique type to all children of this component\n    use_context_provider(|| MyState { count: Signal::new(0) });\n\n    rsx! {\n        // IncrementButton will have access to the count without explicitly passing it through props\n        IncrementButton {}\n    }\n}\n\n#[component]\nfn IncrementButton() -> Element {\n    // Use context gets the value from a parent component\n    let mut count = use_context::<MyState>().count;\n\n    rsx! {\n        button {\n            onclick: move |_| count += 1,\n            \"Increment\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Elements with the rsx! Macro\nDESCRIPTION: This Rust code demonstrates how to create elements using the `rsx!` macro in Dioxus. It shows the usage of attributes, listeners, and children within the macro. It defines a local variable `value` and uses it within the `class` attribute. An `onclick` listener is attached to the `div` element, which prints \"clicked!\" to the console when clicked. The `div` contains an `h1` child element with the text \"hello world\".\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/dioxus/README.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n# use dioxus::prelude::*;\nlet value = \"123\";\n\nrsx! {\n    div {\n        class: \"my-class {value}\",                  // <--- attribute\n        onclick: move |_| println!(\"clicked!\"),   // <--- listener\n        h1 { \"hello world\" }                       // <--- child\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Simple App with state and event handling in Rust\nDESCRIPTION: This code snippet demonstrates a simple Dioxus app with state management and event handling. It defines a functional component `App` that uses the `use_signal` hook to manage a counter. The app includes two buttons that increment and decrement the counter, updating the UI when clicked.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/dioxus-lib/README.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\n\nfn main() {\n    dioxus::launch(App);\n}\n\n#[component]\nfn App() -> Element {\n    let mut count = use_signal(|| 0);\n\n    rsx!(\n        div { \"Count: {count}\" }\n        button { onclick: move |_| count += 1, \"Increment\" }\n        button { onclick: move |_| count -= 1, \"Decrement\" }\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Memo Behavior with Signal Updates\nDESCRIPTION: This code illustrates how memos react to signal updates. The `double_count` memo is updated whenever `count` changes. The `double_count_plus_one` memo is updated only when `double_count` changes.  Writing the same value to `count` doesn't trigger `double_count_plus_one` to rerun, demonstrating the memo's `PartialEq` check.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/derived_state.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nlet mut count = use_signal(|| 1);\n// double_count will rerun when state we read inside the memo changes (count)\nlet double_count = use_memo(move || count() * 2);\n\n// memos act a lot like a read only version of a signal. You can read them, display them, and move them around like any other signal\nprintln!(\"{}\", double_count); // Prints \"2\"\n\n// But you can't write to them directly\n// Instead, any time you write to a value the memo reads, the memo will rerun\ncount += 1;\n\nprintln!(\"{}\", double_count); // Prints \"4\"\n\n// Lets create another memo that reads the value of double_count\nlet double_count_plus_one = use_memo(move || double_count() + 1);\n\nprintln!(\"{}\", double_count_plus_one); // Prints \"5\"\n\n// Now if we write to count the double_count memo will rerun\n// If that the output of double_count changes, then it will cause double_count_plus_one to rerun\ncount += 1;\n\nprintln!(\"{}\", double_count); // Prints \"6\"\nprintln!(\"{}\", double_count_plus_one); // Prints \"7\"\n\n// However if the value of double_count doesn't change after a write, then it won't trigger double_count_plus_one to rerun\n// Since we just write the same value, the doubled value is still 6 and we don't rerun double_count_plus_one\n*count.write() = 3;\n\nprintln!(\"{}\", double_count); // Prints \"6\"\nprintln!(\"{}\", double_count_plus_one); // Prints \"7\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Dioxus Component With Props (Rust)\nDESCRIPTION: This example demonstrates how to define a Dioxus component using the `component` macro with a single `String` prop named `bob`. The component renders the text \"hello, {bob}\". It requires the `dioxus::prelude` module.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/component.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn GreetBob(bob: String) -> Element {\n    rsx! { \"hello, {bob}\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Reactive Context Example in Dioxus (Rust)\nDESCRIPTION: This code snippet demonstrates how reactive contexts work in Dioxus using `use_signal` and `use_memo`. The `use_memo` hook automatically tracks the dependency on the `count` signal, ensuring updates when the signal changes.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core/docs/reactivity.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nlet count = use_signal(|| 0);\n// The reactive context in the memo knows that the memo depends on the count signal\nuse_memo(move || count() * 2);\n```\n\n----------------------------------------\n\nTITLE: Dioxus Component with Default Props (Rust)\nDESCRIPTION: This example showcases the `default` prop modifier. The `text` prop defaults to the empty string, and the `color` prop defaults to \"red\".  If a prop with the default attribute is not explicitly set when the component is used, it will use the default value provided.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/component.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn Button(\n    // The default attributes makes your field optional in the component and uses the default value if it is not set.\n    #[props(default)]\n    text: String,\n    // You can also set an explicit default value instead of using the `Default` implementation.\n    #[props(default = \"red\".to_string())]\n    color: String,\n) -> Element {\n    rsx! {\n        button {\n            color: color,\n            \"{text}\"\n        }\n    }\n}\n\nrsx! {\n    // You can skip setting props that have a default value when you use the component.\n    Button {}\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Component with the rsx! Macro\nDESCRIPTION: This Rust code snippet demonstrates how to create a simple component using the `rsx!` macro in Dioxus. The `App` component, decorated with the `#[component]` attribute, renders an `h1` element with a personalized greeting and a `div` containing a loop that creates multiple `div` elements with \"FizzBuzz\" messages. A local variable named `name` is used within the `h1` element. Class and id attributes are added to the containing div.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/dioxus/README.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn App() -> Element {\n    let name = \"dave\";\n    rsx! {\n        h1 { \"Hello, {name}!\" }\n        div { class: \"my-class\", id: \"my-id\",\n            for i in 0..5 {\n                div { \"FizzBuzz: {i}\" }\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Computed Data with use_memo in Dioxus Signals (Rust)\nDESCRIPTION: Demonstrates how to use the `use_memo` hook in Dioxus Signals to derive data with local subscriptions. The `use_memo` hook only re-runs when its dependencies (signals inside) change. In this example, the `doubled` signal is computed from the `signal` and updates whenever `signal` changes. A child component displays the computed `doubled` value.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/signals/README.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\nuse dioxus_signals::*;\n\n#[component]\nfn App() -> Element {\n    let mut signal = use_signal(|| 0);\n    let doubled = use_memo(move || signal * 2);\n\n    rsx! {\n        button {\n            onclick: move |_| signal += 1,\n            \"Increase\"\n        }\n        Child {\n            signal: doubled\n        }\n    }\n}\n\n#[component]\nfn Child(signal: ReadOnlySignal<usize>) -> Element {\n    rsx! {\n        \"{signal}\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Props with the `into` Attribute in Dioxus\nDESCRIPTION: This example demonstrates how to use the `#[props(into)]` attribute to automatically convert a prop to the correct type using the `Into` trait. This allows passing in any type that implements `Into<T>` for a prop of type `T`.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/props.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[derive(Props, PartialEq, Clone)]\nstruct ButtonProps {\n    /// You can use the `into` attribute on a field to convert types you pass in with the Into trait.\n    #[props(into)]\n    number: u64,\n}\n\nfn Button(props: ButtonProps) -> Element {\n    rsx! {\n        button { \"{props.number}\" }\n    }\n}\n\nrsx! {\n    Button {\n        // Because we used the into attribute, we can pass in any type that implements Into<u64>\n        number: 10u8\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Receiving Data from JavaScript with Eval in Dioxus\nDESCRIPTION: This snippet demonstrates how to receive data sent from JavaScript back to Rust using the `eval` function and the `recv` method on the `Eval` object.  The JavaScript code sends data asynchronously using `dioxus.send()`. It requires the `dioxus` crate.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/document/docs/eval.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\n\nfn app() -> Element {\n    rsx! {\n        button {\n            onclick: move |_| async move {\n                // You can send values from rust to the JavaScript code by using the `send` method on the object returned by `eval`.\n                let mut eval = document::eval(r#\"for(let i = 0; i < 10; i++) {\n                    // You can send values asynchronously with the `dioxus.send()` method.\n                    dioxus.send(i);\n                }\"#);\n\n                // You can receive values from the JavaScript code with the `recv` method on the object returned by `eval`.\n                for _ in 0..10 {\n                    let value: i32 = eval.recv().await.unwrap();\n                    println!(\"Received {}\", value);\n                }\n            },\n            \"Log Count\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Server-Side Rendering\nDESCRIPTION: This snippet demonstrates how to use Dioxus SSR for server-side rendering. It creates a VirtualDom from a simple component, rebuilds it, renders it to a string, and asserts that the rendered string is the expected HTML output.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/ssr/README.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nfn App() -> Element {\n  rsx! { div { \"hello world!\" } }\n}\nlet mut vdom = VirtualDom::new(App);\nvdom.rebuild_in_place();\nlet text = dioxus_ssr::render(&vdom);\nassert_eq!(text, \"<div>hello world!</div>\")\n```\n\n----------------------------------------\n\nTITLE: Rendering Elements with Attributes, Listeners, and Children in Rust\nDESCRIPTION: This snippet shows how to use the `rsx!` macro to create elements with attributes, event listeners, and child elements. The `rsx!` macro allows for defining UI elements in a JSX-like syntax. It accepts attributes in \"struct form\" and any rust expression implementing `IntoIterator<Item = impl IntoVNode>` will be parsed as a child. For loops and if statements are parsed where their body is parsed as a child.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/dioxus-lib/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet value = \"123\";\n\nrsx! {\n    div {\n        class: \"my-class {value}\",                  // <--- attribute\n        onclick: move |_| info!(\"clicked!\"),   // <--- listener\n        h1 { \"hello world\" },                       // <--- child\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Loops within the rsx! Macro\nDESCRIPTION: This Rust code snippet demonstrates how to use a `for` loop within the `rsx!` macro in Dioxus. The `rsx!` macro accepts Rust expressions contained within curly braces that implement `IntoDynNode` to be parsed as a child. It shows an example of a `for` loop iterating from 0 to 9 (exclusive), creating a `span` element with the text \"hello world\" for each iteration.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/dioxus/README.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n# use dioxus::prelude::*;\nrsx! {\n    div {\n        for _ in 0..10 {\n            span { \"hello world\" }\n        }\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: VirtualDom Usage with Event Handling and Rendering in Rust\nDESCRIPTION: This code snippet demonstrates the basic usage of `dioxus-core` to create a virtual DOM, handle events, and render the UI. It initializes a `VirtualDom` with a root component, sets up an event loop, and applies mutations to a hypothetical real DOM. This example requires the `dioxus_core` and `tokio` crates.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# tokio::runtime::Runtime::new().unwrap().block_on(async {\nuse dioxus_core::prelude::*;\nuse dioxus_core::*;\n\nlet mut vdom = VirtualDom::new(app);\nlet real_dom = SomeRenderer::new();\n\nloop {\n    tokio::select! {\n        evt = real_dom.event() => {\n            let evt = Event::new(evt, true);\n            vdom.runtime().handle_event(\"onclick\", evt, ElementId(0))\n        },\n        _ = vdom.wait_for_work() => {}\n    }\n    vdom.render_immediate(&mut real_dom.apply())\n}\n\n# fn app() -> Element { VNode::empty() }\n# struct SomeRenderer; impl SomeRenderer { fn new() -> SomeRenderer { SomeRenderer } async fn event(&self) -> std::rc::Rc<dyn std::any::Any> { unimplemented!() } fn apply(&self) -> Mutations { Mutations::default() } }\n# });\n```\n\n----------------------------------------\n\nTITLE: Sending Data to JavaScript with Eval in Dioxus\nDESCRIPTION: This code shows how to send data from Rust to JavaScript using the `eval` function and the `send` method on the `Eval` object.  The JavaScript code receives these values asynchronously using `await dioxus.recv()`. It requires the `dioxus` crate.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/document/docs/eval.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\n\nfn app() -> Element {\n    rsx! {\n        button {\n            onclick: move |_| {\n                // You can pass initial data to the eval function by formatting it into the JavaScript code.\n                const LOOP_COUNT: usize = 10;\n                let eval = document::eval(&format!(r#\"for(let i = 0; i < {LOOP_COUNT}; i++) {{\n                    // You can receive values asynchronously with the the `await dioxus.recv()` method.\n                    let value = await dioxus.recv();\n                    console.log(\"Received\", value);\n                }}\"#));\n\n                // You can send values from rust to the JavaScript code with the `send` method on the object returned by `eval`.\n                for i in 0..LOOP_COUNT {\n                    eval.send(i).unwrap();\n                }\n            },\n            \"Log Count\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Install Dioxus CLI (Stable Version)\nDESCRIPTION: Installs the stable version of the Dioxus CLI using cargo. This is the recommended installation method.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/cli/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo install dioxus-cli\n```\n\n----------------------------------------\n\nTITLE: Dioxus Component with Children Props (Rust)\nDESCRIPTION: This example demonstrates how to create a component that accepts children using the `children` prop.  The `children` prop will take any RSX inside the component tag.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/component.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn Clickable(\n    href: String,\n    children: Element,\n) -> Element {\n    rsx! {\n        a {\n            href: \"{href}\",\n            class: \"fancy-button\",\n            {children}\n        }\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n# #[component]\n# fn Clickable(\n#     href: String,\n#     children: Element,\n# ) -> Element {\n#     rsx! {\n#         a {\n#             href: \"{href}\",\n#             class: \"fancy-button\",\n#             {children}\n#         }\n#     }\n# }\nrsx! {\n    Clickable {\n        href: \"https://www.youtube.com/watch?v=C-M2hs3sXGo\",\n        \"How to \"\n        i { \"not\" }\n        \" be seen\"\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Tracked Value Example in Dioxus (Rust)\nDESCRIPTION: This snippet illustrates the concept of tracked values in Dioxus using `use_signal` and `use_memo`. When the `count` signal is read within the `use_memo` closure, the reactive context subscribes to it, triggering re-execution when the signal's value changes.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core/docs/reactivity.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n// The count signal is tracked\nlet count = use_signal(|| 0);\n// When you read the count signal, the reactive context subscribes to the count signal\nlet double_count = use_memo(move || count() * 2);\n```\n\n----------------------------------------\n\nTITLE: Defining Component Properties with Structs in Rust\nDESCRIPTION: This code demonstrates how to define component properties using structs in Dioxus. The `Props` derive macro allows adding functionality to how props are interpreted. Properties are memoized by default and implement both Clone and PartialEq. For non-cloneable props, they can be wrapped in a ReadOnlySignal.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/dioxus-lib/README.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// The `Props` derive macro lets us add additional functionality to how props are interpreted.\n#[derive(Props, PartialEq)]\nstruct HeaderProps {\n    title: String,\n    color: String,\n}\n\n#[component]\nfn Header(props: HeaderProps) -> Element {\n    rsx! {\n        div {\n            background_color: \"{props.color}\"\n            h1 { \"{props.title}\" }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dioxus useEffect Modifying Mounted Nodes\nDESCRIPTION: This example demonstrates how to modify mounted nodes using `use_effect` in conjunction with the `onmounted` event. The effect reads the width of a div element after it has been mounted and updates a signal with the size information. The effect reruns whenever the input text changes.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/side_effects.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nfn MyComponent() -> Element {\n    let mut current_text = use_signal(String::new);\n    let mut mounted_text_div: Signal<Option<MountedEvent>> = use_signal(|| None);\n    let mut rendered_size = use_signal(String::new);\n\n    use_effect(move || {\n        // If we have mounted the text div, we can read the width of the div\n        if let Some(div) = mounted_text_div() {\n            // We read the current text here inside of the effect instead of the spawn so the effect subscribes to the signal\n            let text = current_text();\n            spawn(async move {\n                let bounding_box = div.get_client_rect().await;\n                rendered_size.set(format!(\"{text} is {bounding_box:?}\"));\n            });\n        }\n    });\n\n    rsx! {\n        input {\n            // When you enter text into the input, the effect will rerun because it subscribes to the current_text signal\n            oninput: move |evt| current_text.set(evt.value()),\n            placeholder: \"Enter text here\",\n            value: \"{current_text}\"\n        }\n        // When text changes, it will change the size of this div\n        div {\n            onmounted: move |element| {\n                mounted_text_div.set(Some(element.clone()));\n            },\n            \"{current_text}\"\n        }\n\n        \"{rendered_size}\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Reactive `use_resource` with Signal Dependencies in Dioxus\nDESCRIPTION: This example demonstrates how `use_resource` reacts to changes in a Dioxus signal. The resource fetches data based on a count signal, and updates automatically when the signal's value changes. It showcases resource state management and value retrieval.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/use_resource.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n// Create a new count signal\nlet mut count = use_signal(|| 1);\n// Create a new resource that doubles the value of count\nlet double_count = use_resource(move || async move {\n    // Start a request to the server. We are reading the value of count in the format macro\n    // Reading the value of count makes the resource \"subscribe\" to changes to count (when count changes, the resource will rerun)\n    let response = reqwest::get(format!(\"https://myserver.com/doubleme?count={count}\")).await.unwrap();\n    response.text().await.unwrap()\n});\n\n// Resource can be read in a way that is similar to signals, but they have a bit of extra information about the state of the resource future.\n\n// Calling .state() on a resource will return a Signal<UseResourceState> with information about the current status of the resource\nprintln!(\"{:?}\", double_count.state().read()); // Prints \"UseResourceState::Pending\"\n\n// You can also try to get the last resolved value of the resource with the .value() method\nprintln!(\"{:?}\", double_count.read()); // Prints \"None\"\n\n// Wait for the resource to finish and get the value\nstd::thread::sleep(std::time::Duration::from_secs(1));\n\n// Now if we read the state, we will see that it is done\nprintln!(\"{:?}\", double_count.state().read()); // Prints \"UseResourceState::Done\"\n\n// And we can get the value\nprintln!(\"{:?}\", double_count.read()); // Prints \"Some(2)\"\n\n// Now if we write to count, the resource will rerun\ncount += 1; // count is now 2\n\n// Wait for the resource to finish and get the value\nstd::thread::sleep(std::time::Duration::from_secs(1));\n\n// Now if we read the state, we will see that it is done\nprintln!(\"{:?}\", double_count.state().read()); // Prints \"UseResourceState::Done\"\n\n// And we can get the value\nprintln!(\"{:?}\", double_count.read()); // Prints \"Some(4)\"\n\n// One more case, what happens if we write to the resource while it is in progress?\n// The resource will rerun and the value will be None\ncount += 1; // count is now 3\n\n// If we write to a value the resource subscribes to again, it will cancel the current future and start a new one\ncount += 1; // count is now 4\n\nprintln!(\"{:?}\", double_count.state().read()); // Prints \"UseResourceState::Stopped\"\nprintln!(\"{:?}\", double_count.read()); // Prints the last resolved value \"Some(4)\"\n\n// After we wait for the resource to finish, we will get the value of only the latest future\nstd::thread::sleep(std::time::Duration::from_secs(1));\n\nprintln!(\"{:?}\", double_count.state().read()); // Prints \"UseResourceState::Done\"\n\nprintln!(\"{:?}\", double_count.read()); // Prints \"Some(8)\"\n```\n\n----------------------------------------\n\nTITLE: Using the use_signal Hook\nDESCRIPTION: This Rust code demonstrates how to use the `use_signal` hook in Dioxus to manage component state. The `App` component uses `use_signal` to create a signal named `name` initialized with the value \"world\". The component then renders the text \"hello {name}!\". The `use_signal` hook persists values across render cycles.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/dioxus/README.md#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn App() -> Element {\n    // The use signal hook runs once when the component is created and then returns the current value every run after the first\n    let name = use_signal(|| \"world\");\n\n    rsx! { \"hello {name}!\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Dioxus App Component Definition in Rust\nDESCRIPTION: This snippet defines a simple Dioxus app component in Rust that manages a counter using signals. It demonstrates the use of `use_signal` for state management and `rsx!` for defining the UI with increment and decrement buttons.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/ja-jp/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn app() -> Element {\n    let mut count = use_signal(|| 0);\n\n    rsx! {\n        h1 { \"High-Five counter: {count}\" }\n        button { onclick: move |_| count += 1, \"Up high!\" }\n        button { onclick: move |_| count -= 1, \"Down low!\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Async Event Handler (Rust)\nDESCRIPTION: This snippet demonstrates how to use an asynchronous closure to handle events in Dioxus. The `onclick` event accepts a closure that returns an async block. Dioxus automatically spawns this async block when the event occurs, allowing for non-blocking operations.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/html/docs/event_handlers.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\n\nfn App() -> Element {\n    rsx! {\n        button {\n            // The `onclick` event can also accept a closure that returns an async block\n            onclick: move |_| async move {\n                tokio::time::sleep(std::time::Duration::from_secs(1)).await;\n                println!(\"You clicked the button one second ago!\");\n            },\n            \"Click me\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with If Statements in Dioxus\nDESCRIPTION: Explains how to use if statements to conditionally render different parts of a Dioxus component.  The if statement body is parsed as rsx markup. Requires the dioxus prelude.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/rsx.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nlet first_boolean = true;\nlet second_boolean = false;\nrsx! {\n    if first_boolean {\n        div {\n            \"first\"\n        }\n    }\n\n    if second_boolean {\n        \"second\"\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Dioxus Component with Converting Props (Rust)\nDESCRIPTION: This example uses the `into` attribute to automatically convert props to the correct type using the `Into` trait. The `number` prop is a `u64`, but it's passed a `u8`, and the `into` attribute handles the conversion.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/component.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn Button(\n    // You can use the `into` attribute on a field to convert types you pass in with the Into trait.\n    #[props(into)]\n    number: u64,\n) -> Element {\n    rsx! {\n        button { \"{number}\" }\n    }\n}\n\nrsx! {\n    Button {\n        // Because we used the into attribute, we can pass in any type that implements Into<u64>\n        number: 10u8\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Copy Data with Dioxus Signals in Rust\nDESCRIPTION: Demonstrates how Dioxus Signals allows copying data, even when the underlying type does not implement Copy. This is achieved through the Signal type, which enables moving data into futures or child components without ownership issues. The example shows a string signal being used within a spawned async task.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/signals/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\nuse dioxus_signals::*;\n\n#[component]\nfn App() -> Element {\n    let signal = use_signal(|| \"hello world\".to_string());\n\n    spawn(async move {\n        // signal is Copy even though String is not copy\n        print!(\"{signal}\");\n    });\n\n    rsx! {\n        \"{signal}\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Composing Components with Properties\nDESCRIPTION: This Rust code demonstrates how to compose components in Dioxus by passing properties. It shows an `App` component rendering a `Header` component and passing `title` and `color` props to it.  All properties are memoized with `Clone` and `PartialEq` by default.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/dioxus/README.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\n# use dioxus::prelude::*;\n# #[component] fn Header(title: String, color: String) -> Element { todo!() }\n#[component]\nfn App() -> Element {\n    rsx! {\n        Header {\n            title: \"My App\",\n            color: \"red\",\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Event Handler with Cloning for Non-Copy Data (Rust)\nDESCRIPTION: This snippet demonstrates how to handle non-`Copy` data, such as `String`, within event handlers.  It uses the `clone()` method to create a copy of the string that can be moved into the closure, allowing it to be used without transferring ownership from outside the closure.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/html/docs/event_handlers.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n// String is not `Copy`\nlet string = \"hello world\".to_string();\n\nrsx! {\n    button {\n        // The string only has one owner. We could move it into this closure, but since we want to use the string in other closures later, we will clone it instead\n        onclick: {\n            // Clone the string in a new block\n            let string = string.clone();\n            // Then move the cloned string into the closure\n            move |_| println!(\"{}\", string)\n        },\n        \"Print hello world\"\n    }\n    button {\n        // We don't use the string after this closure, so we can just move it into the closure directly\n        onclick: move |_| println!(\"{}\", string),\n        \"Print hello world again\"\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering Components in Dioxus with rsx!\nDESCRIPTION: Illustrates how to render other Dioxus components within a component using the rsx! macro, similar to rendering elements. Components must start with a capital letter or contain an underscore. Requires the dioxus prelude.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/rsx.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn HelloWorld() -> Element {\n    rsx! { \"hello world!\" }\n}\n\nrsx! {\n    div {\n        HelloWorld {}\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Hook Usage in Component and Custom Hook - Rust\nDESCRIPTION: This snippet demonstrates how to correctly and incorrectly use hooks within a Dioxus component and a custom hook.  It shows that hooks should only be called from the root of a component or another hook and not inside conditional expressions to maintain a consistent execution order. The example uses `use_signal` and `use_memo` from Dioxus.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/rules_of_hooks.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nfn App() -> Element {\n    // ✅ You can call hooks from the body of a component\n    let number = use_signal(|| 1);\n    if number() == 1 {\n        // ❌ You can run into issues if you can hooks inside other expressions inside your component\n        // If number changes from 0 to 1, the order of the hooks will be different and your app may panic\n        let string = use_signal(|| \"hello world\".to_string());\n    }\n\n    todo!()\n}\n\nfn use_my_hook() -> Signal<i32> {\n    // ✅ You can call hooks from the body of other hooks\n    let number = use_signal(|| 1);\n    // ❌ Again, creating hooks inside expressions inside other hooks can cause issues\n    if number() == 1 {\n        let string = use_signal(|| \"hello world\".to_string());\n    }\n\n    number\n}\n```\n\n----------------------------------------\n\nTITLE: Using use_reactive with Non-Reactive Props in Dioxus\nDESCRIPTION: This example demonstrates how to use the `use_reactive` macro to explicitly add a prop as a dependency to a reactive hook. The `use_memo` hook will re-run when the `count` prop changes.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/props.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn Counter(count: i32) -> Element {\n    // We can add the count prop as an explicit dependency to every reactive hook that uses it with use_reactive.\n    // The use_reactive macro takes a closure with explicit dependencies as its argument.\n    let doubled_count = use_memo(use_reactive!(|count| count * 2));\n    rsx! {\n        div {\n            \"Count: {count}\"\n            \"Doubled Count: {doubled_count}\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dioxus Counter App\nDESCRIPTION: This code defines a simple counter application using Dioxus. It utilizes the `use_signal` hook to manage the counter state and updates the UI with `rsx!`. The `onclick` event handlers increment or decrement the counter value.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/ko-kr/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn app() -> Element {\n    let mut count = use_signal(|| 0);\n\n    rsx! {\n        h1 { \"High-Five counter: {count}\" }\n        button { onclick: move |_| count += 1, \"Up high!\" }\n        button { onclick: move |_| count -= 1, \"Down low!\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic hook with `use_signal` in Rust\nDESCRIPTION: This code snippet shows how to use hooks to define the state and modify it from within listeners. It uses the `use_signal` hook to create and manage a state variable within a component. It initializes a name state with a default value of \"world\" and displays it.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/dioxus-lib/README.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[component]\nfn App() -> Element {\n    let name = use_signal(|| \"world\");\n\n    rsx! { \"hello {name}!\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Button Component in Dioxus\nDESCRIPTION: This snippet defines a custom `Button` component in Dioxus. It uses the `#[props(extends = ...)]` macro to inherit both global HTML attributes and button-specific attributes. The component renders a standard HTML button with the provided attributes.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/component.md#_snippet_13\n\nLANGUAGE: Rust\nCODE:\n```\n#[component]\nfn Button(\n    #[props(extends = GlobalAttributes, extends = button)]\n    attributes: Vec<Attribute>,\n) -> Element {\n    rsx! {\n        button { ..attributes, \"button\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using use_server_future in Dioxus\nDESCRIPTION: This code demonstrates how to use the `use_server_future` hook in a Dioxus component to fetch data on the server and display it on the client. It defines an async function `fetch_article` that simulates fetching an article. `use_server_future` then executes this function on the server, serializes the result, and sends it to the client for rendering. The suspense is bubbled up, causing the server to wait for the future to resolve before rendering.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/fullstack-hooks/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\nasync fn fetch_article(id: u32) -> String {\n    format!(\"Article {}\", id)\n}\n\nfn App() -> Element {\n    let mut article_id = use_signal(|| 0);\n    // `use_server_future` will spawn a task that runs on the server and serializes the result to send to the client.\n    // The future will rerun any time the\n    // Since we bubble up the suspense with `?`, the server will wait for the future to resolve before rendering\n    let article = use_server_future(move || fetch_article(article_id()))?;\n\n    rsx! {\n        \"{article().unwrap()}\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Making Non-Reactive State Reactive in Dioxus (Rust)\nDESCRIPTION: This snippet demonstrates how to use the `use_reactive` hook to make non-reactive state reactive within a Dioxus component, allowing computed values to stay up-to-date with changes to the underlying state.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core/docs/reactivity.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\n\nlet state = rand::random::<i32>();\n\n// You can make the state reactive by wrapping it in use_reactive\nlet doubled = use_memo(use_reactive!(|state| state * 2));\n```\n\n----------------------------------------\n\nTITLE: Basic Counter App in Dioxus with Rust\nDESCRIPTION: This code defines a simple counter application using Dioxus. It utilizes the `use_signal` hook for state management, allowing the counter value to be updated. The `rsx!` macro defines the UI, which includes a heading displaying the counter value and two buttons to increment and decrement it.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/fa-ir/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn app() -> Element {\n    let mut count = use_signal(|| 0);\n\n    rsx! {\n        h1 { \"High-Five counter: {count}\" }\n        button { onclick: move |_| count += 1, \"Up high!\" }\n        button { onclick: move |_| count -= 1, \"Down low!\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Signal Panics with Blocks and `with_*` Methods in Dioxus\nDESCRIPTION: This code demonstrates how to avoid panics related to overlapping reads and writes in Dioxus signals by using blocks and `with_*` methods. These techniques ensure that reads are dropped before writes occur. The `use dioxus::prelude::*;` is a necessary import.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/signals/docs/signals.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nlet mut signal = use_signal(|| 0);\n{\n    // Since this read is inside a block that ends before we write to the signal, the signal will be dropped before the write and it will not panic\n    let read = signal.read();\n    println!(\"{}\", read);\n}\nsignal += 1;\n\n// Or you can use the with and with_write methods which only read or write to the signal inside the closure\nsignal.with(|read| println!(\"{}\", read));\n// Since the read only lasts as long as the closure, this will not panic\nsignal.with_mut(|write| *write += 1);\n```\n\n----------------------------------------\n\nTITLE: Non-Reactive State Handling in Dioxus (Rust)\nDESCRIPTION: This example highlights the difference between reactive and non-reactive state in Dioxus. It shows how using plain Rust types or `RefCell` without `use_signal` can lead to stale data and how to properly use `use_signal` and `ReadOnlySignal` for reactive props to ensure components update correctly.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core/docs/reactivity.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\n\n// ❌ Don't create non-reactive state\nlet state = use_hook(|| std::cell::RefCell::new(0));\n\n// Computed values will get out of date if the state they depend on is not reactive\nlet doubled = use_memo(move || *state.borrow() * 2);\n\n// ✅ Create reactive state\nlet state = use_signal(|| 0);\n\n// Computed values will automatically keep up to date with the latest reactive state\nlet doubled = use_memo(move || state() * 2);\n\n// ❌ Don't depend on non-reactive prop state in memos/resources\n#[component]\nfn MyComponent(state: i32) -> Element {\n    let doubled = use_memo(move || state * 2);\n    todo!()\n}\n\n// ✅ Wrap your props in ReadOnlySignal to make them reactive\n#[component]\nfn MyReactiveComponent(state: ReadOnlySignal<i32>) -> Element {\n    let doubled = use_memo(move || state() * 2);\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering RSX! Nodes to HTML\nDESCRIPTION: This snippet demonstrates how to render rsx! nodes to HTML using `dioxus_ssr::render_element`. The example creates a div with a loop that outputs \"Number: {i}\" for i in range 0..5. This rendered HTML is then stored in the content variable.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/ssr/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nlet content = dioxus_ssr::render_element(rsx!{\n    div {\n        for i in 0..5 {\n            \"Number: {i}\"\n        }\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Iterating with For Loops in Dioxus with rsx!\nDESCRIPTION: Shows how to use for loops to iterate over a collection of items and render them within a Dioxus component using the rsx! macro. The for loop body is parsed as rsx markup. Requires the dioxus prelude.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/rsx.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nlet numbers = vec![1, 2, 3];\nrsx! {\n    for number in numbers {\n        div {\n            \"{number}\"\n        }\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Dioxus Fullstack Example\nDESCRIPTION: This snippet demonstrates a basic Dioxus fullstack application with a server function. It defines a component that displays a value fetched from a server function when a button is clicked. The `server` attribute marks the `get_meaning` function as a server function, allowing it to be called from the client.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/fullstack/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(non_snake_case)]\nuse dioxus::prelude::*;\n\nfn main() {\n    dioxus::launch(App);\n}\n\n#[component]\nfn App() -> Element {\n    let mut meaning = use_signal(|| None);\n\n    rsx! {\n        h1 { \"Meaning of life: {meaning:?}\" }\n        button {\n            onclick: move |_| async move {\n                if let Ok(data) = get_meaning(\"life the universe and everything\".into()).await {\n                    meaning.set(data);\n                }\n            },\n            \"Run a server function\"\n        }\n    }\n}\n\n#[server]\nasync fn get_meaning(of: String) -> Result<Option<u32>, ServerFnError> {\n    Ok(of.contains(\"life\").then(|| 42))\n}\n\n```\n\n----------------------------------------\n\nTITLE: `use_resource` with Non-Reactive Dependencies in Dioxus\nDESCRIPTION: This code shows how to use `use_resource` with non-reactive dependencies using `use_reactive`. It demonstrates manually adding a dependency to the resource's rerun logic. It also shows how to use it with reactive props without needing `use_reactive`.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/use_resource.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n# async fn sleep(delay: u32) {}\n#[component]\nfn Comp(count: u32) -> Element {\n    // We manually add the resource to the dependencies list with the `use_reactive` hook\n    // Any time `count` changes, the resource will rerun\n    let new_count = use_resource(use_reactive!(|(count,)| async move {\n        sleep(100).await;\n        count + 1\n    }));\n    rsx! { \"{new_count:?}\" }\n}\n\n// If your value is already reactive, you never need to call `use_reactive` manually\n// Instead of manually adding count to the dependencies list, you can make your prop reactive by wrapping it in `ReadOnlySignal`\n#[component]\nfn ReactiveComp(count: ReadOnlySignal<u32>) -> Element {\n    // Because `count` is reactive, the resource knows to rerun when `count` changes automatically\n    let new_count = use_resource(move || async move {\n        sleep(100).await;\n        count() + 1\n    });\n    rsx! { \"{new_count:?}\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Elements with rsx! in Dioxus\nDESCRIPTION: Demonstrates how to render basic HTML elements using the rsx! macro in Dioxus. This includes defining nested divs using the JSX-style syntax. It requires the dioxus prelude.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/rsx.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nrsx! {\n    div {\n        div {}\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Event Handler in Dioxus (Rust)\nDESCRIPTION: This snippet demonstrates a basic event handler in Dioxus that reacts to a button click event. It takes a closure with the signature `fn(Event)` and prints event data to the console.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/html/docs/event_handlers.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\n\nfn App() -> Element {\n    rsx! {\n        button {\n            // The `onclick` event accepts a closure with the signature `fn(Event)`\n            onclick: |event_data| println!(\"clicked! I got the event data: {event_data:?}\"),\n            \"Click me\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dioxus Component Extending Global Attributes (Rust)\nDESCRIPTION: This example demonstrates how to extend props with global attributes using the `extends` attribute.  This allows passing common HTML attributes directly to the component.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/component.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn Card(\n    // You can use the `extends` attribute on a field with the type `Vec<Attribute>` to extend the props with all the attributes from an element or the global element attributes.\n    #[props(extends = GlobalAttributes)]\n    attributes: Vec<Attribute>,\n) -> Element {\n    rsx! {\n        // Instead of copying over every single attribute, we can just spread the attributes from the props into the element.\n        div { ..attributes, \"card\" }\n    }\n}\n\nrsx! {\n    // Since we extend global attributes, you can use any attribute that would normally appear on elements.\n    Card {\n        width: \"10px\",\n        height: \"10px\",\n        color: \"red\",\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Adding Attributes to Elements in Dioxus with rsx!\nDESCRIPTION: Demonstrates how to add attributes to HTML elements using the rsx! macro in Dioxus. It shows setting attributes with string literals and using the format macro to interpolate values. Requires the dioxus prelude.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/rsx.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nlet width = 100;\nrsx! {\n    div {\n        // Set the class attribute to \"my-class\"\n        class: \"my-class\",\n        // attribute strings are automatically formatted with the format macro\n        width: \"{width}px\",\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Card Component with Global Attribute Extension in Dioxus\nDESCRIPTION: This code defines a `Card` component that extends its properties with global HTML attributes using the `#[props(extends = GlobalAttributes)]` attribute. The `attributes` field of the `CardProps` struct will contain all the global HTML attributes, which can then be spread onto the `div` element within the component's `rsx!` macro.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/props.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[derive(Props, PartialEq, Clone)]\nstruct CardProps {\n    /// You can use the `extends` attribute on a field with the type `Vec<Attribute>` to extend the props with all the attributes from an element or the global element attributes.\n    #[props(extends = GlobalAttributes)]\n    attributes: Vec<Attribute>,\n}\n\n#[component]\nfn Card(props: CardProps) -> Element {\n    rsx! {\n        // Instead of copying over every single attribute, we can just spread the attributes from the props into the element.\n        div { ..props.attributes, \"card\" }\n    }\n}\n\nrsx! {\n    // Since we extend global attributes, you can use any attribute that would normally appear on elements.\n    Card {\n        width: \"10px\",\n        height: \"10px\",\n        color: \"red\",\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Dioxus Component with Hooks - Rust\nDESCRIPTION: This example component showcases the correct usage of hooks in a Dioxus component. It demonstrates how hooks are run in the order they are defined and how the state is stored in the component in a list. The example uses `use_signal` and `use_memo` from Dioxus.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/rules_of_hooks.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nfn App() -> Element {\n    let number = use_signal(|| 1); // Hook 1\n    let string = use_signal(|| \"hello world\".to_string()); // Hook 2\n    let doubled = use_memo(move || number() * 2); // Hook 3\n\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Printing HTML Request Info in Dioxus Component (SSR)\nDESCRIPTION: This snippet demonstrates how to access request headers during server-side rendering (SSR) within a Dioxus component. The `server_context()` function is used to retrieve the request context, and `request_parts().headers` provides access to the request headers. This code is conditionally compiled using `server_only!` to ensure it only runs on the server.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/fullstack/docs/request_origin.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn PrintHtmlRequestInfo() -> Element {\n    // The server context only exists on the server, so we need to put it behind a server_only! config\n    server_only! {\n        // Since we are calling this from a component, the server context that is returned will be from\n        // the html request for ssr rendering\n        let context = server_context();\n        let request_parts = context.request_parts();\n        println!(\"headers are {:?}\", request_parts.headers);\n    }\n    rsx! {}\n}\n```\n\n----------------------------------------\n\nTITLE: Dioxus Component with Reactive Props (Rust)\nDESCRIPTION: This example demonstrates how Dioxus reruns components when props change. The `Counter` component updates when the `count` prop changes.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/component.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn Counter(count: i32) -> Element {\n    rsx! {\n        div {\n            \"Count: {count}\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Global State Management in Dioxus (Rust)\nDESCRIPTION: Shows how to use a static GlobalSignal to share state across the entire Dioxus application. A COUNT variable is defined as a static. The IncrementButton component increments this global count directly without props or context. This approach is ergonomic for truly global state, but not recommended for reusable components needing isolated state.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/moving_state_around.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n// Count will be created the first time you access it with the closure you pass to Signal::global\nstatic COUNT: GlobalSignal<i32> = Signal::global(|| 0);\n\nfn ParentComponent() -> Element {\n    rsx! {\n        IncrementButton {}\n    }\n}\n\nfn IncrementButton() -> Element {\n    rsx! {\n        button {\n            // You don't need to pass anything around or get anything out of the context because COUNT is global\n            onclick: move |_| *COUNT.write() += 1,\n            \"Increment\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Signal Helper Methods in Dioxus\nDESCRIPTION: This example showcases using helper methods provided by Dioxus signals, like calling the signal as a function to clone the value, directly displaying it, and accessing vector methods. It requires `use dioxus::prelude::*;` and demonstrates common use cases for simplifying signal interaction.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/signals/docs/signals.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nlet mut signal = use_signal(|| 0);\n// This will clone the value\nlet clone: i32 = signal();\n\n// You can directly display the signal\nprintln!(\"{}\", signal);\n\nlet signal_vec = use_signal(|| vec![1, 2, 3]);\n// And use vec methods like .get and .len without reading the signal explicitly\nlet first = signal_vec.get(0);\nlet last = signal_vec.last();\nlet len = signal_vec.len();\n\n// You can also iterate over signals directly\nfor i in signal_vec.iter() {\n    println!(\"{}\", i);\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Web Components with rsx! in Dioxus\nDESCRIPTION: Shows how to render web components (elements with a hyphen in their name) in Dioxus using the rsx! macro.  Dioxus automatically renders such elements as untyped web components. It requires the dioxus prelude.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/rsx.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nrsx! {\n    div-component {\n        div {}\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Dioxus Component with Required Optional Props (Rust)\nDESCRIPTION: This example uses the `!optional` attribute to make an `Option<T>` field required.  The `text` prop is an `Option<String>`, but the `!optional` attribute requires it to be specified when using the component.  Omitting it will result in an error.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/component.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn Button(\n    // You can use the `!optional` attribute on a field with the type `Option<T>` to make it required.\n    #[props(!optional)]\n    text: Option<String>,\n) -> Element {\n    rsx! {\n        button { {text.unwrap_or(\"button\".to_string())} }\n    }\n}\n\nrsx! {\n    Button {\n        text: None\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Basic `use_resource` Usage in Dioxus\nDESCRIPTION: This example shows the basic usage of `use_resource` to fetch weather data reactively based on a `WeatherLocation` signal. It demonstrates how the UI updates based on the resource's state (loading, success, or error).\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/use_resource.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\n\nasync fn get_weather(location: &WeatherLocation) -> Result<String, String> {\n    Ok(\"Sunny\".to_string())\n}\n\nfn app() -> Element {\n    let country = use_signal(|| WeatherLocation {\n        city: \"Berlin\".to_string(),\n        country: \"Germany\".to_string(),\n        coordinates: (52.5244, 13.4105),\n    });\n\n    // Because the resource's future subscribes to `country` by reading it (`country.read()`),\n    // every time `country` changes the resource's future will run again and thus provide a new value.\n    let current_weather = use_resource(move || async move { get_weather(&country()).await });\n\n    rsx! {\n        // the value of the resource can be polled to\n        // conditionally render elements based off if it's future\n        // finished (Some(Ok(_)), errored Some(Err(_)),\n        // or is still running (None)\n        match &*current_weather.read_unchecked() {\n            Some(Ok(weather)) => rsx! { WeatherElement { weather } },\n            Some(Err(e)) => rsx! { p { \"Loading weather failed, {e}\" } },\n            None =>  rsx! { p { \"Loading...\" } }\n        }\n    }\n}\n\n#[derive(Clone)]\nstruct WeatherLocation {\n    city: String,\n    country: String,\n    coordinates: (f64, f64),\n}\n\n#[component]\nfn WeatherElement(weather: String) -> Element {\n    rsx! { p { \"The weather is {weather}\" } }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering a VirtualDom\nDESCRIPTION: This snippet demonstrates how to render a VirtualDom instance to HTML using the `dioxus_ssr::render` function. It creates a VirtualDom, rebuilds it in place, and then renders it to a string.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/ssr/README.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n# fn app() -> Element { todo!() }\nlet mut vdom = VirtualDom::new(app);\nvdom.rebuild_in_place();\n\nlet content = dioxus_ssr::render(&vdom);\n```\n\n----------------------------------------\n\nTITLE: Dioxus useEffect Example\nDESCRIPTION: This example demonstrates how to use the `use_effect` hook to manually update the DOM after the component has finished rendering. It uses a signal to track a count and updates a canvas element with the current count value. The effect reruns whenever the count signal changes.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/side_effects.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nfn MyComponent() -> Element {\n    let mut count = use_signal(|| 0);\n\n    use_effect(move || {\n        // Effects are reactive like memos, and resources. If you read a value inside the effect, the effect will rerun when that value changes\n        let count = count.read();\n\n        // You can use the count value to update the DOM manually\n        document::eval(&format!(\n            r#\"var c = document.getElementById(\"dioxus-canvas\");\nvar ctx = c.getContext(\"2d\");\nctx.font = \"30px Arial\";\nctx.fillText(\"{count}\", 10, 50);\"#\n        ));\n    });\n\n    rsx! {\n        button {\n            // When you click the button, count will be incremented and the effect will rerun\n            onclick: move |_| count += 1,\n            \"Increment\"\n        }\n        canvas {\n            id: \"dioxus-canvas\",\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Axum Integration with Dioxus\nDESCRIPTION: This snippet demonstrates how to integrate Dioxus with the Axum web framework. It shows how to create an Axum router, add a Dioxus application to it using the `serve_dioxus_application` method, and start the server. It includes conditional compilation based on the `server` feature flag, so that the server code is only included when building for the server.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/fullstack/README.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(non_snake_case)]\nuse dioxus::prelude::*;\n\n// The entry point for the server\n#[cfg(feature = \"server\")]\n#[tokio::main]\nasync fn main() {\n    // Get the address the server should run on. If the CLI is running, the CLI proxies fullstack into the main address\n    // and we use the generated address the CLI gives us\n    let address = dioxus::cli_config::fullstack_address_or_localhost();\n\n    // Set up the axum router\n    let router = axum::Router::new()\n        // You can add a dioxus application to the router with the `serve_dioxus_application` method\n        // This will add a fallback route to the router that will serve your component and server functions\n        .serve_dioxus_application(ServeConfigBuilder::default(), App);\n\n    // Finally, we can launch the server\n    let router = router.into_make_service();\n    let listener = tokio::net::TcpListener::bind(address).await.unwrap();\n    axum::serve(listener, router).await.unwrap();\n}\n\n// For any other platform, we just launch the app\n#[cfg(not(feature = \"server\"))]\nfn main() {\n    dioxus::launch(App);\n}\n\n#[component]\nfn App() -> Element {\n    let mut meaning = use_signal(|| None);\n\n    rsx! {\n        h1 { \"Meaning of life: {meaning:?}\" }\n        button {\n            onclick: move |_| async move {\n                if let Ok(data) = get_meaning(\"life the universe and everything\".into()).await {\n                    meaning.set(data);\n                }\n            },\n            \"Run a server function\"\n        }\n    }\n}\n\n#[server]\nasync fn get_meaning(of: String) -> Result<Option<u32>, ServerFnError> {\n    Ok(of.contains(\"life\").then(|| 42))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Fixing 'argument type to outlive 'static' Error in Dioxus with `move`\nDESCRIPTION: This snippet demonstrates the correct way to handle data within Dioxus event handlers to resolve lifetime issues.  By using the `move` keyword, the code transfers ownership of the `state` signal into the closure, resolving the original error related to the signal being dropped before the event handler could access it.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/html/docs/common_event_handler_errors.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nfn App() -> Element {\n    let state = use_signal(|| \"hello world\".to_string());\n\n    rsx! {\n        button {\n            // ✅ The `move` keyword tells rust it can move the `state` signal into the closure. Since the closure owns the signal state, it can read it even after the function returns\n            onclick: move |_| {\n                println!(\"You clicked the button! The state is: {state}\");\n            },\n            \"Click me\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Including Text in Dioxus Components with rsx!\nDESCRIPTION: Shows how to include text within components in Dioxus using string literals. It also demonstrates how to embed formatted segments inside text using string interpolation. Requires the dioxus prelude.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/rsx.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nlet name = \"World\";\nrsx! {\n    div {\n        \"Hello World\"\n        // Just like attributes, you can included formatted segments inside your text\n        \"Hello {name}\"\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Fixing 'use of moved value' using `ReadOnlySignal` in Dioxus\nDESCRIPTION: This snippet showcases one approach to fix the 'use of moved value' error by utilizing `ReadOnlySignal`, which implements the `Copy` trait. This allows the value to be copied into multiple closures without transferring ownership, thus avoiding the error.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/html/docs/common_event_handler_errors.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n// `MyComponent` accepts `ReadOnlySignal<String>` which implements `Copy`\n#[component]\nfn MyComponent(string: ReadOnlySignal<String>) -> Element {\n    rsx! {\n        button {\n            // ✅ Because the `string` signal is `Copy`, we can copy it into the closure while still having access to it elsewhere\n            onclick: move |_| println!(\"{}\", string),\n            \"Print hello world\"\n        }\n        button {\n            // ✅ Since `string` is `Copy`, we can move it into the onclick handler again\n            onclick: move |_| println!(\"{}\", string),\n            \"Print hello world again\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initialize New Dioxus Project\nDESCRIPTION: Initializes a new Dioxus project using the `dx new` command. It clones from the dioxus-template repository by default.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/cli/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ndx new --template gh:dioxuslabs/dioxus-template\n```\n\n----------------------------------------\n\nTITLE: Using Formatted String Props in Dioxus\nDESCRIPTION: This example demonstrates how to use formatted strings for props with the type `String`. You can use placeholders in the prop value, which will be replaced with the corresponding variables at runtime.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/props.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[derive(Props, PartialEq, Clone)]\nstruct ButtonProps {\n    text: String,\n}\n\nfn Button(props: ButtonProps) -> Element {\n    rsx! {\n        button { \"{props.text}\" }\n    }\n}\n\nlet name = \"Bob\";\nrsx! {\n    Button {\n        // You can use formatted strings in props that accept String just like you would in an element.\n        text: \"Hello {name}!\"\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Interacting with DOM using Eval and useEffect in Dioxus\nDESCRIPTION: This example shows how to interact with the DOM using the `eval` function within the `use_effect` hook in Dioxus.  It demonstrates modifying the inner HTML of an element and retrieving an attribute. The `use_effect` hook ensures that the JavaScript code is executed after the component has been mounted. It requires the `dioxus` crate.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/document/docs/eval.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\n\nconst SCRIPT: &str = r#\"\n    let element = document.getElementById(\"my-element\");\n    element.innerHTML = \"Hello World\";\n    return element.getAttribute(\"data-count\");\n\"#;\n\nfn app() -> Element {\n    // ❌ You shouldn't run eval in the body of a component. This will run before the component has been mounted\n    // document::eval(SCRIPT);\n\n    // ✅ You should run eval inside an effect or event. This will run after the component has been mounted\n    use_effect(move || {\n        spawn(async {\n            let count = document::eval(SCRIPT).await;\n            println!(\"Count is {:?}\", count);\n        });\n    });\n\n\n    rsx! {\n        div {\n            id: \"my-element\",\n            \"data-count\": \"123\",\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Namespaces with rsx! Macro in Dioxus\nDESCRIPTION: This code snippet demonstrates how to use a custom namespace with the `rsx!` macro in Dioxus. It assumes a module `ar_namespace` is defined with custom components like `magic_div`, `magic_header`, and `magic_paragraph`. The `on_magic_click` event handler is attached to the `magic_paragraph` element.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/html/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse ar_namespace::*;\n\nrsx! {\n    magic_div {\n        magic_header {}\n        magic_paragraph {\n            on_magic_click: move |event| {\n                //\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapping Web Components in Custom Components in Dioxus\nDESCRIPTION: Illustrates how to wrap a web component inside a custom component to add type checking when using Dioxus.  It defines a functional component that renders a web component with a type-checked property.  Requires the dioxus prelude.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/rsx.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn MyDivComponent(width: i64) -> Element {\n    rsx! {\n        div-component {\n            \"width\": width\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering a simple Component with `rsx!` in Rust\nDESCRIPTION: This code shows how a simple component can be created using `rsx!` macro to generate the element that the component returns. The `#[component]` macro is used to define functional components in Dioxus, simplifying the process of creating UI elements from Rust code.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/dioxus-lib/README.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[component]\nfn Example() -> Element {\n    rsx!{ \"hello world\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Passing Signals Up the Component Tree in Dioxus\nDESCRIPTION: This example illustrates a potential pitfall in Dioxus: passing signals from child components to parent components. The snippet demonstrates a scenario where dropping the child component leads to issues with the signal owned by the child. This requires importing `dioxus::prelude`.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/signals/docs/signals.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nfn MyComponent() -> Element {\n    let child_signal = use_signal(|| None);\n\n    rsx! {\n        IncrementButton {\n            child_signal\n        }\n    }\n}\n\n#[component]\nfn IncrementButton(mut child_signal: Signal<Option<Signal<i32>>>) -> Element {\n    let signal_owned_by_child = use_signal(|| 0);\n    // Don't do this: it may cause issues if you drop the child component\n    child_signal.set(Some(signal_owned_by_child));\n\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Dioxus Router Example in Rust\nDESCRIPTION: This snippet demonstrates the basic usage of the Dioxus Router. It defines a `Route` enum with nested routes and layout, creates components for different pages, and uses the `Router` component to handle navigation. Dependencies include `dioxus` and `dioxus_router`. Note that rustfmt is skipped for the Route enum for better readability.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/router/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\nuse dioxus_router::prelude::*;\nuse std::str::FromStr;\n\n#[rustfmt::skip]\n#[derive(Clone, Debug, PartialEq, Routable)]\nenum Route {\n    #[nest(\"/blog\")]\n        #[layout(Blog)]\n            #[route(\"/\")]\n            BlogList {},\n\n            #[route(\"/:blog_id\")]\n            BlogPost { blog_id: usize },\n        #[end_layout]\n    #[end_nest]\n    #[route(\"/\")]\n    Index {},\n}\n\n#[component]\nfn App() -> Element {\n    rsx! {\n        Router::<Route> { }\n    }\n}\n\n#[component]\nfn Index() -> Element {\n    rsx! {\n        h1 { \"Index\" }\n        Link {\n            to: Route::BlogList {},\n            \"Go to the blog\"\n        }\n    }\n}\n\n#[component]\nfn Blog() -> Element {\n    rsx! {\n        h1 { \"Blog\" }\n        Outlet::<Route> { }\n    }\n}\n\n#[component]\nfn BlogList() -> Element {\n    rsx! {\n        h2 { \"List of blog posts\" }\n        Link {\n            to: Route::BlogPost { blog_id: 0 },\n            \"Blog post 1\"\n        }\n        Link {\n            to: Route::BlogPost { blog_id: 1 },\n            \"Blog post 2\"\n        }\n    }\n}\n\n#[component]\nfn BlogPost(blog_id: usize) -> Element {\n    rsx! {\n        h2 { \"Blog Post\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Project Structure Overview\nDESCRIPTION: This provides the structure of the Dioxus PWA project including configuration, HTML, service worker, manifest, and rust source code. This structure outlines how custom HTML is used for loading the SW and manifest.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/examples/pwa/README.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n├── Cargo.toml\n├── Dioxus.toml\n├── index.html // Custom HTML is needed for this, to load the SW and manifest.\n├── LICENSE\n├── public\n│   ├── favicon.ico\n│   ├── logo_192.png\n│   ├── logo_512.png\n│   ├── manifest.json // The manifest file - edit this as you need to.\n│   └── sw.js // The service worker - you must edit this for actual projects.\n├── README.md\n└── src\n    └── main.rs\n```\n\n----------------------------------------\n\nTITLE: Executing JavaScript with Eval in Dioxus\nDESCRIPTION: This snippet demonstrates how to execute JavaScript code using the `eval` function within a Dioxus application. It shows how to log a message to the console and return a value from JavaScript, which can then be awaited in Rust.  It requires the `dioxus` crate.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/document/docs/eval.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\n\nfn App() -> Element {\n    rsx! {\n        button {\n            onclick: move |_| async move {\n                // Eval is a global function you can use anywhere inside Dioxus. It will execute the given JavaScript code.\n                let result = document::eval(r#\"console.log(\"Hello World\");\n                return \"Hello World\";\"#);\n\n                // You can use the `await` keyword to wait for the result of the JavaScript code.\n                println!(\"{:?}\", result.await);\n            },\n            \"Log Hello World\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Axum Dependencies\nDESCRIPTION: This TOML snippet shows how to configure the dependencies for a Dioxus fullstack application that integrates with Axum. It makes the `axum` and `tokio` dependencies optional and enables them only when the `server` feature is enabled. This prevents compile errors when building for the web.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/fullstack/README.md#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ndioxus = { version = \"*\", features = [\"fullstack\"] }\naxum = { version = \"0.7.0\", optional = true }\ntokio = { version = \"1.0\", features = [\"full\"], optional = true }\ndioxus-cli-config = { version = \"*\", optional = true }\n\n[features]\nserver = [\"dioxus/server\", \"dep:axum\", \"dep:tokio\", \"dioxus-cli-config\"]\nweb = [\"dioxus/web\"]\n\n```\n\n----------------------------------------\n\nTITLE: Reading Headers in Dioxus Server Function\nDESCRIPTION: This snippet shows how to access request headers within a Dioxus server function. The `server_context()` function is used to retrieve the request context, regardless of whether the request originates from the initial SSR render or a client-side call.  The `request_parts().headers` provides access to the request headers.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/fullstack/docs/request_origin.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[server]\nasync fn read_headers() -> Result<(), ServerFnError> {\n    // Since we are calling this from a server function, the server context that is may be from the\n    // initial request or a request from the client\n    let context = server_context();\n    let request_parts = context.request_parts();\n    println!(\"headers are {:?}\", request_parts.headers);\n    Ok(())\n}\n\n#[component]\nfn CallServerFunction() -> Element {\n    rsx! {\n        button {\n            // If you click the button, the server function will be called and the server context will be\n            // from the client request\n            onclick: move |_| async {\n                _ = read_headers().await\n            },\n            \"Call server function\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing moved value error in Dioxus with `clone`\nDESCRIPTION: This snippet demonstrates how to resolve the \"use of moved value\" error in Dioxus by cloning the data before moving it into an async task. This approach is used when the data does not implement the `Copy` trait. Cloning creates a new, independent copy of the data, allowing it to be moved into multiple tasks without ownership conflicts.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core/docs/common_spawn_errors.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n// `MyComponent` accepts a string which doesn't implement `Copy`\n#[component]\nfn MyComponent(string: String) -> Element {\n    use_hook(move || {\n        // ✅ The string only has one owner. We could move it into this closure, but since we want to use the string in other closures later, we will clone it instead\n        spawn({\n            // Clone the string in a new block\n            let string = string.clone();\n            // Then move the cloned string into the async block\n            async move {\n                println!(\"{}\", string);\n            }\n        });\n        // ✅ We don't use the string after this closure, so we can just move it into the closure directly\n        spawn(async move {\n            println!(\"{}\", string);\n        })\n    });\n\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Component with Props using #[component]\nDESCRIPTION: This Rust code demonstrates how to define a component with properties using the `#[component]` macro in Dioxus.  The `Header` component takes `title` and `color` as arguments, which are automatically converted into named fields in a props struct. The component renders a `div` with the specified background color and an `h1` element with the provided title.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/dioxus/README.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\n# use dioxus::prelude::*;\n// The component macro turns the arguments for our function into named fields we can pass in to the component in rsx\n#[component]\nfn Header(title: String, color: String) -> Element {\n    rsx! {\n        div {\n            background_color: \"{color}\",\n            h1 { \"{title}\" }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering a Dioxus Component to HTML\nDESCRIPTION: This snippet demonstrates how to render a simple Dioxus component to HTML using the `dioxus_ssr::render` function. It creates a VirtualDom from a component that returns a div containing \"hello world!\", rebuilds the VirtualDom, and then renders it to a string.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/ssr/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nfn app() -> Element {\n  rsx!{\n    div {\"hello world!\"}\n  }\n}\n\nlet mut vdom = VirtualDom::new(app);\nvdom.rebuild_in_place();\n\nlet text = dioxus_ssr::render(&vdom);\nassert_eq!(text, \"<div>hello world!</div>\")\n```\n\n----------------------------------------\n\nTITLE: Advanced Asset Definition with Manganis\nDESCRIPTION: This snippet demonstrates various ways to define assets using the `manganis::asset!` macro, including collecting arbitrary files, optimizing images, resizing images, and converting images to web-friendly formats.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/manganis/manganis/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse manganis::{ImageFormat, ImageAssetOptions, Asset, asset, ImageSize};\n// You can collect arbitrary files. Absolute paths are resolved relative to the package root\nconst _: Asset = asset!(\"/assets/script.js\");\n\n// You can collect images which will be automatically optimized\npub const PNG_ASSET: Asset =\n    asset!(\"/assets/image.png\");\n// Resize the image at compile time to make the assets smaller\npub const RESIZED_PNG_ASSET: Asset =\n    asset!(\"/assets/image.png\", ImageAssetOptions::new().with_size(ImageSize::Manual { width: 52, height: 52 }));\n// Or convert the image at compile time to a web friendly format\npub const AVIF_ASSET: Asset = asset!(\"/assets/image.png\", ImageAssetOptions::new().with_format(ImageFormat::Avif));\n```\n\n----------------------------------------\n\nTITLE: Passing State as Props in Dioxus (Rust)\nDESCRIPTION: Demonstrates passing a Signal<i32> state variable as a prop from a parent component (MyComponent) to a child component (IncrementButton). The child component increments the count when the button is clicked. This method is explicit and suitable when passing values isn't overly complex.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/moving_state_around.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nfn MyComponent() -> Element {\n    let count = use_signal(|| 0);\n\n    rsx! {\n        IncrementButton {\n            count\n        }\n    }\n}\n\n#[component]\nfn IncrementButton(mut count: Signal<i32>) -> Element {\n    rsx! {\n        button {\n            onclick: move |_| count += 1,\n            \"Increment\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dioxus Component with Formatted Props (Rust)\nDESCRIPTION: This example shows how to use formatted strings in props that accept `String`. The `text` prop accepts a formatted string.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/component.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn Button(text: String,) -> Element {\n    rsx! {\n        button { \"{text}\" }\n    }\n}\n\nlet name = \"Bob\";\nrsx! {\n    Button {\n        // You can use formatted strings in props that accept String just like you would in an element.\n        text: \"Hello {name}!\"\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Dioxus Logger with Tracing\nDESCRIPTION: This code snippet demonstrates how to initialize the dioxus-logger with a specified logging level (INFO) using the tracing crate. It also shows a basic Dioxus application that logs a message when rendered. The `dioxus::launch` function starts the Dioxus application.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/logger/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\nuse dioxus_logger::tracing::{Level, info};\n\nfn main() {\n  dioxus_logger::init(Level::INFO).expect(\"logger failed to init\");\n  dioxus::launch(App);\n}\n\n#[component]\nfn App() -> Element {\n  info!(\"App rendered\");\n  rsx! {\n    p { \"hi\" }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing and Using Dioxus CLI (dx)\nDESCRIPTION: This shell script demonstrates how to install the Dioxus CLI tool (`dx`) using `cargo-binstall`, create a new Dioxus application, navigate to the application directory, and start the development server. It assumes that Rust and Cargo are already installed. The script uses `cargo install cargo-binstall` to install the `cargo-binstall` tool.  It then uses `cargo binstall dioxus-cli` to install the Dioxus CLI. It generates a new project with `dx new my-app`. Finally, the `dx serve --platform desktop` command launches the application.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/dioxus/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n# skip if you already have cargo-binstall\ncargo install cargo-binstall\n\n# install the precompiled `dx` tool\ncargo binstall dioxus-cli\n\n# create a new app, following the template\ndx new my-app && cd my-app\n\n# and then serve!\ndx serve --platform desktop\n```\n\n----------------------------------------\n\nTITLE: Serialize Const Struct and Enum in Rust\nDESCRIPTION: This Rust code snippet defines a struct named 'Struct' and an enum named 'Enum', both annotated with the `SerializeConst` derive macro from the `const_serialize` crate. It then creates an array of 'Struct' instances, serializes it using `serialize_const`, deserializes it using `deserialize_const!`, and asserts that the original and deserialized data are equal using `serialize_eq`. This demonstrates the basic usage of the `const_serialize` crate for serializing and deserializing complex types in a const context.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/const-serialize/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse const_serialize::{deserialize_const, serialize_const, serialize_eq, ConstVec, SerializeConst};\n#[derive(Clone, Copy, Debug, PartialEq, SerializeConst)]\nstruct Struct {\n    a: u32,\n    b: u8,\n    c: u32,\n    d: Enum,\n}\n\n#[derive(Clone, Copy, Debug, PartialEq, SerializeConst)]\n#[repr(C, u8)]\nenum Enum {\n    A { one: u32, two: u16 },\n    B { one: u8, two: u16 } = 15,\n}\n\nconst {\n    let data = [Struct {\n        a: 0x11111111,\n        b: 0x22,\n        c: 0x33333333,\n        d: Enum::A {\n            one: 0x44444444,\n            two: 0x5555,\n        },\n    }; 3];\n    let mut buf = ConstVec::new();\n    buf = serialize_const(&data, buf);\n    let buf = buf.read();\n    let (buf, deserialized) = match deserialize_const!([Struct; 3], buf) {\n        Some(data) => data,\n        None => panic!(\"data mismatch\"),\n    };\n    if !serialize_eq(&data, &deserialized) {\n        panic!(\"data mismatch\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fullstack Rendering with Head Components and Suspense - Rust\nDESCRIPTION: This example showcases fullstack rendering with Dioxus, emphasizing that only head components rendered before suspense boundaries resolve are included in the server-side rendering.  It demonstrates rendering a title that will be rendered server-side, and a meta tag that will only be rendered client-side.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/document/docs/head.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn App() -> Element {\n    rsx! {\n        // This will render in SSR\n        document::Title { \"My Page\" }\n        SuspenseBoundary {\n            fallback: |_| rsx! { \"Loading...\" },\n            LoadData {\n                // This will only be rendered on the client after hydration so it may not be visible to search engines\n                document::Meta { name: \"description\", content: \"My Page\" }\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Hook Usage in Event Handlers - Rust\nDESCRIPTION: This code snippet presents another common mistake when using hooks: calling them within event handlers. Calling hooks in event handlers will change the order of the hooks which breaks the rules of hooks.  This violates the rule that hooks must execute in a consistent order each time the component renders. The example makes use of `rsx!` and `use_signal` from Dioxus.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/rules_of_hooks.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nfn App() -> Element {\n    rsx! {\n        button {\n            onclick: move |_| {\n                // ❌ Calling the event handler will change the order of the hooks\n                use_signal(|| \"hello world\".to_string());\n            },\n            \"Click me\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Context API with Dioxus Signals in Rust\nDESCRIPTION: Shows how Dioxus Signals can be shared through the context API. The signal is provided by a parent component that does not read from it, and read in a child component. Only the child component will rerun when the signal is changed.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/signals/README.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\nuse dioxus_signals::*;\n\n#[component]\nfn App() -> Element {\n    // Because signal is never read in this component, this component will not rerun when the signal changes\n    use_context_provider(|| Signal::new(0));\n\n    rsx! {\n        Child {}\n    }\n}\n\n#[component]\nfn Child() -> Element {\n    let signal: Signal<i32> = use_context();\n    // This component does read from the signal, so when the signal changes it will rerun\n    rsx! {\n        \"{signal}\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Dioxus file explorer example\nDESCRIPTION: This code snippet shows the command used to run the file explorer example. It utilizes the `dx serve` command, which is part of the Dioxus CLI toolchain. This command typically compiles and serves the Dioxus application for development and testing purposes.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/example-projects/file-explorer/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ndx serve\n```\n\n----------------------------------------\n\nTITLE: Initializing Dioxus Desktop Application\nDESCRIPTION: This Rust code snippet demonstrates the basic setup for a Dioxus Desktop application. It imports the necessary Dioxus prelude, defines a main function that launches the application using `dioxus_desktop::launch` and a simple app component returning 'hello world!' within a div.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/desktop/src/readme.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// main.rs\nuse dioxus::prelude::*;\n\nfn main() {\n    dioxus_desktop::launch(app);\n}\n\nfn app() -> Element {\n    rsx! {\n        div {\n            \"hello world!\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Memos with Async - Potential Panic\nDESCRIPTION: This snippet illustrates the potential for panics when reading memos inside async code due to holding reads over await points. It advises against holding reads over await points when using `use_memo`. Dependencies: `dioxus::prelude::*`.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/signals/docs/memo.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n# async fn sleep(delay: u32) {}\nasync fn double_me_async(value: &u32) -> u32 {\n    sleep(100).await;\n    *value * 2\n}\nlet mut signal = use_signal(|| 0);\nlet halved = use_memo(move || signal() / 2);\n\nlet doubled = use_resource(move || async move {\n    // Don't hold reads over await points\n    let halved = halved.read();\n    // While the future is waiting for the async work to finish, the read will be open\n    double_me_async(&halved).await\n});\n\nrsx!{\n    \"{doubled:?}\"\n    button {\n        onclick: move |_| {\n            // When you write to signal, it will cause the memo to rerun which may panic because you are holding a read of the memo over an await point\n            signal += 1;\n        },\n        \"Increment\"\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Extending Dioxus Elements with a Custom Module\nDESCRIPTION: This code snippet shows how to extend the default Dioxus elements by creating a custom `dioxus_elements` module. It re-exports the existing HTML elements from `dioxus::prelude::dioxus_elements::*` and then defines a new custom element `my_element` by implementing the `DioxusElement` trait.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/html/README.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nmod dioxus_elements {\n    use dioxus::prelude::dioxus_elements::*;\n    struct my_element;\n    impl DioxusElement for my_element {\n        const TAG_NAME: &'static str = \"base\";\n        const NAME_SPACE: Option<&'static str> = None;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing 'use of moved value' by Cloning in Dioxus\nDESCRIPTION: This snippet presents an alternative solution to the 'use of moved value' error by cloning the data before moving it into the closure. It allows multiple closures to access a copy of the data without conflicting ownership issues. This is useful when using a `String` directly instead of a `ReadOnlySignal`.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/html/docs/common_event_handler_errors.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n// `MyComponent` accepts a string which doesn't implement `Copy`\n#[component]\nfn MyComponent(string: String) -> Element {\n    rsx! {\n        button {\n            // ✅ The string only has one owner. We could move it into this closure, but since we want to use the string in other closures later, we will clone it instead\n            onclick: {\n                // Clone the string in a new block\n                let string = string.clone();\n                // Then move the cloned string into the closure\n                move |_| println!(\"{}\", string)\n            },\n            \"Print hello world\"\n        }\n        button {\n            // ✅ We don't use the string after this closure, so we can just move it into the closure directly\n            onclick: move |_| println!(\"{}\", string),\n            \"Print hello world again\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Memos like Signals in Dioxus\nDESCRIPTION: This snippet shows how to call a memo like a function to clone its inner value.  It creates two memos: one that halves a count signal and another that doubles the first memo's value. Dependencies: `dioxus::prelude::*`.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/signals/docs/memo.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n\nfn app() -> Element {\n    let mut count = use_signal(|| 0);\n    // The memo will rerun any time we write to the count signal\n    let halved = use_memo(move || count() / 2);\n    // This will rerun any time the halved value changes\n    let doubled = use_memo(move || 2 * halved());\n\n    rsx! {\n        \"{doubled}\"\n        button {\n            onclick: move |_| {\n                count += 1;\n            },\n            \"Increment\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pre-rendering with Hydration\nDESCRIPTION: This snippet demonstrates how to enable pre-rendering with hydration. It creates a VirtualDom, enables pre-rendering using the `pre_render` flag of the `dioxus_ssr::Renderer`, and renders the VirtualDom to a string.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/ssr/README.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n# fn App() -> Element { todo!() }\nlet mut vdom = VirtualDom::new(App);\n\nvdom.rebuild_in_place();\n\nlet mut renderer = dioxus_ssr::Renderer::new();\nrenderer.pre_render = true;\n\nlet text = renderer.render(&vdom);\n```\n\n----------------------------------------\n\nTITLE: Install Dioxus CLI (Development Build from Git)\nDESCRIPTION: Installs the latest development build of the Dioxus CLI from the git repository. This version may contain bugs and is not fully tested.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/cli/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo install --git https://github.com/DioxusLabs/dioxus dioxus-cli\n```\n\n----------------------------------------\n\nTITLE: Bundling Dioxus App with wasm-split using dx\nDESCRIPTION: This snippet demonstrates how to bundle a Dioxus application with the `wasm-split` feature using the `dx` CLI. The `dioxus-router?/wasm-split` feature flag should be used during bundling, and the `--experimental-wasm-split` flag is also required.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/router/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ndx bundle --features \"dioxus-router?/wasm-split\"  --experimental-wasm-split\n```\n\n----------------------------------------\n\nTITLE: Counters Component Implementation with Dioxus (Rust)\nDESCRIPTION: This snippet demonstrates a Counters component implemented using Dioxus. It uses signals for state management and includes functionality for adding and removing counters.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/tr-tr/README.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nfn Counters() -> Element {\n  let mut counters = use_signal(|| vec![0; initial_length]);\n\n  rsx! {\n    button { onclick: move |_| counters.push(counters.len()); \"Add Counter\" }\n    ul {\n      for idx in 0..counters.len() {\n        li {\n          button { onclick: move |_| counters[idx] += 1; \"{counters[idx]}\" }\n          button { onclick: move |_| { counters.write().remove(idx); } \"Remove\" }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Dioxus Component with use_memo and Reactive Props (Rust)\nDESCRIPTION: This example demonstrates an issue when using `use_memo` with non-reactive props. The memoized value doesn't update when the `count` prop changes.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/component.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn Counter(count: i32) -> Element {\n    // We can use a memo to calculate the doubled count. Since this memo will only be created the first time the component is run and `count` is not reactive, it will never update when `count` changes.\n    let doubled_count = use_memo(move || count * 2);\n    rsx! {\n        div {\n            \"Count: {count}\"\n            \"Doubled Count: {doubled_count}\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Reading a Memo in Dioxus\nDESCRIPTION: This snippet demonstrates how to read a memo in Dioxus using the `Readable` trait. It creates a memo that halves a count signal and displays the value, subscribing the component to the memo's changes.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/signals/docs/memo.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n\nfn app() -> Element {\n    let mut count = use_signal(|| 0);\n    // The memo will rerun any time we write to the count signal\n    let halved = use_memo(move || count() / 2);\n\n    rsx! {\n        // When we read the value of memo, the current component will subscribe to the result of the memo. It will only rerun when the result of the memo changes.\n        \"{halved}\"\n        button {\n            onclick: move |_| {\n                count += 1;\n            },\n            \"Increment\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding dioxus-fullstack-hooks dependency\nDESCRIPTION: This command adds the `dioxus-fullstack-hooks` crate as a dependency to your Rust project using cargo.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/fullstack-hooks/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo add dioxus-fullstack-hooks\n```\n\n----------------------------------------\n\nTITLE: Install Dioxus CLI (From Local Folder)\nDESCRIPTION: Installs the Dioxus CLI from a local folder. Note that building projects in debug profile might fail during development, which is currently under investigation.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/cli/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo install --path .\n```\n\n----------------------------------------\n\nTITLE: Dioxus Component with use_reactive (Rust)\nDESCRIPTION: This example demonstrates how to explicitly add a prop as a dependency to `use_memo` using `use_reactive`. This ensures that the memoized value updates when the `count` prop changes.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/component.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn Counter(count: i32) -> Element {\n    // We can add the count prop as an explicit dependency to every reactive hook that uses it with use_reactive.\n    // The use_reactive macro takes a closure with explicit dependencies as its argument.\n    let doubled_count = use_memo(use_reactive!(|count| count * 2));\n    rsx! {\n        div {\n            \"Count: {count}\"\n            \"Doubled Count: {doubled_count}\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Leptos Counter Component\nDESCRIPTION: This code shows a Leptos implementation of a similar counter component.  It uses `RwSignal` for reactive state and the `<For>` component for dynamic rendering, demonstrating Leptos's reliance on signals and specific control flow components for managing reactive updates. It showcases the leptos way of iterating through dynamic lists.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/ko-kr/README.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nfn Counters() -> impl IntoView {\n    let counters = RwSignal::new(vec![0; 10]);\n\n    view! {\n        <button on:click=move |_| counters.update(|n| n.push(n.len()))>\"Add Counter\"</button>\n        <For\n            each=move || 0..counters.with(Vec::len)\n            key=|idx| *idx\n            let:idx\n        >\n            <li>\n                <button on:click=move |_| counters.update(|n| n[idx] += 1)>\n                    {Memo::new(move |_| counters.with(|n| n[idx]))}\n                </button>\n                <button on:click=move |_| counters.update(|n| { n.remove(idx); })>\n                    \"Remove\"\n                </button>\n            </li>\n        </For>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing async block lifetime error in Dioxus with `move`\nDESCRIPTION: This snippet demonstrates how to resolve the \"async block may outlive the current function\" error by adding the `move` keyword to the async block. This ensures that the data accessed within the task is owned by the task itself and remains valid for the duration of the application's lifetime. The incorrect and corrected components are presented.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core/docs/common_spawn_errors.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\n\nfn App() -> Element {\n    let signal = use_signal(|| 0);\n\n    use_hook(move || {\n        // ❌ The task may run at any point and reads the value of the signal, but the signal is dropped at the end of the function\n        spawn(async {\n            println!(\"{}\", signal());\n        })\n    });\n\n    todo!()\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\n\nfn App() -> Element {\n    let signal = use_signal(|| 0);\n\n    use_hook(move || {\n        // ✅ The `move` keyword tells rust it can move the `state` signal into the async block. Since the async block owns the signal state, it can read it even after the function returns\n        spawn(async move {\n            println!(\"{}\", signal());\n        })\n    });\n\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Addressing 'use of moved value' Error in Dioxus\nDESCRIPTION: This snippet demonstrates the compiler error arising from attempting to move a non-`Copy` value into multiple closures. It shows a scenario where a `String` is moved into one event handler, preventing its use in subsequent event handlers.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/html/docs/common_event_handler_errors.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n// `MyComponent` accepts a string which cannot be copied implicitly\n#[component]\nfn MyComponent(string: String) -> Element {\n    rsx! {\n        button {\n            // ❌ We are moving the string into the onclick handler which means we can't access it elsewhere\n            onclick: move |_| {\n                println!(\"{string}\");\n            },\n            \"Print hello world\"\n        }\n        button {\n            // ❌ Since we already moved the string, we can't move it into the onclick handler again. This will cause a compiler error\n            onclick: move |_| {\n                println!(\"{string}\");\n            },\n            \"Print hello world again\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Raw Attributes in Dioxus with rsx!\nDESCRIPTION: Describes how to include attributes not included in the HTML spec, by using the raw attribute syntax, with the attribute name surrounded by quotes. Requires the dioxus prelude.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/rsx.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nrsx! {\n    div {\n        // Set the data-count attribute to \"1\"\n        \"data-count\": \"1\"\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Dioxus Counters Component\nDESCRIPTION: This Rust code defines a Dioxus component called `Counters` that manages a list of counters. It uses the `use_signal` hook to store the counter values and provides buttons to add and remove counters, as well as increment their values. The `rsx!` macro is used to define the UI structure, including buttons and a list of counters.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/fa-ir/README.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nfn Counters() -> Element {\n  let mut counters = use_signal(|| vec![0; initial_length]);\n\n  rsx! {\n    button { onclick: move |_| counters.push(counters.len()); \"Add Counter\" }\n    ul {\n      for idx in 0..counters.len() {\n        li {\n          button { onclick: move |_| counters[idx] += 1; \"{counters[idx]}\" }\n          button { onclick: move |_| { counters.write().remove(idx); } \"Remove\" }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Children Props in Dioxus\nDESCRIPTION: This example demonstrates how to use the `children` prop to pass child elements to a component. This is similar to how elements can have children in HTML.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/props.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[derive(PartialEq, Clone, Props)]\nstruct ClickableProps {\n    href: String,\n    children: Element,\n}\n\nfn Clickable(props: ClickableProps) -> Element {\n    rsx! {\n        a {\n            href: \"{props.href}\",\n            class: \"fancy-button\",\n            {props.children}\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Including Raw Expressions in Dioxus with rsx!\nDESCRIPTION: Demonstrates how to include raw Rust expressions directly within a Dioxus component using the rsx! macro. The expression must implement the `IntoDynNode` trait. Requires the dioxus prelude.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/rsx.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nlet name = \"World\";\nrsx! {\n    div {\n        // Text can be converted into a dynamic node in rsx\n        {name}\n    }\n    // Iterators can also be converted into dynamic nodes\n    {(0..10).map(|n| n * n).map(|number| rsx! { div { \"{number}\" } })}\n};\n```\n\n----------------------------------------\n\nTITLE: Importing and Utilizing ES6 Modules for Styling - Rust\nDESCRIPTION: This snippet shows how to import ES6 modules in Dioxus using `document::Link` for CSS stylesheets and `document::Script` for JavaScript modules, specifically for syntax highlighting. It also demonstrates how to include a code block with syntax highlighting.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/document/docs/head.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstatic HIGHLIGHT: Asset = asset!(\"/assets/highlight/es/highlight.min.js\");\nstatic RUST: Asset = asset!(\"/assets/highlight/es/languages/rust.min.js\");\nstatic STYLE: Asset = asset!(\"/assets/highlight/styles/atom-one-dark.css\");\n\nfn App() -> Element {\n    rsx! {\n        document::Link { rel: \"stylesheet\", href: STYLE }\n        document::Script {\n            type: \"module\",\n            r#\"import hljs from \"{HIGHLIGHT}\";\n            import rust from \"{RUST}\";\n            hljs.registerLanguage('rust', rust);\n            hljs.highlightAll();\"#\n        }\n        pre {\n            code {\n                class: \"language-rust\",\n                \"fn main() {{\\nprintln!(\\\"Hello, world!\\\");\\n}}\"\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Hook Usage in Loops - Rust\nDESCRIPTION: This example demonstrates another incorrect way to use hooks within a Dioxus component. It illustrates the error of calling hooks within loops. Changing the loop's iteration count will alter the hook call order, possibly leading to errors or unexpected component behavior. `use_signal` from Dioxus is used here.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/rules_of_hooks.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nfn App() -> Element {\n    let number = use_signal(|| 1);\n    // ❌ Changing the loop will change the order of the hooks\n    for i in 0..number() {\n        let string = use_signal(|| \"hello world\".to_string());\n    }\n\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Dioxus Logger (Dioxus v0.6+)\nDESCRIPTION: This example demonstrates how to initialize the dioxus-logger in Dioxus v0.6 and later. The logger is part of dioxus itself, so you can directly call `dioxus::logger::init`. It uses the tracing crate for logging, with Level::INFO set. It shows a basic Dioxus application that logs a message when rendered.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/logger/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\nuse dioxus::logger::tracing::{Level, info};\n\nfn main() {\n  dioxus::logger::init(Level::INFO).expect(\"logger failed to init\");\n  dioxus::launch(App);\n}\n\n#[component]\nfn App() -> Element {\n  info!(\"App rendered\");\n  rsx! {\n    p { \"hi\" }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Serving Dioxus Example on Web Platform\nDESCRIPTION: This command shows how to serve a Dioxus example specifically for the web platform using the Dioxus CLI. It disables default desktop features and enables web features. The `--no-default-features` flag ensures only the web platform features are used.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/ko-kr/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ndx serve --example <example> --platform web -- --no-default-features\n```\n\n----------------------------------------\n\nTITLE: Using Memo with Non-Reactive Props in Dioxus\nDESCRIPTION: This example demonstrates the issue of using `use_memo` with non-reactive props. The `use_memo` hook only runs once during the initial render, meaning it will not update if the `count` prop changes.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/props.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn Counter(count: i32) -> Element {\n    // We can use a memo to calculate the doubled count. Since this memo will only be created the first time the component is run and `count` is not reactive, it will never update when `count` changes.\n    let doubled_count = use_memo(move || count * 2);\n    rsx! {\n        div {\n            \"Count: {count}\"\n            \"Doubled Count: {doubled_count}\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generational Box Usage Example in Rust\nDESCRIPTION: This snippet demonstrates how to use the generational_box crate to create an owner, insert data into it, and read the value. It uses UnsyncStorage for single-threaded scenarios.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/generational-box/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse generational_box::{UnsyncStorage, AnyStorage};\n\n// Create an owner for some state for a scope\nlet owner = UnsyncStorage::owner();\n\n// Create some non-copy data, move it into a owner, and work with copy data\nlet data: String = \"hello world\".to_string();\nlet key = owner.insert(data);\n\n// The generational box can be read from and written to like a RefCell\nlet value = key.read();\nassert_eq!(*value, \"hello world\");\n```\n\n----------------------------------------\n\nTITLE: Leptos Counter Component\nDESCRIPTION: This snippet demonstrates a Leptos component that renders a list of counters with add and remove functionality. It uses `RwSignal` for reactive state management and the `<For>` component for iterating over the counters.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/ja-jp/README.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nfn Counters() -> impl IntoView {\n    let counters = RwSignal::new(vec![0; 10]);\n\n    view! {\n        <button on:click=move |_| counters.update(|n| n.push(n.len()))>\"Add Counter\"</button>\n        <For\n            each=move || 0..counters.with(Vec::len)\n            key=|idx| *idx\n            let:idx\n        >\n            <li>\n                <button on:click=move |_| counters.update(|n| n[idx] += 1)>\n                    {Memo::new(move |_| counters.with(|n| n[idx]))}\n                </button>\n                <button on:click=move |_| counters.update(|n| { n.remove(idx); })>\n                    \"Remove\"\n                </button>\n            </li>\n        </For>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Serving Dioxus Web Example with Dioxus CLI\nDESCRIPTION: This command uses the Dioxus CLI (`dx`) to serve a web example. It disables the default desktop features and enables the web feature.  Replace `<example>` with the desired example name. The `--` separates dx serve arguments from cargo arguments.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ndx serve --example <example> --platform web -- --no-default-features\n```\n\n----------------------------------------\n\nTITLE: Dioxus Counters Component\nDESCRIPTION: This Dioxus component implements a counter list with add and remove functionality. It uses the `use_signal` hook for state management and renders the UI using the `rsx!` macro.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/zh-cn/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn Counters() -> Element {\n    let mut counters = use_signal(|| vec![0; 10]);\n\n    rsx! {\n        button { onclick: move |_| counters.push(counters.len()), \"Add Counter\" }\n        ul {\n            for idx in 0..counters.len() {\n                li {\n                    button { onclick: move |_| counters.write()[idx] += 1, \"{counters.index(idx)}\" }\n                    button { onclick: move |_| { counters.remove(idx); }, \"Remove\" }\n                }\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Component Properties with Function Arguments in Rust\nDESCRIPTION: This example shows how to define component properties directly through function arguments using the `#[component]` macro in Dioxus. This provides a more concise way to define properties compared to using explicit structs. The component function takes the properties as arguments, which can then be used within the `rsx!` macro to generate the UI.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/dioxus-lib/README.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[component]\nfn Header(title: String, color: String) -> Element {\n    rsx! {\n        div {\n            background_color: \"{color}\"\n            h1 { \"{title}\" }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Serving Dioxus Web Example with CLI\nDESCRIPTION: This command demonstrates how to use the Dioxus CLI to serve a web-based example. It disables default features and enables web-specific features, allowing the example to run in a browser.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/ja-jp/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ndx serve --example <example> --platform web -- --no-default-features\n```\n\n----------------------------------------\n\nTITLE: Dioxus DSL Example\nDESCRIPTION: This snippet exemplifies the Dioxus's Rust-like DSL for defining UI elements, automatically formatting the string. It creates a div element with a class, an enabled state and displays a personalized message.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/ko-kr/README.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\n// dioxus\nrsx! {\n  div { class: \"my-class\", enabled: true, \"Hello, {name}\" }\n}\n```\n\n----------------------------------------\n\nTITLE: VirtualDom Initialization and Rendering in Rust\nDESCRIPTION: This snippet showcases how to initialize a `VirtualDom` with a root component and perform an initial render to generate mutations.  It uses the `dioxus` crate, including the `rsx` macro. This example requires the `dioxus` crate.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::dioxus_core::Mutations;\nuse dioxus::prelude::*;\n\n// First, declare a root component\nfn app() -> Element {\n    rsx!{\n        div { \"hello world\" }\n    }\n}\n\nfn main() {\n    // Next, create a new VirtualDom using this app as the root component.\n    let mut dom = VirtualDom::new(app);\n\n    // The initial render of the dom will generate a stream of edits for the real dom to apply\n    let mutations = dom.rebuild_to_vec();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Dioxus Component Without Props (Rust)\nDESCRIPTION: This example demonstrates how to define a Dioxus component using the `component` macro without any props. The component simply renders the text \"hello, bob\". It requires the `dioxus::prelude` module.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/component.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn GreetBob() -> Element {\n    rsx! { \"hello, bob\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Dioxus Counter Component\nDESCRIPTION: This code snippet demonstrates a Dioxus component that creates a list of counters with 'Add Counter', increment, and remove functionalities. It uses `use_signal` for managing the counter state and `rsx!` for declarative UI definition, showcasing Dioxus's approach to reactive updates.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/ko-kr/README.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nfn Counters() -> Element {\n    let mut counters = use_signal(|| vec![0; 10]);\n\n    rsx! {\n        button { onclick: move |_| counters.push(counters.len()), \"Add Counter\" }\n        ul {\n            for idx in 0..counters.len() {\n                li {\n                    button { onclick: move |_| counters.write()[idx] += 1, \"{counters.index(idx)}\" }\n                    button { onclick: move |_| { counters.remove(idx); }, \"Remove\" }\n                }\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Custom Button Component with Attributes\nDESCRIPTION: This snippet demonstrates how to use the custom `Button` component. It shows how to pass global attributes (e.g., `width`) and element-specific attributes (e.g., `disabled`) to the component. These attributes are then applied to the rendered HTML button.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/component.md#_snippet_14\n\nLANGUAGE: Rust\nCODE:\n```\nrsx! {\n    Button {\n        // A global attribute\n        width: \"10px\",\n        // A button specific attribute\n        disabled: true,\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Derived State with use_resource in Dioxus (Rust)\nDESCRIPTION: This code showcases how to use `use_resource` to derive state asynchronously in Dioxus. The resource fetches data from a server based on the `count` signal.  Changes to `count` trigger a re-fetch of the data.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core/docs/reactivity.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse dioxus::prelude::*;\n\nlet count = use_signal(|| 0);\nlet double_count = use_resource(move || async move {\n    // Start a request to the server. We are reading the value of count to format it into the url\n    // Since we are reading count, this resource will \"subscribe\" to changes to count (when count changes, the resource will rerun)\n    let response = reqwest::get(format!(\"https://myserver.com/doubleme?count={count}\")).await.unwrap();\n    response.text().await.unwrap()\n});\n```\n\n----------------------------------------\n\nTITLE: Fixing 'argument type to outlive 'static' Error in Dioxus\nDESCRIPTION: This snippet demonstrates the error that occurs when an event handler tries to borrow a value that doesn't live long enough. The fix involves using the `move` keyword to transfer ownership of the value into the closure, ensuring it lives as long as the closure itself.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/html/docs/common_event_handler_errors.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n// We return an Element which can last as long as the component is on the screen\nfn App() -> Element {\n    // Signals are `Copy` which makes them very easy to move into `'static` closures like event handlers\n    let state = use_signal(|| \"hello world\".to_string());\n\n    rsx! {\n        button {\n            // ❌ Without `move`, rust will try to borrow the `state` signal which fails because the state signal is dropped at the end of the function\n            onclick: |_| {\n                println!(\"You clicked the button! The state is: {state}\");\n            },\n            \"Click me\"\n        }\n    }\n    // The state signal is dropped here, but the event handler still needs to access it\n}\n```\n\n----------------------------------------\n\nTITLE: Dioxus Counter Example in Rust\nDESCRIPTION: This code snippet demonstrates a simple counter application using the Dioxus framework. It defines a component function `app` that uses a signal to manage the counter state and renders buttons to increment and decrement the count. This shows the basic syntax for creating reactive UI elements with Dioxus.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/pt-br/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn app() -> Element {\n    let mut count = use_signal(|| 0);\n\n    rsx! {\n        h1 { \"High-Five counter: {count}\" }\n        button { onclick: move |_| count += 1, \"Up high!\" }\n        button { onclick: move |_| count -= 1, \"Down low!\" }\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Using Optional Attributes with If Statements in Dioxus\nDESCRIPTION: Explains how to include optional attributes in Dioxus components using unterminated if statements. This allows attributes to be conditionally set based on boolean values. Requires the dioxus prelude.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/rsx.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n# let first_boolean = true;\n# let second_boolean = false;\nrsx! {\n    div {\n        // Set the class attribute to \"my-class\" if true\n        class: if first_boolean {\n            \"my-class\"\n        },\n        // Set the class attribute to \"my-other-class\" if false\n        class: if second_boolean {\n            \"my-other-class\"\n        }\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Dioxus Component with ReadOnlySignal Props (Rust)\nDESCRIPTION: This example demonstrates how to make props reactive using `ReadOnlySignal`.  Dioxus automatically converts values to `ReadOnlySignal` when passed as props, ensuring `use_memo` updates when the prop changes.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/component.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn Counter(count: ReadOnlySignal<i32>) -> Element {\n    // Since we made count reactive, the memo will automatically rerun when count changes.\n    let doubled_count = use_memo(move || count() * 2);\n    rsx! {\n        div {\n            \"Count: {count}\"\n            \"Doubled Count: {doubled_count}\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Asset Definition with Manganis\nDESCRIPTION: This snippet demonstrates how to define an asset using the `manganis::asset!` macro. The asset is automatically processed by the CLI tool for optimization or conversion if configured.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/manganis/manganis/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse manganis::{Asset, asset};\nconst AVIF_ASSET: Asset = manganis::asset!(\"/assets/image.png\");\n```\n\n----------------------------------------\n\nTITLE: Incorrect Hook Usage in Conditionals - Rust\nDESCRIPTION: This snippet showcases how not to use hooks in Dioxus components. It highlights the error of calling hooks within conditional statements. Changing the condition will result in varying the order of hooks and potentially lead to errors or unexpected behavior due to Dioxus's hook state management strategy. The example uses `use_signal` from Dioxus.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/rules_of_hooks.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nfn App() -> Element {\n    let number = use_signal(|| 1);\n    // ❌ Changing the condition will change the order of the hooks\n    if number() == 1 {\n        let string = use_signal(|| \"hello world\".to_string());\n    }\n\n    // ❌ Changing the value you are matching will change the order of the hooks\n    match number() {\n        1 => {\n            let string = use_signal(|| \"hello world\".to_string());\n        },\n        _ => (),\n    }\n\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Event Handler with State Management (Rust)\nDESCRIPTION: This snippet demonstrates how to manage state within an event handler in Dioxus. The `count` signal is moved into the closure using the `move` keyword. This shows how to update the state when an event occurs.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/html/docs/event_handlers.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nlet mut count = use_signal(|| 0);\n\nrsx! {\n    button {\n        // Since we added the `move` keyword, the closure will move the `count` signal into the closure\n        onclick: move |_| {\n            // This will panic because the `count` signal is not in scope\n            count.set(count() + 1);\n        },\n        \"Click me\"\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Adding Dioxus and Dioxus Desktop Dependencies\nDESCRIPTION: Adds the Dioxus core library and the Dioxus Desktop integration as dependencies to the Cargo project. This allows the project to use Dioxus components and the desktop rendering functionality.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/desktop/src/readme.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo add dioxus\n$ cargo add dioxus-desktop\n```\n\n----------------------------------------\n\nTITLE: Implementing DioxusElement Trait for a Custom Element\nDESCRIPTION: This code snippet shows how to implement the `DioxusElement` trait for a custom element named `div`. The trait requires defining the `TAG_NAME` and `NAME_SPACE` constants. The `TAG_NAME` specifies the HTML tag name, and `NAME_SPACE` specifies the namespace (None for HTML elements).\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/html/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct div;\nimpl DioxusElement for div {\n    const TAG_NAME: &'static str = \"div\";\n    const NAME_SPACE: Option<&'static str> = None;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling wasm-split feature in Cargo.toml\nDESCRIPTION: This snippet demonstrates how to enable the `wasm-split` feature for bundle splitting in the `Cargo.toml` file. Both `dioxus` and `dioxus-router` crates need this feature enabled. This allows for automatic bundle splitting along route variants for improved performance.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/router/README.md#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ndioxus = { version = \"*\", features = [\"router\", \"wasm-split\"] }\ndioxus-router = { version = \"*\", features = [\"wasm-split\"] }\n```\n\n----------------------------------------\n\nTITLE: Dioxus Component with Optional Props (Rust)\nDESCRIPTION: This example shows how `Option<T>` fields are automatically optional, defaulting to `None`. The `text` prop is an `Option<String>`, so it's optional when using the component.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/component.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn Button(\n    // Since the `text` field is optional, you don't need to set it when you use the component.\n    text: Option<String>,\n) -> Element {\n    rsx! {\n        button { {text.unwrap_or(\"button\".to_string())} }\n    }\n}\n\nrsx! {\n    Button {}\n};\n```\n\n----------------------------------------\n\nTITLE: Handling Signals with Async Code in Dioxus (Incorrect)\nDESCRIPTION: This example illustrates the potential issues of holding reads or writes to Dioxus signals over `await` points in async code. It demonstrates how holding a write open while waiting for an async operation can cause panics, emphasizing a common pitfall. Requires the `dioxus::prelude` import.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/signals/docs/signals.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n# async fn sleep(delay: u32) {}\nasync fn double_me_async(value: &mut u32) {\n    sleep(100).await;\n    *value *= 2;\n}\nlet mut signal = use_signal(|| 0);\n\nuse_future(move || async move {\n    // Don't hold reads or writes over await points\n    let mut write = signal.write();\n    // While the future is waiting for the async work to finish, the write will be open\n    double_me_async(&mut write).await;\n});\n\nrsx!{\n    // This read may panic because the write is still active while the future is waiting for the async work to finish\n    \"{signal}\"\n};\n```\n\n----------------------------------------\n\nTITLE: Serving Dioxus App with wasm-split using dx\nDESCRIPTION: This snippet shows the command to serve a Dioxus application with router splitting enabled using the `dx` CLI. The `--experimental-wasm-split` flag is required when serving with router splitting.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/router/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ndx serve --experimental-wasm-split\n```\n\n----------------------------------------\n\nTITLE: Dioxus Counter Component\nDESCRIPTION: This snippet demonstrates a Dioxus component that renders a list of counters with add and remove functionality. It uses the `use_signal` hook to manage the state of the counters vector and the `rsx!` macro for declarative UI definition.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/ja-jp/README.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nfn Counters() -> Element {\n    let mut counters = use_signal(|| vec![0; 10]);\n\n    rsx! {\n        button { onclick: move |_| counters.push(counters.len()), \"Add Counter\" }\n        ul {\n            for idx in 0..counters.len() {\n                li {\n                    button { onclick: move |_| counters.write()[idx] += 1, \"{counters.index(idx)}\" }\n                    button { onclick: move |_| { counters.remove(idx); }, \"Remove\" }\n                }\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dioxus useEffect with non-reactive dependencies\nDESCRIPTION: This example shows how to use `use_effect` with non-reactive dependencies. The `use_reactive` hook is used to add `count` as a dependency to the effect, causing the effect to rerun every time `count` changes.  Signals are automatically added as dependencies so the user does not need to manually add them using use_reactive.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/side_effects.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n# async fn sleep(delay: u32) {}\n\n#[component]\nfn Comp(count: u32) -> Element {\n    // Because the memo subscribes to `count` by adding it as a dependency, the memo will rerun every time `count` changes.\n    use_effect(use_reactive((&count,), |(count,)| println!(\"Manually manipulate the dom\") ));\n\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Hook Usage in Initialization Closures - Rust\nDESCRIPTION: This snippet shows the incorrect placement of hooks inside initialization closures within other hooks. Initialization closures only execute during the initial render. Any subsequent re-renders would then miss the hook calls within these closures. `use_signal` from Dioxus is used here to demonstrate the error.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/rules_of_hooks.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nfn App() -> Element {\n    let number = use_signal(|| {\n        // ❌ This closure will only be called when the component is first created. Running the component will change the order of the hooks\n        let string = use_signal(|| \"hello world\".to_string());\n        string()\n    });\n\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Using Required Option Props in Dioxus\nDESCRIPTION: This example demonstrates how to make an `Option<T>` field required using the `#[props(!optional)]` attribute. If the `text` prop is not provided, it will result in a compile-time error.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/props.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[derive(Props, PartialEq, Clone)]\nstruct ButtonProps {\n    /// You can use the `!optional` attribute on a field with the type `Option<T>` to make it required.\n    #[props(!optional)]\n    text: Option<String>,\n}\n\nfn Button(props: ButtonProps) -> Element {\n    rsx! {\n        button { {props.text.unwrap_or(\"button\".to_string())} }\n    }\n}\n\nrsx! {\n    Button {\n        text: None\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Using Reactive Props in Dioxus\nDESCRIPTION: This example showcases a Dioxus component that uses reactive props. When the `count` prop changes, the component will automatically re-render to update the UI.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/props.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn Counter(count: i32) -> Element {\n    rsx! {\n        div {\n            \"Count: {count}\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a simple counter component in Dioxus Rust\nDESCRIPTION: This code snippet demonstrates a basic Dioxus component that creates a counter with increment and decrement buttons. It utilizes the `use_signal` hook for state management and the `rsx!` macro for defining the UI.  The component displays the current count and provides buttons to increase or decrease it.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/zh-cn/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn app() -> Element {\n    let mut count = use_signal(|| 0);\n\n    rsx! {\n        h1 { \"High-Five counter: {count}\" }\n        button { onclick: move |_| count += 1, \"Up high!\" }\n        button { onclick: move |_| count -= 1, \"Down low!\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Dioxus Examples\nDESCRIPTION: This command shows how to run a specific Dioxus example using cargo.  Replace EXAMPLE_NAME with the name of the example you want to run.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/examples/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ncargo run --example hello_world\n```\n\n----------------------------------------\n\nTITLE: Defining Attributes for a Dioxus Element\nDESCRIPTION: This code snippet demonstrates how to define attributes for a Dioxus element.  It shows how the `href` and `target` attributes are associated with the `base` element. The attributes are defined as constants on the unit struct with a tuple containing the attribute name, namespace (None for standard HTML attributes), and a boolean indicating if it's a boolean attribute.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/html/README.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct base;\nimpl DioxusElement for base {\n    const TAG_NAME: &'static str = \"base\";\n    const NAME_SPACE: Option<&'static str> = None;\n}\nimpl base {\n    const href: (&'static str, Option<'static str>, bool) = (\"href\", None, false);\n    const target: (&'static str, Option<'static str>, bool) = (\"target\", None, false);\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing moved value error in Dioxus with `Copy` trait\nDESCRIPTION: This snippet illustrates how to fix the \"use of moved value\" error in Dioxus by using the `Copy` trait. The error occurs when attempting to move data that doesn't implement `Copy` into multiple async tasks. The solution involves using `ReadOnlySignal` to ensure data can be copied and used in multiple tasks.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core/docs/common_spawn_errors.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n// `MyComponent` accepts a string which cannot be copied implicitly\n#[component]\nfn MyComponent(string: String) -> Element {\n    use_hook(move || {\n        // ❌ We are moving the string into the async task which means we can't access it elsewhere\n        spawn(async move {\n            println!(\"{}\", string);\n        });\n        // ❌ Since we already moved the string, we can't move it into our new task. This will cause a compiler error\n        spawn(async move {\n            println!(\"{}\", string);\n        })\n    });\n\n    todo!()\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n// `MyComponent` accepts `ReadOnlySignal<String>` which implements `Copy`\n#[component]\nfn MyComponent(string: ReadOnlySignal<String>) -> Element {\n    use_hook(move || {\n        // ✅ Because the `string` signal is `Copy`, we can copy it into the async task while still having access to it elsewhere\n        spawn(async move {\n            println!(\"{}\", string);\n        });\n        // ✅ Since `string` is `Copy`, we can copy it into another async task\n        spawn(async move {\n            println!(\"{}\", string);\n        })\n    });\n\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dioxus CLI from Git\nDESCRIPTION: This command installs the Dioxus CLI directly from the Git repository. It is recommended when using the git version of Dioxus to ensure version compatibility. The `--locked` flag ensures consistent dependency versions.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/ja-jp/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncargo install --git https://github.com/DioxusLabs/dioxus dioxus-cli --locked\n```\n\n----------------------------------------\n\nTITLE: Rendering a List of Elements using `rsx!` macro with a loop in Rust\nDESCRIPTION: This code shows how to use a for loop within the `rsx!` macro to render a list of elements. The `rsx!` macro parses `for` loops and interprets their body as a child element to be repeated. This is used to create dynamic lists of UI elements directly within the component's render function.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/dioxus-lib/README.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nrsx! {\n    div {\n        for _ in 0..10 {\n            span { \"hello world\" }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Counter Component in Dioxus\nDESCRIPTION: This code snippet demonstrates a simple Dioxus component that implements a counter with increment and decrement buttons. It uses the `use_signal` hook to manage the component's state and the `rsx!` macro for declarative UI rendering. The buttons update the counter state when clicked, triggering a re-render of the component.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/tr-tr/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn app() -> Element {\n    let mut count = use_signal(|| 0);\n\n    rsx! {\n        h1 { \"High-Five counter: {count}\" }\n        button { onclick: move |_| count += 1, \"Up high!\" }\n        button { onclick: move |_| count -= 1, \"Down low!\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Dioxus Workspace\nDESCRIPTION: This snippet executes the cargo test command to run all tests within the Dioxus workspace. The --workspace flag ensures all packages in the workspace are tested, and the --tests flag specifies that only tests should be run.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/notes/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo test --workspace --tests\n```\n\n----------------------------------------\n\nTITLE: Running Dioxus PWA with Dioxus CLI\nDESCRIPTION: This snippet shows how to use the Dioxus CLI to run the PWA example locally. It requires Dioxus CLI to be installed.  The command `dx serve` starts a local web server. The command `dx build --release` builds the project for deployment.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/examples/pwa/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndx serve\n```\n\nLANGUAGE: bash\nCODE:\n```\ndx build --release\n```\n\n----------------------------------------\n\nTITLE: Dioxus Simple UI\nDESCRIPTION: This snippet shows a basic Dioxus UI definition using the `rsx!` macro, demonstrating class binding and string interpolation.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/ja-jp/README.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\n// dioxus\nrsx! {\n  div { class: \"my-class\", enabled: true, \"Hello, {name}\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Examples with cargo run\nDESCRIPTION: This command shows how to run a specific example project within the Dioxus repository using `cargo run`.  The `<example>` placeholder should be replaced with the name of the desired example.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/ko-kr/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncargo run --example <example>\n```\n\n----------------------------------------\n\nTITLE: Running Tailwind CSS and Dioxus Server\nDESCRIPTION: This command runs Tailwind CSS to process the input CSS file and generate the output CSS file in the public directory. It also starts the Dioxus server to serve the application. The tailwind command includes the --watch flag, which tells tailwind to automatically rebuild the CSS file when changes are detected.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/example-projects/ecommerce-site/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx tailwindcss -i ./input.css -o ./public/tailwind.css --watch\ndx serve\n```\n\n----------------------------------------\n\nTITLE: Creating a new Rust Project\nDESCRIPTION: Creates a new Rust binary project named 'demo' using Cargo, the Rust package manager. This initializes the project structure, including a 'src/main.rs' file and a 'Cargo.toml' configuration file. Then, it navigates into the newly created project directory.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/desktop/src/readme.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo new --bin demo\n$ cd app\n```\n\n----------------------------------------\n\nTITLE: Adding dioxus-logger as a dependency (Dioxus v0.5)\nDESCRIPTION: This snippet shows how to add `dioxus-logger` as a dependency in your `Cargo.toml` file if you are using Dioxus version 0.5 or earlier. This is needed to use the `dioxus-logger` crate in your Dioxus project before it was integrated into the core Dioxus library.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/logger/README.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ndioxus-logger = \"0.5\"\n```\n\n----------------------------------------\n\nTITLE: Signal Borrow Checking and Panics in Dioxus\nDESCRIPTION: This snippet illustrates the runtime borrow checking in Dioxus signals, which can lead to panics if reads and writes overlap. The code demonstrates a scenario where holding a read while writing causes a panic. The `use dioxus::prelude::*;` statement is required for Dioxus signal functionality.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/signals/docs/signals.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nlet mut signal = use_signal(|| 0);\n// If you create a read and hold it while you write to the signal, it will panic\nlet read = signal.read_unchecked();\n// This will panic\nsignal += 1;\nprintln!(\"{}\", read);\n```\n\n----------------------------------------\n\nTITLE: Dioxus vs Leptos DSL Comparison\nDESCRIPTION: This Rust code demonstrates the difference in DSL syntax between Dioxus and Leptos for creating a simple div element with a class, an enabled attribute, and text content. Dioxus uses the `rsx!` macro with a more Rust-like syntax, while Leptos uses the `view!` macro with an HTML-like structure and closures.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/fa-ir/README.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n// dioxus\nrsx! {\n  div { class: \"my-class\", enabled: true, \"سلام، {name}\" }\n}\n\n// leptos\nview! {\n  <div class=\"my-class\" enabled={true}>\n    \"سلام \"\n    {move || name()}\n  </div>\n}\n```\n\n----------------------------------------\n\nTITLE: Bare-bones Dioxus.toml Template\nDESCRIPTION: Provides a basic template for the `Dioxus.toml` configuration file, including mandatory fields. You can generate a complete Dioxus.toml file by `dx config init project-name`.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/cli/README.md#_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[application]\nname = \"project-name\"\n# Currently supported platforms: web, desktop\ndefault_platform = \"web\"\n\n[web.app]\ntitle = \"Hello\"\n\n[web.resource.dev]\n```\n\n----------------------------------------\n\nTITLE: Using use_reactive() for Non-Reactive Dependencies\nDESCRIPTION: This snippet shows how to add non-reactive dependencies to a memo using the `use_reactive` hook. The `new_count` memo subscribes to the `count` prop by adding it as a dependency, causing the memo to rerun every time `count` changes. Signals are automatically handled as dependencies without needing `use_reactive`.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/hooks/docs/derived_state.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n#[component]\nfn Comp(count: u32) -> Element {\n// Because the memo subscribes to `count` by adding it as a dependency, the memo will rerun every time `count` changes.\nlet new_count = use_memo(use_reactive((&count,), |(count,)| count + 1));\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Leptos HTML-like Syntax Example\nDESCRIPTION: This code shows Leptos's more HTML-like syntax for defining UI. It demonstrates how to bind values using the `={}` syntax.  Notice that the string concatenation must be split into static and dynamic parts.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/ko-kr/README.md#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\n// leptos\nview! {\n  <div class=\"my-class\" enabled={true}>\n    \"Hello \"\n    {name}\n  </div>\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrectly Passing Memos Up Component Tree\nDESCRIPTION: This snippet shows an example of how *not* to use Memos, specifically how passing memos up the component tree may cause issues related to the memo's lifecycle being tied to the component it was created in.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/signals/docs/memo.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\nfn MyComponent() -> Element {\n    let child_signal = use_signal(|| None);\n\n    rsx! {\n        IncrementButton {\n            child_signal\n        }\n    }\n}\n\n#[component]\nfn IncrementButton(mut child_signal: Signal<Option<Memo<i32>>>>) -> Element {\n    let signal_owned_by_child = use_signal(|| 0);\n    let memo_owned_by_child = use_memo(move || signal_owned_by_child() * 2);\n    // Don't do this: it may cause issues if you drop the child component\n    child_signal.set(Some(memo_owned_by_child));\n\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Packaging and Publishing VS Code Extension with VSCE\nDESCRIPTION: This snippet shows how to package a VS Code extension into a `.vsix` file and then publish it to the VS Code Marketplace using the `vsce` (Visual Studio Code Extension Manager) command-line tool. The commands assume that you are in the root directory of your extension project.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/extension/DEV.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ cd myExtension\n$ vsce package\n# myExtension.vsix generated\n$ vsce publish\n# <publisherID>.myExtension published to VS Code Marketplace\n```\n\n----------------------------------------\n\nTITLE: Button Component with Global and Element Attribute Extension\nDESCRIPTION: This code defines a `Button` component that extends its properties with both global HTML attributes and attributes specific to the `button` element using the `#[props(extends = GlobalAttributes, extends = button)]` attribute. The `attributes` field will contain all the specified attributes. The attributes are then spread onto the `button` element.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/core-macro/docs/props.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n# use dioxus::prelude::*;\n\n#[derive(Props, PartialEq, Clone)]\nstruct ButtonProps {\n    #[props(extends = GlobalAttributes, extends = button)]\n    attributes: Vec<Attribute>,\n}\n\n#[component]\nfn Button(props: ButtonProps) -> Element {\n    rsx! {\n        button { ..props.attributes, \"button\" }\n    }\n}\n\nrsx! {\n    Button {\n        // A global attribute\n        width: \"10px\",\n        // A button specific attribute\n        disabled: true,\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Redirecting to a URL Using Meta Tag - Rust\nDESCRIPTION: This code snippet demonstrates how to use the `Meta` component in Dioxus to redirect the user to another URL after a specified delay. The `http_equiv` attribute is set to \"refresh\", and the `content` attribute specifies the delay and the target URL.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/packages/document/docs/head.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn RedirectToDioxusHomepageWithoutJS() -> Element {\n    rsx! {\n        // You can use the meta component to render a meta tag into the head of the page\n        // This meta tag will redirect the user to the dioxuslabs homepage in 10 seconds\n        document::Meta {\n            http_equiv: \"refresh\",\n            content: \"10;url=https://dioxuslabs.com\",\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dioxus vs Leptos DSL Comparison (Rust)\nDESCRIPTION: This snippet compares the DSLs used by Dioxus and Leptos for defining UI elements. Dioxus uses a Rust-like DSL, while Leptos uses a more HTML-like syntax. Dioxus automatically concatenates strings.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/tr-tr/README.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n// dioxus\nrsx! {\n  div { class: \"my-class\", enabled: true, \"Hello, {name}\" }\n}\n\n// leptos\nview! {\n  <div class=\"my-class\" enabled={true}>\n    \"Hello \"\n    {move || name()}\n  </div>\n}\n```\n\n----------------------------------------\n\nTITLE: Leptos Counters Component\nDESCRIPTION: This Rust code defines a Leptos component called `Counters` that manages a list of counters. It uses signals for reactivity and the `<For>` component for dynamic rendering. The component includes buttons to add and remove counters, as well as increment their values. It also showcases the usage of `create_signal` and `set_counters` for managing the state of the counters.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/fa-ir/README.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nfn Counters() -> Element {\n    let initial_counters = (0..initial_length)\n        .map(|id| (id, create_signal(id + 1)))\n        .collect::<Vec<_>>();\n\n    let (counters, set_counters) = create_signal(initial_counters);\n\n    let add_counter = move |_| {\n        let sig = create_signal(next_counter_id + 1);\n        set_counters.update(move |counters| counters.push((next_counter_id, sig)));\n        next_counter_id += 1;\n    };\n\n    view! {\n        <div>\n            <button on:click=add_counter>\n                \"Add Counter\"\n            </button>\n            <ul>\n                <For\n                    each=counters\n                    key=|counter| counter.0\n                    children=move |(id, (count, set_count))| {\n                        view! {\n                            <li>\n                                <button\n                                    on:click=move |_| set_count.update(|n| *n += 1)\n                                >\n                                    {count}\n                                </button>\n                                <button\n                                    on:click=move |_| {\n                                        set_counters.update(|counters| {\n                                            counters.retain(|(counter_id, (signal, _))| {\n\n                                                if counter_id == &id {\n                                                    signal.dispose();\n                                                }\n                                                counter_id != &id\n                                            })\n                                        });\n                                    }\n                                >\n                                    \"Remove\"\n                                </button>\n                            </li>\n                        }\n                    }\n                />\n            </ul>\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Dioxus Examples via Cargo\nDESCRIPTION: This command shows how to run examples within the Dioxus repository using Cargo. It specifies the example name to execute.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/ja-jp/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncargo run --example <example>\n```\n\n----------------------------------------\n\nTITLE: Leptos Counters Component\nDESCRIPTION: This Leptos component implements the same counter list functionality as the Dioxus example. It uses `RwSignal` for reactive state and the `<For>` component for iterating over the counter list.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/zh-cn/README.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn Counters() -> impl IntoView {\n    let counters = RwSignal::new(vec![0; 10]);\n\n    view! {\n        <button on:click=move |_| counters.update(|n| n.push(n.len()))>\"Add Counter\"</button>\n        <For\n            each=move || 0..counters.with(Vec::len)\n            key=|idx| *idx\n            let:idx\n        >\n            <li>\n                <button on:click=move |_| counters.update(|n| n[idx] += 1)>\n                    {Memo::new(move |_| counters.with(|n| n[idx]))}\n                </button>\n                <button on:click=move |_| counters.update(|n| { n.remove(idx); })>\n                    \"Remove\"\n                </button>\n            </li>\n        </For>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Dioxus Examples with Cargo\nDESCRIPTION: This shell command shows how to run a Dioxus example using cargo.  Replace `<example>` with the name of the example you want to run. This command compiles and executes the specified example.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncargo run --example <example>\n```\n\n----------------------------------------\n\nTITLE: Counters Component Implementation with Leptos (Rust)\nDESCRIPTION: This snippet demonstrates a Counters component implemented using Leptos. It uses signals and the <For> component for managing a list of counters with add and remove functionalities. Key tracking and manual memory cleanup are required.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/tr-tr/README.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nfn Counters() -> Element {\n    let initial_counters = (0..initial_length)\n        .map(|id| (id, create_signal(id + 1)))\n        .collect::<Vec<_>>();\n\n    let (counters, set_counters) = create_signal(initial_counters);\n\n    let add_counter = move |_| {\n        let sig = create_signal(next_counter_id + 1);\n        set_counters.update(move |counters| counters.push((next_counter_id, sig)));\n        next_counter_id += 1;\n    };\n\n    view! {\n        <div>\n            <button on:click=add_counter>\n                \"Add Counter\"\n            </button>\n            <ul>\n                <For\n                    each=counters\n                    key=|counter| counter.0\n                    children=move |(id, (count, set_count))| {\n                        view! {\n                            <li>\n                                <button\n                                    on:click=move |_| set_count.update(|n| *n += 1)\n                                >\n                                    {count}\n                                </button>\n                                <button\n                                    on:click=move |_| {\n                                        set_counters.update(|counters| {\n                                            counters.retain(|(counter_id, (signal, _))| {\n\n                                                if counter_id == &id {\n                                                    signal.dispose();\n                                                }\n                                                counter_id != &id\n                                            })\n                                        });\n                                    }\n                                >\n                                    \"Remove\"\n                                </button>\n                            </li>\n                        }\n                    }\n                />\n            </ul>\n        </div>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies on Linux\nDESCRIPTION: This snippet provides the command to install necessary dependencies on Linux using apt. These dependencies are required for building and testing Dioxus. The command updates the package list and installs libraries like gdk, atk, cairo, pango, gdk-pixbuf, soup, javascriptcoregtk, and webkit2gtk.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/notes/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt install libgdk3.0-cil libatk1.0-dev libcairo2-dev libpango1.0-dev libgdk-pixbuf2.0-dev libsoup-3.0-dev libjavascriptcoregtk-4.1-dev libwebkit2gtk-4.1-dev\n```\n\n----------------------------------------\n\nTITLE: Installing Dioxus CLI from Git\nDESCRIPTION: This shell command installs the Dioxus CLI directly from the Git repository. This is useful for working with the development version of Dioxus. The `--locked` flag ensures that the dependencies are resolved consistently.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncargo install --git https://github.com/DioxusLabs/dioxus dioxus-cli --locked\n```\n\n----------------------------------------\n\nTITLE: Installing Dioxus CLI from Git\nDESCRIPTION: This command demonstrates how to install the Dioxus CLI directly from the Git repository. This ensures that you are using a version of the CLI that matches the git version of Dioxus being used in the project.  The `--locked` flag ensures that the dependencies are resolved exactly as specified in the lockfile.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/ko-kr/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncargo install --git https://github.com/DioxusLabs/dioxus dioxus-cli --locked\n```\n\n----------------------------------------\n\nTITLE: Leptos Simple UI\nDESCRIPTION: This snippet shows a basic Leptos UI definition using the `view!` macro, demonstrating class binding and rendering dynamic text.\nSOURCE: https://github.com/dioxuslabs/dioxus/blob/main/translations/ja-jp/README.md#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\n// leptos\nview! {\n  <div class=\"my-class\" enabled={true}>\n    \"Hello \"\n    {move || name()}\n  </div>\n}\n```"
  }
]