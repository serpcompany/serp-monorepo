[
  {
    "owner": "dotnet",
    "repo": "aspnetcore",
    "content": "TITLE: EditContext Class API for ASP.NET Core Blazor Forms\nDESCRIPTION: The EditContext class provides form state tracking and validation capabilities for Blazor forms. It tracks model changes, validation state, and provides methods to validate form data and access validation messages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Forms/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Forms.EditContext\nMicrosoft.AspNetCore.Components.Forms.EditContext.EditContext(object! model) -> void\nMicrosoft.AspNetCore.Components.Forms.EditContext.Field(string! fieldName) -> Microsoft.AspNetCore.Components.Forms.FieldIdentifier\nMicrosoft.AspNetCore.Components.Forms.EditContext.GetValidationMessages() -> System.Collections.Generic.IEnumerable<string!>!\nMicrosoft.AspNetCore.Components.Forms.EditContext.GetValidationMessages(Microsoft.AspNetCore.Components.Forms.FieldIdentifier fieldIdentifier) -> System.Collections.Generic.IEnumerable<string!>!\nMicrosoft.AspNetCore.Components.Forms.EditContext.GetValidationMessages(System.Linq.Expressions.Expression<System.Func<object!>!>! accessor) -> System.Collections.Generic.IEnumerable<string!>!\nMicrosoft.AspNetCore.Components.Forms.EditContext.IsModified() -> bool\nMicrosoft.AspNetCore.Components.Forms.EditContext.IsModified(in Microsoft.AspNetCore.Components.Forms.FieldIdentifier fieldIdentifier) -> bool\nMicrosoft.AspNetCore.Components.Forms.EditContext.IsModified(System.Linq.Expressions.Expression<System.Func<object!>!>! accessor) -> bool\nMicrosoft.AspNetCore.Components.Forms.EditContext.IsValid(in Microsoft.AspNetCore.Components.Forms.FieldIdentifier fieldIdentifier) -> bool\nMicrosoft.AspNetCore.Components.Forms.EditContext.IsValid(System.Linq.Expressions.Expression<System.Func<object!>!>! accessor) -> bool\nMicrosoft.AspNetCore.Components.Forms.EditContext.MarkAsUnmodified() -> void\nMicrosoft.AspNetCore.Components.Forms.EditContext.MarkAsUnmodified(in Microsoft.AspNetCore.Components.Forms.FieldIdentifier fieldIdentifier) -> void\nMicrosoft.AspNetCore.Components.Forms.EditContext.Model.get -> object!\nMicrosoft.AspNetCore.Components.Forms.EditContext.NotifyFieldChanged(in Microsoft.AspNetCore.Components.Forms.FieldIdentifier fieldIdentifier) -> void\nMicrosoft.AspNetCore.Components.Forms.EditContext.NotifyValidationStateChanged() -> void\nMicrosoft.AspNetCore.Components.Forms.EditContext.OnFieldChanged -> System.EventHandler<Microsoft.AspNetCore.Components.Forms.FieldChangedEventArgs!>?\nMicrosoft.AspNetCore.Components.Forms.EditContext.OnValidationRequested -> System.EventHandler<Microsoft.AspNetCore.Components.Forms.ValidationRequestedEventArgs!>?\nMicrosoft.AspNetCore.Components.Forms.EditContext.OnValidationStateChanged -> System.EventHandler<Microsoft.AspNetCore.Components.Forms.ValidationStateChangedEventArgs!>?\nMicrosoft.AspNetCore.Components.Forms.EditContext.Properties.get -> Microsoft.AspNetCore.Components.Forms.EditContextProperties!\nMicrosoft.AspNetCore.Components.Forms.EditContext.ShouldUseFieldIdentifiers.get -> bool\nMicrosoft.AspNetCore.Components.Forms.EditContext.ShouldUseFieldIdentifiers.set -> void\nMicrosoft.AspNetCore.Components.Forms.EditContext.Validate() -> bool\n```\n\n----------------------------------------\n\nTITLE: Defining WebApplication Class in C#\nDESCRIPTION: Defines the WebApplication class with properties and methods for managing the web application, including configuration, environment, services, and lifecycle management.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DefaultBuilder/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Builder.WebApplication\nMicrosoft.AspNetCore.Builder.WebApplication.Configuration.get -> Microsoft.Extensions.Configuration.IConfiguration!\nMicrosoft.AspNetCore.Builder.WebApplication.DisposeAsync() -> System.Threading.Tasks.ValueTask\nMicrosoft.AspNetCore.Builder.WebApplication.Environment.get -> Microsoft.AspNetCore.Hosting.IWebHostEnvironment!\nMicrosoft.AspNetCore.Builder.WebApplication.Lifetime.get -> Microsoft.Extensions.Hosting.IHostApplicationLifetime!\nMicrosoft.AspNetCore.Builder.WebApplication.Logger.get -> Microsoft.Extensions.Logging.ILogger!\nMicrosoft.AspNetCore.Builder.WebApplication.Run(string? url = null) -> void\nMicrosoft.AspNetCore.Builder.WebApplication.RunAsync(string? url = null) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Builder.WebApplication.Services.get -> System.IServiceProvider!\nMicrosoft.AspNetCore.Builder.WebApplication.StartAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Builder.WebApplication.StopAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Builder.WebApplication.Urls.get -> System.Collections.Generic.ICollection<string!>!\nMicrosoft.AspNetCore.Builder.WebApplication.Use(System.Func<Microsoft.AspNetCore.Http.RequestDelegate!, Microsoft.AspNetCore.Http.RequestDelegate!>! middleware) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Route Template Parsing and Part Creation in ASP.NET Core\nDESCRIPTION: These static methods handle the parsing of route templates and creation of template parts in ASP.NET Core routing. They provide the foundation for route matching and URL generation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.Template.TemplateParser.Parse(string! routeTemplate) -> Microsoft.AspNetCore.Routing.Template.RouteTemplate!\n\nstatic Microsoft.AspNetCore.Routing.Template.TemplatePart.CreateLiteral(string! text) -> Microsoft.AspNetCore.Routing.Template.TemplatePart!\n\nstatic Microsoft.AspNetCore.Routing.Template.TemplatePart.CreateParameter(string! name, bool isCatchAll, bool isOptional, object? defaultValue, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Routing.Template.InlineConstraint!>? inlineConstraints) -> Microsoft.AspNetCore.Routing.Template.TemplatePart!\n```\n\n----------------------------------------\n\nTITLE: Defining OpenIdConnectOptions Class in C#\nDESCRIPTION: This snippet defines the OpenIdConnectOptions class, which contains numerous properties for configuring OpenID Connect authentication. It includes settings for client credentials, endpoints, token validation, and various behaviors.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectOptions\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectOptions.AdditionalAuthorizationParameters.get -> System.Collections.Generic.IDictionary<string!, string!>!\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectOptions.AuthenticationMethod.get -> Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectRedirectBehavior\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectOptions.AuthenticationMethod.set -> void\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectOptions.Authority.get -> string?\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectOptions.Authority.set -> void\n// ... (truncated for brevity)\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectOptions.UseTokenLifetime.get -> bool\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectOptions.UseTokenLifetime.set -> void\n```\n\n----------------------------------------\n\nTITLE: Sending HandshakeResponse in JSON for SignalR Protocol\nDESCRIPTION: Example of a HandshakeResponse message sent by the server to acknowledge the HandshakeRequest. It includes an optional error message if the server does not support the requested protocol.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"error\": \"Requested protocol 'messagepack' is not available.\"\n}\n```\n\n----------------------------------------\n\nTITLE: SignalR Hub Context Interface\nDESCRIPTION: Core interface for accessing hub clients and groups from outside a hub instance.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IHubContext<THub>\n{\n    IHubClients Clients { get; }\n    IGroupManager Groups { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: UserManager<TUser> Core Authentication Class\nDESCRIPTION: Main class for managing users including password validation, user validation, and store operations. Handles core user management functionality with dependency injection for customization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class UserManager<TUser> {\n    public UserManager(\n        IUserStore<TUser> store,\n        IOptions<IdentityOptions> optionsAccessor,\n        IPasswordHasher<TUser> passwordHasher,\n        IEnumerable<IUserValidator<TUser>> userValidators,\n        IEnumerable<IPasswordValidator<TUser>> passwordValidators,\n        ILookupNormalizer keyNormalizer,\n        IdentityErrorDescriber errors,\n        IServiceProvider services,\n        ILogger<UserManager<TUser>> logger\n    ) {}\n\n    public IUserStore<TUser> Store { get; set; }\n    public IdentityOptions Options { get; set; }\n    public IPasswordHasher<TUser> PasswordHasher { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Authentication Methods in ControllerBase for ASP.NET Core MVC\nDESCRIPTION: These methods provide functionality for signing in and signing out users in ASP.NET Core MVC applications. They allow for specifying authentication schemes and properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_60\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.SignIn(System.Security.Claims.ClaimsPrincipal! principal, Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, string! authenticationScheme) -> Microsoft.AspNetCore.Mvc.SignInResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.SignIn(System.Security.Claims.ClaimsPrincipal! principal, string! authenticationScheme) -> Microsoft.AspNetCore.Mvc.SignInResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.SignOut() -> Microsoft.AspNetCore.Mvc.SignOutResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.SignOut(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties) -> Microsoft.AspNetCore.Mvc.SignOutResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.SignOut(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, params string![]! authenticationSchemes) -> Microsoft.AspNetCore.Mvc.SignOutResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.SignOut(params string![]! authenticationSchemes) -> Microsoft.AspNetCore.Mvc.SignOutResult!\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultHubLifetimeManager in ASP.NET Core SignalR\nDESCRIPTION: Implementation of hub lifetime manager that handles connection management, group membership, and message routing for SignalR hubs. This includes methods for sending messages to users, groups, and connections.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.SignalR.DefaultHubLifetimeManager<THub>.AddToGroupAsync(string! connectionId, string! groupName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.SignalR.DefaultHubLifetimeManager<THub>.InvokeConnectionAsync<T>(string! connectionId, string! methodName, object?[]! args, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<T>!\noverride Microsoft.AspNetCore.SignalR.DefaultHubLifetimeManager<THub>.OnConnectedAsync(Microsoft.AspNetCore.SignalR.HubConnectionContext! connection) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.SignalR.DefaultHubLifetimeManager<THub>.OnDisconnectedAsync(Microsoft.AspNetCore.SignalR.HubConnectionContext! connection) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.SignalR.DefaultHubLifetimeManager<THub>.RemoveFromGroupAsync(string! connectionId, string! groupName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.SignalR.DefaultHubLifetimeManager<THub>.SendAllAsync(string! methodName, object?[]! args, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.SignalR.DefaultHubLifetimeManager<THub>.SendAllExceptAsync(string! methodName, object?[]! args, System.Collections.Generic.IReadOnlyList<string!>! excludedConnectionIds, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.SignalR.DefaultHubLifetimeManager<THub>.SendConnectionAsync(string! connectionId, string! methodName, object?[]! args, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.SignalR.DefaultHubLifetimeManager<THub>.SendConnectionsAsync(System.Collections.Generic.IReadOnlyList<string!>! connectionIds, string! methodName, object?[]! args, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.SignalR.DefaultHubLifetimeManager<THub>.SendGroupAsync(string! groupName, string! methodName, object?[]! args, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.SignalR.DefaultHubLifetimeManager<THub>.SendGroupExceptAsync(string! groupName, string! methodName, object?[]! args, System.Collections.Generic.IReadOnlyList<string!>! excludedConnectionIds, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.SignalR.DefaultHubLifetimeManager<THub>.SendGroupsAsync(System.Collections.Generic.IReadOnlyList<string!>! groupNames, string! methodName, object?[]! args, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.SignalR.DefaultHubLifetimeManager<THub>.SendUserAsync(string! userId, string! methodName, object?[]! args, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.SignalR.DefaultHubLifetimeManager<THub>.SendUsersAsync(System.Collections.Generic.IReadOnlyList<string!>! userIds, string! methodName, object?[]! args, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.SignalR.DefaultHubLifetimeManager<THub>.SetConnectionResultAsync(string! connectionId, Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage! result) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.SignalR.DefaultHubLifetimeManager<THub>.TryGetReturnType(string! invocationId, out System.Type? type) -> bool\n```\n\n----------------------------------------\n\nTITLE: Using UnauthorizedHttpResult in ASP.NET Core\nDESCRIPTION: API signatures for the UnauthorizedHttpResult class, which returns a 401 Unauthorized response with no content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.UnauthorizedHttpResult\nMicrosoft.AspNetCore.Http.HttpResults.UnauthorizedHttpResult.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.UnauthorizedHttpResult.StatusCode.get -> int\n```\n\n----------------------------------------\n\nTITLE: Adding Cookie Authentication in C#\nDESCRIPTION: Extension methods for adding cookie authentication to an ASP.NET Core application. These methods register cookie authentication services with various configuration options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Cookies/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.CookieExtensions.AddCookie(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\nstatic Microsoft.Extensions.DependencyInjection.CookieExtensions.AddCookie(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, string! authenticationScheme) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\nstatic Microsoft.Extensions.DependencyInjection.CookieExtensions.AddCookie(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, string! authenticationScheme, string? displayName, System.Action<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions!>! configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\nstatic Microsoft.Extensions.DependencyInjection.CookieExtensions.AddCookie(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, string! authenticationScheme, System.Action<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions!>! configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\nstatic Microsoft.Extensions.DependencyInjection.CookieExtensions.AddCookie(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, System.Action<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions!>! configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Authentication Handler Abstract Methods in C#\nDESCRIPTION: Core abstract methods that must be implemented by authentication handlers. Includes methods for handling authentication, remote authentication, sign-in, and sign-out operations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Authentication.AuthenticationHandler<TOptions>.HandleAuthenticateAsync() -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authentication.AuthenticateResult!>!\nabstract Microsoft.AspNetCore.Authentication.RemoteAuthenticationHandler<TOptions>.HandleRemoteAuthenticateAsync() -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authentication.HandleRequestResult!>!\nabstract Microsoft.AspNetCore.Authentication.SignInAuthenticationHandler<TOptions>.HandleSignInAsync(System.Security.Claims.ClaimsPrincipal! user, Microsoft.AspNetCore.Authentication.AuthenticationProperties? properties) -> System.Threading.Tasks.Task!\nabstract Microsoft.AspNetCore.Authentication.SignOutAuthenticationHandler<TOptions>.HandleSignOutAsync(Microsoft.AspNetCore.Authentication.AuthenticationProperties? properties) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Authentication and Sign-in Methods in SignInManager\nDESCRIPTION: Core authentication methods for signing in users with claims, handling two-factor authentication, managing external logins, and validating security stamps. These virtual methods can be overridden to customize authentication behavior.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Identity.SignInManager<TUser>.SignInWithClaimsAsync(TUser! user, Microsoft.AspNetCore.Authentication.AuthenticationProperties? authenticationProperties, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim!>! additionalClaims) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.SignInManager<TUser>.SignOutAsync() -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.SignInManager<TUser>.TwoFactorAuthenticatorSignInAsync(string! code, bool isPersistent, bool rememberClient) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.SignInResult!>!\nvirtual Microsoft.AspNetCore.Identity.SignInManager<TUser>.TwoFactorRecoveryCodeSignInAsync(string! recoveryCode) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.SignInResult!>!\nvirtual Microsoft.AspNetCore.Identity.SignInManager<TUser>.TwoFactorSignInAsync(string! provider, string! code, bool isPersistent, bool rememberClient) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.SignInResult!>!\nvirtual Microsoft.AspNetCore.Identity.SignInManager<TUser>.UpdateExternalAuthenticationTokensAsync(Microsoft.AspNetCore.Identity.ExternalLoginInfo! externalLogin) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\nvirtual Microsoft.AspNetCore.Identity.SignInManager<TUser>.ValidateSecurityStampAsync(System.Security.Claims.ClaimsPrincipal? principal) -> System.Threading.Tasks.Task<TUser?>!\nvirtual Microsoft.AspNetCore.Identity.SignInManager<TUser>.ValidateSecurityStampAsync(TUser? user, string? securityStamp) -> System.Threading.Tasks.Task<bool>!\nvirtual Microsoft.AspNetCore.Identity.SignInManager<TUser>.ValidateTwoFactorSecurityStampAsync(System.Security.Claims.ClaimsPrincipal? principal) -> System.Threading.Tasks.Task<TUser?>!\n```\n\n----------------------------------------\n\nTITLE: AuthorizeAttribute Class Definition in C#\nDESCRIPTION: Definition of the AuthorizeAttribute class used to require authorization for controllers or actions in MVC and API applications, supporting policies, roles, and authentication schemes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute.AuthenticationSchemes.get -> string?\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute.AuthenticationSchemes.set -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute.AuthorizeAttribute() -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute.AuthorizeAttribute(string! policy) -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute.Policy.get -> string?\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute.Policy.set -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute.Roles.get -> string?\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute.Roles.set -> void\n```\n\n----------------------------------------\n\nTITLE: Mapping Core Routes in ASP.NET Core\nDESCRIPTION: Implements the core logic for mapping routes in ASP.NET Core. It handles route patterns, HTTP methods, metadata population, and request delegate creation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Renderer Class in C#\nDESCRIPTION: This snippet defines the Renderer class, which is responsible for managing the rendering process of Blazor components. It includes methods for component instantiation, root component rendering, and event handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.RenderTree.Renderer\nMicrosoft.AspNetCore.Components.RenderTree.Renderer.AssignRootComponentId(Microsoft.AspNetCore.Components.IComponent! component) -> int\nMicrosoft.AspNetCore.Components.RenderTree.Renderer.Dispose() -> void\nMicrosoft.AspNetCore.Components.RenderTree.Renderer.DisposeAsync() -> System.Threading.Tasks.ValueTask\nMicrosoft.AspNetCore.Components.RenderTree.Renderer.ElementReferenceContext.get -> Microsoft.AspNetCore.Components.ElementReferenceContext?\nMicrosoft.AspNetCore.Components.RenderTree.Renderer.ElementReferenceContext.set -> void\nMicrosoft.AspNetCore.Components.RenderTree.Renderer.GetComponentState(int componentId) -> Microsoft.AspNetCore.Components.Rendering.ComponentState!\nMicrosoft.AspNetCore.Components.RenderTree.Renderer.GetComponentState(Microsoft.AspNetCore.Components.IComponent! component) -> Microsoft.AspNetCore.Components.Rendering.ComponentState!\nMicrosoft.AspNetCore.Components.RenderTree.Renderer.GetCurrentRenderTreeFrames(int componentId) -> Microsoft.AspNetCore.Components.RenderTree.ArrayRange<Microsoft.AspNetCore.Components.RenderTree.RenderTreeFrame>\nMicrosoft.AspNetCore.Components.RenderTree.Renderer.GetEventArgsType(ulong eventHandlerId) -> System.Type!\nMicrosoft.AspNetCore.Components.RenderTree.Renderer.InstantiateComponent(System.Type! componentType) -> Microsoft.AspNetCore.Components.IComponent!\nMicrosoft.AspNetCore.Components.RenderTree.Renderer.RemoveRootComponent(int componentId) -> void\nMicrosoft.AspNetCore.Components.RenderTree.Renderer.Renderer(System.IServiceProvider! serviceProvider, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> void\nMicrosoft.AspNetCore.Components.RenderTree.Renderer.Renderer(System.IServiceProvider! serviceProvider, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory, Microsoft.AspNetCore.Components.IComponentActivator! componentActivator) -> void\nMicrosoft.AspNetCore.Components.RenderTree.Renderer.RenderRootComponentAsync(int componentId) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Components.RenderTree.Renderer.RenderRootComponentAsync(int componentId, Microsoft.AspNetCore.Components.ParameterView initialParameters) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Components.RenderTree.Renderer.UnhandledSynchronizationException -> System.UnhandledExceptionEventHandler!\n```\n\n----------------------------------------\n\nTITLE: Initializing OpenID Connect Authentication Extension Methods\nDESCRIPTION: Extension methods for configuring OpenID Connect authentication in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.OpenIdConnectExtensions.AddOpenIdConnect(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Handling Connection Up Event in Blazor Server\nDESCRIPTION: Virtual method in CircuitHandler that's called when a circuit's connection is restored. Provides a hook for custom logic when a previously disconnected circuit reconnects.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandler.OnConnectionUpAsync(Microsoft.AspNetCore.Components.Server.Circuits.Circuit! circuit, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: JSON Response Processing in ASP.NET Core\nDESCRIPTION: Handles execution of HTTP responses, including JSON serialization and direct string writing. Includes special handling for IResult implementations and polymorphic types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BearerTokenExtensions Class in C#\nDESCRIPTION: Defines extension methods for adding Bearer Token authentication to the ASP.NET Core authentication builder. It provides multiple overloads for configuring Bearer Token authentication with different levels of customization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/BearerToken/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.DependencyInjection.BearerTokenExtensions\nstatic Microsoft.Extensions.DependencyInjection.BearerTokenExtensions.AddBearerToken(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\nstatic Microsoft.Extensions.DependencyInjection.BearerTokenExtensions.AddBearerToken(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, string! authenticationScheme) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\nstatic Microsoft.Extensions.DependencyInjection.BearerTokenExtensions.AddBearerToken(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, string! authenticationScheme, System.Action<Microsoft.AspNetCore.Authentication.BearerToken.BearerTokenOptions!>! configure) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\nstatic Microsoft.Extensions.DependencyInjection.BearerTokenExtensions.AddBearerToken(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, System.Action<Microsoft.AspNetCore.Authentication.BearerToken.BearerTokenOptions!>! configure) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Mapping GET Request with Complex Parameter Binding in ASP.NET Core\nDESCRIPTION: This snippet defines a MapGet extension method for IEndpointRouteBuilder. It sets up metadata population, request delegate creation, and handles parameter binding for a BindAsyncFromExplicitStaticAbstractInterface type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet17(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"myBindAsyncParam\", parameters[0], hasTryParse: false, hasBindAsync: true, isOptional: true));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    // ... (rest of the method implementation)\n}\n```\n\n----------------------------------------\n\nTITLE: Using SignOutHttpResult in ASP.NET Core\nDESCRIPTION: API signatures for the SignOutHttpResult class, which returns a sign-out response by signing out of all the specified authentication schemes with optional authentication properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.SignOutHttpResult\nMicrosoft.AspNetCore.Http.HttpResults.SignOutHttpResult.AuthenticationSchemes.get -> System.Collections.Generic.IReadOnlyList<string!>!\nMicrosoft.AspNetCore.Http.HttpResults.SignOutHttpResult.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.SignOutHttpResult.Properties.get -> Microsoft.AspNetCore.Authentication.AuthenticationProperties?\n```\n\n----------------------------------------\n\nTITLE: InputDate Type Property and Enum Definition in ASP.NET Core\nDESCRIPTION: API signature for the InputDate<TValue> component's Type property along with the InputDateType enum which defines the possible date input types (Date, DateTimeLocal, Month, Time).\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Forms.InputDate<TValue>.Type.get -> Microsoft.AspNetCore.Components.Forms.InputDateType\nMicrosoft.AspNetCore.Components.Forms.InputDate<TValue>.Type.set -> void\nMicrosoft.AspNetCore.Components.Forms.InputDateType\nMicrosoft.AspNetCore.Components.Forms.InputDateType.Date = 0 -> Microsoft.AspNetCore.Components.Forms.InputDateType\nMicrosoft.AspNetCore.Components.Forms.InputDateType.DateTimeLocal = 1 -> Microsoft.AspNetCore.Components.Forms.InputDateType\nMicrosoft.AspNetCore.Components.Forms.InputDateType.Month = 2 -> Microsoft.AspNetCore.Components.Forms.InputDateType\nMicrosoft.AspNetCore.Components.Forms.InputDateType.Time = 3 -> Microsoft.AspNetCore.Components.Forms.InputDateType\n```\n\n----------------------------------------\n\nTITLE: Security Stamp Validation\nDESCRIPTION: Methods for validating security stamps in Identity cookie authentication contexts. Handles verification of user security stamps and principal validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nstatic Microsoft.AspNetCore.Identity.SecurityStampValidator.ValidateAsync<TValidator>(Microsoft.AspNetCore.Authentication.Cookies.CookieValidatePrincipalContext! context) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.Identity.SecurityStampValidator.ValidatePrincipalAsync(Microsoft.AspNetCore.Authentication.Cookies.CookieValidatePrincipalContext! context) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Using MapGet for Inline Route Handler in ASP.NET Core\nDESCRIPTION: This snippet shows how to use the MapGet method to define an inline route handler directly in endpoint configuration. It demonstrates creating a simple endpoint that returns a \"Hello World\" response when accessed at the root URL.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/StaticFiles/test/FunctionalTests/SubFolder/Empty.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\napp.UseEndpoints(endpoints =>\n{\n    endpoints.MapGet(\"/\", async context =>\n    {\n        await context.Response.WriteAsync(\"Hello World!\");\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Authentication Scheme Options Class Definition in C#\nDESCRIPTION: Configuration options class for authentication schemes, including forwarding options, claims issuer settings, and event handling configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.AuthenticationSchemeOptions.AuthenticationSchemeOptions() -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationSchemeOptions.ClaimsIssuer.get -> string?\nMicrosoft.AspNetCore.Authentication.AuthenticationSchemeOptions.ClaimsIssuer.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationSchemeOptions.Events.get -> object?\nMicrosoft.AspNetCore.Authentication.AuthenticationSchemeOptions.Events.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationSchemeOptions.EventsType.get -> System.Type?\nMicrosoft.AspNetCore.Authentication.AuthenticationSchemeOptions.EventsType.set -> void\n```\n\n----------------------------------------\n\nTITLE: SignalR Hub Configuration Options Class\nDESCRIPTION: Defines configuration options for SignalR Hubs including timeout intervals, message sizes, and protocol settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class HubOptions\n{\n    public TimeSpan? ClientTimeoutInterval { get; set; }\n    public bool DisableImplicitFromServicesParameters { get; set; }\n    public bool? EnableDetailedErrors { get; set; }\n    public TimeSpan? HandshakeTimeout { get; set; }\n    public TimeSpan? KeepAliveInterval { get; set; }\n    public int MaximumParallelInvocationsPerClient { get; set; }\n    public long? MaximumReceiveMessageSize { get; set; }\n    public long StatefulReconnectBufferSize { get; set; }\n    public int? StreamBufferCapacity { get; set; }\n    public IList<string> SupportedProtocols { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Certificate Authentication Middleware\nDESCRIPTION: Configuration code for setting up certificate authentication in Program.cs. This includes adding authentication services and middleware to the application pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Certificate/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddAuthentication(\n        CertificateAuthenticationDefaults.AuthenticationScheme)\n    .AddCertificate();\n\nvar app = builder.Build();\n\napp.UseAuthentication();\n```\n\n----------------------------------------\n\nTITLE: Processing HTTP Request with Parameter Binding and Response Formatting in ASP.NET Core\nDESCRIPTION: This snippet shows the core request handling logic that checks for parameter binding failures, processes the request through a handler, and formats the response based on the result type. It differentiates between string responses (text/plain) and other responses (application/json).\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\nif (wasParamCheckFailure)\n{\n    httpContext.Response.StatusCode = 400;\n    return;\n}\nvar result = handler(myBindAsyncParam_local);\nif (result is string)\n{\n    httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n}\nelse\n{\n    httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n}\nawait httpContext.Response.WriteAsync(result);\n```\n\n----------------------------------------\n\nTITLE: Configuring Kestrel Server Options in ASP.NET Core\nDESCRIPTION: These methods allow configuring Kestrel server options using either a WebHostBuilderContext and KestrelServerOptions or just KestrelServerOptions. They extend IWebHostBuilder to provide a fluent API for configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Kestrel/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Hosting.WebHostBuilderKestrelExtensions.ConfigureKestrel(this Microsoft.AspNetCore.Hosting.IWebHostBuilder! hostBuilder, System.Action<Microsoft.AspNetCore.Hosting.WebHostBuilderContext!, Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions!>! configureOptions) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Hosting.WebHostBuilderKestrelExtensions.ConfigureKestrel(this Microsoft.AspNetCore.Hosting.IWebHostBuilder! hostBuilder, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions!>! options) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\n```\n\n----------------------------------------\n\nTITLE: Request Body Resolution for Parameter Binding in ASP.NET Core\nDESCRIPTION: Attempts to read and deserialize the HTTP request body as JSON into a strongly-typed object. Handles various error conditions like invalid content types, IO exceptions, and JSON parsing errors.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static async ValueTask<(bool, T?)> TryResolveBodyAsync<T>(HttpContext httpContext, LogOrThrowExceptionHelper logOrThrowExceptionHelper, bool allowEmpty, string parameterTypeName, string parameterName, JsonTypeInfo<T> jsonTypeInfo, bool isInferred = false)\n{\n    var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();\n    T? bodyValue = default;\n    var bodyValueSet = false;\n\n    if (feature?.CanHaveBody == true)\n    {\n        if (!httpContext.Request.HasJsonContentType())\n        {\n            logOrThrowExceptionHelper.UnexpectedJsonContentType(httpContext.Request.ContentType);\n            httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;\n            return (false, default);\n        }\n        try\n        {\n            bodyValue = await httpContext.Request.ReadFromJsonAsync(jsonTypeInfo);\n            bodyValueSet = bodyValue != null;\n        }\n        catch (BadHttpRequestException badHttpRequestException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(badHttpRequestException);\n            httpContext.Response.StatusCode = badHttpRequestException.StatusCode;\n            return (false, default);\n        }\n        catch (IOException ioException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(ioException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n        catch (System.Text.Json.JsonException jsonException)\n        {\n            logOrThrowExceptionHelper.InvalidJsonRequestBody(parameterTypeName, parameterName, jsonException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n    }\n\n    if (!allowEmpty && !bodyValueSet)\n    {\n        if (!isInferred)\n        {\n            logOrThrowExceptionHelper.RequiredParameterNotProvided(parameterTypeName, parameterName, \"body\");\n        }\n        else\n        {\n            logOrThrowExceptionHelper.ImplicitBodyNotProvided(parameterName);\n        }\n        httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n        return (false, bodyValue);\n    }\n\n    return (true, bodyValue);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Route Handler in ASP.NET Core\nDESCRIPTION: Maps HTTP GET requests to route handlers with parameter binding and validation. This method intercepts calls to IEndpointRouteBuilder.MapGet and processes route parameters, supporting parsing of custom types and applying endpoint filters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n%INTERCEPTSLOCATIONATTRIBUTE%\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: true, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(global::System.Int32), contentTypes: GeneratedMetadataConstants.JsonContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n        Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n        var handler = Cast(del, global::System.Int32 (global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[] arg0) => throw null!);\n        EndpointFilterDelegate? filteredInvocation = null;\n        var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n        var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n        var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n        var jsonSerializerOptions = jsonOptions.SerializerOptions;\n        jsonSerializerOptions.MakeReadOnly();\n        var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n        var responseJsonTypeInfo =  (JsonTypeInfo<global::System.Int32>)jsonSerializerOptions.GetTypeInfo(typeof(global::System.Int32));\n\n        if (options.EndpointBuilder.FilterFactories.Count > 0)\n        {\n            filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n            {\n                if (ic.HttpContext.Response.StatusCode == 400)\n                {\n                    return ValueTask.FromResult<object?>(Results.Empty);\n                }\n                return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[]>(0)!));\n            },\n            options.EndpointBuilder,\n            handler.Method);\n        }\n\n        Task RequestHandler(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            // Endpoint Parameter: p (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[], IsOptional = False, IsParsable = True, IsArray = True, Source = Query)\n            var p_raw = httpContext.Request.Query[\"p\"];\n            var p_temp = p_raw.ToArray();\n            global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[] p_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[p_temp.Length];\n            for (var i = 0; i < p_temp.Length; i++)\n            {\n                var element = p_temp[i];\n                if (!GeneratedRouteBuilderExtensionsCore.TryParseExplicit<global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo>(element!, CultureInfo.InvariantCulture, out var parsed_element))\n                {\n                    if (!string.IsNullOrEmpty(element))\n                    {\n                        logOrThrowExceptionHelper.ParameterBindingFailed(\"ParsableTodo[]\", \"p\", element);\n                        wasParamCheckFailure = true;\n                    }\n                }\n                p_local[i] = parsed_element!;\n            }\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n                return Task.CompletedTask;\n            }\n            var result = handler(p_local);\n            return httpContext.Response.WriteAsJsonAsync(result, responseJsonTypeInfo);\n        }\n\n        async Task RequestHandlerFiltered(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            // Endpoint Parameter: p (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[], IsOptional = False, IsParsable = True, IsArray = True, Source = Query)\n            var p_raw = httpContext.Request.Query[\"p\"];\n            var p_temp = p_raw.ToArray();\n            global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[] p_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[p_temp.Length];\n            for (var i = 0; i < p_temp.Length; i++)\n            {\n                var element = p_temp[i];\n                if (!GeneratedRouteBuilderExtensionsCore.TryParseExplicit<global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo>(element!, CultureInfo.InvariantCulture, out var parsed_element))\n                {\n                    if (!string.IsNullOrEmpty(element))\n                    {\n                        logOrThrowExceptionHelper.ParameterBindingFailed(\"ParsableTodo[]\", \"p\", element);\n                        wasParamCheckFailure = true;\n                    }\n                }\n                p_local[i] = parsed_element!;\n            }\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n            }\n            var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[]>(httpContext, p_local));\n            if (result is not null)\n            {\n                await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n            }\n        }\n\n        RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\n        var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\n        return new RequestDelegateResult(targetDelegate, metadata);\n    };\n\n\n```\n\n----------------------------------------\n\nTITLE: Mapping Routes and Verbs in ASP.NET Core\nDESCRIPTION: These extension methods allow for mapping routes and HTTP verbs to request delegates in ASP.NET Core applications. They provide flexibility in defining route templates and handling specific HTTP methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapRoute(this Microsoft.AspNetCore.Routing.IRouteBuilder! builder, string! template, Microsoft.AspNetCore.Http.RequestDelegate! handler) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\n\nstatic Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapVerb(this Microsoft.AspNetCore.Routing.IRouteBuilder! builder, string! verb, string! template, Microsoft.AspNetCore.Http.RequestDelegate! handler) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\n\nstatic Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapVerb(this Microsoft.AspNetCore.Routing.IRouteBuilder! builder, string! verb, string! template, System.Func<Microsoft.AspNetCore.Http.HttpRequest!, Microsoft.AspNetCore.Http.HttpResponse!, Microsoft.AspNetCore.Routing.RouteData!, System.Threading.Tasks.Task!>! handler) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining IWebHostBuilder Interface in C#\nDESCRIPTION: Defines the IWebHostBuilder interface with methods for configuring and building a web host.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Hosting.IWebHostBuilder\nMicrosoft.AspNetCore.Hosting.IWebHostBuilder.Build() -> Microsoft.AspNetCore.Hosting.IWebHost!\nMicrosoft.AspNetCore.Hosting.IWebHostBuilder.ConfigureAppConfiguration(System.Action<Microsoft.AspNetCore.Hosting.WebHostBuilderContext!, Microsoft.Extensions.Configuration.IConfigurationBuilder!>! configureDelegate) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\nMicrosoft.AspNetCore.Hosting.IWebHostBuilder.ConfigureServices(System.Action<Microsoft.AspNetCore.Hosting.WebHostBuilderContext!, Microsoft.Extensions.DependencyInjection.IServiceCollection!>! configureServices) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\nMicrosoft.AspNetCore.Hosting.IWebHostBuilder.ConfigureServices(System.Action<Microsoft.Extensions.DependencyInjection.IServiceCollection!>! configureServices) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\nMicrosoft.AspNetCore.Hosting.IWebHostBuilder.GetSetting(string! key) -> string?\nMicrosoft.AspNetCore.Hosting.IWebHostBuilder.UseSetting(string! key, string? value) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\n```\n\n----------------------------------------\n\nTITLE: Writing JSON to HTTP Response in ASP.NET Core\nDESCRIPTION: Extension methods for serializing objects to JSON and writing them to HTTP responses with support for content type specification and cancellation tokens\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.HttpResponseJsonExtensions.WriteAsJsonAsync<TValue>(this Microsoft.AspNetCore.Http.HttpResponse! response, TValue value, System.Text.Json.JsonSerializerOptions? options, string? contentType, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining TokenValidatedContext Class for JWT Bearer Authentication in C#\nDESCRIPTION: This class represents the context for when a JWT token has been validated. It includes a property for the security token and a constructor that initializes the context with HTTP context, authentication scheme, and options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/JwtBearer/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.JwtBearer.TokenValidatedContext\nMicrosoft.AspNetCore.Authentication.JwtBearer.TokenValidatedContext.SecurityToken.get -> Microsoft.IdentityModel.Tokens.SecurityToken!\nMicrosoft.AspNetCore.Authentication.JwtBearer.TokenValidatedContext.SecurityToken.set -> void\nMicrosoft.AspNetCore.Authentication.JwtBearer.TokenValidatedContext.TokenValidatedContext(Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Authentication.AuthenticationScheme! scheme, Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerOptions! options) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing ClientProxyExtensions in ASP.NET Core SignalR\nDESCRIPTION: Extension methods for ISingleClientProxy to simplify invoking methods on clients with varying parameter counts, providing strongly-typed wrappers around the core invoke method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.ClientProxyExtensions.InvokeAsync<T>(this Microsoft.AspNetCore.SignalR.ISingleClientProxy! clientProxy, string! method, object? arg1, object? arg2, object? arg3, object? arg4, object? arg5, object? arg6, object? arg7, object? arg8, object? arg9, object? arg10, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<T>!\nstatic Microsoft.AspNetCore.SignalR.ClientProxyExtensions.InvokeAsync<T>(this Microsoft.AspNetCore.SignalR.ISingleClientProxy! clientProxy, string! method, object? arg1, object? arg2, object? arg3, object? arg4, object? arg5, object? arg6, object? arg7, object? arg8, object? arg9, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<T>!\nstatic Microsoft.AspNetCore.SignalR.ClientProxyExtensions.InvokeAsync<T>(this Microsoft.AspNetCore.SignalR.ISingleClientProxy! clientProxy, string! method, object? arg1, object? arg2, object? arg3, object? arg4, object? arg5, object? arg6, object? arg7, object? arg8, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<T>!\nstatic Microsoft.AspNetCore.SignalR.ClientProxyExtensions.InvokeAsync<T>(this Microsoft.AspNetCore.SignalR.ISingleClientProxy! clientProxy, string! method, object? arg1, object? arg2, object? arg3, object? arg4, object? arg5, object? arg6, object? arg7, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<T>!\nstatic Microsoft.AspNetCore.SignalR.ClientProxyExtensions.InvokeAsync<T>(this Microsoft.AspNetCore.SignalR.ISingleClientProxy! clientProxy, string! method, object? arg1, object? arg2, object? arg3, object? arg4, object? arg5, object? arg6, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<T>!\nstatic Microsoft.AspNetCore.SignalR.ClientProxyExtensions.InvokeAsync<T>(this Microsoft.AspNetCore.SignalR.ISingleClientProxy! clientProxy, string! method, object? arg1, object? arg2, object? arg3, object? arg4, object? arg5, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<T>!\nstatic Microsoft.AspNetCore.SignalR.ClientProxyExtensions.InvokeAsync<T>(this Microsoft.AspNetCore.SignalR.ISingleClientProxy! clientProxy, string! method, object? arg1, object? arg2, object? arg3, object? arg4, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<T>!\nstatic Microsoft.AspNetCore.SignalR.ClientProxyExtensions.InvokeAsync<T>(this Microsoft.AspNetCore.SignalR.ISingleClientProxy! clientProxy, string! method, object? arg1, object? arg2, object? arg3, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<T>!\nstatic Microsoft.AspNetCore.SignalR.ClientProxyExtensions.InvokeAsync<T>(this Microsoft.AspNetCore.SignalR.ISingleClientProxy! clientProxy, string! method, object? arg1, object? arg2, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<T>!\nstatic Microsoft.AspNetCore.SignalR.ClientProxyExtensions.InvokeAsync<T>(this Microsoft.AspNetCore.SignalR.ISingleClientProxy! clientProxy, string! method, object? arg1, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<T>!\nstatic Microsoft.AspNetCore.SignalR.ClientProxyExtensions.InvokeAsync<T>(this Microsoft.AspNetCore.SignalR.ISingleClientProxy! clientProxy, string! method, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<T>!\n```\n\n----------------------------------------\n\nTITLE: Authentication Classes and Methods\nDESCRIPTION: Core authentication classes and methods including RemoteFailureContext, ResultContext, SecureDataFormat, SignInAuthenticationHandler, and related components. These form the foundation of ASP.NET Core's authentication system.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.RemoteFailureContext.Properties.get -> Microsoft.AspNetCore.Authentication.AuthenticationProperties?\nMicrosoft.AspNetCore.Authentication.RemoteFailureContext.Properties.set -> void\nMicrosoft.AspNetCore.Authentication.RemoteFailureContext.RemoteFailureContext(Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Authentication.AuthenticationScheme! scheme, Microsoft.AspNetCore.Authentication.RemoteAuthenticationOptions! options, System.Exception! failure) -> void\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core Route Handler Builder Configuration\nDESCRIPTION: Configuration for route handler builder including metadata population and request delegate factory setup. Handles parameter binding metadata, response type metadata, and endpoint builder configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\nMetadataPopulator populateMetadata = (methodInfo, options) =>\n{\n    Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n    Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n    options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n    var parameters = methodInfo.GetParameters();\n    options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"httpContext\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n    options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"myBindAsyncParam\", parameters[1], hasTryParse: false, hasBindAsync: true, isOptional: false));\n    options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n    return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ExecuteReturnAsync Method in C#\nDESCRIPTION: Executes the return value of an endpoint, handling different types of results including IResult, string, and JSON serializable objects.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_NoParam_StringReturn_WithFilter.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling WebTransport Connections in Kestrel\nDESCRIPTION: C# code showing how to accept and handle WebTransport sessions in a Kestrel application.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/WebTransport.md#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nhost.Run(async (context) =>\n{\n    var feature = context.Features.GetRequiredFeature<IHttpWebTransportFeature>();\n    if (!feature.IsWebTransportRequest)\n    {\n        return;\n    }\n    var session = await feature.AcceptAsync(CancellationToken.None);\n\n    // Use WebTransport via the newly established session.\n});\n\nawait host.RunAsync();\n```\n\n----------------------------------------\n\nTITLE: Resolving JSON Request Body in ASP.NET Core - C#\nDESCRIPTION: Asynchronously attempts to read and deserialize the JSON request body. Handles various error conditions like invalid content types, IO exceptions, and JSON deserialization errors. Returns a tuple with success status and the deserialized value.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitBodyParam_ComplexReturn_Snapshot.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nprivate static async ValueTask<(bool, T?)> TryResolveBodyAsync<T>(HttpContext httpContext, LogOrThrowExceptionHelper logOrThrowExceptionHelper, bool allowEmpty, string parameterTypeName, string parameterName, JsonTypeInfo<T> jsonTypeInfo, bool isInferred = false)\n{\n    var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();\n    T? bodyValue = default;\n    var bodyValueSet = false;\n\n    if (feature?.CanHaveBody == true)\n    {\n        if (!httpContext.Request.HasJsonContentType())\n        {\n            logOrThrowExceptionHelper.UnexpectedJsonContentType(httpContext.Request.ContentType);\n            httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;\n            return (false, default);\n        }\n        try\n        {\n            bodyValue = await httpContext.Request.ReadFromJsonAsync(jsonTypeInfo);\n            bodyValueSet = bodyValue != null;\n        }\n        catch (BadHttpRequestException badHttpRequestException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(badHttpRequestException);\n            httpContext.Response.StatusCode = badHttpRequestException.StatusCode;\n            return (false, default);\n        }\n        catch (IOException ioException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(ioException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n        catch (System.Text.Json.JsonException jsonException)\n        {\n            logOrThrowExceptionHelper.InvalidJsonRequestBody(parameterTypeName, parameterName, jsonException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n    }\n\n    if (!allowEmpty && !bodyValueSet)\n    {\n        if (!isInferred)\n        {\n            logOrThrowExceptionHelper.RequiredParameterNotProvided(parameterTypeName, parameterName, \"body\");\n        }\n        else\n        {\n            logOrThrowExceptionHelper.ImplicitBodyNotProvided(parameterName);\n        }\n        httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n        return (false, bodyValue);\n    }\n\n    return (true, bodyValue);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Data Protection to persist keys using EF Core\nDESCRIPTION: Extension method usage to configure ASP.NET Core Data Protection to store keys in a database context. The PersistKeysToDbContext method connects data protection with the specified database context.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/EntityFrameworkCore/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Services.AddDataProtection()\n    .PersistKeysToDbContext<MyDbContext>();\n```\n\n----------------------------------------\n\nTITLE: Streaming Typed Data from SignalR Hub in C#\nDESCRIPTION: Provides core functionality for streaming typed data from a SignalR hub method as an IAsyncEnumerable<TResult>, allowing for strongly-typed consumption of streamed data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.SignalR.Client.HubConnection.StreamAsyncCore<TResult>(string! methodName, object?[]! args, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Collections.Generic.IAsyncEnumerable<TResult>!\n```\n\n----------------------------------------\n\nTITLE: Defining TypedResults Methods for HTTP Responses in ASP.NET Core\nDESCRIPTION: A collection of static method signatures from the TypedResults class in ASP.NET Core that provide strongly-typed HTTP results for web applications. These methods create various response types including redirects, authentication responses, content responses, status codes, and file handling responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_42\n\nLANGUAGE: csharp\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.RedirectToRoute(string? routeName, Microsoft.AspNetCore.Routing.RouteValueDictionary? routeValues, bool permanent = false, bool preserveMethod = false, string? fragment = null) -> Microsoft.AspNetCore.Http.HttpResults.RedirectToRouteHttpResult!\nstatic Microsoft.AspNetCore.Http.TypedResults.SignIn(System.Security.Claims.ClaimsPrincipal! principal, Microsoft.AspNetCore.Authentication.AuthenticationProperties? properties = null, string? authenticationScheme = null) -> Microsoft.AspNetCore.Http.HttpResults.SignInHttpResult!\nstatic Microsoft.AspNetCore.Http.TypedResults.SignOut(Microsoft.AspNetCore.Authentication.AuthenticationProperties? properties = null, System.Collections.Generic.IList<string!>? authenticationSchemes = null) -> Microsoft.AspNetCore.Http.HttpResults.SignOutHttpResult!\nstatic Microsoft.AspNetCore.Http.TypedResults.StatusCode(int statusCode) -> Microsoft.AspNetCore.Http.HttpResults.StatusCodeHttpResult!\nstatic Microsoft.AspNetCore.Http.TypedResults.Stream(System.Func<System.IO.Stream!, System.Threading.Tasks.Task!>! streamWriterCallback, string? contentType = null, string? fileDownloadName = null, System.DateTimeOffset? lastModified = null, Microsoft.Net.Http.Headers.EntityTagHeaderValue? entityTag = null) -> Microsoft.AspNetCore.Http.HttpResults.PushStreamHttpResult!\nstatic Microsoft.AspNetCore.Http.TypedResults.Stream(System.IO.Pipelines.PipeReader! pipeReader, string? contentType = null, string? fileDownloadName = null, System.DateTimeOffset? lastModified = null, Microsoft.Net.Http.Headers.EntityTagHeaderValue? entityTag = null, bool enableRangeProcessing = false) -> Microsoft.AspNetCore.Http.HttpResults.FileStreamHttpResult!\nstatic Microsoft.AspNetCore.Http.TypedResults.Stream(System.IO.Stream! stream, string? contentType = null, string? fileDownloadName = null, System.DateTimeOffset? lastModified = null, Microsoft.Net.Http.Headers.EntityTagHeaderValue? entityTag = null, bool enableRangeProcessing = false) -> Microsoft.AspNetCore.Http.HttpResults.FileStreamHttpResult!\nstatic Microsoft.AspNetCore.Http.TypedResults.Text(string? content, string? contentType = null, System.Text.Encoding? contentEncoding = null, int? statusCode = null) -> Microsoft.AspNetCore.Http.HttpResults.ContentHttpResult!\nstatic Microsoft.AspNetCore.Http.TypedResults.Text(string? content, string? contentType, System.Text.Encoding? contentEncoding) -> Microsoft.AspNetCore.Http.HttpResults.ContentHttpResult!\nstatic Microsoft.AspNetCore.Http.TypedResults.Text(System.ReadOnlySpan<byte> utf8Content, string? contentType = null, int? statusCode = null) -> Microsoft.AspNetCore.Http.HttpResults.Utf8ContentHttpResult!\nstatic Microsoft.AspNetCore.Http.TypedResults.Unauthorized() -> Microsoft.AspNetCore.Http.HttpResults.UnauthorizedHttpResult!\nstatic Microsoft.AspNetCore.Http.TypedResults.UnprocessableEntity() -> Microsoft.AspNetCore.Http.HttpResults.UnprocessableEntity!\nstatic Microsoft.AspNetCore.Http.TypedResults.UnprocessableEntity<TValue>(TValue? error) -> Microsoft.AspNetCore.Http.HttpResults.UnprocessableEntity<TValue>!\nstatic Microsoft.AspNetCore.Http.TypedResults.ValidationProblem(System.Collections.Generic.IDictionary<string!, string![]!>! errors, string? detail, string? instance, string? title, string? type, System.Collections.Generic.IDictionary<string!, object?>? extensions) -> Microsoft.AspNetCore.Http.HttpResults.ValidationProblem!\nstatic Microsoft.AspNetCore.Http.TypedResults.ValidationProblem(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string!, string![]!>>! errors, string? detail = null, string? instance = null, string? title = null, string? type = null, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string!, object?>>? extensions = null) -> Microsoft.AspNetCore.Http.HttpResults.ValidationProblem!\nstatic Microsoft.AspNetCore.Http.TypedResults.VirtualFile(string! path, string? contentType = null, string? fileDownloadName = null, System.DateTimeOffset? lastModified = null, Microsoft.Net.Http.Headers.EntityTagHeaderValue? entityTag = null, bool enableRangeProcessing = false) -> Microsoft.AspNetCore.Http.HttpResults.VirtualFileHttpResult!\n```\n\n----------------------------------------\n\nTITLE: Executing Return Values in ASP.NET Core HTTP Context in C#\nDESCRIPTION: This method handles the execution of return values in an ASP.NET Core HTTP context. It supports IResult, string, and JSON serialization of other object types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsSameInterceptorsFromDifferentFiles.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MapPost1 Method for ASP.NET Core Endpoint Routing\nDESCRIPTION: Generated extension method for mapping HTTP POST endpoints with parameter binding metadata. It defines the metadata population and request delegate factory for handling POST requests with structured parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n%INTERCEPTSLOCATIONATTRIBUTE%\ninternal static RouteHandlerBuilder MapPost1(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"HttpContext\", new PropertyAsParameterInfo(false, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParameterListRecordStruct)!.GetProperty(\"HttpContext\")!), hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"Value\", new PropertyAsParameterInfo(false, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParameterListRecordStruct)!.GetProperty(\"Value\")!), hasTryParse: true, hasBindAsync: false, isOptional: false));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n```\n\n----------------------------------------\n\nTITLE: Created Response Methods in ASP.NET Core ControllerBase (C#)\nDESCRIPTION: Methods to return HTTP 201 Created responses, indicating successful resource creation. These methods support specifying the URI of the created resource and optionally including the created resource value in the response.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Created() -> Microsoft.AspNetCore.Mvc.CreatedResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Created(string? uri, object? value) -> Microsoft.AspNetCore.Mvc.CreatedResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Created(System.Uri? uri, object? value) -> Microsoft.AspNetCore.Mvc.CreatedResult!\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core Endpoint Convention Extensions\nDESCRIPTION: Extension methods for configuring endpoint conventions, including metadata, display names, form options, and group settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.RoutingEndpointConventionBuilderExtensions.WithDisplayName<TBuilder>(this TBuilder builder, string! displayName) -> TBuilder\n\nstatic Microsoft.AspNetCore.Builder.RoutingEndpointConventionBuilderExtensions.WithFormOptions<TBuilder>(this TBuilder builder, bool? bufferBody = null, int? memoryBufferThreshold = null, long? bufferBodyLengthLimit = null, int? valueCountLimit = null, int? keyLengthLimit = null, int? valueLengthLimit = null, int? multipartBoundaryLengthLimit = null, int? multipartHeadersCountLimit = null, int? multipartHeadersLengthLimit = null, long? multipartBodyLengthLimit = null) -> TBuilder\n```\n\n----------------------------------------\n\nTITLE: Local Redirect Methods in ASP.NET Core ControllerBase (C#)\nDESCRIPTION: Methods to return local redirects to URLs within the application. These methods support various redirect types including temporary, permanent, and method-preserving redirects to local URLs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.LocalRedirect(string! localUrl) -> Microsoft.AspNetCore.Mvc.LocalRedirectResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.LocalRedirectPermanent(string! localUrl) -> Microsoft.AspNetCore.Mvc.LocalRedirectResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.LocalRedirectPermanentPreserveMethod(string! localUrl) -> Microsoft.AspNetCore.Mvc.LocalRedirectResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.LocalRedirectPreserveMethod(string! localUrl) -> Microsoft.AspNetCore.Mvc.LocalRedirectResult!\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Route Handler in ASP.NET Core\nDESCRIPTION: Implements a strongly-typed route handler for GET requests with metadata population and request delegate creation. Handles parameter binding, filtering, and JSON serialization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_NullableStringArrayParam.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(global::System.Int32), contentTypes: GeneratedMetadataConstants.JsonContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    // ... rest of implementation\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Data Protection Builder in C# for ASP.NET Core\nDESCRIPTION: This snippet defines extension methods for the IDataProtectionBuilder interface in the Microsoft.AspNetCore.DataProtection namespace. These methods allow for configuration of key escrow, key management, and key persistence options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.AddKeyEscrowSink(this Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder! builder, Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink! sink) -> Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder!\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.AddKeyEscrowSink(this Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder! builder, System.Func<System.IServiceProvider!, Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink!>! factory) -> Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder!\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.AddKeyEscrowSink<TImplementation>(this Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder! builder) -> Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder!\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.AddKeyManagementOptions(this Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder! builder, System.Action<Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions!>! setupAction) -> Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder!\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.DisableAutomaticKeyGeneration(this Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder! builder) -> Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder!\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.PersistKeysToFileSystem(this Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder! builder, System.IO.DirectoryInfo! directory) -> Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder!\n```\n\n----------------------------------------\n\nTITLE: AuthorizationPolicy Class Definition in C#\nDESCRIPTION: Definition of the AuthorizationPolicy class that represents a collection of authorization requirements and authentication schemes used to authorize access to resources.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicy\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicy.AuthenticationSchemes.get -> System.Collections.Generic.IReadOnlyList<string!>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicy.AuthorizationPolicy(System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.IAuthorizationRequirement!>! requirements, System.Collections.Generic.IEnumerable<string!>! authenticationSchemes) -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicy.Requirements.get -> System.Collections.Generic.IReadOnlyList<Microsoft.AspNetCore.Authorization.IAuthorizationRequirement!>!\n```\n\n----------------------------------------\n\nTITLE: Managing Authorization Services in C#\nDESCRIPTION: These extension methods are used to add and configure authorization services in the dependency injection container. They allow for adding core authorization services and configuring authorization options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.AuthorizationServiceCollectionExtensions.AddAuthorizationCore(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.AuthorizationServiceCollectionExtensions.AddAuthorizationCore(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Authorization.AuthorizationOptions!>! configure) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Defining ResponseHeaders Class in C#\nDESCRIPTION: This snippet defines the ResponseHeaders class, which represents HTTP response headers. It includes properties and methods for accessing and manipulating various standard and custom headers in HTTP responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.Append(string! name, object! value) -> void\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.AppendList<T>(string! name, System.Collections.Generic.IList<T>! values) -> void\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.CacheControl.get -> Microsoft.Net.Http.Headers.CacheControlHeaderValue?\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.CacheControl.set -> void\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.ContentDisposition.get -> Microsoft.Net.Http.Headers.ContentDispositionHeaderValue?\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.ContentDisposition.set -> void\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.ContentLength.get -> long?\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.ContentLength.set -> void\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.ContentRange.get -> Microsoft.Net.Http.Headers.ContentRangeHeaderValue?\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.ContentRange.set -> void\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.ContentType.get -> Microsoft.Net.Http.Headers.MediaTypeHeaderValue?\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.ContentType.set -> void\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.Date.get -> System.DateTimeOffset?\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.Date.set -> void\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.ETag.get -> Microsoft.Net.Http.Headers.EntityTagHeaderValue?\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.ETag.set -> void\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.Expires.get -> System.DateTimeOffset?\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.Expires.set -> void\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.Get<T>(string! name) -> T?\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.GetList<T>(string! name) -> System.Collections.Generic.IList<T>!\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.Headers.get -> Microsoft.AspNetCore.Http.IHeaderDictionary!\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.LastModified.get -> System.DateTimeOffset?\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.LastModified.set -> void\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.Location.get -> System.Uri?\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.Location.set -> void\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.ResponseHeaders(Microsoft.AspNetCore.Http.IHeaderDictionary! headers) -> void\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.Set(string! name, object? value) -> void\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.SetCookie.get -> System.Collections.Generic.IList<Microsoft.Net.Http.Headers.SetCookieHeaderValue!>!\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.SetCookie.set -> void\nMicrosoft.AspNetCore.Http.Headers.ResponseHeaders.SetList<T>(string! name, System.Collections.Generic.IList<T>? values) -> void\n```\n\n----------------------------------------\n\nTITLE: HTTP Response Methods in ASP.NET Core\nDESCRIPTION: Static method signatures for generating different types of HTTP responses including status codes, content responses, file downloads, JSON responses, redirects, and authentication responses. These methods return IResult interfaces that can be used in ASP.NET Core endpoints and controllers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.Results.Conflict<TValue>(TValue? error) -> Microsoft.AspNetCore.Http.IResult!\nstatic Microsoft.AspNetCore.Http.Results.Content(string? content, Microsoft.Net.Http.Headers.MediaTypeHeaderValue! contentType) -> Microsoft.AspNetCore.Http.IResult!\nstatic Microsoft.AspNetCore.Http.Results.Created() -> Microsoft.AspNetCore.Http.IResult!\nstatic Microsoft.AspNetCore.Http.Results.Json<TValue>(TValue? data, System.Text.Json.JsonSerializerOptions? options = null, string? contentType = null, int? statusCode = null) -> Microsoft.AspNetCore.Http.IResult!\nstatic Microsoft.AspNetCore.Http.Results.File(byte[]! fileContents, string? contentType = null, string? fileDownloadName = null, bool enableRangeProcessing = false, System.DateTimeOffset? lastModified = null, Microsoft.Net.Http.Headers.EntityTagHeaderValue? entityTag = null) -> Microsoft.AspNetCore.Http.IResult!\nstatic Microsoft.AspNetCore.Http.Results.Redirect(string! url, bool permanent = false, bool preserveMethod = false) -> Microsoft.AspNetCore.Http.IResult!\n```\n\n----------------------------------------\n\nTITLE: Defining Remote Authentication Action Constants in C#\nDESCRIPTION: Constant string definitions for various authentication actions like login, logout, profile, and registration endpoints in ASP.NET Core WebAssembly authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationActions.LogIn = \"login\";\nconst Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationActions.LogInCallback = \"login-callback\";\nconst Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationActions.LogInFailed = \"login-failed\";\nconst Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationActions.LogOut = \"logout\";\nconst Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationActions.LogOutCallback = \"logout-callback\";\nconst Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationActions.LogOutFailed = \"logout-failed\";\nconst Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationActions.LogOutSucceeded = \"logged-out\";\nconst Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationActions.Profile = \"profile\";\nconst Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationActions.Register = \"register\";\n```\n\n----------------------------------------\n\nTITLE: Authorizing User Against Policy Name\nDESCRIPTION: Asynchronously authorizes a user against a named policy with an optional resource. Returns an AuthorizationResult indicating whether authorization was successful.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_24\n\nLANGUAGE: csharp\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authorization.DefaultAuthorizationService.AuthorizeAsync(System.Security.Claims.ClaimsPrincipal! user, object? resource, string! policyName) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authorization.AuthorizationResult!>!\n```\n\n----------------------------------------\n\nTITLE: Identity Cookie Authentication Extensions\nDESCRIPTION: Extension methods for configuring Identity cookie authentication in ASP.NET Core applications. Includes methods for adding identity cookies, two-factor authentication cookies, and user ID cookies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nstatic Microsoft.AspNetCore.Identity.IdentityCookieAuthenticationBuilderExtensions.AddIdentityCookies(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder) -> Microsoft.AspNetCore.Identity.IdentityCookiesBuilder!\nstatic Microsoft.AspNetCore.Identity.IdentityCookieAuthenticationBuilderExtensions.AddTwoFactorRememberMeCookie(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder) -> Microsoft.Extensions.Options.OptionsBuilder<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions!>!\n```\n\n----------------------------------------\n\nTITLE: SignIn Manager Class Definition\nDESCRIPTION: Core class for handling user sign-in operations in ASP.NET Core Identity. Includes properties for authentication scheme, claims factory, and user management.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.SignInManager<TUser>.SignInManager(\n    Microsoft.AspNetCore.Identity.UserManager<TUser!>! userManager,\n    Microsoft.AspNetCore.Http.IHttpContextAccessor! contextAccessor,\n    Microsoft.AspNetCore.Identity.IUserClaimsPrincipalFactory<TUser!>! claimsFactory,\n    Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Identity.IdentityOptions!>! optionsAccessor,\n    Microsoft.Extensions.Logging.ILogger<Microsoft.AspNetCore.Identity.SignInManager<TUser!>!>! logger,\n    Microsoft.AspNetCore.Authentication.IAuthenticationSchemeProvider! schemes,\n    Microsoft.AspNetCore.Identity.IUserConfirmation<TUser!>! confirmation) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining PhysicalFile Result Method in C#\nDESCRIPTION: This method creates a physical file result with various options for content type, download name, and caching.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.PhysicalFile(string! path, string? contentType = null, string? fileDownloadName = null, System.DateTimeOffset? lastModified = null, Microsoft.Net.Http.Headers.EntityTagHeaderValue? entityTag = null, bool enableRangeProcessing = false) -> Microsoft.AspNetCore.Http.HttpResults.PhysicalFileHttpResult!\n```\n\n----------------------------------------\n\nTITLE: Configuring Web Host Builder Extension Methods\nDESCRIPTION: Extension methods for IWebHostBuilder that provide configuration options for startup, logging, services and static web assets.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Hosting.WebHostBuilderExtensions.Configure(this Microsoft.AspNetCore.Hosting.IWebHostBuilder! hostBuilder, System.Action<Microsoft.AspNetCore.Builder.IApplicationBuilder!>! configureApp) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\nstatic Microsoft.AspNetCore.Hosting.WebHostBuilderExtensions.UseStartup<TStartup>(this Microsoft.AspNetCore.Hosting.IWebHostBuilder! hostBuilder) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\nstatic Microsoft.AspNetCore.Hosting.WebHostBuilderExtensions.ConfigureLogging(this Microsoft.AspNetCore.Hosting.IWebHostBuilder! hostBuilder, System.Action<Microsoft.Extensions.Logging.ILoggingBuilder!>! configureLogging) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\n```\n\n----------------------------------------\n\nTITLE: User Email Management Interface\nDESCRIPTION: Interface for managing user email operations including setting, confirming, and normalizing email addresses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.IUserEmailStore<TUser>.FindByEmailAsync(string! normalizedEmail, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TUser?>!\nMicrosoft.AspNetCore.Identity.IUserEmailStore<TUser>.SetEmailAsync(TUser! user, string? email, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining OAuthHandler<TOptions> Class in C#\nDESCRIPTION: This generic class implements the core logic for handling OAuth authentication, including properties for the backchannel HttpClient and events.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OAuth/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthHandler<TOptions>\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthHandler<TOptions>.OAuthHandler(Microsoft.Extensions.Options.IOptionsMonitor<TOptions!>! options, Microsoft.Extensions.Logging.ILoggerFactory! logger, System.Text.Encodings.Web.UrlEncoder! encoder) -> void\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthHandler<TOptions>.OAuthHandler(Microsoft.Extensions.Options.IOptionsMonitor<TOptions!>! options, Microsoft.Extensions.Logging.ILoggerFactory! logger, System.Text.Encodings.Web.UrlEncoder! encoder, Microsoft.AspNetCore.Authentication.ISystemClock! clock) -> void\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthHandler<TOptions>.Backchannel.get -> System.Net.Http.HttpClient!\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthHandler<TOptions>.Events.get -> Microsoft.AspNetCore.Authentication.OAuth.OAuthEvents!\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthHandler<TOptions>.Events.set -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring Blazor WebAssembly in Program.cs\nDESCRIPTION: Configuration code for enabling WebAssembly interactivity in a Blazor Web application. Includes service configuration, middleware setup, and component mapping with interactive WebAssembly render mode.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/Server/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Services.AddRazorComponents()\n    .AddInteractiveWebAssemblyComponents();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseWebAssemblyDebugging();\n}\n\napp.UseAntiforgery();\napp.MapStaticAssets();\napp.MapRazorComponents<App>()\n    .AddInteractiveWebAssemblyRenderMode()\n    .AddAdditionalAssemblies(typeof(BlazorWebApp.Client._Imports).Assembly);\n```\n\n----------------------------------------\n\nTITLE: Request Handler Implementation for String Route Parameter\nDESCRIPTION: Implements request handling logic for endpoints that accept a string route parameter. Handles parameter validation, response content type setting, and result writing to the response stream.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitSource_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nTask RequestHandler(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    // Endpoint Parameter: routeValue (Type = string, IsOptional = False, IsParsable = False, IsArray = False, Source = Route)\n    if (options?.RouteParameterNames?.Contains(\"routeValue\", StringComparer.OrdinalIgnoreCase) != true)\n    {\n        throw new InvalidOperationException($\"'routeValue' is not a route parameter.\");\n    }\n    var routeValue_raw = (string?)httpContext.Request.RouteValues[\"routeValue\"];\n    if (routeValue_raw == null)\n    {\n        wasParamCheckFailure = true;\n        logOrThrowExceptionHelper.RequiredParameterNotProvided(\"string\", \"routeValue\", \"route\");\n    }\n    var routeValue_temp = (string?)routeValue_raw;\n    string routeValue_local = routeValue_temp!;\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n        return Task.CompletedTask;\n    }\n    var result = handler(routeValue_local!);\n    if (result is string)\n    {\n        httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n    }\n    else\n    {\n        httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n    }\n    return httpContext.Response.WriteAsync(result);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring RequestDelegate for Header Parameter Binding in ASP.NET Core\nDESCRIPTION: Creates a RequestDelegate that binds a header parameter, performs validation, executes a handler, and writes the response. Includes support for endpoint filtering and different content types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitSource_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nTask RequestHandler(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    // Endpoint Parameter: headerValue (Type = string, IsOptional = False, IsParsable = False, IsArray = False, Source = Header)\n    var headerValue_raw = httpContext.Request.Headers[\"headerValue\"];\n    if (StringValues.IsNullOrEmpty(headerValue_raw))\n    {\n        wasParamCheckFailure = true;\n        logOrThrowExceptionHelper.RequiredParameterNotProvided(\"string\", \"headerValue\", \"header\");\n    }\n    var headerValue_temp = (string?)headerValue_raw;\n    string headerValue_local = headerValue_temp!;\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n        return Task.CompletedTask;\n    }\n    var result = handler(headerValue_local);\n    if (result is string)\n    {\n        httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n    }\n    else\n    {\n        httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n    }\n    return httpContext.Response.WriteAsync(result);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DataProtectionProvider Factory Methods in C#\nDESCRIPTION: This snippet defines static factory methods for creating IDataProtectionProvider instances with various configurations, including application name, key directory, and X509 certificate-based protection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/Extensions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionProvider.Create(string! applicationName) -> Microsoft.AspNetCore.DataProtection.IDataProtectionProvider!\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionProvider.Create(string! applicationName, System.Security.Cryptography.X509Certificates.X509Certificate2! certificate) -> Microsoft.AspNetCore.DataProtection.IDataProtectionProvider!\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionProvider.Create(System.IO.DirectoryInfo! keyDirectory) -> Microsoft.AspNetCore.DataProtection.IDataProtectionProvider!\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionProvider.Create(System.IO.DirectoryInfo! keyDirectory, System.Action<Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder!>! setupAction) -> Microsoft.AspNetCore.DataProtection.IDataProtectionProvider!\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionProvider.Create(System.IO.DirectoryInfo! keyDirectory, System.Action<Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder!>! setupAction, System.Security.Cryptography.X509Certificates.X509Certificate2! certificate) -> Microsoft.AspNetCore.DataProtection.IDataProtectionProvider!\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionProvider.Create(System.IO.DirectoryInfo! keyDirectory, System.Security.Cryptography.X509Certificates.X509Certificate2! certificate) -> Microsoft.AspNetCore.DataProtection.IDataProtectionProvider!\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a custom attribute 'InterceptsLocationAttribute' used for method interception in the System.Runtime.CompilerServices namespace.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_JsonBodyOrService_HandlesBothJsonAndService.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WebSocket Availability Check in C# for ASP.NET Core\nDESCRIPTION: This method checks if the current request can be upgraded to a WebSocket connection. It verifies the presence of the WebSockets feature and checks if the connection supports WebSockets.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Transport.NamedPipes/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic static bool IsWebSocketRequest(this HttpContext context)\n{\n    return context.Features.Get<IHttpRequestFeature>()?.Headers != null &&\n        context.Features.Get<IHttpRequestFeature>().Headers.TryGetValue(HeaderNames.Connection, out var connection) &&\n        connection.ToString().Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries).Select(s => s.Trim()).Contains(\"Upgrade\") &&\n        context.Features.Get<IHttpRequestFeature>().Headers.TryGetValue(HeaderNames.Upgrade, out var upgrade) &&\n        upgrade.ToString().Equals(\"websocket\", StringComparison.OrdinalIgnoreCase) &&\n        context.WebSockets.IsWebSocketRequest;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Negotiate Authentication in ASP.NET Core\nDESCRIPTION: Code snippet for configuring Negotiate Authentication in an ASP.NET Core application's Program.cs file. It adds Negotiate authentication and authorization services to the application.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Negotiate/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Services.AddAuthentication(NegotiateDefaults.AuthenticationScheme)\n   .AddNegotiate();\n\nbuilder.Services.AddAuthorization();\n\nvar app = builder.Build();\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet0 Method for HTTP GET Request Handling\nDESCRIPTION: Implements a method that maps HTTP GET requests to handler delegates with support for endpoint metadata, filters, and error handling. This method is used to register route handlers for GET requests in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsValidationProblemResult_Has_Metadata.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n        %INTERCEPTSLOCATIONATTRIBUTE%\n        internal static RouteHandlerBuilder MapGet0(\n            this IEndpointRouteBuilder endpoints,\n            [StringSyntax(\"Route\")] string pattern,\n            Delegate handler)\n        {\n            MetadataPopulator populateMetadata = (methodInfo, options) =>\n            {\n                Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n                Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n                options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n                PopulateMetadataForEndpoint<global::Microsoft.AspNetCore.Http.HttpResults.ValidationProblem>(methodInfo, options.EndpointBuilder);\n                return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n            };\n            RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n            {\n                Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n                Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n                Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n                Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n                var handler = Cast(del, global::Microsoft.AspNetCore.Http.HttpResults.ValidationProblem () => throw null!);\n                EndpointFilterDelegate? filteredInvocation = null;\n                var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n                var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n                var jsonSerializerOptions = jsonOptions.SerializerOptions;\n                jsonSerializerOptions.MakeReadOnly();\n                var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n\n                if (options.EndpointBuilder.FilterFactories.Count > 0)\n                {\n                    filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n                    {\n                        if (ic.HttpContext.Response.StatusCode == 400)\n                        {\n                            return ValueTask.FromResult<object?>(Results.Empty);\n                        }\n                        return ValueTask.FromResult<object?>(handler());\n                    },\n                    options.EndpointBuilder,\n                    handler.Method);\n                }\n\n                Task RequestHandler(HttpContext httpContext)\n                {\n                    var wasParamCheckFailure = false;\n                    if (wasParamCheckFailure)\n                    {\n                        httpContext.Response.StatusCode = 400;\n                        return Task.CompletedTask;\n                    }\n                    var result = handler();\n                    if (result == null)\n                    {\n                        throw new InvalidOperationException(\"The IResult returned by the Delegate must not be null.\");\n                    }\n                    return GeneratedRouteBuilderExtensionsCore.ExecuteAsyncExplicit(result, httpContext);\n                }\n\n                async Task RequestHandlerFiltered(HttpContext httpContext)\n                {\n                    var wasParamCheckFailure = false;\n                    if (wasParamCheckFailure)\n                    {\n                        httpContext.Response.StatusCode = 400;\n                    }\n                    var result = await filteredInvocation(EndpointFilterInvocationContext.Create(httpContext));\n                    if (result is not null)\n                    {\n                        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n                    }\n                }\n\n                RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\n                var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\n                return new RequestDelegateResult(targetDelegate, metadata);\n            };\n            var castHandler = Cast(handler, global::Microsoft.AspNetCore.Http.HttpResults.ValidationProblem () => throw null!);\n            return MapCore(\n                endpoints,\n                pattern,\n                handler,\n                GetVerb,\n                populateMetadata,\n                createRequestDelegate,\n                castHandler.Method);\n        }\n```\n\n----------------------------------------\n\nTITLE: Executing Response Results in ASP.NET Core Request Handlers\nDESCRIPTION: Handles different response types (IResult, string, or other objects) and executes the appropriate response writing method. It includes special handling for strings and JSON serialization for other object types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_NullableReturn.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IPolicyEvaluator Interface in C#\nDESCRIPTION: Declares the IPolicyEvaluator interface with methods for authenticating and authorizing policies in the context of HTTP requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Policy/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.Policy.IPolicyEvaluator\nMicrosoft.AspNetCore.Authorization.Policy.IPolicyEvaluator.AuthenticateAsync(Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy, Microsoft.AspNetCore.Http.HttpContext! context) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authentication.AuthenticateResult!>!\nMicrosoft.AspNetCore.Authorization.Policy.IPolicyEvaluator.AuthorizeAsync(Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy, Microsoft.AspNetCore.Authentication.AuthenticateResult! authenticationResult, Microsoft.AspNetCore.Http.HttpContext! context, object? resource) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authorization.Policy.PolicyAuthorizationResult!>!\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Response Methods in ControllerBase for ASP.NET Core MVC\nDESCRIPTION: These methods provide ways to return various HTTP status codes and results in ASP.NET Core MVC applications, including status codes, unauthorized responses, and unprocessable entity responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_61\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.StatusCode(int statusCode) -> Microsoft.AspNetCore.Mvc.StatusCodeResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.StatusCode(int statusCode, object? value) -> Microsoft.AspNetCore.Mvc.ObjectResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Unauthorized() -> Microsoft.AspNetCore.Mvc.UnauthorizedResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Unauthorized(object? value) -> Microsoft.AspNetCore.Mvc.UnauthorizedObjectResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.UnprocessableEntity() -> Microsoft.AspNetCore.Mvc.UnprocessableEntityResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.UnprocessableEntity(Microsoft.AspNetCore.Mvc.ModelBinding.ModelStateDictionary! modelState) -> Microsoft.AspNetCore.Mvc.UnprocessableEntityObjectResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.UnprocessableEntity(object? error) -> Microsoft.AspNetCore.Mvc.UnprocessableEntityObjectResult!\n```\n\n----------------------------------------\n\nTITLE: Handling HTTP Requests with Parameter Binding in C#\nDESCRIPTION: This snippet defines methods for handling HTTP requests with parameter binding. It includes logic for processing request parameters, executing handlers, and writing responses based on the result type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitServiceParam_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandlerFiltered(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    // Endpoint Parameter: svc (Type = Microsoft.AspNetCore.Http.Generators.Tests.TestService?, IsOptional = True, IsParsable = False, IsArray = False, Source = Service)\n    var svc_local = httpContext.RequestServices.GetService<global::Microsoft.AspNetCore.Http.Generators.Tests.TestService?>();;\n    // Endpoint Parameter: svcs (Type = System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Http.Generators.Tests.TestService>, IsOptional = False, IsParsable = False, IsArray = False, Source = Service)\n    var svcs_local = httpContext.RequestServices.GetRequiredService<global::System.Collections.Generic.IEnumerable<global::Microsoft.AspNetCore.Http.Generators.Tests.TestService>>();\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n    }\n    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.TestService?, global::System.Collections.Generic.IEnumerable<global::Microsoft.AspNetCore.Http.Generators.Tests.TestService>>(httpContext, svc_local, svcs_local));\n    if (result is not null)\n    {\n        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IHeaderDictionary Interface in ASP.NET Core\nDESCRIPTION: Interface definition for HTTP header dictionary providing strongly-typed access to common HTTP headers. Includes getters and setters for standard headers like Content-Type, Authorization, and Cache-Control.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Features/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.IHeaderDictionary {\n    StringValues this[string key] { get; set; }\n    StringValues Host { get; set; }\n    StringValues ContentType { get; set; }\n    StringValues Authorization { get; set; }\n    // Additional header properties...\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in C#\nDESCRIPTION: Method to handle invalid form request body scenarios, including parameter type and name information. Provides both exception throwing and logging capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Body Logger in ASP.NET Core\nDESCRIPTION: Defines a structured logger for tracking when an implicit body is inferred but not provided. Creates a reusable logging delegate that formats a consistent message with parameter name at Debug level with EventId 5, including a suggestion about using a Service instead.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndGet_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n```\n\n----------------------------------------\n\nTITLE: Defining MapPatch Extension Method for IEndpointRouteBuilder in ASP.NET Core\nDESCRIPTION: Internal extension method declaration that maps HTTP PATCH requests to a specified route pattern using a delegate handler. The method signature shows the parameters needed for creating a route handler.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapPatch3(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Parameter Binding Metadata for ASP.NET Core Endpoints in C#\nDESCRIPTION: Sets up parameter binding metadata for an endpoint that uses a ParametersListWithMetadataType object. It adds metadata for HttpContext and Value parameters and populates additional metadata for custom parameter types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\noptions.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"HttpContext\", new PropertyAsParameterInfo(false, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType)!.GetProperty(\"HttpContext\")!, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType).GetConstructor(new[] { typeof(Microsoft.AspNetCore.Http.HttpContext), typeof(Microsoft.AspNetCore.Http.Generators.Tests.AddsCustomParameterMetadataAsProperty) })?.GetParameters()[0]), hasTryParse: false, hasBindAsync: false, isOptional: false));\noptions.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"Value\", new PropertyAsParameterInfo(false, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType)!.GetProperty(\"Value\")!, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType).GetConstructor(new[] { typeof(Microsoft.AspNetCore.Http.HttpContext), typeof(Microsoft.AspNetCore.Http.Generators.Tests.AddsCustomParameterMetadataAsProperty) })?.GetParameters()[1]), hasTryParse: false, hasBindAsync: false, isOptional: false));\nvar parameterInfos = methodInfo.GetParameters();\nvar Value_ParameterInfo = new PropertyAsParameterInfo(false, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType)!.GetProperty(\"Value\")!, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType).GetConstructor(new[] { typeof(Microsoft.AspNetCore.Http.HttpContext), typeof(Microsoft.AspNetCore.Http.Generators.Tests.AddsCustomParameterMetadataAsProperty) })?.GetParameters()[1]);\nPopulateMetadataForParameter<global::Microsoft.AspNetCore.Http.Generators.Tests.AddsCustomParameterMetadataAsProperty>(Value_ParameterInfo, options.EndpointBuilder);\nPopulateMetadataForEndpoint<global::Microsoft.AspNetCore.Http.Generators.Tests.AddsCustomParameterMetadataAsProperty>(methodInfo, options.EndpointBuilder);\nreturn new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n```\n\n----------------------------------------\n\nTITLE: Defining ISignalRBuilder Interface in ASP.NET Core SignalR (C#)\nDESCRIPTION: Interface for the SignalR builder used in the ASP.NET Core dependency injection system. Provides access to the services collection for adding and configuring SignalR services.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.ISignalRBuilder\nMicrosoft.AspNetCore.SignalR.ISignalRBuilder.Services.get -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Request Handling Error Logger in C#\nDESCRIPTION: Implements error logging and exception handling for request processing. Handles various error scenarios including IO exceptions, JSON parsing errors, parameter binding failures, and content type mismatches.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    // Additional methods for handling specific error scenarios...\n}\n```\n\n----------------------------------------\n\nTITLE: Role Management Interfaces in ASP.NET Core Identity\nDESCRIPTION: Interfaces for managing roles including updating and validating roles. Includes IRoleStore and IRoleValidator interfaces.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.IRoleStore<TRole>.UpdateAsync(TRole! role, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\nMicrosoft.AspNetCore.Identity.IRoleValidator<TRole>.ValidateAsync(Microsoft.AspNetCore.Identity.RoleManager<TRole!>! manager, TRole! role) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\n```\n\n----------------------------------------\n\nTITLE: Adding Certificate Authentication Extensions in ASP.NET Core\nDESCRIPTION: Extension methods for configuring certificate authentication in an ASP.NET Core application. Includes overloads for custom authentication schemes and configuration options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Certificate/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.CertificateAuthenticationAppBuilderExtensions.AddCertificate(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, string! authenticationScheme, System.Action<Microsoft.AspNetCore.Authentication.Certificate.CertificateAuthenticationOptions!>? configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.CertificateAuthenticationAppBuilderExtensions.AddCertificate(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, System.Action<Microsoft.AspNetCore.Authentication.Certificate.CertificateAuthenticationOptions!>? configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.CertificateAuthenticationAppBuilderExtensions.AddCertificateCache(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, System.Action<Microsoft.AspNetCore.Authentication.Certificate.CertificateValidationCacheOptions!>? configureOptions = null) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining JwtBearerExtensions for Authentication Configuration in C#\nDESCRIPTION: These extension methods provide various overloads for adding JWT Bearer authentication to the ASP.NET Core authentication builder. They allow for customization of authentication schemes and options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/JwtBearer/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.JwtBearerExtensions.AddJwtBearer(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\nstatic Microsoft.Extensions.DependencyInjection.JwtBearerExtensions.AddJwtBearer(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, string! authenticationScheme) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\nstatic Microsoft.Extensions.DependencyInjection.JwtBearerExtensions.AddJwtBearer(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, string! authenticationScheme, string? displayName, System.Action<Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerOptions!>! configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\nstatic Microsoft.Extensions.DependencyInjection.JwtBearerExtensions.AddJwtBearer(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, string! authenticationScheme, System.Action<Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerOptions!>! configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\nstatic Microsoft.Extensions.DependencyInjection.JwtBearerExtensions.AddJwtBearer(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, System.Action<Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerOptions!>! configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Creating Date/Time Binders in ASP.NET Core Components\nDESCRIPTION: Extension methods for EventCallbackFactory that create data binding callbacks for date and time types (DateOnly, DateTime, DateTimeOffset, TimeOnly) in both nullable and non-nullable forms. These methods support optional format strings for date/time parsing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<System.DateOnly?>! setter, System.DateOnly? existingValue, string! format, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<System.DateOnly?>! setter, System.DateOnly? existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<System.DateOnly>! setter, System.DateOnly existingValue, string! format, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<System.DateOnly>! setter, System.DateOnly existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<System.DateTime?>! setter, System.DateTime? existingValue, string! format, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<System.DateTime?>! setter, System.DateTime? existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<System.DateTime>! setter, System.DateTime existingValue, string! format, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<System.DateTime>! setter, System.DateTime existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<System.DateTimeOffset?>! setter, System.DateTimeOffset? existingValue, string! format, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<System.DateTimeOffset?>! setter, System.DateTimeOffset? existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<System.DateTimeOffset>! setter, System.DateTimeOffset existingValue, string! format, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<System.DateTimeOffset>! setter, System.DateTimeOffset existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<System.TimeOnly?>! setter, System.TimeOnly? existingValue, string! format, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<System.TimeOnly?>! setter, System.TimeOnly? existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<System.TimeOnly>! setter, System.TimeOnly existingValue, string! format, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<System.TimeOnly>! setter, System.TimeOnly existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Non-Form Content Type in ASP.NET Core\nDESCRIPTION: Method that handles cases where the request contains an unexpected non-form content type. It either throws a BadHttpRequestException with a 415 status code or logs the issue depending on configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitBodyParam_ComplexReturn_Snapshot.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core MVC Interface Definitions\nDESCRIPTION: Core interface definitions and property accessors for ASP.NET Core MVC's dependency injection and application parts management\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.DependencyInjection.IMvcCoreBuilder.PartManager.get -> Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartManager!\nMicrosoft.Extensions.DependencyInjection.IMvcCoreBuilder.Services.get -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Authentication HttpContext Extension Methods in C#\nDESCRIPTION: Extension methods for HttpContext providing convenient authentication operations like authenticate, challenge, forbid, sign in/out and token retrieval.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Authentication.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nstatic class AuthenticationHttpContextExtensions {\n    static Task<AuthenticateResult> AuthenticateAsync(this HttpContext context, string? scheme);\n    static Task ChallengeAsync(this HttpContext context, string? scheme, AuthenticationProperties? properties);\n    static Task ForbidAsync(this HttpContext context, string? scheme);\n    static Task<string?> GetTokenAsync(this HttpContext context, string tokenName);\n    static Task SignInAsync(this HttpContext context, string? scheme, ClaimsPrincipal principal);\n}\n```\n\n----------------------------------------\n\nTITLE: Cookie Authentication Handler Methods in C#\nDESCRIPTION: Override methods of the CookieAuthenticationHandler class that handle various authentication operations like sign-in, sign-out, challenge, and request authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Cookies/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationHandler.CreateEventsAsync() -> System.Threading.Tasks.Task<object!>!\noverride Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationHandler.HandleAuthenticateAsync() -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authentication.AuthenticateResult!>!\noverride Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationHandler.HandleChallengeAsync(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationHandler.HandleForbiddenAsync(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationHandler.HandleSignInAsync(System.Security.Claims.ClaimsPrincipal! user, Microsoft.AspNetCore.Authentication.AuthenticationProperties? properties) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationHandler.HandleSignOutAsync(Microsoft.AspNetCore.Authentication.AuthenticationProperties? properties) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationHandler.InitializeHandlerAsync() -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Route Handler in C# for ASP.NET Core\nDESCRIPTION: Defines a MapGet extension method for IEndpointRouteBuilder to create a GET route handler with parameter binding and metadata population. It includes logic for JSON serialization and endpoint filtering.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedRouteBuilderExtensionsCore\n{\n    private static readonly JsonOptions FallbackJsonOptions = new();\n    private static readonly string[] GetVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Get };\n\n    %INTERCEPTSLOCATIONATTRIBUTE%\n    internal static RouteHandlerBuilder MapGet0(\n        this IEndpointRouteBuilder endpoints,\n        [StringSyntax(\"Route\")] string pattern,\n        Delegate handler)\n    {\n        MetadataPopulator populateMetadata = (methodInfo, options) =>\n        {\n            Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n            Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n            options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n            var parameters = methodInfo.GetParameters();\n            options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: true, hasBindAsync: false, isOptional: false));\n            options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(global::System.Int32), contentTypes: GeneratedMetadataConstants.JsonContentType));\n            return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n        };\n        RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n        {\n            Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n            Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n            Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n            Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n            var handler = Cast(del, global::System.Int32 (global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[] arg0) => throw null!);\n            EndpointFilterDelegate? filteredInvocation = null;\n            var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n            var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n            var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n            var jsonSerializerOptions = jsonOptions.SerializerOptions;\n            jsonSerializerOptions.MakeReadOnly();\n            var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n            var responseJsonTypeInfo =  (JsonTypeInfo<global::System.Int32>)jsonSerializerOptions.GetTypeInfo(typeof(global::System.Int32));\n\n            if (options.EndpointBuilder.FilterFactories.Count > 0)\n            {\n                filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n                {\n                    if (ic.HttpContext.Response.StatusCode == 400)\n                    {\n                        return ValueTask.FromResult<object?>(Results.Empty);\n                    }\n                    return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[]>(0)!));\n                },\n                options.EndpointBuilder,\n                handler.Method);\n            }\n\n            Task RequestHandler(HttpContext httpContext)\n            {\n                var wasParamCheckFailure = false;\n                // Endpoint Parameter: p (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[], IsOptional = False, IsParsable = True, IsArray = True, Source = Header)\n                var p_raw = httpContext.Request.Headers.GetCommaSeparatedValues(\"p\");\n                var p_temp = p_raw.ToArray();\n                global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[] p_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[p_temp.Length];\n                for (var i = 0; i < p_temp.Length; i++)\n                {\n                    var element = p_temp[i];\n                    if (!GeneratedRouteBuilderExtensionsCore.TryParseExplicit<global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo>(element!, CultureInfo.InvariantCulture, out var parsed_element))\n                    {\n                        if (!string.IsNullOrEmpty(element))\n                        {\n                            logOrThrowExceptionHelper.ParameterBindingFailed(\"ParsableTodo[]\", \"p\", element);\n                            wasParamCheckFailure = true;\n                        }\n                    }\n                    p_local[i] = parsed_element!;\n                }\n\n                if (wasParamCheckFailure)\n                {\n                    httpContext.Response.StatusCode = 400;\n                    return Task.CompletedTask;\n                }\n                var result = handler(p_local);\n                return httpContext.Response.WriteAsJsonAsync(result, responseJsonTypeInfo);\n            }\n\n            async Task RequestHandlerFiltered(HttpContext httpContext)\n            {\n                var wasParamCheckFailure = false;\n                // Endpoint Parameter: p (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[], IsOptional = False, IsParsable = True, IsArray = True, Source = Header)\n                var p_raw = httpContext.Request.Headers.GetCommaSeparatedValues(\"p\");\n                var p_temp = p_raw.ToArray();\n                global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[] p_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[p_temp.Length];\n                for (var i = 0; i < p_temp.Length; i++)\n                {\n                    var element = p_temp[i];\n                    if (!GeneratedRouteBuilderExtensionsCore.TryParseExplicit<global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo>(element!, CultureInfo.InvariantCulture, out var parsed_element))\n                    {\n                        if (!string.IsNullOrEmpty(element))\n                        {\n                            logOrThrowExceptionHelper.ParameterBindingFailed(\"ParsableTodo[]\", \"p\", element);\n                            wasParamCheckFailure = true;\n                        }\n                    }\n                    p_local[i] = parsed_element!;\n                }\n\n                if (wasParamCheckFailure)\n                {\n                    httpContext.Response.StatusCode = 400;\n                }\n                var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.ParsableTodo[]>(httpContext, p_local));\n                if (result is not null)\n                {\n                    await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n                }\n            }\n\n            RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\n            var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\n            return new RequestDelegateResult(targetDelegate, metadata);\n        };\n        // ... (remaining code omitted for brevity)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding OpenID Connect Authentication to ASP.NET Core\nDESCRIPTION: Extension methods for registering OpenID Connect authentication with ASP.NET Core's authentication system. These methods add the OpenID Connect authentication handler to the application's authentication pipeline with various configuration options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.OpenIdConnectExtensions.AddOpenIdConnect(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, string! authenticationScheme, string? displayName, System.Action<Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectOptions!>! configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\nstatic Microsoft.Extensions.DependencyInjection.OpenIdConnectExtensions.AddOpenIdConnect(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, string! authenticationScheme, System.Action<Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectOptions!>! configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\nstatic Microsoft.Extensions.DependencyInjection.OpenIdConnectExtensions.AddOpenIdConnect(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, System.Action<Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectOptions!>! configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Exception Handling and Logging Helper for ASP.NET Core - C#\nDESCRIPTION: Helper class for logging errors and/or throwing exceptions based on configuration. Handles various error scenarios like invalid JSON, parameter binding failures, and missing required parameters. Uses structured logging with LoggerMessage patterns.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitBodyParam_ComplexReturn_Snapshot.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n\n    public void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n\n    public void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n\n    public void ImplicitBodyNotProvided(string parameterName)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n\n    public void UnexpectedJsonContentType(string? contentType)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n            throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n```\n\n----------------------------------------\n\nTITLE: Combining Authorization Policies in C#\nDESCRIPTION: These methods allow for combining multiple AuthorizationPolicy objects into a single policy. They can work with an array of policies or an IEnumerable collection, and there's an asynchronous version that works with an IAuthorizationPolicyProvider.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Authorization.AuthorizationPolicy.Combine(params Microsoft.AspNetCore.Authorization.AuthorizationPolicy![]! policies) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicy!\nstatic Microsoft.AspNetCore.Authorization.AuthorizationPolicy.Combine(System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.AuthorizationPolicy!>! policies) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicy!\nstatic Microsoft.AspNetCore.Authorization.AuthorizationPolicy.CombineAsync(Microsoft.AspNetCore.Authorization.IAuthorizationPolicyProvider! policyProvider, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.IAuthorizeData!>! authorizeData) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authorization.AuthorizationPolicy?>!\n```\n\n----------------------------------------\n\nTITLE: Sign-In and Sign-Out Extension Methods for HttpContext in ASP.NET Core\nDESCRIPTION: Extension methods for HttpContext that provide simplified access to authentication sign-in and sign-out functionality. These methods allow for authenticating users with or without specific schemes and authentication properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Authentication.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Authentication.AuthenticationHttpContextExtensions.SignInAsync(this Microsoft.AspNetCore.Http.HttpContext! context, System.Security.Claims.ClaimsPrincipal! principal) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.Authentication.AuthenticationHttpContextExtensions.SignInAsync(this Microsoft.AspNetCore.Http.HttpContext! context, System.Security.Claims.ClaimsPrincipal! principal, Microsoft.AspNetCore.Authentication.AuthenticationProperties? properties) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.Authentication.AuthenticationHttpContextExtensions.SignOutAsync(this Microsoft.AspNetCore.Http.HttpContext! context) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.Authentication.AuthenticationHttpContextExtensions.SignOutAsync(this Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Authentication.AuthenticationProperties? properties) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.Authentication.AuthenticationHttpContextExtensions.SignOutAsync(this Microsoft.AspNetCore.Http.HttpContext! context, string? scheme) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.Authentication.AuthenticationHttpContextExtensions.SignOutAsync(this Microsoft.AspNetCore.Http.HttpContext! context, string? scheme, Microsoft.AspNetCore.Authentication.AuthenticationProperties? properties) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Cookie Authentication Constants\nDESCRIPTION: Default constants used in cookie authentication including chunk size and authentication scheme name.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Cookies/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.Authentication.Cookies.ChunkingCookieManager.DefaultChunkSize = 4050\nconst Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationDefaults.AuthenticationScheme = \"Cookies\"\n```\n\n----------------------------------------\n\nTITLE: Data Protection Builder Extensions\nDESCRIPTION: Extension methods for IDataProtectionBuilder to configure various aspects of data protection including key storage, encryption, and lifetime settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.PersistKeysToRegistry(this Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder! builder, Microsoft.Win32.RegistryKey! registryKey) -> Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder!\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.ProtectKeysWithCertificate(this Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder! builder, string! thumbprint) -> Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder!\n```\n\n----------------------------------------\n\nTITLE: MapGet Route Handler Builder Extension\nDESCRIPTION: Extension method for IEndpointRouteBuilder that configures GET endpoint handling with metadata population and request delegate creation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitSource_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet3(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n```\n\n----------------------------------------\n\nTITLE: Implementing MapPost Route Handler in ASP.NET Core\nDESCRIPTION: Implements a route handler extension method for POST requests that processes form data including file uploads. Handles metadata population and request delegate creation with parameter binding.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/RequestDelegateValidateGeneratedFormCode.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapPost0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        options.EndpointBuilder.Metadata.Add(AntiforgeryMetadata.ValidationRequired);\n        options.EndpointBuilder.Metadata.Add(new AcceptsMetadata(contentTypes: GeneratedMetadataConstants.FormFileContentType));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"httpContext\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"file\", parameters[1], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"fileCollection\", parameters[2], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"collection\", parameters[3], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"tryParseRecord\", parameters[4], hasTryParse: true, hasBindAsync: false, isOptional: false));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n```\n\n----------------------------------------\n\nTITLE: Configuring Authorization for Areas in ASP.NET Core Razor Pages\nDESCRIPTION: Extension methods for PageConventionCollection that configure authorization for pages and folders within areas. These methods allow developers to require authentication with optional policy specification for Razor Pages in specific areas.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.PageConventionCollectionExtensions.AuthorizeAreaFolder(this Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection! conventions, string! areaName, string! folderPath) -> Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection!\nstatic Microsoft.Extensions.DependencyInjection.PageConventionCollectionExtensions.AuthorizeAreaFolder(this Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection! conventions, string! areaName, string! folderPath, string! policy) -> Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection!\nstatic Microsoft.Extensions.DependencyInjection.PageConventionCollectionExtensions.AuthorizeAreaPage(this Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection! conventions, string! areaName, string! pageName) -> Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection!\nstatic Microsoft.Extensions.DependencyInjection.PageConventionCollectionExtensions.AuthorizeAreaPage(this Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection! conventions, string! areaName, string! pageName, string! policy) -> Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection!\n```\n\n----------------------------------------\n\nTITLE: Logging and Exception Handling Helper in ASP.NET Core\nDESCRIPTION: This class provides methods for logging errors and optionally throwing exceptions during request processing. It handles various scenarios such as IO exceptions, invalid JSON, parameter binding failures, and missing required parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    // Additional methods for other error scenarios...\n}\n```\n\n----------------------------------------\n\nTITLE: UserStoreBase Virtual Method Signatures for User Management in ASP.NET Core Identity\nDESCRIPTION: Defines virtual method signatures for the UserStoreBase class that handle user information and authentication settings. These methods are responsible for operations like setting user credentials, managing email information, handling phone numbers, configuring two-factor authentication, managing security tokens, and handling user-role relationships.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Stores/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.SetAuthenticatorKeyAsync(TUser! user, string! key, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.SetEmailAsync(TUser! user, string? email, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.SetEmailConfirmedAsync(TUser! user, bool confirmed, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.SetLockoutEnabledAsync(TUser! user, bool enabled, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.SetLockoutEndDateAsync(TUser! user, System.DateTimeOffset? lockoutEnd, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.SetNormalizedEmailAsync(TUser! user, string? normalizedEmail, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.SetNormalizedUserNameAsync(TUser! user, string? normalizedName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.SetPasswordHashAsync(TUser! user, string? passwordHash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.SetPhoneNumberAsync(TUser! user, string? phoneNumber, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.SetPhoneNumberConfirmedAsync(TUser! user, bool confirmed, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.SetSecurityStampAsync(TUser! user, string! stamp, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.SetTokenAsync(TUser! user, string! loginProvider, string! name, string? value, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.SetTwoFactorEnabledAsync(TUser! user, bool enabled, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.SetUserNameAsync(TUser! user, string? userName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.CreateUserRole(TUser! user, TRole! role) -> TUserRole!\n```\n\n----------------------------------------\n\nTITLE: Antiforgery Middleware Extension\nDESCRIPTION: Extension method for adding antiforgery middleware to the ASP.NET Core request pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Antiforgery/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.AntiforgeryApplicationBuilderExtensions.UseAntiforgery(this Microsoft.AspNetCore.Builder.IApplicationBuilder! builder) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: CascadingValue Component Implementation\nDESCRIPTION: Defines the CascadingValue generic component class that enables passing data down through the component hierarchy.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.CascadingValue<TValue>\nMicrosoft.AspNetCore.Components.CascadingValue<TValue>.Attach(Microsoft.AspNetCore.Components.RenderHandle renderHandle) -> void\nMicrosoft.AspNetCore.Components.CascadingValue<TValue>.CascadingValue() -> void\n```\n\n----------------------------------------\n\nTITLE: MVC Core Builder Extensions for Configuration in ASP.NET Core\nDESCRIPTION: Extension methods for IMvcBuilder to configure MVC Core services. These methods enable adding application parts, registering controllers as services, configuring formatter mappings, JSON options, MVC options, API behavior options, and application part managers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.MvcCoreMvcBuilderExtensions.AddApplicationPart(this Microsoft.Extensions.DependencyInjection.IMvcBuilder! builder, System.Reflection.Assembly! assembly) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\nstatic Microsoft.Extensions.DependencyInjection.MvcCoreMvcBuilderExtensions.AddControllersAsServices(this Microsoft.Extensions.DependencyInjection.IMvcBuilder! builder) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\nstatic Microsoft.Extensions.DependencyInjection.MvcCoreMvcBuilderExtensions.AddFormatterMappings(this Microsoft.Extensions.DependencyInjection.IMvcBuilder! builder, System.Action<Microsoft.AspNetCore.Mvc.Formatters.FormatterMappings!>! setupAction) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\nstatic Microsoft.Extensions.DependencyInjection.MvcCoreMvcBuilderExtensions.AddJsonOptions(this Microsoft.Extensions.DependencyInjection.IMvcBuilder! builder, System.Action<Microsoft.AspNetCore.Mvc.JsonOptions!>! configure) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\nstatic Microsoft.Extensions.DependencyInjection.MvcCoreMvcBuilderExtensions.AddMvcOptions(this Microsoft.Extensions.DependencyInjection.IMvcBuilder! builder, System.Action<Microsoft.AspNetCore.Mvc.MvcOptions!>! setupAction) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\nstatic Microsoft.Extensions.DependencyInjection.MvcCoreMvcBuilderExtensions.ConfigureApiBehaviorOptions(this Microsoft.Extensions.DependencyInjection.IMvcBuilder! builder, System.Action<Microsoft.AspNetCore.Mvc.ApiBehaviorOptions!>! setupAction) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\nstatic Microsoft.Extensions.DependencyInjection.MvcCoreMvcBuilderExtensions.ConfigureApplicationPartManager(this Microsoft.Extensions.DependencyInjection.IMvcBuilder! builder, System.Action<Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartManager!>! setupAction) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\n```\n\n----------------------------------------\n\nTITLE: Extending IHubClients with Groups Methods in C#\nDESCRIPTION: Extension methods for IHubClients<T> to send messages to multiple groups. These methods provide overloads for specifying up to 8 group names individually or using an IEnumerable<string>.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.HubClientsExtensions.Groups<T>(this Microsoft.AspNetCore.SignalR.IHubClients<T>! hubClients, string! group1) -> T\n```\n\n----------------------------------------\n\nTITLE: Writing JSON Response in ASP.NET Core\nDESCRIPTION: Implements JSON response writing with support for polymorphic types and runtime type checking. Includes safety attributes for trimming and AOT compilation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MapCore Method for Endpoint Registration\nDESCRIPTION: A utility method that handles the core functionality of mapping endpoints in ASP.NET Core. It bridges between the route builder extensions and the RouteHandlerServices.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_StringArrayParam.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Model Binding and Validation Methods in ControllerBase for ASP.NET Core MVC\nDESCRIPTION: These methods provide functionality for model binding and validation in ASP.NET Core MVC applications, including updating models and validating model state.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_62\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.TryUpdateModelAsync(object! model, System.Type! modelType, string! prefix) -> System.Threading.Tasks.Task<bool>!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.TryUpdateModelAsync<TModel>(TModel! model) -> System.Threading.Tasks.Task<bool>!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.TryUpdateModelAsync<TModel>(TModel! model, string! prefix) -> System.Threading.Tasks.Task<bool>!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.TryUpdateModelAsync<TModel>(TModel! model, string! prefix, Microsoft.AspNetCore.Mvc.ModelBinding.IValueProvider! valueProvider) -> System.Threading.Tasks.Task<bool>!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.TryValidateModel(object! model) -> bool\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.TryValidateModel(object! model, string? prefix) -> bool\n```\n\n----------------------------------------\n\nTITLE: Enabling CORS Middleware in ASP.NET Core\nDESCRIPTION: This code snippet defines extension methods for IApplicationBuilder to add CORS middleware to the ASP.NET Core request pipeline. It allows for configuring CORS policies with default or custom settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Features/JsonPatch/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic static class CorsMiddlewareExtensions\n{\n    /// <summary>\n    /// Adds the CORS middleware to the specified <see cref=\"IApplicationBuilder\"/>, which enables cross-origin resource sharing.\n    /// </summary>\n    /// <param name=\"app\">The <see cref=\"IApplicationBuilder\"/> to add the middleware to.</param>\n    /// <returns>A reference to this instance after the operation has completed.</returns>\n    public static IApplicationBuilder UseCors(this IApplicationBuilder app)\n    {\n        if (app == null)\n        {\n            throw new ArgumentNullException(nameof(app));\n        }\n\n        return app.UseMiddleware<CorsMiddleware>();\n    }\n\n    /// <summary>\n    /// Adds the CORS middleware to the specified <see cref=\"IApplicationBuilder\"/>, which enables cross-origin resource sharing.\n    /// </summary>\n    /// <param name=\"app\">The <see cref=\"IApplicationBuilder\"/> to add the middleware to.</param>\n    /// <param name=\"policyName\">The CORS policy to apply.</param>\n    /// <returns>A reference to this instance after the operation has completed.</returns>\n    public static IApplicationBuilder UseCors(this IApplicationBuilder app, string policyName)\n    {\n        if (app == null)\n        {\n            throw new ArgumentNullException(nameof(app));\n        }\n\n        return app.UseMiddleware<CorsMiddleware>(policyName);\n    }\n\n    /// <summary>\n    /// Adds the CORS middleware to the specified <see cref=\"IApplicationBuilder\"/>, which enables cross-origin resource sharing.\n    /// </summary>\n    /// <param name=\"app\">The <see cref=\"IApplicationBuilder\"/> to add the middleware to.</param>\n    /// <param name=\"configurePolicy\">A delegate which can use a <see cref=\"CorsPolicyBuilder\"/> to build a policy.</param>\n    /// <returns>A reference to this instance after the operation has completed.</returns>\n    public static IApplicationBuilder UseCors(this IApplicationBuilder app, Action<CorsPolicyBuilder> configurePolicy)\n    {\n        if (app == null)\n        {\n            throw new ArgumentNullException(nameof(app));\n        }\n\n        if (configurePolicy == null)\n        {\n            throw new ArgumentNullException(nameof(configurePolicy));\n        }\n\n        var policyBuilder = new CorsPolicyBuilder();\n        configurePolicy(policyBuilder);\n        return app.UseMiddleware<CorsMiddleware>(policyBuilder.Build());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Identity EntityFrameworkCore in ASP.NET Core\nDESCRIPTION: This snippet shows the extension method for adding EntityFramework stores to the Identity builder and the property signatures for accessing various DbSet properties in the IdentityDbContext and IdentityUserContext classes. These are used to configure and interact with the Identity database schema.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.IdentityEntityFrameworkBuilderExtensions.AddEntityFrameworkStores<TContext>(this Microsoft.AspNetCore.Identity.IdentityBuilder! builder) -> Microsoft.AspNetCore.Identity.IdentityBuilder!\n\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityDbContext<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TRoleClaim, TUserToken>.RoleClaims.get -> Microsoft.EntityFrameworkCore.DbSet<TRoleClaim!>!\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityDbContext<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TRoleClaim, TUserToken>.RoleClaims.set -> void\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityDbContext<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TRoleClaim, TUserToken>.Roles.get -> Microsoft.EntityFrameworkCore.DbSet<TRole!>!\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityDbContext<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TRoleClaim, TUserToken>.Roles.set -> void\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityDbContext<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TRoleClaim, TUserToken>.UserRoles.get -> Microsoft.EntityFrameworkCore.DbSet<TUserRole!>!\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityDbContext<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TRoleClaim, TUserToken>.UserRoles.set -> void\n\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityUserContext<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.SchemaVersion.get -> System.Version!\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityUserContext<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.UserClaims.get -> Microsoft.EntityFrameworkCore.DbSet<TUserClaim!>!\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityUserContext<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.UserClaims.set -> void\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityUserContext<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.UserLogins.get -> Microsoft.EntityFrameworkCore.DbSet<TUserLogin!>!\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityUserContext<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.UserLogins.set -> void\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityUserContext<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.Users.get -> Microsoft.EntityFrameworkCore.DbSet<TUser!>!\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityUserContext<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.Users.set -> void\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityUserContext<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.UserTokens.get -> Microsoft.EntityFrameworkCore.DbSet<TUserToken!>!\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityUserContext<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.UserTokens.set -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON Response Writer with Type Checking\nDESCRIPTION: Implements a method for writing JSON responses with runtime type checking. It uses JsonTypeInfo for efficient serialization and handles trimming and AOT concerns through suppression attributes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsValidationProblemResult_Has_Metadata.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n        [UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n            Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n        [UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\n        private static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n        {\n            var runtimeType = value?.GetType();\n\n            if (jsonTypeInfo.ShouldUseWith(runtimeType))\n            {\n                return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n            }\n\n\n        }\n```\n\n----------------------------------------\n\nTITLE: StaticFileMiddleware Implementation in ASP.NET Core\nDESCRIPTION: Core middleware for serving static files in ASP.NET Core applications. It handles serving static files from disk or other file providers based on the configured options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/StaticFiles/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.StaticFiles.StaticFileMiddleware.Invoke(Microsoft.AspNetCore.Http.HttpContext! context) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.StaticFiles.StaticFileMiddleware.StaticFileMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.AspNetCore.Hosting.IWebHostEnvironment! hostingEnv, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Builder.StaticFileOptions!>! options, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> void\n```\n\n----------------------------------------\n\nTITLE: Adding HTTP Context Accessor to Service Collection in ASP.NET Core\nDESCRIPTION: This extension method adds an HTTP context accessor to the dependency injection container.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.HttpServiceCollectionExtensions.AddHttpContextAccessor(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: JSON Response Writer with Type Information in ASP.NET Core\nDESCRIPTION: Handles writing JSON responses with type information. It determines whether to use the provided JsonTypeInfo directly or fall back to more generic serialization based on runtime type analysis.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Route Handlers in ASP.NET Core\nDESCRIPTION: Implements core route mapping functionality that creates route handler builders. This method connects routes, handlers, HTTP methods, and metadata to create endpoints in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Post_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Twitter Authentication Events in C#\nDESCRIPTION: Defines the TwitterEvents class for handling various events during the Twitter authentication process, such as creating tickets and redirecting to the authorization endpoint.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Twitter/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterEvents\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterEvents.OnCreatingTicket.get -> System.Func<Microsoft.AspNetCore.Authentication.Twitter.TwitterCreatingTicketContext!, System.Threading.Tasks.Task!>!\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterEvents.OnCreatingTicket.set -> void\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterEvents.OnRedirectToAuthorizationEndpoint.get -> System.Func<Microsoft.AspNetCore.Authentication.RedirectContext<Microsoft.AspNetCore.Authentication.Twitter.TwitterOptions!>!, System.Threading.Tasks.Task!>!\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterEvents.OnRedirectToAuthorizationEndpoint.set -> void\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterEvents.TwitterEvents() -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing SignInHttpResult in ASP.NET Core\nDESCRIPTION: API signatures for the SignInHttpResult class, which returns a sign-in response by issuing the specified authentication cookie for a ClaimsPrincipal with optional authentication properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.SignInHttpResult\nMicrosoft.AspNetCore.Http.HttpResults.SignInHttpResult.AuthenticationScheme.get -> string?\nMicrosoft.AspNetCore.Http.HttpResults.SignInHttpResult.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.SignInHttpResult.Principal.get -> System.Security.Claims.ClaimsPrincipal!\nMicrosoft.AspNetCore.Http.HttpResults.SignInHttpResult.Properties.get -> Microsoft.AspNetCore.Authentication.AuthenticationProperties?\n```\n\n----------------------------------------\n\nTITLE: Authorizing User with Policy in ASP.NET Core\nDESCRIPTION: This method performs authorization checks for a user against a specified policy name. It takes a ClaimsPrincipal, an optional resource, and a policy name as parameters, returning an AuthorizationResult.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authorization.DefaultAuthorizationService.AuthorizeAsync(System.Security.Claims.ClaimsPrincipal! user, object? resource, string! policyName) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authorization.AuthorizationResult!>!\n```\n\n----------------------------------------\n\nTITLE: Using ValidationProblem in ASP.NET Core\nDESCRIPTION: API signatures for the ValidationProblem class, which returns a RFC 7807 problem details response for model validation errors with a specified status code.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.ValidationProblem\nMicrosoft.AspNetCore.Http.HttpResults.ValidationProblem.ContentType.get -> string!\nMicrosoft.AspNetCore.Http.HttpResults.ValidationProblem.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.ValidationProblem.ProblemDetails.get -> Microsoft.AspNetCore.Http.HttpValidationProblemDetails!\nMicrosoft.AspNetCore.Http.HttpResults.ValidationProblem.StatusCode.get -> int\n```\n\n----------------------------------------\n\nTITLE: Defining NotFound Result Methods in C#\nDESCRIPTION: These methods create NotFound (HTTP 404) results with optional value content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.NotFound() -> Microsoft.AspNetCore.Http.HttpResults.NotFound!\nstatic Microsoft.AspNetCore.Http.TypedResults.NotFound<TValue>(TValue? value) -> Microsoft.AspNetCore.Http.HttpResults.NotFound<TValue>!\n```\n\n----------------------------------------\n\nTITLE: Configuring SignalR Services in ASP.NET Core\nDESCRIPTION: Extension methods for adding and configuring SignalR services in ASP.NET Core dependency injection. These methods set up the required services for SignalR functionality with optional hub-specific configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/SignalR/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.SignalRDependencyInjectionExtensions.AddHubOptions<THub>(this Microsoft.AspNetCore.SignalR.ISignalRServerBuilder! signalrBuilder, System.Action<Microsoft.AspNetCore.SignalR.HubOptions<THub!>!>! configure) -> Microsoft.AspNetCore.SignalR.ISignalRServerBuilder!\nstatic Microsoft.Extensions.DependencyInjection.SignalRDependencyInjectionExtensions.AddSignalR(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.AspNetCore.SignalR.ISignalRServerBuilder!\nstatic Microsoft.Extensions.DependencyInjection.SignalRDependencyInjectionExtensions.AddSignalR(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.SignalR.HubOptions!>! configure) -> Microsoft.AspNetCore.SignalR.ISignalRServerBuilder!\n```\n\n----------------------------------------\n\nTITLE: CookieAuthenticationEvents Virtual Methods for ASP.NET Core Cookie Authentication in C#\nDESCRIPTION: Virtual methods from the CookieAuthenticationEvents class that can be overridden to customize the cookie authentication flow in ASP.NET Core applications. Includes methods for handling redirects, sign-in/out operations, principal validation, and sliding expiration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Cookies/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationEvents.CheckSlidingExpiration(Microsoft.AspNetCore.Authentication.Cookies.CookieSlidingExpirationContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationEvents.RedirectToAccessDenied(Microsoft.AspNetCore.Authentication.RedirectContext<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions!>! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationEvents.RedirectToLogin(Microsoft.AspNetCore.Authentication.RedirectContext<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions!>! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationEvents.RedirectToLogout(Microsoft.AspNetCore.Authentication.RedirectContext<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions!>! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationEvents.RedirectToReturnUrl(Microsoft.AspNetCore.Authentication.RedirectContext<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions!>! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationEvents.SignedIn(Microsoft.AspNetCore.Authentication.Cookies.CookieSignedInContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationEvents.SigningIn(Microsoft.AspNetCore.Authentication.Cookies.CookieSigningInContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationEvents.SigningOut(Microsoft.AspNetCore.Authentication.Cookies.CookieSigningOutContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationEvents.ValidatePrincipal(Microsoft.AspNetCore.Authentication.Cookies.CookieValidatePrincipalContext! context) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Creating Event Callbacks for Web Events in ASP.NET Core\nDESCRIPTION: These extension methods create EventCallback instances for various web event types like MouseEventArgs, PointerEventArgs, and TouchEventArgs. They allow for both synchronous (Action) and asynchronous (Func<Task>) callback handlers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.Web.WebEventCallbackFactoryEventArgsExtensions.Create(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<Microsoft.AspNetCore.Components.Web.MouseEventArgs!>! callback) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.Web.MouseEventArgs!>\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.Web.WebEventCallbackFactoryEventArgsExtensions.Create(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<Microsoft.AspNetCore.Components.Web.ClipboardEventArgs!, System.Threading.Tasks.Task!>! callback) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.Web.ClipboardEventArgs!>\n```\n\n----------------------------------------\n\nTITLE: Generating and installing ASP.NET Core project templates\nDESCRIPTION: This snippet demonstrates the process of generating, installing, and executing ASP.NET Core project templates. It includes packing the template, installing it, and running a sample Blazor Web template.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/ProjectTemplates/README-BASELINES.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\ndotnet pack ProjectTemplatesNoDeps.slnf --no-restore --no-dependencies && dotnet new uninstall Microsoft.DotNet.Web.ProjectTemplates.8.0 && rm -rf scripts\\MyBlazorApp && powershell .\\scripts\\Run-BlazorWeb-Locally.ps1\n```\n\n----------------------------------------\n\nTITLE: Status Code Response Methods in ASP.NET Core ControllerBase (C#)\nDESCRIPTION: Methods to return common HTTP status code responses like 204 No Content, 404 Not Found, and 200 OK. These methods support returning empty responses or responses with content objects.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.NoContent() -> Microsoft.AspNetCore.Mvc.NoContentResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.NotFound() -> Microsoft.AspNetCore.Mvc.NotFoundResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.NotFound(object? value) -> Microsoft.AspNetCore.Mvc.NotFoundObjectResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Ok() -> Microsoft.AspNetCore.Mvc.OkResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Ok(object? value) -> Microsoft.AspNetCore.Mvc.OkObjectResult!\n```\n\n----------------------------------------\n\nTITLE: CreatedAtRoute Response Methods in ASP.NET Core ControllerBase (C#)\nDESCRIPTION: Methods to return HTTP 201 Created responses with route-generated location headers. These methods create a URL to a named route and return it in the Location header along with the created resource value.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.CreatedAtRoute(object? routeValues, object? value) -> Microsoft.AspNetCore.Mvc.CreatedAtRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.CreatedAtRoute(string? routeName, object? routeValues, object? value) -> Microsoft.AspNetCore.Mvc.CreatedAtRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.CreatedAtRoute(string? routeName, object? value) -> Microsoft.AspNetCore.Mvc.CreatedAtRouteResult!\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom GET Request Handler with Parameter Binding\nDESCRIPTION: Implementation of a custom GET request handler that supports parameter binding, content type negotiation, and response writing. Includes error handling for required parameters and supports both filtered and unfiltered request processing paths.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandler(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var myBindAsyncParam_local = await global::Microsoft.AspNetCore.Http.Generators.Tests.InheritBindAsync.BindAsync(httpContext);\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n        return;\n    }\n    var result = handler(myBindAsyncParam_local);\n    if (result is string)\n    {\n        httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n    }\n    else\n    {\n        httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n    }\n    await httpContext.Response.WriteAsync(result);\n}\n```\n\n----------------------------------------\n\nTITLE: IRoleStore Interface Definition\nDESCRIPTION: Defines the core interface for role management operations in ASP.NET Core Identity, including CRUD operations for roles.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.IRoleStore<TRole>\nMicrosoft.AspNetCore.Identity.IRoleStore<TRole>.CreateAsync(TRole! role, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\nMicrosoft.AspNetCore.Identity.IRoleStore<TRole>.DeleteAsync(TRole! role, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\nMicrosoft.AspNetCore.Identity.IRoleStore<TRole>.FindByIdAsync(string! roleId, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TRole?>!\n```\n\n----------------------------------------\n\nTITLE: Implementing Claims Authorization Requirement in C#\nDESCRIPTION: Constructor for ClaimsAuthorizationRequirement that validates claims-based authorization with specified claim type and allowed values.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.Infrastructure.ClaimsAuthorizationRequirement.ClaimsAuthorizationRequirement(string! claimType, System.Collections.Generic.IEnumerable<string!>? allowedValues) -> void\n```\n\n----------------------------------------\n\nTITLE: Parameter Handling Methods in ASP.NET Core Blazor\nDESCRIPTION: Methods for creating and supplying component parameters, including creating ParameterView from dictionary and adding support for query parameter binding.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.ParameterView.FromDictionary(System.Collections.Generic.IDictionary<string!, object?>! parameters) -> Microsoft.AspNetCore.Components.ParameterView\nstatic Microsoft.AspNetCore.Components.SupplyParameterFromQueryProviderServiceCollectionExtensions.AddSupplyValueFromQueryProvider(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Adding OpenAPI Services to Dependency Injection in C#\nDESCRIPTION: Provides extension methods for IServiceCollection to add OpenAPI services with various configuration options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.OpenApiServiceCollectionExtensions.AddOpenApi(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.OpenApiServiceCollectionExtensions.AddOpenApi(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, string! documentName) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.OpenApiServiceCollectionExtensions.AddOpenApi(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, string! documentName, System.Action<Microsoft.AspNetCore.OpenApi.OpenApiOptions!>! configureOptions) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Connection and Cookie Virtual Methods in ASP.NET Core\nDESCRIPTION: Virtual methods for connection management and cookie building in ASP.NET Core HTTP components, providing extensibility for request closing and cookie generation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Http.ConnectionInfo.RequestClose() -> void\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.Build(Microsoft.AspNetCore.Http.HttpContext! context, System.DateTimeOffset expiresFrom) -> Microsoft.AspNetCore.Http.CookieOptions!\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.Domain.get -> string?\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.Domain.set -> void\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.Expiration.get -> System.TimeSpan?\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.Expiration.set -> void\n```\n\n----------------------------------------\n\nTITLE: JSRuntime Extension Methods for Generic Type Operations\nDESCRIPTION: Extension methods for IJSRuntime to invoke JavaScript functions that return values of generic type TValue, with support for cancellation tokens and timeouts.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/JSInterop/Microsoft.JSInterop/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.JSInterop.JSRuntimeExtensions.InvokeAsync<TValue>(this Microsoft.JSInterop.IJSRuntime! jsRuntime, string! identifier, params object?[]? args) -> System.Threading.Tasks.ValueTask<TValue>\nstatic Microsoft.JSInterop.JSRuntimeExtensions.InvokeAsync<TValue>(this Microsoft.JSInterop.IJSRuntime! jsRuntime, string! identifier, System.Threading.CancellationToken cancellationToken, params object?[]? args) -> System.Threading.Tasks.ValueTask<TValue>\nstatic Microsoft.JSInterop.JSRuntimeExtensions.InvokeAsync<TValue>(this Microsoft.JSInterop.IJSRuntime! jsRuntime, string! identifier, System.TimeSpan timeout, params object?[]? args) -> System.Threading.Tasks.ValueTask<TValue>\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON Patch Controller Action in ASP.NET Core\nDESCRIPTION: Example controller action method demonstrating how to handle JSON Patch requests with model state validation\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Features/JsonPatch/src/PACKAGE.md#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n[HttpPatch]\npublic IActionResult JsonPatchWithModelState(\n    [FromBody] JsonPatchDocument<Customer> patchDoc)\n{\n    if (patchDoc is not null)\n    {\n        var customer = CreateCustomer();\n\n        patchDoc.ApplyTo(customer, ModelState);\n\n        if (!ModelState.IsValid)\n        {\n            return BadRequest(ModelState);\n        }\n\n        return new ObjectResult(customer);\n    }\n    else\n    {\n        return BadRequest(ModelState);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft.AspNetCore.SignalR.Client.Core via .NET CLI\nDESCRIPTION: This command adds the Microsoft.AspNetCore.SignalR.Client.Core package to a .NET project using the dotnet CLI. It's the first step in setting up a SignalR client in a .NET application.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.SignalR.Client.Core\n```\n\n----------------------------------------\n\nTITLE: JSON Request Body Processing\nDESCRIPTION: Handles parsing and validation of JSON request bodies with error handling for invalid content types, IO exceptions, and JSON parsing errors.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\nprivate static async ValueTask<(bool, T?)> TryResolveBodyAsync<T>(HttpContext httpContext, LogOrThrowExceptionHelper logOrThrowExceptionHelper, bool allowEmpty, string parameterTypeName, string parameterName, JsonTypeInfo<T> jsonTypeInfo, bool isInferred = false)\n{\n    var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();\n    T? bodyValue = default;\n    var bodyValueSet = false;\n\n    if (feature?.CanHaveBody == true)\n    {\n        if (!httpContext.Request.HasJsonContentType())\n        {\n            logOrThrowExceptionHelper.UnexpectedJsonContentType(httpContext.Request.ContentType);\n            httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;\n            return (false, default);\n        }\n        try\n        {\n            bodyValue = await httpContext.Request.ReadFromJsonAsync(jsonTypeInfo);\n            bodyValueSet = bodyValue != null;\n        }\n        catch (BadHttpRequestException badHttpRequestException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(badHttpRequestException);\n            httpContext.Response.StatusCode = badHttpRequestException.StatusCode;\n            return (false, default);\n        }\n        catch (IOException ioException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(ioException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n        catch (System.Text.Json.JsonException jsonException)\n        {\n            logOrThrowExceptionHelper.InvalidJsonRequestBody(parameterTypeName, parameterName, jsonException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n    }\n\n    if (!allowEmpty && !bodyValueSet)\n    {\n        if (!isInferred)\n        {\n            logOrThrowExceptionHelper.RequiredParameterNotProvided(parameterTypeName, parameterName, \"body\");\n        }\n        else\n        {\n            logOrThrowExceptionHelper.ImplicitBodyNotProvided(parameterName);\n        }\n        httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n        return (false, bodyValue);\n    }\n\n    return (true, bodyValue);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MapPost Route Handler in ASP.NET Core\nDESCRIPTION: Generated extension method for mapping POST requests with JSON body handling, metadata population, and request delegation. Includes support for endpoint filters and parameter validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitBodyParam_ComplexReturn_Snapshot.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapPost0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        options.EndpointBuilder.Metadata.Add(new AcceptsMetadata(type: typeof(global::Microsoft.AspNetCore.Http.Generators.Tests.Todo), isOptional: false, contentTypes: GeneratedMetadataConstants.JsonContentType));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"todo\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        PopulateMetadataForEndpoint<global::Microsoft.AspNetCore.Http.HttpResults.Ok<global::Microsoft.AspNetCore.Http.Generators.Tests.Todo>>(methodInfo, options.EndpointBuilder);\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    // ... [Additional implementation details truncated for brevity]\n}\n```\n\n----------------------------------------\n\nTITLE: Building Endpoint Filter Delegate Chain in ASP.NET Core\nDESCRIPTION: Creates a chain of endpoint filters by applying them in reverse order. Each filter factory is invoked with a context containing method information and application services, building a nested execution pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Static Utility Methods for WebUtilities in C#\nDESCRIPTION: This snippet contains static method declarations for various utility classes in the Microsoft.AspNetCore.WebUtilities namespace, including Base64 encoding, multipart section handling, query string manipulation, and stream operations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/WebUtilities/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.WebUtilities.Base64UrlTextEncoder.Decode(string! text) -> byte[]!\nstatic Microsoft.AspNetCore.WebUtilities.Base64UrlTextEncoder.Encode(byte[]! data) -> string!\nstatic Microsoft.AspNetCore.WebUtilities.MultipartSectionConverterExtensions.AsFileSection(this Microsoft.AspNetCore.WebUtilities.MultipartSection! section) -> Microsoft.AspNetCore.WebUtilities.FileMultipartSection?\nstatic Microsoft.AspNetCore.WebUtilities.MultipartSectionConverterExtensions.AsFormDataSection(this Microsoft.AspNetCore.WebUtilities.MultipartSection! section) -> Microsoft.AspNetCore.WebUtilities.FormMultipartSection?\nstatic Microsoft.AspNetCore.WebUtilities.MultipartSectionConverterExtensions.GetContentDispositionHeader(this Microsoft.AspNetCore.WebUtilities.MultipartSection! section) -> Microsoft.Net.Http.Headers.ContentDispositionHeaderValue?\nstatic Microsoft.AspNetCore.WebUtilities.MultipartSectionStreamExtensions.ReadAsStringAsync(this Microsoft.AspNetCore.WebUtilities.MultipartSection! section) -> System.Threading.Tasks.Task<string!>!\nstatic Microsoft.AspNetCore.WebUtilities.MultipartSectionStreamExtensions.ReadAsStringAsync(this Microsoft.AspNetCore.WebUtilities.MultipartSection! section, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<string!>\nstatic Microsoft.AspNetCore.WebUtilities.QueryHelpers.AddQueryString(string! uri, string! name, string! value) -> string!\nstatic Microsoft.AspNetCore.WebUtilities.QueryHelpers.AddQueryString(string! uri, System.Collections.Generic.IDictionary<string!, string?>! queryString) -> string!\nstatic Microsoft.AspNetCore.WebUtilities.QueryHelpers.AddQueryString(string! uri, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string!, Microsoft.Extensions.Primitives.StringValues>>! queryString) -> string!\nstatic Microsoft.AspNetCore.WebUtilities.QueryHelpers.AddQueryString(string! uri, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string!, string?>>! queryString) -> string!\nstatic Microsoft.AspNetCore.WebUtilities.QueryHelpers.ParseNullableQuery(string? queryString) -> System.Collections.Generic.Dictionary<string!, Microsoft.Extensions.Primitives.StringValues>?\nstatic Microsoft.AspNetCore.WebUtilities.QueryHelpers.ParseQuery(string? queryString) -> System.Collections.Generic.Dictionary<string!, Microsoft.Extensions.Primitives.StringValues>!\nstatic Microsoft.AspNetCore.WebUtilities.ReasonPhrases.GetReasonPhrase(int statusCode) -> string!\nstatic Microsoft.AspNetCore.WebUtilities.StreamHelperExtensions.DrainAsync(this System.IO.Stream! stream, long? limit, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.WebUtilities.StreamHelperExtensions.DrainAsync(this System.IO.Stream! stream, System.Buffers.ArrayPool<byte>! bytePool, long? limit, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.WebUtilities.StreamHelperExtensions.DrainAsync(this System.IO.Stream! stream, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.WebUtilities.WebEncoders.Base64UrlDecode(string! input) -> byte[]!\nstatic Microsoft.AspNetCore.WebUtilities.WebEncoders.Base64UrlDecode(string! input, int offset, char[]! buffer, int bufferOffset, int count) -> byte[]!\nstatic Microsoft.AspNetCore.WebUtilities.WebEncoders.Base64UrlDecode(string! input, int offset, int count) -> byte[]!\nstatic Microsoft.AspNetCore.WebUtilities.WebEncoders.Base64UrlEncode(byte[]! input) -> string!\nstatic Microsoft.AspNetCore.WebUtilities.WebEncoders.Base64UrlEncode(byte[]! input, int offset, char[]! output, int outputOffset, int count) -> int\nstatic Microsoft.AspNetCore.WebUtilities.WebEncoders.Base64UrlEncode(byte[]! input, int offset, int count) -> string!\nstatic Microsoft.AspNetCore.WebUtilities.WebEncoders.Base64UrlEncode(System.ReadOnlySpan<byte> input) -> string!\nstatic Microsoft.AspNetCore.WebUtilities.WebEncoders.Base64UrlEncode(System.ReadOnlySpan<byte> input, System.Span<char> output) -> int\nstatic Microsoft.AspNetCore.WebUtilities.WebEncoders.GetArraySizeRequiredToDecode(int count) -> int\nstatic Microsoft.AspNetCore.WebUtilities.WebEncoders.GetArraySizeRequiredToEncode(int count) -> int\n```\n\n----------------------------------------\n\nTITLE: CreatedAtAction Response Methods in ASP.NET Core ControllerBase (C#)\nDESCRIPTION: Methods to return HTTP 201 Created responses with action-generated location headers. These methods create a URL to an action and return it in the Location header along with the created resource value.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.CreatedAtAction(string? actionName, object? routeValues, object? value) -> Microsoft.AspNetCore.Mvc.CreatedAtActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.CreatedAtAction(string? actionName, object? value) -> Microsoft.AspNetCore.Mvc.CreatedAtActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.CreatedAtAction(string? actionName, string? controllerName, object? routeValues, object? value) -> Microsoft.AspNetCore.Mvc.CreatedAtActionResult!\n```\n\n----------------------------------------\n\nTITLE: Defining AuthorizationFailure and AuthorizationFailureReason in C#\nDESCRIPTION: These classes represent the result of a failed authorization attempt, including the reasons for failure and the handlers involved.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationFailure\nMicrosoft.AspNetCore.Authorization.AuthorizationFailure.FailCalled.get -> bool\nMicrosoft.AspNetCore.Authorization.AuthorizationFailure.FailedRequirements.get -> System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.IAuthorizationRequirement!>!\nMicrosoft.AspNetCore.Authorization.AuthorizationFailure.FailureReasons.get -> System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.AuthorizationFailureReason!>!\n\nMicrosoft.AspNetCore.Authorization.AuthorizationFailureReason\nMicrosoft.AspNetCore.Authorization.AuthorizationFailureReason.AuthorizationFailureReason(Microsoft.AspNetCore.Authorization.IAuthorizationHandler! handler, string! message) -> void\nMicrosoft.AspNetCore.Authorization.AuthorizationFailureReason.Handler.get -> Microsoft.AspNetCore.Authorization.IAuthorizationHandler!\nMicrosoft.AspNetCore.Authorization.AuthorizationFailureReason.Message.get -> string!\n```\n\n----------------------------------------\n\nTITLE: Extending WebAssemblyAuthenticationServiceCollection in C#\nDESCRIPTION: Extends the WebAssemblyAuthenticationServiceCollection with methods for adding API authorization services in ASP.NET Core WebAssembly authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.WebAssemblyAuthenticationServiceCollectionExtensions.AddApiAuthorization(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationState!, Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount!>!\nstatic Microsoft.Extensions.DependencyInjection.WebAssemblyAuthenticationServiceCollectionExtensions.AddApiAuthorization(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationOptions<Microsoft.AspNetCore.Components.WebAssembly.Authentication.ApiAuthorizationProviderOptions!>!>! configure) -> Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationState!, Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount!>!\nstatic Microsoft.Extensions.DependencyInjection.WebAssemblyAuthenticationServiceCollectionExtensions.AddApiAuthorization<TRemoteAuthenticationState, TAccount>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<TRemoteAuthenticationState!, TAccount!>!\nstatic Microsoft.Extensions.DependencyInjection.WebAssemblyAuthenticationServiceCollectionExtensions.AddApiAuthorization<TRemoteAuthenticationState, TAccount>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationOptions<Microsoft.AspNetCore.Components.WebAssembly.Authentication.ApiAuthorizationProviderOptions!>!>! configure) -> Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<TRemoteAuthenticationState!, TAccount!>!\nstatic Microsoft.Extensions.DependencyInjection.WebAssemblyAuthenticationServiceCollectionExtensions.AddApiAuthorization<TRemoteAuthenticationState>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<TRemoteAuthenticationState!, Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount!>!\nstatic Microsoft.Extensions.DependencyInjection.WebAssemblyAuthenticationServiceCollectionExtensions.AddApiAuthorization<TRemoteAuthenticationState>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationOptions<Microsoft.AspNetCore.Components.WebAssembly.Authentication.ApiAuthorizationProviderOptions!>!>! configure) -> Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<TRemoteAuthenticationState!, Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount!>!\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Extension Method for Route Builder in ASP.NET Core\nDESCRIPTION: Defines a MapGet extension method for the IEndpointRouteBuilder interface that maps HTTP GET requests to a specified handler. This method handles parameter binding, metadata population, and request delegation with support for filters and JSON serialization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_QueryNotPresent.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n%INTERCEPTSLOCATIONATTRIBUTE%\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n        var serviceProviderIsService = serviceProvider.GetRequiredService<IServiceProviderIsService>();\n        var jsonBodyOrServiceTypeTuples = new (bool, Type)[] {\n            #nullable disable\n            (false, typeof(global::System.String[])),\n            #nullable enable\n        };\n        foreach (var (isOptional, type) in jsonBodyOrServiceTypeTuples)\n        {\n            if (!serviceProviderIsService.IsService(type))\n            {\n                options.EndpointBuilder.Metadata.Add(new AcceptsMetadata(type: type, isOptional: isOptional, contentTypes: GeneratedMetadataConstants.JsonContentType));\n                break;\n            }\n        }\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(global::System.Int32), contentTypes: GeneratedMetadataConstants.JsonContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n        Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n        var handler = Cast(del, global::System.Int32 (global::System.String?[] arg0) => throw null!);\n        EndpointFilterDelegate? filteredInvocation = null;\n        var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n        var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n        var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n        var jsonSerializerOptions = jsonOptions.SerializerOptions;\n        jsonSerializerOptions.MakeReadOnly();\n        var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n        var responseJsonTypeInfo =  (JsonTypeInfo<global::System.Int32>)jsonSerializerOptions.GetTypeInfo(typeof(global::System.Int32));\n\n        if (options.EndpointBuilder.FilterFactories.Count > 0)\n        {\n            filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n            {\n                if (ic.HttpContext.Response.StatusCode == 400)\n                {\n                    return ValueTask.FromResult<object?>(Results.Empty);\n                }\n                return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::System.String?[]>(0)!));\n            },\n            options.EndpointBuilder,\n            handler.Method);\n        }\n\n        async Task RequestHandler(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            // Endpoint Parameter: p (Type = string?[], IsOptional = False, IsParsable = False, IsArray = True, Source = JsonBodyOrQuery)\n            global::System.String?[] p_local = null!;\n            if (options.DisableInferBodyFromParameters)\n            {\n                var p_raw = httpContext.Request.Query[\"p\"];\n                p_local = p_raw!;\n            }\n            else\n            {\n                var p_JsonTypeInfo = (JsonTypeInfo<global::System.String?[]>)jsonOptions.SerializerOptions.GetTypeInfo(typeof(global::System.String[]));\n                var p_resolveBodyResult = await GeneratedRouteBuilderExtensionsCore.TryResolveBodyAsync<global::System.String?[]>(httpContext, logOrThrowExceptionHelper, false, \"string?[]\", \"p\", p_JsonTypeInfo);\n                p_local = p_resolveBodyResult.Item2!;\n                if (!p_resolveBodyResult.Item1)\n                {\n                    return;\n                }\n            }\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n                return;\n            }\n            var result = handler(p_local);\n            await httpContext.Response.WriteAsJsonAsync(result, responseJsonTypeInfo);\n        }\n\n        async Task RequestHandlerFiltered(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            // Endpoint Parameter: p (Type = string?[], IsOptional = False, IsParsable = False, IsArray = True, Source = JsonBodyOrQuery)\n            global::System.String?[] p_local = null!;\n            if (options.DisableInferBodyFromParameters)\n            {\n                var p_raw = httpContext.Request.Query[\"p\"];\n                p_local = p_raw!;\n            }\n            else\n            {\n                var p_JsonTypeInfo = (JsonTypeInfo<global::System.String?[]>)jsonOptions.SerializerOptions.GetTypeInfo(typeof(global::System.String[]));\n                var p_resolveBodyResult = await GeneratedRouteBuilderExtensionsCore.TryResolveBodyAsync<global::System.String?[]>(httpContext, logOrThrowExceptionHelper, false, \"string?[]\", \"p\", p_JsonTypeInfo);\n                p_local = p_resolveBodyResult.Item2!;\n                if (!p_resolveBodyResult.Item1)\n                {\n                    return;\n                }\n            }\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n            }\n            var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::System.String?[]>(httpContext, p_local));\n            if (result is not null)\n            {\n\n```\n\n----------------------------------------\n\nTITLE: Listing Components to Migrate from aspnetcore-tooling to aspnetcore\nDESCRIPTION: Lists the components and associated tests that will be migrated from aspnetcore-tooling to aspnetcore in phase one of the consolidation process. These are primarily language-related components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/tooling-consolidation.md#2025-04-08_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Razor.Extensions.Version1_X\nMicrosoft.AspNetCore.Mvc.Razor.Extensions.Version2_X\nMicrosoft.AspNetCore.Mvc.Razor.Extensions\nMicrosoft.AspNetCore.Razor.Language\nMicrosoft.AspNetCore.Razor.Tools\nMicrosoft.CodeAnalysis.Razor\nMicrosoft.NET.Sdk.Razor\n```\n\n----------------------------------------\n\nTITLE: OAuth Token Response Class Members\nDESCRIPTION: Defines properties and methods for handling OAuth token responses including error handling, token information, and response data management\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OAuth/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthTokenResponse.Dispose() -> void\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthTokenResponse.Error.get -> System.Exception?\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthTokenResponse.Error.set -> void\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthTokenResponse.ExpiresIn.get -> string?\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthTokenResponse.ExpiresIn.set -> void\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthTokenResponse.RefreshToken.get -> string?\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthTokenResponse.RefreshToken.set -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultAuthorizationService in C#\nDESCRIPTION: Provides the default implementation of the authorization service in ASP.NET Core. It handles the evaluation of authorization policies and requirements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.DefaultAuthorizationService.DefaultAuthorizationService(Microsoft.AspNetCore.Authorization.IAuthorizationPolicyProvider! policyProvider, Microsoft.AspNetCore.Authorization.IAuthorizationHandlerProvider! handlers, Microsoft.Extensions.Logging.ILogger<Microsoft.AspNetCore.Authorization.DefaultAuthorizationService!>! logger, Microsoft.AspNetCore.Authorization.IAuthorizationHandlerContextFactory! contextFactory, Microsoft.AspNetCore.Authorization.IAuthorizationEvaluator! evaluator, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Authorization.AuthorizationOptions!>! options) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining Formatter Methods for ASP.NET Core MVC\nDESCRIPTION: These methods define the behavior of input and output formatters in ASP.NET Core MVC. They handle reading input, writing output, and determining content types for various data formats.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_65\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.Formatters.FormatFilter.GetFormat(Microsoft.AspNetCore.Mvc.ActionContext! context) -> string?\nvirtual Microsoft.AspNetCore.Mvc.Formatters.InputFormatter.CanRead(Microsoft.AspNetCore.Mvc.Formatters.InputFormatterContext! context) -> bool\nvirtual Microsoft.AspNetCore.Mvc.Formatters.InputFormatter.CanReadType(System.Type! type) -> bool\nvirtual Microsoft.AspNetCore.Mvc.Formatters.InputFormatter.GetDefaultValueForType(System.Type! modelType) -> object?\nvirtual Microsoft.AspNetCore.Mvc.Formatters.InputFormatter.GetSupportedContentTypes(string! contentType, System.Type! objectType) -> System.Collections.Generic.IReadOnlyList<string!>?\nvirtual Microsoft.AspNetCore.Mvc.Formatters.InputFormatter.ReadAsync(Microsoft.AspNetCore.Mvc.Formatters.InputFormatterContext! context) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.Formatters.InputFormatterResult!>!\nvirtual Microsoft.AspNetCore.Mvc.Formatters.OutputFormatter.CanWriteResult(Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterCanWriteContext! context) -> bool\nvirtual Microsoft.AspNetCore.Mvc.Formatters.OutputFormatter.CanWriteType(System.Type? type) -> bool\nvirtual Microsoft.AspNetCore.Mvc.Formatters.OutputFormatter.GetSupportedContentTypes(string! contentType, System.Type! objectType) -> System.Collections.Generic.IReadOnlyList<string!>?\nvirtual Microsoft.AspNetCore.Mvc.Formatters.OutputFormatter.WriteAsync(Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterWriteContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Mvc.Formatters.OutputFormatter.WriteResponseHeaders(Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterWriteContext! context) -> void\nvirtual Microsoft.AspNetCore.Mvc.Formatters.TextOutputFormatter.SelectCharacterEncoding(Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterWriteContext! context) -> System.Text.Encoding!\n```\n\n----------------------------------------\n\nTITLE: InputFileChangeEventArgs Class for File Upload Events\nDESCRIPTION: API signature for the InputFileChangeEventArgs class that provides access to browser files uploaded through the InputFile component, including methods to access a single file or multiple files.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Forms.InputFileChangeEventArgs\nMicrosoft.AspNetCore.Components.Forms.InputFileChangeEventArgs.File.get -> Microsoft.AspNetCore.Components.Forms.IBrowserFile!\nMicrosoft.AspNetCore.Components.Forms.InputFileChangeEventArgs.FileCount.get -> int\nMicrosoft.AspNetCore.Components.Forms.InputFileChangeEventArgs.GetMultipleFiles(int maximumFileCount = 10) -> System.Collections.Generic.IReadOnlyList<Microsoft.AspNetCore.Components.Forms.IBrowserFile!>!\nMicrosoft.AspNetCore.Components.Forms.InputFileChangeEventArgs.InputFileChangeEventArgs(System.Collections.Generic.IReadOnlyList<Microsoft.AspNetCore.Components.Forms.IBrowserFile!>! files) -> void\n```\n\n----------------------------------------\n\nTITLE: Invoking Hub Methods with SignalR Client in C#\nDESCRIPTION: These methods provide various overloads for invoking hub methods asynchronously with different numbers of arguments. They allow for both void and generic return types, and include optional cancellation token support.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.InvokeAsync(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, object? arg1, object? arg2, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.InvokeAsync<TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, object? arg1, object? arg2, object? arg3, object? arg4, object? arg5, object? arg6, object? arg7, object? arg8, object? arg9, object? arg10, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<TResult>!\n```\n\n----------------------------------------\n\nTITLE: Implementing UserStore in C# for ASP.NET Core Identity\nDESCRIPTION: Defines the UserStore class and its variations for managing users in ASP.NET Core Identity. It includes methods for CRUD operations on users, claims, logins, and tokens.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.AutoSaveChanges.get -> bool\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.AutoSaveChanges.set -> void\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.SaveChanges(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.UserStore(TContext! context, Microsoft.AspNetCore.Identity.IdentityErrorDescriber? describer = null) -> void\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Failure Handler in C#\nDESCRIPTION: Handles cases where parameter binding fails, either throwing an exception or logging the failure depending on configuration. Uses LoggerMessage pattern for efficient logging.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Certificate for WebTransport\nDESCRIPTION: C# function to generate and manage a self-signed certificate suitable for WebTransport over HTTP/3, including automatic rotation of expired certificates.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/WebTransport.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstatic X509Certificate2 GenerateManualCertificate()\n{\n    X509Certificate2 cert = null;\n    var store = new X509Store(\"KestrelWebTransportCertificates\", StoreLocation.CurrentUser);\n    store.Open(OpenFlags.ReadWrite);\n    if (store.Certificates.Count > 0)\n    {\n        cert = store.Certificates[^1];\n\n        // rotate key after it expires\n        if (DateTime.Parse(cert.GetExpirationDateString(), null) < DateTimeOffset.UtcNow)\n        {\n            cert = null;\n        }\n    }\n    if (cert == null)\n    {\n        // generate a new cert\n        var now = DateTimeOffset.UtcNow;\n        SubjectAlternativeNameBuilder sanBuilder = new();\n        sanBuilder.AddDnsName(\"localhost\");\n        using var ec = ECDsa.Create(ECCurve.NamedCurves.nistP256);\n        CertificateRequest req = new(\"CN=localhost\", ec, HashAlgorithmName.SHA256);\n        // Adds purpose\n        req.CertificateExtensions.Add(new X509EnhancedKeyUsageExtension(new OidCollection\n        {\n            new(\"1.3.6.1.5.5.7.3.1\") // serverAuth\n        }, false));\n        // Adds usage\n        req.CertificateExtensions.Add(new X509KeyUsageExtension(X509KeyUsageFlags.DigitalSignature, false));\n        // Adds subject alternate names\n        req.CertificateExtensions.Add(sanBuilder.Build());\n        // Sign\n        using var crt = req.CreateSelfSigned(now, now.AddDays(14)); // 14 days is the max duration of a certificate for this\n        cert = new(crt.Export(X509ContentType.Pfx));\n\n        // Save\n        store.Add(cert);\n    }\n    store.Close();\n\n    var hash = SHA256.HashData(cert.RawData);\n    var certStr = Convert.ToBase64String(hash);\n    Console.WriteLine($\"\\n\\n\\n\\n\\nCertificate: {certStr}\\n\\n\\n\\n\"); // <-- you will need to put this output into the JS API call to allow the connection\n    return cert;\n}\n```\n\n----------------------------------------\n\nTITLE: Form Mapping API for ASP.NET Core Form Components\nDESCRIPTION: API signatures for form mapping infrastructure that handles mapping form data to model objects, including FormMappingError for error reporting and FormValueMappingContext for the mapping process.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Forms.Mapping.FormMappingError\nMicrosoft.AspNetCore.Components.Forms.Mapping.FormMappingError.AttemptedValue.get -> string?\nMicrosoft.AspNetCore.Components.Forms.Mapping.FormMappingError.Container.get -> object!\nMicrosoft.AspNetCore.Components.Forms.Mapping.FormMappingError.ErrorMessages.get -> System.Collections.Generic.IReadOnlyList<System.FormattableString!>!\nMicrosoft.AspNetCore.Components.Forms.Mapping.FormMappingError.Name.get -> string!\nMicrosoft.AspNetCore.Components.Forms.Mapping.FormMappingError.Path.get -> string!\nMicrosoft.AspNetCore.Components.Forms.Mapping.FormValueMappingContext\nMicrosoft.AspNetCore.Components.Forms.Mapping.FormValueMappingContext.AcceptFormName.get -> string?\nMicrosoft.AspNetCore.Components.Forms.Mapping.FormValueMappingContext.AcceptMappingScopeName.get -> string!\nMicrosoft.AspNetCore.Components.Forms.Mapping.FormValueMappingContext.MapErrorToContainer.get -> System.Action<string!, object!>?\nMicrosoft.AspNetCore.Components.Forms.Mapping.FormValueMappingContext.MapErrorToContainer.set -> void\nMicrosoft.AspNetCore.Components.Forms.Mapping.FormValueMappingContext.OnError.get -> System.Action<string!, System.FormattableString!, string?>?\nMicrosoft.AspNetCore.Components.Forms.Mapping.FormValueMappingContext.OnError.set -> void\nMicrosoft.AspNetCore.Components.Forms.Mapping.FormValueMappingContext.ParameterName.get -> string!\nMicrosoft.AspNetCore.Components.Forms.Mapping.FormValueMappingContext.Result.get -> object?\nMicrosoft.AspNetCore.Components.Forms.Mapping.FormValueMappingContext.SetResult(object? result) -> void\nMicrosoft.AspNetCore.Components.Forms.Mapping.FormValueMappingContext.ValueType.get -> System.Type!\nMicrosoft.AspNetCore.Components.Forms.Mapping.IFormValueMapper\nMicrosoft.AspNetCore.Components.Forms.Mapping.IFormValueMapper.CanMap(System.Type! valueType, string! scopeName, string? formName) -> bool\nMicrosoft.AspNetCore.Components.Forms.Mapping.IFormValueMapper.Map(Microsoft.AspNetCore.Components.Forms.Mapping.FormValueMappingContext! context) -> void\nMicrosoft.AspNetCore.Components.Forms.Mapping.SupplyParameterFromFormServiceCollectionExtensions\n```\n\n----------------------------------------\n\nTITLE: Configuring Twitter Authentication Options in C#\nDESCRIPTION: Defines the TwitterOptions class for configuring Twitter authentication, including properties for consumer key, consumer secret, and user details retrieval.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Twitter/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterOptions\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterOptions.ClaimActions.get -> Microsoft.AspNetCore.Authentication.OAuth.Claims.ClaimActionCollection!\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterOptions.ConsumerKey.get -> string?\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterOptions.ConsumerKey.set -> void\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterOptions.ConsumerSecret.get -> string?\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterOptions.ConsumerSecret.set -> void\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterOptions.Events.get -> Microsoft.AspNetCore.Authentication.Twitter.TwitterEvents!\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterOptions.Events.set -> void\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterOptions.RetrieveUserDetails.get -> bool\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterOptions.RetrieveUserDetails.set -> void\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterOptions.StateCookie.get -> Microsoft.AspNetCore.Http.CookieBuilder!\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterOptions.StateCookie.set -> void\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterOptions.StateDataFormat.get -> Microsoft.AspNetCore.Authentication.ISecureDataFormat<Microsoft.AspNetCore.Authentication.Twitter.RequestToken!>!\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterOptions.StateDataFormat.set -> void\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterOptions.TwitterOptions() -> void\n```\n\n----------------------------------------\n\nTITLE: Defining SignalR Hub Invocation Message Classes\nDESCRIPTION: Base classes for hub invocation messages, providing common properties like invocation IDs, headers, and target methods. Forms the foundation for different types of invocation messages in SignalR.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.Protocol.HubInvocationMessage\nMicrosoft.AspNetCore.SignalR.Protocol.HubInvocationMessage.Headers.get -> System.Collections.Generic.IDictionary<string!, string!>?\nMicrosoft.AspNetCore.SignalR.Protocol.HubInvocationMessage.Headers.set -> void\nMicrosoft.AspNetCore.SignalR.Protocol.HubInvocationMessage.HubInvocationMessage(string? invocationId) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.HubInvocationMessage.InvocationId.get -> string?\n\nMicrosoft.AspNetCore.SignalR.Protocol.HubMessage\nMicrosoft.AspNetCore.SignalR.Protocol.HubMessage.HubMessage() -> void\n\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.Arguments.get -> object?[]!\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.HubMethodInvocationMessage(string? invocationId, string! target, object?[]! arguments) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.HubMethodInvocationMessage(string? invocationId, string! target, object?[]! arguments, string![]? streamIds) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.StreamIds.get -> string![]?\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.Target.get -> string!\n```\n\n----------------------------------------\n\nTITLE: Static Event and Resource Members in ASP.NET Core Blazor\nDESCRIPTION: Static readonly members for event callback handling and resource management in Blazor components, providing default and factory instances.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Components.EventCallback.Empty -> Microsoft.AspNetCore.Components.EventCallback\nstatic readonly Microsoft.AspNetCore.Components.EventCallback.Factory -> Microsoft.AspNetCore.Components.EventCallbackFactory!\nstatic readonly Microsoft.AspNetCore.Components.EventCallback<TValue>.Empty -> Microsoft.AspNetCore.Components.EventCallback<TValue>\nstatic readonly Microsoft.AspNetCore.Components.EventCallbackWorkItem.Empty -> Microsoft.AspNetCore.Components.EventCallbackWorkItem\nstatic readonly Microsoft.AspNetCore.Components.ResourceAssetCollection.Empty -> Microsoft.AspNetCore.Components.ResourceAssetCollection!\n```\n\n----------------------------------------\n\nTITLE: Implementing GET Route Handler in ASP.NET Core\nDESCRIPTION: Internal implementation of MapGet19 method that creates a route handler for HTTP GET requests. Handles parameter binding, metadata population, and request delegate creation with support for endpoint filters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet19(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"myBindAsyncParam\", parameters[0], hasTryParse: false, hasBindAsync: true, isOptional: true));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n```\n\n----------------------------------------\n\nTITLE: Defining Redirect Result Methods in C#\nDESCRIPTION: These methods create redirect results with options for permanence and method preservation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.Redirect(string! url, bool permanent = false, bool preserveMethod = false) -> Microsoft.AspNetCore.Http.HttpResults.RedirectHttpResult!\nstatic Microsoft.AspNetCore.Http.TypedResults.RedirectToRoute(string? routeName = null, object? routeValues = null, bool permanent = false, bool preserveMethod = false, string? fragment = null) -> Microsoft.AspNetCore.Http.HttpResults.RedirectToRouteHttpResult!\n```\n\n----------------------------------------\n\nTITLE: Building Endpoint Filter Delegate in ASP.NET Core\nDESCRIPTION: Creates a filter delegate that wraps a handler function, handling error conditions (HTTP 400) gracefully and processing request arguments through the filter pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitSource_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nfilteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n{\n    if (ic.HttpContext.Response.StatusCode == 400)\n    {\n        return ValueTask.FromResult<object?>(Results.Empty);\n    }\n    return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::System.String>(0)!));\n},\noptions.EndpointBuilder,\nhandler.Method);\n```\n\n----------------------------------------\n\nTITLE: RequestDelegateRouteBuilderExtensions Methods for HTTP Verb Routing in ASP.NET Core\nDESCRIPTION: Extension methods for IRouteBuilder that map HTTP verbs (GET, POST, PUT, DELETE) to route handlers. These methods allow both direct handler delegation and middleware integration for route handling, supporting various overloads for different implementation patterns.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapDelete(this Microsoft.AspNetCore.Routing.IRouteBuilder! builder, string! template, Microsoft.AspNetCore.Http.RequestDelegate! handler) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\nstatic Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapDelete(this Microsoft.AspNetCore.Routing.IRouteBuilder! builder, string! template, System.Func<Microsoft.AspNetCore.Http.HttpRequest!, Microsoft.AspNetCore.Http.HttpResponse!, Microsoft.AspNetCore.Routing.RouteData!, System.Threading.Tasks.Task!>! handler) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\nstatic Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapGet(this Microsoft.AspNetCore.Routing.IRouteBuilder! builder, string! template, Microsoft.AspNetCore.Http.RequestDelegate! handler) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\nstatic Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapGet(this Microsoft.AspNetCore.Routing.IRouteBuilder! builder, string! template, System.Func<Microsoft.AspNetCore.Http.HttpRequest!, Microsoft.AspNetCore.Http.HttpResponse!, Microsoft.AspNetCore.Routing.RouteData!, System.Threading.Tasks.Task!>! handler) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\nstatic Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewareDelete(this Microsoft.AspNetCore.Routing.IRouteBuilder! builder, string! template, System.Action<Microsoft.AspNetCore.Builder.IApplicationBuilder!>! action) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\nstatic Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewareGet(this Microsoft.AspNetCore.Routing.IRouteBuilder! builder, string! template, System.Action<Microsoft.AspNetCore.Builder.IApplicationBuilder!>! action) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\nstatic Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewarePost(this Microsoft.AspNetCore.Routing.IRouteBuilder! builder, string! template, System.Action<Microsoft.AspNetCore.Builder.IApplicationBuilder!>! action) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\nstatic Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewarePut(this Microsoft.AspNetCore.Routing.IRouteBuilder! builder, string! template, System.Action<Microsoft.AspNetCore.Builder.IApplicationBuilder!>! action) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\nstatic Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewareRoute(this Microsoft.AspNetCore.Routing.IRouteBuilder! builder, string! template, System.Action<Microsoft.AspNetCore.Builder.IApplicationBuilder!>! action) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\nstatic Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewareVerb(this Microsoft.AspNetCore.Routing.IRouteBuilder! builder, string! verb, string! template, System.Action<Microsoft.AspNetCore.Builder.IApplicationBuilder!>! action) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\nstatic Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapPost(this Microsoft.AspNetCore.Routing.IRouteBuilder! builder, string! template, Microsoft.AspNetCore.Http.RequestDelegate! handler) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\nstatic Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapPost(this Microsoft.AspNetCore.Routing.IRouteBuilder! builder, string! template, System.Func<Microsoft.AspNetCore.Http.HttpRequest!, Microsoft.AspNetCore.Http.HttpResponse!, Microsoft.AspNetCore.Routing.RouteData!, System.Threading.Tasks.Task!>! handler) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\nstatic Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapPut(this Microsoft.AspNetCore.Routing.IRouteBuilder! builder, string! template, Microsoft.AspNetCore.Http.RequestDelegate! handler) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\nstatic Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapPut(this Microsoft.AspNetCore.Routing.IRouteBuilder! builder, string! template, System.Func<Microsoft.AspNetCore.Http.HttpRequest!, Microsoft.AspNetCore.Http.HttpResponse!, Microsoft.AspNetCore.Routing.RouteData!, System.Threading.Tasks.Task!>! handler) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining CreatedAtRoute Result Methods in C#\nDESCRIPTION: These methods create CreatedAtRoute results with optional route name, values, and content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.CreatedAtRoute(string? routeName = null, object? routeValues = null) -> Microsoft.AspNetCore.Http.HttpResults.CreatedAtRoute!\nstatic Microsoft.AspNetCore.Http.TypedResults.CreatedAtRoute(string? routeName, Microsoft.AspNetCore.Routing.RouteValueDictionary? routeValues) -> Microsoft.AspNetCore.Http.HttpResults.CreatedAtRoute!\nstatic Microsoft.AspNetCore.Http.TypedResults.CreatedAtRoute<TValue>(TValue? value, string? routeName = null, object? routeValues = null) -> Microsoft.AspNetCore.Http.HttpResults.CreatedAtRoute<TValue>!\nstatic Microsoft.AspNetCore.Http.TypedResults.CreatedAtRoute<TValue>(TValue? value, string? routeName, Microsoft.AspNetCore.Routing.RouteValueDictionary? routeValues) -> Microsoft.AspNetCore.Http.HttpResults.CreatedAtRoute<TValue>!\n```\n\n----------------------------------------\n\nTITLE: Implementing OAuthOptions Class in C#\nDESCRIPTION: This class defines the options for configuring OAuth authentication, including endpoints, client credentials, and claim actions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OAuth/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthOptions\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthOptions.OAuthOptions() -> void\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthOptions.AuthorizationEndpoint.get -> string!\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthOptions.AuthorizationEndpoint.set -> void\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthOptions.TokenEndpoint.get -> string!\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthOptions.TokenEndpoint.set -> void\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthOptions.UserInformationEndpoint.get -> string!\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthOptions.UserInformationEndpoint.set -> void\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthOptions.ClientId.get -> string!\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthOptions.ClientId.set -> void\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthOptions.ClientSecret.get -> string!\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthOptions.ClientSecret.set -> void\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthOptions.Scope.get -> System.Collections.Generic.ICollection<string!>!\nMicrosoft.AspNetCore.Authentication.OAuth.OAuthOptions.ClaimActions.get -> Microsoft.AspNetCore.Authentication.OAuth.Claims.ClaimActionCollection!\n```\n\n----------------------------------------\n\nTITLE: Remote Authentication Service Methods in ASP.NET Core WebAssembly\nDESCRIPTION: Virtual methods of the RemoteAuthenticationService class for handling authentication operations in WebAssembly applications. These methods implement sign-in, sign-out, access token acquisition, and user retrieval functionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationService<TRemoteAuthenticationState, TAccount, TProviderOptions>.CompleteSignInAsync(Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationContext<TRemoteAuthenticationState!>! context) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationResult<TRemoteAuthenticationState!>!>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationService<TRemoteAuthenticationState, TAccount, TProviderOptions>.CompleteSignOutAsync(Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationContext<TRemoteAuthenticationState!>! context) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationResult<TRemoteAuthenticationState!>!>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationService<TRemoteAuthenticationState, TAccount, TProviderOptions>.GetAuthenticatedUser() -> System.Threading.Tasks.ValueTask<System.Security.Claims.ClaimsPrincipal!>\n```\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationService<TRemoteAuthenticationState, TAccount, TProviderOptions>.RequestAccessToken() -> System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Components.WebAssembly.Authentication.AccessTokenResult!>\n```\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationService<TRemoteAuthenticationState, TAccount, TProviderOptions>.RequestAccessToken(Microsoft.AspNetCore.Components.WebAssembly.Authentication.AccessTokenRequestOptions! options) -> System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Components.WebAssembly.Authentication.AccessTokenResult!>\n```\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationService<TRemoteAuthenticationState, TAccount, TProviderOptions>.SignInAsync(Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationContext<TRemoteAuthenticationState!>! context) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationResult<TRemoteAuthenticationState!>!>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationService<TRemoteAuthenticationState, TAccount, TProviderOptions>.SignOutAsync(Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationContext<TRemoteAuthenticationState!>! context) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationResult<TRemoteAuthenticationState!>!>!\n```\n\n----------------------------------------\n\nTITLE: Configuring Microsoft Account Authentication Extensions\nDESCRIPTION: Extension methods for adding Microsoft Account authentication to the ASP.NET Core authentication pipeline with various configuration options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/MicrosoftAccount/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.MicrosoftAccountExtensions.AddMicrosoftAccount(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.MicrosoftAccountExtensions.AddMicrosoftAccount(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, System.Action<Microsoft.AspNetCore.Authentication.MicrosoftAccount.MicrosoftAccountOptions!>! configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n```\n\n----------------------------------------\n\nTITLE: SignInOptions Class Properties and Methods\nDESCRIPTION: Class that handles configuration options for user sign-in functionality including email confirmation and phone number verification requirements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class SignInOptions {\n    public bool RequireConfirmedEmail { get; set; }\n    public bool RequireConfirmedPhoneNumber { get; set; }\n    public SignInOptions() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WriteJsonResponseAsync Method in C#\nDESCRIPTION: Writes a JSON response to the HTTP response stream, handling potential trimming and AOT compilation issues.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_NoParam_StringReturn_WithFilter.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        // ... (implementation details)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Request Delegate Factory Function in ASP.NET Core\nDESCRIPTION: Implements a request delegate factory function that sets up JSON serialization options, builds filter delegates if needed, and prepares request handling based on parameter binding and content negotiation requirements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nRequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n{\n    Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n    Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n    Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n    Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n    var handler = Cast(del, global::System.String (global::Microsoft.AspNetCore.Http.HttpContext arg0, global::Microsoft.AspNetCore.Http.Generators.Tests.MyBothBindAsyncStruct arg1) => throw null!);\n    EndpointFilterDelegate? filteredInvocation = null;\n    var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n    var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n    var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n    var jsonSerializerOptions = jsonOptions.SerializerOptions;\n    jsonSerializerOptions.MakeReadOnly();\n    var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n    var parameters = del.Method.GetParameters();\n```\n\n----------------------------------------\n\nTITLE: Invalid Content Type Handlers\nDESCRIPTION: Handles unexpected content type scenarios for both JSON and form data requests. Implements status code 415 for unsupported media types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_TakesCustomMetadataEmitter_Has_Metadata.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Defining IHttpApplication Interface in ASP.NET Core Server\nDESCRIPTION: Generic interface that defines the contract for HTTP application processing. It provides methods for creating a context from feature collections, processing HTTP requests asynchronously, and disposing contexts when processing is complete.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Server.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Hosting.Server.IHttpApplication<TContext>\nMicrosoft.AspNetCore.Hosting.Server.IHttpApplication<TContext>.CreateContext(Microsoft.AspNetCore.Http.Features.IFeatureCollection! contextFeatures) -> TContext\nMicrosoft.AspNetCore.Hosting.Server.IHttpApplication<TContext>.DisposeContext(TContext context, System.Exception? exception) -> void\nMicrosoft.AspNetCore.Hosting.Server.IHttpApplication<TContext>.ProcessRequestAsync(TContext context) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Writing JSON Response in ASP.NET Core\nDESCRIPTION: This method writes a JSON response to the HTTP response. It handles type checking and uses the appropriate serialization method based on the runtime type and JSON type information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: AuthorizeAsync Method Signatures in DefaultAuthorizationService\nDESCRIPTION: Defines two overloads of the AuthorizeAsync virtual method for the DefaultAuthorizationService class. The first method authorizes against a policy name, while the second authorizes against explicit requirements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authorization.DefaultAuthorizationService.AuthorizeAsync(System.Security.Claims.ClaimsPrincipal! user, object? resource, string! policyName) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authorization.AuthorizationResult!>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authorization.DefaultAuthorizationService.AuthorizeAsync(System.Security.Claims.ClaimsPrincipal! user, object? resource, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.IAuthorizationRequirement!>! requirements) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authorization.AuthorizationResult!>!\n```\n\n----------------------------------------\n\nTITLE: Filter Delegate Builder for Request Pipeline\nDESCRIPTION: Constructs a filtered delegate chain for request processing by applying endpoint filters in reverse order. Uses EndpointFilterFactoryContext for filter configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsDifferentInterceptorsFromSameLocation.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IServerAddressesFeature Interface in ASP.NET Core\nDESCRIPTION: Interface that provides access to server addresses and configuration for URL preferences. It exposes a collection of server address strings and a flag to determine if hosting URLs should be preferred.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Server.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Hosting.Server.Features.IServerAddressesFeature\nMicrosoft.AspNetCore.Hosting.Server.Features.IServerAddressesFeature.Addresses.get -> System.Collections.Generic.ICollection<string!>!\nMicrosoft.AspNetCore.Hosting.Server.Features.IServerAddressesFeature.PreferHostingUrls.get -> bool\nMicrosoft.AspNetCore.Hosting.Server.Features.IServerAddressesFeature.PreferHostingUrls.set -> void\n```\n\n----------------------------------------\n\nTITLE: Casting Delegate in C#\nDESCRIPTION: A generic method to cast a Delegate to a specific delegate type T.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n```\n\n----------------------------------------\n\nTITLE: Authentication Token Management Extension Methods in ASP.NET Core\nDESCRIPTION: Extension methods for managing authentication tokens in ASP.NET Core. These methods provide functionality to retrieve, store, and update authentication tokens for authenticated sessions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Authentication.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Authentication.AuthenticationTokenExtensions.GetTokenAsync(this Microsoft.AspNetCore.Authentication.IAuthenticationService! auth, Microsoft.AspNetCore.Http.HttpContext! context, string! tokenName) -> System.Threading.Tasks.Task<string?>!\nstatic Microsoft.AspNetCore.Authentication.AuthenticationTokenExtensions.GetTokenAsync(this Microsoft.AspNetCore.Authentication.IAuthenticationService! auth, Microsoft.AspNetCore.Http.HttpContext! context, string? scheme, string! tokenName) -> System.Threading.Tasks.Task<string?>!\nstatic Microsoft.AspNetCore.Authentication.AuthenticationTokenExtensions.GetTokens(this Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties) -> System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authentication.AuthenticationToken!>!\nstatic Microsoft.AspNetCore.Authentication.AuthenticationTokenExtensions.GetTokenValue(this Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, string! tokenName) -> string?\nstatic Microsoft.AspNetCore.Authentication.AuthenticationTokenExtensions.StoreTokens(this Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authentication.AuthenticationToken!>! tokens) -> void\nstatic Microsoft.AspNetCore.Authentication.AuthenticationTokenExtensions.UpdateTokenValue(this Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, string! tokenName, string! tokenValue) -> bool\n```\n\n----------------------------------------\n\nTITLE: Cookie Authentication Configuration in C#\nDESCRIPTION: Post-configuration class for cookie authentication options that applies default configurations and data protection to cookie authentication options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Cookies/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.Cookies.PostConfigureCookieAuthenticationOptions\nMicrosoft.AspNetCore.Authentication.Cookies.PostConfigureCookieAuthenticationOptions.PostConfigure(string? name, Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions! options) -> void\nMicrosoft.AspNetCore.Authentication.Cookies.PostConfigureCookieAuthenticationOptions.PostConfigureCookieAuthenticationOptions(Microsoft.AspNetCore.DataProtection.IDataProtectionProvider! dataProtection) -> void\n```\n\n----------------------------------------\n\nTITLE: Required Parameter Missing Handler in C#\nDESCRIPTION: Handles cases where a required parameter is not provided in the request. Includes exception throwing and structured logging functionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n    }\n}\n\nprivate static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n    LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n```\n\n----------------------------------------\n\nTITLE: MapCore Core Endpoint Routing Implementation in C#\nDESCRIPTION: Core implementation for mapping endpoints in ASP.NET Core routing. Handles route pattern matching, delegates, and HTTP method constraints.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndPut_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Message for Parameter Binding Failure in C#\nDESCRIPTION: This snippet defines a LoggerMessage for logging parameter binding failures. It uses LogLevel.Debug and creates an EventId for the message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n    LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Configuring Anonymous Access in ASP.NET Core Razor Pages\nDESCRIPTION: Extension methods for PageConventionCollection that allow anonymous access to pages and folders. These methods allow developers to specify pages that don't require authentication, with support for areas.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.PageConventionCollectionExtensions.AllowAnonymousToAreaFolder(this Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection! conventions, string! areaName, string! folderPath) -> Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection!\nstatic Microsoft.Extensions.DependencyInjection.PageConventionCollectionExtensions.AllowAnonymousToAreaPage(this Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection! conventions, string! areaName, string! pageName) -> Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection!\nstatic Microsoft.Extensions.DependencyInjection.PageConventionCollectionExtensions.AllowAnonymousToFolder(this Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection! conventions, string! folderPath) -> Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection!\nstatic Microsoft.Extensions.DependencyInjection.PageConventionCollectionExtensions.AllowAnonymousToPage(this Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection! conventions, string! pageName) -> Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection!\n```\n\n----------------------------------------\n\nTITLE: Negotiate Authentication Event Handlers\nDESCRIPTION: Virtual methods for handling different stages of the Negotiate authentication process including successful authentication, failed attempts, challenges, and LDAP claim retrieval.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Negotiate/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authentication.Negotiate.NegotiateEvents.Authenticated(Microsoft.AspNetCore.Authentication.Negotiate.AuthenticatedContext! context) -> System.Threading.Tasks.Task!\n```\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authentication.Negotiate.NegotiateEvents.AuthenticationFailed(Microsoft.AspNetCore.Authentication.Negotiate.AuthenticationFailedContext! context) -> System.Threading.Tasks.Task!\n```\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authentication.Negotiate.NegotiateEvents.Challenge(Microsoft.AspNetCore.Authentication.Negotiate.ChallengeContext! context) -> System.Threading.Tasks.Task!\n```\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authentication.Negotiate.NegotiateEvents.RetrieveLdapClaims(Microsoft.AspNetCore.Authentication.Negotiate.LdapContext! context) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Adding Razor Components Services in C#\nDESCRIPTION: Extension method for IServiceCollection to add Razor Components services. It allows optional configuration through an action parameter.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Endpoints/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.RazorComponentsServiceCollectionExtensions.AddRazorComponents(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Components.Endpoints.RazorComponentsServiceOptions!>? configure = null) -> Microsoft.Extensions.DependencyInjection.IRazorComponentsBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining AuthorizationCodeReceivedContext Class in C#\nDESCRIPTION: This class represents the context for receiving an authorization code in OpenID Connect. It includes methods for handling code redemption and properties for various aspects of the authentication process.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthorizationCodeReceivedContext\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthorizationCodeReceivedContext.AuthorizationCodeReceivedContext(Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Authentication.AuthenticationScheme! scheme, Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectOptions! options, Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties) -> void\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthorizationCodeReceivedContext.Backchannel.get -> System.Net.Http.HttpClient!\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthorizationCodeReceivedContext.HandleCodeRedemption() -> void\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthorizationCodeReceivedContext.HandleCodeRedemption(Microsoft.IdentityModel.Protocols.OpenIdConnect.OpenIdConnectMessage! tokenEndpointResponse) -> void\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthorizationCodeReceivedContext.HandleCodeRedemption(string! accessToken, string! idToken) -> void\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthorizationCodeReceivedContext.HandledCodeRedemption.get -> bool\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthorizationCodeReceivedContext.JwtSecurityToken.get -> System.IdentityModel.Tokens.Jwt.JwtSecurityToken?\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthorizationCodeReceivedContext.JwtSecurityToken.set -> void\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthorizationCodeReceivedContext.ProtocolMessage.get -> Microsoft.IdentityModel.Protocols.OpenIdConnect.OpenIdConnectMessage!\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthorizationCodeReceivedContext.ProtocolMessage.set -> void\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthorizationCodeReceivedContext.TokenEndpointRequest.get -> Microsoft.IdentityModel.Protocols.OpenIdConnect.OpenIdConnectMessage?\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthorizationCodeReceivedContext.TokenEndpointRequest.set -> void\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthorizationCodeReceivedContext.TokenEndpointResponse.get -> Microsoft.IdentityModel.Protocols.OpenIdConnect.OpenIdConnectMessage?\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthorizationCodeReceivedContext.TokenEndpointResponse.set -> void\n```\n\n----------------------------------------\n\nTITLE: KeyboardEventArgs Class for ASP.NET Core Blazor Events\nDESCRIPTION: Defines the KeyboardEventArgs class for keyboard events in Blazor. Contains properties for key information, keyboard state, and event metadata for keyboard events triggered in browser-based Blazor applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.AltKey.get -> bool\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.AltKey.set -> void\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.Code.get -> string!\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.Code.set -> void\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.CtrlKey.get -> bool\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.CtrlKey.set -> void\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.IsComposing.get -> bool\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.IsComposing.set -> void\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.Key.get -> string!\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.Key.set -> void\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.KeyboardEventArgs() -> void\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.Location.get -> float\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.Location.set -> void\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.MetaKey.get -> bool\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.MetaKey.set -> void\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.Repeat.get -> bool\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.Repeat.set -> void\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.ShiftKey.get -> bool\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.ShiftKey.set -> void\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.Type.get -> string!\nMicrosoft.AspNetCore.Components.Web.KeyboardEventArgs.Type.set -> void\n```\n\n----------------------------------------\n\nTITLE: Append Cookie Context for Cookie Operations\nDESCRIPTION: Context class used during cookie append operations, providing access to the current HttpContext, cookie options, and consent information. Used by the OnAppendCookie callback in CookiePolicyOptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/CookiePolicy/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.CookiePolicy.AppendCookieContext\nMicrosoft.AspNetCore.CookiePolicy.AppendCookieContext.AppendCookieContext(Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Http.CookieOptions! options, string! name, string! value) -> void\nMicrosoft.AspNetCore.CookiePolicy.AppendCookieContext.Context.get -> Microsoft.AspNetCore.Http.HttpContext!\nMicrosoft.AspNetCore.CookiePolicy.AppendCookieContext.CookieName.get -> string!\nMicrosoft.AspNetCore.CookiePolicy.AppendCookieContext.CookieName.set -> void\nMicrosoft.AspNetCore.CookiePolicy.AppendCookieContext.CookieOptions.get -> Microsoft.AspNetCore.Http.CookieOptions!\nMicrosoft.AspNetCore.CookiePolicy.AppendCookieContext.CookieValue.get -> string!\nMicrosoft.AspNetCore.CookiePolicy.AppendCookieContext.CookieValue.set -> void\nMicrosoft.AspNetCore.CookiePolicy.AppendCookieContext.HasConsent.get -> bool\nMicrosoft.AspNetCore.CookiePolicy.AppendCookieContext.IsConsentNeeded.get -> bool\nMicrosoft.AspNetCore.CookiePolicy.AppendCookieContext.IssueCookie.get -> bool\nMicrosoft.AspNetCore.CookiePolicy.AppendCookieContext.IssueCookie.set -> void\n```\n\n----------------------------------------\n\nTITLE: Application Model Convention Extensions for MVC in ASP.NET Core\nDESCRIPTION: Extension methods for managing application model conventions in ASP.NET Core MVC. These methods allow adding specific types of conventions (action, controller, parameter) to the conventions collection and removing conventions by type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.ApplicationModelConventionExtensions.Add(this System.Collections.Generic.IList<Microsoft.AspNetCore.Mvc.ApplicationModels.IApplicationModelConvention!>! conventions, Microsoft.AspNetCore.Mvc.ApplicationModels.IActionModelConvention! actionModelConvention) -> void\nstatic Microsoft.Extensions.DependencyInjection.ApplicationModelConventionExtensions.Add(this System.Collections.Generic.IList<Microsoft.AspNetCore.Mvc.ApplicationModels.IApplicationModelConvention!>! conventions, Microsoft.AspNetCore.Mvc.ApplicationModels.IControllerModelConvention! controllerModelConvention) -> void\nstatic Microsoft.Extensions.DependencyInjection.ApplicationModelConventionExtensions.Add(this System.Collections.Generic.IList<Microsoft.AspNetCore.Mvc.ApplicationModels.IApplicationModelConvention!>! conventions, Microsoft.AspNetCore.Mvc.ApplicationModels.IParameterModelBaseConvention! parameterModelConvention) -> void\nstatic Microsoft.Extensions.DependencyInjection.ApplicationModelConventionExtensions.Add(this System.Collections.Generic.IList<Microsoft.AspNetCore.Mvc.ApplicationModels.IApplicationModelConvention!>! conventions, Microsoft.AspNetCore.Mvc.ApplicationModels.IParameterModelConvention! parameterModelConvention) -> void\nstatic Microsoft.Extensions.DependencyInjection.ApplicationModelConventionExtensions.RemoveType(this System.Collections.Generic.IList<Microsoft.AspNetCore.Mvc.ApplicationModels.IApplicationModelConvention!>! list, System.Type! type) -> void\nstatic Microsoft.Extensions.DependencyInjection.ApplicationModelConventionExtensions.RemoveType<TApplicationModelConvention>(this System.Collections.Generic.IList<Microsoft.AspNetCore.Mvc.ApplicationModels.IApplicationModelConvention!>! list) -> void\n```\n\n----------------------------------------\n\nTITLE: Filtered Request Handler Implementation for ASP.NET Core Endpoints\nDESCRIPTION: Implements the filtered request handler that processes HTTP requests through a filter pipeline. It handles parameter extraction, validation, error conditions, and async invocation of the endpoint handler through filters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandlerFiltered(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParameterListRecordStruct, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)\n                    var HttpContext_local = httpContext;\n    // Endpoint Parameter: Value (Type = int, IsOptional = False, IsParsable = True, IsArray = False, Source = RouteOrQuery)\n    var Value_raw = Value_RouteOrQueryResolver(httpContext);\n    if (Value_raw is StringValues { Count: 0 })\n    {\n        wasParamCheckFailure = true;\n        logOrThrowExceptionHelper.RequiredParameterNotProvided(\"int\", \"Value\", \"route or query string\");\n    }\n    var Value_temp = (string?)Value_raw;\n    if (!GeneratedRouteBuilderExtensionsCore.TryParseExplicit<int>(Value_temp!, CultureInfo.InvariantCulture, out var Value_parsed_temp))\n    {\n        if (!string.IsNullOrEmpty(Value_temp))\n        {\n            logOrThrowExceptionHelper.ParameterBindingFailed(\"int\", \"Value\", Value_temp);\n            wasParamCheckFailure = true;\n        }\n    }\n    int Value_local = Value_parsed_temp!;\n\n    var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListRecordStruct { HttpContext = HttpContext_local, Value = Value_local };\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n    }\n    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListRecordStruct>(httpContext, args_local));\n    if (result is not null)\n    {\n\n\n```\n\n----------------------------------------\n\nTITLE: Extension Methods for HTTPS Configuration in C#\nDESCRIPTION: Extension methods for configuring HTTPS and HSTS in the ASP.NET Core application builder and service collection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpsPolicy/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static class HstsBuilderExtensions\n{\n    public static IApplicationBuilder UseHsts(this IApplicationBuilder app);\n}\n\npublic static class HttpsPolicyBuilderExtensions\n{\n    public static IApplicationBuilder UseHttpsRedirection(this IApplicationBuilder app);\n}\n\npublic static class HttpsRedirectionServicesExtensions\n{\n    public static IServiceCollection AddHttpsRedirection(this IServiceCollection services, Action<HttpsRedirectionOptions> configureOptions);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet0 Method for HTTP GET Endpoint Registration\nDESCRIPTION: A core method that extends IEndpointRouteBuilder to register HTTP GET endpoints. It handles metadata population, request delegation, parameter binding from headers, and response serialization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_StringArrayParam.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n%INTERCEPTSLOCATIONATTRIBUTE%\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(global::System.Int32), contentTypes: GeneratedMetadataConstants.JsonContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n        Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n        var handler = Cast(del, global::System.Int32 (global::System.String[] arg0) => throw null!);\n        EndpointFilterDelegate? filteredInvocation = null;\n        var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n        var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n        var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n        var jsonSerializerOptions = jsonOptions.SerializerOptions;\n        jsonSerializerOptions.MakeReadOnly();\n        var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n        var responseJsonTypeInfo =  (JsonTypeInfo<global::System.Int32>)jsonSerializerOptions.GetTypeInfo(typeof(global::System.Int32));\n\n        if (options.EndpointBuilder.FilterFactories.Count > 0)\n        {\n            filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n            {\n                if (ic.HttpContext.Response.StatusCode == 400)\n                {\n                    return ValueTask.FromResult<object?>(Results.Empty);\n                }\n                return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::System.String[]>(0)!));\n            },\n            options.EndpointBuilder,\n            handler.Method);\n        }\n\n        Task RequestHandler(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            // Endpoint Parameter: p (Type = string[], IsOptional = False, IsParsable = False, IsArray = True, Source = Header)\n            var p_raw = httpContext.Request.Headers.GetCommaSeparatedValues(\"p\");\n            var p_temp = p_raw.ToArray();\n            string[] p_local = p_temp!;\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n                return Task.CompletedTask;\n            }\n            var result = handler(p_local);\n            return httpContext.Response.WriteAsJsonAsync(result, responseJsonTypeInfo);\n        }\n\n        async Task RequestHandlerFiltered(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            // Endpoint Parameter: p (Type = string[], IsOptional = False, IsParsable = False, IsArray = True, Source = Header)\n            var p_raw = httpContext.Request.Headers.GetCommaSeparatedValues(\"p\");\n            var p_temp = p_raw.ToArray();\n            string[] p_local = p_temp!;\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n            }\n            var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::System.String[]>(httpContext, p_local));\n            if (result is not null)\n            {\n                await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n            }\n        }\n\n        RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\n        var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\n        return new RequestDelegateResult(targetDelegate, metadata);\n    };\n    var castHandler = Cast(handler, global::System.Int32 (global::System.String[] arg0) => throw null!);\n    return MapCore(\n        endpoints,\n        pattern,\n        handler,\n        GetVerb,\n        populateMetadata,\n        createRequestDelegate,\n        castHandler.Method);\n}\n```\n\n----------------------------------------\n\nTITLE: Validation Components API for Form Validation\nDESCRIPTION: API signatures for ValidationMessage<TValue> and ValidationSummary components that display validation errors for specific fields or the entire form, including properties for attributes and model references.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Forms.ValidationMessage<TValue>\nMicrosoft.AspNetCore.Components.Forms.ValidationMessage<TValue>.AdditionalAttributes.get -> System.Collections.Generic.IReadOnlyDictionary<string!, object!>?\nMicrosoft.AspNetCore.Components.Forms.ValidationMessage<TValue>.AdditionalAttributes.set -> void\nMicrosoft.AspNetCore.Components.Forms.ValidationMessage<TValue>.For.get -> System.Linq.Expressions.Expression<System.Func<TValue>!>?\nMicrosoft.AspNetCore.Components.Forms.ValidationMessage<TValue>.For.set -> void\nMicrosoft.AspNetCore.Components.Forms.ValidationMessage<TValue>.ValidationMessage() -> void\nMicrosoft.AspNetCore.Components.Forms.ValidationSummary\nMicrosoft.AspNetCore.Components.Forms.ValidationSummary.AdditionalAttributes.get -> System.Collections.Generic.IReadOnlyDictionary<string!, object!>?\nMicrosoft.AspNetCore.Components.Forms.ValidationSummary.AdditionalAttributes.set -> void\nMicrosoft.AspNetCore.Components.Forms.ValidationSummary.Model.get -> object?\nMicrosoft.AspNetCore.Components.Forms.ValidationSummary.Model.set -> void\nMicrosoft.AspNetCore.Components.Forms.ValidationSummary.ValidationSummary() -> void\n```\n\n----------------------------------------\n\nTITLE: Extending NavigationManager for Authentication in C#\nDESCRIPTION: Extends the NavigationManager class with methods for navigating to login and logout pages in ASP.NET Core WebAssembly authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.WebAssembly.Authentication.NavigationManagerExtensions.NavigateToLogin(this Microsoft.AspNetCore.Components.NavigationManager! manager, string! loginPath) -> void\nstatic Microsoft.AspNetCore.Components.WebAssembly.Authentication.NavigationManagerExtensions.NavigateToLogin(this Microsoft.AspNetCore.Components.NavigationManager! manager, string! loginPath, Microsoft.AspNetCore.Components.WebAssembly.Authentication.InteractiveRequestOptions! request) -> void\nstatic Microsoft.AspNetCore.Components.WebAssembly.Authentication.NavigationManagerExtensions.NavigateToLogout(this Microsoft.AspNetCore.Components.NavigationManager! manager, string! logoutPath) -> void\nstatic Microsoft.AspNetCore.Components.WebAssembly.Authentication.NavigationManagerExtensions.NavigateToLogout(this Microsoft.AspNetCore.Components.NavigationManager! manager, string! logoutPath, string? returnUrl) -> void\n```\n\n----------------------------------------\n\nTITLE: Core SignalR Classes and Interfaces in C#\nDESCRIPTION: Definitions of core SignalR classes and interfaces including DefaultUserIdProvider, Hub, HubConnectionContext, and HubLifetimeManager<THub>. These classes provide essential functionality for SignalR hubs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.SignalR.DefaultUserIdProvider.GetUserId(Microsoft.AspNetCore.SignalR.HubConnectionContext! connection) -> string?\n```\n\n----------------------------------------\n\nTITLE: Navigation Manager Query Parameter Extensions\nDESCRIPTION: Extension methods for NavigationManager to handle URL query parameters. Supports multiple data types including primitives, nullable types, and date/time types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.NavigationManagerExtensions.GetUriWithQueryParameter(this Microsoft.AspNetCore.Components.NavigationManager! navigationManager, string! name, string? value) -> string!\n```\n\n----------------------------------------\n\nTITLE: Page Link Generator Extensions for Path and URI Building in ASP.NET Core\nDESCRIPTION: Extensions for LinkGenerator to create paths and URIs for Razor Pages. These methods generate URLs based on page names and handlers with options for customizing the resulting URL including scheme, host, path base, and fragment.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.PageLinkGeneratorExtensions.GetPathByPage(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, Microsoft.AspNetCore.Http.HttpContext! httpContext, string? page = null, string? handler = null, object? values = null, Microsoft.AspNetCore.Http.PathString? pathBase = null, Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\nstatic Microsoft.AspNetCore.Routing.PageLinkGeneratorExtensions.GetPathByPage(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, string! page, string? handler = null, object? values = null, Microsoft.AspNetCore.Http.PathString pathBase = default(Microsoft.AspNetCore.Http.PathString), Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\nstatic Microsoft.AspNetCore.Routing.PageLinkGeneratorExtensions.GetUriByPage(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, Microsoft.AspNetCore.Http.HttpContext! httpContext, string? page = null, string? handler = null, object? values = null, string? scheme = null, Microsoft.AspNetCore.Http.HostString? host = null, Microsoft.AspNetCore.Http.PathString? pathBase = null, Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\nstatic Microsoft.AspNetCore.Routing.PageLinkGeneratorExtensions.GetUriByPage(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, string! page, string? handler, object? values, string! scheme, Microsoft.AspNetCore.Http.HostString host, Microsoft.AspNetCore.Http.PathString pathBase = default(Microsoft.AspNetCore.Http.PathString), Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\n```\n\n----------------------------------------\n\nTITLE: Extending ComponentEndpointRouteBuilderExtensions in C#\nDESCRIPTION: Static class providing extension methods for IEndpointRouteBuilder to map Blazor hub endpoints with various configuration options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions.MapBlazorHub(this Microsoft.AspNetCore.Routing.IEndpointRouteBuilder! endpoints) -> Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder!\nstatic Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions.MapBlazorHub(this Microsoft.AspNetCore.Routing.IEndpointRouteBuilder! endpoints, string! path) -> Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder!\nstatic Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions.MapBlazorHub(this Microsoft.AspNetCore.Routing.IEndpointRouteBuilder! endpoints, string! path, System.Action<Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions!>! configureOptions) -> Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder!\nstatic Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions.MapBlazorHub(this Microsoft.AspNetCore.Routing.IEndpointRouteBuilder! endpoints, System.Action<Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions!>! configureOptions) -> Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder!\n```\n\n----------------------------------------\n\nTITLE: Starting and Stopping SignalR HubConnection in C#\nDESCRIPTION: Provides methods for asynchronously starting and stopping the SignalR hub connection, with support for cancellation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.SignalR.Client.HubConnection.StartAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.SignalR.Client.HubConnection.StopAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Cookie Manager Interface in C#\nDESCRIPTION: Interface that defines operations for managing cookies in ASP.NET Core, including methods to append cookies to responses, retrieve cookies from requests, and delete cookies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Cookies/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.Cookies.ICookieManager\nMicrosoft.AspNetCore.Authentication.Cookies.ICookieManager.AppendResponseCookie(Microsoft.AspNetCore.Http.HttpContext! context, string! key, string? value, Microsoft.AspNetCore.Http.CookieOptions! options) -> void\nMicrosoft.AspNetCore.Authentication.Cookies.ICookieManager.DeleteCookie(Microsoft.AspNetCore.Http.HttpContext! context, string! key, Microsoft.AspNetCore.Http.CookieOptions! options) -> void\nMicrosoft.AspNetCore.Authentication.Cookies.ICookieManager.GetRequestCookie(Microsoft.AspNetCore.Http.HttpContext! context, string! key) -> string?\n```\n\n----------------------------------------\n\nTITLE: Configuring Remote Authentication in ASP.NET Core WebAssembly\nDESCRIPTION: Extension methods for adding customizable remote authentication services to WebAssembly applications. These methods support generic type parameters for authentication state, account type, and provider options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.WebAssemblyAuthenticationServiceCollectionExtensions.AddRemoteAuthentication<TRemoteAuthenticationState, TAccount, TProviderOptions>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<TRemoteAuthenticationState!, TAccount!>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.WebAssemblyAuthenticationServiceCollectionExtensions.AddRemoteAuthentication<TRemoteAuthenticationState, TAccount, TProviderOptions>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationOptions<TProviderOptions!>!>? configure) -> Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<TRemoteAuthenticationState!, TAccount!>!\n```\n\n----------------------------------------\n\nTITLE: JSRuntime Extension Methods for Void Operations\nDESCRIPTION: Extension methods for IJSRuntime to invoke JavaScript functions that don't return values, with support for cancellation tokens and timeouts.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/JSInterop/Microsoft.JSInterop/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.JSInterop.JSRuntimeExtensions.InvokeVoidAsync(this Microsoft.JSInterop.IJSRuntime! jsRuntime, string! identifier, params object?[]? args) -> System.Threading.Tasks.ValueTask\nstatic Microsoft.JSInterop.JSRuntimeExtensions.InvokeVoidAsync(this Microsoft.JSInterop.IJSRuntime! jsRuntime, string! identifier, System.Threading.CancellationToken cancellationToken, params object?[]? args) -> System.Threading.Tasks.ValueTask\nstatic Microsoft.JSInterop.JSRuntimeExtensions.InvokeVoidAsync(this Microsoft.JSInterop.IJSRuntime! jsRuntime, string! identifier, System.TimeSpan timeout, params object?[]? args) -> System.Threading.Tasks.ValueTask\n```\n\n----------------------------------------\n\nTITLE: Handling Unsupported Form Content Type in ASP.NET Core\nDESCRIPTION: Handles cases where a form media type was expected but an unsupported content type was provided. Returns a 415 Unsupported Media Type status code when throwing exceptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Route Handler in ASP.NET Core\nDESCRIPTION: Generated extension method for mapping GET requests with metadata population and request delegate creation. Handles JSON body parsing, parameter binding, and response serialization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n        var serviceProviderIsService = serviceProvider.GetRequiredService<IServiceProviderIsService>();\n        var jsonBodyOrServiceTypeTuples = new (bool, Type)[] {\n            #nullable disable\n            (false, typeof(global::System.String[])),\n            #nullable enable\n        };\n        foreach (var (isOptional, type) in jsonBodyOrServiceTypeTuples)\n        {\n            if (!serviceProviderIsService.IsService(type))\n            {\n                options.EndpointBuilder.Metadata.Add(new AcceptsMetadata(type: type, isOptional: isOptional, contentTypes: GeneratedMetadataConstants.JsonContentType));\n                break;\n            }\n        }\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(global::System.Int32), contentTypes: GeneratedMetadataConstants.JsonContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: QueryCollection Class API\nDESCRIPTION: Defines the public API surface for handling HTTP query string parameters\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.QueryCollection.ContainsKey(string! key) -> bool\nMicrosoft.AspNetCore.Http.QueryCollection.Count.get -> int\nMicrosoft.AspNetCore.Http.QueryCollection.GetEnumerator() -> QueryCollection.Enumerator\n```\n\n----------------------------------------\n\nTITLE: Configuring SignalR Hub Connection Extensions in C#\nDESCRIPTION: Extension methods for configuring SignalR client connections using URLs, transport types, and connection options. Includes methods for both string and Uri-based URLs, with optional transport configuration and HTTP connection options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\nMicrosoft.AspNetCore.SignalR.Client.HubConnectionBuilderHttpExtensions\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionBuilderHttpExtensions.WithStatefulReconnect(this Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder! hubConnectionBuilder) -> Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionBuilderHttpExtensions.WithUrl(this Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder! hubConnectionBuilder, string! url) -> Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionBuilderHttpExtensions.WithUrl(this Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder! hubConnectionBuilder, string! url, Microsoft.AspNetCore.Http.Connections.HttpTransportType transports) -> Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionBuilderHttpExtensions.WithUrl(this Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder! hubConnectionBuilder, string! url, Microsoft.AspNetCore.Http.Connections.HttpTransportType transports, System.Action<Microsoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions!>! configureHttpConnection) -> Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionBuilderHttpExtensions.WithUrl(this Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder! hubConnectionBuilder, string! url, System.Action<Microsoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions!>! configureHttpConnection) -> Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionBuilderHttpExtensions.WithUrl(this Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder! hubConnectionBuilder, System.Uri! url) -> Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionBuilderHttpExtensions.WithUrl(this Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder! hubConnectionBuilder, System.Uri! url, Microsoft.AspNetCore.Http.Connections.HttpTransportType transports) -> Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionBuilderHttpExtensions.WithUrl(this Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder! hubConnectionBuilder, System.Uri! url, Microsoft.AspNetCore.Http.Connections.HttpTransportType transports, System.Action<Microsoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions!>! configureHttpConnection) -> Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionBuilderHttpExtensions.WithUrl(this Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder! hubConnectionBuilder, System.Uri! url, System.Action<Microsoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions!>! configureHttpConnection) -> Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder!\n```\n\n----------------------------------------\n\nTITLE: IHeaderDictionary Interface Definition in C#\nDESCRIPTION: Defines the interface for HTTP header management in ASP.NET Core, providing strongly-typed access to standard HTTP headers. Includes getters and setters for common HTTP headers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Features/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.IHeaderDictionary\nMicrosoft.AspNetCore.Http.IHeaderDictionary.Accept.get -> Microsoft.Extensions.Primitives.StringValues\nMicrosoft.AspNetCore.Http.IHeaderDictionary.Accept.set -> void\n// ... additional header definitions\n```\n\n----------------------------------------\n\nTITLE: Filtered Request Handler with Parameter Binding in ASP.NET Core\nDESCRIPTION: Implements a filtered request handler that binds parameters asynchronously, handles validation failures, and processes the request through an endpoint filter pipeline. The method supports null-checking and proper response handling based on filter results.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandlerFiltered(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var myBindAsyncParam_local = await BindAsync<global::Microsoft.AspNetCore.Http.Generators.Tests.BindAsyncFromExplicitStaticAbstractInterface>(httpContext, parameters[0]);\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n    }\n    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.BindAsyncFromExplicitStaticAbstractInterface?>(httpContext, myBindAsyncParam_local));\n    if (result is not null)\n    {\n        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Role Management Methods in ASP.NET Core Identity\nDESCRIPTION: Virtual methods for managing roles in ASP.NET Core Identity, including CRUD operations, claim management, and role validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Identity.RoleManager<TRole>.CreateAsync(TRole! role) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\nvirtual Microsoft.AspNetCore.Identity.RoleManager<TRole>.DeleteAsync(TRole! role) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\nvirtual Microsoft.AspNetCore.Identity.RoleManager<TRole>.FindByIdAsync(string! roleId) -> System.Threading.Tasks.Task<TRole?>!\n```\n\n----------------------------------------\n\nTITLE: Processing Invalid Form Request Bodies in ASP.NET Core\nDESCRIPTION: Handles invalid form request bodies by either throwing a BadHttpRequestException or logging the error. Includes parameter type and name information in the error message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n        {\n            if (_shouldThrow)\n            {\n                var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n                throw new BadHttpRequestException(message, exception);\n            }\n\n            if (_rdgLogger != null)\n            {\n                _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n            }\n        }\n```\n\n----------------------------------------\n\nTITLE: HTTP Features Class Definitions in C#\nDESCRIPTION: Defines core HTTP feature interfaces and classes for ASP.NET Core, including request lifetime management, response handling, and activity tracking.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic class HttpRequestLifetimeFeature {\n    public CancellationToken RequestAborted { get; set; }\n}\n\npublic class HttpResponseFeature {\n    public Stream Body { get; set; }\n    public IHeaderDictionary Headers { get; set; }\n    public string? ReasonPhrase { get; set; }\n    public int StatusCode { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ProblemHttpResult in ASP.NET Core\nDESCRIPTION: API signatures for the ProblemHttpResult class which returns RFC 7807 problem details responses with a specified ProblemDetails object and status code.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.ProblemHttpResult\nMicrosoft.AspNetCore.Http.HttpResults.ProblemHttpResult.ContentType.get -> string!\nMicrosoft.AspNetCore.Http.HttpResults.ProblemHttpResult.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.ProblemHttpResult.ProblemDetails.get -> Microsoft.AspNetCore.Mvc.ProblemDetails!\nMicrosoft.AspNetCore.Http.HttpResults.ProblemHttpResult.StatusCode.get -> int\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Extension Method for RouteBuilder in C#\nDESCRIPTION: Implements a MapGet extension method for IEndpointRouteBuilder. It handles GET requests, processes query parameters, and supports endpoint filtering and metadata population.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleEnumParam_StringReturn.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedRouteBuilderExtensionsCore\n{\n    private static readonly JsonOptions FallbackJsonOptions = new();\n    private static readonly string[] GetVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Get };\n\n    %INTERCEPTSLOCATIONATTRIBUTE%\n    internal static RouteHandlerBuilder MapGet0(\n        this IEndpointRouteBuilder endpoints,\n        [StringSyntax(\"Route\")] string pattern,\n        Delegate handler)\n    {\n        MetadataPopulator populateMetadata = (methodInfo, options) =>\n        {\n            // Metadata population logic\n        };\n        RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n        {\n            // Request delegate creation logic\n        };\n\n        // Rest of the implementation\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining QueryBuilder Class in C#\nDESCRIPTION: This snippet defines the QueryBuilder class, which is used to construct query strings for URLs. It includes constructors and methods for adding key-value pairs and converting to a QueryString.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Extensions.QueryBuilder\nMicrosoft.AspNetCore.Http.Extensions.QueryBuilder.Add(string! key, string! value) -> void\nMicrosoft.AspNetCore.Http.Extensions.QueryBuilder.Add(string! key, System.Collections.Generic.IEnumerable<string!>! values) -> void\nMicrosoft.AspNetCore.Http.Extensions.QueryBuilder.GetEnumerator() -> System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<string!, string!>>!\nMicrosoft.AspNetCore.Http.Extensions.QueryBuilder.QueryBuilder() -> void\nMicrosoft.AspNetCore.Http.Extensions.QueryBuilder.QueryBuilder(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string!, Microsoft.Extensions.Primitives.StringValues>>! parameters) -> void\nMicrosoft.AspNetCore.Http.Extensions.QueryBuilder.QueryBuilder(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string!, string!>>! parameters) -> void\nMicrosoft.AspNetCore.Http.Extensions.QueryBuilder.ToQueryString() -> Microsoft.AspNetCore.Http.QueryString\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in C#\nDESCRIPTION: Method to handle invalid form request bodies. It either throws a BadHttpRequestException or logs a debug message depending on the _shouldThrow flag. The method includes parameter type and name information in the error message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Filtered Request Handler Implementation in C#\nDESCRIPTION: Implements request handling with endpoint filtering support. Processes HTTP requests through a filter pipeline and handles parameter binding and response generation with filtering applied.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandlerFiltered(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var httpContext_local = httpContext;\n    var myBindAsyncParam_local = await global::Microsoft.AspNetCore.Http.Generators.Tests.MyNullableBindAsyncStruct.BindAsync(httpContext, parameters[1]);\n    if (!myBindAsyncParam_local.HasValue)\n    {\n        logOrThrowExceptionHelper.RequiredParameterNotProvided(\"MyNullableBindAsyncStruct\", \"myBindAsyncParam\", \"MyNullableBindAsyncStruct.BindAsync(HttpContext, ParameterInfo)\");\n        wasParamCheckFailure = true;\n        myBindAsyncParam_local = default!;\n    }\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n    }\n    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.HttpContext, global::Microsoft.AspNetCore.Http.Generators.Tests.MyNullableBindAsyncStruct>(httpContext, httpContext_local, myBindAsyncParam_local.HasValue ? myBindAsyncParam_local.Value : default));\n    if (result is not null)\n    {\n        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a sealed class InterceptsLocationAttribute used for method interception. It takes a version and data string as parameters in the constructor.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: AcceptedAtAction Result Implementation\nDESCRIPTION: Class implementation for handling HTTP 202 Accepted responses with action-based location headers in ASP.NET Core MVC.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.AcceptedAtActionResult.AcceptedAtActionResult(string? actionName, string? controllerName, object? routeValues, object? value) -> void\nMicrosoft.AspNetCore.Mvc.AcceptedAtActionResult.ActionName.get -> string?\nMicrosoft.AspNetCore.Mvc.AcceptedAtActionResult.ActionName.set -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring Identity with Entity Framework Core in ASP.NET Core\nDESCRIPTION: Code snippet for Program.cs that configures Entity Framework Core with Identity services. It adds the database context and identity services to the application's service collection, enabling authentication and authorization features.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/EntityFrameworkCore/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Services.AddDbContext<ApplicationDbContext>(options =>\n    options.UseSqlServer(builder.Configuration.GetConnectionString(\"DefaultConnection\")));\n\nbuilder.Services.AddDefaultIdentity<ApplicationUser>()\n    .AddEntityFrameworkStores<ApplicationDbContext>();\n```\n\n----------------------------------------\n\nTITLE: Request Error Logging Helper\nDESCRIPTION: Helper class for handling and logging request processing errors, including IO exceptions, JSON parsing failures, and parameter binding issues.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsDifferentInterceptorsFromSameLocation.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    // Additional methods and implementations...\n}\n```\n\n----------------------------------------\n\nTITLE: LinkGenerator Abstract Methods Implementation in C#\nDESCRIPTION: Defines abstract methods for generating URLs and paths based on route addresses and values in ASP.NET Core routing system.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Routing.LinkGenerator.GetPathByAddress<TAddress>(\n    Microsoft.AspNetCore.Http.HttpContext! httpContext,\n    TAddress address,\n    Microsoft.AspNetCore.Routing.RouteValueDictionary! values,\n    Microsoft.AspNetCore.Routing.RouteValueDictionary? ambientValues = null,\n    Microsoft.AspNetCore.Http.PathString? pathBase = null,\n    Microsoft.AspNetCore.Http.FragmentString fragment = default,\n    Microsoft.AspNetCore.Routing.LinkOptions? options = null\n) -> string?\n```\n\n----------------------------------------\n\nTITLE: Processing HTTP Responses in ASP.NET Core Request Handler\nDESCRIPTION: Handles the HTTP response for an endpoint by setting appropriate content type based on the result type and writing the result to the response. Sets 400 status code if parameter validation fails.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n{\n    httpContext.Response.StatusCode = 400;\n    return;\n}\nvar result = handler(myBindAsyncParam_local);\nif (result is string)\n{\n    httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n}\nelse\n{\n    httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n}\nawait httpContext.Response.WriteAsync(result);\n```\n\n----------------------------------------\n\nTITLE: Authentication Result Static Factory Methods in C#\nDESCRIPTION: Static methods for creating AuthenticateResult instances representing different authentication outcomes like success, failure, or no result.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Authentication.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nstatic class AuthenticateResult {\n    static AuthenticateResult Fail(string failureMessage);\n    static AuthenticateResult Fail(Exception failure);\n    static AuthenticateResult NoResult();\n    static AuthenticateResult Success(AuthenticationTicket ticket);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LoginModel for ASP.NET Core Identity UI V5\nDESCRIPTION: This snippet defines the LoginModel class and its nested InputModel for ASP.NET Core Identity UI version 5. It includes properties for managing login information, external logins, and user input.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.ErrorMessage.get -> string?\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.ErrorMessage.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.ExternalLogins.get -> System.Collections.Generic.IList<Microsoft.AspNetCore.Authentication.AuthenticationScheme!>?\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.ExternalLogins.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.Input.get -> Microsoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.InputModel!\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.Input.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.InputModel\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.InputModel.Email.get -> string!\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.InputModel.Email.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.InputModel.InputModel() -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.InputModel.Password.get -> string!\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.InputModel.Password.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.InputModel.RememberMe.get -> bool\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.InputModel.RememberMe.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.LoginModel() -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.ReturnUrl.get -> string?\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginModel.ReturnUrl.set -> void\n```\n\n----------------------------------------\n\nTITLE: IParsable Parameter Parsing for Type Conversion\nDESCRIPTION: Generic method that attempts to parse a string value to a type that implements IParsable<T>. Used for parameter binding in minimal APIs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static bool TryParseExplicit<T>(string? s, IFormatProvider? provider, [MaybeNullWhen(returnValue: false)] out T result) where T: IParsable<T>\n    => T.TryParse(s, provider, out result);\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a sealed attribute class for method interception with version and data parameters. Used for code generation tracking.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleComplexTypeParam_StringReturn.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nfile sealed class InterceptsLocationAttribute : Attribute\n{\n    public InterceptsLocationAttribute(int version, string data)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RemoteAuthenticationService in C#\nDESCRIPTION: Implements the GetAuthenticationStateAsync method in the RemoteAuthenticationService class for retrieving authentication state in ASP.NET Core WebAssembly applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationService<TRemoteAuthenticationState, TAccount, TProviderOptions>.GetAuthenticationStateAsync() -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Components.Authorization.AuthenticationState!>!\n```\n\n----------------------------------------\n\nTITLE: MSAL Provider Options Configuration in C#\nDESCRIPTION: The MsalProviderOptions class defines the configuration for the MSAL provider, including authentication settings, token scopes, and caching options. This class serves as the main configuration point for MSAL authentication in Blazor WebAssembly.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/Authentication.Msal/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions.AdditionalScopesToConsent.get -> System.Collections.Generic.IList<string!>!\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions.AdditionalScopesToConsent.set -> void\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions.Authentication.get -> Microsoft.Authentication.WebAssembly.Msal.MsalAuthenticationOptions!\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions.Authentication.set -> void\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions.Cache.get -> Microsoft.Authentication.WebAssembly.Msal.Models.MsalCacheOptions!\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions.Cache.set -> void\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions.DefaultAccessTokenScopes.get -> System.Collections.Generic.IList<string!>!\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions.DefaultAccessTokenScopes.set -> void\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions.LoginMode.get -> string!\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions.LoginMode.set -> void\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions.MsalProviderOptions() -> void\n```\n\n----------------------------------------\n\nTITLE: Defining IRequestCookieCollection Interface in ASP.NET Core\nDESCRIPTION: Interface for accessing HTTP request cookies. Provides methods to check cookie existence, get values, and access the collection of cookies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Features/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.IRequestCookieCollection {\n    bool ContainsKey(string key);\n    int Count { get; }\n    ICollection<string> Keys { get; }\n    string this[string key] { get; }\n    bool TryGetValue(string key, out string value);\n}\n```\n\n----------------------------------------\n\nTITLE: HtmlRootComponent Class Definition for ASP.NET Core\nDESCRIPTION: Defines the HtmlRootComponent class which represents a rendered component in HTML format. Provides methods to output the rendered HTML as a string or write it to a TextWriter, and access to the component's quiescence status.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Web.HtmlRendering.HtmlRootComponent\nMicrosoft.AspNetCore.Components.Web.HtmlRendering.HtmlRootComponent.HtmlRootComponent() -> void\nMicrosoft.AspNetCore.Components.Web.HtmlRendering.HtmlRootComponent.QuiescenceTask.get -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Components.Web.HtmlRendering.HtmlRootComponent.ToHtmlString() -> string!\nMicrosoft.AspNetCore.Components.Web.HtmlRendering.HtmlRootComponent.WriteHtmlTo(System.IO.TextWriter! output) -> void\n```\n\n----------------------------------------\n\nTITLE: QueryString Utilities and Operators in ASP.NET Core\nDESCRIPTION: Methods for creating and manipulating URL query strings in ASP.NET Core, including creation from key-value pairs and URI components, plus operators for combining query strings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.QueryString.Create(string! name, string! value) -> Microsoft.AspNetCore.Http.QueryString\nstatic Microsoft.AspNetCore.Http.QueryString.Create(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string!, Microsoft.Extensions.Primitives.StringValues>>! parameters) -> Microsoft.AspNetCore.Http.QueryString\nstatic Microsoft.AspNetCore.Http.QueryString.Create(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string!, string?>>! parameters) -> Microsoft.AspNetCore.Http.QueryString\nstatic Microsoft.AspNetCore.Http.QueryString.FromUriComponent(string! uriComponent) -> Microsoft.AspNetCore.Http.QueryString\nstatic Microsoft.AspNetCore.Http.QueryString.FromUriComponent(System.Uri! uri) -> Microsoft.AspNetCore.Http.QueryString\nstatic Microsoft.AspNetCore.Http.QueryString.operator !=(Microsoft.AspNetCore.Http.QueryString left, Microsoft.AspNetCore.Http.QueryString right) -> bool\nstatic Microsoft.AspNetCore.Http.QueryString.operator +(Microsoft.AspNetCore.Http.QueryString left, Microsoft.AspNetCore.Http.QueryString right) -> Microsoft.AspNetCore.Http.QueryString\nstatic Microsoft.AspNetCore.Http.QueryString.operator ==(Microsoft.AspNetCore.Http.QueryString left, Microsoft.AspNetCore.Http.QueryString right) -> bool\n```\n\n----------------------------------------\n\nTITLE: Content Response Methods in ASP.NET Core ControllerBase (C#)\nDESCRIPTION: Methods to return HTTP responses with custom content. These methods allow specifying the content string, content type, and optional content encoding for customized HTTP responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Content(string! content) -> Microsoft.AspNetCore.Mvc.ContentResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Content(string! content, Microsoft.Net.Http.Headers.MediaTypeHeaderValue? contentType) -> Microsoft.AspNetCore.Mvc.ContentResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Content(string! content, string! contentType) -> Microsoft.AspNetCore.Mvc.ContentResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Content(string! content, string! contentType, System.Text.Encoding! contentEncoding) -> Microsoft.AspNetCore.Mvc.ContentResult!\n```\n\n----------------------------------------\n\nTITLE: Health Check Middleware Class Definition\nDESCRIPTION: Core middleware class for handling health check requests in ASP.NET Core applications. Includes constructor and invoke method for processing health check requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HealthChecks/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class HealthCheckMiddleware\n{\n    public HealthCheckMiddleware(RequestDelegate next, IOptions<HealthCheckOptions> healthCheckOptions, HealthCheckService healthCheckService);\n    public Task InvokeAsync(HttpContext httpContext);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AcceptedAtRoute Result Methods in C#\nDESCRIPTION: These methods create AcceptedAtRoute results with optional route name, values, and content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.AcceptedAtRoute(string? routeName = null, object? routeValues = null) -> Microsoft.AspNetCore.Http.HttpResults.AcceptedAtRoute!\nstatic Microsoft.AspNetCore.Http.TypedResults.AcceptedAtRoute(string? routeName, Microsoft.AspNetCore.Routing.RouteValueDictionary? routeValues) -> Microsoft.AspNetCore.Http.HttpResults.AcceptedAtRoute!\nstatic Microsoft.AspNetCore.Http.TypedResults.AcceptedAtRoute<TValue>(TValue? value, string? routeName = null, object? routeValues = null) -> Microsoft.AspNetCore.Http.HttpResults.AcceptedAtRoute<TValue>!\nstatic Microsoft.AspNetCore.Http.TypedResults.AcceptedAtRoute<TValue>(TValue? value, string? routeName, Microsoft.AspNetCore.Routing.RouteValueDictionary? routeValues) -> Microsoft.AspNetCore.Http.HttpResults.AcceptedAtRoute<TValue>!\n```\n\n----------------------------------------\n\nTITLE: Configuring Microsoft Account Authentication in ASP.NET Core\nDESCRIPTION: Code example showing how to configure Microsoft Account authentication in an ASP.NET Core application's Program.cs file. Sets up the authentication middleware with client ID and secret from configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/MicrosoftAccount/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddAuthentication().AddMicrosoftAccount(microsoftOptions =>\n{\n    microsoftOptions.ClientId = builder.Configuration[\"Authentication:Microsoft:ClientId\"];\n    microsoftOptions.ClientSecret = builder.Configuration[\"Authentication:Microsoft:ClientSecret\"];\n});\n```\n\n----------------------------------------\n\nTITLE: Defining AuthenticateResult Class in C#\nDESCRIPTION: Defines the AuthenticateResult class with properties for authentication status, principal, ticket, and failure information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Authentication.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.AuthenticateResult\nMicrosoft.AspNetCore.Authentication.AuthenticateResult.AuthenticateResult() -> void\nMicrosoft.AspNetCore.Authentication.AuthenticateResult.Clone() -> Microsoft.AspNetCore.Authentication.AuthenticateResult!\nMicrosoft.AspNetCore.Authentication.AuthenticateResult.Failure.get -> System.Exception?\nMicrosoft.AspNetCore.Authentication.AuthenticateResult.Failure.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticateResult.None.get -> bool\nMicrosoft.AspNetCore.Authentication.AuthenticateResult.None.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticateResult.Principal.get -> System.Security.Claims.ClaimsPrincipal?\nMicrosoft.AspNetCore.Authentication.AuthenticateResult.Properties.get -> Microsoft.AspNetCore.Authentication.AuthenticationProperties?\nMicrosoft.AspNetCore.Authentication.AuthenticateResult.Properties.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticateResult.Succeeded.get -> bool\nMicrosoft.AspNetCore.Authentication.AuthenticateResult.Ticket.get -> Microsoft.AspNetCore.Authentication.AuthenticationTicket?\nMicrosoft.AspNetCore.Authentication.AuthenticateResult.Ticket.set -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Route Handler in ASP.NET Core\nDESCRIPTION: Generated extension method for mapping GET requests with metadata population and request delegation. Handles JSON body parsing and response writing with proper error handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n        var serviceProviderIsService = serviceProvider.GetRequiredService<IServiceProviderIsService>();\n        var jsonBodyOrServiceTypeTuples = new (bool, Type)[] {\n            #nullable disable\n            (true, typeof(global::System.String[])),\n            #nullable enable\n        };\n        foreach (var (isOptional, type) in jsonBodyOrServiceTypeTuples)\n        {\n            if (!serviceProviderIsService.IsService(type))\n            {\n                options.EndpointBuilder.Metadata.Add(new AcceptsMetadata(type: type, isOptional: isOptional, contentTypes: GeneratedMetadataConstants.JsonContentType));\n                break;\n            }\n        }\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: true));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(global::System.String[]), contentTypes: GeneratedMetadataConstants.JsonContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n```\n\n----------------------------------------\n\nTITLE: Executing Different Return Types in ASP.NET Core Endpoints\nDESCRIPTION: Handles endpoint responses based on return type - executing IResult objects, writing string responses directly, or serializing other objects as JSON. This provides flexible response generation for route handlers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Post_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Logging and Exception Handling in C# for ASP.NET Core\nDESCRIPTION: This class provides methods for logging errors or throwing exceptions based on configuration. It handles various scenarios such as IO exceptions, JSON parsing errors, parameter binding failures, and content type mismatches.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_NoParam_StringReturn_WithFilter.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    // Additional methods for various error scenarios...\n\n    private static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n\n    public void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Abstract Algorithm Configuration Base Class\nDESCRIPTION: Defines the base abstract class for algorithm configurations requiring implementation of CreateNewDescriptor method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AlgorithmConfiguration.CreateNewDescriptor() -> Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor!\n```\n\n----------------------------------------\n\nTITLE: Implementing Model Explorer and Metadata Extensions in C#\nDESCRIPTION: These extension methods provide functionality for working with model explorers and metadata in ASP.NET Core MVC. They include methods for getting simple display text and creating model explorers for specific types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Mvc.ViewFeatures.ModelExplorerExtensions.GetSimpleDisplayText(this Microsoft.AspNetCore.Mvc.ViewFeatures.ModelExplorer modelExplorer) -> string\nstatic Microsoft.AspNetCore.Mvc.ViewFeatures.ModelMetadataProviderExtensions.GetModelExplorerForType(this Microsoft.AspNetCore.Mvc.ModelBinding.IModelMetadataProvider provider, System.Type modelType, object model) -> Microsoft.AspNetCore.Mvc.ViewFeatures.ModelExplorer\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Route Handler in ASP.NET Core\nDESCRIPTION: Generated extension method for mapping GET requests with metadata population and request delegation. Handles JSON body parsing and response writing with proper error handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n        var serviceProviderIsService = serviceProvider.GetRequiredService<IServiceProviderIsService>();\n        var jsonBodyOrServiceTypeTuples = new (bool, Type)[] {\n            #nullable disable\n            (true, typeof(global::System.String[])),\n            #nullable enable\n        };\n        foreach (var (isOptional, type) in jsonBodyOrServiceTypeTuples)\n        {\n            if (!serviceProviderIsService.IsService(type))\n            {\n                options.EndpointBuilder.Metadata.Add(new AcceptsMetadata(type: type, isOptional: isOptional, contentTypes: GeneratedMetadataConstants.JsonContentType));\n                break;\n            }\n        }\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: true));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(global::System.String[]), contentTypes: GeneratedMetadataConstants.JsonContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n```\n\n----------------------------------------\n\nTITLE: Interactive Render Mode Classes for ASP.NET Core Components\nDESCRIPTION: Defines render mode classes for interactive Blazor components. Includes Auto, Server, and WebAssembly render modes with prerendering configuration options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Web.InteractiveAutoRenderMode\nMicrosoft.AspNetCore.Components.Web.InteractiveAutoRenderMode.InteractiveAutoRenderMode() -> void\nMicrosoft.AspNetCore.Components.Web.InteractiveAutoRenderMode.InteractiveAutoRenderMode(bool prerender) -> void\nMicrosoft.AspNetCore.Components.Web.InteractiveAutoRenderMode.Prerender.get -> bool\nMicrosoft.AspNetCore.Components.Web.InteractiveServerRenderMode\nMicrosoft.AspNetCore.Components.Web.InteractiveServerRenderMode.InteractiveServerRenderMode() -> void\nMicrosoft.AspNetCore.Components.Web.InteractiveServerRenderMode.InteractiveServerRenderMode(bool prerender) -> void\nMicrosoft.AspNetCore.Components.Web.InteractiveServerRenderMode.Prerender.get -> bool\nMicrosoft.AspNetCore.Components.Web.InteractiveWebAssemblyRenderMode\nMicrosoft.AspNetCore.Components.Web.InteractiveWebAssemblyRenderMode.InteractiveWebAssemblyRenderMode() -> void\nMicrosoft.AspNetCore.Components.Web.InteractiveWebAssemblyRenderMode.InteractiveWebAssemblyRenderMode(bool prerender) -> void\nMicrosoft.AspNetCore.Components.Web.InteractiveWebAssemblyRenderMode.Prerender.get -> bool\n```\n\n----------------------------------------\n\nTITLE: Executing Result Objects in ASP.NET Core Response Pipeline\nDESCRIPTION: Handles execution of response objects based on their type. It processes IResult implementations, string responses, and JSON serialization for other object types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Streaming Async Data from SignalR Hub in C#\nDESCRIPTION: Extends HubConnection to stream data asynchronously from a SignalR hub method. It returns an IAsyncEnumerable<TResult> for consuming streamed data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.StreamAsync<TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Collections.Generic.IAsyncEnumerable<TResult>!\n```\n\n----------------------------------------\n\nTITLE: Building Filter Delegates for Endpoint Processing\nDESCRIPTION: Constructs an endpoint filter delegate chain by applying multiple filter factories in reverse order. This enables middleware-like processing for endpoint invocations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Handshake Response Message in SignalR Protocol\nDESCRIPTION: Static method to attempt parsing a HandshakeResponseMessage from a ReadOnlySequence<byte> buffer in the SignalR protocol. Returns a boolean indicating success and outputs the parsed message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.TryParseResponseMessage(ref System.Buffers.ReadOnlySequence<byte> buffer, out Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage? responseMessage) -> bool\n```\n\n----------------------------------------\n\nTITLE: Implementing ASP.NET Core Generated HTTP Namespace with Required Using Directives\nDESCRIPTION: Declares the Microsoft.AspNetCore.Http.Generated namespace and imports necessary dependencies for HTTP request handling. Includes type aliases for metadata population and request delegate factory functions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitServiceParam_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace Microsoft.AspNetCore.Http.Generated\n{\n    using System;\n    using System.Collections;\n    using System.Collections.Generic;\n    using System.Collections.ObjectModel;\n    using System.Diagnostics;\n    using System.Diagnostics.CodeAnalysis;\n    using System.Globalization;\n    using System.Linq;\n    using System.Reflection;\n    using System.Runtime.CompilerServices;\n    using System.Text.Json;\n    using System.Text.Json.Serialization.Metadata;\n    using System.Threading.Tasks;\n    using System.IO;\n    using Microsoft.AspNetCore.Antiforgery;\n    using Microsoft.AspNetCore.Routing;\n    using Microsoft.AspNetCore.Routing.Patterns;\n    using Microsoft.AspNetCore.Builder;\n    using Microsoft.AspNetCore.Http;\n    using Microsoft.AspNetCore.Http.Json;\n    using Microsoft.AspNetCore.Http.Metadata;\n    using Microsoft.Extensions.DependencyInjection;\n    using Microsoft.Extensions.FileProviders;\n    using Microsoft.Extensions.Logging;\n    using Microsoft.Extensions.Primitives;\n    using Microsoft.Extensions.Options;\n\n    using MetadataPopulator = System.Func<System.Reflection.MethodInfo, Microsoft.AspNetCore.Http.RequestDelegateFactoryOptions?, Microsoft.AspNetCore.Http.RequestDelegateMetadataResult>;\n    using RequestDelegateFactoryFunc = System.Func<System.Delegate, Microsoft.AspNetCore.Http.RequestDelegateFactoryOptions, Microsoft.AspNetCore.Http.RequestDelegateMetadataResult?, Microsoft.AspNetCore.Http.RequestDelegateResult>;\n```\n\n----------------------------------------\n\nTITLE: Defining URL Prefix Class in C#\nDESCRIPTION: Class for handling HTTP.sys URL prefixes, providing properties to access components like scheme, host, port, and path. Includes static factory methods for creating URL prefix instances.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/HttpSys/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefix\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefix.FullPrefix.get -> string!\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefix.Host.get -> string!\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefix.IsHttps.get -> bool\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefix.Path.get -> string!\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefix.Port.get -> string!\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefix.PortValue.get -> int\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefix.Scheme.get -> string!\noverride Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.Equals(object? obj) -> bool\noverride Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.GetHashCode() -> int\noverride Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.ToString() -> string!\nstatic Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.Create(string! prefix) -> Microsoft.AspNetCore.Server.HttpSys.UrlPrefix!\nstatic Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.Create(string! scheme, string! host, int? portValue, string! path) -> Microsoft.AspNetCore.Server.HttpSys.UrlPrefix!\nstatic Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.Create(string! scheme, string! host, string! port, string! path) -> Microsoft.AspNetCore.Server.HttpSys.UrlPrefix!\n```\n\n----------------------------------------\n\nTITLE: Response Writer with JSON Support\nDESCRIPTION: Handles writing different types of responses including IResult implementations, strings, and JSON objects. Includes special handling for polymorphic types and AOT considerations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsDifferentInterceptorsFromSameLocation.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Authorization Policies in C#\nDESCRIPTION: This snippet defines methods for the AuthorizationBuilder class, allowing for the creation and configuration of authorization policies, including default and fallback policies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authorization.AuthorizationBuilder.AddDefaultPolicy(string! name, Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy) -> Microsoft.AspNetCore.Authorization.AuthorizationBuilder!\nvirtual Microsoft.AspNetCore.Authorization.AuthorizationBuilder.AddDefaultPolicy(string! name, System.Action<Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!>! configurePolicy) -> Microsoft.AspNetCore.Authorization.AuthorizationBuilder!\nvirtual Microsoft.AspNetCore.Authorization.AuthorizationBuilder.AddFallbackPolicy(string! name, Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy) -> Microsoft.AspNetCore.Authorization.AuthorizationBuilder!\nvirtual Microsoft.AspNetCore.Authorization.AuthorizationBuilder.AddFallbackPolicy(string! name, System.Action<Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!>! configurePolicy) -> Microsoft.AspNetCore.Authorization.AuthorizationBuilder!\nvirtual Microsoft.AspNetCore.Authorization.AuthorizationBuilder.AddPolicy(string! name, Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy) -> Microsoft.AspNetCore.Authorization.AuthorizationBuilder!\nvirtual Microsoft.AspNetCore.Authorization.AuthorizationBuilder.AddPolicy(string! name, System.Action<Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!>! configurePolicy) -> Microsoft.AspNetCore.Authorization.AuthorizationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Generating Request Delegate for GET Request with HttpContext and Custom Binding\nDESCRIPTION: This method generates a request delegate for handling GET requests with HttpContext and custom parameter binding. It includes metadata population, request handling, and optional filtering.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet2(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        // ... (metadata population logic)\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        // ... (request delegate creation logic)\n    };\n    // ... (additional implementation details)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LoginWithRecoveryCodeModel for ASP.NET Core Identity UI V5\nDESCRIPTION: This snippet defines the LoginWithRecoveryCodeModel class and its nested InputModel for ASP.NET Core Identity UI version 5. It includes properties for managing recovery code login information and user input.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWithRecoveryCodeModel\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWithRecoveryCodeModel.Input.get -> Microsoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWithRecoveryCodeModel.InputModel!\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWithRecoveryCodeModel.Input.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWithRecoveryCodeModel.InputModel\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWithRecoveryCodeModel.InputModel.InputModel() -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWithRecoveryCodeModel.InputModel.RecoveryCode.get -> string!\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWithRecoveryCodeModel.InputModel.RecoveryCode.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWithRecoveryCodeModel.LoginWithRecoveryCodeModel() -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWithRecoveryCodeModel.ReturnUrl.get -> string?\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWithRecoveryCodeModel.ReturnUrl.set -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing NegotiationResponse Class in C#\nDESCRIPTION: A class representing the response from a connection negotiation. Contains connection details, available transports, and error information needed for establishing a SignalR connection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/Http.Connections.Common/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse.AccessToken.get -> string?\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse.AccessToken.set -> void\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse.AvailableTransports.get -> System.Collections.Generic.IList<Microsoft.AspNetCore.Http.Connections.AvailableTransport!>?\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse.AvailableTransports.set -> void\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse.ConnectionId.get -> string?\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse.ConnectionId.set -> void\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse.ConnectionToken.get -> string?\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse.ConnectionToken.set -> void\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse.Error.get -> string?\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse.Error.set -> void\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse.NegotiationResponse() -> void\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse.Url.get -> string?\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse.Url.set -> void\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse.UseStatefulReconnect.get -> bool\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse.UseStatefulReconnect.set -> void\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse.Version.get -> int\nMicrosoft.AspNetCore.Http.Connections.NegotiationResponse.Version.set -> void\n```\n\n----------------------------------------\n\nTITLE: Creating Event Callbacks for Event Arguments\nDESCRIPTION: Extension methods for EventCallbackFactory to create callbacks for ChangeEventArgs and EventArgs. Provides both synchronous (Action) and asynchronous (Func) overloads.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryEventArgsExtensions.Create(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<Microsoft.AspNetCore.Components.ChangeEventArgs!>! callback) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\n```\n\n----------------------------------------\n\nTITLE: RoutePatternFactory Methods for Creating Route Pattern Components in ASP.NET Core\nDESCRIPTION: Factory methods for creating route pattern components like patterns, constraints, parameter parts, and parameter policies. These methods are used to build route patterns programmatically for ASP.NET Core routing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Combine(Microsoft.AspNetCore.Routing.Patterns.RoutePattern? left, Microsoft.AspNetCore.Routing.Patterns.RoutePattern! right) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Constraint(Microsoft.AspNetCore.Routing.IRouteConstraint! constraint) -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterPolicyReference!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Constraint(object! constraint) -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterPolicyReference!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Constraint(string! constraint) -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterPolicyReference!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.LiteralPart(string! content) -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternLiteralPart!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.ParameterPart(string! parameterName) -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterPart!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.ParameterPart(string! parameterName, object! default) -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterPart!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.ParameterPart(string! parameterName, object? default, Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterKind parameterKind) -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterPart!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.ParameterPart(string! parameterName, object? default, Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterKind parameterKind, params Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterPolicyReference![]! parameterPolicies) -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterPart!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.ParameterPart(string! parameterName, object? default, Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterKind parameterKind, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterPolicyReference!>! parameterPolicies) -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterPart!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.ParameterPolicy(Microsoft.AspNetCore.Routing.IParameterPolicy! parameterPolicy) -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterPolicyReference!\n```\n\n----------------------------------------\n\nTITLE: Implementing Core Route Mapping in ASP.NET Core\nDESCRIPTION: Maps route handlers with metadata and request delegates. Handles route pattern matching and HTTP method filtering.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TempDataDictionaryFactory Class in C#\nDESCRIPTION: This snippet shows the constructor and method signature for the TempDataDictionaryFactory class, which is responsible for creating ITempDataDictionary instances in ASP.NET Core MVC.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ViewFeatures.TempDataDictionaryFactory.TempDataDictionaryFactory(Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataProvider provider) -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ViewFeatures.TempDataDictionaryFactory.GetTempData(Microsoft.AspNetCore.Http.HttpContext context) -> Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataDictionary\n```\n\n----------------------------------------\n\nTITLE: SignalR HandshakeProtocol Method Declarations in C#\nDESCRIPTION: Static method declarations for the HandshakeProtocol class in SignalR, including methods to get successful handshake data, parse request and response messages, and write messages to buffer writers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.GetSuccessfulHandshake(Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol! protocol) -> System.ReadOnlySpan<byte>\nstatic Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.TryParseRequestMessage(ref System.Buffers.ReadOnlySequence<byte> buffer, out Microsoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage? requestMessage) -> bool\nstatic Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.TryParseResponseMessage(ref System.Buffers.ReadOnlySequence<byte> buffer, out Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage? responseMessage) -> bool\nstatic Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.WriteRequestMessage(Microsoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage! requestMessage, System.Buffers.IBufferWriter<byte>! output) -> void\nstatic Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.WriteResponseMessage(Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage! responseMessage, System.Buffers.IBufferWriter<byte>! output) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining RenderTree-related Classes in C#\nDESCRIPTION: This snippet defines classes and enums related to render tree operations, including ArrayBuilderSegment, ArrayRange, ComponentFrameFlags, and EventFieldInfo. These are used for managing render tree data structures and component rendering.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.RenderTree.ArrayBuilderSegment<T>\nMicrosoft.AspNetCore.Components.RenderTree.ArrayBuilderSegment<T>.Array.get -> T[]!\nMicrosoft.AspNetCore.Components.RenderTree.ArrayBuilderSegment<T>.ArrayBuilderSegment() -> void\nMicrosoft.AspNetCore.Components.RenderTree.ArrayBuilderSegment<T>.Count.get -> int\nMicrosoft.AspNetCore.Components.RenderTree.ArrayBuilderSegment<T>.Offset.get -> int\nMicrosoft.AspNetCore.Components.RenderTree.ArrayBuilderSegment<T>.this[int index].get -> T\nMicrosoft.AspNetCore.Components.RenderTree.ArrayRange<T>\nMicrosoft.AspNetCore.Components.RenderTree.ArrayRange<T>.ArrayRange() -> void\nMicrosoft.AspNetCore.Components.RenderTree.ArrayRange<T>.ArrayRange(T[]! array, int count) -> void\nMicrosoft.AspNetCore.Components.RenderTree.ArrayRange<T>.Clone() -> Microsoft.AspNetCore.Components.RenderTree.ArrayRange<T>\nMicrosoft.AspNetCore.Components.RenderTree.ComponentFrameFlags\nMicrosoft.AspNetCore.Components.RenderTree.ComponentFrameFlags.HasCallerSpecifiedRenderMode = 1 -> Microsoft.AspNetCore.Components.RenderTree.ComponentFrameFlags\nMicrosoft.AspNetCore.Components.RenderTree.EventFieldInfo\nMicrosoft.AspNetCore.Components.RenderTree.EventFieldInfo.ComponentId.get -> int\nMicrosoft.AspNetCore.Components.RenderTree.EventFieldInfo.ComponentId.set -> void\nMicrosoft.AspNetCore.Components.RenderTree.EventFieldInfo.EventFieldInfo() -> void\nMicrosoft.AspNetCore.Components.RenderTree.EventFieldInfo.FieldValue.get -> object!\nMicrosoft.AspNetCore.Components.RenderTree.EventFieldInfo.FieldValue.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute for Method Interception in C#\nDESCRIPTION: Defines a compiler-generated attribute class that enables method interception with versioning support. This attribute is used for marking methods that will intercept calls to other methods at specific locations in the code.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling HTTP GET Request with Parameter Binding in ASP.NET Core\nDESCRIPTION: This snippet shows a method for mapping a GET request to a handler function. It includes parameter binding, metadata population, and support for endpoint filters. The method handles both filtered and unfiltered requests, and supports different content types based on the response.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet3(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"myBindAsyncParam\", parameters[0], hasTryParse: false, hasBindAsync: true, isOptional: true));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        // ... (implementation details)\n    };\n    var castHandler = Cast(handler, global::System.String (global::Microsoft.AspNetCore.Http.Generators.Tests.MyBindAsyncStruct? arg0) => throw null!);\n    return MapCore(\n        endpoints,\n        pattern,\n        handler,\n        GetVerb,\n        populateMetadata,\n        createRequestDelegate,\n        castHandler.Method);\n}\n```\n\n----------------------------------------\n\nTITLE: Dispatcher Abstract Method Definitions\nDESCRIPTION: Defines abstract methods for the Dispatcher class to handle synchronization and invocation of work items across different execution contexts.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Components.Dispatcher.CheckAccess() -> bool\nabstract Microsoft.AspNetCore.Components.Dispatcher.InvokeAsync(System.Action! workItem) -> System.Threading.Tasks.Task!\nabstract Microsoft.AspNetCore.Components.Dispatcher.InvokeAsync(System.Func<System.Threading.Tasks.Task!>! workItem) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining ViewDataDictionary<TModel> Class in C#\nDESCRIPTION: Defines the ViewDataDictionary<TModel> class with properties and constructors for managing view data in ASP.NET Core MVC.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary<TModel>\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary<TModel>.Model.get -> TModel\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary<TModel>.Model.set -> void\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary<TModel>.ViewDataDictionary(Microsoft.AspNetCore.Mvc.ModelBinding.IModelMetadataProvider! metadataProvider, Microsoft.AspNetCore.Mvc.ModelBinding.ModelStateDictionary! modelState) -> void\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary<TModel>.ViewDataDictionary(Microsoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary! source) -> void\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary<TModel>.ViewDataDictionary(Microsoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary! source, object? model) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining Form Content Type Logger Message in C#\nDESCRIPTION: Defines a logger message for unexpected non-form content type scenarios with debug level logging.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/RequestDelegateValidateGeneratedFormCode.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nLoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Configuring Redis Key Storage for Data Protection\nDESCRIPTION: Code example showing how to configure ASP.NET Core Data Protection to persist keys to Redis using StackExchange.Redis. Creates a connection to Redis and configures the data protection system with a specific key prefix.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/StackExchangeRedis/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar redis = ConnectionMultiplexer.Connect(\"<URI>\");\nbuilder.Services.AddDataProtection()\n    .PersistKeysToStackExchangeRedis(redis, \"DataProtection-Keys\");\n```\n\n----------------------------------------\n\nTITLE: Physical File Response Method in ASP.NET Core ControllerBase (C#)\nDESCRIPTION: Method to return file content from a physical file path on disk. This method supports specifying the content type for the physical file download response.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.PhysicalFile(string! physicalPath, string! contentType) -> Microsoft.AspNetCore.Mvc.PhysicalFileResult!\n```\n\n----------------------------------------\n\nTITLE: PageModel Authentication Methods\nDESCRIPTION: Methods for handling user authentication including sign-in and sign-out operations with support for authentication schemes and properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.SignIn(System.Security.Claims.ClaimsPrincipal! principal, Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, string! authenticationScheme) -> Microsoft.AspNetCore.Mvc.SignInResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.SignIn(System.Security.Claims.ClaimsPrincipal! principal, string! authenticationScheme) -> Microsoft.AspNetCore.Mvc.SignInResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.SignOut(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, params string![]! authenticationSchemes) -> Microsoft.AspNetCore.Mvc.SignOutResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.SignOut(params string![]! authenticationSchemes) -> Microsoft.AspNetCore.Mvc.SignOutResult!\n```\n\n----------------------------------------\n\nTITLE: Utility Methods for ASP.NET Core Request Handling\nDESCRIPTION: This section includes utility methods for delegate casting, filter delegate building, and JSON response writing. These methods support the core request handling functionality in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitBodyParam_ComplexReturn_Snapshot.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n```\n\n----------------------------------------\n\nTITLE: Processing Form Data in ASP.NET Core\nDESCRIPTION: Asynchronously processes form data from HTTP requests with comprehensive error handling for bad requests, IO exceptions, and invalid data. Returns a tuple containing success status and form value.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/RequestDelegateValidateGeneratedFormCode.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nprivate static async Task<(bool, object?)> TryResolveFormAsync(\n    HttpContext httpContext,\n    LogOrThrowExceptionHelper logOrThrowExceptionHelper,\n    string parameterTypeName,\n    string parameterName)\n{\n    object? formValue = null;\n    var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();\n\n    if (feature?.CanHaveBody == true)\n    {\n        if (!httpContext.Request.HasFormContentType)\n        {\n            logOrThrowExceptionHelper.UnexpectedNonFormContentType(httpContext.Request.ContentType);\n            httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;\n            return (false, null);\n        }\n\n        try\n        {\n            formValue = await httpContext.Request.ReadFormAsync();\n        }\n        catch (BadHttpRequestException ex)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(ex);\n            httpContext.Response.StatusCode = ex.StatusCode;\n            return (false, null);\n        }\n        catch (IOException ex)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(ex);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, null);\n        }\n        catch (InvalidDataException ex)\n        {\n            logOrThrowExceptionHelper.InvalidFormRequestBody(parameterTypeName, parameterName, ex);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, null);\n        }\n    }\n\n    return (true, formValue);\n}\n```\n\n----------------------------------------\n\nTITLE: Authentication Result Handling\nDESCRIPTION: Classes and methods for handling authentication results, including success, failure, and no-result scenarios.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Authentication.HandleRequestResult.Fail(string! failureMessage) -> Microsoft.AspNetCore.Authentication.HandleRequestResult!\nstatic Microsoft.AspNetCore.Authentication.HandleRequestResult.Success(Microsoft.AspNetCore.Authentication.AuthenticationTicket! ticket) -> Microsoft.AspNetCore.Authentication.HandleRequestResult!\nstatic Microsoft.AspNetCore.Authentication.HandleRequestResult.NoResult() -> Microsoft.AspNetCore.Authentication.HandleRequestResult!\n```\n\n----------------------------------------\n\nTITLE: Ticket Store Interface in C#\nDESCRIPTION: Interface for storing, retrieving, renewing, and removing authentication tickets used with cookie authentication. Provides methods with various overloads including cancellation token support and HTTP context.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Cookies/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.Cookies.ITicketStore\nMicrosoft.AspNetCore.Authentication.Cookies.ITicketStore.RemoveAsync(string! key) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Authentication.Cookies.ITicketStore.RemoveAsync(string! key, Microsoft.AspNetCore.Http.HttpContext! httpContext, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Authentication.Cookies.ITicketStore.RemoveAsync(string! key, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Authentication.Cookies.ITicketStore.RenewAsync(string! key, Microsoft.AspNetCore.Authentication.AuthenticationTicket! ticket) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Authentication.Cookies.ITicketStore.RenewAsync(string! key, Microsoft.AspNetCore.Authentication.AuthenticationTicket! ticket, Microsoft.AspNetCore.Http.HttpContext! httpContext, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Authentication.Cookies.ITicketStore.RenewAsync(string! key, Microsoft.AspNetCore.Authentication.AuthenticationTicket! ticket, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Authentication.Cookies.ITicketStore.RetrieveAsync(string! key) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authentication.AuthenticationTicket?>!\nMicrosoft.AspNetCore.Authentication.Cookies.ITicketStore.RetrieveAsync(string! key, Microsoft.AspNetCore.Http.HttpContext! httpContext, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authentication.AuthenticationTicket?>!\nMicrosoft.AspNetCore.Authentication.Cookies.ITicketStore.RetrieveAsync(string! key, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authentication.AuthenticationTicket?>!\nMicrosoft.AspNetCore.Authentication.Cookies.ITicketStore.StoreAsync(Microsoft.AspNetCore.Authentication.AuthenticationTicket! ticket) -> System.Threading.Tasks.Task<string!>!\nMicrosoft.AspNetCore.Authentication.Cookies.ITicketStore.StoreAsync(Microsoft.AspNetCore.Authentication.AuthenticationTicket! ticket, Microsoft.AspNetCore.Http.HttpContext! httpContext, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<string!>!\nMicrosoft.AspNetCore.Authentication.Cookies.ITicketStore.StoreAsync(Microsoft.AspNetCore.Authentication.AuthenticationTicket! ticket, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<string!>!\n```\n\n----------------------------------------\n\nTITLE: NavigationManager Class API\nDESCRIPTION: Core navigation class for Blazor applications that handles URI-based navigation, location change events, and URL transformations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class NavigationManager\n{\n    public string BaseUri { get; protected set; }\n    public string Uri { get; protected set; }\n    public string? HistoryEntryState { get; protected set; }\n    public event EventHandler<LocationChangedEventArgs> LocationChanged;\n    \n    public void NavigateTo(string uri, bool forceLoad = false, bool replace = false);\n    public void NavigateTo(string uri, NavigationOptions options);\n    public Uri ToAbsoluteUri(string? relativeUri);\n    public string ToBaseRelativePath(string uri);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EntityFrameworkCoreXmlRepository in ASP.NET Core\nDESCRIPTION: Definition of the EntityFrameworkCoreXmlRepository generic class which manages the storage and retrieval of data protection keys using Entity Framework Core. It provides methods for storing XML elements and retrieving all elements from the database.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.DataProtection.EntityFrameworkCore.EntityFrameworkCoreXmlRepository<TContext>\nMicrosoft.AspNetCore.DataProtection.EntityFrameworkCore.EntityFrameworkCoreXmlRepository<TContext>.EntityFrameworkCoreXmlRepository(System.IServiceProvider! services, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> void\nMicrosoft.AspNetCore.DataProtection.EntityFrameworkCore.EntityFrameworkCoreXmlRepository<TContext>.StoreElement(System.Xml.Linq.XElement! element, string! friendlyName) -> void\nvirtual Microsoft.AspNetCore.DataProtection.EntityFrameworkCore.EntityFrameworkCoreXmlRepository<TContext>.GetAllElements() -> System.Collections.Generic.IReadOnlyCollection<System.Xml.Linq.XElement!>!\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Extension Method in C#\nDESCRIPTION: Implements a MapGet extension method for IEndpointRouteBuilder to handle HTTP GET requests. It includes metadata population, request delegate creation, and parameter binding logic.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        // Metadata population logic\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        // Request delegate creation logic\n    };\n    var castHandler = Cast(handler, global::System.Int32[] (global::System.Int32[]? arg0= default) => throw null!);\n    return MapCore(\n        endpoints,\n        pattern,\n        handler,\n        GetVerb,\n        populateMetadata,\n        createRequestDelegate,\n        castHandler.Method);\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping GET Request with Metadata Population in ASP.NET Core\nDESCRIPTION: This method maps a GET request to a specific pattern and handler. It populates metadata for the endpoint, including generated code attributes, parameter binding information, and response type metadata. The method also creates a request delegate factory function for handling the request.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet9(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"myBindAsyncParam\", parameters[0], hasTryParse: false, hasBindAsync: true, isOptional: true));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    // ... (rest of the method implementation)\n}\n```\n\n----------------------------------------\n\nTITLE: MVC Controller Base Action Results\nDESCRIPTION: Virtual methods in ControllerBase class for generating HTTP action results like Accepted, BadRequest, and Challenge responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Accepted() -> Microsoft.AspNetCore.Mvc.AcceptedResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.BadRequest() -> Microsoft.AspNetCore.Mvc.BadRequestResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Challenge() -> Microsoft.AspNetCore.Mvc.ChallengeResult!\n```\n\n----------------------------------------\n\nTITLE: Configuring OIDC Authentication in ASP.NET Core WebAssembly\nDESCRIPTION: Extension methods to add OpenID Connect (OIDC) authentication to WebAssembly applications. These methods configure services needed for OIDC authentication with various type parameters for customization of state and account types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.WebAssemblyAuthenticationServiceCollectionExtensions.AddOidcAuthentication(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationOptions<Microsoft.AspNetCore.Components.WebAssembly.Authentication.OidcProviderOptions!>!>! configure) -> Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationState!, Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount!>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.WebAssemblyAuthenticationServiceCollectionExtensions.AddOidcAuthentication<TRemoteAuthenticationState, TAccount>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationOptions<Microsoft.AspNetCore.Components.WebAssembly.Authentication.OidcProviderOptions!>!>! configure) -> Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<TRemoteAuthenticationState!, TAccount!>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.WebAssemblyAuthenticationServiceCollectionExtensions.AddOidcAuthentication<TRemoteAuthenticationState>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationOptions<Microsoft.AspNetCore.Components.WebAssembly.Authentication.OidcProviderOptions!>!>! configure) -> Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<TRemoteAuthenticationState!, Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount!>!\n```\n\n----------------------------------------\n\nTITLE: Authentication Handlers and Extensions\nDESCRIPTION: Authentication handlers for sign-in/sign-out operations and extension methods for authentication configuration and base64url encoding/decoding.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Authentication.Base64UrlTextEncoder.Decode(string! text) -> byte[]!\nstatic Microsoft.AspNetCore.Authentication.Base64UrlTextEncoder.Encode(byte[]! data) -> string!\nstatic Microsoft.AspNetCore.Builder.AuthAppBuilderExtensions.UseAuthentication(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining AspNetUserManager<TUser> Constructor in C#\nDESCRIPTION: Constructor for AspNetUserManager<TUser> class, responsible for managing users in ASP.NET Core Identity. It includes dependencies for user store, options, password hashing, and validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.AspNetUserManager<TUser>.AspNetUserManager(Microsoft.AspNetCore.Identity.IUserStore<TUser!>! store, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Identity.IdentityOptions!>! optionsAccessor, Microsoft.AspNetCore.Identity.IPasswordHasher<TUser!>! passwordHasher, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Identity.IUserValidator<TUser!>!>! userValidators, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Identity.IPasswordValidator<TUser!>!>! passwordValidators, Microsoft.AspNetCore.Identity.ILookupNormalizer! keyNormalizer, Microsoft.AspNetCore.Identity.IdentityErrorDescriber! errors, System.IServiceProvider! services, Microsoft.Extensions.Logging.ILogger<Microsoft.AspNetCore.Identity.UserManager<TUser!>!>! logger) -> void\n```\n\n----------------------------------------\n\nTITLE: TagHelper Order Property Getters\nDESCRIPTION: Virtual property getters for Order property in TagHelper and TagHelperComponent classes. These properties determine the execution order of tag helpers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Razor/Razor/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvirtual Microsoft.AspNetCore.Razor.TagHelpers.TagHelper.Order.get -> int\nvirtual Microsoft.AspNetCore.Razor.TagHelpers.TagHelperComponent.Order.get -> int\n```\n\n----------------------------------------\n\nTITLE: Label HTML Helpers in ASP.NET Core MVC\nDESCRIPTION: Extension methods for generating HTML label elements with various overloads supporting model expressions and custom text. These methods help create accessible form labels.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperLabelExtensions.Label(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper htmlHelper, string expression) -> Microsoft.AspNetCore.Html.IHtmlContent\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperLabelExtensions.LabelFor<TModel, TResult>(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper<TModel> htmlHelper, System.Linq.Expressions.Expression<System.Func<TModel, TResult>> expression) -> Microsoft.AspNetCore.Html.IHtmlContent\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Extension Method for ASP.NET Core Routing with Array Parameters\nDESCRIPTION: This method extends IEndpointRouteBuilder to handle HTTP GET requests with integer array parameters. It includes parameter binding, validation, metadata population, and JSON response serialization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: true, hasBindAsync: false, isOptional: true));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(global::System.Int32[]), contentTypes: GeneratedMetadataConstants.JsonContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n        Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n        var handler = Cast(del, global::System.Int32[] (global::System.Int32[]? arg0= default) => throw null!);\n        EndpointFilterDelegate? filteredInvocation = null;\n        var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n        var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n        var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n        var jsonSerializerOptions = jsonOptions.SerializerOptions;\n        jsonSerializerOptions.MakeReadOnly();\n        var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n        var responseJsonTypeInfo =  (JsonTypeInfo<global::System.Int32[]?>)jsonSerializerOptions.GetTypeInfo(typeof(global::System.Int32[]));\n        var p_RouteOrQueryResolver = GeneratedRouteBuilderExtensionsCore.ResolveFromRouteOrQuery(\"p\", options.RouteParameterNames);\n\n        if (options.EndpointBuilder.FilterFactories.Count > 0)\n        {\n            filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n            {\n                if (ic.HttpContext.Response.StatusCode == 400)\n                {\n                    return ValueTask.FromResult<object?>(Results.Empty);\n                }\n                return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::System.Int32[]?>(0)!));\n            },\n            options.EndpointBuilder,\n            handler.Method);\n        }\n\n        Task RequestHandler(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            // Endpoint Parameter: p (Type = int[]?, IsOptional = True, IsParsable = True, IsArray = True, Source = RouteOrQuery)\n            var p_raw = p_RouteOrQueryResolver(httpContext);\n            var p_temp = p_raw.ToArray();\n            global::System.Int32[]? p_local = new global::System.Int32[p_temp.Length];\n            for (var i = 0; i < p_temp.Length; i++)\n            {\n                var element = p_temp[i];\n                if (!GeneratedRouteBuilderExtensionsCore.TryParseExplicit<int>(element!, CultureInfo.InvariantCulture, out var parsed_element))\n                {\n                    if (!string.IsNullOrEmpty(element))\n                    {\n                        logOrThrowExceptionHelper.ParameterBindingFailed(\"int[]?\", \"p\", element);\n                        wasParamCheckFailure = true;\n                    }\n                }\n                p_local[i] = parsed_element!;\n            }\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n                return Task.CompletedTask;\n            }\n            var result = handler(p_local);\n            return GeneratedRouteBuilderExtensionsCore.WriteJsonResponseAsync(httpContext.Response, result, responseJsonTypeInfo);\n        }\n\n        async Task RequestHandlerFiltered(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            // Endpoint Parameter: p (Type = int[]?, IsOptional = True, IsParsable = True, IsArray = True, Source = RouteOrQuery)\n            var p_raw = p_RouteOrQueryResolver(httpContext);\n            var p_temp = p_raw.ToArray();\n            global::System.Int32[]? p_local = new global::System.Int32[p_temp.Length];\n            for (var i = 0; i < p_temp.Length; i++)\n            {\n                var element = p_temp[i];\n                if (!GeneratedRouteBuilderExtensionsCore.TryParseExplicit<int>(element!, CultureInfo.InvariantCulture, out var parsed_element))\n                {\n                    if (!string.IsNullOrEmpty(element))\n                    {\n                        logOrThrowExceptionHelper.ParameterBindingFailed(\"int[]?\", \"p\", element);\n                        wasParamCheckFailure = true;\n                    }\n                }\n                p_local[i] = parsed_element!;\n            }\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n            }\n            var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::System.Int32[]?>(httpContext, p_local));\n            if (result is not null)\n            {\n                await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n            }\n        }\n\n        RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\n        var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\n        return new RequestDelegateResult(targetDelegate, metadata);\n    };\n    var castHandler = Cast(handler, global::System.Int32[] (global::System.Int32[]? arg0= default) => throw null!);\n    return MapCore(\n        endpoints,\n        pattern,\n        handler,\n        GetVerb,\n        populateMetadata,\n        createRequestDelegate,\n```\n\n----------------------------------------\n\nTITLE: Logging and Exception Handling Helper for ASP.NET Core in C#\nDESCRIPTION: This class provides methods for logging errors and optionally throwing exceptions in ASP.NET Core request processing, handling various scenarios such as invalid JSON, parameter binding failures, and missing required parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsSameInterceptorsFromDifferentFiles.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n\n    public void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n\n    public void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n\n    public void ImplicitBodyNotProvided(string parameterName)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n\n    public void UnexpectedJsonContentType(string? contentType)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n            throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n\n    public void UnexpectedNonFormContentType(string? contentType)\n    {\n        if (_shouldThrow)\n        {\n\n\n```\n\n----------------------------------------\n\nTITLE: JSON Type Compatibility Check for Serialization\nDESCRIPTION: Determines whether a JsonTypeInfo instance should be used with a given runtime type for serialization. Handles null values and polymorphism efficiently.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Identity Provider Resolver in ASP.NET Core\nDESCRIPTION: This snippet shows how to configure authentication services with a custom identity provider resolver. It demonstrates the usage of AddAuthentication and AddOpenIdConnect methods, along with a custom resolver for determining the identity provider.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PublicAPI/net462/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nbuilder.Services.AddAuthentication(options =>\n{\n    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n    options.DefaultChallengeScheme = OpenIdConnectDefaults.AuthenticationScheme;\n})\n.AddCookie()\n.AddOpenIdConnect(options =>\n{\n    options.SignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n    options.Authority = \"https://login.microsoftonline.com/common/v2.0\";\n    options.ClientId = \"<client-id>\";\n    options.ResponseType = OpenIdConnectResponseType.IdToken;\n    options.CallbackPath = \"/signin-oidc\";\n    options.IdentityProvider = new CustomIdentityProviderResolver();\n});\n```\n\n----------------------------------------\n\nTITLE: IHtmlHelper Interface Methods - ASP.NET Core MVC\nDESCRIPTION: Core interface methods for generating HTML elements and form controls in ASP.NET Core MVC views. Includes methods for creating inputs, labels, validation messages and handling view data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Rendering.IHtmlHelper {\n    IEnumerable<SelectListItem> GetEnumSelectList(Type enumType);\n    IEnumerable<SelectListItem> GetEnumSelectList<TEnum>();\n    IHtmlContent Hidden(string expression, object value, object htmlAttributes);\n    string Id(string expression);\n    string IdAttributeDotReplacement { get; }\n    IHtmlContent Label(string expression, string labelText, object htmlAttributes);\n    // Additional methods omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Generic IHtmlHelper<TModel> Interface Methods - ASP.NET Core MVC\nDESCRIPTION: Strongly-typed interface methods for model-bound HTML generation in ASP.NET Core MVC views. Provides type-safe methods for creating form controls and displaying model properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Rendering.IHtmlHelper<TModel> {\n    IHtmlContent CheckBoxFor(Expression<Func<TModel, bool>> expression, object htmlAttributes);\n    IHtmlContent DisplayFor<TResult>(Expression<Func<TModel, TResult>> expression, string templateName, string htmlFieldName, object additionalViewData);\n    string DisplayNameFor<TResult>(Expression<Func<TModel, TResult>> expression);\n    // Additional methods omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Extension Method in C#\nDESCRIPTION: Implements a MapGet extension method for IEndpointRouteBuilder to handle HTTP GET requests. It includes metadata population, request delegate creation, and parameter binding logic.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        // Metadata population logic\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        // Request delegate creation logic\n    };\n    var castHandler = Cast(handler, global::System.Int32[] (global::System.Int32[]? arg0= default) => throw null!);\n    return MapCore(\n        endpoints,\n        pattern,\n        handler,\n        GetVerb,\n        populateMetadata,\n        createRequestDelegate,\n        castHandler.Method);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing JwtBearerHandler Methods in C#\nDESCRIPTION: These methods override the base authentication handler to provide JWT Bearer specific functionality for creating events, handling authentication, challenges, and forbidden responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/JwtBearer/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler.CreateEventsAsync() -> System.Threading.Tasks.Task<object!>!\noverride Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler.HandleAuthenticateAsync() -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authentication.AuthenticateResult!>!\noverride Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler.HandleChallengeAsync(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler.HandleForbiddenAsync(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Adding Policy Handlers Extension Methods\nDESCRIPTION: Extension methods for IHttpClientBuilder to add various types of Polly policy handlers to the HTTP client pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HttpClientFactory/Polly/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.PollyHttpClientBuilderExtensions.AddPolicyHandler(this Microsoft.Extensions.DependencyInjection.IHttpClientBuilder! builder, Polly.IAsyncPolicy<System.Net.Http.HttpResponseMessage!>! policy) -> Microsoft.Extensions.DependencyInjection.IHttpClientBuilder!\nstatic Microsoft.Extensions.DependencyInjection.PollyHttpClientBuilderExtensions.AddPolicyHandler(this Microsoft.Extensions.DependencyInjection.IHttpClientBuilder! builder, System.Func<System.IServiceProvider!, System.Net.Http.HttpRequestMessage!, Polly.IAsyncPolicy<System.Net.Http.HttpResponseMessage!>!>! policySelector) -> Microsoft.Extensions.DependencyInjection.IHttpClientBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining WsFederationEvents for Handling Authentication Events in C#\nDESCRIPTION: This class provides event handlers for various stages of the WS-Federation authentication process, including message received, security token received and validated, authentication failed, and remote sign-out.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/WsFederation/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationEvents\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.OnAuthenticationFailed.get -> System.Func<Microsoft.AspNetCore.Authentication.WsFederation.AuthenticationFailedContext!, System.Threading.Tasks.Task!>!\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.OnAuthenticationFailed.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.OnMessageReceived.get -> System.Func<Microsoft.AspNetCore.Authentication.WsFederation.MessageReceivedContext!, System.Threading.Tasks.Task!>!\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.OnMessageReceived.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.OnRedirectToIdentityProvider.get -> System.Func<Microsoft.AspNetCore.Authentication.WsFederation.RedirectContext!, System.Threading.Tasks.Task!>!\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.OnRedirectToIdentityProvider.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.OnRemoteSignOut.get -> System.Func<Microsoft.AspNetCore.Authentication.WsFederation.RemoteSignOutContext!, System.Threading.Tasks.Task!>!\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.OnRemoteSignOut.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.OnSecurityTokenReceived.get -> System.Func<Microsoft.AspNetCore.Authentication.WsFederation.SecurityTokenReceivedContext!, System.Threading.Tasks.Task!>!\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.OnSecurityTokenReceived.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.OnSecurityTokenValidated.get -> System.Func<Microsoft.AspNetCore.Authentication.WsFederation.SecurityTokenValidatedContext!, System.Threading.Tasks.Task!>!\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.OnSecurityTokenValidated.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.WsFederationEvents() -> void\n```\n\n----------------------------------------\n\nTITLE: Form Content Type Logger Definition\nDESCRIPTION: Defines a logger action for unexpected form content types with debug level logging and event ID 7.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleComplexTypeParam_StringReturn.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Identity UI Extension Methods in C#\nDESCRIPTION: Static extension methods for configuring ASP.NET Core Identity UI services and adding default identity functionality to applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.IdentityServiceCollectionUIExtensions.AddDefaultIdentity<TUser>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.AspNetCore.Identity.IdentityBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.IdentityServiceCollectionUIExtensions.AddDefaultIdentity<TUser>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Identity.IdentityOptions!>! configureOptions) -> Microsoft.AspNetCore.Identity.IdentityBuilder!\n```\n\n----------------------------------------\n\nTITLE: Complete OpenAPI 3.1.1 Specification\nDESCRIPTION: Full OpenAPI specification describing XML-related API endpoints including paths, schemas, and tag definitions. The specification includes endpoints for handling todos, projects, board items and demonstrates various data types with examples.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/test/Microsoft.AspNetCore.OpenApi.Tests/Integration/snapshots/OpenApi3_1/OpenApiDocumentIntegrationTests.VerifyOpenApiDocument_documentName=xml.verified.txt#2025-04-08_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"openapi\": \"3.1.1\",\n  \"info\": {\n    \"title\": \"Sample | xml\",\n    \"version\": \"1.0.0\"\n  },\n  \"paths\": {\n    \"/xml/type-with-examples\": {\n      \"get\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/TypeWithExamples\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/TypeWithExamples\"\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"/xml/todo\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/TodoFomInterface\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/xml/project\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/Project\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/xml/board\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/BoardItem\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/xml/project-record\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/ProjectRecord\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/xml/todo-with-description\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/TodoWithDescription\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/Xml\": {\n      \"get\": {\n        \"tags\": [\n          \"Xml\"\n        ],\n        \"parameters\": [\n          {\n            \"name\": \"name\",\n            \"in\": \"query\",\n            \"description\": \"The name of the person.\",\n            \"schema\": {\n              \"type\": \"string\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Returns the greeting.\",\n            \"content\": {\n              \"text/plain\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              },\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              },\n              \"text/json\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              }\n            }\n          }\n        }\n      },\n      \"post\": {\n        \"tags\": [\n          \"Xml\"\n        ],\n        \"requestBody\": {\n          \"description\": \"The todo to insert into the database.\",\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/Todo\"\n              }\n            },\n            \"text/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/Todo\"\n              }\n            },\n            \"application/*+json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/Todo\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"text/plain\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              },\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              },\n              \"text/json\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"BoardItem\": {\n        \"required\": [\n          \"name\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\"\n          }\n        },\n        \"description\": \"An item on the board.\"\n      },\n      \"Project\": {\n        \"required\": [\n          \"name\",\n          \"description\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\"\n          },\n          \"description\": {\n            \"type\": \"string\"\n          }\n        },\n        \"description\": \"The project that contains Todo items.\"\n      },\n      \"ProjectRecord\": {\n        \"required\": [\n          \"name\",\n          \"description\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"The name of the project.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"The description of the project.\"\n          }\n        },\n        \"description\": \"The project that contains Todo items.\"\n      },\n      \"Todo\": {\n        \"required\": [\n          \"id\",\n          \"title\",\n          \"completed\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\"\n          },\n          \"title\": {\n            \"type\": \"string\"\n          },\n          \"completed\": {\n            \"type\": \"boolean\"\n          }\n        }\n      },\n      \"TodoFomInterface\": {\n        \"required\": [\n          \"name\",\n          \"description\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"integer\",\n            \"description\": \"The identifier of the todo.\",\n            \"format\": \"int32\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"The name of the todo.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"A description of the todo.\"\n          }\n        },\n        \"description\": \"This is a todo item.\"\n      },\n      \"TodoWithDescription\": {\n        \"required\": [\n          \"name\",\n          \"description\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"integer\",\n            \"description\": \"The identifier of the todo, overridden.\",\n            \"format\": \"int32\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"The name of the todo, overridden.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"Another description of the todo.\"\n          }\n        }\n      },\n      \"TypeWithExamples\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"booleanType\": {\n            \"type\": \"boolean\",\n            \"example\": true\n          },\n          \"integerType\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"example\": 42\n          },\n          \"longType\": {\n            \"type\": \"integer\",\n            \"format\": \"int64\",\n            \"example\": 1234567890123456789\n          },\n          \"doubleType\": {\n            \"type\": \"number\",\n            \"format\": \"double\",\n            \"example\": 3.14\n          },\n          \"floatType\": {\n            \"type\": \"number\",\n            \"format\": \"float\",\n            \"example\": 3.14\n          },\n          \"dateTimeType\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"example\": \"2022-01-01T00:00:00Z\"\n          },\n          \"dateOnlyType\": {\n            \"type\": \"string\",\n            \"format\": \"date\",\n            \"example\": \"2022-01-01\"\n          }\n        }\n      }\n    }\n  },\n  \"tags\": [\n    {\n      \"name\": \"Sample\"\n    },\n    {\n      \"name\": \"Xml\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Static Web Assets Configuration\nDESCRIPTION: Methods for configuring and using static web assets in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Hosting.StaticWebAssets.StaticWebAssetsLoader.UseStaticWebAssets(Microsoft.AspNetCore.Hosting.IWebHostEnvironment! environment, Microsoft.Extensions.Configuration.IConfiguration! configuration) -> void\nstatic Microsoft.AspNetCore.Hosting.WebHostBuilderExtensions.UseStaticWebAssets(this Microsoft.AspNetCore.Hosting.IWebHostBuilder! builder) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\n```\n\n----------------------------------------\n\nTITLE: Logging Unexpected JSON Content Type in ASP.NET Core\nDESCRIPTION: Defines a logger message for unexpected JSON content types using LoggerMessage.Define. The logger captures the content type and outputs a debug-level message with a specific event ID.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n            LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: HeaderDictionary Class API\nDESCRIPTION: Defines the public API surface for managing HTTP headers in ASP.NET Core\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HeaderDictionary.GetEnumerator() -> HeaderDictionary.Enumerator\nMicrosoft.AspNetCore.Http.HeaderDictionary.HeaderDictionary() -> void\nMicrosoft.AspNetCore.Http.HeaderDictionary.HeaderDictionary(int capacity) -> void\n```\n\n----------------------------------------\n\nTITLE: HeaderDictionary Class API\nDESCRIPTION: Defines the public API surface for managing HTTP headers in ASP.NET Core\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HeaderDictionary.GetEnumerator() -> HeaderDictionary.Enumerator\nMicrosoft.AspNetCore.Http.HeaderDictionary.HeaderDictionary() -> void\nMicrosoft.AspNetCore.Http.HeaderDictionary.HeaderDictionary(int capacity) -> void\n```\n\n----------------------------------------\n\nTITLE: URL Routing Methods in ASP.NET Core MVC\nDESCRIPTION: Virtual methods for URL generation and routing in ASP.NET Core. These methods handle route value transformation, URL generation, virtual path data retrieval, and validation of local URLs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_70\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.Routing.DynamicRouteValueTransformer.FilterAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext, Microsoft.AspNetCore.Routing.RouteValueDictionary! values, System.Collections.Generic.IReadOnlyList<Microsoft.AspNetCore.Http.Endpoint!>! endpoints) -> System.Threading.Tasks.ValueTask<System.Collections.Generic.IReadOnlyList<Microsoft.AspNetCore.Http.Endpoint!>!>\nvirtual Microsoft.AspNetCore.Mvc.Routing.UrlHelper.GenerateUrl(string? protocol, string? host, Microsoft.AspNetCore.Routing.VirtualPathData? pathData, string? fragment) -> string?\nvirtual Microsoft.AspNetCore.Mvc.Routing.UrlHelper.GetVirtualPathData(string? routeName, Microsoft.AspNetCore.Routing.RouteValueDictionary! values) -> Microsoft.AspNetCore.Routing.VirtualPathData?\nvirtual Microsoft.AspNetCore.Mvc.Routing.UrlHelperBase.Content(string? contentPath) -> string?\nvirtual Microsoft.AspNetCore.Mvc.Routing.UrlHelperBase.IsLocalUrl(string? url) -> bool\nvirtual Microsoft.AspNetCore.Mvc.Routing.UrlHelperBase.Link(string? routeName, object? values) -> string?\n```\n\n----------------------------------------\n\nTITLE: PageModel Status and Validation Methods\nDESCRIPTION: Methods for returning HTTP status codes, handling model validation, and unauthorized responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.StatusCode(int statusCode) -> Microsoft.AspNetCore.Mvc.StatusCodeResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.StatusCode(int statusCode, object! value) -> Microsoft.AspNetCore.Mvc.ObjectResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.TryValidateModel(object! model) -> bool\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.TryValidateModel(object! model, string? name) -> bool\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.Unauthorized() -> Microsoft.AspNetCore.Mvc.UnauthorizedResult!\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants Definition\nDESCRIPTION: Defines static string arrays for common HTTP content types used in request processing including JSON, plaintext, and form data types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Response Caching Middleware in C#\nDESCRIPTION: Extension methods for configuring response caching in ASP.NET Core applications, including middleware registration and service configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ResponseCaching/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.ResponseCachingExtensions.UseResponseCaching(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.ResponseCachingServicesExtensions.AddResponseCaching(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n\nstatic Microsoft.Extensions.DependencyInjection.ResponseCachingServicesExtensions.AddResponseCaching(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.ResponseCaching.ResponseCachingOptions!>! configureOptions) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Required Parameters in ASP.NET Core (C#)\nDESCRIPTION: This method handles cases where a required parameter is not provided. It can throw an exception or log the error based on configuration. It takes the parameter type, name, and source as inputs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Post_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Hub Method Handlers in SignalR Client C#\nDESCRIPTION: Allows registration of handlers for hub methods with support for parameterized and state-based callbacks. It returns an IDisposable for unregistering the handler.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.SignalR.Client.HubConnection.On(string! methodName, System.Type![]! parameterTypes, System.Func<object?[]!, object!, System.Threading.Tasks.Task!>! handler, object! state) -> System.IDisposable!\nvirtual Microsoft.AspNetCore.SignalR.Client.HubConnection.On(string! methodName, System.Type![]! parameterTypes, System.Func<object?[]!, object!, System.Threading.Tasks.Task<object?>!>! handler, object! state) -> System.IDisposable!\n```\n\n----------------------------------------\n\nTITLE: Handling Circuit Opened Event in Blazor Server\nDESCRIPTION: Virtual method in CircuitHandler that's called when a new Blazor server circuit is established. Provides a hook for custom logic when a circuit is first created.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandler.OnCircuitOpenedAsync(Microsoft.AspNetCore.Components.Server.Circuits.Circuit! circuit, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: RedisXmlRepository Class Definition in ASP.NET Core\nDESCRIPTION: Class definition for RedisXmlRepository which implements storage of XML elements in Redis. It provides methods for storing and retrieving XML elements used by the Data Protection system.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/StackExchangeRedis/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.DataProtection.StackExchangeRedis.RedisXmlRepository\nMicrosoft.AspNetCore.DataProtection.StackExchangeRedis.RedisXmlRepository.GetAllElements() -> System.Collections.Generic.IReadOnlyCollection<System.Xml.Linq.XElement!>!\nMicrosoft.AspNetCore.DataProtection.StackExchangeRedis.RedisXmlRepository.RedisXmlRepository(System.Func<StackExchange.Redis.IDatabase!>! databaseFactory, StackExchange.Redis.RedisKey key) -> void\nMicrosoft.AspNetCore.DataProtection.StackExchangeRedis.RedisXmlRepository.StoreElement(System.Xml.Linq.XElement! element, string! friendlyName) -> void\n```\n\n----------------------------------------\n\nTITLE: Controller Action Results\nDESCRIPTION: Classes representing various action result types for controller responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.CreatedAtActionResult\nMicrosoft.AspNetCore.Mvc.CreatedAtActionResult.CreatedAtActionResult(string? actionName, string? controllerName, object? routeValues, object? value) -> void\nMicrosoft.AspNetCore.Mvc.CreatedAtRouteResult\nMicrosoft.AspNetCore.Mvc.CreatedAtRouteResult.CreatedAtRouteResult(string? routeName, object? routeValues, object? value) -> void\n```\n\n----------------------------------------\n\nTITLE: Controller Action Results\nDESCRIPTION: Classes representing various action result types for controller responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.CreatedAtActionResult\nMicrosoft.AspNetCore.Mvc.CreatedAtActionResult.CreatedAtActionResult(string? actionName, string? controllerName, object? routeValues, object? value) -> void\nMicrosoft.AspNetCore.Mvc.CreatedAtRouteResult\nMicrosoft.AspNetCore.Mvc.CreatedAtRouteResult.CreatedAtRouteResult(string? routeName, object? routeValues, object? value) -> void\n```\n\n----------------------------------------\n\nTITLE: Extending IHubClients with GroupExcept Methods in C#\nDESCRIPTION: Extension methods for IHubClients<T> to send messages to a group while excluding specific connection IDs. These methods provide overloads for excluding up to 8 connection IDs individually or using an IEnumerable<string>.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.HubClientsExtensions.GroupExcept<T>(this Microsoft.AspNetCore.SignalR.IHubClients<T>! hubClients, string! groupName, string! excludedConnectionId1, string! excludedConnectionId2, string! excludedConnectionId3, string! excludedConnectionId4, string! excludedConnectionId5, string! excludedConnectionId6, string! excludedConnectionId7) -> T\n```\n\n----------------------------------------\n\nTITLE: Implementing MapPut Extension for IEndpointRouteBuilder in ASP.NET Core\nDESCRIPTION: Internal extension method that maps HTTP PUT requests to a specified route pattern with a delegate handler. It populates metadata for request parameters and creates a request delegate that processes HTTP context data and invokes the handler function.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapPut2(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"HttpContext\", new PropertyAsParameterInfo(false, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext)!.GetProperty(\"HttpContext\")!, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext).GetConstructor(new[] { typeof(Microsoft.AspNetCore.Http.HttpContext), typeof(System.Security.Claims.ClaimsPrincipal), typeof(Microsoft.AspNetCore.Http.HttpRequest), typeof(Microsoft.AspNetCore.Http.HttpResponse) })?.GetParameters()[0]), hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"User\", new PropertyAsParameterInfo(false, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext)!.GetProperty(\"User\")!, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext).GetConstructor(new[] { typeof(Microsoft.AspNetCore.Http.HttpContext), typeof(System.Security.Claims.ClaimsPrincipal), typeof(Microsoft.AspNetCore.Http.HttpRequest), typeof(Microsoft.AspNetCore.Http.HttpResponse) })?.GetParameters()[1]), hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"Request\", new PropertyAsParameterInfo(false, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext)!.GetProperty(\"Request\")!, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext).GetConstructor(new[] { typeof(Microsoft.AspNetCore.Http.HttpContext), typeof(System.Security.Claims.ClaimsPrincipal), typeof(Microsoft.AspNetCore.Http.HttpRequest), typeof(Microsoft.AspNetCore.Http.HttpResponse) })?.GetParameters()[2]), hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"Response\", new PropertyAsParameterInfo(false, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext)!.GetProperty(\"Response\")!, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext).GetConstructor(new[] { typeof(Microsoft.AspNetCore.Http.HttpContext), typeof(System.Security.Claims.ClaimsPrincipal), typeof(Microsoft.AspNetCore.Http.HttpRequest), typeof(Microsoft.AspNetCore.Http.HttpResponse) })?.GetParameters()[3]), hasTryParse: false, hasBindAsync: false, isOptional: false));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n        Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n        var handler = Cast(del, void (global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext arg0) => throw null!);\n        EndpointFilterDelegate? filteredInvocation = null;\n        var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n        var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n        var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n        var jsonSerializerOptions = jsonOptions.SerializerOptions;\n        jsonSerializerOptions.MakeReadOnly();\n        var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n\n        if (options.EndpointBuilder.FilterFactories.Count > 0)\n        {\n            filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n            {\n                if (ic.HttpContext.Response.StatusCode == 400)\n                {\n                    return ValueTask.FromResult<object?>(Results.Empty);\n                }\n                handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext>(0)!);\n                return ValueTask.FromResult<object?>(Results.Empty);\n            },\n            options.EndpointBuilder,\n            handler.Method);\n        }\n\n        Task RequestHandler(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)\n                                var HttpContext_local = httpContext;\n            var User_local = httpContext.User;\n            var Request_local = httpContext.Request;\n            var Response_local = httpContext.Response;\n\n            var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext(HttpContext_local, User_local, Request_local, Response_local);\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n                return Task.CompletedTask;\n            }\n            handler(args_local);\n            return Task.CompletedTask;\n        }\n\n        async Task RequestHandlerFiltered(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)\n                                var HttpContext_local = httpContext;\n            var User_local = httpContext.User;\n            var Request_local = httpContext.Request;\n            var Response_local = httpContext.Response;\n\n            var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext(HttpContext_local, User_local, Request_local, Response_local);\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n            }\n            var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext>(httpContext, args_local));\n            if (result is not null)\n            {\n                await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n            }\n        }\n\n        RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\n        var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\n        return new RequestDelegateResult(targetDelegate, metadata);\n    };\n    var castHandler = Cast(handler, void (global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext arg0) => throw null!);\n    return MapCore(\n        endpoints,\n        pattern,\n        handler,\n        PutVerb,\n        populateMetadata,\n        createRequestDelegate,\n        castHandler.Method);\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Cookie Policy Services with Dependency Injection\nDESCRIPTION: Extension methods for registering and configuring Cookie Policy services with ASP.NET Core's dependency injection system. These methods allow configuring CookiePolicyOptions at application startup.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/CookiePolicy/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.CookiePolicyServiceCollectionExtensions.AddCookiePolicy(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Builder.CookiePolicyOptions!>! configureOptions) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.CookiePolicyServiceCollectionExtensions.AddCookiePolicy<TService>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Builder.CookiePolicyOptions!, TService!>! configureOptions) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Overriding User Management Methods in ASP.NET Core Identity\nDESCRIPTION: This snippet showcases the method signatures for overriding various user management operations in ASP.NET Core Identity. It includes methods for adding claims, logins, and tokens, as well as CRUD operations on users.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.AddClaimsAsync(TUser! user, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim!>! claims, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.AddLoginAsync(TUser! user, Microsoft.AspNetCore.Identity.UserLoginInfo! login, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.AddUserTokenAsync(TUserToken! token) -> System.Threading.Tasks.Task!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.CreateAsync(TUser! user, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.DeleteAsync(TUser! user, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core Builder and Middleware Classes\nDESCRIPTION: Core interfaces and classes for building and configuring ASP.NET Core middleware pipeline, including EndpointBuilder, MapMiddleware, and various middleware options classes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nMicrosoft.AspNetCore.Builder.EndpointBuilder\nMicrosoft.AspNetCore.Builder.EndpointBuilder.ApplicationServices.get -> System.IServiceProvider!\nMicrosoft.AspNetCore.Builder.EndpointBuilder.ApplicationServices.init -> void\n// ... additional builder definitions ...\n```\n\n----------------------------------------\n\nTITLE: Authentication Interface Definitions in C#\nDESCRIPTION: Core authentication interfaces defining the contract for authentication handlers, providers and services in ASP.NET Core. Includes methods for authenticating, challenging, signing in/out and managing authentication schemes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Authentication.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.IAuthenticationHandler {\n    Task<AuthenticateResult> AuthenticateAsync();\n    Task ChallengeAsync(AuthenticationProperties? properties);\n    Task ForbidAsync(AuthenticationProperties? properties);\n    Task InitializeAsync(AuthenticationScheme scheme, HttpContext context);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AuthenticationOptions Class in C#\nDESCRIPTION: Defines the AuthenticationOptions class with properties for default authentication schemes and methods for adding new schemes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Authentication.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.AddScheme(string! name, System.Action<Microsoft.AspNetCore.Authentication.AuthenticationSchemeBuilder!>! configureBuilder) -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.AddScheme<THandler>(string! name, string? displayName) -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.AuthenticationOptions() -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.DefaultAuthenticateScheme.get -> string?\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.DefaultAuthenticateScheme.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.DefaultChallengeScheme.get -> string?\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.DefaultChallengeScheme.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.DefaultForbidScheme.get -> string?\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.DefaultForbidScheme.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.DefaultScheme.get -> string?\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.DefaultScheme.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.DefaultSignInScheme.get -> string?\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.DefaultSignInScheme.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.DefaultSignOutScheme.get -> string?\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.DefaultSignOutScheme.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.RequireAuthenticatedSignIn.get -> bool\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.RequireAuthenticatedSignIn.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.SchemeMap.get -> System.Collections.Generic.IDictionary<string!, Microsoft.AspNetCore.Authentication.AuthenticationSchemeBuilder!>!\nMicrosoft.AspNetCore.Authentication.AuthenticationOptions.Schemes.get -> System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authentication.AuthenticationSchemeBuilder!>!\n```\n\n----------------------------------------\n\nTITLE: Defining TagHelper and Related Classes in C#\nDESCRIPTION: This snippet defines the TagHelper class and related classes like TagHelperAttribute, TagHelperContext, and TagHelperOutput. These classes are fundamental to implementing custom tag helpers in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Razor/Razor.Runtime/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Razor.TagHelpers.TagHelper\nMicrosoft.AspNetCore.Razor.TagHelpers.TagHelper.TagHelper() -> void\nMicrosoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute\nMicrosoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute.ValueStyle.get -> Microsoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle\nMicrosoft.AspNetCore.Razor.TagHelpers.TagHelperContext\nMicrosoft.AspNetCore.Razor.TagHelpers.TagHelperOutput\nMicrosoft.AspNetCore.Razor.TagHelpers.TagHelperOutput.IsContentModified.get -> bool\nMicrosoft.AspNetCore.Razor.TagHelpers.TagHelperOutput.SuppressOutput() -> void\nMicrosoft.AspNetCore.Razor.TagHelpers.TagHelperOutput.TagMode.get -> Microsoft.AspNetCore.Razor.TagHelpers.TagMode\nMicrosoft.AspNetCore.Razor.TagHelpers.TagHelperOutput.TagMode.set -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring TestServer for ASP.NET Core Middleware Testing\nDESCRIPTION: Example test method that demonstrates how to set up and use TestServer for testing ASP.NET Core middleware in isolation. It configures a test host using HostBuilder, adds required services, configures the middleware under test, and verifies the response status code.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/TestHost/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[Fact]\npublic async Task MiddlewareTest_ReturnsNotFoundForRequest()\n{\n    // Build and start a host that uses TestServer\n    using var host = await new HostBuilder()\n        .ConfigureWebHost(builder =>\n        {\n            builder.UseTestServer()\n                .ConfigureServices(services =>\n                {\n                    // Add any required services that the middleware uses\n                    services.AddMyServices();\n                })\n                .Configure(app =>\n                {\n                    // Configure the processing pipeline to use the middleware\n                    // for the test\n                    app.UseMiddleware<MyMiddleware>();\n                });\n        })\n        .StartAsync();\n\n    var response = await host.GetTestClient().GetAsync(\"/\");\n\n    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PBKDF2 Key Derivation Method in C# for ASP.NET Core\nDESCRIPTION: This snippet defines a static method Pbkdf2 in the KeyDerivation class. It takes a password, salt, PRF algorithm, iteration count, and desired output length as inputs to perform PBKDF2 key derivation. The method returns a byte array containing the derived key.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/Cryptography.KeyDerivation/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Cryptography.KeyDerivation.KeyDerivation.Pbkdf2(string! password, byte[]! salt, Microsoft.AspNetCore.Cryptography.KeyDerivation.KeyDerivationPrf prf, int iterationCount, int numBytesRequested) -> byte[]!\n```\n\n----------------------------------------\n\nTITLE: Output Cache API Definitions\nDESCRIPTION: Interface and class definitions for ASP.NET Core's output caching system, including cache rules, policies, storage mechanisms and configuration options. These APIs enable developers to implement and customize output caching behavior in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/OutputCaching/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\nMicrosoft.AspNetCore.Builder.OutputCacheApplicationBuilderExtensions\nMicrosoft.AspNetCore.OutputCaching.CacheVaryByRules\nMicrosoft.AspNetCore.OutputCaching.CacheVaryByRules.CacheKeyPrefix.get -> string?\nMicrosoft.AspNetCore.OutputCaching.CacheVaryByRules.CacheKeyPrefix.set -> void\nMicrosoft.AspNetCore.OutputCaching.CacheVaryByRules.CacheVaryByRules() -> void\nMicrosoft.AspNetCore.OutputCaching.CacheVaryByRules.HeaderNames.get -> Microsoft.Extensions.Primitives.StringValues\nMicrosoft.AspNetCore.OutputCaching.CacheVaryByRules.HeaderNames.set -> void\nMicrosoft.AspNetCore.OutputCaching.CacheVaryByRules.QueryKeys.get -> Microsoft.Extensions.Primitives.StringValues\nMicrosoft.AspNetCore.OutputCaching.CacheVaryByRules.QueryKeys.set -> void\nMicrosoft.AspNetCore.OutputCaching.CacheVaryByRules.RouteValueNames.get -> Microsoft.Extensions.Primitives.StringValues\nMicrosoft.AspNetCore.OutputCaching.CacheVaryByRules.RouteValueNames.set -> void\nMicrosoft.AspNetCore.OutputCaching.CacheVaryByRules.VaryByHost.get -> bool\nMicrosoft.AspNetCore.OutputCaching.CacheVaryByRules.VaryByHost.set -> void\nMicrosoft.AspNetCore.OutputCaching.CacheVaryByRules.VaryByValues.get -> System.Collections.Generic.IDictionary<string!, string!>!\nMicrosoft.AspNetCore.OutputCaching.IOutputCacheBufferStore\nMicrosoft.AspNetCore.OutputCaching.IOutputCacheBufferStore.SetAsync(string! key, System.Buffers.ReadOnlySequence<byte> value, System.ReadOnlyMemory<string!> tags, System.TimeSpan validFor, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask\nMicrosoft.AspNetCore.OutputCaching.IOutputCacheBufferStore.TryGetAsync(string! key, System.IO.Pipelines.PipeWriter! destination, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<bool>\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Extension Method for IEndpointRouteBuilder\nDESCRIPTION: This code implements the MapGet extension method for IEndpointRouteBuilder to handle GET requests with array parameters. It includes parameter binding, metadata population, and request delegation with support for filters and JSON serialization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n%INTERCEPTSLOCATIONATTRIBUTE%\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: true, hasBindAsync: false, isOptional: true));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(global::System.Int32[]), contentTypes: GeneratedMetadataConstants.JsonContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n        Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n        var handler = Cast(del, global::System.Int32[] (global::System.Int32[]? arg0= default) => throw null!);\n        EndpointFilterDelegate? filteredInvocation = null;\n        var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n        var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n        var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n        var jsonSerializerOptions = jsonOptions.SerializerOptions;\n        jsonSerializerOptions.MakeReadOnly();\n        var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n        var responseJsonTypeInfo =  (JsonTypeInfo<global::System.Int32[]?>)jsonSerializerOptions.GetTypeInfo(typeof(global::System.Int32[]));\n        var p_RouteOrQueryResolver = GeneratedRouteBuilderExtensionsCore.ResolveFromRouteOrQuery(\"p\", options.RouteParameterNames);\n\n        if (options.EndpointBuilder.FilterFactories.Count > 0)\n        {\n            filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n            {\n                if (ic.HttpContext.Response.StatusCode == 400)\n                {\n                    return ValueTask.FromResult<object?>(Results.Empty);\n                }\n                return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::System.Int32[]?>(0)!));\n            },\n            options.EndpointBuilder,\n            handler.Method);\n        }\n\n        Task RequestHandler(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            // Endpoint Parameter: p (Type = int[]?, IsOptional = True, IsParsable = True, IsArray = True, Source = RouteOrQuery)\n            var p_raw = p_RouteOrQueryResolver(httpContext);\n            var p_temp = p_raw.ToArray();\n            global::System.Int32[]? p_local = new global::System.Int32[p_temp.Length];\n            for (var i = 0; i < p_temp.Length; i++)\n            {\n                var element = p_temp[i];\n                if (!GeneratedRouteBuilderExtensionsCore.TryParseExplicit<int>(element!, CultureInfo.InvariantCulture, out var parsed_element))\n                {\n                    if (!string.IsNullOrEmpty(element))\n                    {\n                        logOrThrowExceptionHelper.ParameterBindingFailed(\"int[]?\", \"p\", element);\n                        wasParamCheckFailure = true;\n                    }\n                }\n                p_local[i] = parsed_element!;\n            }\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n                return Task.CompletedTask;\n            }\n            var result = handler(p_local);\n            return GeneratedRouteBuilderExtensionsCore.WriteJsonResponseAsync(httpContext.Response, result, responseJsonTypeInfo);\n        }\n\n        async Task RequestHandlerFiltered(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            // Endpoint Parameter: p (Type = int[]?, IsOptional = True, IsParsable = True, IsArray = True, Source = RouteOrQuery)\n            var p_raw = p_RouteOrQueryResolver(httpContext);\n            var p_temp = p_raw.ToArray();\n            global::System.Int32[]? p_local = new global::System.Int32[p_temp.Length];\n            for (var i = 0; i < p_temp.Length; i++)\n            {\n                var element = p_temp[i];\n                if (!GeneratedRouteBuilderExtensionsCore.TryParseExplicit<int>(element!, CultureInfo.InvariantCulture, out var parsed_element))\n                {\n                    if (!string.IsNullOrEmpty(element))\n                    {\n                        logOrThrowExceptionHelper.ParameterBindingFailed(\"int[]?\", \"p\", element);\n                        wasParamCheckFailure = true;\n                    }\n                }\n                p_local[i] = parsed_element!;\n            }\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n            }\n            var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::System.Int32[]?>(httpContext, p_local));\n            if (result is not null)\n            {\n                await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n            }\n        }\n\n        RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\n        var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\n        return new RequestDelegateResult(targetDelegate, metadata);\n    };\n    var castHandler = Cast(handler, global::System.Int32[] (global::System.Int32[]? arg0= default) => throw null!);\n    return MapCore(\n        endpoints,\n        pattern,\n        handler,\n        GetVerb,\n        populateMetadata,\n        createRequestDelegate,\n```\n\n----------------------------------------\n\nTITLE: Implementing UserOnlyStore in C# for ASP.NET Core Identity\nDESCRIPTION: Defines the UserOnlyStore class for managing users without roles in ASP.NET Core Identity. It includes methods for CRUD operations on users, claims, logins, and tokens.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.AutoSaveChanges.get -> bool\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.AutoSaveChanges.set -> void\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.SaveChanges(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.UserClaims.get -> Microsoft.EntityFrameworkCore.DbSet<TUserClaim!>!\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.UserLogins.get -> Microsoft.EntityFrameworkCore.DbSet<TUserLogin!>!\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.UserOnlyStore(TContext! context, Microsoft.AspNetCore.Identity.IdentityErrorDescriber? describer = null) -> void\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.UsersSet.get -> Microsoft.EntityFrameworkCore.DbSet<TUser!>!\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.UserTokens.get -> Microsoft.EntityFrameworkCore.DbSet<TUserToken!>!\n```\n\n----------------------------------------\n\nTITLE: Request Delegate Factory Implementation in C#\nDESCRIPTION: Implements logic for creating and configuring request delegates that handle HTTP requests. Includes parameter binding, response type handling, and endpoint filtering. Handles both filtered and unfiltered request processing paths.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandler(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var httpContext_local = httpContext;\n    var myBindAsyncParam_local = await global::Microsoft.AspNetCore.Http.Generators.Tests.MyNullableBindAsyncStruct.BindAsync(httpContext, parameters[1]);\n    if (!myBindAsyncParam_local.HasValue)\n    {\n        logOrThrowExceptionHelper.RequiredParameterNotProvided(\"MyNullableBindAsyncStruct\", \"myBindAsyncParam\", \"MyNullableBindAsyncStruct.BindAsync(HttpContext, ParameterInfo)\");\n        wasParamCheckFailure = true;\n        myBindAsyncParam_local = default!;\n    }\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n        return;\n    }\n    var result = handler(httpContext_local, myBindAsyncParam_local.HasValue ? myBindAsyncParam_local.Value : default);\n    if (result is string)\n    {\n        httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n    }\n    else\n    {\n        httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n    }\n    await httpContext.Response.WriteAsync(result);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IAuthorizeData Interface in C#\nDESCRIPTION: Declares the IAuthorizeData interface with properties for authentication schemes, policies, and roles. This interface is used to configure authorization requirements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Metadata/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.IAuthorizeData\nMicrosoft.AspNetCore.Authorization.IAuthorizeData.AuthenticationSchemes.get -> string?\nMicrosoft.AspNetCore.Authorization.IAuthorizeData.AuthenticationSchemes.set -> void\nMicrosoft.AspNetCore.Authorization.IAuthorizeData.Policy.get -> string?\nMicrosoft.AspNetCore.Authorization.IAuthorizeData.Policy.set -> void\nMicrosoft.AspNetCore.Authorization.IAuthorizeData.Roles.get -> string?\nMicrosoft.AspNetCore.Authorization.IAuthorizeData.Roles.set -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring Authentication State Serialization for WebAssembly Components\nDESCRIPTION: Extension method for IRazorComponentsBuilder that adds support for serializing authentication state for WebAssembly components. This enables authentication state to be transmitted between server and client components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.WebAssemblyRazorComponentsBuilderExtensions.AddAuthenticationStateSerialization(this Microsoft.Extensions.DependencyInjection.IRazorComponentsBuilder! builder, System.Action<Microsoft.AspNetCore.Components.WebAssembly.Server.AuthenticationStateSerializationOptions!>? configure = null) -> Microsoft.Extensions.DependencyInjection.IRazorComponentsBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining IComponentPrerenderer Interface in C#\nDESCRIPTION: This interface defines methods for prerendering Razor Components and persisted state in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Endpoints/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Endpoints.IComponentPrerenderer\nMicrosoft.AspNetCore.Components.Endpoints.IComponentPrerenderer.Dispatcher.get -> Microsoft.AspNetCore.Components.Dispatcher!\nMicrosoft.AspNetCore.Components.Endpoints.IComponentPrerenderer.PrerenderComponentAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext, System.Type! componentType, Microsoft.AspNetCore.Components.IComponentRenderMode! renderMode, Microsoft.AspNetCore.Components.ParameterView parameters) -> System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Html.IHtmlAsyncContent!>\nMicrosoft.AspNetCore.Components.Endpoints.IComponentPrerenderer.PrerenderPersistedStateAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext, Microsoft.AspNetCore.Components.PersistedStateSerializationMode serializationMode) -> System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Html.IHtmlContent!>\n```\n\n----------------------------------------\n\nTITLE: Processing Form Parameters in ASP.NET Core Request Handler\nDESCRIPTION: Implements request handling for ASP.NET Core with form parameter binding. It processes form data including IFormFile, IFormFileCollection, IFormCollection, and custom parsable types, with validation and error handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/RequestDelegateValidateGeneratedFormCode.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandlerFiltered(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var httpContext_local = httpContext;\n    // Endpoint Parameter: file (Type = Microsoft.AspNetCore.Http.IFormFile, IsOptional = False, IsParsable = False, IsArray = False, Source = FormBody)\n    var file_resolveFormResult = await GeneratedRouteBuilderExtensionsCore.TryResolveFormAsync(httpContext, logOrThrowExceptionHelper, \"IFormFile\", \"file\");\n    if (!file_resolveFormResult.Item1)\n    {\n        return;\n    }\n    var file_raw = httpContext.Request.Form.Files[\"file\"];\n    if (file_raw == null)\n    {\n        wasParamCheckFailure = true;\n        logOrThrowExceptionHelper.RequiredParameterNotProvided(\"IFormFile\", \"file\", \"form\");\n    }\n    var file_temp = file_raw;\n    global::Microsoft.AspNetCore.Http.IFormFile file_local = file_temp!;\n    // Endpoint Parameter: fileCollection (Type = Microsoft.AspNetCore.Http.IFormFileCollection, IsOptional = False, IsParsable = False, IsArray = False, Source = FormBody)\n    var fileCollection_raw = httpContext.Request.Form.Files;\n    if (fileCollection_raw == null)\n    {\n        wasParamCheckFailure = true;\n        logOrThrowExceptionHelper.RequiredParameterNotProvided(\"IFormFileCollection\", \"fileCollection\", \"form\");\n    }\n    var fileCollection_temp = fileCollection_raw;\n    global::Microsoft.AspNetCore.Http.IFormFileCollection fileCollection_local = fileCollection_temp!;\n    // Endpoint Parameter: collection (Type = Microsoft.AspNetCore.Http.IFormCollection, IsOptional = False, IsParsable = False, IsArray = False, Source = FormBody)\n    var collection_raw = httpContext.Request.Form;\n    if (collection_raw == null)\n    {\n        wasParamCheckFailure = true;\n        logOrThrowExceptionHelper.RequiredParameterNotProvided(\"IFormCollection\", \"collection\", \"form\");\n    }\n    var collection_temp = collection_raw;\n    global::Microsoft.AspNetCore.Http.IFormCollection collection_local = collection_temp!;\n    // Endpoint Parameter: tryParseRecord (Type = Microsoft.AspNetCore.Http.Generators.Tests.MyTryParseRecord, IsOptional = False, IsParsable = True, IsArray = False, Source = FormBody)\n    var tryParseRecord_raw = (string?)httpContext.Request.Form[\"tryParseRecord\"];\n    if (tryParseRecord_raw == null)\n    {\n        wasParamCheckFailure = true;\n        logOrThrowExceptionHelper.RequiredParameterNotProvided(\"MyTryParseRecord\", \"tryParseRecord\", \"form\");\n    }\n    var tryParseRecord_temp = tryParseRecord_raw;\n    if (!global::Microsoft.AspNetCore.Http.Generators.Tests.MyTryParseRecord.TryParse(tryParseRecord_temp!, out var tryParseRecord_parsed_temp))\n    {\n        if (!string.IsNullOrEmpty(tryParseRecord_temp))\n        {\n            logOrThrowExceptionHelper.ParameterBindingFailed(\"MyTryParseRecord\", \"tryParseRecord\", tryParseRecord_temp);\n            wasParamCheckFailure = true;\n        }\n    }\n    global::Microsoft.AspNetCore.Http.Generators.Tests.MyTryParseRecord tryParseRecord_local = tryParseRecord_parsed_temp!;\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n    }\n    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.HttpContext, global::Microsoft.AspNetCore.Http.IFormFile, global::Microsoft.AspNetCore.Http.IFormFileCollection, global::Microsoft.AspNetCore.Http.IFormCollection, global::Microsoft.AspNetCore.Http.Generators.Tests.MyTryParseRecord>(httpContext, httpContext_local, file_local!, fileCollection_local!, collection_local!, tryParseRecord_local!));\n    if (result is not null)\n    {\n        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FeatureCollection Class in ASP.NET Core\nDESCRIPTION: This code snippet defines the FeatureCollection class in the Microsoft.AspNetCore.Http.Features namespace. It provides methods for managing and accessing HTTP features in a collection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Features/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Features.FeatureCollection (forwarded, contained in Microsoft.Extensions.Features)\nMicrosoft.AspNetCore.Http.Features.FeatureCollection.FeatureCollection() -> void (forwarded, contained in Microsoft.Extensions.Features)\nMicrosoft.AspNetCore.Http.Features.FeatureCollection.FeatureCollection(int initialCapacity) -> void (forwarded, contained in Microsoft.Extensions.Features)\nMicrosoft.AspNetCore.Http.Features.FeatureCollection.FeatureCollection(Microsoft.AspNetCore.Http.Features.IFeatureCollection! defaults) -> void (forwarded, contained in Microsoft.Extensions.Features)\nMicrosoft.AspNetCore.Http.Features.FeatureCollection.Get<TFeature>() -> TFeature? (forwarded, contained in Microsoft.Extensions.Features)\nMicrosoft.AspNetCore.Http.Features.FeatureCollection.GetEnumerator() -> System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<System.Type!, object!>>! (forwarded, contained in Microsoft.Extensions.Features)\nMicrosoft.AspNetCore.Http.Features.FeatureCollection.IsReadOnly.get -> bool (forwarded, contained in Microsoft.Extensions.Features)\nMicrosoft.AspNetCore.Http.Features.FeatureCollection.Set<TFeature>(TFeature? feature) -> void (forwarded, contained in Microsoft.Extensions.Features)\n```\n\n----------------------------------------\n\nTITLE: Handling HTTP Response Results in ASP.NET Core\nDESCRIPTION: Executes the appropriate response writing logic based on the returned object type. Handles IResult implementations, string values, and JSON serialization for other object types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Route View Rendering in ASP.NET Core Blazor\nDESCRIPTION: Virtual method for rendering route views in Blazor routing system, allowing customization of how routes are rendered to the component tree.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.RouteView.Render(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder! builder) -> void\n```\n\n----------------------------------------\n\nTITLE: AuthorizationHandlerContext Class Definition in C#\nDESCRIPTION: Definition of the AuthorizationHandlerContext class that provides context information for authorization handlers, including requirements, user, and resource being authorized.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationHandlerContext\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationHandlerContext.AuthorizationHandlerContext(System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.IAuthorizationRequirement!>! requirements, System.Security.Claims.ClaimsPrincipal! user, object? resource) -> void\n```\n\n----------------------------------------\n\nTITLE: QuickGrid Component Method and Property Definitions in ASP.NET Core\nDESCRIPTION: Defines the API surface for the QuickGrid<TGridItem> component including an asynchronous method to hide column options and properties for customizing row CSS classes based on the grid item.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/QuickGrid/Microsoft.AspNetCore.Components.QuickGrid/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\nMicrosoft.AspNetCore.Components.QuickGrid.QuickGrid<TGridItem>.HideColumnOptionsAsync() -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Components.QuickGrid.QuickGrid<TGridItem>.RowClass.get -> System.Func<TGridItem, string?>?\nMicrosoft.AspNetCore.Components.QuickGrid.QuickGrid<TGridItem>.RowClass.set -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing ContentRangeHeaderValue Class in C#\nDESCRIPTION: Defines the ContentRangeHeaderValue class for handling Content-Range headers, including constructors and range-related properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Headers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Net.Http.Headers.ContentRangeHeaderValue\nMicrosoft.Net.Http.Headers.ContentRangeHeaderValue.ContentRangeHeaderValue(long from, long to) -> void\nMicrosoft.Net.Http.Headers.ContentRangeHeaderValue.ContentRangeHeaderValue(long from, long to, long length) -> void\nMicrosoft.Net.Http.Headers.ContentRangeHeaderValue.ContentRangeHeaderValue(long length) -> void\n// ... (additional properties)\n```\n\n----------------------------------------\n\nTITLE: JSON Content Type Logger Definition\nDESCRIPTION: Defines a logger action for unexpected JSON content types with debug level logging and event ID 6.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleComplexTypeParam_StringReturn.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: More W3CLoggingFields Definitions in ASP.NET Core\nDESCRIPTION: Additional field definitions for the W3CLoggingFields enumeration, including server information, timing, URI components, and user agent fields.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpLogging/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.ServerIpAddress = 32 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.ServerName = 16 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.ServerPort = 64 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.Time = 2 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.TimeTaken = 2048 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.UriQuery = 512 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.UriStem = 256 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.UserAgent = 16384 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.UserName = 8 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\n```\n\n----------------------------------------\n\nTITLE: Querying User Data in ASP.NET Core Identity EntityFrameworkCore\nDESCRIPTION: This snippet shows the signatures of overridden methods in the UserStore class for querying user-related data such as claims, logins, roles, and users associated with specific claims or roles. These methods provide access to the underlying EntityFrameworkCore database.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.GetClaimsAsync(TUser! user, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<System.Collections.Generic.IList<System.Security.Claims.Claim!>!>!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.GetLoginsAsync(TUser! user, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<System.Collections.Generic.IList<Microsoft.AspNetCore.Identity.UserLoginInfo!>!>!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.GetRolesAsync(TUser! user, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<System.Collections.Generic.IList<string!>!>!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.GetUsersForClaimAsync(System.Security.Claims.Claim! claim, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<System.Collections.Generic.IList<TUser!>!>!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.GetUsersInRoleAsync(string! normalizedRoleName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<System.Collections.Generic.IList<TUser!>!>!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.IsInRoleAsync(TUser! user, string! normalizedRoleName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<bool>!\n```\n\n----------------------------------------\n\nTITLE: OpenID Connect Authentication Event Handlers\nDESCRIPTION: Virtual methods for handling various events during the OpenID Connect authentication flow, including token validation, authorization code processing, redirects, and sign-out events. These methods can be overridden to customize authentication behavior.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectEvents.AuthenticationFailed(Microsoft.AspNetCore.Authentication.OpenIdConnect.AuthenticationFailedContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectEvents.AuthorizationCodeReceived(Microsoft.AspNetCore.Authentication.OpenIdConnect.AuthorizationCodeReceivedContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectEvents.MessageReceived(Microsoft.AspNetCore.Authentication.OpenIdConnect.MessageReceivedContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectEvents.PushAuthorization(Microsoft.AspNetCore.Authentication.OpenIdConnect.PushedAuthorizationContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectEvents.RedirectToIdentityProvider(Microsoft.AspNetCore.Authentication.OpenIdConnect.RedirectContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectEvents.RedirectToIdentityProviderForSignOut(Microsoft.AspNetCore.Authentication.OpenIdConnect.RedirectContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectEvents.RemoteSignOut(Microsoft.AspNetCore.Authentication.OpenIdConnect.RemoteSignOutContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectEvents.SignedOutCallbackRedirect(Microsoft.AspNetCore.Authentication.OpenIdConnect.RemoteSignOutContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectEvents.TokenResponseReceived(Microsoft.AspNetCore.Authentication.OpenIdConnect.TokenResponseReceivedContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectEvents.TokenValidated(Microsoft.AspNetCore.Authentication.OpenIdConnect.TokenValidatedContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectEvents.UserInformationReceived(Microsoft.AspNetCore.Authentication.OpenIdConnect.UserInformationReceivedContext! context) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: OpenID Connect Authentication Handler Methods\nDESCRIPTION: Virtual methods for the OpenID Connect authentication handler that implement core functionality such as retrieving user information, handling sign-out, redeeming authorization codes, and managing remote sign-out events.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectHandler.GetUserInformationAsync(Microsoft.IdentityModel.Protocols.OpenIdConnect.OpenIdConnectMessage! message, System.IdentityModel.Tokens.Jwt.JwtSecurityToken! jwt, System.Security.Claims.ClaimsPrincipal! principal, Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authentication.HandleRequestResult!>!\nvirtual Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectHandler.HandleRemoteSignOutAsync() -> System.Threading.Tasks.Task<bool>!\nvirtual Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectHandler.HandleSignOutCallbackAsync() -> System.Threading.Tasks.Task<bool>!\nvirtual Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectHandler.RedeemAuthorizationCodeAsync(Microsoft.IdentityModel.Protocols.OpenIdConnect.OpenIdConnectMessage! tokenEndpointRequest) -> System.Threading.Tasks.Task<Microsoft.IdentityModel.Protocols.OpenIdConnect.OpenIdConnectMessage!>!\nvirtual Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectHandler.SignOutAsync(Microsoft.AspNetCore.Authentication.AuthenticationProperties? properties) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining IdentityDbContext Classes in C#\nDESCRIPTION: Defines various IdentityDbContext classes with different generic parameters for customizing the identity schema. These classes are used to configure and interact with the identity database.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.IdentityDbContext\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.IdentityDbContext.IdentityDbContext() -> void\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.IdentityDbContext.IdentityDbContext(Microsoft.EntityFrameworkCore.DbContextOptions! options) -> void\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.IdentityDbContext<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TRoleClaim, TUserToken>\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.IdentityDbContext<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TRoleClaim, TUserToken>.IdentityDbContext() -> void\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.IdentityDbContext<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TRoleClaim, TUserToken>.IdentityDbContext(Microsoft.EntityFrameworkCore.DbContextOptions! options) -> void\n```\n\n----------------------------------------\n\nTITLE: Redirect Response in ASP.NET Core Transport Protocol\nDESCRIPTION: JSON response that redirects the client to another URL with an optional access token. Used during negotiation when the connection should be established to a different endpoint.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/TransportProtocols.md#2025-04-08_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"url\": \"https://myapp.com/chat\",\n  \"accessToken\": \"accessToken\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Header Propagation Entry Collection in C#\nDESCRIPTION: Collection class for managing header propagation entries with methods to add and configure header mappings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HeaderPropagation/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.HeaderPropagation.HeaderPropagationEntryCollection.Add(string! headerName) -> void\nMicrosoft.AspNetCore.HeaderPropagation.HeaderPropagationEntryCollection.Add(string! headerName, System.Func<Microsoft.AspNetCore.HeaderPropagation.HeaderPropagationContext, Microsoft.Extensions.Primitives.StringValues>! valueFilter) -> void\nMicrosoft.AspNetCore.HeaderPropagation.HeaderPropagationEntryCollection.Add(string! inboundHeaderName, string! outboundHeaderName) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing AvailableTransport Class in C#\nDESCRIPTION: A class representing an available transport option during connection negotiation. Contains properties for the transport type and supported transfer formats.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/Http.Connections.Common/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Connections.AvailableTransport\nMicrosoft.AspNetCore.Http.Connections.AvailableTransport.AvailableTransport() -> void\nMicrosoft.AspNetCore.Http.Connections.AvailableTransport.TransferFormats.get -> System.Collections.Generic.IList<string!>?\nMicrosoft.AspNetCore.Http.Connections.AvailableTransport.TransferFormats.set -> void\nMicrosoft.AspNetCore.Http.Connections.AvailableTransport.Transport.get -> string?\nMicrosoft.AspNetCore.Http.Connections.AvailableTransport.Transport.set -> void\n```\n\n----------------------------------------\n\nTITLE: MouseEventArgs Class for ASP.NET Core Blazor Events\nDESCRIPTION: Defines the MouseEventArgs class for mouse events in Blazor. Contains properties for mouse coordinates, button states, keyboard modifiers, and other mouse event information for browser-based Blazor applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.AltKey.get -> bool\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.AltKey.set -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.Button.get -> long\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.Button.set -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.Buttons.get -> long\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.Buttons.set -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.ClientX.get -> double\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.ClientX.set -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.ClientY.get -> double\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.ClientY.set -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.CtrlKey.get -> bool\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.CtrlKey.set -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.Detail.get -> long\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.Detail.set -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.MetaKey.get -> bool\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.MetaKey.set -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.MouseEventArgs() -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.MovementX.get -> double\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.MovementX.set -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.MovementY.get -> double\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.MovementY.set -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.OffsetX.get -> double\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.OffsetX.set -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.OffsetY.get -> double\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.OffsetY.set -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.PageX.get -> double\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.PageX.set -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.PageY.get -> double\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.PageY.set -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.ScreenX.get -> double\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.ScreenX.set -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.ScreenY.get -> double\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.ScreenY.set -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.ShiftKey.get -> bool\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.ShiftKey.set -> void\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.Type.get -> string!\nMicrosoft.AspNetCore.Components.Web.MouseEventArgs.Type.set -> void\n```\n\n----------------------------------------\n\nTITLE: Creating Request Delegate for GET Handler in ASP.NET Core\nDESCRIPTION: This snippet defines a function to create a request delegate. It handles parameter binding, filtering, and request processing for a GET handler that takes a BindAsyncFromExplicitStaticAbstractInterface parameter.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\nRequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n{\n    Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n    Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n    Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n    Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n    var handler = Cast(del, global::System.String (global::Microsoft.AspNetCore.Http.Generators.Tests.BindAsyncFromExplicitStaticAbstractInterface? arg0) => throw null!);\n    EndpointFilterDelegate? filteredInvocation = null;\n    var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n    var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n    var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n    var jsonSerializerOptions = jsonOptions.SerializerOptions;\n    jsonSerializerOptions.MakeReadOnly();\n    var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n    var parameters = del.Method.GetParameters();\n\n    // ... (rest of the function implementation)\n};\n```\n\n----------------------------------------\n\nTITLE: Defining IInvocationBinder Interface in ASP.NET Core SignalR (C#)\nDESCRIPTION: Interface for binding hub method invocations to their parameter types and return types. Used by hub protocols to convert serialized data to the correct types when invoking hub methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.IInvocationBinder\nMicrosoft.AspNetCore.SignalR.IInvocationBinder.GetParameterTypes(string! methodName) -> System.Collections.Generic.IReadOnlyList<System.Type!>!\nMicrosoft.AspNetCore.SignalR.IInvocationBinder.GetReturnType(string! invocationId) -> System.Type!\nMicrosoft.AspNetCore.SignalR.IInvocationBinder.GetStreamItemType(string! streamId) -> System.Type!\n```\n\n----------------------------------------\n\nTITLE: Form Request Body Validation in C#\nDESCRIPTION: Handles validation of form request body data. Throws BadHttpRequestException if the form data cannot be properly read or parsed.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_QueryNotPresent.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Parameter Validation and Default Value Handling in ASP.NET Core Request Processing\nDESCRIPTION: Code that handles parameter parsing from HTTP requests with default value fallback. If a parameter cannot be parsed as an integer, it sets a default value of 42 when the input is empty or marks parsing as failed for non-empty invalid inputs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nif (GeneratedRouteBuilderExtensionsCore.TryParseExplicit<int>(Value_temp!, CultureInfo.InvariantCulture, out var Value_temp_parsed_non_nullable))\n{\n    Value_parsed_temp = Value_temp_parsed_non_nullable;\n}\nelse if (string.IsNullOrEmpty(Value_temp))\n{\n    Value_parsed_temp = 42;\n}\nelse\n{\n    wasParamCheckFailure = true;\n}\nint Value_local = Value_parsed_temp!;\n\nvar args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue(HttpContext_local, Value_local);\n\nif (wasParamCheckFailure)\n{\n    httpContext.Response.StatusCode = 400;\n}\nvar result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue>(httpContext, args_local));\nif (result is not null)\n{\n    await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Key Management Interface Definitions in C#\nDESCRIPTION: Core interfaces defining key management functionality including IKey for encryption key metadata, IKeyManager for key lifecycle operations, and IKeyEscrowSink for key backup storage.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IKey {\n    DateTimeOffset CreationDate { get; }\n    IAuthenticatedEncryptorDescriptor Descriptor { get; }\n    DateTimeOffset ExpirationDate { get; }\n    bool IsRevoked { get; }\n    Guid KeyId { get; }\n}\n\npublic interface IKeyManager {\n    IKey CreateNewKey(DateTimeOffset activationDate, DateTimeOffset expirationDate);\n    IReadOnlyCollection<IKey> GetAllKeys();\n    CancellationToken GetCacheExpirationToken();\n    void RevokeAllKeys(DateTimeOffset revocationDate, string? reason = null);\n    void RevokeKey(Guid keyId, string? reason = null);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RemoteSignOutContext for WS-Federation Authentication in C#\nDESCRIPTION: This class represents the context for remote sign-out in WS-Federation authentication. It contains information about the HTTP context, authentication scheme, options, and the WS-Federation message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/WsFederation/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.WsFederation.RemoteSignOutContext.RemoteSignOutContext(Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Authentication.AuthenticationScheme! scheme, Microsoft.AspNetCore.Authentication.WsFederation.WsFederationOptions! options, Microsoft.IdentityModel.Protocols.WsFederation.WsFederationMessage! message) -> void\n```\n\n----------------------------------------\n\nTITLE: HttpConnectionOptions Class Properties in ASP.NET Core (C#)\nDESCRIPTION: Defines the HttpConnectionOptions class with numerous properties for configuring HTTP connections, including transport types, authentication, headers, timeout values, and proxy settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Http.Connections.Client/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.AccessTokenProvider.get -> System.Func<System.Threading.Tasks.Task<string?>!>?\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.AccessTokenProvider.set -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.ApplicationMaxBufferSize.get -> long\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.ApplicationMaxBufferSize.set -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.ClientCertificates.get -> System.Security.Cryptography.X509Certificates.X509CertificateCollection?\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.ClientCertificates.set -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.CloseTimeout.get -> System.TimeSpan\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.CloseTimeout.set -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.Cookies.get -> System.Net.CookieContainer!\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.Cookies.set -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.Credentials.get -> System.Net.ICredentials?\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.Credentials.set -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.DefaultTransferFormat.get -> Microsoft.AspNetCore.Connections.TransferFormat\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.DefaultTransferFormat.set -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.Headers.get -> System.Collections.Generic.IDictionary<string!, string!>!\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.Headers.set -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.HttpConnectionOptions() -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.HttpMessageHandlerFactory.get -> System.Func<System.Net.Http.HttpMessageHandler!, System.Net.Http.HttpMessageHandler!>?\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.HttpMessageHandlerFactory.set -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.Proxy.get -> System.Net.IWebProxy?\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.Proxy.set -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.SkipNegotiation.get -> bool\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.SkipNegotiation.set -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.TransportMaxBufferSize.get -> long\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.TransportMaxBufferSize.set -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.Transports.get -> Microsoft.AspNetCore.Http.Connections.HttpTransportType\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.Transports.set -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.Url.get -> System.Uri?\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.Url.set -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.UseDefaultCredentials.get -> bool?\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.UseDefaultCredentials.set -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.UseStatefulReconnect.get -> bool\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.UseStatefulReconnect.set -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.WebSocketConfiguration.get -> System.Action<System.Net.WebSockets.ClientWebSocketOptions!>?\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.WebSocketConfiguration.set -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.WebSocketFactory.get -> System.Func<Microsoft.AspNetCore.Http.Connections.Client.WebSocketConnectionContext!, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask<System.Net.WebSockets.WebSocket!>>?\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions.WebSocketFactory.set -> void\n```\n\n----------------------------------------\n\nTITLE: Request Handler Implementation for GET Endpoint in ASP.NET Core\nDESCRIPTION: This snippet shows the implementation of the request handler for a GET endpoint. It handles parameter binding, validation, and response writing for both filtered and unfiltered scenarios.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandler(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var myBindAsyncParam_local = await BindAsync<global::Microsoft.AspNetCore.Http.Generators.Tests.BindAsyncFromExplicitStaticAbstractInterface>(httpContext, parameters[0]);\n\n    // ... (rest of the handler implementation)\n}\n\nasync Task RequestHandlerFiltered(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var myBindAsyncParam_local = await BindAsync<global::Microsoft.AspNetCore.Http.Generators.Tests.BindAsyncFromExplicitStaticAbstractInterface>(httpContext, parameters[0]);\n\n    // ... (rest of the filtered handler implementation)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ASP.NET Core MVC Infrastructure Interfaces and Classes\nDESCRIPTION: Defines core infrastructure interfaces and classes for ASP.NET Core MVC including action contexts, descriptors, executors and parameter handling. These components form the foundation for MVC request processing and result handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Infrastructure.IActionContextAccessor\nMicrosoft.AspNetCore.Mvc.Infrastructure.IActionDescriptorChangeProvider\nMicrosoft.AspNetCore.Mvc.Infrastructure.IActionDescriptorCollectionProvider\nMicrosoft.AspNetCore.Mvc.Infrastructure.IActionInvokerFactory\nMicrosoft.AspNetCore.Mvc.Infrastructure.IActionResultExecutor<TResult>\nMicrosoft.AspNetCore.Mvc.Infrastructure.IActionResultTypeMapper\nMicrosoft.AspNetCore.Mvc.Infrastructure.IActionSelector\nMicrosoft.AspNetCore.Mvc.Infrastructure.IApiBehaviorMetadata\nMicrosoft.AspNetCore.Mvc.Infrastructure.IClientErrorActionResult\nMicrosoft.AspNetCore.Mvc.Infrastructure.IClientErrorFactory\n```\n\n----------------------------------------\n\nTITLE: IFormFile Interface Definition in C#\nDESCRIPTION: Defines the interface for handling uploaded files in ASP.NET Core forms. Includes properties and methods for accessing file metadata and content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Features/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.IFormFile\nMicrosoft.AspNetCore.Http.IFormFile.ContentDisposition.get -> string!\nMicrosoft.AspNetCore.Http.IFormFile.ContentType.get -> string!\nMicrosoft.AspNetCore.Http.IFormFile.CopyTo(System.IO.Stream! target) -> void\nMicrosoft.AspNetCore.Http.IFormFile.CopyToAsync(System.IO.Stream! target, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.IFormFile.FileName.get -> string!\nMicrosoft.AspNetCore.Http.IFormFile.Headers.get -> Microsoft.AspNetCore.Http.IHeaderDictionary!\nMicrosoft.AspNetCore.Http.IFormFile.Length.get -> long\nMicrosoft.AspNetCore.Http.IFormFile.Name.get -> string!\nMicrosoft.AspNetCore.Http.IFormFile.OpenReadStream() -> System.IO.Stream!\n```\n\n----------------------------------------\n\nTITLE: Configuring WebTransport Preview Features in .NET Project\nDESCRIPTION: XML configuration to enable preview features for WebTransport and H3 Datagrams in the project file.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/WebTransport.md#2025-04-08_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<ItemGroup>\n    <RuntimeHostConfigurationOption Include=\"Microsoft.AspNetCore.Server.Kestrel.Experimental.WebTransportAndH3Datagrams\" Value=\"true\" />\n</ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core MVC Model Binding Implementation\nDESCRIPTION: Method and property overrides for model binding context and value provider implementations\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Mvc.ModelBinding.DefaultModelBindingContext.ActionContext.get -> Microsoft.AspNetCore.Mvc.ActionContext!\noverride Microsoft.AspNetCore.Mvc.ModelBinding.DefaultModelBindingContext.ActionContext.set -> void\noverride Microsoft.AspNetCore.Mvc.ModelBinding.DefaultModelBindingContext.BinderModelName.get -> string?\noverride Microsoft.AspNetCore.Mvc.ModelBinding.DefaultModelBindingContext.BinderModelName.set -> void\n```\n\n----------------------------------------\n\nTITLE: Database Developer Page Exception Filter in ASP.NET Core (C#)\nDESCRIPTION: An exception filter that enhances the developer exception page with database-specific diagnostic information. The filter intercepts database-related exceptions and adds context before they reach the exception page.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics.EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Diagnostics.EntityFrameworkCore.DatabaseDeveloperPageExceptionFilter.DatabaseDeveloperPageExceptionFilter(Microsoft.Extensions.Logging.ILogger<Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore.DatabaseDeveloperPageExceptionFilter!>! logger, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Builder.DatabaseErrorPageOptions!>! options) -> void\nMicrosoft.AspNetCore.Diagnostics.EntityFrameworkCore.DatabaseDeveloperPageExceptionFilter.HandleExceptionAsync(Microsoft.AspNetCore.Diagnostics.ErrorContext! errorContext, System.Func<Microsoft.AspNetCore.Diagnostics.ErrorContext!, System.Threading.Tasks.Task!>! next) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: HttpConnection Class and Constructors in ASP.NET Core (C#)\nDESCRIPTION: Defines the HttpConnection class and its various constructors that allow establishing HTTP connections with different configurations, including URL, transport types, and logger factory options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Http.Connections.Client/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnection\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnection.HttpConnection(Microsoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions! httpConnectionOptions, Microsoft.Extensions.Logging.ILoggerFactory? loggerFactory) -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnection.HttpConnection(System.Uri! url) -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnection.HttpConnection(System.Uri! url, Microsoft.AspNetCore.Http.Connections.HttpTransportType transports) -> void\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnection.HttpConnection(System.Uri! url, Microsoft.AspNetCore.Http.Connections.HttpTransportType transports, Microsoft.Extensions.Logging.ILoggerFactory? loggerFactory) -> void\n```\n\n----------------------------------------\n\nTITLE: Abstract Method for Parsing Input Values in InputBase<TValue> Component\nDESCRIPTION: Abstract method in InputBase<TValue> for parsing string values into the generic type. Returns success status and provides the parsed result or validation error message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Components.Forms.InputBase<TValue>.TryParseValueFromString(string? value, out TValue result, out string? validationErrorMessage) -> bool\n```\n\n----------------------------------------\n\nTITLE: Sending Data over WebTransport Stream in C#\nDESCRIPTION: This code shows how to send data over a WebTransport stream. It writes data to the stream and automatically flushes it to the client.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/WebTransport.md#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nvar stream = connectionContext.Transport.Output;\nawait stream.WriteAsync(ReadOnlyMemory<byte> bytes);\n```\n\n----------------------------------------\n\nTITLE: Adding Server-Side Blazor to Service Collection in ASP.NET Core\nDESCRIPTION: Extension method for IServiceCollection that adds server-side Blazor services to the dependency injection container. Optionally configures CircuitOptions through an action delegate.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.ComponentServiceCollectionExtensions.AddServerSideBlazor(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Components.Server.CircuitOptions!>? configure = null) -> Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining AuthenticationTicket and AuthenticationToken Classes in C#\nDESCRIPTION: Defines the AuthenticationTicket and AuthenticationToken classes for handling authentication tickets and tokens.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Authentication.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.AuthenticationTicket\nMicrosoft.AspNetCore.Authentication.AuthenticationTicket.AuthenticationScheme.get -> string!\nMicrosoft.AspNetCore.Authentication.AuthenticationTicket.AuthenticationTicket(System.Security.Claims.ClaimsPrincipal! principal, Microsoft.AspNetCore.Authentication.AuthenticationProperties? properties, string! authenticationScheme) -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationTicket.AuthenticationTicket(System.Security.Claims.ClaimsPrincipal! principal, string! authenticationScheme) -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationTicket.Clone() -> Microsoft.AspNetCore.Authentication.AuthenticationTicket!\nMicrosoft.AspNetCore.Authentication.AuthenticationTicket.Principal.get -> System.Security.Claims.ClaimsPrincipal!\nMicrosoft.AspNetCore.Authentication.AuthenticationTicket.Properties.get -> Microsoft.AspNetCore.Authentication.AuthenticationProperties!\nMicrosoft.AspNetCore.Authentication.AuthenticationToken\nMicrosoft.AspNetCore.Authentication.AuthenticationToken.AuthenticationToken() -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationToken.Name.get -> string!\nMicrosoft.AspNetCore.Authentication.AuthenticationToken.Name.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationToken.Value.get -> string!\nMicrosoft.AspNetCore.Authentication.AuthenticationToken.Value.set -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing ServerComponentsEndpointOptions Class in C#\nDESCRIPTION: Class for configuring server components endpoint options, including WebSocket acceptance, content security policy, and WebSocket compression settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Server.ServerComponentsEndpointOptions\nMicrosoft.AspNetCore.Components.Server.ServerComponentsEndpointOptions.ConfigureWebSocketAcceptContext.get -> System.Func<Microsoft.AspNetCore.Http.HttpContext!, Microsoft.AspNetCore.Http.WebSocketAcceptContext!, System.Threading.Tasks.Task!>?\nMicrosoft.AspNetCore.Components.Server.ServerComponentsEndpointOptions.ConfigureWebSocketAcceptContext.set -> void\nMicrosoft.AspNetCore.Components.Server.ServerComponentsEndpointOptions.ContentSecurityFrameAncestorsPolicy.get -> string?\nMicrosoft.AspNetCore.Components.Server.ServerComponentsEndpointOptions.ContentSecurityFrameAncestorsPolicy.set -> void\nMicrosoft.AspNetCore.Components.Server.ServerComponentsEndpointOptions.DisableWebSocketCompression.get -> bool\nMicrosoft.AspNetCore.Components.Server.ServerComponentsEndpointOptions.DisableWebSocketCompression.set -> void\nMicrosoft.AspNetCore.Components.Server.ServerComponentsEndpointOptions.ServerComponentsEndpointOptions() -> void\n```\n\n----------------------------------------\n\nTITLE: Sending Data to SignalR Hub Asynchronously in C#\nDESCRIPTION: Implements core functionality for sending data to a SignalR hub method asynchronously, with support for cancellation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.SignalR.Client.HubConnection.SendCoreAsync(string! methodName, object?[]! args, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Endpoint Mapping and Request Delegate Creation in ASP.NET Core\nDESCRIPTION: These static methods handle the mapping of endpoints and creation of request delegates in ASP.NET Core. They provide advanced customization options for metadata population and request delegate creation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.RouteHandlerServices.Map(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder! endpoints, string! pattern, System.Delegate! handler, System.Collections.Generic.IEnumerable<string!>? httpMethods, System.Func<System.Reflection.MethodInfo!, Microsoft.AspNetCore.Http.RequestDelegateFactoryOptions?, Microsoft.AspNetCore.Http.RequestDelegateMetadataResult!>! populateMetadata, System.Func<System.Delegate!, Microsoft.AspNetCore.Http.RequestDelegateFactoryOptions!, Microsoft.AspNetCore.Http.RequestDelegateMetadataResult?, Microsoft.AspNetCore.Http.RequestDelegateResult!>! createRequestDelegate) -> Microsoft.AspNetCore.Builder.RouteHandlerBuilder!\n\nstatic Microsoft.AspNetCore.Routing.RouteHandlerServices.Map(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder! endpoints, string! pattern, System.Delegate! handler, System.Collections.Generic.IEnumerable<string!>? httpMethods, System.Func<System.Reflection.MethodInfo!, Microsoft.AspNetCore.Http.RequestDelegateFactoryOptions?, Microsoft.AspNetCore.Http.RequestDelegateMetadataResult!>! populateMetadata, System.Func<System.Delegate!, Microsoft.AspNetCore.Http.RequestDelegateFactoryOptions!, Microsoft.AspNetCore.Http.RequestDelegateMetadataResult?, Microsoft.AspNetCore.Http.RequestDelegateResult!>! createRequestDelegate, System.Reflection.MethodInfo! methodInfo) -> Microsoft.AspNetCore.Builder.RouteHandlerBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining HttpsRedirectionOptions Class in ASP.NET Core C#\nDESCRIPTION: This class defines the configuration options for the HTTPS redirection middleware in ASP.NET Core. It allows setting the HTTPS port and HTTP status code for redirection responses. By default, it uses port -1 (automatic detection) and status code 307 (Temporary Redirect).\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Session/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Initializing Microsoft Account Authentication Constants\nDESCRIPTION: Defines core constants used for Microsoft Account authentication including the default scheme name \"Microsoft\".\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/MicrosoftAccount/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.Authentication.MicrosoftAccount.MicrosoftAccountDefaults.AuthenticationScheme = \"Microsoft\"\n```\n\n----------------------------------------\n\nTITLE: Logging and Exception Handling in ASP.NET Core Request Processing\nDESCRIPTION: This class provides methods for logging errors or throwing exceptions during request processing. It handles scenarios like invalid JSON, parameter binding failures, and missing required parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsTodo_Has_Metadata.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    // ... (methods for handling various error scenarios)\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving JSON Body in ASP.NET Core Requests\nDESCRIPTION: This method attempts to resolve the JSON body of an HTTP request into a specified type. It handles various error cases, such as invalid content types or JSON parsing errors, and sets appropriate HTTP status codes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_TakesCustomMetadataEmitter_Has_Metadata.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nprivate static async ValueTask<(bool, T?)> TryResolveBodyAsync<T>(HttpContext httpContext, LogOrThrowExceptionHelper logOrThrowExceptionHelper, bool allowEmpty, string parameterTypeName, string parameterName, JsonTypeInfo<T> jsonTypeInfo, bool isInferred = false)\n{\n    var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();\n    T? bodyValue = default;\n    var bodyValueSet = false;\n\n    if (feature?.CanHaveBody == true)\n    {\n        if (!httpContext.Request.HasJsonContentType())\n        {\n            logOrThrowExceptionHelper.UnexpectedJsonContentType(httpContext.Request.ContentType);\n            httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;\n            return (false, default);\n        }\n        try\n        {\n            bodyValue = await httpContext.Request.ReadFromJsonAsync(jsonTypeInfo);\n            bodyValueSet = bodyValue != null;\n        }\n        catch (BadHttpRequestException badHttpRequestException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(badHttpRequestException);\n            httpContext.Response.StatusCode = badHttpRequestException.StatusCode;\n            return (false, default);\n        }\n        catch (IOException ioException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(ioException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n        catch (System.Text.Json.JsonException jsonException)\n        {\n            logOrThrowExceptionHelper.InvalidJsonRequestBody(parameterTypeName, parameterName, jsonException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n    }\n\n    if (!allowEmpty && !bodyValueSet)\n    {\n        if (!isInferred)\n        {\n            logOrThrowExceptionHelper.RequiredParameterNotProvided(parameterTypeName, parameterName, \"body\");\n        }\n        else\n        {\n            logOrThrowExceptionHelper.ImplicitBodyNotProvided(parameterName);\n        }\n        httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n        return (false, bodyValue);\n    }\n\n    return (true, bodyValue);\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Messages with 'SendAsync' Extension Methods in SignalR Client\nDESCRIPTION: Various overloads of the SendAsync extension method for HubConnection that allow sending messages to a SignalR hub. These methods support different numbers of arguments (from 1 to 10) and accept an optional CancellationToken for cancellation support.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.SendAsync(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, object? arg1, object? arg2, object? arg3, object? arg4, object? arg5, object? arg6, object? arg7, object? arg8, object? arg9, object? arg10, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.SendAsync(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, object? arg1, object? arg2, object? arg3, object? arg4, object? arg5, object? arg6, object? arg7, object? arg8, object? arg9, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.SendAsync(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, object? arg1, object? arg2, object? arg3, object? arg4, object? arg5, object? arg6, object? arg7, object? arg8, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.SendAsync(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, object? arg1, object? arg2, object? arg3, object? arg4, object? arg5, object? arg6, object? arg7, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.SendAsync(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, object? arg1, object? arg2, object? arg3, object? arg4, object? arg5, object? arg6, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.SendAsync(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, object? arg1, object? arg2, object? arg3, object? arg4, object? arg5, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.SendAsync(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, object? arg1, object? arg2, object? arg3, object? arg4, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.SendAsync(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, object? arg1, object? arg2, object? arg3, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.SendAsync(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, object? arg1, object? arg2, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.SendAsync(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, object? arg1, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: IPasswordHasher Interface Definition\nDESCRIPTION: Defines the interface for password hashing functionality in ASP.NET Core Identity, including methods for hashing and verifying passwords.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.IPasswordHasher<TUser>\nMicrosoft.AspNetCore.Identity.IPasswordHasher<TUser>.HashPassword(TUser! user, string! password) -> string!\nMicrosoft.AspNetCore.Identity.IPasswordHasher<TUser>.VerifyHashedPassword(TUser! user, string! hashedPassword, string! providedPassword) -> Microsoft.AspNetCore.Identity.PasswordVerificationResult\n```\n\n----------------------------------------\n\nTITLE: Building Endpoint Filter Chain in ASP.NET Core\nDESCRIPTION: Constructs a filter pipeline for endpoints by applying endpoint filters in reverse order to create a chain of responsibility. Filters can modify the request/response or perform cross-cutting concerns.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Authentication Methods in PageModel\nDESCRIPTION: Methods for handling authentication and authorization in Razor Pages including Forbid with various parameter combinations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.Forbid(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties) -> Microsoft.AspNetCore.Mvc.ForbidResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.Forbid(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, params string![]! authenticationSchemes) -> Microsoft.AspNetCore.Mvc.ForbidResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.Forbid(params string![]! authenticationSchemes) -> Microsoft.AspNetCore.Mvc.ForbidResult!\n```\n\n----------------------------------------\n\nTITLE: Defining RequestCultureFeature Class in C#\nDESCRIPTION: Defines the RequestCultureFeature class for implementing the IRequestCultureFeature interface.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Localization.RequestCultureFeature\nMicrosoft.AspNetCore.Localization.RequestCultureFeature.Provider.get -> Microsoft.AspNetCore.Localization.IRequestCultureProvider?\nMicrosoft.AspNetCore.Localization.RequestCultureFeature.RequestCulture.get -> Microsoft.AspNetCore.Localization.RequestCulture!\nMicrosoft.AspNetCore.Localization.RequestCultureFeature.RequestCultureFeature(Microsoft.AspNetCore.Localization.RequestCulture! requestCulture, Microsoft.AspNetCore.Localization.IRequestCultureProvider? provider) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing OWIN Feature Collection in C#\nDESCRIPTION: Defines the OwinFeatureCollection class for managing OWIN features and their associated environment.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Owin/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Owin.OwinFeatureCollection.Environment.get -> System.Collections.Generic.IDictionary<string, object>\nMicrosoft.AspNetCore.Owin.OwinFeatureCollection.Environment.set -> void\nMicrosoft.AspNetCore.Owin.OwinFeatureCollection.Get(System.Type key) -> object\nMicrosoft.AspNetCore.Owin.OwinFeatureCollection.GetEnumerator() -> System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<System.Type, object>>\nMicrosoft.AspNetCore.Owin.OwinFeatureCollection.OwinFeatureCollection(System.Collections.Generic.IDictionary<string, object> environment) -> void\nMicrosoft.AspNetCore.Owin.OwinFeatureCollection.Set(System.Type key, object value) -> void\nMicrosoft.AspNetCore.Owin.OwinFeatureCollection.this[System.Type key].get -> object\nMicrosoft.AspNetCore.Owin.OwinFeatureCollection.this[System.Type key].set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining AspNetRoleManager<TRole> Constructor in C#\nDESCRIPTION: Constructor for AspNetRoleManager<TRole> class, which manages roles in ASP.NET Core Identity. It takes various dependencies including role store, validators, and logging components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.AspNetRoleManager<TRole>.AspNetRoleManager(Microsoft.AspNetCore.Identity.IRoleStore<TRole!>! store, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Identity.IRoleValidator<TRole!>!>! roleValidators, Microsoft.AspNetCore.Identity.ILookupNormalizer! keyNormalizer, Microsoft.AspNetCore.Identity.IdentityErrorDescriber! errors, Microsoft.Extensions.Logging.ILogger<Microsoft.AspNetCore.Identity.RoleManager<TRole!>!>! logger, Microsoft.AspNetCore.Http.IHttpContextAccessor! contextAccessor) -> void\n```\n\n----------------------------------------\n\nTITLE: Attribute Route Configuration\nDESCRIPTION: Defines AttributeRouteInfo class for configuring attribute-based routing in ASP.NET Core MVC, including route templates, naming, and path matching behavior.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic class AttributeRouteInfo\n{\n    public string? Name { get; set; }\n    public int Order { get; set; }\n    public bool SuppressLinkGeneration { get; set; }\n    public bool SuppressPathMatching { get; set; }\n    public string? Template { get; set; }\n    \n    public AttributeRouteInfo();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IDecompressionProvider Interface in C#\nDESCRIPTION: This interface defines a method for getting a decompression stream from an input stream. It's part of the Microsoft.AspNetCore.RequestDecompression namespace.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/RequestDecompression/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.RequestDecompression.IDecompressionProvider.GetDecompressionStream(System.IO.Stream! stream) -> System.IO.Stream!\n```\n\n----------------------------------------\n\nTITLE: Writing JSON Response in ASP.NET Core (C#)\nDESCRIPTION: This method writes a JSON response, handling type information and serialization options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Core Route Mapping Implementation\nDESCRIPTION: Internal implementation of MapCore method that provides the core functionality for mapping routes in ASP.NET Core. Handles route pattern, delegate handler, and HTTP methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: AuthorizationFailure Class Definition in C#\nDESCRIPTION: Definition of the AuthorizationFailure class that represents a failed authorization attempt, containing information about which requirements failed and why.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationFailure\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationFailure.FailCalled.get -> bool\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationFailure.FailedRequirements.get -> System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.IAuthorizationRequirement!>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationFailure.FailureReasons.get -> System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.AuthorizationFailureReason!>!\n```\n\n----------------------------------------\n\nTITLE: Using PushStreamHttpResult in ASP.NET Core\nDESCRIPTION: API signatures for the PushStreamHttpResult class, which represents a result that streams file content to the response and allows for range processing, with properties for managing content metadata.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.PushStreamHttpResult\nMicrosoft.AspNetCore.Http.HttpResults.PushStreamHttpResult.ContentType.get -> string!\nMicrosoft.AspNetCore.Http.HttpResults.PushStreamHttpResult.EnableRangeProcessing.get -> bool\nMicrosoft.AspNetCore.Http.HttpResults.PushStreamHttpResult.EntityTag.get -> Microsoft.Net.Http.Headers.EntityTagHeaderValue?\nMicrosoft.AspNetCore.Http.HttpResults.PushStreamHttpResult.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.PushStreamHttpResult.FileDownloadName.get -> string?\nMicrosoft.AspNetCore.Http.HttpResults.PushStreamHttpResult.FileLength.get -> long?\nMicrosoft.AspNetCore.Http.HttpResults.PushStreamHttpResult.LastModified.get -> System.DateTimeOffset?\n```\n\n----------------------------------------\n\nTITLE: Defining ListenOptions Properties and Methods in C#\nDESCRIPTION: This snippet defines properties and methods for the ListenOptions class, which is used to configure how Kestrel listens for connections. It includes options for endpoints, protocols, and middleware.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Server.Kestrel.Core.ListenOptions\nMicrosoft.AspNetCore.Server.Kestrel.Core.ListenOptions.ApplicationServices.get -> System.IServiceProvider!\nMicrosoft.AspNetCore.Server.Kestrel.Core.ListenOptions.Build() -> Microsoft.AspNetCore.Connections.ConnectionDelegate!\nMicrosoft.AspNetCore.Server.Kestrel.Core.ListenOptions.DisableAltSvcHeader.get -> bool\nMicrosoft.AspNetCore.Server.Kestrel.Core.ListenOptions.DisableAltSvcHeader.set -> void\nMicrosoft.AspNetCore.Server.Kestrel.Core.ListenOptions.EndPoint.get -> System.Net.EndPoint!\nMicrosoft.AspNetCore.Server.Kestrel.Core.ListenOptions.FileHandle.get -> ulong\nMicrosoft.AspNetCore.Server.Kestrel.Core.ListenOptions.IPEndPoint.get -> System.Net.IPEndPoint?\nMicrosoft.AspNetCore.Server.Kestrel.Core.ListenOptions.KestrelServerOptions.get -> Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions!\nMicrosoft.AspNetCore.Server.Kestrel.Core.ListenOptions.PipeName.get -> string?\nMicrosoft.AspNetCore.Server.Kestrel.Core.ListenOptions.Protocols.get -> Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols\nMicrosoft.AspNetCore.Server.Kestrel.Core.ListenOptions.Protocols.set -> void\nMicrosoft.AspNetCore.Server.Kestrel.Core.ListenOptions.SocketPath.get -> string?\nMicrosoft.AspNetCore.Server.Kestrel.Core.ListenOptions.Use(System.Func<Microsoft.AspNetCore.Connections.ConnectionDelegate!, Microsoft.AspNetCore.Connections.ConnectionDelegate!>! middleware) -> Microsoft.AspNetCore.Connections.IConnectionBuilder!\n```\n\n----------------------------------------\n\nTITLE: Empty CloseMessage Instance in SignalR Protocol\nDESCRIPTION: Static readonly field representing an empty CloseMessage in the SignalR protocol.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.SignalR.Protocol.CloseMessage.Empty -> Microsoft.AspNetCore.SignalR.Protocol.CloseMessage!\n```\n\n----------------------------------------\n\nTITLE: Implementing Filtered Request Handler for ASP.NET Core Endpoints\nDESCRIPTION: Defines a request handler function with endpoint filtering support. This handler extracts parameters from the request context, performs validation, and processes the request through the endpoint filter pipeline, handling the result appropriately.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandlerFiltered(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)\n                    var HttpContext_local = httpContext;\n    // Endpoint Parameter: Value (Type = Microsoft.AspNetCore.Http.Generators.Tests.AddsCustomParameterMetadataAsProperty, IsOptional = False, IsParsable = False, IsArray = False, Source = JsonBodyOrService)\n    var Value_resolveJsonBodyOrServiceResult = await Value_JsonBodyOrServiceResolver(httpContext, false);\n    if (!Value_resolveJsonBodyOrServiceResult.Item1)\n    {\n        return;\n    }\n    var Value_local = Value_resolveJsonBodyOrServiceResult.Item2!;\n\n    var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType(HttpContext_local, Value_local);\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n    }\n    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType>(httpContext, args_local));\n    if (result is not null)\n    {\n        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining API Endpoints with Schema References in OpenAPI\nDESCRIPTION: OpenAPI endpoint definitions that use schema references to specify request and response bodies. These endpoints demonstrate how to reference schemas defined in the components section.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/test/Microsoft.AspNetCore.OpenApi.Tests/Integration/snapshots/OpenApi3_1/OpenApiDocumentIntegrationTests.VerifyOpenApiDocument_documentName=schemas-by-ref.verified.txt#2025-04-08_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"/schemas-by-ref/parent\": {\n    \"post\": {\n      \"tags\": [\n        \"Sample\"\n      ],\n      \"requestBody\": {\n        \"content\": {\n          \"application/json\": {\n            \"schema\": {\n              \"$ref\": \"#/components/schemas/ParentObject\"\n            }\n          }\n        },\n        \"required\": true\n      },\n      \"responses\": {\n        \"200\": {\n          \"description\": \"OK\"\n        }\n      }\n    }\n  },\n  \"/schemas-by-ref/child\": {\n    \"post\": {\n      \"tags\": [\n        \"Sample\"\n      ],\n      \"requestBody\": {\n        \"content\": {\n          \"application/json\": {\n            \"schema\": {\n              \"$ref\": \"#/components/schemas/ChildObject\"\n            }\n          }\n        },\n        \"required\": true\n      },\n      \"responses\": {\n        \"200\": {\n          \"description\": \"OK\"\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining KeyDerivationPrf Enum in C# for ASP.NET Core Cryptography\nDESCRIPTION: This snippet defines the KeyDerivationPrf enum with three constants representing different HMAC algorithms used in key derivation functions. The enum is part of the Microsoft.AspNetCore.Cryptography.KeyDerivation namespace.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/Cryptography.KeyDerivation/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Cryptography.KeyDerivation.KeyDerivationPrf.HMACSHA1 = 0 -> Microsoft.AspNetCore.Cryptography.KeyDerivation.KeyDerivationPrf\nMicrosoft.AspNetCore.Cryptography.KeyDerivation.KeyDerivationPrf.HMACSHA256 = 1 -> Microsoft.AspNetCore.Cryptography.KeyDerivation.KeyDerivationPrf\nMicrosoft.AspNetCore.Cryptography.KeyDerivation.KeyDerivationPrf.HMACSHA512 = 2 -> Microsoft.AspNetCore.Cryptography.KeyDerivation.KeyDerivationPrf\n```\n\n----------------------------------------\n\nTITLE: Mapping Routes with Endpoint Builder in ASP.NET Core\nDESCRIPTION: Core implementation for mapping routes to handlers in ASP.NET Core. Takes a route pattern, handler delegate, HTTP methods, and metadata population functions to create a route handler builder.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IdentityRole Class in C#\nDESCRIPTION: Defines the IdentityRole class and its generic version for representing roles in ASP.NET Core Identity. It includes constructors and properties for role management.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Stores/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.IdentityRole\nMicrosoft.AspNetCore.Identity.IdentityRole.IdentityRole() -> void\nMicrosoft.AspNetCore.Identity.IdentityRole.IdentityRole(string! roleName) -> void\nMicrosoft.AspNetCore.Identity.IdentityRole<TKey>\nMicrosoft.AspNetCore.Identity.IdentityRole<TKey>.IdentityRole() -> void\nMicrosoft.AspNetCore.Identity.IdentityRole<TKey>.IdentityRole(string! roleName) -> void\n```\n\n----------------------------------------\n\nTITLE: Extending IConnectionBuilder with UseHub Method in C#\nDESCRIPTION: Extension method for IConnectionBuilder to use a specific hub type in the SignalR connection pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.SignalRConnectionBuilderExtensions.UseHub<THub>(this Microsoft.AspNetCore.Connections.IConnectionBuilder! connectionBuilder) -> Microsoft.AspNetCore.Connections.IConnectionBuilder!\n```\n\n----------------------------------------\n\nTITLE: Implementing Controller Methods in C#\nDESCRIPTION: Defines virtual methods for the Controller class in ASP.NET Core MVC, including methods for creating views and handling action execution.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.Controller.Dispose(bool disposing) -> void\nvirtual Microsoft.AspNetCore.Mvc.Controller.Json(object? data) -> Microsoft.AspNetCore.Mvc.JsonResult!\nvirtual Microsoft.AspNetCore.Mvc.Controller.Json(object? data, object? serializerSettings) -> Microsoft.AspNetCore.Mvc.JsonResult!\nvirtual Microsoft.AspNetCore.Mvc.Controller.OnActionExecuted(Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext! context) -> void\nvirtual Microsoft.AspNetCore.Mvc.Controller.OnActionExecuting(Microsoft.AspNetCore.Mvc.Filters.ActionExecutingContext! context) -> void\nvirtual Microsoft.AspNetCore.Mvc.Controller.OnActionExecutionAsync(Microsoft.AspNetCore.Mvc.Filters.ActionExecutingContext! context, Microsoft.AspNetCore.Mvc.Filters.ActionExecutionDelegate! next) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Mvc.Controller.PartialView() -> Microsoft.AspNetCore.Mvc.PartialViewResult!\nvirtual Microsoft.AspNetCore.Mvc.Controller.PartialView(object? model) -> Microsoft.AspNetCore.Mvc.PartialViewResult!\nvirtual Microsoft.AspNetCore.Mvc.Controller.PartialView(string? viewName) -> Microsoft.AspNetCore.Mvc.PartialViewResult!\nvirtual Microsoft.AspNetCore.Mvc.Controller.PartialView(string? viewName, object? model) -> Microsoft.AspNetCore.Mvc.PartialViewResult!\nvirtual Microsoft.AspNetCore.Mvc.Controller.View() -> Microsoft.AspNetCore.Mvc.ViewResult!\nvirtual Microsoft.AspNetCore.Mvc.Controller.View(object? model) -> Microsoft.AspNetCore.Mvc.ViewResult!\nvirtual Microsoft.AspNetCore.Mvc.Controller.View(string? viewName) -> Microsoft.AspNetCore.Mvc.ViewResult!\nvirtual Microsoft.AspNetCore.Mvc.Controller.View(string? viewName, object? model) -> Microsoft.AspNetCore.Mvc.ViewResult!\n```\n\n----------------------------------------\n\nTITLE: Accessing PhysicalFileHttpResult Properties in ASP.NET Core\nDESCRIPTION: API signatures for the PhysicalFileHttpResult class, which provides properties and methods for returning physical files in HTTP responses, including content metadata like EntityTag, FileDownloadName, and LastModified.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.PhysicalFileHttpResult.EntityTag.get -> Microsoft.Net.Http.Headers.EntityTagHeaderValue?\nMicrosoft.AspNetCore.Http.HttpResults.PhysicalFileHttpResult.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.PhysicalFileHttpResult.FileDownloadName.get -> string?\nMicrosoft.AspNetCore.Http.HttpResults.PhysicalFileHttpResult.FileLength.get -> long?\nMicrosoft.AspNetCore.Http.HttpResults.PhysicalFileHttpResult.FileName.get -> string!\nMicrosoft.AspNetCore.Http.HttpResults.PhysicalFileHttpResult.LastModified.get -> System.DateTimeOffset?\n```\n\n----------------------------------------\n\nTITLE: Implementing MVC Builder Extensions for View Features in C#\nDESCRIPTION: These extension methods provide configuration options for MVC builders in ASP.NET Core. They include methods for adding temp data providers, view components, and configuring view options for both IMvcBuilder and IMvcCoreBuilder.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.MvcViewFeaturesMvcBuilderExtensions.AddCookieTempDataProvider(this Microsoft.Extensions.DependencyInjection.IMvcBuilder builder) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder\nstatic Microsoft.Extensions.DependencyInjection.MvcViewFeaturesMvcBuilderExtensions.AddCookieTempDataProvider(this Microsoft.Extensions.DependencyInjection.IMvcBuilder builder, System.Action<Microsoft.AspNetCore.Mvc.CookieTempDataProviderOptions> setupAction) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder\nstatic Microsoft.Extensions.DependencyInjection.MvcViewFeaturesMvcBuilderExtensions.AddSessionStateTempDataProvider(this Microsoft.Extensions.DependencyInjection.IMvcBuilder builder) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder\nstatic Microsoft.Extensions.DependencyInjection.MvcViewFeaturesMvcBuilderExtensions.AddViewComponentsAsServices(this Microsoft.Extensions.DependencyInjection.IMvcBuilder builder) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder\nstatic Microsoft.Extensions.DependencyInjection.MvcViewFeaturesMvcBuilderExtensions.AddViewOptions(this Microsoft.Extensions.DependencyInjection.IMvcBuilder builder, System.Action<Microsoft.AspNetCore.Mvc.MvcViewOptions> setupAction) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder\nstatic Microsoft.Extensions.DependencyInjection.MvcViewFeaturesMvcCoreBuilderExtensions.AddCookieTempDataProvider(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder builder) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder\nstatic Microsoft.Extensions.DependencyInjection.MvcViewFeaturesMvcCoreBuilderExtensions.AddCookieTempDataProvider(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder builder, System.Action<Microsoft.AspNetCore.Mvc.CookieTempDataProviderOptions> setupAction) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder\nstatic Microsoft.Extensions.DependencyInjection.MvcViewFeaturesMvcCoreBuilderExtensions.AddViews(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder builder) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder\nstatic Microsoft.Extensions.DependencyInjection.MvcViewFeaturesMvcCoreBuilderExtensions.AddViews(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder builder, System.Action<Microsoft.AspNetCore.Mvc.MvcViewOptions> setupAction) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder\nstatic Microsoft.Extensions.DependencyInjection.MvcViewFeaturesMvcCoreBuilderExtensions.ConfigureViews(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder builder, System.Action<Microsoft.AspNetCore.Mvc.MvcViewOptions> setupAction) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder\n```\n\n----------------------------------------\n\nTITLE: Determining Response Compression Eligibility in ASP.NET Core\nDESCRIPTION: A virtual method in the ResponseCompressionProvider class that determines if an HTTP response should be compressed. It takes an HttpContext parameter and returns a boolean value indicating whether compression should be applied.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ResponseCompression/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.ResponseCompression.ResponseCompressionProvider.ShouldCompressResponse(Microsoft.AspNetCore.Http.HttpContext! context) -> bool\n```\n\n----------------------------------------\n\nTITLE: OpenID Connect Handler Override Methods\nDESCRIPTION: Override methods for handling OpenID Connect authentication requests and challenges.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectHandler.CreateEventsAsync() -> System.Threading.Tasks.Task<object!>!\noverride Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectHandler.HandleChallengeAsync(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectHandler.HandleRemoteAuthenticateAsync() -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authentication.HandleRequestResult!>!\noverride Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectHandler.HandleRequestAsync() -> System.Threading.Tasks.Task<bool>!\n```\n\n----------------------------------------\n\nTITLE: Executing and Returning HTTP Response in ASP.NET Core\nDESCRIPTION: Method that handles different return types from endpoint handlers, converting them to appropriate HTTP responses. It can process IResult objects, string values, or serialize objects as JSON responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_MultipleSpecialTypeParam_StringReturn.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Authorizing User with Requirements in ASP.NET Core\nDESCRIPTION: This method performs authorization checks for a user against a set of authorization requirements. It takes a ClaimsPrincipal, an optional resource, and a collection of IAuthorizationRequirement objects as parameters, returning an AuthorizationResult.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authorization.DefaultAuthorizationService.AuthorizeAsync(System.Security.Claims.ClaimsPrincipal! user, object? resource, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.IAuthorizationRequirement!>! requirements) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authorization.AuthorizationResult!>!\n```\n\n----------------------------------------\n\nTITLE: Building Filter Delegate for ASP.NET Core Endpoints\nDESCRIPTION: This method constructs a filter delegate by applying multiple endpoint filters to an initial invocation. It iterates through the filter factories in reverse order, allowing each filter to wrap the previous one.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_TakesCustomMetadataEmitter_Has_Metadata.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Helper Interface Methods in C#\nDESCRIPTION: Interface definitions for HTML helper methods used in ASP.NET Core MVC views for generating HTML content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Rendering.IHtmlHelper.ActionLink(string linkText, string actionName, string controllerName, string protocol, string hostname, string fragment, object routeValues, object htmlAttributes) -> Microsoft.AspNetCore.Html.IHtmlContent\nMicrosoft.AspNetCore.Mvc.Rendering.IHtmlHelper.AntiForgeryToken() -> Microsoft.AspNetCore.Html.IHtmlContent\n```\n\n----------------------------------------\n\nTITLE: Defining NoContent Result Method in C#\nDESCRIPTION: This method creates a NoContent (HTTP 204) result.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.NoContent() -> Microsoft.AspNetCore.Http.HttpResults.NoContent!\n```\n\n----------------------------------------\n\nTITLE: JSON Response Writing in ASP.NET Core\nDESCRIPTION: Handles writing JSON responses with proper type information and polymorphism support. Includes special handling for IResult interfaces and string responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndPut_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HtmlRenderer Class in C#\nDESCRIPTION: Defines the HtmlRenderer class for rendering components to HTML. It includes methods for beginning component rendering and managing the rendering lifecycle.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Web.HtmlRenderer\nMicrosoft.AspNetCore.Components.Web.HtmlRenderer.BeginRenderingComponent(System.Type! componentType) -> Microsoft.AspNetCore.Components.Web.HtmlRendering.HtmlRootComponent\nMicrosoft.AspNetCore.Components.Web.HtmlRenderer.BeginRenderingComponent(System.Type! componentType, Microsoft.AspNetCore.Components.ParameterView parameters) -> Microsoft.AspNetCore.Components.Web.HtmlRendering.HtmlRootComponent\nMicrosoft.AspNetCore.Components.Web.HtmlRenderer.BeginRenderingComponent<TComponent>() -> Microsoft.AspNetCore.Components.Web.HtmlRendering.HtmlRootComponent\nMicrosoft.AspNetCore.Components.Web.HtmlRenderer.BeginRenderingComponent<TComponent>(Microsoft.AspNetCore.Components.ParameterView parameters) -> Microsoft.AspNetCore.Components.Web.HtmlRendering.HtmlRootComponent\nMicrosoft.AspNetCore.Components.Web.HtmlRenderer.Dispatcher.get -> Microsoft.AspNetCore.Components.Dispatcher!\nMicrosoft.AspNetCore.Components.Web.HtmlRenderer.Dispose() -> void\nMicrosoft.AspNetCore.Components.Web.HtmlRenderer.DisposeAsync() -> System.Threading.Tasks.ValueTask\nMicrosoft.AspNetCore.Components.Web.HtmlRenderer.HtmlRenderer(System.IServiceProvider! services, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> void\nMicrosoft.AspNetCore.Components.Web.HtmlRenderer.RenderComponentAsync(System.Type! componentType) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Components.Web.HtmlRendering.HtmlRootComponent>!\n```\n\n----------------------------------------\n\nTITLE: Defining ConnectionOptions Class in C#\nDESCRIPTION: Defines the ConnectionOptions class with a property for DisconnectTimeout.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/Http.Connections/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Connections.ConnectionOptions\nMicrosoft.AspNetCore.Http.Connections.ConnectionOptions.ConnectionOptions() -> void\nMicrosoft.AspNetCore.Http.Connections.ConnectionOptions.DisconnectTimeout.get -> System.TimeSpan?\nMicrosoft.AspNetCore.Http.Connections.ConnectionOptions.DisconnectTimeout.set -> void\n```\n\n----------------------------------------\n\nTITLE: Building Endpoint Filter Delegate Chain\nDESCRIPTION: Implements a method that builds a chain of endpoint filters by applying filter factories in reverse order. This enables middleware-like processing for endpoint handlers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsValidationProblemResult_Has_Metadata.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n        private static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n        {\n            var routeHandlerFilters =  builder.FilterFactories;\n            var context0 = new EndpointFilterFactoryContext\n            {\n                MethodInfo = mi,\n                ApplicationServices = builder.ApplicationServices,\n            };\n            var initialFilteredInvocation = filteredInvocation;\n            for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n            {\n                var filterFactory = routeHandlerFilters[i];\n                filteredInvocation = filterFactory(context0, filteredInvocation);\n            }\n            return filteredInvocation;\n        }\n```\n\n----------------------------------------\n\nTITLE: Handling Parameter Binding Failures in ASP.NET Core\nDESCRIPTION: Handles cases where parameter binding failed by either throwing a BadHttpRequestException or logging the failure. The method takes the parameter type, name, and source value that caused the binding failure.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Request Delegate Result Creation in ASP.NET Core Routing\nDESCRIPTION: Code for creating a RequestDelegateResult by determining the appropriate request handler based on filter presence. It selects either filtered or non-filtered request handler and associates metadata with the endpoint.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nRequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\nvar metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\nreturn new RequestDelegateResult(targetDelegate, metadata);\n};\nvar castHandler = Cast(handler, void (global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue arg0) => throw null!);\nreturn MapCore(\n    endpoints,\n    pattern,\n    handler,\n    GetVerb,\n    populateMetadata,\n    createRequestDelegate,\n    castHandler.Method);\n```\n\n----------------------------------------\n\nTITLE: Executing HTTP Response in C# for ASP.NET Core\nDESCRIPTION: This method handles the execution of HTTP responses based on the result type. It supports IResult, string, and JSON serialization for other object types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitServiceParam_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Async Return in ASP.NET Core\nDESCRIPTION: This method handles the execution of async returns in ASP.NET Core, supporting IResult, string, and JSON responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Authentication Scheme Provider Methods\nDESCRIPTION: Virtual methods for managing authentication schemes including adding, removing, and retrieving schemes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Authentication.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authentication.AuthenticationSchemeProvider.AddScheme(Microsoft.AspNetCore.Authentication.AuthenticationScheme! scheme) -> void\nvirtual Microsoft.AspNetCore.Authentication.AuthenticationSchemeProvider.GetAllSchemesAsync() -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authentication.AuthenticationScheme!>!>!\nvirtual Microsoft.AspNetCore.Authentication.AuthenticationSchemeProvider.RemoveScheme(string! name) -> void\nvirtual Microsoft.AspNetCore.Authentication.AuthenticationSchemeProvider.TryAddScheme(Microsoft.AspNetCore.Authentication.AuthenticationScheme! scheme) -> bool\n```\n\n----------------------------------------\n\nTITLE: NamedPipeEndPoint Method Overrides\nDESCRIPTION: Override implementations for NamedPipeEndPoint methods including Equals, GetHashCode, and ToString.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Connections.NamedPipeEndPoint.Equals(object? obj) -> bool\noverride Microsoft.AspNetCore.Connections.NamedPipeEndPoint.GetHashCode() -> int\noverride Microsoft.AspNetCore.Connections.NamedPipeEndPoint.ToString() -> string!\n```\n\n----------------------------------------\n\nTITLE: PageTitle Component for ASP.NET Core Blazor\nDESCRIPTION: Defines the PageTitle component for setting the document title in Blazor applications. Allows setting the browser's page title through Blazor component rendering.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Web.PageTitle\nMicrosoft.AspNetCore.Components.Web.PageTitle.ChildContent.get -> Microsoft.AspNetCore.Components.RenderFragment?\nMicrosoft.AspNetCore.Components.Web.PageTitle.ChildContent.set -> void\nMicrosoft.AspNetCore.Components.Web.PageTitle.PageTitle() -> void\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Required Parameters in ASP.NET Core\nDESCRIPTION: Manages cases where a required parameter is not provided, either throwing an exception or logging the error. Takes parameter type, name, and source as inputs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndPut_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Authorization Failures in C#\nDESCRIPTION: These static methods are used to create AuthorizationFailure objects, which represent failed authorization attempts. They allow for specifying explicit failures or providing reasons for the failure.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Authorization.AuthorizationFailure.ExplicitFail() -> Microsoft.AspNetCore.Authorization.AuthorizationFailure!\nstatic Microsoft.AspNetCore.Authorization.AuthorizationFailure.Failed(System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.AuthorizationFailureReason!>! reasons) -> Microsoft.AspNetCore.Authorization.AuthorizationFailure!\nstatic Microsoft.AspNetCore.Authorization.AuthorizationFailure.Failed(System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.IAuthorizationRequirement!>! failed) -> Microsoft.AspNetCore.Authorization.AuthorizationFailure!\n```\n\n----------------------------------------\n\nTITLE: Authorization Policy Builder Methods in C#\nDESCRIPTION: Methods for building authorization policies by adding authentication schemes, requirements, and common authorization conditions. These methods are used to configure authorization policies in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.AddAuthenticationSchemes(params string![]! schemes) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.AddRequirements(params Microsoft.AspNetCore.Authorization.IAuthorizationRequirement![]! requirements) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireAssertion(System.Func<Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext!, bool>! handler) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireAssertion(System.Func<Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext!, System.Threading.Tasks.Task<bool>!>! handler) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireAuthenticatedUser() -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireClaim(string! claimType) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireClaim(string! claimType, params string![]! allowedValues) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireClaim(string! claimType, System.Collections.Generic.IEnumerable<string!>! allowedValues) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireRole(params string![]! roles) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireRole(System.Collections.Generic.IEnumerable<string!>! roles) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireUserName(string! userName) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\n----------------------------------------\n\nTITLE: File Stream Response Methods in ASP.NET Core ControllerBase (C#)\nDESCRIPTION: Methods to return file content from streams. These methods support specifying content type, download name, caching parameters, and range processing options for streaming file downloads.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(System.IO.Stream! fileStream, string! contentType) -> Microsoft.AspNetCore.Mvc.FileStreamResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(System.IO.Stream! fileStream, string! contentType, bool enableRangeProcessing) -> Microsoft.AspNetCore.Mvc.FileStreamResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(System.IO.Stream! fileStream, string! contentType, string? fileDownloadName) -> Microsoft.AspNetCore.Mvc.FileStreamResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(System.IO.Stream! fileStream, string! contentType, string? fileDownloadName, bool enableRangeProcessing) -> Microsoft.AspNetCore.Mvc.FileStreamResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(System.IO.Stream! fileStream, string! contentType, string? fileDownloadName, System.DateTimeOffset? lastModified, Microsoft.Net.Http.Headers.EntityTagHeaderValue! entityTag) -> Microsoft.AspNetCore.Mvc.FileStreamResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(System.IO.Stream! fileStream, string! contentType, string? fileDownloadName, System.DateTimeOffset? lastModified, Microsoft.Net.Http.Headers.EntityTagHeaderValue! entityTag, bool enableRangeProcessing) -> Microsoft.AspNetCore.Mvc.FileStreamResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(System.IO.Stream! fileStream, string! contentType, System.DateTimeOffset? lastModified, Microsoft.Net.Http.Headers.EntityTagHeaderValue! entityTag) -> Microsoft.AspNetCore.Mvc.FileStreamResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(System.IO.Stream! fileStream, string! contentType, System.DateTimeOffset? lastModified, Microsoft.Net.Http.Headers.EntityTagHeaderValue! entityTag, bool enableRangeProcessing) -> Microsoft.AspNetCore.Mvc.FileStreamResult!\n```\n\n----------------------------------------\n\nTITLE: Defining MultiplexedConnectionContext Abstract Class in C#\nDESCRIPTION: Provides methods for accepting and connecting multiplexed connections asynchronously, with support for cancellation and feature collections.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Connections.MultiplexedConnectionContext.AcceptAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Connections.ConnectionContext?>\nabstract Microsoft.AspNetCore.Connections.MultiplexedConnectionContext.ConnectAsync(Microsoft.AspNetCore.Http.Features.IFeatureCollection? features = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Connections.ConnectionContext!>\n```\n\n----------------------------------------\n\nTITLE: Socket Transport Factory Method Signatures\nDESCRIPTION: Core method signatures for Socket Transport functionality including binding endpoints and configuring web hosts with socket options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Transport.Sockets/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nValueTask<IConnectionListener> BindAsync(EndPoint endpoint, CancellationToken cancellationToken = default);\nIWebHostBuilder UseSockets(this IWebHostBuilder hostBuilder);\nIWebHostBuilder UseSockets(this IWebHostBuilder hostBuilder, Action<SocketTransportOptions> configureOptions);\n```\n\n----------------------------------------\n\nTITLE: AuthenticationState Constructor and Property\nDESCRIPTION: Defines the constructor and User property for AuthenticationState class that represents the authentication state of a user.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Authorization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Authorization.AuthenticationState.AuthenticationState(System.Security.Claims.ClaimsPrincipal! user) -> void\nMicrosoft.AspNetCore.Components.Authorization.AuthenticationState.User.get -> System.Security.Claims.ClaimsPrincipal!\n```\n\n----------------------------------------\n\nTITLE: Email Management Models in ASP.NET Core Identity UI\nDESCRIPTION: Defines models for email-related operations including EmailModel and ResendEmailConfirmationModel with properties for email management and confirmation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Manage.Internal.EmailModel\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Manage.Internal.EmailModel.Email.get -> string?\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Manage.Internal.EmailModel.IsEmailConfirmed.get -> bool\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Manage.Internal.EmailModel.StatusMessage.get -> string?\n```\n\n----------------------------------------\n\nTITLE: Rendering ASP.NET Core Vehicle Update Form with Validation\nDESCRIPTION: HTML markup for a vehicle update form that includes client-side validation using data-val attributes. The form contains dealer information, validation error messages, and input fields for vehicle data like VIN and manufacturing year with specific validation rules.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/test/Mvc.FunctionalTests/compiler/resources/UpdateDealerVehicle_PopulatesValidationSummary.txt#2025-04-08_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n<div>\n    <span class=\"bold\">TestCarDealer</span>\n    <em>SE</em>\n    <input data-val=\"true\" data-val-required=\"The Id field is required.\" id=\"Dealer_Id\" name=\"Dealer.Id\" type=\"hidden\" value=\"43\" />\n</div>\n<div class=\"validation-summary-errors\"><ul><li>Make is invalid for region.</li>\n</ul></div>\n<form action=\"/dealers/43/update-vehicle?dealer.name=TestCarDealer&amp;dealer.location=SE\" method=\"post\">    <fieldset>\n        <input data-val=\"true\" data-val-length=\"The field Vin must be a string with a maximum length of 8.\" data-val-length-max=\"8\" data-val-required=\"The Vin field is required.\" id=\"Vehicle_Vin\" name=\"Vehicle.Vin\" type=\"text\" value=\"8chars\" />\n        <span class=\"field-validation-valid\" data-valmsg-for=\"Vehicle.Vin\" data-valmsg-replace=\"true\"></span>\n    </fieldset>\n    <fieldset>\n        <input class=\"text-box single-line\" data-val=\"true\" data-val-range=\"The field Year must be between 1980 and 2034.\" data-val-range-max=\"2034\" data-val-range-min=\"1980\" data-val-required=\"The Year field is required.\" id=\"Vehicle_Year\" name=\"Vehicle.Year\" type=\"number\" value=\"2013\" />\n        <span class=\"field-validation-valid\" data-valmsg-for=\"Vehicle.Year\" data-valmsg-replace=\"true\"></span>\n    </fieldset>\n</form>\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in ASP.NET Core\nDESCRIPTION: Implements error handling for cases where form data in a request body couldn't be properly parsed. Takes the parameter type name, parameter name, and the exception that occurred during parsing, then either throws a BadHttpRequestException or logs the error.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Response Writing with Type Checking in C#\nDESCRIPTION: Implements JSON response writing with runtime type checking and polymorphism support. Handles null values and different type scenarios while writing JSON responses using HttpResponse extensions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Response Writing with Type Info in ASP.NET Core\nDESCRIPTION: Writes JSON responses with source-generated serialization when possible. Contains trimming/AOT-friendly code with specific suppression messages to ensure serialization works correctly in constrained environments.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Post_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Validation Context and Options in C#\nDESCRIPTION: These classes define the context and options for validation in ASP.NET Core, including depth tracking and error collection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Validation.ValidateContext\nMicrosoft.AspNetCore.Http.Validation.ValidateContext.CurrentDepth.get -> int\nMicrosoft.AspNetCore.Http.Validation.ValidateContext.CurrentDepth.set -> void\nMicrosoft.AspNetCore.Http.Validation.ValidateContext.CurrentValidationPath.get -> string!\nMicrosoft.AspNetCore.Http.Validation.ValidateContext.CurrentValidationPath.set -> void\nMicrosoft.AspNetCore.Http.Validation.ValidateContext.ValidateContext() -> void\nMicrosoft.AspNetCore.Http.Validation.ValidateContext.ValidationContext.get -> System.ComponentModel.DataAnnotations.ValidationContext?\nMicrosoft.AspNetCore.Http.Validation.ValidateContext.ValidationContext.set -> void\nMicrosoft.AspNetCore.Http.Validation.ValidateContext.ValidationErrors.get -> System.Collections.Generic.Dictionary<string!, string![]!>?\nMicrosoft.AspNetCore.Http.Validation.ValidateContext.ValidationErrors.set -> void\nMicrosoft.AspNetCore.Http.Validation.ValidateContext.ValidationOptions.get -> Microsoft.AspNetCore.Http.Validation.ValidationOptions!\nMicrosoft.AspNetCore.Http.Validation.ValidateContext.ValidationOptions.set -> void\nMicrosoft.AspNetCore.Http.Validation.ValidationOptions\nMicrosoft.AspNetCore.Http.Validation.ValidationOptions.MaxDepth.get -> int\nMicrosoft.AspNetCore.Http.Validation.ValidationOptions.MaxDepth.set -> void\nMicrosoft.AspNetCore.Http.Validation.ValidationOptions.Resolvers.get -> System.Collections.Generic.IList<Microsoft.AspNetCore.Http.Validation.IValidatableInfoResolver!>!\nMicrosoft.AspNetCore.Http.Validation.ValidationOptions.TryGetValidatableParameterInfo(System.Reflection.ParameterInfo! parameterInfo, out Microsoft.AspNetCore.Http.Validation.IValidatableInfo? validatableInfo) -> bool\nMicrosoft.AspNetCore.Http.Validation.ValidationOptions.TryGetValidatableTypeInfo(System.Type! type, out Microsoft.AspNetCore.Http.Validation.IValidatableInfo? validatableTypeInfo) -> bool\nMicrosoft.AspNetCore.Http.Validation.ValidationOptions.ValidationOptions() -> void\n```\n\n----------------------------------------\n\nTITLE: IClientModelValidator Interface\nDESCRIPTION: Interface for implementing client-side validation in ASP.NET Core MVC. Allows adding validation rules that will be rendered to the client.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IClientModelValidator\n{\n    void AddValidation(ClientModelValidationContext context);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Redis Cache in ASP.NET Core Application\nDESCRIPTION: Example of configuring Redis distributed cache in an ASP.NET Core application. It demonstrates setting up the connection string and instance name using the AddStackExchangeRedisCache extension method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = WebApplication.CreateBuilder();\n\nbuilder.Services.AddStackExchangeRedisCache(options =>\n{\n    options.Configuration = builder.Configuration.GetConnectionString(\"MyRedisConStr\");\n    options.InstanceName = \"MyCache\";\n});\n```\n\n----------------------------------------\n\nTITLE: Defining ValidationSummary HTML Helper Extension Methods in C#\nDESCRIPTION: These extension methods provide various overloads for generating validation summary HTML content in ASP.NET Core MVC views. They allow customization of property error exclusion, messages, HTML attributes, and output tags.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperValidationExtensions.ValidationSummary(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper htmlHelper, bool excludePropertyErrors, string message, string tag) -> Microsoft.AspNetCore.Html.IHtmlContent\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperValidationExtensions.ValidationSummary(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper htmlHelper, string message) -> Microsoft.AspNetCore.Html.IHtmlContent\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperValidationExtensions.ValidationSummary(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper htmlHelper, string message, object htmlAttributes) -> Microsoft.AspNetCore.Html.IHtmlContent\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperValidationExtensions.ValidationSummary(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper htmlHelper, string message, object htmlAttributes, string tag) -> Microsoft.AspNetCore.Html.IHtmlContent\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperValidationExtensions.ValidationSummary(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper htmlHelper, string message, string tag) -> Microsoft.AspNetCore.Html.IHtmlContent\n```\n\n----------------------------------------\n\nTITLE: PageContext Properties in Razor Pages\nDESCRIPTION: Virtual properties for the PageContext class in Razor Pages, providing access to action descriptors, value provider factories, view data, and view start factories.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageContext.ActionDescriptor.get -> Microsoft.AspNetCore.Mvc.RazorPages.CompiledPageActionDescriptor!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageContext.ActionDescriptor.set -> void\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageContext.ValueProviderFactories.get -> System.Collections.Generic.IList<Microsoft.AspNetCore.Mvc.ModelBinding.IValueProviderFactory!>!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageContext.ValueProviderFactories.set -> void\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageContext.ViewData.get -> Microsoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageContext.ViewData.set -> void\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageContext.ViewStartFactories.get -> System.Collections.Generic.IList<System.Func<Microsoft.AspNetCore.Mvc.Razor.IRazorPage!>!>!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageContext.ViewStartFactories.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining DefaultAuthorizationPolicyProvider in C#\nDESCRIPTION: Implements the default authorization policy provider for ASP.NET Core. It handles retrieving default and fallback authorization policies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.DefaultAuthorizationPolicyProvider.DefaultAuthorizationPolicyProvider(Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Authorization.AuthorizationOptions!>! options) -> void\nMicrosoft.AspNetCore.Authorization.DefaultAuthorizationPolicyProvider.GetDefaultPolicyAsync() -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authorization.AuthorizationPolicy!>!\nMicrosoft.AspNetCore.Authorization.DefaultAuthorizationPolicyProvider.GetFallbackPolicyAsync() -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authorization.AuthorizationPolicy?>!\n```\n\n----------------------------------------\n\nTITLE: Overriding InputText and InputTextArea Component Methods in C#\nDESCRIPTION: Overrides the BuildRenderTree and TryParseValueFromString methods for InputText and InputTextArea components in ASP.NET Core Forms.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Components.Forms.InputText.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder! builder) -> void\noverride Microsoft.AspNetCore.Components.Forms.InputText.TryParseValueFromString(string? value, out string? result, out string? validationErrorMessage) -> bool\noverride Microsoft.AspNetCore.Components.Forms.InputTextArea.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder! builder) -> void\noverride Microsoft.AspNetCore.Components.Forms.InputTextArea.TryParseValueFromString(string? value, out string? result, out string? validationErrorMessage) -> bool\n```\n\n----------------------------------------\n\nTITLE: Implementing Standard Request Handler in ASP.NET Core\nDESCRIPTION: Implements the standard (non-filtered) request handler that asynchronously binds parameters, validates inputs, sets appropriate content types based on result types, and writes the response.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandler(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var httpContext_local = httpContext;\n    var myBindAsyncParam_local = await global::Microsoft.AspNetCore.Http.Generators.Tests.MyBothBindAsyncStruct.BindAsync(httpContext, parameters[1]);\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n        return;\n    }\n    var result = handler(httpContext_local, myBindAsyncParam_local);\n    if (result is string)\n    {\n        httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n    }\n    else\n    {\n        httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n    }\n    await httpContext.Response.WriteAsync(result);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Methods for RoleStoreBase in C#\nDESCRIPTION: This snippet defines abstract methods for the RoleStoreBase class, which handles role-related operations in ASP.NET Core Identity. It includes methods for CRUD operations on roles, managing claims, and querying roles.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Stores/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Identity.RoleStoreBase<TRole, TKey, TUserRole, TRoleClaim>.AddClaimAsync(TRole! role, System.Security.Claims.Claim! claim, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nabstract Microsoft.AspNetCore.Identity.RoleStoreBase<TRole, TKey, TUserRole, TRoleClaim>.CreateAsync(TRole! role, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\nabstract Microsoft.AspNetCore.Identity.RoleStoreBase<TRole, TKey, TUserRole, TRoleClaim>.DeleteAsync(TRole! role, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\nabstract Microsoft.AspNetCore.Identity.RoleStoreBase<TRole, TKey, TUserRole, TRoleClaim>.FindByIdAsync(string! id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<TRole?>!\nabstract Microsoft.AspNetCore.Identity.RoleStoreBase<TRole, TKey, TUserRole, TRoleClaim>.FindByNameAsync(string! normalizedName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<TRole?>!\nabstract Microsoft.AspNetCore.Identity.RoleStoreBase<TRole, TKey, TUserRole, TRoleClaim>.GetClaimsAsync(TRole! role, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<System.Collections.Generic.IList<System.Security.Claims.Claim!>!>!\nabstract Microsoft.AspNetCore.Identity.RoleStoreBase<TRole, TKey, TUserRole, TRoleClaim>.RemoveClaimAsync(TRole! role, System.Security.Claims.Claim! claim, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nabstract Microsoft.AspNetCore.Identity.RoleStoreBase<TRole, TKey, TUserRole, TRoleClaim>.Roles.get -> System.Linq.IQueryable<TRole!>!\nabstract Microsoft.AspNetCore.Identity.RoleStoreBase<TRole, TKey, TUserRole, TRoleClaim>.UpdateAsync(TRole! role, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\n```\n\n----------------------------------------\n\nTITLE: Implementing BearerTokenOptions Class in C#\nDESCRIPTION: Defines the BearerTokenOptions class which provides configuration options for Bearer Token authentication. It includes properties for token expiration, token protectors, and authentication events.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/BearerToken/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.BearerToken.BearerTokenOptions\nMicrosoft.AspNetCore.Authentication.BearerToken.BearerTokenOptions.BearerTokenExpiration.get -> System.TimeSpan\nMicrosoft.AspNetCore.Authentication.BearerToken.BearerTokenOptions.BearerTokenExpiration.set -> void\nMicrosoft.AspNetCore.Authentication.BearerToken.BearerTokenOptions.BearerTokenOptions() -> void\nMicrosoft.AspNetCore.Authentication.BearerToken.BearerTokenOptions.BearerTokenProtector.get -> Microsoft.AspNetCore.Authentication.ISecureDataFormat<Microsoft.AspNetCore.Authentication.AuthenticationTicket!>!\nMicrosoft.AspNetCore.Authentication.BearerToken.BearerTokenOptions.BearerTokenProtector.set -> void\nMicrosoft.AspNetCore.Authentication.BearerToken.BearerTokenOptions.Events.get -> Microsoft.AspNetCore.Authentication.BearerToken.BearerTokenEvents!\nMicrosoft.AspNetCore.Authentication.BearerToken.BearerTokenOptions.Events.set -> void\nMicrosoft.AspNetCore.Authentication.BearerToken.BearerTokenOptions.RefreshTokenExpiration.get -> System.TimeSpan\nMicrosoft.AspNetCore.Authentication.BearerToken.BearerTokenOptions.RefreshTokenExpiration.set -> void\nMicrosoft.AspNetCore.Authentication.BearerToken.BearerTokenOptions.RefreshTokenProtector.get -> Microsoft.AspNetCore.Authentication.ISecureDataFormat<Microsoft.AspNetCore.Authentication.AuthenticationTicket!>!\nMicrosoft.AspNetCore.Authentication.BearerToken.BearerTokenOptions.RefreshTokenProtector.set -> void\n```\n\n----------------------------------------\n\nTITLE: Authorization Filter Event Data Classes in C#\nDESCRIPTION: Defines event data classes for monitoring authorization filter execution including context, filter metadata and action descriptor information\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Diagnostics.BeforeAuthorizationFilterOnAuthorizationEventData.BeforeAuthorizationFilterOnAuthorizationEventData(Microsoft.AspNetCore.Mvc.Abstractions.ActionDescriptor! actionDescriptor, Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext! authorizationContext, Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata! filter) -> void\n```\n\n----------------------------------------\n\nTITLE: SignalR Hub Filter Interface\nDESCRIPTION: Interface for implementing hub filters to intercept hub method invocations and lifetime events.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IHubFilter\n{\n    ValueTask<object?> InvokeMethodAsync(HubInvocationContext invocationContext, Func<HubInvocationContext, ValueTask<object?>> next);\n    Task OnConnectedAsync(HubLifetimeContext context, Func<HubLifetimeContext, Task> next);\n    Task OnDisconnectedAsync(HubLifetimeContext context, Exception? exception, Func<HubLifetimeContext, Exception?, Task> next);\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Database Developer Page Exception Filter in ASP.NET Core (C#)\nDESCRIPTION: Extension method for registering the Database Developer Page Exception Filter in the dependency injection container. This enables enhanced database error diagnostics in the developer exception page.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics.EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.DatabaseDeveloperPageExceptionFilterServiceExtensions.AddDatabaseDeveloperPageExceptionFilter(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Defining DataProtectionTokenProviderOptions in C#\nDESCRIPTION: Definition of DataProtectionTokenProviderOptions class, which provides configuration options for the DataProtectionTokenProvider. It includes properties for the provider name and token lifespan.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.DataProtectionTokenProviderOptions\nMicrosoft.AspNetCore.Identity.DataProtectionTokenProviderOptions.DataProtectionTokenProviderOptions() -> void\nMicrosoft.AspNetCore.Identity.DataProtectionTokenProviderOptions.Name.get -> string!\nMicrosoft.AspNetCore.Identity.DataProtectionTokenProviderOptions.Name.set -> void\nMicrosoft.AspNetCore.Identity.DataProtectionTokenProviderOptions.TokenLifespan.get -> System.TimeSpan\nMicrosoft.AspNetCore.Identity.DataProtectionTokenProviderOptions.TokenLifespan.set -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Authentication in ASP.NET Core\nDESCRIPTION: This code snippet defines extension methods for the AuthenticationBuilder class to add and configure various HTTP authentication schemes. It includes methods for basic, digest, and NTLM authentication, as well as a generic method for custom HTTP authentication handlers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Formatters.Json/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n\nusing System;\nusing Microsoft.AspNetCore.Authentication;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.DependencyInjection.Extensions;\nusing Microsoft.Extensions.Options;\n\nnamespace Microsoft.AspNetCore.Authentication.HTTP;\n\n/// <summary>\nExtension methods to add HTTP authentication to an application.\n</summary>\npublic static class HttpExtensions\n{\n    /// <summary>\nAdds HTTP authentication to <see cref=\"AuthenticationBuilder\"/> using the default scheme.\nThe default scheme is specified by <see cref=\"HttpDefaults.AuthenticationScheme\"/>.\n    </summary>\n    /// <param name=\"builder\">The <see cref=\"AuthenticationBuilder\"/>.</param>\n    /// <returns>A reference to <paramref name=\"builder\"/> after the operation has completed.</returns>\n    public static AuthenticationBuilder AddHttp(this AuthenticationBuilder builder)\n        => builder.AddHttp(HttpDefaults.AuthenticationScheme);\n\n    /// <summary>\nAdds HTTP authentication to <see cref=\"AuthenticationBuilder\"/> using the specified scheme.\n    </summary>\n    /// <param name=\"builder\">The <see cref=\"AuthenticationBuilder\"/>.</param>\n    /// <param name=\"authenticationScheme\">The authentication scheme.</param>\n    /// <returns>A reference to <paramref name=\"builder\"/> after the operation has completed.</returns>\n    public static AuthenticationBuilder AddHttp(this AuthenticationBuilder builder, string authenticationScheme)\n        => builder.AddHttp(authenticationScheme, configureOptions: null);\n\n    /// <summary>\nAdds HTTP authentication to <see cref=\"AuthenticationBuilder\"/> using the default scheme.\nThe default scheme is specified by <see cref=\"HttpDefaults.AuthenticationScheme\"/>.\n    </summary>\n    /// <param name=\"builder\">The <see cref=\"AuthenticationBuilder\"/>.</param>\n    /// <param name=\"configureOptions\">A delegate to configure <see cref=\"HttpOptions\"/>.</param>\n    /// <returns>A reference to <paramref name=\"builder\"/> after the operation has completed.</returns>\n    public static AuthenticationBuilder AddHttp(this AuthenticationBuilder builder, Action<HttpOptions> configureOptions)\n        => builder.AddHttp(HttpDefaults.AuthenticationScheme, configureOptions);\n\n    /// <summary>\nAdds HTTP authentication to <see cref=\"AuthenticationBuilder\"/> using the specified scheme.\n    </summary>\n    /// <param name=\"builder\">The <see cref=\"AuthenticationBuilder\"/>.</param>\n    /// <param name=\"authenticationScheme\">The authentication scheme.</param>\n    /// <param name=\"configureOptions\">A delegate to configure <see cref=\"HttpOptions\"/>.</param>\n    /// <returns>A reference to <paramref name=\"builder\"/> after the operation has completed.</returns>\n    public static AuthenticationBuilder AddHttp(this AuthenticationBuilder builder, string authenticationScheme, Action<HttpOptions>? configureOptions)\n    {\n        builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton<IPostConfigureOptions<HttpOptions>, HttpPostConfigureOptions>());\n        return builder.AddScheme<HttpOptions, HttpHandler>(authenticationScheme, configureOptions);\n    }\n\n    /// <summary>\nAdds HTTP Basic authentication to <see cref=\"AuthenticationBuilder\"/> using the default scheme.\nThe default scheme is specified by <see cref=\"HttpDefaults.AuthenticationScheme\"/>.\n    </summary>\n    /// <param name=\"builder\">The <see cref=\"AuthenticationBuilder\"/>.</param>\n    /// <returns>A reference to <paramref name=\"builder\"/> after the operation has completed.</returns>\n    public static AuthenticationBuilder AddHttpBasic(this AuthenticationBuilder builder)\n        => builder.AddHttpBasic(HttpDefaults.AuthenticationScheme);\n\n    /// <summary>\nAdds HTTP Basic authentication to <see cref=\"AuthenticationBuilder\"/> using the specified scheme.\n    </summary>\n    /// <param name=\"builder\">The <see cref=\"AuthenticationBuilder\"/>.</param>\n    /// <param name=\"authenticationScheme\">The authentication scheme.</param>\n    /// <returns>A reference to <paramref name=\"builder\"/> after the operation has completed.</returns>\n    public static AuthenticationBuilder AddHttpBasic(this AuthenticationBuilder builder, string authenticationScheme)\n        => builder.AddHttpBasic(authenticationScheme, configureOptions: null);\n\n    /// <summary>\nAdds HTTP Basic authentication to <see cref=\"AuthenticationBuilder\"/> using the default scheme.\nThe default scheme is specified by <see cref=\"HttpDefaults.AuthenticationScheme\"/>.\n    </summary>\n    /// <param name=\"builder\">The <see cref=\"AuthenticationBuilder\"/>.</param>\n    /// <param name=\"configureOptions\">A delegate to configure <see cref=\"HttpOptions\"/>.</param>\n    /// <returns>A reference to <paramref name=\"builder\"/> after the operation has completed.</returns>\n    public static AuthenticationBuilder AddHttpBasic(this AuthenticationBuilder builder, Action<HttpOptions> configureOptions)\n        => builder.AddHttpBasic(HttpDefaults.AuthenticationScheme, configureOptions);\n\n    /// <summary>\nAdds HTTP Basic authentication to <see cref=\"AuthenticationBuilder\"/> using the specified scheme.\n    </summary>\n    /// <param name=\"builder\">The <see cref=\"AuthenticationBuilder\"/>.</param>\n    /// <param name=\"authenticationScheme\">The authentication scheme.</param>\n    /// <param name=\"configureOptions\">A delegate to configure <see cref=\"HttpOptions\"/>.</param>\n    /// <returns>A reference to <paramref name=\"builder\"/> after the operation has completed.</returns>\n    public static AuthenticationBuilder AddHttpBasic(this AuthenticationBuilder builder, string authenticationScheme, Action<HttpOptions>? configureOptions)\n    {\n        builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton<IPostConfigureOptions<HttpOptions>, HttpPostConfigureOptions>());\n        return builder.AddScheme<HttpOptions, HttpBasicHandler>(authenticationScheme, configureOptions);\n    }\n\n    /// <summary>\nAdds HTTP Digest authentication to <see cref=\"AuthenticationBuilder\"/> using the default scheme.\nThe default scheme is specified by <see cref=\"HttpDefaults.AuthenticationScheme\"/>.\n    </summary>\n    /// <param name=\"builder\">The <see cref=\"AuthenticationBuilder\"/>.</param>\n    /// <returns>A reference to <paramref name=\"builder\"/> after the operation has completed.</returns>\n    public static AuthenticationBuilder AddHttpDigest(this AuthenticationBuilder builder)\n        => builder.AddHttpDigest(HttpDefaults.AuthenticationScheme);\n\n    /// <summary>\nAdds HTTP Digest authentication to <see cref=\"AuthenticationBuilder\"/> using the specified scheme.\n    </summary>\n    /// <param name=\"builder\">The <see cref=\"AuthenticationBuilder\"/>.</param>\n    /// <param name=\"authenticationScheme\">The authentication scheme.</param>\n    /// <returns>A reference to <paramref name=\"builder\"/> after the operation has completed.</returns>\n    public static AuthenticationBuilder AddHttpDigest(this AuthenticationBuilder builder, string authenticationScheme)\n        => builder.AddHttpDigest(authenticationScheme, configureOptions: null);\n\n    /// <summary>\nAdds HTTP Digest authentication to <see cref=\"AuthenticationBuilder\"/> using the default scheme.\nThe default scheme is specified by <see cref=\"HttpDefaults.AuthenticationScheme\"/>.\n    </summary>\n    /// <param name=\"builder\">The <see cref=\"AuthenticationBuilder\"/>.</param>\n    /// <param name=\"configureOptions\">A delegate to configure <see cref=\"HttpOptions\"/>.</param>\n    /// <returns>A reference to <paramref name=\"builder\"/> after the operation has completed.</returns>\n    public static AuthenticationBuilder AddHttpDigest(this AuthenticationBuilder builder, Action<HttpOptions> configureOptions)\n        => builder.AddHttpDigest(HttpDefaults.AuthenticationScheme, configureOptions);\n\n    /// <summary>\nAdds HTTP Digest authentication to <see cref=\"AuthenticationBuilder\"/> using the specified scheme.\n    </summary>\n    /// <param name=\"builder\">The <see cref=\"AuthenticationBuilder\"/>.</param>\n    /// <param name=\"authenticationScheme\">The authentication scheme.</param>\n    /// <param name=\"configureOptions\">A delegate to configure <see cref=\"HttpOptions\"/>.</param>\n    /// <returns>A reference to <paramref name=\"builder\"/> after the operation has completed.</returns>\n    public static AuthenticationBuilder AddHttpDigest(this AuthenticationBuilder builder, string authenticationScheme, Action<HttpOptions>? configureOptions)\n    {\n        builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton<IPostConfigureOptions<HttpOptions>, HttpPostConfigureOptions>());\n        return builder.AddScheme<HttpOptions, HttpDigestHandler>(authenticationScheme, configureOptions);\n    }\n\n    /// <summary>\nAdds HTTP NTLM authentication to <see cref=\"AuthenticationBuilder\"/> using the default scheme.\nThe default scheme is specified by <see cref=\"HttpDefaults.AuthenticationScheme\"/>.\n    </summary>\n    /// <param name=\"builder\">The <see cref=\"AuthenticationBuilder\"/>.</param>\n    /// <returns>A reference to <paramref name=\"builder\"/> after the operation has completed.</returns>\n    public static AuthenticationBuilder AddHttpNtlm(this AuthenticationBuilder builder)\n        => builder.AddHttpNtlm(HttpDefaults.AuthenticationScheme);\n\n    /// <summary>\nAdds HTTP NTLM authentication to <see cref=\"AuthenticationBuilder\"/> using the specified scheme.\n    </summary>\n    /// <param name=\"builder\">The <see cref=\"AuthenticationBuilder\"/>.</param>\n    /// <param name=\"authenticationScheme\">The authentication scheme.</param>\n    /// <returns>A reference to <paramref name=\"builder\"/> after the operation has completed.</returns>\n    public static AuthenticationBuilder AddHttpNtlm(this AuthenticationBuilder builder, string authenticationScheme)\n        => builder.AddHttpNtlm(authenticationScheme, configureOptions: null);\n\n    /// <summary>\nAdds HTTP NTLM authentication to <see cref=\"AuthenticationBuilder\"/> using the default scheme.\nThe default scheme is specified by <see cref=\"HttpDefaults.AuthenticationScheme\"/>.\n    </summary>\n    /// <param name=\"builder\">The <see cref=\"AuthenticationBuilder\"/>.</param>\n    /// <param name=\"configureOptions\">A delegate to configure <see cref=\"HttpOptions\"/>.</param>\n    /// <returns>A reference to <paramref name=\"builder\"/> after the operation has completed.</returns>\n    public static AuthenticationBuilder AddHttpNtlm(this AuthenticationBuilder builder, Action<HttpOptions> configureOptions)\n        => builder.AddHttpNtlm(HttpDefaults.AuthenticationScheme, configureOptions);\n\n    /// <summary>\nAdds HTTP NTLM authentication to <see cref=\"AuthenticationBuilder\"/> using the specified scheme.\n    </summary>\n    /// <param name=\"builder\">The <see cref=\"AuthenticationBuilder\"/>.</param>\n    /// <param name=\"authenticationScheme\">The authentication scheme.</param>\n    /// <param name=\"configureOptions\">A delegate to configure <see cref=\"HttpOptions\"/>.</param>\n    /// <returns>A reference to <paramref name=\"builder\"/> after the operation has completed.</returns>\n    public static AuthenticationBuilder AddHttpNtlm(this AuthenticationBuilder builder, string authenticationScheme, Action<HttpOptions>? configureOptions)\n    {\n        builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton<IPostConfigureOptions<HttpOptions>, HttpPostConfigureOptions>());\n        return builder.AddScheme<HttpOptions, HttpNtlmHandler>(authenticationScheme, configureOptions);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ControllerModel Class Definition in ASP.NET Core MVC\nDESCRIPTION: A model class that represents an MVC controller. Contains properties for controller name, actions, selectors, filters, API explorer settings, and more.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel.Actions.get -> System.Collections.Generic.IList<Microsoft.AspNetCore.Mvc.ApplicationModels.ActionModel!>!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel.ApiExplorer.get -> Microsoft.AspNetCore.Mvc.ApplicationModels.ApiExplorerModel!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel.ApiExplorer.set -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel.Application.get -> Microsoft.AspNetCore.Mvc.ApplicationModels.ApplicationModel?\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel.Application.set -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel.Attributes.get -> System.Collections.Generic.IReadOnlyList<object!>!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel.ControllerModel(Microsoft.AspNetCore.Mvc.ApplicationModels.ControllerModel! other) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel.ControllerModel(System.Reflection.TypeInfo! controllerType, System.Collections.Generic.IReadOnlyList<object!>! attributes) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel.ControllerName.get -> string!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel.ControllerName.set -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel.ControllerProperties.get -> System.Collections.Generic.IList<Microsoft.AspNetCore.Mvc.ApplicationModels.PropertyModel!>!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel.ControllerType.get -> System.Reflection.TypeInfo!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel.DisplayName.get -> string!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel.Filters.get -> System.Collections.Generic.IList<Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata!>!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel.Properties.get -> System.Collections.Generic.IDictionary<object!, object?>!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel.RouteValues.get -> System.Collections.Generic.IDictionary<string!, string?>!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ControllerModel.Selectors.get -> System.Collections.Generic.IList<Microsoft.AspNetCore.Mvc.ApplicationModels.SelectorModel!>!\n```\n\n----------------------------------------\n\nTITLE: Implementing HTML Generator Extensions in C#\nDESCRIPTION: These extension methods for IHtmlGenerator provide functionality to generate form-related HTML in ASP.NET Core MVC. They include methods for generating forms with various routing and attribute options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Mvc.ViewFeatures.DefaultHtmlGeneratorExtensions.GenerateForm(this Microsoft.AspNetCore.Mvc.ViewFeatures.IHtmlGenerator generator, Microsoft.AspNetCore.Mvc.Rendering.ViewContext viewContext, string actionName, string controllerName, string fragment, object routeValues, string method, object htmlAttributes) -> Microsoft.AspNetCore.Mvc.Rendering.TagBuilder\nstatic Microsoft.AspNetCore.Mvc.ViewFeatures.DefaultHtmlGeneratorExtensions.GenerateRouteForm(this Microsoft.AspNetCore.Mvc.ViewFeatures.IHtmlGenerator generator, Microsoft.AspNetCore.Mvc.Rendering.ViewContext viewContext, string routeName, object routeValues, string fragment, string method, object htmlAttributes) -> Microsoft.AspNetCore.Mvc.Rendering.TagBuilder\n```\n\n----------------------------------------\n\nTITLE: Handling HTTP GET Request with Filtered Invocation in ASP.NET Core\nDESCRIPTION: This snippet demonstrates the creation of a request delegate for handling HTTP GET requests. It includes parameter binding, error handling, and support for endpoint filtering. The method uses generics and async/await patterns for efficient request processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandlerFiltered(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var httpContext_local = httpContext;\n    var myBindAsyncParam_local = await global::Microsoft.AspNetCore.Http.Generators.Tests.MySimpleBindAsyncRecord.BindAsync(httpContext);\n    if (myBindAsyncParam_local == null)\n    {\n        logOrThrowExceptionHelper.RequiredParameterNotProvided(\"MySimpleBindAsyncRecord\", \"myBindAsyncParam\", \"MySimpleBindAsyncRecord.BindAsync(HttpContext)\");\n        wasParamCheckFailure = true;\n        myBindAsyncParam_local = default!;\n    }\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n    }\n    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.HttpContext, global::Microsoft.AspNetCore.Http.Generators.Tests.MySimpleBindAsyncRecord?>(httpContext, httpContext_local, myBindAsyncParam_local));\n    if (result is not null)\n    {\n        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying SignalR Source Generator Diagnostic Codes in Markdown\nDESCRIPTION: A markdown table listing SignalR Source Generator-specific diagnostic codes (SSG0000-SSG0110) with their corresponding descriptions. These codes cover various issues related to HubServerProxy and HubClientProxy methods and their configurations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/list-of-diagnostics.md#2025-04-08_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n### SignalR Source Generator (`SSG0000-SSG0110`)\n\n| Diagnostic ID     | Description |\n| :---------------- | :---------- |\n|  __`SSG0000`__ | Non-interface generic type argument |\n|  __`SSG0001`__ | Unsupported return type |\n|  __`SSG0002`__ | Too many HubServerProxy attributed methods |\n|  __`SSG0003`__ | HubServerProxy attributed method has bad accessibility |\n|  __`SSG0004`__ | HubServerProxy attributed method is not partial |\n|  __`SSG0005`__ | HubServerProxy attributed method is not an extension method |\n|  __`SSG0006`__ | HubServerProxy attributed method has bad number of type arguments |\n|  __`SSG0007`__ | HubServerProxy attributed method type argument and return type does not match |\n|  __`SSG0008`__ | HubServerProxy attributed method has bad number of arguments |\n|  __`SSG0009`__ | HubServerProxy attributed method has argument of wrong type |\n|  __`SSG0100`__ | Unsupported return type |\n|  __`SSG0102`__ | Too many HubClientProxy attributed methods |\n|  __`SSG0103`__ | HubClientProxy attributed method has bad accessibility |\n|  __`SSG0104`__ | HubClientProxy attributed method is not partial |\n|  __`SSG0105`__ | HubClientProxy attributed method is not an extension method |\n|  __`SSG0106`__ | HubClientProxy attributed method has bad number of type arguments |\n|  __`SSG0107`__ | HubClientProxy attributed method type argument and return type does not match |\n|  __`SSG0108`__ | HubClientProxy attributed method has bad number of arguments |\n|  __`SSG0109`__ | HubClientProxy attributed method has first argument of wrong type |\n|  __`SSG0110`__ | HubClientProxy attributed method has wrong return type |\n```\n\n----------------------------------------\n\nTITLE: Installing SignalR Client Package\nDESCRIPTION: Commands for installing the SignalR client package using npm or yarn package managers. Includes options for both stable and preview versions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/ts/signalr/README.md#2025-04-08_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @microsoft/signalr\n# or\nyarn add @microsoft/signalr\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @microsoft/signalr@next\n# or\nyarn add @microsoft/signalr@next\n```\n\n----------------------------------------\n\nTITLE: Server-Initiated WebTransport Stream Example in C#\nDESCRIPTION: This example demonstrates opening a new stream from the server side and sending data. It includes WebTransport session setup and stream creation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/WebTransport.md#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.WebHost.ConfigureKestrel((context, options) =>\n{\n    // Port configured for WebTransport\n    options.Listen(IPAddress.Any, 5007, listenOptions =>\n    {\n        listenOptions.UseHttps(GenerateManualCertificate());\n        listenOptions.UseConnectionLogging();\n        listenOptions.Protocols = HttpProtocols.Http1AndHttp2AndHttp3;\n    });\n});\nvar host = builder.Build();\n\nhost.Run(async (context) =>\n{\n    var feature = context.Features.GetRequiredFeature<IHttpWebTransportFeature>();\n    if (!feature.IsWebTransportRequest)\n    {\n        return;\n    }\n    var session = await feature.AcceptAsync(CancellationToken.None);\n    // open a new stream from the server to the client\n    var stream = await session.OpenUnidirectionalStreamAsync(CancellationToken.None);\n\n    // write data to the stream\n    var outputPipe = stream.Transport.Output;\n    await outputPipe.WriteAsync(new Memory<byte>(new byte[] { 65, 66, 67, 68, 69 }), CancellationToken.None);\n    await outputPipe.FlushAsync(CancellationToken.None);\n});\n\nawait host.RunAsync();\n```\n\n----------------------------------------\n\nTITLE: Decoding Completion Message with Error in MessagePack\nDESCRIPTION: Illustrates the decoding of a Completion message with an error result in the SignalR MessagePack protocol. It includes message type, headers, invocation ID, result kind, and error message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_8\n\nLANGUAGE: MessagePack\nCODE:\n```\n0x95 0x03 0x80 0xa3 0x78 0x79 0x7a 0x01 0xa5 0x45 0x72 0x72 0x6f 0x72\n```\n\n----------------------------------------\n\nTITLE: Normalize.css License Notice\nDESCRIPTION: This snippet shows the beginning of the license notice for Normalize.css, which is used in the ASP.NET Core project. It indicates that Normalize.css is licensed under the MIT License.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/THIRD-PARTY-NOTICES.txt#2025-04-08_snippet_2\n\nLANGUAGE: Plaintext\nCODE:\n```\n\"# The MIT License (MIT)\n\nCopyright (c)Nicolas Gallagher and Jonathan Neal\n\n\n```\n\n----------------------------------------\n\nTITLE: Resolving Request Body in ASP.NET Core\nDESCRIPTION: Attempts to resolve the request body asynchronously. It handles JSON content type validation, deserialization, and various error conditions. Supports optional parameters and inferred body types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nprivate static async ValueTask<(bool, T?)> TryResolveBodyAsync<T>(HttpContext httpContext, LogOrThrowExceptionHelper logOrThrowExceptionHelper, bool allowEmpty, string parameterTypeName, string parameterName, JsonTypeInfo<T> jsonTypeInfo, bool isInferred = false)\n{\n    var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();\n    T? bodyValue = default;\n    var bodyValueSet = false;\n\n    if (feature?.CanHaveBody == true)\n    {\n        if (!httpContext.Request.HasJsonContentType())\n        {\n            logOrThrowExceptionHelper.UnexpectedJsonContentType(httpContext.Request.ContentType);\n            httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;\n            return (false, default);\n        }\n        try\n        {\n            bodyValue = await httpContext.Request.ReadFromJsonAsync(jsonTypeInfo);\n            bodyValueSet = bodyValue != null;\n        }\n        catch (BadHttpRequestException badHttpRequestException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(badHttpRequestException);\n            httpContext.Response.StatusCode = badHttpRequestException.StatusCode;\n            return (false, default);\n        }\n        catch (IOException ioException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(ioException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n        catch (System.Text.Json.JsonException jsonException)\n        {\n            logOrThrowExceptionHelper.InvalidJsonRequestBody(parameterTypeName, parameterName, jsonException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n    }\n\n    if (!allowEmpty && !bodyValueSet)\n    {\n        if (!isInferred)\n        {\n            logOrThrowExceptionHelper.RequiredParameterNotProvided(parameterTypeName, parameterName, \"body\");\n        }\n        else\n        {\n            logOrThrowExceptionHelper.ImplicitBodyNotProvided(parameterName);\n        }\n        httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n        return (false, bodyValue);\n    }\n\n    return (true, bodyValue);\n}\n```\n\n----------------------------------------\n\nTITLE: Error Logging and Exception Handling Helper\nDESCRIPTION: Comprehensive helper class for logging binding errors and optionally throwing exceptions based on configuration. Provides consistent error messages for various parameter binding failures.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n\n    public void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n\n    public void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n\n    public void ImplicitBodyNotProvided(string parameterName)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n}\n```\n\n----------------------------------------\n\nTITLE: Facebook Authentication Handler Constructor\nDESCRIPTION: Constructor for FacebookHandler that initializes authentication handling with required dependencies for options monitoring, logging, URL encoding and system clock.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Facebook/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.Facebook.FacebookHandler.FacebookHandler(Microsoft.Extensions.Options.IOptionsMonitor<Microsoft.AspNetCore.Authentication.Facebook.FacebookOptions!>! options, Microsoft.Extensions.Logging.ILoggerFactory! logger, System.Text.Encodings.Web.UrlEncoder! encoder, Microsoft.AspNetCore.Authentication.ISystemClock! clock) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing HttpFieldValueCollectionParser in C#\nDESCRIPTION: This static class provides methods for parsing HTTP field value collections from form data and query strings. It handles URL encoding, special characters, and supports multiple values for the same parameter name.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Azure/AzureAppServicesIntegration/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Writing JSON Response Asynchronously in ASP.NET Core\nDESCRIPTION: Writes a JSON response using the appropriate JsonTypeInfo, handling potential polymorphism.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Parameter Binding Failures in ASP.NET Core (C#)\nDESCRIPTION: Handles cases where parameter binding fails during request processing. The method either throws a BadHttpRequestException or logs the failure based on configuration, providing detailed information about the parameter type, name, and source value that failed to bind.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Get_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Benchmark from Single Swagger File in C#\nDESCRIPTION: This command uses the Swaggatherer CLI tool to generate a benchmark from a single Swagger JSON file. It specifies the input file and the output file for the generated benchmark.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/tools/Swaggatherer/README.md#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ndotnet run -- -i swagger.json -o MyGeneratedBenchark.generated.cs\n```\n\n----------------------------------------\n\nTITLE: Implementing EmbeddedFileProvider Class in C#\nDESCRIPTION: This snippet defines the EmbeddedFileProvider class, which provides access to embedded resources. It includes constructors and methods for getting directory contents, file information, and watching for changes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/FileProviders/Embedded/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.FileProviders.EmbeddedFileProvider\nMicrosoft.Extensions.FileProviders.EmbeddedFileProvider.EmbeddedFileProvider(System.Reflection.Assembly! assembly) -> void\nMicrosoft.Extensions.FileProviders.EmbeddedFileProvider.EmbeddedFileProvider(System.Reflection.Assembly! assembly, string? baseNamespace) -> void\nMicrosoft.Extensions.FileProviders.EmbeddedFileProvider.GetDirectoryContents(string! subpath) -> Microsoft.Extensions.FileProviders.IDirectoryContents!\nMicrosoft.Extensions.FileProviders.EmbeddedFileProvider.GetFileInfo(string! subpath) -> Microsoft.Extensions.FileProviders.IFileInfo!\nMicrosoft.Extensions.FileProviders.EmbeddedFileProvider.Watch(string! pattern) -> Microsoft.Extensions.Primitives.IChangeToken!\n```\n\n----------------------------------------\n\nTITLE: Reading JSON from HTTP Request in ASP.NET Core\nDESCRIPTION: Extension methods for deserializing JSON data from HTTP requests with various overloads supporting different type configurations and serialization options\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.HttpRequestJsonExtensions.ReadFromJsonAsync<TValue>(this Microsoft.AspNetCore.Http.HttpRequest! request, System.Text.Json.JsonSerializerOptions? options, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<TValue?>\n```\n\n----------------------------------------\n\nTITLE: Defining RequestLocalizationOptionsExtensions Methods in C#\nDESCRIPTION: Defines extension methods for RequestLocalizationOptions to add initial request culture providers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.RequestLocalizationOptionsExtensions.AddInitialRequestCultureProvider(this Microsoft.AspNetCore.Builder.RequestLocalizationOptions! requestLocalizationOptions, Microsoft.AspNetCore.Localization.RequestCultureProvider! requestCultureProvider) -> Microsoft.AspNetCore.Builder.RequestLocalizationOptions!\n```\n\n----------------------------------------\n\nTITLE: Configuring OpenID Connect Authentication in ASP.NET Core\nDESCRIPTION: This code snippet demonstrates how to configure OpenID Connect authentication services in an ASP.NET Core application. It sets up default authentication schemes and configures the OpenIdConnect options with necessary parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Services\n    .AddAuthentication(options =>\n    {\n        options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n        options.DefaultChallengeScheme = OpenIdConnectDefaults.AuthenticationScheme;\n    })\n    .AddCookie()\n    .AddOpenIdConnect(options =>\n    {\n        // Configure the authentication options\n        options.SignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n        options.Authority = \"your-identity-provider\";\n        options.ClientId = \"your-client-id\";\n        options.ClientSecret = \"your-client-secret-from-user-secrets-or-keyvault\";\n        options.ResponseType = \"code\";\n        options.Scope.Add(\"profile\");\n        options.SaveTokens = true;\n    });\n```\n\n----------------------------------------\n\nTITLE: HTTP Server API Type Definitions\nDESCRIPTION: Lists required Windows HTTP Server API types and functions for code generation. Includes HTTP request/response structures, authentication flags, and server management functions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/HttpSys/src/NativeMethods.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// https://github.com/microsoft/cswin32\n// Listing specific types reduces the size of the final dll.\n// Uncomment the next line to import all definitions during development.\n// Windows.Win32.Networking.HttpServer\nCloseHandle\nFILE_SKIP_COMPLETION_PORT_ON_SUCCESS\nFILE_SKIP_SET_EVENT_ON_HANDLE\nHTTP_AUTH_EX_FLAG_*\nHTTP_AUTH_STATUS\nHTTP_BINDING_INFO\nHTTP_CACHE_POLICY\nHTTP_CONNECTION_LIMIT_INFO\nHTTP_COOKED_URL\nHTTP_CREATE_REQUEST_QUEUE_FLAG_*\nHTTP_DATA_CHUNK\nHTTP_FEATURE_ID\nHTTP_HEADER_ID\nHTTP_KNOWN_HEADER\nHTTP_MULTIPLE_KNOWN_HEADERS\nHTTP_PROPERTY_FLAGS\nHTTP_QOS_SETTING_INFO\nHTTP_REQUEST_AUTH_INFO\nHTTP_REQUEST_AUTH_TYPE\nHTTP_REQUEST_FLAG_*\nHTTP_REQUEST_PROPERTY\nHTTP_REQUEST_PROPERTY_SNI\nHTTP_REQUEST_PROPERTY_SNI_HOST_MAX_LENGTH\nHTTP_REQUEST_PROPERTY_STREAM_ERROR\nHTTP_REQUEST_V1\nHTTP_REQUEST_V2\nHTTP_RESPONSE_INFO\nHTTP_RESPONSE_INFO_FLAGS_PRESERVE_ORDER\nHTTP_RESPONSE_INFO_TYPE\nHTTP_RESPONSE_V2\nHTTP_SEND_RESPONSE_FLAG_*\nHTTP_SERVER_AUTHENTICATION_INFO\nHTTP_SERVER_PROPERTY\nHTTP_SSL_PROTOCOL_INFO\nHTTP_TIMEOUT_LIMIT_INFO\nHttpAddUrlToUrlGroup\nHTTPAPI_VERSION\nHttpCancelHttpRequest\nHttpCloseServerSession\nHttpCloseUrlGroup\nHttpCreateRequestQueue\nHttpCreateServerSession\nHttpCreateUrlGroup\nHttpDelegateRequestEx\nHttpFindUrlGroupId\nHttpInitialize\nHttpIsFeatureSupported\nHttpReceiveRequestEntityBody\nHttpRemoveUrlFromUrlGroup\nHttpSendHttpResponse\nHttpSendResponseEntityBody\nHttpSetRequestQueueProperty\nHttpSetUrlGroupProperty\nHttpSetUrlGroupProperty\nSetFileCompletionNotificationModes\nSOCKADDR_IN\nSOCKADDR_IN6\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Body Missing Logger in ASP.NET Core (C#)\nDESCRIPTION: Defines a structured logging action for missing implicit body scenarios. Creates a reusable logging delegate with specific event ID and message template for consistent logging when an implicit body is expected but not provided.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Get_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n```\n\n----------------------------------------\n\nTITLE: Defining Required Parameter Logger in ASP.NET Core\nDESCRIPTION: Defines a structured logger for tracking when required parameters are not provided. Creates a reusable logging delegate that formats a consistent message with parameter type, name, and source at Debug level with EventId 4.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndGet_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n    LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n```\n\n----------------------------------------\n\nTITLE: Installing Crank Controller Tool for ASP.NET Core Benchmarking\nDESCRIPTION: Command to install the Microsoft.Crank.Controller dotnet tool globally, which is required to start benchmarks remotely on the performance infrastructure.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Benchmarks.md#2025-04-08_snippet_0\n\nLANGUAGE: console\nCODE:\n```\ndotnet tool install Microsoft.Crank.Controller --version \"0.2.0-*\" --global\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Class in ASP.NET Core\nDESCRIPTION: Defines a class that holds metadata for parameter binding in ASP.NET Core. It includes information such as parameter name, type, and various flags indicating binding capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WsFederationHandler for Authentication in C#\nDESCRIPTION: This class is the main handler for WS-Federation authentication. It manages the authentication process and interacts with the WS-Federation identity provider.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/WsFederation/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationHandler\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationHandler.Events.get -> Microsoft.AspNetCore.Authentication.WsFederation.WsFederationEvents!\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationHandler.Events.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationHandler.WsFederationHandler(Microsoft.Extensions.Options.IOptionsMonitor<Microsoft.AspNetCore.Authentication.WsFederation.WsFederationOptions!>! options, Microsoft.Extensions.Logging.ILoggerFactory! logger, System.Text.Encodings.Web.UrlEncoder! encoder) -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationHandler.WsFederationHandler(Microsoft.Extensions.Options.IOptionsMonitor<Microsoft.AspNetCore.Authentication.WsFederation.WsFederationOptions!>! options, Microsoft.Extensions.Logging.ILoggerFactory! logger, System.Text.Encodings.Web.UrlEncoder! encoder, Microsoft.AspNetCore.Authentication.ISystemClock! clock) -> void\n```\n\n----------------------------------------\n\nTITLE: HTTP Header Utility Functions in C#\nDESCRIPTION: A collection of utility methods for working with HTTP headers. Includes functions for escaping and unescaping quoted strings, formatting dates, parsing integers, and checking for cache directives.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Headers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Net.Http.Headers.HeaderUtilities.ContainsCacheDirective(Microsoft.Extensions.Primitives.StringValues cacheControlDirectives, string! targetDirectives) -> bool\nstatic Microsoft.Net.Http.Headers.HeaderUtilities.EscapeAsQuotedString(Microsoft.Extensions.Primitives.StringSegment input) -> Microsoft.Extensions.Primitives.StringSegment\nstatic Microsoft.Net.Http.Headers.HeaderUtilities.FormatDate(System.DateTimeOffset dateTime) -> string!\nstatic Microsoft.Net.Http.Headers.HeaderUtilities.FormatDate(System.DateTimeOffset dateTime, bool quoted) -> string!\nstatic Microsoft.Net.Http.Headers.HeaderUtilities.FormatNonNegativeInt64(long value) -> string!\nstatic Microsoft.Net.Http.Headers.HeaderUtilities.IsQuoted(Microsoft.Extensions.Primitives.StringSegment input) -> bool\nstatic Microsoft.Net.Http.Headers.HeaderUtilities.RemoveQuotes(Microsoft.Extensions.Primitives.StringSegment input) -> Microsoft.Extensions.Primitives.StringSegment\nstatic Microsoft.Net.Http.Headers.HeaderUtilities.TryParseDate(Microsoft.Extensions.Primitives.StringSegment input, out System.DateTimeOffset result) -> bool\nstatic Microsoft.Net.Http.Headers.HeaderUtilities.TryParseNonNegativeInt32(Microsoft.Extensions.Primitives.StringSegment value, out int result) -> bool\nstatic Microsoft.Net.Http.Headers.HeaderUtilities.TryParseNonNegativeInt64(Microsoft.Extensions.Primitives.StringSegment value, out long result) -> bool\nstatic Microsoft.Net.Http.Headers.HeaderUtilities.TryParseSeconds(Microsoft.Extensions.Primitives.StringValues headerValues, string! targetValue, out System.TimeSpan? value) -> bool\nstatic Microsoft.Net.Http.Headers.HeaderUtilities.UnescapeAsQuotedString(Microsoft.Extensions.Primitives.StringSegment input) -> Microsoft.Extensions.Primitives.StringSegment\n```\n\n----------------------------------------\n\nTITLE: Overriding ToString Methods for CORS Classes in C#\nDESCRIPTION: Overrides the ToString method for various CORS-related classes to provide custom string representations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Cors.DisableCorsAttribute.ToString() -> string!\noverride Microsoft.AspNetCore.Cors.EnableCorsAttribute.ToString() -> string!\noverride Microsoft.AspNetCore.Cors.Infrastructure.CorsPolicy.ToString() -> string!\noverride Microsoft.AspNetCore.Cors.Infrastructure.CorsResult.ToString() -> string!\n```\n\n----------------------------------------\n\nTITLE: Account Management Methods\nDESCRIPTION: Virtual methods for handling account-related operations like email confirmation, password reset, and registration in ASP.NET Core Identity UI V4.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Identity.UI.V4.Pages.Account.Internal.ConfirmEmailChangeModel.OnGetAsync(string! userId, string! email, string! code) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult!>!\nvirtual Microsoft.AspNetCore.Identity.UI.V4.Pages.Account.Internal.ConfirmEmailModel.OnGetAsync(string! userId, string! code) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult!>!\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Extension Method for ASP.NET Core Route Builder\nDESCRIPTION: Defines a MapGet extension method for IEndpointRouteBuilder that generates route handlers with metadata population and request processing for HTTP GET endpoints. This method handles parameter binding, JSON serialization, and endpoint filtering.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n        %INTERCEPTSLOCATIONATTRIBUTE%\n        internal static RouteHandlerBuilder MapGet0(\n            this IEndpointRouteBuilder endpoints,\n            [StringSyntax(\"Route\")] string pattern,\n            Delegate handler)\n        {\n            MetadataPopulator populateMetadata = (methodInfo, options) =>\n            {\n                Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n                Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n                options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n                var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n                var serviceProviderIsService = serviceProvider.GetRequiredService<IServiceProviderIsService>();\n                var jsonBodyOrServiceTypeTuples = new (bool, Type)[] {\n                    #nullable disable\n                    (false, typeof(global::System.String[])),\n                    #nullable enable\n                };\n                foreach (var (isOptional, type) in jsonBodyOrServiceTypeTuples)\n                {\n                    if (!serviceProviderIsService.IsService(type))\n                    {\n                        options.EndpointBuilder.Metadata.Add(new AcceptsMetadata(type: type, isOptional: isOptional, contentTypes: GeneratedMetadataConstants.JsonContentType));\n                        break;\n                    }\n                }\n                var parameters = methodInfo.GetParameters();\n                options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n                options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(global::System.Int32), contentTypes: GeneratedMetadataConstants.JsonContentType));\n                return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n            };\n            RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n            {\n                Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n                Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n                Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n                Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n                var handler = Cast(del, global::System.Int32 (global::System.String?[] arg0) => throw null!);\n                EndpointFilterDelegate? filteredInvocation = null;\n                var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n                var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n                var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n                var jsonSerializerOptions = jsonOptions.SerializerOptions;\n                jsonSerializerOptions.MakeReadOnly();\n                var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n                var responseJsonTypeInfo =  (JsonTypeInfo<global::System.Int32>)jsonSerializerOptions.GetTypeInfo(typeof(global::System.Int32));\n\n                if (options.EndpointBuilder.FilterFactories.Count > 0)\n                {\n                    filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n                    {\n                        if (ic.HttpContext.Response.StatusCode == 400)\n                        {\n                            return ValueTask.FromResult<object?>(Results.Empty);\n                        }\n                        return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::System.String?[]>(0)!));\n                    },\n                    options.EndpointBuilder,\n                    handler.Method);\n                }\n\n                async Task RequestHandler(HttpContext httpContext)\n                {\n                    var wasParamCheckFailure = false;\n                    // Endpoint Parameter: p (Type = string?[], IsOptional = False, IsParsable = False, IsArray = True, Source = JsonBodyOrQuery)\n                    global::System.String?[] p_local = null!;\n                    if (options.DisableInferBodyFromParameters)\n                    {\n                        var p_raw = httpContext.Request.Query[\"p\"];\n                        p_local = p_raw!;\n                    }\n                    else\n                    {\n                        var p_JsonTypeInfo = (JsonTypeInfo<global::System.String?[]>)jsonOptions.SerializerOptions.GetTypeInfo(typeof(global::System.String[]));\n                        var p_resolveBodyResult = await GeneratedRouteBuilderExtensionsCore.TryResolveBodyAsync<global::System.String?[]>(httpContext, logOrThrowExceptionHelper, false, \"string?[]\", \"p\", p_JsonTypeInfo);\n                        p_local = p_resolveBodyResult.Item2!;\n                        if (!p_resolveBodyResult.Item1)\n                        {\n                            return;\n                        }\n                    }\n\n                    if (wasParamCheckFailure)\n                    {\n                        httpContext.Response.StatusCode = 400;\n                        return;\n                    }\n                    var result = handler(p_local);\n                    await httpContext.Response.WriteAsJsonAsync(result, responseJsonTypeInfo);\n                }\n\n                async Task RequestHandlerFiltered(HttpContext httpContext)\n                {\n                    var wasParamCheckFailure = false;\n                    // Endpoint Parameter: p (Type = string?[], IsOptional = False, IsParsable = False, IsArray = True, Source = JsonBodyOrQuery)\n                    global::System.String?[] p_local = null!;\n                    if (options.DisableInferBodyFromParameters)\n                    {\n                        var p_raw = httpContext.Request.Query[\"p\"];\n                        p_local = p_raw!;\n                    }\n                    else\n                    {\n                        var p_JsonTypeInfo = (JsonTypeInfo<global::System.String?[]>)jsonOptions.SerializerOptions.GetTypeInfo(typeof(global::System.String[]));\n                        var p_resolveBodyResult = await GeneratedRouteBuilderExtensionsCore.TryResolveBodyAsync<global::System.String?[]>(httpContext, logOrThrowExceptionHelper, false, \"string?[]\", \"p\", p_JsonTypeInfo);\n                        p_local = p_resolveBodyResult.Item2!;\n                        if (!p_resolveBodyResult.Item1)\n                        {\n                            return;\n                        }\n                    }\n\n                    if (wasParamCheckFailure)\n                    {\n                        httpContext.Response.StatusCode = 400;\n                    }\n                    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::System.String?[]>(httpContext, p_local));\n                    if (result is not null)\n                    {\n```\n\n----------------------------------------\n\nTITLE: Defining TwitterOptions class in C# for ASP.NET Core\nDESCRIPTION: This snippet defines the TwitterOptions class, which inherits from OAuthOptions<TwitterOptions>. It sets default values for Twitter-specific authentication endpoints and includes properties for RetrieveUserDetails and StateCookie.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/JwtBearer/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n/// <summary>\n/// Options for the Twitter OAuth authentication handler.\n/// </summary>\npublic class TwitterOptions : OAuthOptions<TwitterOptions>\n{\n    /// <summary>\n    /// Initializes a new instance of the <see cref=\"TwitterOptions\"/> class.\n    /// </summary>\n    public TwitterOptions()\n    {\n        CallbackPath = new PathString(\"/signin-twitter\");\n        AuthorizationEndpoint = TwitterDefaults.AuthorizationEndpoint;\n        TokenEndpoint = TwitterDefaults.TokenEndpoint;\n        UserInformationEndpoint = TwitterDefaults.UserInformationEndpoint;\n        UsePkce = true;\n    }\n\n    /// <summary>\n    /// Gets or sets if the Twitter handler should ask for user details on sign in.\n    /// When false, the authentiction flow will finish at token step.\n    /// The default value is true.\n    /// </summary>\n    public bool RetrieveUserDetails { get; set; } = true;\n\n    /// <summary>\n    /// Gets or sets the name of the cookie used to get the state from on signin.\n    /// This defaults to 'name + StateCookie' or TwitterAuthenticationDefaults.StateCookiePrefix + 'State'.\n    /// </summary>\n    public string? StateCookie { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Form Request Body Validation in ASP.NET Core\nDESCRIPTION: Handles invalid form request body data, throwing BadHttpRequestException with the original exception or logging the error.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HttpConnection Override Methods in ASP.NET Core (C#)\nDESCRIPTION: Defines the override methods for HttpConnection class that implement the base interface functionality, including property getters/setters for ConnectionId, Features, Items, and Transport.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Http.Connections.Client/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Http.Connections.Client.HttpConnection.ConnectionId.get -> string?\noverride Microsoft.AspNetCore.Http.Connections.Client.HttpConnection.ConnectionId.set -> void\noverride Microsoft.AspNetCore.Http.Connections.Client.HttpConnection.DisposeAsync() -> System.Threading.Tasks.ValueTask\noverride Microsoft.AspNetCore.Http.Connections.Client.HttpConnection.Features.get -> Microsoft.AspNetCore.Http.Features.IFeatureCollection!\noverride Microsoft.AspNetCore.Http.Connections.Client.HttpConnection.Items.get -> System.Collections.Generic.IDictionary<object!, object?>!\noverride Microsoft.AspNetCore.Http.Connections.Client.HttpConnection.Items.set -> void\noverride Microsoft.AspNetCore.Http.Connections.Client.HttpConnection.Transport.get -> System.IO.Pipelines.IDuplexPipe!\noverride Microsoft.AspNetCore.Http.Connections.Client.HttpConnection.Transport.set -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring Hub Endpoint Conventions in ASP.NET Core\nDESCRIPTION: Methods for adding and finalizing conventions to SignalR hub endpoints. These methods allow customization of hub endpoint metadata and behavior.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/SignalR/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Builder.HubEndpointConventionBuilder.Add(System.Action<Microsoft.AspNetCore.Builder.EndpointBuilder!>! convention) -> void\nMicrosoft.AspNetCore.Builder.HubEndpointConventionBuilder.Finally(System.Action<Microsoft.AspNetCore.Builder.EndpointBuilder!>! finalConvention) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining IWebHost Interface in C#\nDESCRIPTION: Defines the IWebHost interface with methods for starting and stopping the web host, and properties for accessing server features and services.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Hosting.IWebHost\nMicrosoft.AspNetCore.Hosting.IWebHost.ServerFeatures.get -> Microsoft.AspNetCore.Http.Features.IFeatureCollection!\nMicrosoft.AspNetCore.Hosting.IWebHost.Services.get -> System.IServiceProvider!\nMicrosoft.AspNetCore.Hosting.IWebHost.Start() -> void\nMicrosoft.AspNetCore.Hosting.IWebHost.StartAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Hosting.IWebHost.StopAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: JSON Body Resolution Implementation\nDESCRIPTION: Handles JSON request body deserialization with proper error handling and validation for required parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_JsonBodyOrService_HandlesBothJsonAndService.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nprivate static async ValueTask<(bool, T?)> TryResolveBodyAsync<T>(HttpContext httpContext, LogOrThrowExceptionHelper logOrThrowExceptionHelper, bool allowEmpty, string parameterTypeName, string parameterName, JsonTypeInfo<T> jsonTypeInfo, bool isInferred = false)\n```\n\n----------------------------------------\n\nTITLE: Defining IHubProtocol Interface in ASP.NET Core SignalR (C#)\nDESCRIPTION: Interface for hub protocols that handle serialization and deserialization of SignalR messages. Protocols implementing this interface are used to communicate between SignalR clients and servers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.GetMessageBytes(Microsoft.AspNetCore.SignalR.Protocol.HubMessage! message) -> System.ReadOnlyMemory<byte>\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.IsVersionSupported(int version) -> bool\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.Name.get -> string!\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.TransferFormat.get -> Microsoft.AspNetCore.Connections.TransferFormat\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.TryParseMessage(ref System.Buffers.ReadOnlySequence<byte> input, Microsoft.AspNetCore.SignalR.IInvocationBinder! binder, out Microsoft.AspNetCore.SignalR.Protocol.HubMessage? message) -> bool\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.Version.get -> int\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.WriteMessage(Microsoft.AspNetCore.SignalR.Protocol.HubMessage! message, System.Buffers.IBufferWriter<byte>! output) -> void\n```\n\n----------------------------------------\n\nTITLE: HTTP Protocol Version Utilities in ASP.NET Core\nDESCRIPTION: Methods for working with HTTP protocol versions, including version checking and conversion between System.Version and protocol string representations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.HttpProtocol.GetHttpProtocol(System.Version! version) -> string!\nstatic Microsoft.AspNetCore.Http.HttpProtocol.IsHttp09(string! protocol) -> bool\nstatic Microsoft.AspNetCore.Http.HttpProtocol.IsHttp10(string! protocol) -> bool\nstatic Microsoft.AspNetCore.Http.HttpProtocol.IsHttp11(string! protocol) -> bool\nstatic Microsoft.AspNetCore.Http.HttpProtocol.IsHttp2(string! protocol) -> bool\nstatic Microsoft.AspNetCore.Http.HttpProtocol.IsHttp3(string! protocol) -> bool\n```\n\n----------------------------------------\n\nTITLE: Defining Accepted HTTP Result in C#\nDESCRIPTION: Defines the Accepted class for representing HTTP 202 Accepted responses. It includes properties for Location and StatusCode, and an ExecuteAsync method for handling the response.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.Accepted\nMicrosoft.AspNetCore.Http.HttpResults.Accepted.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.Accepted.Location.get -> string?\nMicrosoft.AspNetCore.Http.HttpResults.Accepted.StatusCode.get -> int\n```\n\n----------------------------------------\n\nTITLE: Defining IAuthenticatedEncryptor Interface in C#\nDESCRIPTION: This snippet defines the IAuthenticatedEncryptor interface, which provides methods for encrypting and decrypting data with additional authenticated data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor.Decrypt(System.ArraySegment<byte> ciphertext, System.ArraySegment<byte> additionalAuthenticatedData) -> byte[]!\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor.Encrypt(System.ArraySegment<byte> plaintext, System.ArraySegment<byte> additionalAuthenticatedData) -> byte[]!\n```\n\n----------------------------------------\n\nTITLE: DefaultFilesMiddleware Implementation in ASP.NET Core\nDESCRIPTION: Middleware component that checks for default files in requested directories. It examines if a default file exists in the requested directory and rewriting the request to serve that file instead.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/StaticFiles/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.StaticFiles.DefaultFilesMiddleware.DefaultFilesMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.AspNetCore.Hosting.IWebHostEnvironment! hostingEnv, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Builder.DefaultFilesOptions!>! options) -> void\nMicrosoft.AspNetCore.StaticFiles.DefaultFilesMiddleware.Invoke(Microsoft.AspNetCore.Http.HttpContext! context) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Request Delegate Factory Function for ASP.NET Core Endpoints\nDESCRIPTION: Creates a request delegate factory function with service resolution, JSON serialization configuration, and endpoint filtering setup. This function prepares the environment for handling HTTP requests with parameter binding and validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nRequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n{\n    Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n    Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n    Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n    Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n    var handler = Cast(del, void (global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListRecordStruct arg0) => throw null!);\n    EndpointFilterDelegate? filteredInvocation = null;\n    var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n    var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n    var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n    var jsonSerializerOptions = jsonOptions.SerializerOptions;\n    jsonSerializerOptions.MakeReadOnly();\n    var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n    var Value_RouteOrQueryResolver = GeneratedRouteBuilderExtensionsCore.ResolveFromRouteOrQuery(\"Value\", options.RouteParameterNames);\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft.AspNetCore.SignalR.Client via .NET CLI\nDESCRIPTION: This command installs the Microsoft.AspNetCore.SignalR.Client package using the .NET CLI. It adds the package to your project, enabling the use of SignalR client functionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.SignalR.Client\n```\n\n----------------------------------------\n\nTITLE: Configuring JWT Bearer Authentication in ASP.NET Core\nDESCRIPTION: This code snippet demonstrates how to configure JWT Bearer authentication in an ASP.NET Core application using the Microsoft.AspNetCore.Authentication.JwtBearer package. It sets up the authentication service with custom token validation parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/JwtBearer/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.IdentityModel.Tokens;\nusing System.Text;\n\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n        .AddJwtBearer(options =>\n        {\n            options.TokenValidationParameters = new TokenValidationParameters\n            {\n                ValidateIssuer = true,\n                ValidateAudience = true,\n                ValidateLifetime = true,\n                ValidateIssuerSigningKey = true,\n                ValidIssuer = \"your_issuer\",\n                ValidAudience = \"your_audience\",\n                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(\"your_secret_key\"))\n            };\n        });\n\n    // Other configurations...\n}\n```\n\n----------------------------------------\n\nTITLE: Building Endpoint Filter Chain in ASP.NET Core\nDESCRIPTION: Constructs a chain of endpoint filters by applying filter factories in reverse order. Creates filtered invocation pipeline for endpoint execution.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocationAttribute for Method Interception in C#\nDESCRIPTION: Defines a sealed attribute class used for method interception with version and data parameters. The attribute can be applied multiple times to methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_NullableStringArrayParam.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nfile sealed class InterceptsLocationAttribute : Attribute\n{\n    public InterceptsLocationAttribute(int version, string data)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SendAsync Method Extension for SignalR HubConnection\nDESCRIPTION: Extension method to send an asynchronous message to a SignalR hub without parameters. Takes a hub method name and optional cancellation token.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.SendAsync(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Authenticated Encryptor Factory Implementation\nDESCRIPTION: Factory class for creating authenticated encryptor instances from keys.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.AuthenticatedEncryptorFactory.AuthenticatedEncryptorFactory(Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> void\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.AuthenticatedEncryptorFactory.CreateEncryptorInstance(Microsoft.AspNetCore.DataProtection.KeyManagement.IKey! key) -> Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor?\n```\n\n----------------------------------------\n\nTITLE: ISignalRBuilder Interface Definition\nDESCRIPTION: Interface for configuring SignalR in an ASP.NET Core application. It provides access to the service collection to register SignalR-related services.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.ISignalRBuilder\nMicrosoft.AspNetCore.SignalR.ISignalRBuilder.Services.get -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Running Specific ASP.NET Core Benchmark\nDESCRIPTION: Command to run a specific benchmark by providing its name as a parameter. Requires Release configuration and target framework specification.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/perf/Microbenchmarks/readme.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet run -c Release --framework <tfm> <benchmark_name>\n```\n\n----------------------------------------\n\nTITLE: CascadingAuthenticationState Override Method\nDESCRIPTION: Override implementation of BuildRenderTree method in CascadingAuthenticationState class.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Authorization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n~override Microsoft.AspNetCore.Components.Authorization.CascadingAuthenticationState.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder __builder) -> void\n```\n\n----------------------------------------\n\nTITLE: Adding Routing Services in ASP.NET Core\nDESCRIPTION: These extension methods add routing services to the dependency injection container in ASP.NET Core applications. They allow for configuring routing options and adding core routing services.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.RoutingServiceCollectionExtensions.AddRouting(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n\nstatic Microsoft.Extensions.DependencyInjection.RoutingServiceCollectionExtensions.AddRouting(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Routing.RouteOptions!>! configureOptions) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n\nstatic Microsoft.Extensions.DependencyInjection.RoutingServiceCollectionExtensions.AddRoutingCore(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Attribute Dictionary Implementation\nDESCRIPTION: Implementation of a dictionary class for handling HTML attributes in ASP.NET Core MVC views. Provides methods for managing key-value pairs of attribute data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic class AttributeDictionary\n{\n    public void Add(string key, string value);\n    public bool ContainsKey(string key);\n    public bool Remove(string key);\n    public bool TryGetValue(string key, out string value);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BearerTokenDefaults Authentication Scheme in C#\nDESCRIPTION: Defines a constant string for the default Bearer Token authentication scheme. This constant is used to identify and configure Bearer Token authentication in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/BearerToken/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.Authentication.BearerToken.BearerTokenDefaults.AuthenticationScheme = \"BearerToken\" -> string!\n```\n\n----------------------------------------\n\nTITLE: Required Parameter Validation in ASP.NET Core\nDESCRIPTION: Handles missing required parameters, throwing BadHttpRequestException if configured or logging the error at Debug level.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Kestrel Tests with PowerShell\nDESCRIPTION: Command to run the tests for the Kestrel project using PowerShell. This should be executed inside the project directory.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/README.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd -t\n```\n\n----------------------------------------\n\nTITLE: Request Delegate Execution Methods\nDESCRIPTION: Helper methods for executing request delegates and populating endpoint metadata. Includes async execution and generic metadata population.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsValidationProblemResult_Has_Metadata.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteAsyncExplicit(IResult result, HttpContext httpContext)\n    => result.ExecuteAsync(httpContext);\nprivate static void PopulateMetadataForEndpoint<T>(MethodInfo method, EndpointBuilder builder)\n    where T : IEndpointMetadataProvider\n{\n    T.PopulateMetadata(method, builder);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Methods for Connection Handling in C#\nDESCRIPTION: Defines extension methods for mapping connection handlers and connections in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/Http.Connections/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilderExtensions.MapConnectionHandler<TConnectionHandler>(this Microsoft.AspNetCore.Routing.IEndpointRouteBuilder! endpoints, string! pattern) -> Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder!\nstatic Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilderExtensions.MapConnectionHandler<TConnectionHandler>(this Microsoft.AspNetCore.Routing.IEndpointRouteBuilder! endpoints, string! pattern, System.Action<Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions!>? configureOptions) -> Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder!\nstatic Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilderExtensions.MapConnections(this Microsoft.AspNetCore.Routing.IEndpointRouteBuilder! endpoints, string! pattern, Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions! options, System.Action<Microsoft.AspNetCore.Connections.IConnectionBuilder!>! configure) -> Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder!\nstatic Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilderExtensions.MapConnections(this Microsoft.AspNetCore.Routing.IEndpointRouteBuilder! endpoints, string! pattern, System.Action<Microsoft.AspNetCore.Connections.IConnectionBuilder!>! configure) -> Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder!\n```\n\n----------------------------------------\n\nTITLE: Building JavaScript Components for JSInterop\nDESCRIPTION: Commands to build the JavaScript components of Microsoft.JSInterop.JS. These steps include cleaning previous builds and generating new distribution files that must be included in source control.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/JSInterop/README.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncd Microsoft.JSInterop.JS/src\nnpm run preclean\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Identity Result Static Properties\nDESCRIPTION: Static properties representing various authentication and identity operation results.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Identity.SignInResult.Failed.get -> Microsoft.AspNetCore.Identity.SignInResult!\nstatic Microsoft.AspNetCore.Identity.SignInResult.LockedOut.get -> Microsoft.AspNetCore.Identity.SignInResult!\nstatic Microsoft.AspNetCore.Identity.SignInResult.NotAllowed.get -> Microsoft.AspNetCore.Identity.SignInResult!\nstatic Microsoft.AspNetCore.Identity.SignInResult.Success.get -> Microsoft.AspNetCore.Identity.SignInResult!\nstatic Microsoft.AspNetCore.Identity.SignInResult.TwoFactorRequired.get -> Microsoft.AspNetCore.Identity.SignInResult!\n```\n\n----------------------------------------\n\nTITLE: Building the JWT Bearer Authentication Project Using PowerShell\nDESCRIPTION: Command to build the Microsoft.AspNetCore.Authentication.JwtBearer project from the parent security directory using PowerShell.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/JwtBearer/src/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: Extending RemoteAuthenticationBuilder in C#\nDESCRIPTION: Extends the RemoteAuthenticationBuilder with methods for adding account claims principal factories in ASP.NET Core WebAssembly authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.RemoteAuthenticationBuilderExtensions.AddAccountClaimsPrincipalFactory<TAccountClaimsPrincipalFactory>(this Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationState!, Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount!>! builder) -> Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationState!, Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount!>!\nstatic Microsoft.Extensions.DependencyInjection.RemoteAuthenticationBuilderExtensions.AddAccountClaimsPrincipalFactory<TRemoteAuthenticationState, TAccount, TAccountClaimsPrincipalFactory>(this Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<TRemoteAuthenticationState!, TAccount!>! builder) -> Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<TRemoteAuthenticationState!, TAccount!>!\nstatic Microsoft.Extensions.DependencyInjection.RemoteAuthenticationBuilderExtensions.AddAccountClaimsPrincipalFactory<TRemoteAuthenticationState, TAccountClaimsPrincipalFactory>(this Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<TRemoteAuthenticationState!, Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount!>! builder) -> Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<TRemoteAuthenticationState!, Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount!>!\n```\n\n----------------------------------------\n\nTITLE: Building Twitter Authentication Project in ASP.NET Core using PowerShell\nDESCRIPTION: PowerShell command to build the Twitter Authentication project from within the parent 'security' directory. This command executes the build script that compiles the project code.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Twitter/src/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: Endpoint Filter Delegate Construction in ASP.NET Core\nDESCRIPTION: Constructs an endpoint filter delegate when filter factories are present. This delegate wraps the handler method, checks for HTTP status codes, and processes arguments through the filter pipeline, allowing for middleware-like behavior in the request processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\nif (options.EndpointBuilder.FilterFactories.Count > 0)\n{\n    filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n    {\n        if (ic.HttpContext.Response.StatusCode == 400)\n        {\n            return ValueTask.FromResult<object?>(Results.Empty);\n        }\n        return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.HttpContext>(0)!, ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.MyBindAsyncFromInterfaceRecord?>(1)!));\n    },\n    options.EndpointBuilder,\n    handler.Method);\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Content-Range Header in C#\nDESCRIPTION: Static methods for parsing Content-Range headers. These methods handle both parsing a single header value and attempting to parse with error handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Headers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Net.Http.Headers.ContentRangeHeaderValue.Parse(Microsoft.Extensions.Primitives.StringSegment input) -> Microsoft.Net.Http.Headers.ContentRangeHeaderValue!\nstatic Microsoft.Net.Http.Headers.ContentRangeHeaderValue.TryParse(Microsoft.Extensions.Primitives.StringSegment input, out Microsoft.Net.Http.Headers.ContentRangeHeaderValue? parsedValue) -> bool\n```\n\n----------------------------------------\n\nTITLE: Implementing Virtual Properties for ActionExecutedContext in C#\nDESCRIPTION: Defines virtual properties for the ActionExecutedContext class, including Canceled, Controller, Exception, ExceptionDispatchInfo, ExceptionHandled, and Result. These properties allow for customization of action execution behavior.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext.Canceled.get -> bool\nvirtual Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext.Canceled.set -> void\nvirtual Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext.Controller.get -> object!\nvirtual Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext.Exception.get -> System.Exception?\nvirtual Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext.Exception.set -> void\nvirtual Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext.ExceptionDispatchInfo.get -> System.Runtime.ExceptionServices.ExceptionDispatchInfo?\nvirtual Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext.ExceptionDispatchInfo.set -> void\nvirtual Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext.ExceptionHandled.get -> bool\nvirtual Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext.ExceptionHandled.set -> void\nvirtual Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext.Result.get -> Microsoft.AspNetCore.Mvc.IActionResult?\nvirtual Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext.Result.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining PolicyAuthorizationResult Class in C#\nDESCRIPTION: Declares the PolicyAuthorizationResult class with properties for representing the outcome of a policy authorization process.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Policy/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.Policy.PolicyAuthorizationResult\nMicrosoft.AspNetCore.Authorization.Policy.PolicyAuthorizationResult.AuthorizationFailure.get -> Microsoft.AspNetCore.Authorization.AuthorizationFailure?\nMicrosoft.AspNetCore.Authorization.Policy.PolicyAuthorizationResult.Challenged.get -> bool\nMicrosoft.AspNetCore.Authorization.Policy.PolicyAuthorizationResult.Forbidden.get -> bool\nMicrosoft.AspNetCore.Authorization.Policy.PolicyAuthorizationResult.Succeeded.get -> bool\n```\n\n----------------------------------------\n\nTITLE: Implementing AuthorizationMiddlewareResultHandler Class in C#\nDESCRIPTION: Implements the AuthorizationMiddlewareResultHandler class with a constructor and HandleAsync method for processing authorization results.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Policy/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.Policy.AuthorizationMiddlewareResultHandler\nMicrosoft.AspNetCore.Authorization.Policy.AuthorizationMiddlewareResultHandler.AuthorizationMiddlewareResultHandler() -> void\nMicrosoft.AspNetCore.Authorization.Policy.AuthorizationMiddlewareResultHandler.HandleAsync(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy, Microsoft.AspNetCore.Authorization.Policy.PolicyAuthorizationResult! authorizeResult) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Implementing Virtual Methods and Properties for Model Binding in C#\nDESCRIPTION: Defines virtual methods and properties for BindingSource, ModelBindingMessageProvider, ModelBinderProviderContext, and ModelBindingContext classes. These members allow customization of model binding behavior and error messages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.BindingSource.CanAcceptDataFrom(Microsoft.AspNetCore.Mvc.ModelBinding.BindingSource! bindingSource) -> bool\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.ModelBindingMessageProvider.AttemptedValueIsInvalidAccessor.get -> System.Func<string!, string!, string!>!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.ModelBindingMessageProvider.MissingBindRequiredValueAccessor.get -> System.Func<string!, string!>!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.ModelBindingMessageProvider.MissingKeyOrValueAccessor.get -> System.Func<string!>!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.ModelBindingMessageProvider.MissingRequestBodyRequiredValueAccessor.get -> System.Func<string!>!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.ModelBindingMessageProvider.NonPropertyAttemptedValueIsInvalidAccessor.get -> System.Func<string!, string!>!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.ModelBindingMessageProvider.NonPropertyUnknownValueIsInvalidAccessor.get -> System.Func<string!>!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.ModelBindingMessageProvider.NonPropertyValueMustBeANumberAccessor.get -> System.Func<string!>!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.ModelBindingMessageProvider.UnknownValueIsInvalidAccessor.get -> System.Func<string!, string!>!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.ModelBindingMessageProvider.ValueIsInvalidAccessor.get -> System.Func<string!, string!>!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.ModelBindingMessageProvider.ValueMustBeANumberAccessor.get -> System.Func<string!, string!>!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.ModelBindingMessageProvider.ValueMustNotBeNullAccessor.get -> System.Func<string!, string!>!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.ModelBinderProviderContext.CreateBinder(Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata! metadata, Microsoft.AspNetCore.Mvc.ModelBinding.BindingInfo! bindingInfo) -> Microsoft.AspNetCore.Mvc.ModelBinding.IModelBinder!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.ModelBinderProviderContext.Services.get -> System.IServiceProvider!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.ModelBindingContext.HttpContext.get -> Microsoft.AspNetCore.Http.HttpContext!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.ModelBindingContext.ModelType.get -> System.Type!\n```\n\n----------------------------------------\n\nTITLE: Authentication Ticket Serialization Methods\nDESCRIPTION: Methods for serializing and deserializing authentication tickets, including handling of claims and identities. Provides functionality for binary reading and writing of authentication data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authentication.TicketSerializer.Deserialize(byte[]! data) -> Microsoft.AspNetCore.Authentication.AuthenticationTicket?\n\nvirtual Microsoft.AspNetCore.Authentication.TicketSerializer.Serialize(Microsoft.AspNetCore.Authentication.AuthenticationTicket! ticket) -> byte[]!\n\nvirtual Microsoft.AspNetCore.Authentication.TicketSerializer.WriteClaim(System.IO.BinaryWriter! writer, System.Security.Claims.Claim! claim) -> void\n\nvirtual Microsoft.AspNetCore.Authentication.TicketSerializer.WriteIdentity(System.IO.BinaryWriter! writer, System.Security.Claims.ClaimsIdentity! identity) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining RedisCacheOptions Class in C# for ASP.NET Core\nDESCRIPTION: Defines the RedisCacheOptions class which provides configuration options for the Redis cache. It includes properties for setting the Redis connection string, instance name, and custom configuration options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.Configuration.get -> string?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.Configuration.set -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ConfigurationOptions.get -> StackExchange.Redis.ConfigurationOptions?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ConfigurationOptions.set -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ConnectionMultiplexerFactory.get -> System.Func<System.Threading.Tasks.Task<StackExchange.Redis.IConnectionMultiplexer!>!>?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ConnectionMultiplexerFactory.set -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.InstanceName.get -> string?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.InstanceName.set -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ProfilingSession.get -> System.Func<StackExchange.Redis.Profiling.ProfilingSession!>?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ProfilingSession.set -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.RedisCacheOptions() -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing HubConnectionHandler in ASP.NET Core SignalR\nDESCRIPTION: Implementation of connection handler for hub connections, which manages the lifecycle of SignalR hub connections.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.SignalR.HubConnectionHandler<THub>.OnConnectedAsync(Microsoft.AspNetCore.Connections.ConnectionContext! connection) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Implementing AuthorizationHandlerContext in C#\nDESCRIPTION: This class represents the context for authorization handlers, containing information about the user, resource, and requirements being evaluated.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationHandlerContext\nMicrosoft.AspNetCore.Authorization.AuthorizationHandlerContext.AuthorizationHandlerContext(System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.IAuthorizationRequirement!>! requirements, System.Security.Claims.ClaimsPrincipal! user, object? resource) -> void\n```\n\n----------------------------------------\n\nTITLE: QuickGrid Core Component Implementation\nDESCRIPTION: Main grid component implementation with support for virtualization, pagination, sorting, and item templating.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/QuickGrid/Microsoft.AspNetCore.Components.QuickGrid/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.QuickGrid.QuickGrid<TGridItem> {\n    IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }\n    RenderFragment? ChildContent { get; set; }\n    string? Class { get; set; }\n    Func<TGridItem, object> ItemKey { get; set; }\n    IQueryable<TGridItem>? Items { get; set; }\n    float ItemSize { get; set; }\n    GridItemsProvider<TGridItem>? ItemsProvider { get; set; }\n    PaginationState? Pagination { get; set; }\n    string? Theme { get; set; }\n    bool Virtualize { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Unexpected Non-Form Content Type Logger in ASP.NET Core\nDESCRIPTION: Defines a structured logger for tracking unexpected content types when a form content type was expected. Creates a reusable logging delegate that formats a consistent message with the actual content type at Debug level with EventId 7.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndGet_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions and Logging in ASP.NET Core Request Delegation\nDESCRIPTION: This class provides methods for logging or throwing exceptions related to request delegation, including IO exceptions, JSON parsing errors, and parameter binding failures.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_MultipleStringParam_StringReturn.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    // ... (other methods omitted for brevity)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IQueryCollection Interface in ASP.NET Core\nDESCRIPTION: Interface for accessing HTTP query string parameters. Provides methods to check key existence, get values, and access the collection of query parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Features/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.IQueryCollection {\n    bool ContainsKey(string key);\n    int Count { get; }\n    ICollection<string> Keys { get; }\n    StringValues this[string key] { get; }\n    bool TryGetValue(string key, out StringValues value);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RoutePatternParameterPart Properties in C#\nDESCRIPTION: This snippet defines properties for the RoutePatternParameterPart class, including IsOptional, Name, ParameterKind, and ParameterPolicies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Routing.Patterns.RoutePatternParameterPart.IsOptional.get -> bool\nMicrosoft.AspNetCore.Routing.Patterns.RoutePatternParameterPart.Name.get -> string!\nMicrosoft.AspNetCore.Routing.Patterns.RoutePatternParameterPart.ParameterKind.get -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterKind\nMicrosoft.AspNetCore.Routing.Patterns.RoutePatternParameterPart.ParameterPolicies.get -> System.Collections.Generic.IReadOnlyList<Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterPolicyReference!>!\n```\n\n----------------------------------------\n\nTITLE: Request Delegate Result Creation in ASP.NET Core\nDESCRIPTION: Creates a RequestDelegateResult by selecting the appropriate request delegate based on the presence of filters. It combines the target delegate with endpoint metadata to form the final result that will be used for request handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\nRequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\nvar metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\nreturn new RequestDelegateResult(targetDelegate, metadata);\n```\n\n----------------------------------------\n\nTITLE: Stopping Lingering Processes in PowerShell\nDESCRIPTION: PowerShell command to kill processes that might be holding files being deleted during cleaning, such as Visual Studio, MSBuild, and other dotnet processes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/README.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\nGet-Process dotnet, escape-node-job, msbuild, VBCSCompiler, node, vstest.console, Microsoft.CodeAnalysis.LanguageServer -ErrorAction Continue | Stop-Process;\n```\n\n----------------------------------------\n\nTITLE: JSON Serialization for HTTP Responses with Type Handling in ASP.NET Core\nDESCRIPTION: Writes JSON to HTTP responses with support for polymorphic types. It uses JsonTypeInfo to determine if the runtime type matches the expected type and selects the appropriate serialization approach.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: NotFound Result Methods in PageModel\nDESCRIPTION: Methods for returning NotFound (404) responses, with options for including object values in the response.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.NotFound() -> Microsoft.AspNetCore.Mvc.NotFoundResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.NotFound(object! value) -> Microsoft.AspNetCore.Mvc.NotFoundObjectResult!\n```\n\n----------------------------------------\n\nTITLE: Implementing CircuitOptions Class in C#\nDESCRIPTION: Class for configuring Blazor circuit options, including detailed errors, disconnected circuit retention, JS interop timeout, and root component settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Server.CircuitOptions\nMicrosoft.AspNetCore.Components.Server.CircuitOptions.CircuitOptions() -> void\nMicrosoft.AspNetCore.Components.Server.CircuitOptions.DetailedErrors.get -> bool\nMicrosoft.AspNetCore.Components.Server.CircuitOptions.DetailedErrors.set -> void\nMicrosoft.AspNetCore.Components.Server.CircuitOptions.DisconnectedCircuitMaxRetained.get -> int\nMicrosoft.AspNetCore.Components.Server.CircuitOptions.DisconnectedCircuitMaxRetained.set -> void\nMicrosoft.AspNetCore.Components.Server.CircuitOptions.DisconnectedCircuitRetentionPeriod.get -> System.TimeSpan\nMicrosoft.AspNetCore.Components.Server.CircuitOptions.DisconnectedCircuitRetentionPeriod.set -> void\nMicrosoft.AspNetCore.Components.Server.CircuitOptions.JSInteropDefaultCallTimeout.get -> System.TimeSpan\nMicrosoft.AspNetCore.Components.Server.CircuitOptions.JSInteropDefaultCallTimeout.set -> void\nMicrosoft.AspNetCore.Components.Server.CircuitOptions.MaxBufferedUnacknowledgedRenderBatches.get -> int\nMicrosoft.AspNetCore.Components.Server.CircuitOptions.MaxBufferedUnacknowledgedRenderBatches.set -> void\nMicrosoft.AspNetCore.Components.Server.CircuitOptions.RootComponents.get -> Microsoft.AspNetCore.Components.Server.CircuitRootComponentOptions!\n```\n\n----------------------------------------\n\nTITLE: Restoring JavaScript Modules with NPM\nDESCRIPTION: Command to restore required JavaScript modules using NPM in offline mode, which doesn't require an internet connection as sources are read from a sub-module.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/README.md#2025-04-08_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\nnpm ci --offline\n```\n\n----------------------------------------\n\nTITLE: Defining IRequestCultureProvider Interface in C#\nDESCRIPTION: Defines the IRequestCultureProvider interface for implementing custom request culture providers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Localization.IRequestCultureProvider\nMicrosoft.AspNetCore.Localization.IRequestCultureProvider.DetermineProviderCultureResult(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Localization.ProviderCultureResult?>!\n```\n\n----------------------------------------\n\nTITLE: Selecting Specific Clients in ASP.NET Core SignalR\nDESCRIPTION: These methods allow selecting specific clients by their connection IDs. They provide overloads for selecting up to 8 individual connection IDs or a collection of connection IDs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.HubClientsExtensions.Clients<T>(this Microsoft.AspNetCore.SignalR.IHubClients<T>! hubClients, string! connection1) -> T\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.HubClientsExtensions.Clients<T>(this Microsoft.AspNetCore.SignalR.IHubClients<T>! hubClients, System.Collections.Generic.IEnumerable<string!>! connectionIds) -> T\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C# Project\nDESCRIPTION: Directive that enables nullable reference type checking for this C# file. This feature helps prevent null reference exceptions by providing compiler warnings when potentially null values are dereferenced.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Razor/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining Invalid Form Request Body Logger in ASP.NET Core (C#)\nDESCRIPTION: Defines a structured logging action for invalid form request body errors. Creates a reusable logging delegate with specific event ID and message template for consistent logging when a form parameter cannot be properly parsed from the request body.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Get_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n    LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Running Tests for ASP.NET Core Authorization Components in PowerShell\nDESCRIPTION: Command to run the tests for the ASP.NET Core authorization components. The -t flag specifies running tests, and this should be executed from the parent 'security' directory.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/README.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd -t\n```\n\n----------------------------------------\n\nTITLE: Determining JsonTypeInfo Usage for Runtime Type\nDESCRIPTION: This extension method determines if a JsonTypeInfo should be used with a given runtime type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\n----------------------------------------\n\nTITLE: Queue Policy Configuration Options\nDESCRIPTION: Configuration options for queue policies used by the concurrency limiter. Controls maximum concurrent requests and queue size limits.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ConcurrencyLimiter/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.ConcurrencyLimiter.QueuePolicyOptions.QueuePolicyOptions() -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.ConcurrencyLimiter.QueuePolicyOptions.MaxConcurrentRequests.get -> int\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.ConcurrencyLimiter.QueuePolicyOptions.MaxConcurrentRequests.set -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.ConcurrencyLimiter.QueuePolicyOptions.RequestQueueLimit.get -> int\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.ConcurrencyLimiter.QueuePolicyOptions.RequestQueueLimit.set -> void\n```\n\n----------------------------------------\n\nTITLE: Cleaning and Resetting All Submodules\nDESCRIPTION: Command to clean and reset all submodules, removing untracked files and reverting to the last commit.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Submodules.md#2025-04-08_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit submodule foreach 'git reset --hard; git clean -xfd'\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Implicit Body in ASP.NET Core Request\nDESCRIPTION: Handles cases where an implicit body was expected for a parameter but no body was provided in the request. Suggests using a Service instead and either throws or logs based on configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic void ImplicitBodyNotProvided(string parameterName)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AccessDeniedModel for ASP.NET Core Identity UI V5\nDESCRIPTION: This snippet defines the AccessDeniedModel class for ASP.NET Core Identity UI version 5. It includes a constructor and a method for handling GET requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.AccessDeniedModel\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.AccessDeniedModel.AccessDeniedModel() -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.AccessDeniedModel.OnGet() -> void\n```\n\n----------------------------------------\n\nTITLE: Microsoft Account Authentication Handler Implementation\nDESCRIPTION: Handler class constructors and override methods for processing Microsoft Account authentication challenges and tickets.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/MicrosoftAccount/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.MicrosoftAccount.MicrosoftAccountHandler.MicrosoftAccountHandler(Microsoft.Extensions.Options.IOptionsMonitor<Microsoft.AspNetCore.Authentication.MicrosoftAccount.MicrosoftAccountOptions!>! options, Microsoft.Extensions.Logging.ILoggerFactory! logger, System.Text.Encodings.Web.UrlEncoder! encoder) -> void\n\noverride Microsoft.AspNetCore.Authentication.MicrosoftAccount.MicrosoftAccountHandler.BuildChallengeUrl(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, string! redirectUri) -> string!\n\noverride Microsoft.AspNetCore.Authentication.MicrosoftAccount.MicrosoftAccountHandler.CreateTicketAsync(System.Security.Claims.ClaimsIdentity! identity, Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, Microsoft.AspNetCore.Authentication.OAuth.OAuthTokenResponse! tokens) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authentication.AuthenticationTicket!>!\n```\n\n----------------------------------------\n\nTITLE: Handling Implicit Body Not Provided in ASP.NET Core\nDESCRIPTION: This method handles cases where an implicit body is expected but not provided. It throws a BadHttpRequestException if _shouldThrow is true, otherwise logs the event if a logger is available.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitServiceParam_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic void ImplicitBodyNotProvided(string parameterName)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Schema for Tag Object in Pet Store API\nDESCRIPTION: This snippet defines the JSON schema for a Tag object. It specifies required fields, property types, and formats for the id and name properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Tools/Microsoft.dotnet-openapi/test/TestContent/openapi.json.txt#2025-04-08_snippet_3\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"type\": \"object\",\n  \"additionalProperties\": false,\n  \"required\": [\n    \"id\"\n  ],\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\",\n      \"format\": \"int32\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in ASP.NET Core\nDESCRIPTION: Method that handles failures when reading form data from the request body. It either throws a BadHttpRequestException with the original exception as the inner exception or logs a debug message with parameter type and name information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ConnectionEndpointRouteBuilder Class in C#\nDESCRIPTION: Defines the ConnectionEndpointRouteBuilder class with methods for adding conventions and final conventions to endpoint builders.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/Http.Connections/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder\nMicrosoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder.Add(System.Action<Microsoft.AspNetCore.Builder.EndpointBuilder!>! convention) -> void\nMicrosoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder.Finally(System.Action<Microsoft.AspNetCore.Builder.EndpointBuilder!>! finalConvention) -> void\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C# for ASP.NET Core\nDESCRIPTION: This directive enables nullable reference types, which helps catch null reference exceptions at compile-time rather than runtime. It enforces more explicit null-checking in the codebase.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/FileProviders/Embedded/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing Delegate Type Casting in ASP.NET Core\nDESCRIPTION: Provides type-safe casting of delegates with generic constraints. Used to ensure type safety when handling different delegate types within the routing system.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Navigation Methods in WebViewManager\nDESCRIPTION: Abstract methods for navigation and message sending that derived WebViewManager classes must implement to control the underlying web view.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebView/WebView/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\nabstract Microsoft.AspNetCore.Components.WebView.WebViewManager.NavigateCore(System.Uri! absoluteUri) -> void\nabstract Microsoft.AspNetCore.Components.WebView.WebViewManager.SendMessage(string! message) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a custom attribute 'InterceptsLocationAttribute' used for method interception in the System.Runtime.CompilerServices namespace.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_NoParam_StringReturn_WithFilter.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: AuthorizationFailureReason Class Definition in C#\nDESCRIPTION: Definition of the AuthorizationFailureReason class that provides detailed information about why a specific authorization requirement failed, including the handler and error message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationFailureReason\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationFailureReason.AuthorizationFailureReason(Microsoft.AspNetCore.Authorization.IAuthorizationHandler! handler, string! message) -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationFailureReason.Handler.get -> Microsoft.AspNetCore.Authorization.IAuthorizationHandler!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationFailureReason.Message.get -> string!\n```\n\n----------------------------------------\n\nTITLE: Defining RequestCultureProvider Abstract Class in C#\nDESCRIPTION: Defines the abstract RequestCultureProvider class as a base for custom request culture providers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Localization.RequestCultureProvider\nMicrosoft.AspNetCore.Localization.RequestCultureProvider.Options.get -> Microsoft.AspNetCore.Builder.RequestLocalizationOptions?\nMicrosoft.AspNetCore.Localization.RequestCultureProvider.Options.set -> void\nMicrosoft.AspNetCore.Localization.RequestCultureProvider.RequestCultureProvider() -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring JSON Patch Input Formatter in ASP.NET Core\nDESCRIPTION: Configuration code to register the custom JSON Patch input formatter in Program.cs\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Features/JsonPatch/src/PACKAGE.md#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers(options =>\n{\n    options.InputFormatters.Insert(0, GetJsonPatchInputFormatter());\n});\n```\n\n----------------------------------------\n\nTITLE: Defining ISingleClientProxy Interface in ASP.NET Core SignalR\nDESCRIPTION: Interface for a proxy to a single client connection in SignalR, providing method to invoke remote methods on the client with various parameter counts.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.ISingleClientProxy\nMicrosoft.AspNetCore.SignalR.ISingleClientProxy.InvokeCoreAsync<T>(string! method, object?[]! args, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<T>!\n```\n\n----------------------------------------\n\nTITLE: Rendering and Component State Management in ASP.NET Core Blazor\nDESCRIPTION: Virtual methods for managing component rendering, state, and disposal in the Blazor rendering pipeline, including task management and render mode resolution.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.Rendering.ComponentState.DisposeAsync() -> System.Threading.Tasks.ValueTask\nvirtual Microsoft.AspNetCore.Components.RenderTree.Renderer.AddPendingTask(Microsoft.AspNetCore.Components.Rendering.ComponentState? componentState, System.Threading.Tasks.Task! task) -> void\nvirtual Microsoft.AspNetCore.Components.RenderTree.Renderer.Assets.get -> Microsoft.AspNetCore.Components.ResourceAssetCollection!\nvirtual Microsoft.AspNetCore.Components.RenderTree.Renderer.CreateComponentState(int componentId, Microsoft.AspNetCore.Components.IComponent! component, Microsoft.AspNetCore.Components.Rendering.ComponentState? parentComponentState) -> Microsoft.AspNetCore.Components.Rendering.ComponentState!\nvirtual Microsoft.AspNetCore.Components.RenderTree.Renderer.DispatchEventAsync(ulong eventHandlerId, Microsoft.AspNetCore.Components.RenderTree.EventFieldInfo? fieldInfo, System.EventArgs! eventArgs) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Components.RenderTree.Renderer.DispatchEventAsync(ulong eventHandlerId, Microsoft.AspNetCore.Components.RenderTree.EventFieldInfo? fieldInfo, System.EventArgs! eventArgs, bool waitForQuiescence) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Components.RenderTree.Renderer.Dispose(bool disposing) -> void\nvirtual Microsoft.AspNetCore.Components.RenderTree.Renderer.GetComponentRenderMode(Microsoft.AspNetCore.Components.IComponent! component) -> Microsoft.AspNetCore.Components.IComponentRenderMode?\nvirtual Microsoft.AspNetCore.Components.RenderTree.Renderer.ProcessPendingRender() -> void\nvirtual Microsoft.AspNetCore.Components.RenderTree.Renderer.RendererInfo.get -> Microsoft.AspNetCore.Components.RendererInfo!\nvirtual Microsoft.AspNetCore.Components.RenderTree.Renderer.ResolveComponentForRenderMode(System.Type! componentType, int? parentComponentId, Microsoft.AspNetCore.Components.IComponentActivator! componentActivator, Microsoft.AspNetCore.Components.IComponentRenderMode! renderMode) -> Microsoft.AspNetCore.Components.IComponent!\n```\n\n----------------------------------------\n\nTITLE: InputSelect, InputText, and InputTextArea Components API\nDESCRIPTION: API signatures for InputSelect<TValue>, InputText, and InputTextArea components that render select dropdowns, text inputs, and textarea elements in forms, including properties for child content and element references.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Forms.InputSelect<TValue>\nMicrosoft.AspNetCore.Components.Forms.InputSelect<TValue>.ChildContent.get -> Microsoft.AspNetCore.Components.RenderFragment?\nMicrosoft.AspNetCore.Components.Forms.InputSelect<TValue>.ChildContent.set -> void\nMicrosoft.AspNetCore.Components.Forms.InputSelect<TValue>.Element.get -> Microsoft.AspNetCore.Components.ElementReference?\nMicrosoft.AspNetCore.Components.Forms.InputSelect<TValue>.Element.set -> void\nMicrosoft.AspNetCore.Components.Forms.InputSelect<TValue>.InputSelect() -> void\nMicrosoft.AspNetCore.Components.Forms.InputText\nMicrosoft.AspNetCore.Components.Forms.InputText.Element.get -> Microsoft.AspNetCore.Components.ElementReference?\nMicrosoft.AspNetCore.Components.Forms.InputText.Element.set -> void\nMicrosoft.AspNetCore.Components.Forms.InputText.InputText() -> void\nMicrosoft.AspNetCore.Components.Forms.InputTextArea\nMicrosoft.AspNetCore.Components.Forms.InputTextArea.Element.get -> Microsoft.AspNetCore.Components.ElementReference?\nMicrosoft.AspNetCore.Components.Forms.InputTextArea.Element.set -> void\nMicrosoft.AspNetCore.Components.Forms.InputTextArea.InputTextArea() -> void\n```\n\n----------------------------------------\n\nTITLE: ValidationVisitor Method Signatures in ASP.NET Core MVC\nDESCRIPTION: Virtual methods from the ValidationVisitor class that handle different aspects of model validation. These methods control the validation process for simple types, complex types, and model hierarchies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_67\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.Validation.ValidationVisitor.ValidateNode() -> bool\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.Validation.ValidationVisitor.Visit(Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata! metadata, string? key, object? model) -> bool\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.Validation.ValidationVisitor.VisitChildren(Microsoft.AspNetCore.Mvc.ModelBinding.Validation.IValidationStrategy! strategy) -> bool\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.Validation.ValidationVisitor.VisitComplexType(Microsoft.AspNetCore.Mvc.ModelBinding.Validation.IValidationStrategy! defaultStrategy) -> bool\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.Validation.ValidationVisitor.VisitSimpleType() -> bool\n```\n\n----------------------------------------\n\nTITLE: Defining WebApplicationBuilder Class in C#\nDESCRIPTION: Defines the WebApplicationBuilder class with properties for configuring various aspects of the web application, including configuration, environment, host, logging, and services.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DefaultBuilder/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Builder.WebApplicationBuilder\nMicrosoft.AspNetCore.Builder.WebApplicationBuilder.Build() -> Microsoft.AspNetCore.Builder.WebApplication!\nMicrosoft.AspNetCore.Builder.WebApplicationBuilder.Configuration.get -> Microsoft.Extensions.Configuration.ConfigurationManager!\nMicrosoft.AspNetCore.Builder.WebApplicationBuilder.Environment.get -> Microsoft.AspNetCore.Hosting.IWebHostEnvironment!\nMicrosoft.AspNetCore.Builder.WebApplicationBuilder.Host.get -> Microsoft.AspNetCore.Builder.ConfigureHostBuilder!\nMicrosoft.AspNetCore.Builder.WebApplicationBuilder.Logging.get -> Microsoft.Extensions.Logging.ILoggingBuilder!\nMicrosoft.AspNetCore.Builder.WebApplicationBuilder.Metrics.get -> Microsoft.Extensions.Diagnostics.Metrics.IMetricsBuilder!\nMicrosoft.AspNetCore.Builder.WebApplicationBuilder.Services.get -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nMicrosoft.AspNetCore.Builder.WebApplicationBuilder.WebHost.get -> Microsoft.AspNetCore.Builder.ConfigureWebHostBuilder!\n```\n\n----------------------------------------\n\nTITLE: IFormCollection Interface Definition in C#\nDESCRIPTION: Defines the interface for handling form data collections in ASP.NET Core, including methods for accessing form values and files. Provides functionality for key-based access and collection management.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Features/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.IFormCollection\nMicrosoft.AspNetCore.Http.IFormCollection.ContainsKey(string! key) -> bool\nMicrosoft.AspNetCore.Http.IFormCollection.Count.get -> int\nMicrosoft.AspNetCore.Http.IFormCollection.Files.get -> Microsoft.AspNetCore.Http.IFormFileCollection!\nMicrosoft.AspNetCore.Http.IFormCollection.Keys.get -> System.Collections.Generic.ICollection<string!>!\nMicrosoft.AspNetCore.Http.IFormCollection.this[string! key].get -> Microsoft.Extensions.Primitives.StringValues\nMicrosoft.AspNetCore.Http.IFormCollection.TryGetValue(string! key, out Microsoft.Extensions.Primitives.StringValues value) -> bool\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Class for ASP.NET Core Request Delegation\nDESCRIPTION: Implements IParameterBindingMetadata to store information about parameters bound from HTTP requests. It tracks parameter name, type information, and binding capabilities like TryParse and BindAsync support.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleNullableStringParam_WithEmptyQueryStringValueProvided_StringReturn.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining WebHostDefaults Configuration Keys in ASP.NET Core\nDESCRIPTION: A collection of static readonly string constants that define standard configuration keys used throughout the ASP.NET Core hosting system. These keys are used to configure various aspects of web host behavior such as content roots, environments, ports, and startup assemblies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Hosting.WebHostDefaults.ContentRootKey -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.WebHostDefaults.DetailedErrorsKey -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.WebHostDefaults.EnvironmentKey -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.WebHostDefaults.HostingStartupAssembliesKey -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.WebHostDefaults.HostingStartupExcludeAssembliesKey -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.WebHostDefaults.HttpPortsKey -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.WebHostDefaults.HttpsPortsKey -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.WebHostDefaults.PreferHostingUrlsKey -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.WebHostDefaults.PreventHostingStartupKey -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.WebHostDefaults.ServerUrlsKey -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.WebHostDefaults.ShutdownTimeoutKey -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.WebHostDefaults.StartupAssemblyKey -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.WebHostDefaults.StaticWebAssetsKey -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.WebHostDefaults.SuppressStatusMessagesKey -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.WebHostDefaults.WebRootKey -> string!\n```\n\n----------------------------------------\n\nTITLE: RequestFormLimitsAttribute Class Definition - C#\nDESCRIPTION: Attribute for configuring form request limits including buffer sizes, length limits for multipart content, and value count restrictions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.RequestFormLimitsAttribute.RequestFormLimitsAttribute() -> void\nMicrosoft.AspNetCore.Mvc.RequestFormLimitsAttribute.BufferBody.get -> bool\nMicrosoft.AspNetCore.Mvc.RequestFormLimitsAttribute.BufferBodyLengthLimit.get -> long\n```\n\n----------------------------------------\n\nTITLE: Defining ConfigureWebHostBuilder Class in C#\nDESCRIPTION: Defines the ConfigureWebHostBuilder class with methods for configuring the web host, including app configuration, services configuration, and settings management.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DefaultBuilder/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Builder.ConfigureWebHostBuilder\nMicrosoft.AspNetCore.Builder.ConfigureWebHostBuilder.ConfigureAppConfiguration(System.Action<Microsoft.AspNetCore.Hosting.WebHostBuilderContext!, Microsoft.Extensions.Configuration.IConfigurationBuilder!>! configureDelegate) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\nMicrosoft.AspNetCore.Builder.ConfigureWebHostBuilder.ConfigureServices(System.Action<Microsoft.AspNetCore.Hosting.WebHostBuilderContext!, Microsoft.Extensions.DependencyInjection.IServiceCollection!>! configureServices) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\nMicrosoft.AspNetCore.Builder.ConfigureWebHostBuilder.ConfigureServices(System.Action<Microsoft.Extensions.DependencyInjection.IServiceCollection!>! configureServices) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\nMicrosoft.AspNetCore.Builder.ConfigureWebHostBuilder.GetSetting(string! key) -> string?\nMicrosoft.AspNetCore.Builder.ConfigureWebHostBuilder.UseSetting(string! key, string? value) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\n```\n\n----------------------------------------\n\nTITLE: SignalR Protocol Message Classes\nDESCRIPTION: Classes representing different types of messages exchanged in SignalR connections. These include acknowledgment, invocation, completion, streaming, and control messages that form the core of the SignalR protocol.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.Protocol.AckMessage\nMicrosoft.AspNetCore.SignalR.Protocol.AckMessage.AckMessage(long sequenceId) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.AckMessage.SequenceId.get -> long\nMicrosoft.AspNetCore.SignalR.Protocol.AckMessage.SequenceId.set -> void\n\nMicrosoft.AspNetCore.SignalR.Protocol.CancelInvocationMessage\nMicrosoft.AspNetCore.SignalR.Protocol.CancelInvocationMessage.CancelInvocationMessage(string! invocationId) -> void\n\nMicrosoft.AspNetCore.SignalR.Protocol.CloseMessage\nMicrosoft.AspNetCore.SignalR.Protocol.CloseMessage.AllowReconnect.get -> bool\nMicrosoft.AspNetCore.SignalR.Protocol.CloseMessage.CloseMessage(string? error) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.CloseMessage.CloseMessage(string? error, bool allowReconnect) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.CloseMessage.Error.get -> string?\n\nMicrosoft.AspNetCore.SignalR.Protocol.CompletionMessage\nMicrosoft.AspNetCore.SignalR.Protocol.CompletionMessage.CompletionMessage(string! invocationId, string? error, object? result, bool hasResult) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.CompletionMessage.Error.get -> string?\nMicrosoft.AspNetCore.SignalR.Protocol.CompletionMessage.HasResult.get -> bool\nMicrosoft.AspNetCore.SignalR.Protocol.CompletionMessage.Result.get -> object?\noverride Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.ToString() -> string!\nstatic Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.Empty(string! invocationId) -> Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage!\nstatic Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.WithError(string! invocationId, string? error) -> Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage!\n\nMicrosoft.AspNetCore.SignalR.Protocol.PingMessage\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive to enable nullable reference type checking at the file level. This enforces strict null checking for reference types in C#.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Authentication.Abstractions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in ASP.NET Core\nDESCRIPTION: This method processes invalid form request bodies, either throwing a BadHttpRequestException or logging the error. It includes parameter type and name information in the error message and uses a predefined LoggerMessage for efficient logging.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n\nprivate static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n    LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a custom attribute 'InterceptsLocationAttribute' used for method interception. It takes a version and data string as parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleEnumParam_StringReturn.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet1 Extension Method in C#\nDESCRIPTION: Implements a route builder extension method for handling asynchronous GET requests. Similar to MapGet0 but designed for async Task<string> return types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_NoParam_StringReturn.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet1(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    // ... [truncated for brevity]\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive to enable nullable reference type checking for the current file scope. This ensures better null-safety by making nullability explicit in the type system.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HealthChecks.EntityFrameworkCore/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Extending IHubClients with Users Methods in C#\nDESCRIPTION: Extension methods for IHubClients<T> to send messages to multiple users. These methods provide overloads for specifying up to 8 user IDs individually or using an IEnumerable<string>.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.HubClientsExtensions.Users<T>(this Microsoft.AspNetCore.SignalR.IHubClients<T>! hubClients, string! user1) -> T\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Non-Form Content Types in ASP.NET Core\nDESCRIPTION: Processes cases where the content type of a request doesn't match expected form media types. Based on configuration, it either throws a BadHttpRequestException with a 415 status code or logs a debug message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C# for ASP.NET Core\nDESCRIPTION: This directive enables nullable reference types for the entire file or project. It helps catch potential null reference exceptions at compile-time by making reference types non-nullable by default.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Http.Connections.Client/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Route or Query Parameter Resolution\nDESCRIPTION: Creates a function to resolve parameter values from either route values or query string based on parameter name presence in route parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsDifferentInterceptorsFromSameLocation.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Func<HttpContext, StringValues> ResolveFromRouteOrQuery(string parameterName, IEnumerable<string>? routeParameterNames)\n{\n    return routeParameterNames?.Contains(parameterName, StringComparer.OrdinalIgnoreCase) == true\n        ? (httpContext) => new StringValues((string?)httpContext.Request.RouteValues[parameterName])\n        : (httpContext) => httpContext.Request.Query[parameterName];\n}\n```\n\n----------------------------------------\n\nTITLE: OAuth Handler Implementation\nDESCRIPTION: Virtual and override methods for handling OAuth authentication flow including challenge, ticket creation, and code exchange\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OAuth/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authentication.OAuth.OAuthHandler<TOptions>.BuildChallengeUrl(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, string! redirectUri) -> string!\nvirtual Microsoft.AspNetCore.Authentication.OAuth.OAuthHandler<TOptions>.CreateTicketAsync(System.Security.Claims.ClaimsIdentity! identity, Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, Microsoft.AspNetCore.Authentication.OAuth.OAuthTokenResponse! tokens) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authentication.AuthenticationTicket!>!\n```\n\n----------------------------------------\n\nTITLE: Implementing Core Route Mapping in ASP.NET Core\nDESCRIPTION: Core implementation for mapping routes with support for HTTP methods, metadata population, and request delegate creation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UseRequestDecompression Extension Method in C#\nDESCRIPTION: This extension method adds request decompression middleware to the application pipeline. It's part of the Microsoft.AspNetCore.Builder namespace.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/RequestDecompression/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.RequestDecompressionBuilderExtensions.UseRequestDecompression(this Microsoft.AspNetCore.Builder.IApplicationBuilder! builder) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Action for Invalid Form Request Body in ASP.NET Core\nDESCRIPTION: This code defines a static readonly Action for logging invalid form request bodies. It uses LoggerMessage.Define to create a structured log message with parameter type and name information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n    LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Enabling C# Nullable Reference Types\nDESCRIPTION: Compiler directive that enables nullable reference type checks, requiring developers to explicitly handle potential null values.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Cors/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocationAttribute for ASP.NET Core Source Generators\nDESCRIPTION: A compiler-generated attribute class used for interceptor location in ASP.NET Core source generators. This attribute is used to mark methods that intercept other methods and specify version and data information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Negotiate Authentication Extension Methods\nDESCRIPTION: Extension methods for adding Negotiate authentication to ASP.NET Core authentication builder.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Negotiate/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.NegotiateExtensions.AddNegotiate(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.NegotiateExtensions.AddNegotiate(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, string! authenticationScheme, System.Action<Microsoft.AspNetCore.Authentication.Negotiate.NegotiateOptions!>! configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.NegotiateExtensions.AddNegotiate(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, string! authenticationScheme, string? displayName, System.Action<Microsoft.AspNetCore.Authentication.Negotiate.NegotiateOptions!>! configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Message for Invalid Form Request Body\nDESCRIPTION: Creates a static logger message definition for when a parameter cannot be properly read from the request body as form data. Optimizes logging using LoggerMessage.Define with multiple parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n    LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive that enables nullable reference type checking to help prevent null reference exceptions. This feature requires C# 8.0 or later.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/StaticFiles/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Building Filter Delegate Chain for Endpoint Handlers in C#\nDESCRIPTION: Creates a chain of endpoint filters by applying filter factories in reverse order to the initial endpoint invocation. This enables middleware-like behavior for endpoint request processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n        private static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n        {\n            var routeHandlerFilters =  builder.FilterFactories;\n            var context0 = new EndpointFilterFactoryContext\n            {\n                MethodInfo = mi,\n                ApplicationServices = builder.ApplicationServices,\n            };\n            var initialFilteredInvocation = filteredInvocation;\n            for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n            {\n                var filterFactory = routeHandlerFilters[i];\n                filteredInvocation = filterFactory(context0, filteredInvocation);\n            }\n            return filteredInvocation;\n        }\n```\n\n----------------------------------------\n\nTITLE: Static Assets Extension Method Definition\nDESCRIPTION: Extension method for mapping static assets endpoints in ASP.NET Core applications. Allows configuration of static assets with an optional manifest path.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/StaticAssets/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.StaticAssetsEndpointRouteBuilderExtensions.MapStaticAssets(this Microsoft.AspNetCore.Routing.IEndpointRouteBuilder! endpoints, string? staticAssetsManifestPath = null) -> Microsoft.AspNetCore.StaticAssets.StaticAssetsEndpointConventionBuilder!\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Implicit Body in ASP.NET Core\nDESCRIPTION: Handles cases where an implicit body parameter is expected but not provided. Takes parameter name as input and either throws an exception or logs the error.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndPut_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic void ImplicitBodyNotProvided(string parameterName)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive to enable nullable reference type checking. This improves type safety by requiring explicit handling of potentially null values.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Antiforgery/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing BearerTokenEvents Class in C#\nDESCRIPTION: Defines the BearerTokenEvents class which provides hooks for customizing Bearer Token authentication behavior. It includes an event for handling message received during authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/BearerToken/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.BearerToken.BearerTokenEvents\nMicrosoft.AspNetCore.Authentication.BearerToken.BearerTokenEvents.BearerTokenEvents() -> void\nMicrosoft.AspNetCore.Authentication.BearerToken.BearerTokenEvents.OnMessageReceived.get -> System.Func<Microsoft.AspNetCore.Authentication.BearerToken.MessageReceivedContext!, System.Threading.Tasks.Task!>!\nMicrosoft.AspNetCore.Authentication.BearerToken.BearerTokenEvents.OnMessageReceived.set -> void\nvirtual Microsoft.AspNetCore.Authentication.BearerToken.BearerTokenEvents.MessageReceivedAsync(Microsoft.AspNetCore.Authentication.BearerToken.MessageReceivedContext! context) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocation Attribute in C#\nDESCRIPTION: Auto-generated attribute class used for method interception with version and data parameters. This attribute is sealed and can be applied multiple times to methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class InterceptsLocationAttribute : Attribute\n{\n    public InterceptsLocationAttribute(int version, string data)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Middleware Analysis Extensions for ASP.NET Core in C#\nDESCRIPTION: This snippet defines an extension method for IServiceCollection to add middleware analysis services to the dependency injection container. It allows easy integration of middleware analysis into ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/MiddlewareAnalysis/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.DependencyInjection.AnalysisServiceCollectionExtensions\nstatic Microsoft.Extensions.DependencyInjection.AnalysisServiceCollectionExtensions.AddMiddlewareAnalysis(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Defining QueryStringRequestCultureProvider Class in C#\nDESCRIPTION: Defines the QueryStringRequestCultureProvider class for handling query string-based culture selection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Localization.QueryStringRequestCultureProvider\nMicrosoft.AspNetCore.Localization.QueryStringRequestCultureProvider.QueryStringKey.get -> string!\nMicrosoft.AspNetCore.Localization.QueryStringRequestCultureProvider.QueryStringKey.set -> void\nMicrosoft.AspNetCore.Localization.QueryStringRequestCultureProvider.QueryStringRequestCultureProvider() -> void\nMicrosoft.AspNetCore.Localization.QueryStringRequestCultureProvider.UIQueryStringKey.get -> string!\nMicrosoft.AspNetCore.Localization.QueryStringRequestCultureProvider.UIQueryStringKey.set -> void\n```\n\n----------------------------------------\n\nTITLE: Exception Handling and Logging in ASP.NET Core Request Processing\nDESCRIPTION: Handles and logs exceptions during request processing. Provides methods for logging IO exceptions and invalid JSON request bodies, with options to either log or throw exceptions based on configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n\n```\n\n----------------------------------------\n\nTITLE: Modifying User Data in ASP.NET Core Identity EntityFrameworkCore\nDESCRIPTION: This snippet shows the signatures of overridden methods in the UserStore class for modifying user-related data such as removing claims, roles, logins, and updating user information. These methods interact with the underlying EntityFrameworkCore database to perform update and delete operations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.RemoveClaimsAsync(TUser! user, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim!>! claims, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.RemoveFromRoleAsync(TUser! user, string! normalizedRoleName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.RemoveLoginAsync(TUser! user, string! loginProvider, string! providerKey, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.RemoveUserTokenAsync(TUserToken! token) -> System.Threading.Tasks.Task!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.ReplaceClaimAsync(TUser! user, System.Security.Claims.Claim! claim, System.Security.Claims.Claim! newClaim, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.UpdateAsync(TUser! user, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Implementation\nDESCRIPTION: Class for handling parameter binding metadata including name, type information, and binding capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n    public bool HasTryParse { get; }\n    public bool HasBindAsync { get; }\n    public ParameterInfo ParameterInfo { get; }\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: HandshakeProtocol Static Methods in SignalR Protocol - C#\nDESCRIPTION: Static methods for the HandshakeProtocol class that handle serialization, deserialization, and processing of SignalR handshake messages. These methods manage the protocol-level communication at the beginning of SignalR connections.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.GetSuccessfulHandshake(Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol! protocol) -> System.ReadOnlySpan<byte>\nstatic Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.TryParseRequestMessage(ref System.Buffers.ReadOnlySequence<byte> buffer, out Microsoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage? requestMessage) -> bool\nstatic Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.TryParseResponseMessage(ref System.Buffers.ReadOnlySequence<byte> buffer, out Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage? responseMessage) -> bool\nstatic Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.WriteRequestMessage(Microsoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage! requestMessage, System.Buffers.IBufferWriter<byte>! output) -> void\nstatic Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.WriteResponseMessage(Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage! responseMessage, System.Buffers.IBufferWriter<byte>! output) -> void\n```\n\n----------------------------------------\n\nTITLE: HTTP Response Trailer Extensions in ASP.NET Core\nDESCRIPTION: Extension methods for working with HTTP trailers in responses, enabling trailer declaration, appending trailer values, and checking for trailer support.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.ResponseTrailerExtensions.AppendTrailer(this Microsoft.AspNetCore.Http.HttpResponse! response, string! trailerName, Microsoft.Extensions.Primitives.StringValues trailerValues) -> void\nstatic Microsoft.AspNetCore.Http.ResponseTrailerExtensions.DeclareTrailer(this Microsoft.AspNetCore.Http.HttpResponse! response, string! trailerName) -> void\nstatic Microsoft.AspNetCore.Http.ResponseTrailerExtensions.SupportsTrailers(this Microsoft.AspNetCore.Http.HttpResponse! response) -> bool\n```\n\n----------------------------------------\n\nTITLE: Activating Local .NET SDK Installation\nDESCRIPTION: Commands to activate the locally installed .NET SDK in Linux/Mac and Windows environments.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/BuildFromSource.md#2025-04-08_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Linux or Mac\nsource activate.sh\n```\n\nLANGUAGE: powershell\nCODE:\n```\n# Windows - note the leading period followed by a space\n. ./activate.ps1\n```\n\n----------------------------------------\n\nTITLE: Defining Identity Data Transfer Objects in C#\nDESCRIPTION: Definitions for various data transfer objects used in ASP.NET Core Identity, including ForgotPasswordRequest, LoginRequest, RegisterRequest, and others. These classes represent request and response structures for identity operations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.Data.ForgotPasswordRequest\nMicrosoft.AspNetCore.Identity.Data.ForgotPasswordRequest.Email.get -> string!\nMicrosoft.AspNetCore.Identity.Data.ForgotPasswordRequest.Email.init -> void\nMicrosoft.AspNetCore.Identity.Data.ForgotPasswordRequest.ForgotPasswordRequest() -> void\n\nMicrosoft.AspNetCore.Identity.Data.LoginRequest\nMicrosoft.AspNetCore.Identity.Data.LoginRequest.Email.get -> string!\nMicrosoft.AspNetCore.Identity.Data.LoginRequest.Email.init -> void\nMicrosoft.AspNetCore.Identity.Data.LoginRequest.LoginRequest() -> void\nMicrosoft.AspNetCore.Identity.Data.LoginRequest.Password.get -> string!\nMicrosoft.AspNetCore.Identity.Data.LoginRequest.Password.init -> void\nMicrosoft.AspNetCore.Identity.Data.LoginRequest.TwoFactorCode.get -> string?\nMicrosoft.AspNetCore.Identity.Data.LoginRequest.TwoFactorCode.init -> void\nMicrosoft.AspNetCore.Identity.Data.LoginRequest.TwoFactorRecoveryCode.get -> string?\nMicrosoft.AspNetCore.Identity.Data.LoginRequest.TwoFactorRecoveryCode.init -> void\n\nMicrosoft.AspNetCore.Identity.Data.RegisterRequest\nMicrosoft.AspNetCore.Identity.Data.RegisterRequest.Email.get -> string!\nMicrosoft.AspNetCore.Identity.Data.RegisterRequest.Email.init -> void\nMicrosoft.AspNetCore.Identity.Data.RegisterRequest.Password.get -> string!\nMicrosoft.AspNetCore.Identity.Data.RegisterRequest.Password.init -> void\nMicrosoft.AspNetCore.Identity.Data.RegisterRequest.RegisterRequest() -> void\n```\n\n----------------------------------------\n\nTITLE: Implicit Body Validation Handler in C#\nDESCRIPTION: Handles cases where an implicit body parameter is expected but not provided. Provides guidance about potentially using a Service instead.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_QueryNotPresent.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic void ImplicitBodyNotProvided(string parameterName)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WebAssembly Hot Reload in C#\nDESCRIPTION: Defines methods for implementing hot reload functionality in WebAssembly applications. This includes methods for applying hot reload deltas and retrieving update capabilities, which are crucial for enabling live updates in WebAssembly-based applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.WebAssembly.HotReload.WebAssemblyHotReload\nstatic Microsoft.AspNetCore.Components.WebAssembly.HotReload.WebAssemblyHotReload.ApplyHotReloadDelta(string! moduleIdString, byte[]! metadataDelta, byte[]! ilDelta, byte[]! pdbBytes, int[]? updatedTypes) -> void\nstatic Microsoft.AspNetCore.Components.WebAssembly.HotReload.WebAssemblyHotReload.GetApplyUpdateCapabilities() -> string!\n```\n\n----------------------------------------\n\nTITLE: Creating Binders for Numeric Types in ASP.NET Core Components\nDESCRIPTION: Extension methods for EventCallbackFactory that create data binding callbacks for numeric types (int, long, short, float) in both nullable and non-nullable forms. These methods handle converting input values from form elements to the appropriate numeric type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<float>! setter, float existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<int?>! setter, int? existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<int>! setter, int existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<long?>! setter, long? existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<long>! setter, long existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<short?>! setter, short? existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<short>! setter, short existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\n```\n\n----------------------------------------\n\nTITLE: Implementing CORS Middleware Extensions in C#\nDESCRIPTION: Defines extension methods for using CORS middleware in the ASP.NET Core application pipeline with different configuration options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.CorsMiddlewareExtensions.UseCors(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.CorsMiddlewareExtensions.UseCors(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app, string! policyName) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.CorsMiddlewareExtensions.UseCors(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app, System.Action<Microsoft.AspNetCore.Cors.Infrastructure.CorsPolicyBuilder!>! configurePolicy) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: RenderMode Enum Values\nDESCRIPTION: Defines rendering mode options for Blazor components including Server, Static, WebAssembly and their prerendered variants.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Rendering.RenderMode.Server = 2 -> Microsoft.AspNetCore.Mvc.Rendering.RenderMode\nMicrosoft.AspNetCore.Mvc.Rendering.RenderMode.ServerPrerendered = 3 -> Microsoft.AspNetCore.Mvc.Rendering.RenderMode\nMicrosoft.AspNetCore.Mvc.Rendering.RenderMode.Static = 1 -> Microsoft.AspNetCore.Mvc.Rendering.RenderMode\nMicrosoft.AspNetCore.Mvc.Rendering.RenderMode.WebAssembly = 4 -> Microsoft.AspNetCore.Mvc.Rendering.RenderMode\nMicrosoft.AspNetCore.Mvc.Rendering.RenderMode.WebAssemblyPrerendered = 5 -> Microsoft.AspNetCore.Mvc.Rendering.RenderMode\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocationAttribute in C#\nDESCRIPTION: Custom attribute class for method interception that stores version and data information. Used for compiler-generated code to mark interception points.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class InterceptsLocationAttribute : Attribute\n{\n    public InterceptsLocationAttribute(int version, string data)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: InvalidModelStateFilterConvention Class Definition in ASP.NET Core MVC\nDESCRIPTION: A convention that adds a filter to handle invalid model state automatically in MVC actions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ApplicationModels.InvalidModelStateFilterConvention\nMicrosoft.AspNetCore.Mvc.ApplicationModels.InvalidModelStateFilterConvention.Apply(Microsoft.AspNetCore.Mvc.ApplicationModels.ActionModel! action) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.InvalidModelStateFilterConvention.InvalidModelStateFilterConvention() -> void\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants for ASP.NET Core Request Processing\nDESCRIPTION: Generated static class providing standard content type string arrays for various common MIME types used in HTTP requests and responses, including JSON, plaintext, form data, and URL-encoded form content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/HandlesEndpointsWithAndWithoutDiagnostics.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\n    file static class GeneratedMetadataConstants\n    {\n        public static readonly string[] JsonContentType = new [] { \"application/json\" };\n        public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n        public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n        public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating Request Delegate Factory Function in ASP.NET Core\nDESCRIPTION: Defines a request delegate factory function that handles setting up service resolution, JSON serialization options, and endpoint filtering. It prepares the runtime environment for handling HTTP requests with the specified parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nRequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n{\n    Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n    Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n    Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n    Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n    var handler = Cast(del, void (global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType arg0) => throw null!);\n    EndpointFilterDelegate? filteredInvocation = null;\n    var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n    var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n    var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n    var jsonSerializerOptions = jsonOptions.SerializerOptions;\n    jsonSerializerOptions.MakeReadOnly();\n    var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n    var serviceProviderIsService = serviceProvider?.GetService<IServiceProviderIsService>();\n    var Value_JsonBodyOrServiceResolver = ResolveJsonBodyOrService<global::Microsoft.AspNetCore.Http.Generators.Tests.AddsCustomParameterMetadataAsProperty>(logOrThrowExceptionHelper, \"AddsCustomParameterMetadataAsProperty\", \"Value\", jsonSerializerOptions, serviceProviderIsService);\n\n    if (options.EndpointBuilder.FilterFactories.Count > 0)\n    {\n        filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n        {\n            if (ic.HttpContext.Response.StatusCode == 400)\n            {\n                return ValueTask.FromResult<object?>(Results.Empty);\n            }\n            handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType>(0)!);\n            return ValueTask.FromResult<object?>(Results.Empty);\n        },\n        options.EndpointBuilder,\n        handler.Method);\n    }\n```\n\n----------------------------------------\n\nTITLE: HTTP Response Methods in PageBase Class\nDESCRIPTION: Virtual methods for generating HTTP responses with specific status codes and content. Includes methods for returning specific status codes and attaching object values to the response.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.StatusCode(int statusCode) -> Microsoft.AspNetCore.Mvc.StatusCodeResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.StatusCode(int statusCode, object! value) -> Microsoft.AspNetCore.Mvc.ObjectResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.Unauthorized() -> Microsoft.AspNetCore.Mvc.UnauthorizedResult!\n```\n\n----------------------------------------\n\nTITLE: Implementing ResourceManagerStringLocalizer Class in C#\nDESCRIPTION: Defines a class for managing string localization using resource managers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Localization/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Localization.ResourceManagerStringLocalizer.GetAllStrings(bool includeParentCultures, System.Globalization.CultureInfo! culture) -> System.Collections.Generic.IEnumerable<Microsoft.Extensions.Localization.LocalizedString!>!\nMicrosoft.Extensions.Localization.ResourceManagerStringLocalizer.GetStringSafely(string! name, System.Globalization.CultureInfo? culture) -> string?\nMicrosoft.Extensions.Localization.ResourceManagerStringLocalizer.ResourceManagerStringLocalizer(System.Resources.ResourceManager! resourceManager, System.Reflection.Assembly! resourceAssembly, string! baseName, Microsoft.Extensions.Localization.IResourceNamesCache! resourceNamesCache, Microsoft.Extensions.Logging.ILogger! logger) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON Type Info Extensions\nDESCRIPTION: Collection of extension methods for JsonTypeInfo class handling polymorphism and type checking. Includes methods for checking known polymorphism and type matching.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsValidationProblemResult_Has_Metadata.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\n----------------------------------------\n\nTITLE: Referencing RouteData Type in ASP.NET Core\nDESCRIPTION: Code reference showing the RouteData type usage in ASP.NET Core for route handling and URL generation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/test/WebSites/BasicWebSite/readme.md#2025-04-08_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nRouteData\n```\n\n----------------------------------------\n\nTITLE: RouterMiddleware Implementation\nDESCRIPTION: Implementation of middleware component that handles routing in ASP.NET Core applications. Includes constructor and invoke method definitions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Builder.RouterMiddleware.RouterMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory, Microsoft.AspNetCore.Routing.IRouter! router) -> void\nMicrosoft.AspNetCore.Builder.RouterMiddleware.Invoke(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining ServerStreamingMethodInvoker class for gRPC server streaming in C#\nDESCRIPTION: Implements a specialized MethodInvoker for server streaming gRPC methods. This class handles method invocation where the server sends multiple responses in a stream to a client.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Transport.Sockets/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected JSON Content Type in C#\nDESCRIPTION: This method handles cases where an unexpected JSON content type is received. It throws a BadHttpRequestException with a 415 status code or logs the issue.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedJsonContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Parameter Binding Failures in ASP.NET Core\nDESCRIPTION: Handles cases where parameter binding fails by either throwing a BadHttpRequestException or logging the failure. Takes parameter type, name, and source value as inputs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndPut_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CookieRequestCultureProvider Class in C#\nDESCRIPTION: Defines the CookieRequestCultureProvider class with properties and methods for handling cookie-based culture selection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Localization.CookieRequestCultureProvider\nMicrosoft.AspNetCore.Localization.CookieRequestCultureProvider.CookieName.get -> string!\nMicrosoft.AspNetCore.Localization.CookieRequestCultureProvider.CookieName.set -> void\nMicrosoft.AspNetCore.Localization.CookieRequestCultureProvider.CookieRequestCultureProvider() -> void\n```\n\n----------------------------------------\n\nTITLE: Defining CustomRequestCultureProvider Class in C#\nDESCRIPTION: Defines the CustomRequestCultureProvider class for creating custom culture providers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Localization.CustomRequestCultureProvider\nMicrosoft.AspNetCore.Localization.CustomRequestCultureProvider.CustomRequestCultureProvider(System.Func<Microsoft.AspNetCore.Http.HttpContext!, System.Threading.Tasks.Task<Microsoft.AspNetCore.Localization.ProviderCultureResult?>!>! provider) -> void\n```\n\n----------------------------------------\n\nTITLE: SignalR Protocol Static Members and Constants - C#\nDESCRIPTION: Static readonly fields that provide singleton instances of common SignalR protocol messages. These predefined message instances are used for standard protocol operations like empty responses, pings, and connection closures.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.SignalR.Protocol.CloseMessage.Empty -> Microsoft.AspNetCore.SignalR.Protocol.CloseMessage!\nstatic readonly Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage.Empty -> Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage!\nstatic readonly Microsoft.AspNetCore.SignalR.Protocol.PingMessage.Instance -> Microsoft.AspNetCore.SignalR.Protocol.PingMessage!\n```\n\n----------------------------------------\n\nTITLE: Request Handling Error Logging in ASP.NET Core\nDESCRIPTION: Helper class for consistent error handling during request processing. It provides methods to either log or throw exceptions based on configuration for various error scenarios like invalid JSON, parameter binding failures, and missing required parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleNullableStringParam_WithEmptyQueryStringValueProvided_StringReturn.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n\n    public void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n\n    public void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n\n    public void ImplicitBodyNotProvided(string parameterName)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n\n    public void UnexpectedJsonContentType(string? contentType)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n            throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n\n    public void UnexpectedNonFormContentType(string? contentType)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n            throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n\n    public void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Logging Unexpected Content Type in ASP.NET Core\nDESCRIPTION: Defines a logger message for unexpected content types in HTTP requests. This creates a structured logging pattern for when the server receives a request with an unsupported JSON media type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitBodyParam_ComplexReturn_Snapshot.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nLoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Defining URL Prefix Collection Class in C#\nDESCRIPTION: Collection class for managing HTTP.sys URL prefixes, implementing standard collection methods for adding, removing, and enumerating URL prefixes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/HttpSys/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefixCollection\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.Add(Microsoft.AspNetCore.Server.HttpSys.UrlPrefix! item) -> void\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.Add(string! prefix) -> void\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.Clear() -> void\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.Contains(Microsoft.AspNetCore.Server.HttpSys.UrlPrefix! item) -> bool\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.CopyTo(Microsoft.AspNetCore.Server.HttpSys.UrlPrefix![]! array, int arrayIndex) -> void\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.Count.get -> int\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.GetEnumerator() -> System.Collections.Generic.IEnumerator<Microsoft.AspNetCore.Server.HttpSys.UrlPrefix!>!\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.IsReadOnly.get -> bool\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.Remove(Microsoft.AspNetCore.Server.HttpSys.UrlPrefix! item) -> bool\nMicrosoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.Remove(string! prefix) -> bool\n```\n\n----------------------------------------\n\nTITLE: Defining IServer Interface in ASP.NET Core\nDESCRIPTION: Core interface that all server implementations must implement. It defines methods for starting and stopping the server asynchronously, as well as accessing server features through a feature collection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Server.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Hosting.Server.IServer\nMicrosoft.AspNetCore.Hosting.Server.IServer.Features.get -> Microsoft.AspNetCore.Http.Features.IFeatureCollection!\nMicrosoft.AspNetCore.Hosting.Server.IServer.StartAsync<TContext>(Microsoft.AspNetCore.Hosting.Server.IHttpApplication<TContext>! application, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Hosting.Server.IServer.StopAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining HtmlString Class in C#\nDESCRIPTION: This snippet defines the HtmlString class, which represents a string of HTML content. It includes a constructor, a property to access the value, and methods for writing and converting to string.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Html.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Html.HtmlString\nMicrosoft.AspNetCore.Html.HtmlString.HtmlString(string? value) -> void\nMicrosoft.AspNetCore.Html.HtmlString.Value.get -> string?\nMicrosoft.AspNetCore.Html.HtmlString.WriteTo(System.IO.TextWriter! writer, System.Text.Encodings.Web.HtmlEncoder! encoder) -> void\noverride Microsoft.AspNetCore.Html.HtmlString.ToString() -> string!\nstatic readonly Microsoft.AspNetCore.Html.HtmlString.Empty -> Microsoft.AspNetCore.Html.HtmlString!\nstatic readonly Microsoft.AspNetCore.Html.HtmlString.NewLine -> Microsoft.AspNetCore.Html.HtmlString!\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Class\nDESCRIPTION: Class implementing IParameterBindingMetadata to store parameter binding information including name, type info, and binding capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsDifferentInterceptorsFromSameLocation.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n    public bool HasTryParse { get; }\n    public bool HasBindAsync { get; }\n    public ParameterInfo ParameterInfo { get; }\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Non-Form Content Type in ASP.NET Core\nDESCRIPTION: Handles cases where a form media type was expected but a different content type was received. Either throws a BadHttpRequestException or logs the issue based on configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core Routing Interface Definitions\nDESCRIPTION: Collection of interface method signatures for ASP.NET Core routing system components. Includes abstract methods for endpoint data sources, link parsing, matcher policies, and route pattern transformation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Routing.EndpointDataSource.Endpoints.get -> System.Collections.Generic.IReadOnlyList<Microsoft.AspNetCore.Http.Endpoint!>!\nabstract Microsoft.AspNetCore.Routing.EndpointDataSource.GetChangeToken() -> Microsoft.Extensions.Primitives.IChangeToken!\nabstract Microsoft.AspNetCore.Routing.LinkParser.ParsePathByAddress<TAddress>(TAddress address, Microsoft.AspNetCore.Http.PathString path) -> Microsoft.AspNetCore.Routing.RouteValueDictionary?\nabstract Microsoft.AspNetCore.Routing.MatcherPolicy.Order.get -> int\nabstract Microsoft.AspNetCore.Routing.Matching.EndpointSelector.SelectAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext, Microsoft.AspNetCore.Routing.Matching.CandidateSet! candidates) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining AddRequestDecompression Extension Methods in C#\nDESCRIPTION: These extension methods add request decompression services to the service collection. They're part of the Microsoft.Extensions.DependencyInjection namespace.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/RequestDecompression/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.RequestDecompressionServiceExtensions.AddRequestDecompression(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.RequestDecompressionServiceExtensions.AddRequestDecompression(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.RequestDecompression.RequestDecompressionOptions!>! configureOptions) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Login Model Implementation\nDESCRIPTION: Defines the login model class with properties for email, password, and remember me functionality. Includes input validation and external login support.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.UI.V4.Pages.Account.Internal.LoginModel.InputModel\nMicrosoft.AspNetCore.Identity.UI.V4.Pages.Account.Internal.LoginModel.InputModel.Email.get -> string!\nMicrosoft.AspNetCore.Identity.UI.V4.Pages.Account.Internal.LoginModel.InputModel.Email.set -> void\nMicrosoft.AspNetCore.Identity.UI.V4.Pages.Account.Internal.LoginModel.InputModel.Password.get -> string!\nMicrosoft.AspNetCore.Identity.UI.V4.Pages.Account.Internal.LoginModel.InputModel.Password.set -> void\nMicrosoft.AspNetCore.Identity.UI.V4.Pages.Account.Internal.LoginModel.InputModel.RememberMe.get -> bool\nMicrosoft.AspNetCore.Identity.UI.V4.Pages.Account.Internal.LoginModel.InputModel.RememberMe.set -> void\n```\n\n----------------------------------------\n\nTITLE: Authentication Methods in PageBase Class\nDESCRIPTION: Virtual methods for handling authentication in Razor Pages, including SignIn and SignOut functionality with various overloads for specifying authentication schemes and properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.SignIn(System.Security.Claims.ClaimsPrincipal! principal, Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, string! authenticationScheme) -> Microsoft.AspNetCore.Mvc.SignInResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.SignIn(System.Security.Claims.ClaimsPrincipal! principal, string! authenticationScheme) -> Microsoft.AspNetCore.Mvc.SignInResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.SignOut(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, params string![]! authenticationSchemes) -> Microsoft.AspNetCore.Mvc.SignOutResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.SignOut(params string![]! authenticationSchemes) -> Microsoft.AspNetCore.Mvc.SignOutResult!\n```\n\n----------------------------------------\n\nTITLE: Defining Conflict Result Methods in C#\nDESCRIPTION: These methods create Conflict (HTTP 409) results with optional error content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.Conflict() -> Microsoft.AspNetCore.Http.HttpResults.Conflict!\nstatic Microsoft.AspNetCore.Http.TypedResults.Conflict<TValue>(TValue? error) -> Microsoft.AspNetCore.Http.HttpResults.Conflict<TValue>!\n```\n\n----------------------------------------\n\nTITLE: Creating Completion Message with Result in SignalR Protocol\nDESCRIPTION: Static method to create a CompletionMessage with a result payload for a given invocation ID in the SignalR protocol.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.WithResult(string! invocationId, object? payload) -> Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage!\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Implementation\nDESCRIPTION: Implements IParameterBindingMetadata interface to store metadata about parameter binding capabilities and requirements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/RequestDelegateValidateGeneratedFormCode.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining XML Decryption in C# for ASP.NET Core Data Protection\nDESCRIPTION: This snippet defines classes for XML decryption in the Microsoft.AspNetCore.DataProtection.XmlEncryption namespace. It includes implementations for DPAPI, DPAPI-NG, and generic EncryptedXml decryption methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlDecryptor\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlDecryptor.Decrypt(System.Xml.Linq.XElement! encryptedElement) -> System.Xml.Linq.XElement!\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlDecryptor.DpapiNGXmlDecryptor() -> void\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlDecryptor.DpapiNGXmlDecryptor(System.IServiceProvider? services) -> void\n\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlDecryptor\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlDecryptor.Decrypt(System.Xml.Linq.XElement! encryptedElement) -> System.Xml.Linq.XElement!\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlDecryptor.DpapiXmlDecryptor() -> void\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlDecryptor.DpapiXmlDecryptor(System.IServiceProvider? services) -> void\n\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlDecryptor\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlDecryptor.Decrypt(System.Xml.Linq.XElement! encryptedElement) -> System.Xml.Linq.XElement!\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlDecryptor.EncryptedXmlDecryptor() -> void\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlDecryptor.EncryptedXmlDecryptor(System.IServiceProvider? services) -> void\n```\n\n----------------------------------------\n\nTITLE: StackExchangeRedisDataProtectionBuilderExtensions in ASP.NET Core\nDESCRIPTION: Extension methods for IDataProtectionBuilder to configure Redis as the storage mechanism for data protection keys. Provides several overloads for different Redis connection scenarios.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/StackExchangeRedis/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.DataProtection.StackExchangeRedisDataProtectionBuilderExtensions\nstatic Microsoft.AspNetCore.DataProtection.StackExchangeRedisDataProtectionBuilderExtensions.PersistKeysToStackExchangeRedis(this Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder! builder, StackExchange.Redis.IConnectionMultiplexer! connectionMultiplexer) -> Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder!\nstatic Microsoft.AspNetCore.DataProtection.StackExchangeRedisDataProtectionBuilderExtensions.PersistKeysToStackExchangeRedis(this Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder! builder, StackExchange.Redis.IConnectionMultiplexer! connectionMultiplexer, StackExchange.Redis.RedisKey key) -> Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder!\nstatic Microsoft.AspNetCore.DataProtection.StackExchangeRedisDataProtectionBuilderExtensions.PersistKeysToStackExchangeRedis(this Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder! builder, System.Func<StackExchange.Redis.IDatabase!>! databaseFactory, StackExchange.Redis.RedisKey key) -> Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder!\n```\n\n----------------------------------------\n\nTITLE: Registration Models in ASP.NET Core Identity UI\nDESCRIPTION: Defines model classes for user registration functionality including RegisterModel, RegisterConfirmationModel, and related input models with properties for email, password, and confirmation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.RegisterModel.InputModel\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.RegisterModel.InputModel.Email.get -> string!\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.RegisterModel.InputModel.Password.get -> string!\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.RegisterModel.InputModel.ConfirmPassword.get -> string?\n```\n\n----------------------------------------\n\nTITLE: Identity Service Configuration Extensions\nDESCRIPTION: Extension methods for configuring Identity services in ASP.NET Core dependency injection. Provides methods for adding Identity with various configurations and API endpoints.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.IdentityServiceCollectionExtensions.AddIdentity<TUser, TRole>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.AspNetCore.Identity.IdentityBuilder!\nstatic Microsoft.Extensions.DependencyInjection.IdentityServiceCollectionExtensions.AddIdentityApiEndpoints<TUser>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.AspNetCore.Identity.IdentityBuilder!\n```\n\n----------------------------------------\n\nTITLE: JSObjectReference Extension Methods for Void Operations\nDESCRIPTION: Extension methods for IJSObjectReference to invoke JavaScript functions that don't return values, with support for cancellation tokens and timeouts.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/JSInterop/Microsoft.JSInterop/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.JSInterop.JSObjectReferenceExtensions.InvokeVoidAsync(this Microsoft.JSInterop.IJSObjectReference! jsObjectReference, string! identifier, System.Threading.CancellationToken cancellationToken, params object?[]? args) -> System.Threading.Tasks.ValueTask\nstatic Microsoft.JSInterop.JSObjectReferenceExtensions.InvokeVoidAsync(this Microsoft.JSInterop.IJSObjectReference! jsObjectReference, string! identifier, System.TimeSpan timeout, params object?[]? args) -> System.Threading.Tasks.ValueTask\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Implementation\nDESCRIPTION: Implements parameter binding metadata handling for request processing, including support for TryParse, async binding, and optional parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleEnumParam_StringReturn.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n    public bool HasTryParse { get; }\n    public bool HasBindAsync { get; }\n    public ParameterInfo ParameterInfo { get; }\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: HttpLoggingEndpointConventionBuilderExtensions in ASP.NET Core\nDESCRIPTION: Extension method for endpoint builders that applies HTTP logging to specific endpoints with configurable logging fields and body size limits.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpLogging/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.HttpLoggingEndpointConventionBuilderExtensions.WithHttpLogging<TBuilder>(this TBuilder builder, Microsoft.AspNetCore.HttpLogging.HttpLoggingFields loggingFields, int? requestBodyLogLimit = null, int? responseBodyLogLimit = null) -> TBuilder\n```\n\n----------------------------------------\n\nTITLE: HttpRequestLifetimeFeature in ASP.NET Core\nDESCRIPTION: Feature managing the lifetime of HTTP requests in ASP.NET Core. It provides the ability to abort request processing, which can be triggered by timeouts, cancellation, or other exceptional conditions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Features.HttpRequestLifetimeFeature\nMicrosoft.AspNetCore.Http.Features.HttpRequestLifetimeFeature.Abort() -> void\n```\n\n----------------------------------------\n\nTITLE: Defining IStringLocalizer Interface in C#\nDESCRIPTION: Core interface definition for string localization in ASP.NET Core, providing methods to retrieve localized strings and collections.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Localization/Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Localization.IStringLocalizer.GetAllStrings(bool includeParentCultures) -> System.Collections.Generic.IEnumerable<Microsoft.Extensions.Localization.LocalizedString!>!\nMicrosoft.Extensions.Localization.IStringLocalizer.this[string! name, params object![]! arguments].get -> Microsoft.Extensions.Localization.LocalizedString!\nMicrosoft.Extensions.Localization.IStringLocalizer.this[string! name].get -> Microsoft.Extensions.Localization.LocalizedString!\n```\n\n----------------------------------------\n\nTITLE: Running SignalR Tests in Browser\nDESCRIPTION: Steps to build and run the tests in a browser environment, which provides better debugging capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/JSFunctionalTests.md#2025-04-08_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./build /t:Restore\n```\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh /t:Restore\n```\n\nLANGUAGE: bash\nCODE:\n```\ncd clients/ts\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\nLANGUAGE: bash\nCODE:\n```\ncd FunctionalTests\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON Response Writing with Type Validation in ASP.NET Core\nDESCRIPTION: A private method that writes JSON responses using the appropriate JsonTypeInfo. It evaluates whether the runtime type matches the JsonTypeInfo and handles polymorphism cases.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ProtectedBrowserStorage Class in C#\nDESCRIPTION: Abstract class for protected browser storage operations, including methods for getting, setting, and deleting protected data in browser storage.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorage\nMicrosoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorage.DeleteAsync(string! key) -> System.Threading.Tasks.ValueTask\nMicrosoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorage.GetAsync<TValue>(string! key) -> System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorageResult<TValue>>\nMicrosoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorage.GetAsync<TValue>(string! purpose, string! key) -> System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorageResult<TValue>>\nMicrosoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorage.SetAsync(string! key, object! value) -> System.Threading.Tasks.ValueTask\nMicrosoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorage.SetAsync(string! purpose, string! key, object! value) -> System.Threading.Tasks.ValueTask\n```\n\n----------------------------------------\n\nTITLE: OpenAPI 3.1.1 Schema Definition - User Management API\nDESCRIPTION: Defines REST API endpoints for user management with GET and POST operations. Includes external documentation links, response schemas, and API metadata like version and license information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/test/Microsoft.AspNetCore.OpenApi.Tests/Integration/snapshots/OpenApi3_1/OpenApiDocumentIntegrationTests.VerifyOpenApiDocument_documentName=v2.verified.txt#2025-04-08_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"openapi\": \"3.1.1\",\n  \"info\": {\n    \"title\": \"Sample | v2\",\n    \"contact\": {\n      \"name\": \"OpenAPI Enthusiast\",\n      \"email\": \"iloveopenapi@example.com\"\n    },\n    \"license\": {\n      \"name\": \"MIT\"\n    },\n    \"version\": \"1.0.0\"\n  },\n  \"paths\": {\n    \"/v2/users\": {\n      \"get\": {\n        \"tags\": [\n          \"users\"\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"array\",\n                  \"items\": {\n                    \"type\": \"string\",\n                    \"externalDocs\": {\n                      \"description\": \"Documentation for this OpenAPI schema\",\n                      \"url\": \"https://example.com/api/docs/schemas/string\"\n                    }\n                  },\n                  \"externalDocs\": {\n                    \"description\": \"Documentation for this OpenAPI schema\",\n                    \"url\": \"https://example.com/api/docs/schemas/array\"\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"externalDocs\": {\n          \"description\": \"Documentation for this OpenAPI endpoint\",\n          \"url\": \"https://example.com/api/docs/operations/CreateUser\"\n        },\n        \"operationId\": \"CreateUser\",\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    }\n  },\n  \"tags\": [\n    {\n      \"name\": \"users\"\n    },\n    {\n      \"name\": \"Sample\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Empty HandshakeResponseMessage Instance in SignalR Protocol\nDESCRIPTION: Static readonly field representing an empty HandshakeResponseMessage in the SignalR protocol.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage.Empty -> Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage!\n```\n\n----------------------------------------\n\nTITLE: XML Wrapper Provider Interfaces\nDESCRIPTION: Interface definitions for XML wrapper providers that handle type conversion and wrapping/unwrapping of objects during XML serialization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Formatters.Xml/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IWrapperProvider\n{\n    Type WrappingType { get; }\n    object? Wrap(object? original);\n}\n\npublic interface IWrapperProviderFactory\n{\n    IWrapperProvider? GetProvider(WrapperProviderContext context);\n}\n\npublic interface IUnwrappable\n{\n    object Unwrap(Type declaredType);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring OWIN Middleware in ASP.NET Core Pipeline\nDESCRIPTION: Example showing how to add OWIN middleware to the ASP.NET Core pipeline using the UseOwin extension method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Owin/src/PACKAGE.md#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\napp.UseOwin(pipeline =>\n{\n    pipeline(next => OwinHello);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Schema for ApiResponse Object in Pet Store API\nDESCRIPTION: This snippet defines the JSON schema for an ApiResponse object. It specifies required fields, property types, and formats for the code, message, and type properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Tools/Microsoft.dotnet-openapi/test/TestContent/openapi.json.txt#2025-04-08_snippet_5\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"type\": \"object\",\n  \"additionalProperties\": false,\n  \"required\": [\n    \"code\"\n  ],\n  \"properties\": {\n    \"code\": {\n      \"type\": \"integer\",\n      \"format\": \"int32\"\n    },\n    \"message\": {\n      \"type\": \"string\"\n    },\n    \"type\": {\n      \"type\": \"string\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying CORS Policies to Endpoints in ASP.NET Core\nDESCRIPTION: This code snippet defines extension methods for IEndpointConventionBuilder to apply CORS policies to specific endpoints in ASP.NET Core applications. It allows for configuring CORS policies with default or custom settings for individual routes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Features/JsonPatch/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic static class CorsEndpointConventionBuilderExtensions\n{\n    /// <summary>\n    /// Adds a CORS policy with the specified name to the endpoint(s).\n    /// </summary>\n    /// <param name=\"builder\">The endpoint convention builder.</param>\n    /// <param name=\"policyName\">The name of the policy.</param>\n    /// <returns>The original convention builder parameter.</returns>\n    public static TBuilder RequireCors<TBuilder>(this TBuilder builder, string policyName) where TBuilder : IEndpointConventionBuilder\n    {\n        if (builder == null)\n        {\n            throw new ArgumentNullException(nameof(builder));\n        }\n\n        builder.Add(endpointBuilder =>\n        {\n            endpointBuilder.Metadata.Add(new CorsPolicyMetadata(policyName));\n        });\n        return builder;\n    }\n\n    /// <summary>\n    /// Adds a CORS policy with the specified policy to the endpoint(s).\n    /// </summary>\n    /// <param name=\"builder\">The endpoint convention builder.</param>\n    /// <param name=\"configurePolicy\">A delegate which can use a <see cref=\"CorsPolicyBuilder\"/> to build a policy.</param>\n    /// <returns>The original convention builder parameter.</returns>\n    public static TBuilder RequireCors<TBuilder>(this TBuilder builder, Action<CorsPolicyBuilder> configurePolicy) where TBuilder : IEndpointConventionBuilder\n    {\n        if (builder == null)\n        {\n            throw new ArgumentNullException(nameof(builder));\n        }\n\n        if (configurePolicy == null)\n        {\n            throw new ArgumentNullException(nameof(configurePolicy));\n        }\n\n        var policyBuilder = new CorsPolicyBuilder();\n        configurePolicy(policyBuilder);\n        var policy = policyBuilder.Build();\n\n        builder.Add(endpointBuilder =>\n        {\n            endpointBuilder.Metadata.Add(new CorsPolicyMetadata(policy));\n        });\n        return builder;\n    }\n\n    /// <summary>\n    /// Adds the specified CORS policy to the endpoint(s).\n    /// </summary>\n    /// <param name=\"builder\">The endpoint convention builder.</param>\n    /// <param name=\"policy\">The <see cref=\"CorsPolicy\"/>.</param>\n    /// <returns>The original convention builder parameter.</returns>\n    public static TBuilder RequireCors<TBuilder>(this TBuilder builder, CorsPolicy policy) where TBuilder : IEndpointConventionBuilder\n    {\n        if (builder == null)\n        {\n            throw new ArgumentNullException(nameof(builder));\n        }\n\n        if (policy == null)\n        {\n            throw new ArgumentNullException(nameof(policy));\n        }\n\n        builder.Add(endpointBuilder =>\n        {\n            endpointBuilder.Metadata.Add(new CorsPolicyMetadata(policy));\n        });\n        return builder;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing PowerShell Command to Generate Required Files\nDESCRIPTION: This PowerShell command generates required files before building projects without using build.cmd or build.sh. It skips building native and managed components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/BuildErrors.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n.\\build.cmd -noBuildNative -noBuildManaged\n```\n\n----------------------------------------\n\nTITLE: Defining HtmlContentBuilder Class in C#\nDESCRIPTION: This snippet defines the HtmlContentBuilder class, which implements methods for building and manipulating HTML content. It includes constructors, methods for appending content, and utility functions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Html.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Html.HtmlContentBuilder\nMicrosoft.AspNetCore.Html.HtmlContentBuilder.Append(string? unencoded) -> Microsoft.AspNetCore.Html.IHtmlContentBuilder!\nMicrosoft.AspNetCore.Html.HtmlContentBuilder.AppendHtml(Microsoft.AspNetCore.Html.IHtmlContent? htmlContent) -> Microsoft.AspNetCore.Html.IHtmlContentBuilder!\nMicrosoft.AspNetCore.Html.HtmlContentBuilder.AppendHtml(string? encoded) -> Microsoft.AspNetCore.Html.IHtmlContentBuilder!\nMicrosoft.AspNetCore.Html.HtmlContentBuilder.Clear() -> Microsoft.AspNetCore.Html.IHtmlContentBuilder!\nMicrosoft.AspNetCore.Html.HtmlContentBuilder.CopyTo(Microsoft.AspNetCore.Html.IHtmlContentBuilder! destination) -> void\nMicrosoft.AspNetCore.Html.HtmlContentBuilder.Count.get -> int\nMicrosoft.AspNetCore.Html.HtmlContentBuilder.HtmlContentBuilder() -> void\nMicrosoft.AspNetCore.Html.HtmlContentBuilder.HtmlContentBuilder(int capacity) -> void\nMicrosoft.AspNetCore.Html.HtmlContentBuilder.HtmlContentBuilder(System.Collections.Generic.IList<object!>! entries) -> void\nMicrosoft.AspNetCore.Html.HtmlContentBuilder.MoveTo(Microsoft.AspNetCore.Html.IHtmlContentBuilder! destination) -> void\nMicrosoft.AspNetCore.Html.HtmlContentBuilder.WriteTo(System.IO.TextWriter! writer, System.Text.Encodings.Web.HtmlEncoder! encoder) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining OpenIdConnectHandler Class in C#\nDESCRIPTION: This snippet defines the OpenIdConnectHandler class, which is responsible for handling OpenID Connect authentication. It includes constructors and a property for HTML encoding.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectHandler.HtmlEncoder.get -> System.Text.Encodings.Web.HtmlEncoder!\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectHandler.OpenIdConnectHandler(Microsoft.Extensions.Options.IOptionsMonitor<Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectOptions!>! options, Microsoft.Extensions.Logging.ILoggerFactory! logger, System.Text.Encodings.Web.HtmlEncoder! htmlEncoder, System.Text.Encodings.Web.UrlEncoder! encoder) -> void\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectHandler.OpenIdConnectHandler(Microsoft.Extensions.Options.IOptionsMonitor<Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectOptions!>! options, Microsoft.Extensions.Logging.ILoggerFactory! logger, System.Text.Encodings.Web.HtmlEncoder! htmlEncoder, System.Text.Encodings.Web.UrlEncoder! encoder, Microsoft.AspNetCore.Authentication.ISystemClock! clock) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining SignalR Message Classes in ASP.NET Core (C#)\nDESCRIPTION: Definitions of various message classes used in the SignalR protocol, including base classes and specific message types for invocations, streaming, completion, and connection management.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.Protocol.AckMessage\nMicrosoft.AspNetCore.SignalR.Protocol.AckMessage.AckMessage(long sequenceId) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.AckMessage.SequenceId.get -> long\nMicrosoft.AspNetCore.SignalR.Protocol.AckMessage.SequenceId.set -> void\nMicrosoft.AspNetCore.SignalR.Protocol.CancelInvocationMessage\nMicrosoft.AspNetCore.SignalR.Protocol.CancelInvocationMessage.CancelInvocationMessage(string! invocationId) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.CloseMessage\nMicrosoft.AspNetCore.SignalR.Protocol.CloseMessage.AllowReconnect.get -> bool\nMicrosoft.AspNetCore.SignalR.Protocol.CloseMessage.CloseMessage(string? error) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.CloseMessage.CloseMessage(string? error, bool allowReconnect) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.CloseMessage.Error.get -> string?\nMicrosoft.AspNetCore.SignalR.Protocol.CompletionMessage\nMicrosoft.AspNetCore.SignalR.Protocol.CompletionMessage.CompletionMessage(string! invocationId, string? error, object? result, bool hasResult) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.CompletionMessage.Error.get -> string?\nMicrosoft.AspNetCore.SignalR.Protocol.CompletionMessage.HasResult.get -> bool\nMicrosoft.AspNetCore.SignalR.Protocol.CompletionMessage.Result.get -> object?\nMicrosoft.AspNetCore.SignalR.Protocol.HandshakeProtocol\nMicrosoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage\nMicrosoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage.HandshakeRequestMessage(string! protocol, int version) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage.Protocol.get -> string!\nMicrosoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage.Version.get -> int\nMicrosoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage\nMicrosoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage.Error.get -> string?\nMicrosoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage.HandshakeResponseMessage(string? error) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.HubInvocationMessage\nMicrosoft.AspNetCore.SignalR.Protocol.HubInvocationMessage.Headers.get -> System.Collections.Generic.IDictionary<string!, string!>?\nMicrosoft.AspNetCore.SignalR.Protocol.HubInvocationMessage.Headers.set -> void\nMicrosoft.AspNetCore.SignalR.Protocol.HubInvocationMessage.HubInvocationMessage(string? invocationId) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.HubInvocationMessage.InvocationId.get -> string?\nMicrosoft.AspNetCore.SignalR.Protocol.HubMessage\nMicrosoft.AspNetCore.SignalR.Protocol.HubMessage.HubMessage() -> void\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.Arguments.get -> object?[]!\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.HubMethodInvocationMessage(string? invocationId, string! target, object?[]! arguments) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.HubMethodInvocationMessage(string? invocationId, string! target, object?[]! arguments, string![]? streamIds) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.StreamIds.get -> string![]?\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.Target.get -> string!\nMicrosoft.AspNetCore.SignalR.Protocol.HubProtocolConstants\nMicrosoft.AspNetCore.SignalR.Protocol.HubProtocolExtensions\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationBindingFailureMessage\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationBindingFailureMessage.BindingFailure.get -> System.Runtime.ExceptionServices.ExceptionDispatchInfo!\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationBindingFailureMessage.InvocationBindingFailureMessage(string? invocationId, string! target, System.Runtime.ExceptionServices.ExceptionDispatchInfo! bindingFailure) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationBindingFailureMessage.Target.get -> string!\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationMessage\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationMessage.InvocationMessage(string! target, object?[]! arguments) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationMessage.InvocationMessage(string? invocationId, string! target, object?[]! arguments) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationMessage.InvocationMessage(string? invocationId, string! target, object?[]! arguments, string![]? streamIds) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.PingMessage\nMicrosoft.AspNetCore.SignalR.Protocol.RawResult\nMicrosoft.AspNetCore.SignalR.Protocol.RawResult.RawResult(System.Buffers.ReadOnlySequence<byte> rawBytes) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.RawResult.RawSerializedData.get -> System.Buffers.ReadOnlySequence<byte>\nMicrosoft.AspNetCore.SignalR.Protocol.SequenceMessage\nMicrosoft.AspNetCore.SignalR.Protocol.SequenceMessage.SequenceId.get -> long\nMicrosoft.AspNetCore.SignalR.Protocol.SequenceMessage.SequenceId.set -> void\nMicrosoft.AspNetCore.SignalR.Protocol.SequenceMessage.SequenceMessage(long sequenceId) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.StreamBindingFailureMessage\nMicrosoft.AspNetCore.SignalR.Protocol.StreamBindingFailureMessage.BindingFailure.get -> System.Runtime.ExceptionServices.ExceptionDispatchInfo!\nMicrosoft.AspNetCore.SignalR.Protocol.StreamBindingFailureMessage.Id.get -> string!\nMicrosoft.AspNetCore.SignalR.Protocol.StreamBindingFailureMessage.StreamBindingFailureMessage(string! id, System.Runtime.ExceptionServices.ExceptionDispatchInfo! bindingFailure) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.StreamInvocationMessage\nMicrosoft.AspNetCore.SignalR.Protocol.StreamInvocationMessage.StreamInvocationMessage(string! invocationId, string! target, object?[]! arguments) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.StreamInvocationMessage.StreamInvocationMessage(string! invocationId, string! target, object?[]! arguments, string![]? streamIds) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.StreamItemMessage\nMicrosoft.AspNetCore.SignalR.Protocol.StreamItemMessage.Item.get -> object?\nMicrosoft.AspNetCore.SignalR.Protocol.StreamItemMessage.Item.set -> void\nMicrosoft.AspNetCore.SignalR.Protocol.StreamItemMessage.StreamItemMessage(string! invocationId, object? item) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract AuthorizationHandler Methods in C#\nDESCRIPTION: These abstract methods define the core functionality for handling authorization requirements in ASP.NET Core. They are implemented by custom authorization handlers to enforce specific authorization rules.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Authorization.AuthorizationHandler<TRequirement, TResource>.HandleRequirementAsync(Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext! context, TRequirement requirement, TResource resource) -> System.Threading.Tasks.Task!\n\nabstract Microsoft.AspNetCore.Authorization.AuthorizationHandler<TRequirement>.HandleRequirementAsync(Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext! context, TRequirement requirement) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants Definition in ASP.NET Core\nDESCRIPTION: Generated code that defines constant string arrays for common HTTP content types used in content negotiation and request validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: ValidationMessageStore Class API for ASP.NET Core Blazor Forms\nDESCRIPTION: The ValidationMessageStore class manages validation error messages for an EditContext. It provides methods to add, clear, and retrieve validation messages for specific fields or the entire form.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Forms/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Forms.ValidationMessageStore\nMicrosoft.AspNetCore.Components.Forms.ValidationMessageStore.Add(in Microsoft.AspNetCore.Components.Forms.FieldIdentifier fieldIdentifier, string! message) -> void\nMicrosoft.AspNetCore.Components.Forms.ValidationMessageStore.Add(in Microsoft.AspNetCore.Components.Forms.FieldIdentifier fieldIdentifier, System.Collections.Generic.IEnumerable<string!>! messages) -> void\nMicrosoft.AspNetCore.Components.Forms.ValidationMessageStore.Add(System.Linq.Expressions.Expression<System.Func<object!>!>! accessor, string! message) -> void\nMicrosoft.AspNetCore.Components.Forms.ValidationMessageStore.Add(System.Linq.Expressions.Expression<System.Func<object!>!>! accessor, System.Collections.Generic.IEnumerable<string!>! messages) -> void\nMicrosoft.AspNetCore.Components.Forms.ValidationMessageStore.Clear() -> void\nMicrosoft.AspNetCore.Components.Forms.ValidationMessageStore.Clear(in Microsoft.AspNetCore.Components.Forms.FieldIdentifier fieldIdentifier) -> void\nMicrosoft.AspNetCore.Components.Forms.ValidationMessageStore.Clear(System.Linq.Expressions.Expression<System.Func<object!>!>! accessor) -> void\nMicrosoft.AspNetCore.Components.Forms.ValidationMessageStore.this[Microsoft.AspNetCore.Components.Forms.FieldIdentifier fieldIdentifier].get -> System.Collections.Generic.IEnumerable<string!>!\nMicrosoft.AspNetCore.Components.Forms.ValidationMessageStore.this[System.Linq.Expressions.Expression<System.Func<object!>!>! accessor].get -> System.Collections.Generic.IEnumerable<string!>!\nMicrosoft.AspNetCore.Components.Forms.ValidationMessageStore.ValidationMessageStore(Microsoft.AspNetCore.Components.Forms.EditContext! editContext) -> void\n```\n\n----------------------------------------\n\nTITLE: Overriding StaticHtmlRenderer Methods in C#\nDESCRIPTION: Overrides the Dispatcher, HandleException, RendererInfo, and UpdateDisplayAsync methods for the StaticHtmlRenderer class in ASP.NET Core Components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Components.HtmlRendering.Infrastructure.StaticHtmlRenderer.Dispatcher.get -> Microsoft.AspNetCore.Components.Dispatcher!\noverride Microsoft.AspNetCore.Components.HtmlRendering.Infrastructure.StaticHtmlRenderer.HandleException(System.Exception! exception) -> void\noverride Microsoft.AspNetCore.Components.HtmlRendering.Infrastructure.StaticHtmlRenderer.RendererInfo.get -> Microsoft.AspNetCore.Components.RendererInfo!\noverride Microsoft.AspNetCore.Components.HtmlRendering.Infrastructure.StaticHtmlRenderer.UpdateDisplayAsync(in Microsoft.AspNetCore.Components.RenderTree.RenderBatch renderBatch) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Implementing Limit Parameter Validation Middleware in ASP.NET Core\nDESCRIPTION: This class implements a middleware component that transforms and validates the 'limit' query parameter. It enforces minimum and maximum values, applies a default value when not provided, and allows custom validation rules.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.DataAnnotations/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining WebAssemblyHost and WebAssemblyHostBuilder in C#\nDESCRIPTION: Defines the WebAssemblyHost and WebAssemblyHostBuilder classes with methods for configuration, services, and environment management. These classes are crucial for setting up and managing WebAssembly applications in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHost.Services.get -> System.IServiceProvider!\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostBuilder\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostBuilder.Build() -> Microsoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHost!\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostBuilder.Configuration.get -> Microsoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostConfiguration!\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostBuilder.ConfigureContainer<TBuilder>(Microsoft.Extensions.DependencyInjection.IServiceProviderFactory<TBuilder>! factory, System.Action<TBuilder>? configure = null) -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostBuilder.HostEnvironment.get -> Microsoft.AspNetCore.Components.WebAssembly.Hosting.IWebAssemblyHostEnvironment!\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostBuilder.Logging.get -> Microsoft.Extensions.Logging.ILoggingBuilder!\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostBuilder.RootComponents.get -> Microsoft.AspNetCore.Components.WebAssembly.Hosting.RootComponentMappingCollection!\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostBuilder.Services.get -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Identity Core Service Configuration Methods\nDESCRIPTION: Extension methods for configuring Identity services in ASP.NET Core applications with dependency injection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.IdentityServiceCollectionExtensions.AddIdentityCore<TUser>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.AspNetCore.Identity.IdentityBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.IdentityServiceCollectionExtensions.AddIdentityCore<TUser>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Identity.IdentityOptions!>! setupAction) -> Microsoft.AspNetCore.Identity.IdentityBuilder!\n```\n\n----------------------------------------\n\nTITLE: CNG CBC Authenticated Encryptor Factory\nDESCRIPTION: Factory class for creating CBC-mode authenticated encryptors using the Windows Cryptography API: Next Generation (CNG).\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.CngCbcAuthenticatedEncryptorFactory.CngCbcAuthenticatedEncryptorFactory(Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> void\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.CngCbcAuthenticatedEncryptorFactory.CreateEncryptorInstance(Microsoft.AspNetCore.DataProtection.KeyManagement.IKey! key) -> Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor?\n```\n\n----------------------------------------\n\nTITLE: Configuring WsFederationOptions for Authentication in C#\nDESCRIPTION: This class provides configuration options for WS-Federation authentication, including settings for metadata, security tokens, and various authentication behaviors.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/WsFederation/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.AllowUnsolicitedLogins.get -> bool\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.AllowUnsolicitedLogins.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.Configuration.get -> Microsoft.IdentityModel.Protocols.WsFederation.WsFederationConfiguration?\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.Configuration.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.ConfigurationManager.get -> Microsoft.IdentityModel.Protocols.IConfigurationManager<Microsoft.IdentityModel.Protocols.WsFederation.WsFederationConfiguration!>!\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.ConfigurationManager.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.Events.get -> Microsoft.AspNetCore.Authentication.WsFederation.WsFederationEvents!\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.Events.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.MetadataAddress.get -> string?\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.MetadataAddress.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.RefreshOnIssuerKeyNotFound.get -> bool\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.RefreshOnIssuerKeyNotFound.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.RemoteSignOutPath.get -> Microsoft.AspNetCore.Http.PathString\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.RemoteSignOutPath.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.RequireHttpsMetadata.get -> bool\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.RequireHttpsMetadata.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.SaveTokens.get -> bool\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.SaveTokens.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.SecurityTokenHandlers.get -> System.Collections.Generic.ICollection<Microsoft.IdentityModel.Tokens.ISecurityTokenValidator!>!\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.SecurityTokenHandlers.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.SignOutScheme.get -> string?\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.SignOutScheme.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.SignOutWreply.get -> string?\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.SignOutWreply.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.SkipUnrecognizedRequests.get -> bool\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.SkipUnrecognizedRequests.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.StateDataFormat.get -> Microsoft.AspNetCore.Authentication.ISecureDataFormat<Microsoft.AspNetCore.Authentication.AuthenticationProperties!>!\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.StateDataFormat.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.TokenHandlers.get -> System.Collections.Generic.ICollection<Microsoft.IdentityModel.Tokens.TokenHandler!>!\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.TokenValidationParameters.get -> Microsoft.IdentityModel.Tokens.TokenValidationParameters!\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.TokenValidationParameters.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.UseSecurityTokenHandlers.get -> bool\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.UseSecurityTokenHandlers.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.UseTokenLifetime.get -> bool\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.UseTokenLifetime.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.Wreply.get -> string?\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.Wreply.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.WsFederationOptions() -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.Wtrealm.get -> string?\nMicrosoft.AspNetCore.Authentication.WsFederation.WsFederationOptions.Wtrealm.set -> void\n```\n\n----------------------------------------\n\nTITLE: Excluding Clients from a Group in ASP.NET Core SignalR\nDESCRIPTION: These methods allow excluding specific clients from a group. They provide overloads for excluding up to 6 individual connection IDs from a specified group.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.HubClientsExtensions.GroupExcept<T>(this Microsoft.AspNetCore.SignalR.IHubClients<T>! hubClients, string! groupName, string! excludedConnectionId1) -> T\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.HubClientsExtensions.GroupExcept<T>(this Microsoft.AspNetCore.SignalR.IHubClients<T>! hubClients, string! groupName, string! excludedConnectionId1, string! excludedConnectionId2, string! excludedConnectionId3, string! excludedConnectionId4, string! excludedConnectionId5, string! excludedConnectionId6) -> T\n```\n\n----------------------------------------\n\nTITLE: Defining Forbid Result Method in C#\nDESCRIPTION: This method creates a Forbid (HTTP 403) result with optional authentication properties and schemes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.Forbid(Microsoft.AspNetCore.Authentication.AuthenticationProperties? properties = null, System.Collections.Generic.IList<string!>? authenticationSchemes = null) -> Microsoft.AspNetCore.Http.HttpResults.ForbidHttpResult!\n```\n\n----------------------------------------\n\nTITLE: Building Microsoft Account Authentication Project\nDESCRIPTION: Command to build the Microsoft Account Authentication project from within the security directory.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/MicrosoftAccount/src/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: Identity UI Logger Event IDs\nDESCRIPTION: Static readonly event ID definitions for Identity UI logging, including authentication, password changes, and recovery code validation events.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Identity.UI.LoggerEventIds.AuthenticationAppKeyReset -> Microsoft.Extensions.Logging.EventId\nstatic readonly Microsoft.AspNetCore.Identity.UI.LoggerEventIds.InvalidAuthenticatorCode -> Microsoft.Extensions.Logging.EventId\nstatic readonly Microsoft.AspNetCore.Identity.UI.LoggerEventIds.InvalidRecoveryCode -> Microsoft.Extensions.Logging.EventId\nstatic readonly Microsoft.AspNetCore.Identity.UI.LoggerEventIds.PasswordChanged -> Microsoft.Extensions.Logging.EventId\n```\n\n----------------------------------------\n\nTITLE: Implementing ExecuteReturnAsync for Result Handling\nDESCRIPTION: A method that processes the return value from endpoint handlers, handling special cases for IResult objects and providing JSON serialization for other types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_StringArrayParam.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Model Binding Methods in PageBase Class\nDESCRIPTION: Virtual methods for model binding and validation in Razor Pages. These methods facilitate updating model objects from HTTP request data and validating model state.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.TryUpdateModelAsync(object! model, System.Type! modelType, string! prefix) -> System.Threading.Tasks.Task<bool>!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.TryUpdateModelAsync<TModel>(TModel! model) -> System.Threading.Tasks.Task<bool>!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.TryUpdateModelAsync<TModel>(TModel! model, string! prefix) -> System.Threading.Tasks.Task<bool>!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.TryUpdateModelAsync<TModel>(TModel! model, string! prefix, Microsoft.AspNetCore.Mvc.ModelBinding.IValueProvider! valueProvider) -> System.Threading.Tasks.Task<bool>!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.TryValidateModel(object! model) -> bool\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.TryValidateModel(object! model, string? prefix) -> bool\n```\n\n----------------------------------------\n\nTITLE: NodeJS SignalR Connection Setup\nDESCRIPTION: Example of establishing a SignalR connection in a Node.js environment, showing module import and connection setup.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/ts/signalr/README.md#2025-04-08_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst signalR = require(\"@microsoft/signalr\");\n\nlet connection = new signalR.HubConnectionBuilder()\n    .withUrl(\"/chat\")\n    .build();\n\nconnection.on(\"send\", data => {\n    console.log(data);\n});\n\nconnection.start()\n    .then(() => connection.invoke(\"send\", \"Hello\"));\n```\n\n----------------------------------------\n\nTITLE: Implementing BuildFilterDelegate Method in C#\nDESCRIPTION: Builds a filter delegate by applying a series of endpoint filters to the initial invocation delegate.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_NoParam_StringReturn_WithFilter.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: A directive that enables C# nullable reference types. When enabled, reference types are treated as non-nullable by default, and the compiler warns about potential null reference exceptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/eng/PublicAPI.empty.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Building Endpoint Filter Delegate in C# for ASP.NET Core\nDESCRIPTION: This method builds an endpoint filter delegate by applying multiple filters to an initial filtered invocation. It uses the endpoint builder and method info to create the filter context.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitServiceParam_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive that enables nullable reference type checking for the current file or project scope. This helps catch potential null reference exceptions at compile time.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HealthChecks/Abstractions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Building Endpoint Filter Chains in ASP.NET Core\nDESCRIPTION: Constructs a chain of endpoint filters from endpoint builder filter factories. The method applies filters in reverse order to create a nested invocation chain, supporting middleware-like behavior for request processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_NullableReturn.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LocalizedString Class in C#\nDESCRIPTION: Class representing a localized string with properties for name, value, resource status, and search location.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Localization/Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Localization.LocalizedString.LocalizedString(string! name, string! value) -> void\nMicrosoft.Extensions.Localization.LocalizedString.LocalizedString(string! name, string! value, bool resourceNotFound) -> void\nMicrosoft.Extensions.Localization.LocalizedString.LocalizedString(string! name, string! value, bool resourceNotFound, string? searchedLocation) -> void\nMicrosoft.Extensions.Localization.LocalizedString.Name.get -> string!\nMicrosoft.Extensions.Localization.LocalizedString.ResourceNotFound.get -> bool\nMicrosoft.Extensions.Localization.LocalizedString.SearchedLocation.get -> string?\nMicrosoft.Extensions.Localization.LocalizedString.Value.get -> string!\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive to enable nullable reference type checking at the project or file level. This ensures better null-safety by making reference types non-nullable by default.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing.Abstractions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive to enable nullable reference type checking at the file level. This helps catch potential null reference issues at compile time rather than runtime.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/WebEncoders/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Building Filter Delegate for Endpoint in ASP.NET Core\nDESCRIPTION: Constructs a filter delegate for an endpoint by applying route handler filters in reverse order.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Preprocessor directive that enables nullable reference type checking for the current file or project scope. This enhances type safety by making null-handling explicit.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HttpClientFactory/Polly/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Configuring Razor Runtime Compilation in ASP.NET Core Startup\nDESCRIPTION: Code snippet showing how to configure runtime compilation for Razor views in an ASP.NET Core MVC application. This is added to the ConfigureServices method in Startup.cs, enabling views to be updated without restarting the application.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Razor.RuntimeCompilation/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.DependencyInjection;\n\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddControllersWithViews()\n        .AddRazorRuntimeCompilation();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Hub Options for Server-Side Blazor in ASP.NET Core\nDESCRIPTION: Extension method for IServerSideBlazorBuilder that configures SignalR HubOptions through an action delegate. Allows customization of the underlying SignalR hub used by Blazor server.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.ServerSideBlazorBuilderExtensions.AddHubOptions(this Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder! builder, System.Action<Microsoft.AspNetCore.SignalR.HubOptions!>! configure) -> Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder!\n```\n\n----------------------------------------\n\nTITLE: Extending OWIN Builder in C#\nDESCRIPTION: Defines extension methods for the OWIN builder to integrate with ASP.NET Core's IApplicationBuilder.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Owin/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.OwinExtensions.UseBuilder(this System.Action<System.Func<System.Func<System.Collections.Generic.IDictionary<string, object>, System.Threading.Tasks.Task>, System.Func<System.Collections.Generic.IDictionary<string, object>, System.Threading.Tasks.Task>>> app) -> Microsoft.AspNetCore.Builder.IApplicationBuilder\nstatic Microsoft.AspNetCore.Builder.OwinExtensions.UseBuilder(this System.Action<System.Func<System.Func<System.Collections.Generic.IDictionary<string, object>, System.Threading.Tasks.Task>, System.Func<System.Collections.Generic.IDictionary<string, object>, System.Threading.Tasks.Task>>> app, System.Action<Microsoft.AspNetCore.Builder.IApplicationBuilder> pipeline) -> System.Action<System.Func<System.Func<System.Collections.Generic.IDictionary<string, object>, System.Threading.Tasks.Task>, System.Func<System.Collections.Generic.IDictionary<string, object>, System.Threading.Tasks.Task>>>\nstatic Microsoft.AspNetCore.Builder.OwinExtensions.UseBuilder(this System.Action<System.Func<System.Func<System.Collections.Generic.IDictionary<string, object>, System.Threading.Tasks.Task>, System.Func<System.Collections.Generic.IDictionary<string, object>, System.Threading.Tasks.Task>>> app, System.Action<Microsoft.AspNetCore.Builder.IApplicationBuilder> pipeline, System.IServiceProvider serviceProvider) -> System.Action<System.Func<System.Func<System.Collections.Generic.IDictionary<string, object>, System.Threading.Tasks.Task>, System.Func<System.Collections.Generic.IDictionary<string, object>, System.Threading.Tasks.Task>>>\nstatic Microsoft.AspNetCore.Builder.OwinExtensions.UseBuilder(this System.Action<System.Func<System.Func<System.Collections.Generic.IDictionary<string, object>, System.Threading.Tasks.Task>, System.Func<System.Collections.Generic.IDictionary<string, object>, System.Threading.Tasks.Task>>> app, System.IServiceProvider serviceProvider) -> Microsoft.AspNetCore.Builder.IApplicationBuilder\nstatic Microsoft.AspNetCore.Builder.OwinExtensions.UseOwin(this Microsoft.AspNetCore.Builder.IApplicationBuilder builder) -> System.Action<System.Func<System.Func<System.Collections.Generic.IDictionary<string, object>, System.Threading.Tasks.Task>, System.Func<System.Collections.Generic.IDictionary<string, object>, System.Threading.Tasks.Task>>>\nstatic Microsoft.AspNetCore.Builder.OwinExtensions.UseOwin(this Microsoft.AspNetCore.Builder.IApplicationBuilder builder, System.Action<System.Action<System.Func<System.Func<System.Collections.Generic.IDictionary<string, object>, System.Threading.Tasks.Task>, System.Func<System.Collections.Generic.IDictionary<string, object>, System.Threading.Tasks.Task>>>> pipeline) -> Microsoft.AspNetCore.Builder.IApplicationBuilder\n```\n\n----------------------------------------\n\nTITLE: Defining IResourceNamesCache Interface in C#\nDESCRIPTION: Declares an interface for caching resource names with a GetOrAdd method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Localization/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Localization.IResourceNamesCache.GetOrAdd(string! name, System.Func<string!, System.Collections.Generic.IList<string!>?>! valueFactory) -> System.Collections.Generic.IList<string!>?\n```\n\n----------------------------------------\n\nTITLE: Defining Specialized HttpRequestBuilder Class for Testing in C#\nDESCRIPTION: This code defines a specialized HttpRequestBuilder class for testing purposes that inherits from the base HttpRequestBuilder. It includes a constructor that initializes the builder with default values and configures it for testing scenarios.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/QuickGrid/Microsoft.AspNetCore.Components.QuickGrid.EntityFrameworkAdapter/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Google Authentication Constants Definition\nDESCRIPTION: Defines constant values for Google authentication endpoints and default configuration values\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Google/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.Authentication.Google.GoogleDefaults.AuthenticationScheme = \"Google\" -> string!\n\nstatic readonly Microsoft.AspNetCore.Authentication.Google.GoogleDefaults.AuthorizationEndpoint -> string!\nstatic readonly Microsoft.AspNetCore.Authentication.Google.GoogleDefaults.TokenEndpoint -> string!\nstatic readonly Microsoft.AspNetCore.Authentication.Google.GoogleDefaults.UserInformationEndpoint -> string!\nstatic readonly Microsoft.AspNetCore.Authentication.Google.GoogleDefaults.DisplayName -> string!\n```\n\n----------------------------------------\n\nTITLE: Implementing MapPost0 Method for ASP.NET Core Route Builder\nDESCRIPTION: Implements the MapPost0 extension method for IEndpointRouteBuilder to handle HTTP POST requests. It includes metadata population and request delegate creation logic.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_JsonBodyOrService_HandlesBothJsonAndService.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedRouteBuilderExtensionsCore\n{\n    private static readonly JsonOptions FallbackJsonOptions = new();\n    private static readonly string[] PostVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Post };\n\n    %INTERCEPTSLOCATIONATTRIBUTE%\n    internal static RouteHandlerBuilder MapPost0(\n        this IEndpointRouteBuilder endpoints,\n        [StringSyntax(\"Route\")] string pattern,\n        Delegate handler)\n    {\n        MetadataPopulator populateMetadata = (methodInfo, options) =>\n        {\n            // Metadata population logic\n        };\n        RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n        {\n            // Request delegate creation logic\n        };\n\n        // Request handling logic\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: RoleStore Class Method Signatures in ASP.NET Core Identity\nDESCRIPTION: Method signatures for the RoleStore class that handles role management operations including create, read, update, delete, and claim management. These methods are part of the ASP.NET Core Identity EntityFrameworkCore implementation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.RoleStore<TRole, TContext, TKey, TUserRole, TRoleClaim>.AddClaimAsync(TRole! role, System.Security.Claims.Claim! claim, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.RoleStore<TRole, TContext, TKey, TUserRole, TRoleClaim>.Context.get -> TContext!\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.RoleStore<TRole, TContext, TKey, TUserRole, TRoleClaim>.ConvertIdFromString(string! id) -> TKey?\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.RoleStore<TRole, TContext, TKey, TUserRole, TRoleClaim>.ConvertIdToString(TKey id) -> string?\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.RoleStore<TRole, TContext, TKey, TUserRole, TRoleClaim>.CreateAsync(TRole! role, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\n```\n\n----------------------------------------\n\nTITLE: Creating Request Delegate for ASP.NET Core Endpoint\nDESCRIPTION: This method creates a request delegate for an ASP.NET Core endpoint. It sets up JSON serialization options, builds filter delegates if needed, and defines request handling logic including parameter resolution and result execution.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitBodyParam_ComplexReturn_Snapshot.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nRequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n{\n    Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n    Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n    Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n    Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n    var handler = Cast(del, global::Microsoft.AspNetCore.Http.HttpResults.Ok<global::Microsoft.AspNetCore.Http.Generators.Tests.Todo> (global::Microsoft.AspNetCore.Http.Generators.Tests.Todo? arg0) => throw null!);\n    EndpointFilterDelegate? filteredInvocation = null;\n    var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n    var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n    var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n    var jsonSerializerOptions = jsonOptions.SerializerOptions;\n    jsonSerializerOptions.MakeReadOnly();\n    var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n    var todo_JsonTypeInfo = (JsonTypeInfo<global::Microsoft.AspNetCore.Http.Generators.Tests.Todo?>)jsonSerializerOptions.GetTypeInfo(typeof(global::Microsoft.AspNetCore.Http.Generators.Tests.Todo));\n\n    if (options.EndpointBuilder.FilterFactories.Count > 0)\n    {\n        filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n        {\n            if (ic.HttpContext.Response.StatusCode == 400)\n            {\n                return ValueTask.FromResult<object?>(Results.Empty);\n            }\n            return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.Todo?>(0)!));\n        },\n        options.EndpointBuilder,\n        handler.Method);\n    }\n\n    async Task RequestHandler(HttpContext httpContext)\n    {\n        var wasParamCheckFailure = false;\n        // Endpoint Parameter: todo (Type = Microsoft.AspNetCore.Http.Generators.Tests.Todo?, IsOptional = True, IsParsable = False, IsArray = False, Source = JsonBody)\n        var todo_resolveBodyResult = await GeneratedRouteBuilderExtensionsCore.TryResolveBodyAsync<global::Microsoft.AspNetCore.Http.Generators.Tests.Todo?>(httpContext, logOrThrowExceptionHelper, true, \"Todo?\", \"todo\", todo_JsonTypeInfo);\n        var todo_local = todo_resolveBodyResult.Item2;\n        if (!todo_resolveBodyResult.Item1)\n        {\n            return;\n        }\n\n        if (wasParamCheckFailure)\n        {\n            httpContext.Response.StatusCode = 400;\n            return;\n        }\n        var result = handler(todo_local);\n        if (result == null)\n        {\n            throw new InvalidOperationException(\"The IResult returned by the Delegate must not be null.\");\n        }\n        await GeneratedRouteBuilderExtensionsCore.ExecuteAsyncExplicit(result, httpContext);\n    }\n\n    async Task RequestHandlerFiltered(HttpContext httpContext)\n    {\n        var wasParamCheckFailure = false;\n        // Endpoint Parameter: todo (Type = Microsoft.AspNetCore.Http.Generators.Tests.Todo?, IsOptional = True, IsParsable = False, IsArray = False, Source = JsonBody)\n        var todo_resolveBodyResult = await GeneratedRouteBuilderExtensionsCore.TryResolveBodyAsync<global::Microsoft.AspNetCore.Http.Generators.Tests.Todo?>(httpContext, logOrThrowExceptionHelper, true, \"Todo?\", \"todo\", todo_JsonTypeInfo);\n        var todo_local = todo_resolveBodyResult.Item2;\n        if (!todo_resolveBodyResult.Item1)\n        {\n            return;\n        }\n\n        if (wasParamCheckFailure)\n        {\n            httpContext.Response.StatusCode = 400;\n        }\n        var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.Todo?>(httpContext, todo_local));\n        if (result is not null)\n        {\n            await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n        }\n    }\n\n    RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\n    var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\n    return new RequestDelegateResult(targetDelegate, metadata);\n};\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Required Parameters in ASP.NET Core\nDESCRIPTION: This method handles cases where a required parameter is not provided. It either throws a BadHttpRequestException or logs the issue, depending on the configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RequestLocalizationMiddleware Class in C#\nDESCRIPTION: Defines the RequestLocalizationMiddleware class for handling request localization in the ASP.NET Core pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Localization.RequestLocalizationMiddleware\nMicrosoft.AspNetCore.Localization.RequestLocalizationMiddleware.Invoke(Microsoft.AspNetCore.Http.HttpContext! context) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Localization.RequestLocalizationMiddleware.RequestLocalizationMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Builder.RequestLocalizationOptions!>! options, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> void\n```\n\n----------------------------------------\n\nTITLE: Adding SignalR Core Services to IServiceCollection in C#\nDESCRIPTION: Extension method for IServiceCollection to add core SignalR services to the dependency injection container.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.SignalRDependencyInjectionExtensions.AddSignalRCore(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.AspNetCore.SignalR.ISignalRServerBuilder!\n```\n\n----------------------------------------\n\nTITLE: Implementing Route Handler Mapping in ASP.NET Core\nDESCRIPTION: Core method for mapping route handlers in ASP.NET Core. Takes route pattern, delegate handler, HTTP methods and metadata population function to create route handler builder.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Page Handling Methods in PageModel\nDESCRIPTION: Event handling methods for page execution lifecycle including selection, execution, and post-execution phases.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.OnPageHandlerExecuted(Microsoft.AspNetCore.Mvc.Filters.PageHandlerExecutedContext! context) -> void\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.OnPageHandlerExecuting(Microsoft.AspNetCore.Mvc.Filters.PageHandlerExecutingContext! context) -> void\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.OnPageHandlerExecutionAsync(Microsoft.AspNetCore.Mvc.Filters.PageHandlerExecutingContext! context, Microsoft.AspNetCore.Mvc.Filters.PageHandlerExecutionDelegate! next) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.OnPageHandlerSelected(Microsoft.AspNetCore.Mvc.Filters.PageHandlerSelectedContext! context) -> void\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.OnPageHandlerSelectionAsync(Microsoft.AspNetCore.Mvc.Filters.PageHandlerSelectedContext! context) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Event Args Classes for ASP.NET Core Blazor Forms\nDESCRIPTION: Event argument classes for form-related events including field changes, validation requests, and validation state changes. These classes are used by the event handling system in EditContext.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Forms/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Forms.FieldChangedEventArgs\nMicrosoft.AspNetCore.Components.Forms.FieldChangedEventArgs.FieldChangedEventArgs(in Microsoft.AspNetCore.Components.Forms.FieldIdentifier fieldIdentifier) -> void\nMicrosoft.AspNetCore.Components.Forms.FieldChangedEventArgs.FieldIdentifier.get -> Microsoft.AspNetCore.Components.Forms.FieldIdentifier\nMicrosoft.AspNetCore.Components.Forms.ValidationRequestedEventArgs\nMicrosoft.AspNetCore.Components.Forms.ValidationRequestedEventArgs.ValidationRequestedEventArgs() -> void\nMicrosoft.AspNetCore.Components.Forms.ValidationStateChangedEventArgs\nMicrosoft.AspNetCore.Components.Forms.ValidationStateChangedEventArgs.ValidationStateChangedEventArgs() -> void\nstatic readonly Microsoft.AspNetCore.Components.Forms.ValidationRequestedEventArgs.Empty -> Microsoft.AspNetCore.Components.Forms.ValidationRequestedEventArgs!\nstatic readonly Microsoft.AspNetCore.Components.Forms.ValidationStateChangedEventArgs.Empty -> Microsoft.AspNetCore.Components.Forms.ValidationStateChangedEventArgs!\n```\n\n----------------------------------------\n\nTITLE: Defining InternalServerError Result Methods in C#\nDESCRIPTION: These methods create InternalServerError (HTTP 500) results with optional error content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.InternalServerError() -> Microsoft.AspNetCore.Http.HttpResults.InternalServerError!\nstatic Microsoft.AspNetCore.Http.TypedResults.InternalServerError<TValue>(TValue? error) -> Microsoft.AspNetCore.Http.HttpResults.InternalServerError<TValue>!\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive that enables nullable reference type checking for the current file scope. This enforces more strict null checking and helps prevent null reference exceptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SiteExtensions/Microsoft.Web.Xdt.Extensions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining MapGet13 Method Signature for ASP.NET Core Endpoint Routing\nDESCRIPTION: This code snippet defines the signature and initial metadata setup for the MapGet13 method, which registers a GET endpoint with an optional parameter using BindAsync.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_26\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet13(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"myBindAsyncParam\", parameters[0], hasTryParse: false, hasBindAsync: true, isOptional: true));\n\n```\n\n----------------------------------------\n\nTITLE: Razor Pages Authentication Methods\nDESCRIPTION: Authentication-related methods for handling challenges, forbid responses, and authentication schemes in Razor Pages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.Challenge() -> Microsoft.AspNetCore.Mvc.ChallengeResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.Forbid() -> Microsoft.AspNetCore.Mvc.ForbidResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.Challenge(params string![]! authenticationSchemes) -> Microsoft.AspNetCore.Mvc.ChallengeResult!\n```\n\n----------------------------------------\n\nTITLE: Forbid Response Methods in ASP.NET Core ControllerBase (C#)\nDESCRIPTION: Methods to return HTTP 403 Forbidden responses, indicating the server understood the request but refuses to authorize it. These methods support specifying authentication schemes and properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Forbid() -> Microsoft.AspNetCore.Mvc.ForbidResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Forbid(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties) -> Microsoft.AspNetCore.Mvc.ForbidResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Forbid(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, params string![]! authenticationSchemes) -> Microsoft.AspNetCore.Mvc.ForbidResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Forbid(params string![]! authenticationSchemes) -> Microsoft.AspNetCore.Mvc.ForbidResult!\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive that enables nullable reference type checks, requiring explicit null handling and improving type safety in C# code.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ResponseCaching.Abstractions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining HtmlContentBuilderExtensions in C#\nDESCRIPTION: This snippet defines extension methods for IHtmlContentBuilder, providing additional functionality for appending formatted content, HTML lines, and setting content. It includes methods for various content manipulation operations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Html.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Html.HtmlContentBuilderExtensions\nstatic Microsoft.AspNetCore.Html.HtmlContentBuilderExtensions.AppendFormat(this Microsoft.AspNetCore.Html.IHtmlContentBuilder! builder, string! format, params object?[]! args) -> Microsoft.AspNetCore.Html.IHtmlContentBuilder!\nstatic Microsoft.AspNetCore.Html.HtmlContentBuilderExtensions.AppendFormat(this Microsoft.AspNetCore.Html.IHtmlContentBuilder! builder, System.IFormatProvider! formatProvider, string! format, params object?[]! args) -> Microsoft.AspNetCore.Html.IHtmlContentBuilder!\nstatic Microsoft.AspNetCore.Html.HtmlContentBuilderExtensions.AppendHtmlLine(this Microsoft.AspNetCore.Html.IHtmlContentBuilder! builder, string! encoded) -> Microsoft.AspNetCore.Html.IHtmlContentBuilder!\nstatic Microsoft.AspNetCore.Html.HtmlContentBuilderExtensions.AppendLine(this Microsoft.AspNetCore.Html.IHtmlContentBuilder! builder) -> Microsoft.AspNetCore.Html.IHtmlContentBuilder!\nstatic Microsoft.AspNetCore.Html.HtmlContentBuilderExtensions.AppendLine(this Microsoft.AspNetCore.Html.IHtmlContentBuilder! builder, Microsoft.AspNetCore.Html.IHtmlContent! content) -> Microsoft.AspNetCore.Html.IHtmlContentBuilder!\nstatic Microsoft.AspNetCore.Html.HtmlContentBuilderExtensions.AppendLine(this Microsoft.AspNetCore.Html.IHtmlContentBuilder! builder, string! unencoded) -> Microsoft.AspNetCore.Html.IHtmlContentBuilder!\nstatic Microsoft.AspNetCore.Html.HtmlContentBuilderExtensions.SetContent(this Microsoft.AspNetCore.Html.IHtmlContentBuilder! builder, string! unencoded) -> Microsoft.AspNetCore.Html.IHtmlContentBuilder!\nstatic Microsoft.AspNetCore.Html.HtmlContentBuilderExtensions.SetHtmlContent(this Microsoft.AspNetCore.Html.IHtmlContentBuilder! builder, Microsoft.AspNetCore.Html.IHtmlContent! content) -> Microsoft.AspNetCore.Html.IHtmlContentBuilder!\nstatic Microsoft.AspNetCore.Html.HtmlContentBuilderExtensions.SetHtmlContent(this Microsoft.AspNetCore.Html.IHtmlContentBuilder! builder, string! encoded) -> Microsoft.AspNetCore.Html.IHtmlContentBuilder!\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: This directive enables nullable reference type checking for the entire file. When enabled, the compiler will warn about potential null reference issues, improving code safety and reducing runtime exceptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing IDataProtectionKeyContext in a DbContext class\nDESCRIPTION: Sample implementation of a DbContext class that implements the IDataProtectionKeyContext interface required for data protection key storage. The context includes a DbSet property for DataProtectionKey entities that will be stored in the database.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/EntityFrameworkCore/src/PACKAGE.md#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass MyDbContext : DbContext, IDataProtectionKeyContext\n{\n    public MyKeysContext(DbContextOptions<MyKeysContext> options)\n        : base(options)\n    {\n    }\n\n    // This maps to the table that stores keys\n    public DbSet<DataProtectionKey> DataProtectionKeys { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Remote Browser File Stream Options for InputFile\nDESCRIPTION: API signature for RemoteBrowserFileStreamOptions class that configures the behavior of streaming files from the browser, including buffer size, segment size, and timeout settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Forms.RemoteBrowserFileStreamOptions\nMicrosoft.AspNetCore.Components.Forms.RemoteBrowserFileStreamOptions.MaxBufferSize.get -> int\nMicrosoft.AspNetCore.Components.Forms.RemoteBrowserFileStreamOptions.MaxBufferSize.set -> void\nMicrosoft.AspNetCore.Components.Forms.RemoteBrowserFileStreamOptions.MaxSegmentSize.get -> int\nMicrosoft.AspNetCore.Components.Forms.RemoteBrowserFileStreamOptions.MaxSegmentSize.set -> void\nMicrosoft.AspNetCore.Components.Forms.RemoteBrowserFileStreamOptions.RemoteBrowserFileStreamOptions() -> void\nMicrosoft.AspNetCore.Components.Forms.RemoteBrowserFileStreamOptions.SegmentFetchTimeout.get -> System.TimeSpan\nMicrosoft.AspNetCore.Components.Forms.RemoteBrowserFileStreamOptions.SegmentFetchTimeout.set -> void\n```\n\n----------------------------------------\n\nTITLE: Logger Factory Extensions\nDESCRIPTION: Extension methods for adding Azure Web App diagnostics to the logging builder with optional configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Logging.AzureAppServices/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n~static Microsoft.Extensions.Logging.AzureAppServicesLoggerFactoryExtensions.AddAzureWebAppDiagnostics(this Microsoft.Extensions.Logging.ILoggingBuilder builder) -> Microsoft.Extensions.Logging.ILoggingBuilder\n~static Microsoft.Extensions.Logging.AzureAppServicesLoggerFactoryExtensions.AddAzureWebAppDiagnostics(this Microsoft.Extensions.Logging.ILoggingBuilder builder, System.Action<Microsoft.Extensions.Logging.AzureAppServices.AzureBlobLoggerOptions> configureBlobLoggerOptions) -> Microsoft.Extensions.Logging.ILoggingBuilder\n```\n\n----------------------------------------\n\nTITLE: Activating Local .NET Environment on Windows\nDESCRIPTION: PowerShell command to activate the locally installed .NET environment, necessary before running tests on Windows.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/README.md#2025-04-08_snippet_9\n\nLANGUAGE: powershell\nCODE:\n```\n. ./activate.ps1\n```\n\n----------------------------------------\n\nTITLE: Overriding ErrorBoundary Component Methods in C#\nDESCRIPTION: Overrides the BuildRenderTree and OnErrorAsync methods for the ErrorBoundary component in ASP.NET Core Web.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Components.Web.ErrorBoundary.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder! builder) -> void\noverride Microsoft.AspNetCore.Components.Web.ErrorBoundary.OnErrorAsync(System.Exception! exception) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining ConfirmEmailChangeModel for ASP.NET Core Identity UI V5\nDESCRIPTION: This snippet defines the ConfirmEmailChangeModel class for ASP.NET Core Identity UI version 5. It includes a constructor and properties for managing status messages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ConfirmEmailChangeModel\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ConfirmEmailChangeModel.ConfirmEmailChangeModel() -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ConfirmEmailChangeModel.StatusMessage.get -> string?\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ConfirmEmailChangeModel.StatusMessage.set -> void\n```\n\n----------------------------------------\n\nTITLE: MVC Diagnostic Event Constants\nDESCRIPTION: Constant definitions for ASP.NET Core MVC diagnostic event names related to action execution, filtering and results.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.Mvc.Diagnostics.AfterActionEventData.EventName = \"Microsoft.AspNetCore.Mvc.AfterAction\" -> string!\nconst Microsoft.AspNetCore.Mvc.Diagnostics.BeforeActionEventData.EventName = \"Microsoft.AspNetCore.Mvc.BeforeAction\" -> string!\n```\n\n----------------------------------------\n\nTITLE: Setting Root Directory for Razor Pages with MVC Core in ASP.NET Core\nDESCRIPTION: Extension method for IMvcCoreBuilder that sets a custom root directory for Razor Pages. Similar to the IMvcBuilder version but for applications using the more lightweight MVC Core system.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.MvcRazorPagesMvcCoreBuilderExtensions.WithRazorPagesRoot(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder! builder, string! rootDirectory) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder!\n```\n\n----------------------------------------\n\nTITLE: Authentication Service Methods\nDESCRIPTION: Core authentication service methods for handling authentication operations like sign-in, sign-out, challenge, and forbid.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Authentication.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authentication.AuthenticationService.AuthenticateAsync(Microsoft.AspNetCore.Http.HttpContext! context, string? scheme) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authentication.AuthenticateResult!>!\nvirtual Microsoft.AspNetCore.Authentication.AuthenticationService.SignInAsync(Microsoft.AspNetCore.Http.HttpContext! context, string? scheme, System.Security.Claims.ClaimsPrincipal! principal, Microsoft.AspNetCore.Authentication.AuthenticationProperties? properties) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.AuthenticationService.SignOutAsync(Microsoft.AspNetCore.Http.HttpContext! context, string? scheme, Microsoft.AspNetCore.Authentication.AuthenticationProperties? properties) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Updating Dependabot Configuration for Submodule Updates\nDESCRIPTION: Reference to the dependabot.yml configuration file that needs to be updated to list currently active release branches for submodule updates in the main branch.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/UpdatingMajorVersionAndTFM.md#2025-04-08_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n.github/dependabot.yml#L74-L85\n```\n\n----------------------------------------\n\nTITLE: Defining WebHost Static Methods in C#\nDESCRIPTION: Defines static methods for the WebHost class, including methods for creating default builders, starting web hosts, and configuring routes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DefaultBuilder/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.WebHost\nstatic Microsoft.AspNetCore.WebHost.CreateDefaultBuilder() -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\nstatic Microsoft.AspNetCore.WebHost.CreateDefaultBuilder(string![]! args) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\nstatic Microsoft.AspNetCore.WebHost.CreateDefaultBuilder<TStartup>(string![]! args) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\nstatic Microsoft.AspNetCore.WebHost.Start(Microsoft.AspNetCore.Http.RequestDelegate! app) -> Microsoft.AspNetCore.Hosting.IWebHost!\nstatic Microsoft.AspNetCore.WebHost.Start(string! url, Microsoft.AspNetCore.Http.RequestDelegate! app) -> Microsoft.AspNetCore.Hosting.IWebHost!\nstatic Microsoft.AspNetCore.WebHost.Start(string! url, System.Action<Microsoft.AspNetCore.Routing.IRouteBuilder!>! routeBuilder) -> Microsoft.AspNetCore.Hosting.IWebHost!\nstatic Microsoft.AspNetCore.WebHost.Start(System.Action<Microsoft.AspNetCore.Routing.IRouteBuilder!>! routeBuilder) -> Microsoft.AspNetCore.Hosting.IWebHost!\nstatic Microsoft.AspNetCore.WebHost.StartWith(string! url, System.Action<Microsoft.AspNetCore.Builder.IApplicationBuilder!>! app) -> Microsoft.AspNetCore.Hosting.IWebHost!\nstatic Microsoft.AspNetCore.WebHost.StartWith(System.Action<Microsoft.AspNetCore.Builder.IApplicationBuilder!>! app) -> Microsoft.AspNetCore.Hosting.IWebHost!\n```\n\n----------------------------------------\n\nTITLE: Declaring BufferedReadStream Class in C#\nDESCRIPTION: Defines a BufferedReadStream class with methods for buffered reading from a stream, including constructors and methods for ensuring buffer content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/WebUtilities/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.WebUtilities.BufferedReadStream\nMicrosoft.AspNetCore.WebUtilities.BufferedReadStream.BufferedData.get -> System.ArraySegment<byte>\nMicrosoft.AspNetCore.WebUtilities.BufferedReadStream.BufferedReadStream(System.IO.Stream! inner, int bufferSize) -> void\nMicrosoft.AspNetCore.WebUtilities.BufferedReadStream.BufferedReadStream(System.IO.Stream! inner, int bufferSize, System.Buffers.ArrayPool<byte>! bytePool) -> void\nMicrosoft.AspNetCore.WebUtilities.BufferedReadStream.EnsureBuffered() -> bool\nMicrosoft.AspNetCore.WebUtilities.BufferedReadStream.EnsureBuffered(int minCount) -> bool\nMicrosoft.AspNetCore.WebUtilities.BufferedReadStream.EnsureBufferedAsync(int minCount, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>!\nMicrosoft.AspNetCore.WebUtilities.BufferedReadStream.EnsureBufferedAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>!\nMicrosoft.AspNetCore.WebUtilities.BufferedReadStream.ReadLine(int lengthLimit) -> string!\nMicrosoft.AspNetCore.WebUtilities.BufferedReadStream.ReadLineAsync(int lengthLimit, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<string!>!\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Implementation for ASP.NET Core\nDESCRIPTION: Implements the IParameterBindingMetadata interface to store information about request parameters, including parsing capabilities, binding options, and parameter characteristics. This class is used during request processing to determine how parameters should be bound from HTTP requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_StringArrayParam.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AngularCliBuilder Class in C#\nDESCRIPTION: Defines the AngularCliBuilder class for building Angular CLI projects in ASP.NET Core. Includes a constructor and a Build method for integrating with the SPA builder.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Spa/SpaServices.Extensions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SpaServices.AngularCli.AngularCliBuilder\nMicrosoft.AspNetCore.SpaServices.AngularCli.AngularCliBuilder.AngularCliBuilder(string! npmScript) -> void\nMicrosoft.AspNetCore.SpaServices.AngularCli.AngularCliBuilder.Build(Microsoft.AspNetCore.SpaServices.ISpaBuilder! spaBuilder) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Handling Implicit Body Not Provided Error in ASP.NET Core\nDESCRIPTION: Handles cases where an implicit body is inferred for a parameter but no request body was provided. Provides guidance in the error message suggesting the user might have intended to use a Service instead. Either throws an exception or logs the error.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndGet_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic void ImplicitBodyNotProvided(string parameterName)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Extension Method in C#\nDESCRIPTION: Generates a MapGet extension method for IEndpointRouteBuilder to handle GET requests. It includes metadata population, request delegate creation, and JSON serialization logic.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedRouteBuilderExtensionsCore\n{\n    private static readonly JsonOptions FallbackJsonOptions = new();\n    private static readonly string[] GetVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Get };\n\n    %INTERCEPTSLOCATIONATTRIBUTE%\n    internal static RouteHandlerBuilder MapGet0(\n        this IEndpointRouteBuilder endpoints,\n        [StringSyntax(\"Route\")] string pattern,\n        Delegate handler)\n    {\n        MetadataPopulator populateMetadata = (methodInfo, options) =>\n        {\n            // Metadata population logic\n        };\n        RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n        {\n            // Request delegate creation logic\n        };\n\n        async Task RequestHandler(HttpContext httpContext)\n        {\n            // Request handling logic\n        }\n\n        async Task RequestHandlerFiltered(HttpContext httpContext)\n        {\n            // Filtered request handling logic\n        }\n\n        // Method implementation continues...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Static RenderMode Properties in C#\nDESCRIPTION: Defines static properties for different render modes in ASP.NET Core Web Components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.Web.RenderMode.InteractiveAuto.get -> Microsoft.AspNetCore.Components.Web.InteractiveAutoRenderMode!\nstatic Microsoft.AspNetCore.Components.Web.RenderMode.InteractiveServer.get -> Microsoft.AspNetCore.Components.Web.InteractiveServerRenderMode!\nstatic Microsoft.AspNetCore.Components.Web.RenderMode.InteractiveWebAssembly.get -> Microsoft.AspNetCore.Components.Web.InteractiveWebAssemblyRenderMode!\n```\n\n----------------------------------------\n\nTITLE: EditContextDataAnnotationsExtensions API for ASP.NET Core Blazor Forms\nDESCRIPTION: Static extensions methods for adding DataAnnotations validation support to an EditContext. These methods configure an EditContext to use DataAnnotations validation with optional service provider integration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Forms/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Forms.EditContextDataAnnotationsExtensions\nstatic Microsoft.AspNetCore.Components.Forms.EditContextDataAnnotationsExtensions.AddDataAnnotationsValidation(this Microsoft.AspNetCore.Components.Forms.EditContext! editContext) -> Microsoft.AspNetCore.Components.Forms.EditContext!\nstatic Microsoft.AspNetCore.Components.Forms.EditContextDataAnnotationsExtensions.EnableDataAnnotationsValidation(this Microsoft.AspNetCore.Components.Forms.EditContext! editContext) -> System.IDisposable!\nstatic Microsoft.AspNetCore.Components.Forms.EditContextDataAnnotationsExtensions.EnableDataAnnotationsValidation(this Microsoft.AspNetCore.Components.Forms.EditContext! editContext, System.IServiceProvider! serviceProvider) -> System.IDisposable!\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Status Codes in ASP.NET Core\nDESCRIPTION: Constants defining standard HTTP status codes from 406 to 511, including both standard and custom status codes. Each constant maps a descriptive name to its numeric value.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nconst Microsoft.AspNetCore.Http.StatusCodes.Status406NotAcceptable = 406 -> int\nconst Microsoft.AspNetCore.Http.StatusCodes.Status407ProxyAuthenticationRequired = 407 -> int\n// ... additional status codes ...\nconst Microsoft.AspNetCore.Http.StatusCodes.Status511NetworkAuthenticationRequired = 511 -> int\n```\n\n----------------------------------------\n\nTITLE: Endpoint Filter Chain Builder\nDESCRIPTION: Builds a chain of endpoint filters by applying filter factories in reverse order. Creates the final filtered invocation pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitSource_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IHubProtocol Interface for SignalR\nDESCRIPTION: Interface for hub protocols that defines methods for serializing and deserializing hub messages. Provides functionality to parse messages from byte sequences and convert messages to bytes for transmission.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.GetMessageBytes(Microsoft.AspNetCore.SignalR.Protocol.HubMessage! message) -> System.ReadOnlyMemory<byte>\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.IsVersionSupported(int version) -> bool\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.Name.get -> string!\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.TransferFormat.get -> Microsoft.AspNetCore.Connections.TransferFormat\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.TryParseMessage(ref System.Buffers.ReadOnlySequence<byte> input, Microsoft.AspNetCore.SignalR.IInvocationBinder! binder, out Microsoft.AspNetCore.SignalR.Protocol.HubMessage? message) -> bool\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.Version.get -> int\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.WriteMessage(Microsoft.AspNetCore.SignalR.Protocol.HubMessage! message, System.Buffers.IBufferWriter<byte>! output) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining IRequestCultureFeature Interface in C#\nDESCRIPTION: Defines the IRequestCultureFeature interface for accessing request culture information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Localization.IRequestCultureFeature\nMicrosoft.AspNetCore.Localization.IRequestCultureFeature.Provider.get -> Microsoft.AspNetCore.Localization.IRequestCultureProvider?\nMicrosoft.AspNetCore.Localization.IRequestCultureFeature.RequestCulture.get -> Microsoft.AspNetCore.Localization.RequestCulture!\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft.AspNetCore.DataProtection.EntityFrameworkCore via dotnet CLI\nDESCRIPTION: Command to install the Microsoft.AspNetCore.DataProtection.EntityFrameworkCore package using the dotnet CLI tool. This package enables storing data protection keys in a database using Entity Framework Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/EntityFrameworkCore/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.DataProtection.EntityFrameworkCore\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Class for ASP.NET Core in C#\nDESCRIPTION: This class represents metadata for parameter binding in ASP.NET Core, including information about the parameter name, type, and binding capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsSameInterceptorsFromDifferentFiles.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HtmlAttributeNameAttribute in C#\nDESCRIPTION: Declaration of the HtmlAttributeNameAttribute class in the Microsoft.AspNetCore.Razor.TagHelpers namespace. This attribute is used to specify HTML attribute names for tag helpers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Razor/Razor.Runtime/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Razor.TagHelpers.HtmlAttributeNameAttribute (forwarded, contained in Microsoft.AspNetCore.Razor)\nMicrosoft.AspNetCore.Razor.TagHelpers.HtmlAttributeNameAttribute.DictionaryAttributePrefixSet.get -> bool (forwarded, contained in Microsoft.AspNetCore.Razor)\nMicrosoft.AspNetCore.Razor.TagHelpers.HtmlAttributeNameAttribute.HtmlAttributeNameAttribute() -> void (forwarded, contained in Microsoft.AspNetCore.Razor)\n```\n\n----------------------------------------\n\nTITLE: Implementing ModelBinderFactoryContext Class in C#\nDESCRIPTION: This code defines the ModelBinderFactoryContext class with nullable reference types enabled. The class provides properties for accessing model metadata and binding context information required for model binding in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Enabling OpenID Connect Authentication Middleware in ASP.NET Core\nDESCRIPTION: This code snippet shows how to enable the OpenID Connect authentication middleware in the ASP.NET Core request pipeline. It ensures that the authentication middleware is added and ready to process requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/PACKAGE.md#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar app = builder.Build();\n\napp.UseAuthentication();\n```\n\n----------------------------------------\n\nTITLE: Implementing Utf8ContentHttpResult in ASP.NET Core\nDESCRIPTION: API signatures for the Utf8ContentHttpResult class, which returns a UTF-8 encoded content response with optional content type and status code.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.Utf8ContentHttpResult\nMicrosoft.AspNetCore.Http.HttpResults.Utf8ContentHttpResult.ContentType.get -> string?\nMicrosoft.AspNetCore.Http.HttpResults.Utf8ContentHttpResult.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.Utf8ContentHttpResult.ResponseContent.get -> System.ReadOnlyMemory<byte>\nMicrosoft.AspNetCore.Http.HttpResults.Utf8ContentHttpResult.StatusCode.get -> int?\n```\n\n----------------------------------------\n\nTITLE: Validation HTML Attribute Provider Interface in C#\nDESCRIPTION: Abstract interface definition for providing validation attributes in ASP.NET Core MVC views.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Mvc.ViewFeatures.ValidationHtmlAttributeProvider.AddValidationAttributes(Microsoft.AspNetCore.Mvc.Rendering.ViewContext viewContext, Microsoft.AspNetCore.Mvc.ViewFeatures.ModelExplorer modelExplorer, System.Collections.Generic.IDictionary<string, string> attributes) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining OpenAPI Schema in JSON for ASP.NET Core Application\nDESCRIPTION: This JSON document defines an OpenAPI schema for an ASP.NET Core web API. It includes API endpoint definitions, request body schemas, component definitions with various object models, inheritance relationships with discriminators, and reference relationships between objects.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/test/Microsoft.AspNetCore.OpenApi.Tests/Integration/snapshots/OpenApi3_0/OpenApiDocumentIntegrationTests.VerifyOpenApiDocument_documentName=schemas-by-ref.verified.txt#2025-04-08_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"required\": true\n},\n\"responses\": {\n  \"200\": {\n    \"description\": \"OK\"\n  }\n}\n}\n},\n\"/schemas-by-ref/parent\": {\n\"post\": {\n\"tags\": [\n  \"Sample\"\n],\n\"requestBody\": {\n  \"content\": {\n    \"application/json\": {\n      \"schema\": {\n        \"$ref\": \"#/components/schemas/ParentObject\"\n      }\n    }\n  },\n  \"required\": true\n},\n\"responses\": {\n  \"200\": {\n    \"description\": \"OK\"\n  }\n}\n}\n},\n\"/schemas-by-ref/child\": {\n\"post\": {\n\"tags\": [\n  \"Sample\"\n],\n\"requestBody\": {\n  \"content\": {\n    \"application/json\": {\n      \"schema\": {\n        \"$ref\": \"#/components/schemas/ChildObject\"\n      }\n    }\n  },\n  \"required\": true\n},\n\"responses\": {\n  \"200\": {\n    \"description\": \"OK\"\n  }\n}\n}\n}\n},\n\"components\": {\n\"schemas\": {\n\"Account\": {\n\"type\": \"object\",\n\"properties\": {\n  \"id\": {\n    \"type\": \"integer\",\n    \"format\": \"int32\"\n  },\n  \"name\": {\n    \"type\": \"string\"\n  }\n}\n},\n\"AddressDto\": {\n\"required\": [\n  \"relatedLocation\"\n],\n\"type\": \"object\",\n\"properties\": {\n  \"relatedLocation\": {\n    \"$ref\": \"#/components/schemas/LocationDto\"\n  }\n}\n},\n\"Category\": {\n\"required\": [\n  \"name\",\n  \"parent\"\n],\n\"type\": \"object\",\n\"properties\": {\n  \"name\": {\n    \"type\": \"string\"\n  },\n  \"parent\": {\n    \"$ref\": \"#/components/schemas/Category\"\n  },\n  \"tags\": { }\n}\n},\n\"ChildObject\": {\n\"required\": [\n  \"parent\"\n],\n\"type\": \"object\",\n\"properties\": {\n  \"id\": {\n    \"type\": \"integer\",\n    \"format\": \"int32\"\n  },\n  \"parent\": {\n    \"$ref\": \"#/components/schemas/ParentObject\"\n  }\n}\n},\n\"ContainerType\": {\n\"type\": \"object\",\n\"properties\": {\n  \"seq1\": {\n    \"type\": \"array\",\n    \"items\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    }\n  },\n  \"seq2\": {\n    \"type\": \"array\",\n    \"items\": { }\n  }\n}\n},\n\"Item\": {\n\"type\": \"object\",\n\"properties\": {\n  \"name\": { },\n  \"value\": {\n    \"type\": \"integer\",\n    \"format\": \"int32\"\n  }\n}\n},\n\"LocationContainer\": {\n\"required\": [\n  \"location\"\n],\n\"type\": \"object\",\n\"properties\": {\n  \"location\": {\n    \"$ref\": \"#/components/schemas/LocationDto\"\n  }\n}\n},\n\"LocationDto\": {\n\"required\": [\n  \"address\"\n],\n\"type\": \"object\",\n\"properties\": {\n  \"address\": {\n    \"$ref\": \"#/components/schemas/AddressDto\"\n  }\n}\n},\n\"ParentObject\": {\n\"type\": \"object\",\n\"properties\": {\n  \"id\": {\n    \"type\": \"integer\",\n    \"format\": \"int32\"\n  },\n  \"children\": {\n    \"type\": \"array\",\n    \"items\": {\n      \"$ref\": \"#/components/schemas/ChildObject\"\n    }\n  }\n}\n},\n\"Person\": {\n\"required\": [\n  \"discriminator\"\n],\n\"type\": \"object\",\n\"anyOf\": [\n  {\n    \"$ref\": \"#/components/schemas/PersonStudent\"\n  },\n  {\n    \"$ref\": \"#/components/schemas/PersonTeacher\"\n  }\n],\n\"discriminator\": {\n  \"propertyName\": \"discriminator\",\n  \"mapping\": {\n    \"student\": \"#/components/schemas/PersonStudent\",\n    \"teacher\": \"#/components/schemas/PersonTeacher\"\n  }\n}\n},\n\"PersonStudent\": {\n\"properties\": {\n  \"discriminator\": {\n    \"enum\": [\n      \"student\"\n    ],\n    \"type\": \"string\"\n  },\n  \"gpa\": {\n    \"type\": \"number\",\n    \"format\": \"double\"\n  }\n}\n},\n\"PersonTeacher\": {\n\"required\": [\n  \"subject\"\n],\n\"properties\": {\n  \"discriminator\": {\n    \"enum\": [\n      \"teacher\"\n    ],\n    \"type\": \"string\"\n  },\n  \"subject\": {\n    \"type\": \"string\"\n  }\n}\n},\n\"Product\": {\n\"type\": \"object\",\n\"properties\": {\n  \"id\": {\n    \"type\": \"integer\",\n    \"format\": \"int32\"\n  },\n  \"name\": {\n    \"type\": \"string\"\n  }\n}\n},\n\"Root\": {\n\"type\": \"object\",\n\"properties\": {\n  \"item1\": {\n    \"$ref\": \"#/components/schemas/Item\"\n  },\n  \"item2\": {\n    \"$ref\": \"#/components/schemas/Item\"\n  }\n}\n},\n\"Shape\": {\n\"required\": [\n  \"$type\"\n],\n\"type\": \"object\",\n\"anyOf\": [\n  {\n    \"$ref\": \"#/components/schemas/ShapeTriangle\"\n  },\n  {\n    \"$ref\": \"#/components/schemas/ShapeSquare\"\n  }\n],\n\"discriminator\": {\n  \"propertyName\": \"$type\",\n  \"mapping\": {\n    \"triangle\": \"#/components/schemas/ShapeTriangle\",\n    \"square\": \"#/components/schemas/ShapeSquare\"\n  }\n}\n},\n\"ShapeSquare\": {\n\"properties\": {\n  \"$type\": {\n    \"enum\": [\n      \"square\"\n    ],\n    \"type\": \"string\"\n  },\n  \"area\": {\n    \"type\": \"number\",\n    \"format\": \"double\"\n  },\n  \"color\": {\n    \"type\": \"string\"\n  },\n  \"sides\": {\n    \"type\": \"integer\",\n    \"format\": \"int32\"\n  }\n}\n},\n\"ShapeTriangle\": {\n\"properties\": {\n  \"$type\": {\n    \"enum\": [\n      \"triangle\"\n    ],\n    \"type\": \"string\"\n  },\n  \"hypotenuse\": {\n    \"type\": \"number\",\n    \"format\": \"double\"\n  },\n  \"color\": {\n    \"type\": \"string\"\n  },\n  \"sides\": {\n    \"type\": \"integer\",\n    \"format\": \"int32\"\n  }\n}\n},\n\"Tag\": {\n\"required\": [\n  \"name\"\n],\n\"type\": \"object\",\n\"properties\": {\n  \"name\": {\n    \"type\": \"string\"\n  }\n}\n},\n\"Triangle\": {\n\"type\": \"object\",\n\"properties\": {\n  \"hypotenuse\": {\n    \"type\": \"number\",\n    \"format\": \"double\"\n  },\n  \"color\": {\n    \"type\": \"string\"\n  },\n  \"sides\": {\n    \"type\": \"integer\",\n    \"format\": \"int32\"\n  }\n}\n},\n\"WeatherForecastBase\": {\n\"required\": [\n  \"$type\"\n],\n\"type\": \"object\",\n\"anyOf\": [\n  {\n    \"$ref\": \"#/components/schemas/WeatherForecastBaseWeatherForecastWithCity\"\n  },\n  {\n    \"$ref\": \"#/components/schemas/WeatherForecastBaseWeatherForecastWithTimeSeries\"\n  },\n  {\n    \"$ref\": \"#/components/schemas/WeatherForecastBaseWeatherForecastWithLocalNews\"\n  }\n],\n\"discriminator\": {\n  \"propertyName\": \"$type\",\n  \"mapping\": {\n    \"0\": \"#/components/schemas/WeatherForecastBaseWeatherForecastWithCity\",\n    \"1\": \"#/components/schemas/WeatherForecastBaseWeatherForecastWithTimeSeries\",\n    \"2\": \"#/components/schemas/WeatherForecastBaseWeatherForecastWithLocalNews\"\n  }\n}\n},\n\"WeatherForecastBaseWeatherForecastWithCity\": {\n\"required\": [\n  \"city\"\n],\n\"properties\": {\n  \"$type\": {\n    \"enum\": [\n      0\n    ],\n    \"type\": \"integer\"\n  },\n  \"city\": {\n    \"type\": \"string\"\n  }\n}\n},\n\"WeatherForecastBaseWeatherForecastWithLocalNews\": {\n\"required\": [\n  \"news\"\n],\n\"properties\": {\n  \"$type\": {\n    \"enum\": [\n      2\n    ],\n    \"type\": \"integer\"\n  },\n  \"news\": {\n    \"type\": \"string\"\n  }\n}\n},\n\"WeatherForecastBaseWeatherForecastWithTimeSeries\": {\n\"required\": [\n  \"summary\"\n],\n\"properties\": {\n  \"$type\": {\n    \"enum\": [\n      1\n    ],\n    \"type\": \"integer\"\n  },\n  \"date\": {\n    \"type\": \"string\",\n    \"format\": \"date-time\"\n  },\n  \"temperatureC\": {\n    \"type\": \"integer\",\n    \"format\": \"int32\"\n  },\n  \"summary\": {\n    \"type\": \"string\"\n  }\n}\n}\n}\n},\n\"tags\": [\n{\n  \"name\": \"Sample\"\n}\n]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Authentication Interfaces in C#\nDESCRIPTION: Defines various interfaces related to authentication, including IAuthenticateResultFeature, IAuthenticationConfigurationProvider, IAuthenticationFeature.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Authentication.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.IAuthenticateResultFeature\nMicrosoft.AspNetCore.Authentication.IAuthenticateResultFeature.AuthenticateResult.get -> Microsoft.AspNetCore.Authentication.AuthenticateResult?\nMicrosoft.AspNetCore.Authentication.IAuthenticateResultFeature.AuthenticateResult.set -> void\nMicrosoft.AspNetCore.Authentication.IAuthenticationConfigurationProvider\nMicrosoft.AspNetCore.Authentication.IAuthenticationConfigurationProvider.AuthenticationConfiguration.get -> Microsoft.Extensions.Configuration.IConfiguration!\nMicrosoft.AspNetCore.Authentication.IAuthenticationFeature\nMicrosoft.AspNetCore.Authentication.IAuthenticationFeature.OriginalPath.get -> Microsoft.AspNetCore.Http.PathString\nMicrosoft.AspNetCore.Authentication.IAuthenticationFeature.OriginalPath.set -> void\nMicrosoft.AspNetCore.Authentication.IAuthenticationFeature.OriginalPathBase.get -> Microsoft.AspNetCore.Http.PathString\n```\n\n----------------------------------------\n\nTITLE: Displaying ASP Diagnostic Codes in Markdown\nDESCRIPTION: A markdown table listing ASP-specific diagnostic codes (ASP0000-ASP0028) with their corresponding descriptions. These codes cover various ASP.NET Core configuration and usage warnings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/list-of-diagnostics.md#2025-04-08_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n### ASP  (`ASP0000-ASP0024`)\n\n| Diagnostic ID     | Description |\n| :---------------- | :---------- |\n|  __`ASP0000`__ | Do not call 'IServiceCollection.BuildServiceProvider' in 'ConfigureServices' |\n|  __`ASP0001`__ | Authorization middleware is incorrectly configured |\n|  __`ASP0003`__ | Do not use model binding attributes with route handlers |\n|  __`ASP0004`__ | Do not use action results with route handlers |\n|  __`ASP0005`__ | Do not place attribute on method called by route handler lambda |\n|  __`ASP0006`__ | Do not use non-literal sequence numbers |\n|  __`ASP0007`__ | Route parameter and argument optionality is mismatched |\n|  __`ASP0008`__ | Do not use ConfigureWebHost with WebApplicationBuilder.Host |\n|  __`ASP0009`__ | Do not use Configure with WebApplicationBuilder.WebHost |\n|  __`ASP0010`__ | Do not use UseStartup with WebApplicationBuilder.WebHost |\n|  __`ASP0011`__ | Suggest using builder.Logging over Host.ConfigureLogging or WebHost.ConfigureLogging |\n|  __`ASP0012`__ | Suggest using builder.Services over Host.ConfigureServices or WebHost.ConfigureServices |\n|  __`ASP0013`__ | Suggest switching from using Configure methods to WebApplicationBuilder.Configuration |\n|  __`ASP0014`__ | Suggest using top level route registrations |\n|  __`ASP0015`__ | Suggest using IHeaderDictionary properties |\n|  __`ASP0016`__ | Do not return a value from RequestDelegate |\n|  __`ASP0017`__ | Invalid route pattern |\n|  __`ASP0018`__ | Unused route parameter |\n|  __`ASP0019`__ | Suggest using IHeaderDictionary.Append or the indexer |\n|  __`ASP0020`__ | Complex types referenced by route parameters must be parsable |\n|  __`ASP0021`__ | When implementing BindAsync(...) method, the return type must be ValueTask<T> |\n|  __`ASP0022`__ | Route conflict detected between route handlers |\n|  __`ASP0023`__ | Route conflict detected between controller actions |\n|  __`ASP0024`__ | Route handler has multiple parameters with the [FromBody] attribute |\n|  __`ASP0025`__ | Use AddAuthorizationBuilder |\n|  __`ASP0026`__ | [Authorize] overridden by [AllowAnonymous] from farther away |\n|  __`ASP0027`__ | Unnecessary public Program class declaration |\n|  __`ASP0028`__ | Consider using ListenAnyIP() instead of Listen(IPAddress.Any) |\n```\n\n----------------------------------------\n\nTITLE: Virtual File Response Methods in ASP.NET Core ControllerBase (C#)\nDESCRIPTION: Methods to return file content from virtual paths within the web host. These methods support specifying content type, download name, caching parameters, and range processing options for virtual file downloads.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_50\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(string! virtualPath, string! contentType) -> Microsoft.AspNetCore.Mvc.VirtualFileResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(string! virtualPath, string! contentType, bool enableRangeProcessing) -> Microsoft.AspNetCore.Mvc.VirtualFileResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(string! virtualPath, string! contentType, string? fileDownloadName) -> Microsoft.AspNetCore.Mvc.VirtualFileResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(string! virtualPath, string! contentType, string? fileDownloadName, bool enableRangeProcessing) -> Microsoft.AspNetCore.Mvc.VirtualFileResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(string! virtualPath, string! contentType, string? fileDownloadName, System.DateTimeOffset? lastModified, Microsoft.Net.Http.Headers.EntityTagHeaderValue! entityTag) -> Microsoft.AspNetCore.Mvc.VirtualFileResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(string! virtualPath, string! contentType, string? fileDownloadName, System.DateTimeOffset? lastModified, Microsoft.Net.Http.Headers.EntityTagHeaderValue! entityTag, bool enableRangeProcessing) -> Microsoft.AspNetCore.Mvc.VirtualFileResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(string! virtualPath, string! contentType, System.DateTimeOffset? lastModified, Microsoft.Net.Http.Headers.EntityTagHeaderValue! entityTag) -> Microsoft.AspNetCore.Mvc.VirtualFileResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(string! virtualPath, string! contentType, System.DateTimeOffset? lastModified, Microsoft.Net.Http.Headers.EntityTagHeaderValue! entityTag, bool enableRangeProcessing) -> Microsoft.AspNetCore.Mvc.VirtualFileResult!\n```\n\n----------------------------------------\n\nTITLE: Getting Properties from ApiDescription in ASP.NET Core API Explorer\nDESCRIPTION: Extension method that retrieves a property of type T from an ApiDescription object. This method enables storing and retrieving custom metadata on API descriptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ApiExplorer/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Mvc.ApiExplorer.ApiDescriptionExtensions.GetProperty<T>(this Microsoft.AspNetCore.Mvc.ApiExplorer.ApiDescription! apiDescription) -> T?\n```\n\n----------------------------------------\n\nTITLE: ConnectionBuilderExtensions Static Methods\nDESCRIPTION: Extension methods for IConnectionBuilder to handle middleware configuration and connection handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.Run(this Microsoft.AspNetCore.Connections.IConnectionBuilder! connectionBuilder, System.Func<Microsoft.AspNetCore.Connections.ConnectionContext!, System.Threading.Tasks.Task!>! middleware) -> Microsoft.AspNetCore.Connections.IConnectionBuilder!\nstatic Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.Use(this Microsoft.AspNetCore.Connections.IConnectionBuilder! connectionBuilder, System.Func<Microsoft.AspNetCore.Connections.ConnectionContext!, Microsoft.AspNetCore.Connections.ConnectionDelegate!, System.Threading.Tasks.Task!>! middleware) -> Microsoft.AspNetCore.Connections.IConnectionBuilder!\nstatic Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.Use(this Microsoft.AspNetCore.Connections.IConnectionBuilder! connectionBuilder, System.Func<Microsoft.AspNetCore.Connections.ConnectionContext!, System.Func<System.Threading.Tasks.Task!>!, System.Threading.Tasks.Task!>! middleware) -> Microsoft.AspNetCore.Connections.IConnectionBuilder!\nstatic Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.UseConnectionHandler<TConnectionHandler>(this Microsoft.AspNetCore.Connections.IConnectionBuilder! connectionBuilder) -> Microsoft.AspNetCore.Connections.IConnectionBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining JWT Bearer Authentication Scheme Constant\nDESCRIPTION: Defines the default authentication scheme name constant for JWT Bearer authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/JwtBearer/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\nconst Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerDefaults.AuthenticationScheme = \"Bearer\"\n```\n\n----------------------------------------\n\nTITLE: InputNumber Generic Component API\nDESCRIPTION: API signature for the InputNumber<TValue> component which renders an input element for numeric values, including properties for Element reference, constructor, and customizable parsing error message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Forms.InputNumber<TValue>\nMicrosoft.AspNetCore.Components.Forms.InputNumber<TValue>.Element.get -> Microsoft.AspNetCore.Components.ElementReference?\nMicrosoft.AspNetCore.Components.Forms.InputNumber<TValue>.Element.set -> void\nMicrosoft.AspNetCore.Components.Forms.InputNumber<TValue>.InputNumber() -> void\nMicrosoft.AspNetCore.Components.Forms.InputNumber<TValue>.ParsingErrorMessage.get -> string!\nMicrosoft.AspNetCore.Components.Forms.InputNumber<TValue>.ParsingErrorMessage.set -> void\n```\n\n----------------------------------------\n\nTITLE: Mapping Routes and Creating Request Delegates in ASP.NET Core\nDESCRIPTION: This method maps routes and creates request delegates using the provided parameters. It handles metadata population and delegate creation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_MultipleStringParam_StringReturn.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ServerIntegratedAuth Class in ASP.NET Core\nDESCRIPTION: Implementation of the IServerIntegratedAuth interface that provides integrated authentication functionality. It includes properties for the authentication scheme and enabled status, along with a default constructor.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Server.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Hosting.Server.ServerIntegratedAuth\nMicrosoft.AspNetCore.Hosting.Server.ServerIntegratedAuth.AuthenticationScheme.get -> string!\nMicrosoft.AspNetCore.Hosting.Server.ServerIntegratedAuth.AuthenticationScheme.set -> void\nMicrosoft.AspNetCore.Hosting.Server.ServerIntegratedAuth.IsEnabled.get -> bool\nMicrosoft.AspNetCore.Hosting.Server.ServerIntegratedAuth.IsEnabled.set -> void\nMicrosoft.AspNetCore.Hosting.Server.ServerIntegratedAuth.ServerIntegratedAuth() -> void\n```\n\n----------------------------------------\n\nTITLE: Encoding StreamInvocation Message in MessagePack\nDESCRIPTION: Illustrates the structure and encoding of a StreamInvocation message in the SignalR MessagePack protocol. It includes message type, headers, invocation ID, target, arguments, and stream IDs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_5\n\nLANGUAGE: MessagePack\nCODE:\n```\n[4, Headers, InvocationId, Target, [Arguments], [StreamIds]]\n```\n\n----------------------------------------\n\nTITLE: Defining RequestHeaders Class in C#\nDESCRIPTION: This snippet defines the RequestHeaders class, which represents HTTP request headers. It includes properties and methods for accessing and manipulating various standard and custom headers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Accept.get -> System.Collections.Generic.IList<Microsoft.Net.Http.Headers.MediaTypeHeaderValue!>!\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Accept.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.AcceptCharset.get -> System.Collections.Generic.IList<Microsoft.Net.Http.Headers.StringWithQualityHeaderValue!>!\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.AcceptCharset.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.AcceptEncoding.get -> System.Collections.Generic.IList<Microsoft.Net.Http.Headers.StringWithQualityHeaderValue!>!\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.AcceptEncoding.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.AcceptLanguage.get -> System.Collections.Generic.IList<Microsoft.Net.Http.Headers.StringWithQualityHeaderValue!>!\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.AcceptLanguage.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Append(string! name, object! value) -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.AppendList<T>(string! name, System.Collections.Generic.IList<T>! values) -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.CacheControl.get -> Microsoft.Net.Http.Headers.CacheControlHeaderValue?\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.CacheControl.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.ContentDisposition.get -> Microsoft.Net.Http.Headers.ContentDispositionHeaderValue?\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.ContentDisposition.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.ContentLength.get -> long?\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.ContentLength.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.ContentRange.get -> Microsoft.Net.Http.Headers.ContentRangeHeaderValue?\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.ContentRange.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.ContentType.get -> Microsoft.Net.Http.Headers.MediaTypeHeaderValue?\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.ContentType.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Cookie.get -> System.Collections.Generic.IList<Microsoft.Net.Http.Headers.CookieHeaderValue!>!\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Cookie.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Date.get -> System.DateTimeOffset?\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Date.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Expires.get -> System.DateTimeOffset?\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Expires.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Get<T>(string! name) -> T?\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.GetList<T>(string! name) -> System.Collections.Generic.IList<T>!\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Headers.get -> Microsoft.AspNetCore.Http.IHeaderDictionary!\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Host.get -> Microsoft.AspNetCore.Http.HostString\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Host.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.IfMatch.get -> System.Collections.Generic.IList<Microsoft.Net.Http.Headers.EntityTagHeaderValue!>!\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.IfMatch.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.IfModifiedSince.get -> System.DateTimeOffset?\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.IfModifiedSince.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.IfNoneMatch.get -> System.Collections.Generic.IList<Microsoft.Net.Http.Headers.EntityTagHeaderValue!>!\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.IfNoneMatch.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.IfRange.get -> Microsoft.Net.Http.Headers.RangeConditionHeaderValue?\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.IfRange.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.IfUnmodifiedSince.get -> System.DateTimeOffset?\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.IfUnmodifiedSince.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.LastModified.get -> System.DateTimeOffset?\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.LastModified.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Range.get -> Microsoft.Net.Http.Headers.RangeHeaderValue?\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Range.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Referer.get -> System.Uri?\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Referer.set -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.RequestHeaders(Microsoft.AspNetCore.Http.IHeaderDictionary! headers) -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.Set(string! name, object? value) -> void\nMicrosoft.AspNetCore.Http.Headers.RequestHeaders.SetList<T>(string! name, System.Collections.Generic.IList<T>? values) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing MapMethods Route Handler in ASP.NET Core\nDESCRIPTION: Implements a route handler builder extension method for mapping HTTP methods to endpoints. Handles parameter binding, JSON serialization, and request processing with support for filters and middleware.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndPut_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapMethods0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    IEnumerable<string> httpMethods,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n        var serviceProviderIsService = serviceProvider.GetRequiredService<IServiceProviderIsService>();\n        var jsonBodyOrServiceTypeTuples = new (bool, Type)[] {\n            #nullable disable\n            (false, typeof(global::System.String[])),\n            #nullable enable\n        };\n        foreach (var (isOptional, type) in jsonBodyOrServiceTypeTuples)\n        {\n            if (!serviceProviderIsService.IsService(type))\n            {\n                options.EndpointBuilder.Metadata.Add(new AcceptsMetadata(type: type, isOptional: isOptional, contentTypes: GeneratedMetadataConstants.JsonContentType));\n                break;\n            }\n        }\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n```\n\n----------------------------------------\n\nTITLE: PageModel ViewComponent Methods\nDESCRIPTION: Methods for rendering view components with support for component name or type and optional arguments.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.ViewComponent(string! componentName) -> Microsoft.AspNetCore.Mvc.ViewComponentResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.ViewComponent(string! componentName, object? arguments) -> Microsoft.AspNetCore.Mvc.ViewComponentResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.ViewComponent(System.Type! componentType) -> Microsoft.AspNetCore.Mvc.ViewComponentResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.ViewComponent(System.Type! componentType, object? arguments) -> Microsoft.AspNetCore.Mvc.ViewComponentResult!\n```\n\n----------------------------------------\n\nTITLE: Implementing GridItemsProvider in C#\nDESCRIPTION: This snippet defines the GridItemsProviderRequest and GridItemsProviderResult classes, which are used to handle data requests and responses for the QuickGrid component.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/QuickGrid/Microsoft.AspNetCore.Components.QuickGrid/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProvider<TGridItem>\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderRequest<TGridItem>\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderRequest<TGridItem>.ApplySorting(System.Linq.IQueryable<TGridItem>! source) -> System.Linq.IQueryable<TGridItem>!\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderRequest<TGridItem>.CancellationToken.get -> System.Threading.CancellationToken\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderRequest<TGridItem>.CancellationToken.init -> void\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderRequest<TGridItem>.Count.get -> int?\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderRequest<TGridItem>.Count.init -> void\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderRequest<TGridItem>.GetSortByProperties() -> System.Collections.Generic.IReadOnlyCollection<Microsoft.AspNetCore.Components.QuickGrid.SortedProperty>!\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderRequest<TGridItem>.GridItemsProviderRequest() -> void\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderRequest<TGridItem>.SortByAscending.get -> bool\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderRequest<TGridItem>.SortByAscending.init -> void\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderRequest<TGridItem>.SortByColumn.get -> Microsoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>?\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderRequest<TGridItem>.SortByColumn.init -> void\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderRequest<TGridItem>.StartIndex.get -> int\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderRequest<TGridItem>.StartIndex.init -> void\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderResult\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderResult<TGridItem>\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderResult<TGridItem>.GridItemsProviderResult() -> void\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderResult<TGridItem>.Items.get -> System.Collections.Generic.ICollection<TGridItem>!\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderResult<TGridItem>.Items.init -> void\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderResult<TGridItem>.TotalItemCount.get -> int\nMicrosoft.AspNetCore.Components.QuickGrid.GridItemsProviderResult<TGridItem>.TotalItemCount.init -> void\n```\n\n----------------------------------------\n\nTITLE: Generic Parse Method for IParsable Types\nDESCRIPTION: Generic method to attempt parsing a string value to a type that implements IParsable<T> interface.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsDifferentInterceptorsFromSameLocation.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nprivate static bool TryParseExplicit<T>(string? s, IFormatProvider? provider, [MaybeNullWhen(returnValue: false)] out T result) where T: IParsable<T>\n    => T.TryParse(s, provider, out result);\n```\n\n----------------------------------------\n\nTITLE: Controller Property and Parameter Descriptors\nDESCRIPTION: Class definitions for controller property and parameter descriptors, providing reflection-based metadata access.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Controllers.ControllerBoundPropertyDescriptor\nMicrosoft.AspNetCore.Mvc.Controllers.ControllerBoundPropertyDescriptor.PropertyInfo.get -> System.Reflection.PropertyInfo!\nMicrosoft.AspNetCore.Mvc.Controllers.ControllerParameterDescriptor\nMicrosoft.AspNetCore.Mvc.Controllers.ControllerParameterDescriptor.ParameterInfo.get -> System.Reflection.ParameterInfo!\n```\n\n----------------------------------------\n\nTITLE: Static Assets Helper Method Definition\nDESCRIPTION: Helper method to check if a static assets data source exists for given endpoint route builder and manifest path.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/StaticAssets/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.StaticAssets.Infrastructure.StaticAssetsEndpointDataSourceHelper.HasStaticAssetsDataSource(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder! builder, string? staticAssetsManifestPath = null) -> bool\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute Class in System.Runtime.CompilerServices Namespace\nDESCRIPTION: Defines a compiler-generated attribute class that marks methods for interception at specific locations. The attribute accepts version and data parameters to identify interception points.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding View Localization to IMvcCoreBuilder in C#\nDESCRIPTION: This snippet shows multiple overloads of the AddViewLocalization extension method for IMvcCoreBuilder. These methods allow configuration of view localization options and language view location expander format.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.MvcLocalizationMvcCoreBuilderExtensions.AddViewLocalization(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder! builder) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.MvcLocalizationMvcCoreBuilderExtensions.AddViewLocalization(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder! builder, Microsoft.AspNetCore.Mvc.Razor.LanguageViewLocationExpanderFormat format) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.MvcLocalizationMvcCoreBuilderExtensions.AddViewLocalization(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder! builder, Microsoft.AspNetCore.Mvc.Razor.LanguageViewLocationExpanderFormat format, System.Action<Microsoft.Extensions.Localization.LocalizationOptions!>? setupAction) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.MvcLocalizationMvcCoreBuilderExtensions.AddViewLocalization(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder! builder, System.Action<Microsoft.Extensions.Localization.LocalizationOptions!>? setupAction) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder!\n```\n\n----------------------------------------\n\nTITLE: MSAL Authentication Options Configuration in C#\nDESCRIPTION: The MsalAuthenticationOptions class defines configuration settings for MSAL authentication, including authority, client ID, redirect URIs, and validation options. These properties control how the MSAL authentication flow operates.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/Authentication.Msal/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Authentication.WebAssembly.Msal.MsalAuthenticationOptions\nMicrosoft.Authentication.WebAssembly.Msal.MsalAuthenticationOptions.Authority.get -> string?\nMicrosoft.Authentication.WebAssembly.Msal.MsalAuthenticationOptions.Authority.set -> void\nMicrosoft.Authentication.WebAssembly.Msal.MsalAuthenticationOptions.ClientId.get -> string?\nMicrosoft.Authentication.WebAssembly.Msal.MsalAuthenticationOptions.ClientId.set -> void\nMicrosoft.Authentication.WebAssembly.Msal.MsalAuthenticationOptions.KnownAuthorities.get -> System.Collections.Generic.IList<string!>!\nMicrosoft.Authentication.WebAssembly.Msal.MsalAuthenticationOptions.KnownAuthorities.set -> void\nMicrosoft.Authentication.WebAssembly.Msal.MsalAuthenticationOptions.MsalAuthenticationOptions() -> void\nMicrosoft.Authentication.WebAssembly.Msal.MsalAuthenticationOptions.NavigateToLoginRequestUrl.get -> bool\nMicrosoft.Authentication.WebAssembly.Msal.MsalAuthenticationOptions.NavigateToLoginRequestUrl.set -> void\nMicrosoft.Authentication.WebAssembly.Msal.MsalAuthenticationOptions.PostLogoutRedirectUri.get -> string?\nMicrosoft.Authentication.WebAssembly.Msal.MsalAuthenticationOptions.PostLogoutRedirectUri.set -> void\nMicrosoft.Authentication.WebAssembly.Msal.MsalAuthenticationOptions.RedirectUri.get -> string?\nMicrosoft.Authentication.WebAssembly.Msal.MsalAuthenticationOptions.RedirectUri.set -> void\nMicrosoft.Authentication.WebAssembly.Msal.MsalAuthenticationOptions.ValidateAuthority.get -> bool\nMicrosoft.Authentication.WebAssembly.Msal.MsalAuthenticationOptions.ValidateAuthority.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining IResponseCachingFeature Interface in ASP.NET Core (C#)\nDESCRIPTION: Declaration of the IResponseCachingFeature interface in the Microsoft.AspNetCore.ResponseCaching namespace with the VaryByQueryKeys property. This interface allows for controlling response caching behavior based on query string parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ResponseCaching.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\nMicrosoft.AspNetCore.ResponseCaching.IResponseCachingFeature\nMicrosoft.AspNetCore.ResponseCaching.IResponseCachingFeature.VaryByQueryKeys.get -> string![]?\nMicrosoft.AspNetCore.ResponseCaching.IResponseCachingFeature.VaryByQueryKeys.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining Content Type Constants in C# for ASP.NET Core\nDESCRIPTION: This class defines constants for various content types used in HTTP communication, including JSON, plaintext, form data, and URL-encoded forms.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_NoParam_StringReturn_WithFilter.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RoleStore in C# for ASP.NET Core Identity\nDESCRIPTION: Defines the RoleStore class and its variations for managing roles in ASP.NET Core Identity. It includes methods for CRUD operations on roles and associated claims.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.RoleStore<TRole, TContext, TKey, TUserRole, TRoleClaim>\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.RoleStore<TRole, TContext, TKey, TUserRole, TRoleClaim>.AutoSaveChanges.get -> bool\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.RoleStore<TRole, TContext, TKey, TUserRole, TRoleClaim>.AutoSaveChanges.set -> void\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.RoleStore<TRole, TContext, TKey, TUserRole, TRoleClaim>.Dispose() -> void\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.RoleStore<TRole, TContext, TKey, TUserRole, TRoleClaim>.ErrorDescriber.get -> Microsoft.AspNetCore.Identity.IdentityErrorDescriber!\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.RoleStore<TRole, TContext, TKey, TUserRole, TRoleClaim>.ErrorDescriber.set -> void\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.RoleStore<TRole, TContext, TKey, TUserRole, TRoleClaim>.RoleStore(TContext! context, Microsoft.AspNetCore.Identity.IdentityErrorDescriber? describer = null) -> void\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.RoleStore<TRole, TContext, TKey, TUserRole, TRoleClaim>.ThrowIfDisposed() -> void\n```\n\n----------------------------------------\n\nTITLE: Delegate Casting Helper Method in C#\nDESCRIPTION: This utility method casts a delegate to a specified delegate type. It's used to ensure type safety when working with delegates in the request handling pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling User Sign-In in ASP.NET Core MVC Controllers\nDESCRIPTION: These methods allow signing in a user with a ClaimsPrincipal and optional authentication properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_59\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.SignIn(System.Security.Claims.ClaimsPrincipal! principal) -> Microsoft.AspNetCore.Mvc.SignInResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.SignIn(System.Security.Claims.ClaimsPrincipal! principal, Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties) -> Microsoft.AspNetCore.Mvc.SignInResult!\n```\n\n----------------------------------------\n\nTITLE: HTTP Header Name Constants in C#\nDESCRIPTION: Comprehensive list of static readonly string constants for standard HTTP header names, including general headers, request headers, response headers, and entity headers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Headers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Accept -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.AcceptCharset -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.AcceptEncoding -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.AcceptLanguage -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.AcceptRanges -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.AccessControlAllowCredentials -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.AccessControlAllowHeaders -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.AccessControlAllowMethods -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.AccessControlAllowOrigin -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.AccessControlExposeHeaders -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.AccessControlMaxAge -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.AccessControlRequestHeaders -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.AccessControlRequestMethod -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Age -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Allow -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.AltSvc -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Authority -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Authorization -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Baggage -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.CacheControl -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Connection -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.ContentDisposition -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.ContentEncoding -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.ContentLanguage -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.ContentLength -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.ContentLocation -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.ContentMD5 -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.ContentRange -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.ContentSecurityPolicy -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.ContentSecurityPolicyReportOnly -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.ContentType -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Cookie -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.CorrelationContext -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Date -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.DNT -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.ETag -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Expect -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Expires -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.From -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.GrpcAcceptEncoding -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.GrpcEncoding -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.GrpcMessage -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.GrpcStatus -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.GrpcTimeout -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Host -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.IfMatch -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.IfModifiedSince -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.IfNoneMatch -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.IfRange -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.IfUnmodifiedSince -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.KeepAlive -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.LastModified -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Link -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Location -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.MaxForwards -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Method -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Origin -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Path -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Pragma -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.ProxyAuthenticate -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.ProxyAuthorization -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.ProxyConnection -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Range -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Referer -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.RequestId -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.RetryAfter -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Scheme -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.SecWebSocketAccept -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.SecWebSocketExtensions -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.SecWebSocketKey -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.SecWebSocketProtocol -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.SecWebSocketVersion -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Server -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.SetCookie -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Status -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.StrictTransportSecurity -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.TE -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.TraceParent -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.TraceState -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Trailer -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.TransferEncoding -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Translate -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Upgrade -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.UpgradeInsecureRequests -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.UserAgent -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Vary -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Via -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.Warning -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.WebSocketSubProtocols -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.WWWAuthenticate -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.XContentTypeOptions -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.XFrameOptions -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.XPoweredBy -> string!\n```\n\n----------------------------------------\n\nTITLE: JavaScript Component Configuration Interface and Implementation in ASP.NET Core\nDESCRIPTION: Defines interfaces and classes for JavaScript component integration in Blazor. Includes IJSComponentConfiguration interface and JSComponentInterop class for managing JavaScript-based components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Web.IJSComponentConfiguration\nMicrosoft.AspNetCore.Components.Web.IJSComponentConfiguration.JSComponents.get -> Microsoft.AspNetCore.Components.Web.JSComponentConfigurationStore!\nMicrosoft.AspNetCore.Components.Web.Infrastructure.JSComponentInterop\nMicrosoft.AspNetCore.Components.Web.Infrastructure.JSComponentInterop.JSComponentInterop(Microsoft.AspNetCore.Components.Web.JSComponentConfigurationStore! configuration) -> void\nMicrosoft.AspNetCore.Components.Web.Infrastructure.JSComponentInterop.SetRootComponentParameters(int componentId, int parameterCount, System.Text.Json.JsonElement parametersJson, System.Text.Json.JsonSerializerOptions! jsonOptions) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Accepted HTTP Result in C#\nDESCRIPTION: Defines a generic version of the Accepted class that can include a value of type TValue in the response. It includes properties for Location, StatusCode, and Value, along with an ExecuteAsync method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.Accepted<TValue>\nMicrosoft.AspNetCore.Http.HttpResults.Accepted<TValue>.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.Accepted<TValue>.Location.get -> string?\nMicrosoft.AspNetCore.Http.HttpResults.Accepted<TValue>.StatusCode.get -> int\nMicrosoft.AspNetCore.Http.HttpResults.Accepted<TValue>.Value.get -> TValue?\n```\n\n----------------------------------------\n\nTITLE: Implementing HtmlTestEncoder class in C#\nDESCRIPTION: Implements the HtmlTestEncoder class with methods for encoding HTML content in testing scenarios.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/WebEncoders/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.WebEncoders.Testing.HtmlTestEncoder\nMicrosoft.Extensions.WebEncoders.Testing.HtmlTestEncoder.HtmlTestEncoder() -> void\noverride Microsoft.Extensions.WebEncoders.Testing.HtmlTestEncoder.Encode(string! value) -> string!\noverride Microsoft.Extensions.WebEncoders.Testing.HtmlTestEncoder.Encode(System.IO.TextWriter! output, char[]! value, int startIndex, int characterCount) -> void\noverride Microsoft.Extensions.WebEncoders.Testing.HtmlTestEncoder.Encode(System.IO.TextWriter! output, string! value, int startIndex, int characterCount) -> void\noverride Microsoft.Extensions.WebEncoders.Testing.HtmlTestEncoder.FindFirstCharacterToEncode(char* text, int textLength) -> int\noverride Microsoft.Extensions.WebEncoders.Testing.HtmlTestEncoder.MaxOutputCharactersPerInputCharacter.get -> int\noverride Microsoft.Extensions.WebEncoders.Testing.HtmlTestEncoder.TryEncodeUnicodeScalar(int unicodeScalar, char* buffer, int bufferLength, out int numberOfCharactersWritten) -> bool\noverride Microsoft.Extensions.WebEncoders.Testing.HtmlTestEncoder.WillEncode(int unicodeScalar) -> bool\n```\n\n----------------------------------------\n\nTITLE: Defining RequestDecompressionOptions Class in C#\nDESCRIPTION: This class provides options for request decompression, including a dictionary of decompression providers. It's part of the Microsoft.AspNetCore.RequestDecompression namespace.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/RequestDecompression/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.RequestDecompression.RequestDecompressionOptions.DecompressionProviders.get -> System.Collections.Generic.IDictionary<string!, Microsoft.AspNetCore.RequestDecompression.IDecompressionProvider!>!\nMicrosoft.AspNetCore.RequestDecompression.RequestDecompressionOptions.RequestDecompressionOptions() -> void\n```\n\n----------------------------------------\n\nTITLE: Defining WebAssembly HTTP Enums and Extensions in C#\nDESCRIPTION: Defines enums and extension methods for customizing HTTP requests in WebAssembly applications. This includes options for browser request caching, credentials, and request modes, as well as methods to set these options on HttpRequestMessage objects.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCache\nMicrosoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCache.Default = 0 -> Microsoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCache\nMicrosoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCache.ForceCache = 4 -> Microsoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCache\nMicrosoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCache.NoCache = 3 -> Microsoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCache\nMicrosoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCache.NoStore = 1 -> Microsoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCache\nMicrosoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCache.OnlyIfCached = 5 -> Microsoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCache\nMicrosoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCache.Reload = 2 -> Microsoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCache\nMicrosoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCredentials\nMicrosoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCredentials.Include = 2 -> Microsoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCredentials\nMicrosoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCredentials.Omit = 0 -> Microsoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCredentials\nMicrosoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCredentials.SameOrigin = 1 -> Microsoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestCredentials\nMicrosoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestMode\nMicrosoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestMode.Cors = 2 -> Microsoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestMode\nMicrosoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestMode.Navigate = 3 -> Microsoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestMode\nMicrosoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestMode.NoCors = 1 -> Microsoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestMode\nMicrosoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestMode.SameOrigin = 0 -> Microsoft.AspNetCore.Components.WebAssembly.Http.BrowserRequestMode\nMicrosoft.AspNetCore.Components.WebAssembly.Http.WebAssemblyHttpRequestMessageExtensions\n```\n\n----------------------------------------\n\nTITLE: Handshake Protocol Classes in SignalR\nDESCRIPTION: Classes representing handshake messages used to establish SignalR connections. These messages are exchanged during connection initialization to negotiate protocol and version.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.Protocol.HandshakeProtocol\n\nMicrosoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage\nMicrosoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage.HandshakeRequestMessage(string! protocol, int version) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage.Protocol.get -> string!\nMicrosoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage.Version.get -> int\n\nMicrosoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage\nMicrosoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage.Error.get -> string?\nMicrosoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage.HandshakeResponseMessage(string? error) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining BadRequest Result Methods in C#\nDESCRIPTION: These methods create BadRequest (HTTP 400) results with optional error content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.BadRequest() -> Microsoft.AspNetCore.Http.HttpResults.BadRequest!\nstatic Microsoft.AspNetCore.Http.TypedResults.BadRequest<TValue>(TValue? error) -> Microsoft.AspNetCore.Http.HttpResults.BadRequest<TValue>!\n```\n\n----------------------------------------\n\nTITLE: Implementing CookieHeaderValue Class in C#\nDESCRIPTION: Defines the CookieHeaderValue class for handling Cookie headers, including constructors and name/value properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Headers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Net.Http.Headers.CookieHeaderValue\nMicrosoft.Net.Http.Headers.CookieHeaderValue.CookieHeaderValue(Microsoft.Extensions.Primitives.StringSegment name) -> void\nMicrosoft.Net.Http.Headers.CookieHeaderValue.CookieHeaderValue(Microsoft.Extensions.Primitives.StringSegment name, Microsoft.Extensions.Primitives.StringSegment value) -> void\nMicrosoft.Net.Http.Headers.CookieHeaderValue.Name.get -> Microsoft.Extensions.Primitives.StringSegment\nMicrosoft.Net.Http.Headers.CookieHeaderValue.Name.set -> void\nMicrosoft.Net.Http.Headers.CookieHeaderValue.Value.get -> Microsoft.Extensions.Primitives.StringSegment\nMicrosoft.Net.Http.Headers.CookieHeaderValue.Value.set -> void\n```\n\n----------------------------------------\n\nTITLE: Redis Cache Class Definition\nDESCRIPTION: Core Redis cache implementation class with distributed cache operations including Get, Set, Remove and Refresh methods with both synchronous and asynchronous variants.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PublicAPI/net8.0/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.Dispose() -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.Get(string! key) -> byte[]?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.GetAsync(string! key, System.Threading.CancellationToken token = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<byte[]?>!\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.RedisCache(Microsoft.Extensions.Options.IOptions<Microsoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions!>! optionsAccessor) -> void\n```\n\n----------------------------------------\n\nTITLE: Writing JSON Responses with Type Information in ASP.NET Core\nDESCRIPTION: Writes JSON responses to the HTTP response stream with proper type handling. It uses JsonTypeInfo to determine the appropriate serialization approach based on the runtime type of the value.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleNullableStringParam_WithEmptyQueryStringValueProvided_StringReturn.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Response Writer Implementation in C#\nDESCRIPTION: Handles writing different types of responses (IResult, string, or JSON) to the HTTP response stream. Includes special handling for JSON serialization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: WebSocketConnectionContext in ASP.NET Core (C#)\nDESCRIPTION: Defines WebSocketConnectionContext class for managing WebSocket connections with properties for URI and connection options, plus a constructor.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Http.Connections.Client/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Connections.Client.WebSocketConnectionContext\nMicrosoft.AspNetCore.Http.Connections.Client.WebSocketConnectionContext.Options.get -> Microsoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions!\nMicrosoft.AspNetCore.Http.Connections.Client.WebSocketConnectionContext.Uri.get -> System.Uri!\nMicrosoft.AspNetCore.Http.Connections.Client.WebSocketConnectionContext.WebSocketConnectionContext(System.Uri! uri, Microsoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions! options) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocation Attribute for C#\nDESCRIPTION: Defines a sealed attribute class for method interception that takes version and data parameters. Used for compile-time method interception in generated code.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleNullableStringParam_WithEmptyQueryStringValueProvided_StringReturn.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nfile sealed class InterceptsLocationAttribute : Attribute\n{\n    public InterceptsLocationAttribute(int version, string data)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Logging and Exception Handling Helper in ASP.NET Core\nDESCRIPTION: This class provides methods for logging errors and optionally throwing exceptions based on configuration in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    // ... (other methods omitted for brevity)\n}\n```\n\n----------------------------------------\n\nTITLE: User Management Constants\nDESCRIPTION: Defines constant string values used for various token purposes in ASP.NET Core Identity's UserManager class.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.Identity.UserManager<TUser>.ChangePhoneNumberTokenPurpose = \"ChangePhoneNumber\" -> string!\nconst Microsoft.AspNetCore.Identity.UserManager<TUser>.ConfirmEmailTokenPurpose = \"EmailConfirmation\" -> string!\nconst Microsoft.AspNetCore.Identity.UserManager<TUser>.ResetPasswordTokenPurpose = \"ResetPassword\" -> string!\n```\n\n----------------------------------------\n\nTITLE: Implementing Parameter Binding Metadata in ASP.NET Core\nDESCRIPTION: Represents metadata for parameter binding in request handlers. Contains information about parameter names, binding methods, and optionality used during request processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Password Validation and Hashing Methods\nDESCRIPTION: Methods for password validation and hashing in Identity framework, including character validation and hash verification.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Identity.PasswordHasher<TUser>.HashPassword(TUser! user, string! password) -> string!\n\nvirtual Microsoft.AspNetCore.Identity.PasswordHasher<TUser>.VerifyHashedPassword(TUser! user, string! hashedPassword, string! providedPassword) -> Microsoft.AspNetCore.Identity.PasswordVerificationResult\n\nvirtual Microsoft.AspNetCore.Identity.PasswordValidator<TUser>.IsDigit(char c) -> bool\nvirtual Microsoft.AspNetCore.Identity.PasswordValidator<TUser>.IsLetterOrDigit(char c) -> bool\nvirtual Microsoft.AspNetCore.Identity.PasswordValidator<TUser>.IsLower(char c) -> bool\nvirtual Microsoft.AspNetCore.Identity.PasswordValidator<TUser>.IsUpper(char c) -> bool\n```\n\n----------------------------------------\n\nTITLE: Configuring CORS Policies for ASP.NET Core Endpoints in C#\nDESCRIPTION: This snippet defines extension methods for IEndpointRouteBuilder to configure CORS policies. It includes methods for applying CORS policies to specific endpoints and retrieving CORS metadata from endpoint metadata.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PublicAPI/net8.0/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.AspNetCore.Cors.Infrastructure;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Routing;\nusing Microsoft.Extensions.Primitives;\n\nnamespace Microsoft.AspNetCore.Builder;\n\ninternal static class CorsEndpointConventionBuilderExtensions\n{\n    private const string CorsPolicyMetadataKey = \"Microsoft.AspNetCore.Cors.CorsPolicyMetadata\";\n\n    public static TBuilder RequireCors<TBuilder>(this TBuilder builder, string policyName) where TBuilder : IEndpointConventionBuilder\n    {\n        ArgumentNullException.ThrowIfNull(builder);\n\n        return builder.RequireCors(new CorsPolicy { PolicyName = policyName });\n    }\n\n    public static TBuilder RequireCors<TBuilder>(this TBuilder builder, Action<CorsPolicyBuilder> configurePolicy) where TBuilder : IEndpointConventionBuilder\n    {\n        ArgumentNullException.ThrowIfNull(builder);\n        ArgumentNullException.ThrowIfNull(configurePolicy);\n\n        var policyBuilder = new CorsPolicyBuilder();\n        configurePolicy(policyBuilder);\n        return builder.RequireCors(policyBuilder.Build());\n    }\n\n    public static TBuilder RequireCors<TBuilder>(this TBuilder builder, CorsPolicy policy) where TBuilder : IEndpointConventionBuilder\n    {\n        ArgumentNullException.ThrowIfNull(builder);\n        ArgumentNullException.ThrowIfNull(policy);\n\n        builder.Add(endpointBuilder =>\n        {\n            endpointBuilder.Metadata.Add(new CorsPolicyMetadata(policy));\n        });\n        return builder;\n    }\n\n    internal static CorsPolicy? GetCorsPolicy(this Endpoint endpoint)\n    {\n        return endpoint.Metadata.GetMetadata<CorsPolicyMetadata>()?.Policy;\n    }\n\n    internal static CorsPolicy? GetCorsMetadata(this IReadOnlyList<object?> metadata)\n    {\n        var corsMetadata = metadata.OfType<ICorsPolicyMetadata>().FirstOrDefault();\n        return corsMetadata?.Policy;\n    }\n\n    private sealed class CorsPolicyMetadata : ICorsPolicyMetadata\n    {\n        public CorsPolicyMetadata(CorsPolicy policy)\n        {\n            Policy = policy;\n        }\n\n        public CorsPolicy Policy { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: A compiler directive that enables nullable reference type checking, allowing the compiler to help detect potential null reference exceptions at compile-time. This feature helps enforce null-safety in C# code.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Authentication.Core/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Configuring Antiforgery Services Extension Method\nDESCRIPTION: Extension methods for configuring antiforgery services in the ASP.NET Core dependency injection container. Provides both a parameter-less and an options-based configuration approach.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Antiforgery/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.AntiforgeryServiceCollectionExtensions.AddAntiforgery(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.AntiforgeryServiceCollectionExtensions.AddAntiforgery(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Antiforgery.AntiforgeryOptions!>! setupAction) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Merging Constructor and Property Attributes in C#\nDESCRIPTION: This method combines attributes from a constructor and a property, giving priority to constructor attributes. It's used in custom property information handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\nvar propertyAttributes = _underlyingProperty.GetCustomAttributes(inherit);\n\n// Since the constructors attributes should take priority we will add them first,\n// as we usually call it as First() or FirstOrDefault() in the argument creation\nvar mergedAttributes = new object[constructorAttributes.Length + propertyAttributes.Length];\nArray.Copy(constructorAttributes, mergedAttributes, constructorAttributes.Length);\nArray.Copy(propertyAttributes, 0, mergedAttributes, constructorAttributes.Length, propertyAttributes.Length);\n\nreturn mergedAttributes;\n```\n\n----------------------------------------\n\nTITLE: JSON Patch Input Formatter Implementation\nDESCRIPTION: Implementation of JSON Patch document processing formatter with support for model validation and custom exception handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.NewtonsoftJson/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic override bool CanRead(InputFormatterContext context)\n\npublic override InputFormatterExceptionPolicy ExceptionPolicy\n\npublic override Task<InputFormatterResult> ReadRequestBodyAsync(InputFormatterContext context, System.Text.Encoding encoding)\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Preprocessor directive that enables nullable reference type checking for subsequent code in the file. This ensures better null-safety by requiring explicit null checks and annotations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Microsoft.AspNetCore.OutputCaching.StackExchangeRedis/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Building Endpoint Filter Delegate in ASP.NET Core\nDESCRIPTION: This method constructs an endpoint filter delegate by chaining multiple filter factories. It iterates through the filter factories in reverse order, creating a nested structure of filters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        // ... (method continues)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: RoutePatternFactory Methods for Pattern Creation in ASP.NET Core Routing\nDESCRIPTION: Static methods from RoutePatternFactory that create and manipulate route patterns for ASP.NET Core routing. These methods support creating route patterns from strings, route segments, and configuration parameters like defaults and parameter policies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.ParameterPolicy(string! parameterPolicy) -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterPolicyReference!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Parse(string! pattern) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Parse(string! pattern, Microsoft.AspNetCore.Routing.RouteValueDictionary? defaults, Microsoft.AspNetCore.Routing.RouteValueDictionary? parameterPolicies) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Parse(string! pattern, Microsoft.AspNetCore.Routing.RouteValueDictionary? defaults, Microsoft.AspNetCore.Routing.RouteValueDictionary? parameterPolicies, Microsoft.AspNetCore.Routing.RouteValueDictionary? requiredValues) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Parse(string! pattern, object? defaults, object? parameterPolicies) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Parse(string! pattern, object? defaults, object? parameterPolicies, object? requiredValues) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Pattern(Microsoft.AspNetCore.Routing.RouteValueDictionary? defaults, Microsoft.AspNetCore.Routing.RouteValueDictionary? parameterPolicies, params Microsoft.AspNetCore.Routing.Patterns.RoutePatternPathSegment![]! segments) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Pattern(Microsoft.AspNetCore.Routing.RouteValueDictionary? defaults, Microsoft.AspNetCore.Routing.RouteValueDictionary? parameterPolicies, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Routing.Patterns.RoutePatternPathSegment!>! segments) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Pattern(object? defaults, object? parameterPolicies, params Microsoft.AspNetCore.Routing.Patterns.RoutePatternPathSegment![]! segments) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Pattern(object? defaults, object? parameterPolicies, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Routing.Patterns.RoutePatternPathSegment!>! segments) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Pattern(params Microsoft.AspNetCore.Routing.Patterns.RoutePatternPathSegment![]! segments) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Pattern(string! rawText, params Microsoft.AspNetCore.Routing.Patterns.RoutePatternPathSegment![]! segments) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Pattern(string? rawText, Microsoft.AspNetCore.Routing.RouteValueDictionary? defaults, Microsoft.AspNetCore.Routing.RouteValueDictionary? parameterPolicies, params Microsoft.AspNetCore.Routing.Patterns.RoutePatternPathSegment![]! segments) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Pattern(string? rawText, Microsoft.AspNetCore.Routing.RouteValueDictionary? defaults, Microsoft.AspNetCore.Routing.RouteValueDictionary? parameterPolicies, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Routing.Patterns.RoutePatternPathSegment!>! segments) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Pattern(string? rawText, object? defaults, object? parameterPolicies, params Microsoft.AspNetCore.Routing.Patterns.RoutePatternPathSegment![]! segments) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Pattern(string? rawText, object? defaults, object? parameterPolicies, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Routing.Patterns.RoutePatternPathSegment!>! segments) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Pattern(string? rawText, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Routing.Patterns.RoutePatternPathSegment!>! segments) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Pattern(System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Routing.Patterns.RoutePatternPathSegment!>! segments) -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Segment(params Microsoft.AspNetCore.Routing.Patterns.RoutePatternPart![]! parts) -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternPathSegment!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.Segment(System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Routing.Patterns.RoutePatternPart!>! parts) -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternPathSegment!\nstatic Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory.SeparatorPart(string! content) -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternSeparatorPart!\n```\n\n----------------------------------------\n\nTITLE: Overriding NamedPipeEndPoint and UriEndPoint Methods in C#\nDESCRIPTION: This snippet contains method overrides for the NamedPipeEndPoint class, including Equals, GetHashCode, and ToString methods. It also includes a ToString override for UriEndPoint.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Connections.NamedPipeEndPoint.Equals(object? obj) -> bool\noverride Microsoft.AspNetCore.Connections.NamedPipeEndPoint.GetHashCode() -> int\noverride Microsoft.AspNetCore.Connections.NamedPipeEndPoint.ToString() -> string!\noverride Microsoft.AspNetCore.Connections.UriEndPoint.ToString() -> string!\n```\n\n----------------------------------------\n\nTITLE: Serving Physical Files in ASP.NET Core MVC Controllers\nDESCRIPTION: These methods allow serving physical files from the server with various options for content type, file download name, last modified date, entity tag, and range processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.PhysicalFile(string! physicalPath, string! contentType, bool enableRangeProcessing) -> Microsoft.AspNetCore.Mvc.PhysicalFileResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.PhysicalFile(string! physicalPath, string! contentType, string? fileDownloadName) -> Microsoft.AspNetCore.Mvc.PhysicalFileResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.PhysicalFile(string! physicalPath, string! contentType, string? fileDownloadName, bool enableRangeProcessing) -> Microsoft.AspNetCore.Mvc.PhysicalFileResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.PhysicalFile(string! physicalPath, string! contentType, string? fileDownloadName, System.DateTimeOffset? lastModified, Microsoft.Net.Http.Headers.EntityTagHeaderValue! entityTag) -> Microsoft.AspNetCore.Mvc.PhysicalFileResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.PhysicalFile(string! physicalPath, string! contentType, string? fileDownloadName, System.DateTimeOffset? lastModified, Microsoft.Net.Http.Headers.EntityTagHeaderValue! entityTag, bool enableRangeProcessing) -> Microsoft.AspNetCore.Mvc.PhysicalFileResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.PhysicalFile(string! physicalPath, string! contentType, System.DateTimeOffset? lastModified, Microsoft.Net.Http.Headers.EntityTagHeaderValue! entityTag) -> Microsoft.AspNetCore.Mvc.PhysicalFileResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.PhysicalFile(string! physicalPath, string! contentType, System.DateTimeOffset? lastModified, Microsoft.Net.Http.Headers.EntityTagHeaderValue! entityTag, bool enableRangeProcessing) -> Microsoft.AspNetCore.Mvc.PhysicalFileResult!\n```\n\n----------------------------------------\n\nTITLE: Document Property in OpenAPI Schema Transformer Context\nDESCRIPTION: Property and initializer for accessing the OpenApiDocument in an OpenApiSchemaTransformerContext. The property is nullable and can be initialized.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.OpenApi.OpenApiSchemaTransformerContext.Document.get -> Microsoft.OpenApi.Models.OpenApiDocument?\nMicrosoft.AspNetCore.OpenApi.OpenApiSchemaTransformerContext.Document.init -> void\n```\n\n----------------------------------------\n\nTITLE: MessagePack Binary Encoding Format Example\nDESCRIPTION: Example showing the binary encoding format for MessagePack payloads. Demonstrates how messages are framed with a VarInt length prefix followed by the message body, with a practical example of encoding 'Hello\\nWorld' and a binary payload.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_18\n\nLANGUAGE: text\nCODE:\n```\n0x0B                                                   (start of frame; VarInt value: 11)\n0x68 0x65 0x6C 0x6C 0x6F 0x0A 0x77 0x6F 0x72 0x6C 0x64 (UTF-8 encoding of 'Hello\\nWorld')\n0x02                                                   (start of frame; VarInt value: 2)\n0x01 0x02                                              (body)\n```\n\n----------------------------------------\n\nTITLE: Defining Security and Browser Compatibility HTTP Headers in C#\nDESCRIPTION: Defines three static readonly string constants for HTTP headers: X-Requested-With for AJAX requests, X-UA-Compatible for IE browser compatibility, and X-XSS-Protection for cross-site scripting protection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Headers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.XRequestedWith -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.XUACompatible -> string!\nstatic readonly Microsoft.Net.Http.Headers.HeaderNames.XXSSProtection -> string!\n```\n\n----------------------------------------\n\nTITLE: Decoding StreamItem Message in MessagePack\nDESCRIPTION: Shows the structure and decoding of a StreamItem message in the SignalR MessagePack protocol. It includes message type, headers, invocation ID, and the stream item value.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_7\n\nLANGUAGE: MessagePack\nCODE:\n```\n0x94 0x02 0x80 0xa3 0x78 0x79 0x7a 0x2a\n```\n\n----------------------------------------\n\nTITLE: Configuring HSTS Options in ASP.NET Core\nDESCRIPTION: This snippet defines a class for HTTP Strict Transport Security (HSTS) options in ASP.NET Core. It includes properties for max age, subdomains, and preload, with default values set.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/SqlServer/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Microsoft.AspNetCore.HttpsPolicy;\n\n/// <summary>\n/// Options for the Strict-Transport-Security header.\n/// </summary>\npublic class HstsOptions\n{\n    /// <summary>\n    /// Sets the max-age parameter of the Strict-Transport-Security header.\n    /// </summary>\n    public TimeSpan MaxAge { get; set; } = TimeSpan.FromDays(30);\n\n    /// <summary>\n    /// Enables includeSubDomain parameter of the Strict-Transport-Security header.\n    /// </summary>\n    public bool IncludeSubDomains { get; set; } = false;\n\n    /// <summary>\n    /// Sets the preload parameter of the Strict-Transport-Security header.\n    /// </summary>\n    public bool Preload { get; set; } = false;\n\n    /// <summary>\n    /// A list of host names that will not add the HSTS header.\n    /// </summary>\n    public IList<string> ExcludedHosts { get; } = new List<string>();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generated MapGet0 Extension Method for IEndpointRouteBuilder\nDESCRIPTION: Implements a route handler builder extension method for HTTP GET requests that processes nullable integer array parameters from query strings. The method includes metadata population, request delegate creation, and parameter binding with validation logic.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n    %INTERCEPTSLOCATIONATTRIBUTE%\n    internal static RouteHandlerBuilder MapGet0(\n        this IEndpointRouteBuilder endpoints,\n        [StringSyntax(\"Route\")] string pattern,\n        Delegate handler)\n    {\n        MetadataPopulator populateMetadata = (methodInfo, options) =>\n        {\n            Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n            Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n            options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n            var parameters = methodInfo.GetParameters();\n            options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: true, hasBindAsync: false, isOptional: true));\n            options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(global::System.Int32?[]), contentTypes: GeneratedMetadataConstants.JsonContentType));\n            return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n        };\n        RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n        {\n            Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n            Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n            Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n            Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n            var handler = Cast(del, global::System.Int32?[] (global::System.Int32?[]? arg0= default) => throw null!);\n            EndpointFilterDelegate? filteredInvocation = null;\n            var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n            var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n            var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n            var jsonSerializerOptions = jsonOptions.SerializerOptions;\n            jsonSerializerOptions.MakeReadOnly();\n            var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n            var responseJsonTypeInfo =  (JsonTypeInfo<global::System.Int32?[]?>)jsonSerializerOptions.GetTypeInfo(typeof(global::System.Int32?[]));\n\n            if (options.EndpointBuilder.FilterFactories.Count > 0)\n            {\n                filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n                {\n                    if (ic.HttpContext.Response.StatusCode == 400)\n                    {\n                        return ValueTask.FromResult<object?>(Results.Empty);\n                    }\n                    return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::System.Int32?[]?>(0)!));\n                },\n                options.EndpointBuilder,\n                handler.Method);\n            }\n\n            Task RequestHandler(HttpContext httpContext)\n            {\n                var wasParamCheckFailure = false;\n                // Endpoint Parameter: p (Type = int?[]?, IsOptional = True, IsParsable = True, IsArray = True, Source = Query)\n                var p_raw = httpContext.Request.Query[\"p\"];\n                var p_temp = p_raw.ToArray();\n                global::System.Int32?[]? p_local = new global::System.Int32?[p_temp.Length];\n                for (var i = 0; i < p_temp.Length; i++)\n                {\n                    var element = p_temp[i];\n                    if (!GeneratedRouteBuilderExtensionsCore.TryParseExplicit<int>(element!, CultureInfo.InvariantCulture, out var parsed_element))\n                    {\n                        if (!string.IsNullOrEmpty(element))\n                        {\n                            wasParamCheckFailure = true;\n                            logOrThrowExceptionHelper.RequiredParameterNotProvided(\"int?[]?\", \"p\", \"query string\");\n                        }\n                    }\n                    p_local[i] = string.IsNullOrEmpty(element) ? null! : parsed_element!;\n                }\n\n                if (wasParamCheckFailure)\n                {\n                    httpContext.Response.StatusCode = 400;\n                    return Task.CompletedTask;\n                }\n                var result = handler(p_local);\n                return GeneratedRouteBuilderExtensionsCore.WriteJsonResponseAsync(httpContext.Response, result, responseJsonTypeInfo);\n            }\n\n            async Task RequestHandlerFiltered(HttpContext httpContext)\n            {\n                var wasParamCheckFailure = false;\n                // Endpoint Parameter: p (Type = int?[]?, IsOptional = True, IsParsable = True, IsArray = True, Source = Query)\n                var p_raw = httpContext.Request.Query[\"p\"];\n                var p_temp = p_raw.ToArray();\n                global::System.Int32?[]? p_local = new global::System.Int32?[p_temp.Length];\n                for (var i = 0; i < p_temp.Length; i++)\n                {\n                    var element = p_temp[i];\n                    if (!GeneratedRouteBuilderExtensionsCore.TryParseExplicit<int>(element!, CultureInfo.InvariantCulture, out var parsed_element))\n                    {\n                        if (!string.IsNullOrEmpty(element))\n                        {\n                            wasParamCheckFailure = true;\n                            logOrThrowExceptionHelper.RequiredParameterNotProvided(\"int?[]?\", \"p\", \"query string\");\n                        }\n                    }\n                    p_local[i] = string.IsNullOrEmpty(element) ? null! : parsed_element!;\n                }\n\n                if (wasParamCheckFailure)\n                {\n                    httpContext.Response.StatusCode = 400;\n                }\n                var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::System.Int32?[]?>(httpContext, p_local));\n                if (result is not null)\n                {\n                    await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n                }\n            }\n\n            RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\n            var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\n            return new RequestDelegateResult(targetDelegate, metadata);\n        };\n        var castHandler = Cast(handler, global::System.Int32?[] (global::System.Int32?[]? arg0= default) => throw null!);\n        return MapCore(\n            endpoints,\n            pattern,\n            handler,\n            GetVerb,\n            populateMetadata,\n            createRequestDelegate,\n            castHandler.Method);\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Methods for Dependency Injection in C#\nDESCRIPTION: Defines extension methods for adding connection-related services to the dependency injection container in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/Http.Connections/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.ConnectionsDependencyInjectionExtensions.AddConnections(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.ConnectionsDependencyInjectionExtensions.AddConnections(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Http.Connections.ConnectionOptions!>! options) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Declaring OpenIdConnectPostConfigureOptions Class in C#\nDESCRIPTION: This snippet declares the OpenIdConnectPostConfigureOptions class, which is likely used for post-configuration of OpenID Connect options in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectPostConfigureOptions\n```\n\n----------------------------------------\n\nTITLE: Delegate Type Casting Helper in ASP.NET Core\nDESCRIPTION: Utility method to cast delegates to specific delegate types while maintaining type safety. This is used in the request processing pipeline for proper handler type management.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_NullableReturn.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive to enable nullable reference type checking at the file level. This enforces more strict null-checking in C# code.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining AcceptedAtRoute HTTP Result in C#\nDESCRIPTION: Implements the AcceptedAtRoute class for HTTP 202 Accepted responses with route information. It includes properties for RouteName, RouteValues, and StatusCode, along with an ExecuteAsync method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.AcceptedAtRoute\nMicrosoft.AspNetCore.Http.HttpResults.AcceptedAtRoute.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.AcceptedAtRoute.RouteName.get -> string?\nMicrosoft.AspNetCore.Http.HttpResults.AcceptedAtRoute.RouteValues.get -> Microsoft.AspNetCore.Routing.RouteValueDictionary!\nMicrosoft.AspNetCore.Http.HttpResults.AcceptedAtRoute.StatusCode.get -> int\n```\n\n----------------------------------------\n\nTITLE: Defining KeyPerFileConfigurationSource Class in C#\nDESCRIPTION: Defines the KeyPerFileConfigurationSource class with properties for configuring the source, including file provider, ignore conditions, and reload settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Configuration.KeyPerFile/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource\nMicrosoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource.Build(Microsoft.Extensions.Configuration.IConfigurationBuilder! builder) -> Microsoft.Extensions.Configuration.IConfigurationProvider!\nMicrosoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource.FileProvider.get -> Microsoft.Extensions.FileProviders.IFileProvider?\nMicrosoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource.FileProvider.set -> void\nMicrosoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource.IgnoreCondition.get -> System.Func<string!, bool>!\nMicrosoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource.IgnoreCondition.set -> void\nMicrosoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource.IgnorePrefix.get -> string!\nMicrosoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource.IgnorePrefix.set -> void\nMicrosoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource.KeyPerFileConfigurationSource() -> void\nMicrosoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource.Optional.get -> bool\nMicrosoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource.Optional.set -> void\nMicrosoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource.ReloadDelay.get -> int\nMicrosoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource.ReloadDelay.set -> void\nMicrosoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource.ReloadOnChange.get -> bool\nMicrosoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource.ReloadOnChange.set -> void\nMicrosoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource.SectionDelimiter.get -> string!\nMicrosoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource.SectionDelimiter.set -> void\n```\n\n----------------------------------------\n\nTITLE: Complex Type Model Binding Methods in ASP.NET Core\nDESCRIPTION: Defines methods for binding complex type models in ASP.NET Core MVC, including property binding and model creation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n~Microsoft.AspNetCore.Mvc.ModelBinding.Binders.ComplexTypeModelBinder.BindModelAsync(Microsoft.AspNetCore.Mvc.ModelBinding.ModelBindingContext bindingContext) -> System.Threading.Tasks.Task\n~Microsoft.AspNetCore.Mvc.ModelBinding.Binders.ComplexTypeModelBinder.ComplexTypeModelBinder(System.Collections.Generic.IDictionary<Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata, Microsoft.AspNetCore.Mvc.ModelBinding.IModelBinder> propertyBinders, Microsoft.Extensions.Logging.ILoggerFactory loggerFactory) -> void\n```\n\n----------------------------------------\n\nTITLE: Google Challenge Properties Implementation\nDESCRIPTION: Defines properties and configuration options for Google OAuth challenge requests including access type, approval prompt, and login hints\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Google/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.Google.GoogleChallengeProperties.AccessType.get -> string?\nMicrosoft.AspNetCore.Authentication.Google.GoogleChallengeProperties.AccessType.set -> void\nMicrosoft.AspNetCore.Authentication.Google.GoogleChallengeProperties.ApprovalPrompt.get -> string?\nMicrosoft.AspNetCore.Authentication.Google.GoogleChallengeProperties.ApprovalPrompt.set -> void\nMicrosoft.AspNetCore.Authentication.Google.GoogleChallengeProperties.LoginHint.get -> string?\nMicrosoft.AspNetCore.Authentication.Google.GoogleChallengeProperties.LoginHint.set -> void\n```\n\n----------------------------------------\n\nTITLE: JSON Type Information Polymorphism Check in ASP.NET Core\nDESCRIPTION: Helper method that determines whether a JsonTypeInfo can handle polymorphism based on the type's characteristics. Checks if the type is sealed, a value type, or has explicit polymorphism options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_NullableReturn.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n```\n\n----------------------------------------\n\nTITLE: Configuring CORS Middleware\nDESCRIPTION: Shows how to configure CORS middleware in the ASP.NET Core pipeline using extension methods and policy options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddCors(options => {\n        options.AddDefaultPolicy(builder => {\n            builder.WithOrigins(\"https://example.com\")\n                   .AllowAnyMethod()\n                   .AllowAnyHeader();\n        });\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Nullable Enable Directive in C#\nDESCRIPTION: Sets the nullable context for the file, enabling nullable reference types. This helps catch potential null reference exceptions at compile time rather than runtime.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/Extensions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing BuildFilterDelegate for ASP.NET Core Endpoint Filtering\nDESCRIPTION: Defines a BuildFilterDelegate method that constructs a filter delegate for ASP.NET Core endpoints. It applies filters from the endpoint builder in reverse order.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Migrations Endpoint Middleware in ASP.NET Core (C#)\nDESCRIPTION: Extension methods for adding Migrations Endpoint middleware to the ASP.NET Core request pipeline. This middleware provides an endpoint that can apply pending Entity Framework Core migrations programmatically via a web request.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics.EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.MigrationsEndPointExtensions.UseMigrationsEndPoint(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.MigrationsEndPointExtensions.UseMigrationsEndPoint(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app, Microsoft.AspNetCore.Builder.MigrationsEndPointOptions! options) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive that enables nullable reference type checking at the file level. This helps catch potential null reference exceptions at compile time rather than runtime.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/CookiePolicy/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Content Type in ASP.NET Core\nDESCRIPTION: Handles cases where an unexpected form media type is received. Takes content type as input and either throws a 415 status code exception or logs the error.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndPut_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Event Attributes to RenderTreeBuilder in ASP.NET Core\nDESCRIPTION: These extension methods add event prevention and propagation attributes to the RenderTreeBuilder. They are used to control event behavior in rendered components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.Web.WebRenderTreeBuilderExtensions.AddEventPreventDefaultAttribute(this Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder! builder, int sequence, string! eventName, bool value) -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.Web.WebRenderTreeBuilderExtensions.AddEventStopPropagationAttribute(this Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder! builder, int sequence, string! eventName, bool value) -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring MVC Core Builder Extensions\nDESCRIPTION: Extension methods for IMvcCoreBuilder to configure MVC services including authorization, controllers, formatters and JSON options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.MvcCoreMvcCoreBuilderExtensions.AddAuthorization(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder! builder) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder!\nstatic Microsoft.Extensions.DependencyInjection.MvcCoreMvcCoreBuilderExtensions.AddJsonOptions(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder! builder, System.Action<Microsoft.AspNetCore.Mvc.JsonOptions!>! configure) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining HTML Content Interfaces in C#\nDESCRIPTION: This snippet defines interfaces for HTML content manipulation, including IHtmlAsyncContent, IHtmlContent, IHtmlContentBuilder, and IHtmlContentContainer. These interfaces declare methods for writing, appending, and moving HTML content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Html.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Html.IHtmlAsyncContent\nMicrosoft.AspNetCore.Html.IHtmlAsyncContent.WriteToAsync(System.IO.TextWriter! writer) -> System.Threading.Tasks.ValueTask\nMicrosoft.AspNetCore.Html.IHtmlContent\nMicrosoft.AspNetCore.Html.IHtmlContent.WriteTo(System.IO.TextWriter! writer, System.Text.Encodings.Web.HtmlEncoder! encoder) -> void\nMicrosoft.AspNetCore.Html.IHtmlContentBuilder\nMicrosoft.AspNetCore.Html.IHtmlContentBuilder.Append(string! unencoded) -> Microsoft.AspNetCore.Html.IHtmlContentBuilder!\nMicrosoft.AspNetCore.Html.IHtmlContentBuilder.AppendHtml(Microsoft.AspNetCore.Html.IHtmlContent! content) -> Microsoft.AspNetCore.Html.IHtmlContentBuilder!\nMicrosoft.AspNetCore.Html.IHtmlContentBuilder.AppendHtml(string! encoded) -> Microsoft.AspNetCore.Html.IHtmlContentBuilder!\nMicrosoft.AspNetCore.Html.IHtmlContentBuilder.Clear() -> Microsoft.AspNetCore.Html.IHtmlContentBuilder!\nMicrosoft.AspNetCore.Html.IHtmlContentContainer\nMicrosoft.AspNetCore.Html.IHtmlContentContainer.CopyTo(Microsoft.AspNetCore.Html.IHtmlContentBuilder! builder) -> void\nMicrosoft.AspNetCore.Html.IHtmlContentContainer.MoveTo(Microsoft.AspNetCore.Html.IHtmlContentBuilder! builder) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining Infrastructure Methods for ASP.NET Core MVC\nDESCRIPTION: These methods define various infrastructure components in ASP.NET Core MVC, including compatibility options, content result execution, and file result handling. They provide low-level functionality for executing results and managing responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_66\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.Infrastructure.ConfigureCompatibilityOptions<TOptions>.PostConfigure(string? name, TOptions! options) -> void\nvirtual Microsoft.AspNetCore.Mvc.Infrastructure.ContentResultExecutor.ExecuteAsync(Microsoft.AspNetCore.Mvc.ActionContext! context, Microsoft.AspNetCore.Mvc.ContentResult! result) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Mvc.Infrastructure.FileContentResultExecutor.ExecuteAsync(Microsoft.AspNetCore.Mvc.ActionContext! context, Microsoft.AspNetCore.Mvc.FileContentResult! result) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Mvc.Infrastructure.FileContentResultExecutor.WriteFileAsync(Microsoft.AspNetCore.Mvc.ActionContext! context, Microsoft.AspNetCore.Mvc.FileContentResult! result, Microsoft.Net.Http.Headers.RangeItemHeaderValue? range, long rangeLength) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Mvc.Infrastructure.FileResultExecutorBase.SetHeadersAndLog(Microsoft.AspNetCore.Mvc.ActionContext! context, Microsoft.AspNetCore.Mvc.FileResult! result, long? fileLength, bool enableRangeProcessing, System.DateTimeOffset? lastModified = null, Microsoft.Net.Http.Headers.EntityTagHeaderValue? etag = null) -> (Microsoft.Net.Http.Headers.RangeItemHeaderValue? range, long rangeLength, bool serveBody)\n```\n\n----------------------------------------\n\nTITLE: Partial View HTML Helpers in ASP.NET Core MVC\nDESCRIPTION: Extension methods for rendering partial views within a parent view. These methods allow passing view data and model data to partial views.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperPartialExtensions.Partial(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper htmlHelper, string partialViewName) -> Microsoft.AspNetCore.Html.IHtmlContent\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperPartialExtensions.Partial(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper htmlHelper, string partialViewName, Microsoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary viewData) -> Microsoft.AspNetCore.Html.IHtmlContent\n```\n\n----------------------------------------\n\nTITLE: Decoding Ping Message in MessagePack\nDESCRIPTION: Shows the simple structure and decoding of a Ping message in the SignalR MessagePack protocol. It consists of only the message type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_12\n\nLANGUAGE: MessagePack\nCODE:\n```\n0x91 0x06\n```\n\n----------------------------------------\n\nTITLE: AuthorizationBuilder Class Definition in C#\nDESCRIPTION: Definition of the AuthorizationBuilder class that provides a fluent API for configuring authorization services in the dependency injection container.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationBuilder\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationBuilder.AuthorizationBuilder(Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocationAttribute for Method Interception in C#\nDESCRIPTION: This attribute is used for method interception in C#. It allows the runtime to intercept method calls at specific locations in code, as indicated by version and data parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\nfile sealed class InterceptsLocationAttribute : Attribute\n{\n    public InterceptsLocationAttribute(int version, string data)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive that enables nullable reference type checking, requiring explicit handling of potentially null values. This helps catch null-reference errors at compile time rather than runtime.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net462/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing Filtered Request Handler with Multiple Parameters in ASP.NET Core\nDESCRIPTION: Implements a filtered request handler that handles multiple parameters, including direct HttpContext access. Handles parameter binding, validation, filter invocation, and result execution.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandlerFiltered(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var httpContext_local = httpContext;\n    var myBindAsyncParam_local = await global::Microsoft.AspNetCore.Http.Generators.Tests.MyBothBindAsyncStruct.BindAsync(httpContext, parameters[1]);\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n    }\n    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.HttpContext, global::Microsoft.AspNetCore.Http.Generators.Tests.MyBothBindAsyncStruct>(httpContext, httpContext_local, myBindAsyncParam_local));\n    if (result is not null)\n    {\n        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding API Explorer to ASP.NET Core MVC Core Builder\nDESCRIPTION: Extension method that adds API Explorer functionality to the MVC Core builder. This method registers the necessary services for generating API descriptions in ASP.NET Core MVC applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ApiExplorer/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.MvcApiExplorerMvcCoreBuilderExtensions.AddApiExplorer(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder! builder) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder!\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocationAttribute Class in System.Runtime.CompilerServices Namespace\nDESCRIPTION: Auto-generated definition of the InterceptsLocationAttribute class needed for method interception. This attribute is marked as 'file sealed' and is used to specify interception points in generated code.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsDifferentInterceptorsFromSameLocation.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a custom attribute 'InterceptsLocationAttribute' used for method interception in the System.Runtime.CompilerServices namespace.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsSameInterceptorsFromDifferentFiles.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a custom attribute 'InterceptsLocationAttribute' used for method interception in the System.Runtime.CompilerServices namespace.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsTodo_Has_Metadata.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Endpoint Routing in ASP.NET Core Startup\nDESCRIPTION: This code snippet demonstrates how to set up endpoint routing middleware in the ASP.NET Core Startup.Configure method. It shows the standard pattern of using app.UseRouting() and app.UseEndpoints() with controller routes and Razor Pages configured.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/StaticFiles/test/FunctionalTests/SubFolder/Empty.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env)\n{\n    // Other middleware like app.UseStaticFiles();\n\n    app.UseRouting();\n\n    // Middleware between routing and endpoint execution\n    // like app.UseAuthentication();\n\n    app.UseEndpoints(endpoints =>\n    {\n        endpoints.MapControllerRoute(\n            name: \"default\",\n            pattern: \"{controller=Home}/{action=Index}/{id?}\");\n        endpoints.MapRazorPages();\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Certificate Authentication Constants\nDESCRIPTION: Default authentication scheme constant for certificate authentication\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Certificate/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.Authentication.Certificate.CertificateAuthenticationDefaults.AuthenticationScheme = \"Certificate\"\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Schema for Image Object in Pet Store API\nDESCRIPTION: This snippet defines the JSON schema for an Image object. It specifies required fields, property types, and formats for the id and url properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Tools/Microsoft.dotnet-openapi/test/TestContent/openapi.json.txt#2025-04-08_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"type\": \"object\",\n  \"additionalProperties\": false,\n  \"required\": [\n    \"id\"\n  ],\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\",\n      \"format\": \"int32\"\n    },\n    \"url\": {\n      \"type\": \"string\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Redis SignalR Extension Methods\nDESCRIPTION: Extension methods for configuring Redis backplane in SignalR server applications with various overloads for connection configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/StackExchangeRedis/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static class StackExchangeRedisDependencyInjectionExtensions\n{\n    public static ISignalRServerBuilder AddStackExchangeRedis(this ISignalRServerBuilder signalrBuilder);\n    public static ISignalRServerBuilder AddStackExchangeRedis(this ISignalRServerBuilder signalrBuilder, string redisConnectionString);\n    public static ISignalRServerBuilder AddStackExchangeRedis(this ISignalRServerBuilder signalrBuilder, Action<RedisOptions> configure);\n    public static ISignalRServerBuilder AddStackExchangeRedis(this ISignalRServerBuilder signalrBuilder, string redisConnectionString, Action<RedisOptions> configure);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HtmlFormattableString Class in C#\nDESCRIPTION: This snippet defines the HtmlFormattableString class, which provides methods for creating and writing formatted HTML strings. It includes constructors and a method for writing to a TextWriter.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Html.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Html.HtmlFormattableString\nMicrosoft.AspNetCore.Html.HtmlFormattableString.HtmlFormattableString(string! format, params object?[]! args) -> void\nMicrosoft.AspNetCore.Html.HtmlFormattableString.HtmlFormattableString(System.IFormatProvider? formatProvider, string! format, params object?[]! args) -> void\nMicrosoft.AspNetCore.Html.HtmlFormattableString.WriteTo(System.IO.TextWriter! writer, System.Text.Encodings.Web.HtmlEncoder! encoder) -> void\n```\n\n----------------------------------------\n\nTITLE: Registering Hub Method Handlers with SignalR Client in C#\nDESCRIPTION: These methods allow registering handlers for hub methods with various numbers of parameters. They support both synchronous and asynchronous handlers, as well as handlers with generic return types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Action! handler) -> System.IDisposable!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, System.Threading.Tasks.Task<TResult>!>! handler) -> System.IDisposable!\n```\n\n----------------------------------------\n\nTITLE: Implementing RootComponentMapping Class in C#\nDESCRIPTION: Defines the RootComponentMapping class with properties and constructors for component type, selector, and parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.RootComponentMapping\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.RootComponentMapping.ComponentType.get -> System.Type!\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.RootComponentMapping.Parameters.get -> Microsoft.AspNetCore.Components.ParameterView\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.RootComponentMapping.RootComponentMapping() -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.RootComponentMapping.RootComponentMapping(System.Type! componentType, string! selector) -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.RootComponentMapping.RootComponentMapping(System.Type! componentType, string! selector, Microsoft.AspNetCore.Components.ParameterView parameters) -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.RootComponentMapping.Selector.get -> string!\n```\n\n----------------------------------------\n\nTITLE: Implementing RemoteAuthenticationActions in C#\nDESCRIPTION: Implements the IsAction method in the RemoteAuthenticationActions class for checking authentication actions in ASP.NET Core WebAssembly applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationActions.IsAction(string! action, string! candidate) -> bool\n```\n\n----------------------------------------\n\nTITLE: Overriding InputFile Component Methods in C#\nDESCRIPTION: Overrides the BuildRenderTree and OnAfterRenderAsync methods for the InputFile component in ASP.NET Core Forms.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Components.Forms.InputFile.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder! builder) -> void\noverride Microsoft.AspNetCore.Components.Forms.InputFile.OnAfterRenderAsync(bool firstRender) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Using Concurrency Limiter Middleware in ASP.NET Core\nDESCRIPTION: Extension method to add the ConcurrencyLimiter middleware to the ASP.NET Core request pipeline. This allows applications to limit concurrent request processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ConcurrencyLimiter/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.ConcurrencyLimiterExtensions.UseConcurrencyLimiter(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: File Content Response Methods in ASP.NET Core ControllerBase (C#)\nDESCRIPTION: Methods to return file content from byte arrays. These methods support specifying content type, download name, caching parameters, and range processing options for file downloads.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_49\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(byte[]! fileContents, string! contentType) -> Microsoft.AspNetCore.Mvc.FileContentResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(byte[]! fileContents, string! contentType, bool enableRangeProcessing) -> Microsoft.AspNetCore.Mvc.FileContentResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(byte[]! fileContents, string! contentType, string? fileDownloadName) -> Microsoft.AspNetCore.Mvc.FileContentResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(byte[]! fileContents, string! contentType, string? fileDownloadName, bool enableRangeProcessing) -> Microsoft.AspNetCore.Mvc.FileContentResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(byte[]! fileContents, string! contentType, string? fileDownloadName, System.DateTimeOffset? lastModified, Microsoft.Net.Http.Headers.EntityTagHeaderValue! entityTag) -> Microsoft.AspNetCore.Mvc.FileContentResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(byte[]! fileContents, string! contentType, string? fileDownloadName, System.DateTimeOffset? lastModified, Microsoft.Net.Http.Headers.EntityTagHeaderValue! entityTag, bool enableRangeProcessing) -> Microsoft.AspNetCore.Mvc.FileContentResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(byte[]! fileContents, string! contentType, System.DateTimeOffset? lastModified, Microsoft.Net.Http.Headers.EntityTagHeaderValue! entityTag) -> Microsoft.AspNetCore.Mvc.FileContentResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.File(byte[]! fileContents, string! contentType, System.DateTimeOffset? lastModified, Microsoft.Net.Http.Headers.EntityTagHeaderValue! entityTag, bool enableRangeProcessing) -> Microsoft.AspNetCore.Mvc.FileContentResult!\n```\n\n----------------------------------------\n\nTITLE: DefaultModelBindingContext Overrides in C#\nDESCRIPTION: Override definitions for the DefaultModelBindingContext class, including property getters and setters for model binding functionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_31\n\nLANGUAGE: csharp\nCODE:\n```\noverride Microsoft.AspNetCore.Mvc.ModelBinding.DefaultModelBindingContext.PropertyFilter.set -> void\noverride Microsoft.AspNetCore.Mvc.ModelBinding.DefaultModelBindingContext.Result.get -> Microsoft.AspNetCore.Mvc.ModelBinding.ModelBindingResult\noverride Microsoft.AspNetCore.Mvc.ModelBinding.DefaultModelBindingContext.Result.set -> void\noverride Microsoft.AspNetCore.Mvc.ModelBinding.DefaultModelBindingContext.ValidationState.get -> Microsoft.AspNetCore.Mvc.ModelBinding.Validation.ValidationStateDictionary!\noverride Microsoft.AspNetCore.Mvc.ModelBinding.DefaultModelBindingContext.ValidationState.set -> void\noverride Microsoft.AspNetCore.Mvc.ModelBinding.DefaultModelBindingContext.ValueProvider.get -> Microsoft.AspNetCore.Mvc.ModelBinding.IValueProvider!\noverride Microsoft.AspNetCore.Mvc.ModelBinding.DefaultModelBindingContext.ValueProvider.set -> void\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive that enables nullable reference type checking at the file or project level. This ensures better null-safety by making null-state analysis more strict.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/netstandard2.0/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Configuring Circuit Options for Server-Side Blazor in ASP.NET Core\nDESCRIPTION: Extension method for IServerSideBlazorBuilder that configures CircuitOptions through an action delegate. Allows customization of Blazor server circuit behavior.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.ServerSideBlazorBuilderExtensions.AddCircuitOptions(this Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder! builder, System.Action<Microsoft.AspNetCore.Components.Server.CircuitOptions!>! configure) -> Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder!\n```\n\n----------------------------------------\n\nTITLE: LinkGenerator Route Values Extensions for Path and URI Generation in ASP.NET Core\nDESCRIPTION: Extension methods for Microsoft.AspNetCore.Routing.LinkGenerator that generate paths and URIs using route values. These methods support various parameter combinations and contexts for link generation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.LinkGeneratorRouteValuesAddressExtensions.GetPathByRouteValues(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, Microsoft.AspNetCore.Http.HttpContext! httpContext, string? routeName, Microsoft.AspNetCore.Routing.RouteValueDictionary? values = null, Microsoft.AspNetCore.Http.PathString? pathBase = null, Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.LinkGeneratorRouteValuesAddressExtensions.GetPathByRouteValues(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, Microsoft.AspNetCore.Http.HttpContext! httpContext, string? routeName, object? values, Microsoft.AspNetCore.Http.PathString? pathBase = null, Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.LinkGeneratorRouteValuesAddressExtensions.GetPathByRouteValues(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, string? routeName, Microsoft.AspNetCore.Routing.RouteValueDictionary? values = null, Microsoft.AspNetCore.Http.PathString pathBase = default(Microsoft.AspNetCore.Http.PathString), Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.LinkGeneratorRouteValuesAddressExtensions.GetPathByRouteValues(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, string? routeName, object? values, Microsoft.AspNetCore.Http.PathString pathBase = default(Microsoft.AspNetCore.Http.PathString), Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.LinkGeneratorRouteValuesAddressExtensions.GetUriByRouteValues(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, Microsoft.AspNetCore.Http.HttpContext! httpContext, string? routeName, Microsoft.AspNetCore.Routing.RouteValueDictionary? values = null, string? scheme = null, Microsoft.AspNetCore.Http.HostString? host = null, Microsoft.AspNetCore.Http.PathString? pathBase = null, Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.LinkGeneratorRouteValuesAddressExtensions.GetUriByRouteValues(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, Microsoft.AspNetCore.Http.HttpContext! httpContext, string? routeName, object? values, string? scheme = null, Microsoft.AspNetCore.Http.HostString? host = null, Microsoft.AspNetCore.Http.PathString? pathBase = null, Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.LinkGeneratorRouteValuesAddressExtensions.GetUriByRouteValues(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, string? routeName, Microsoft.AspNetCore.Routing.RouteValueDictionary! values, string! scheme, Microsoft.AspNetCore.Http.HostString host, Microsoft.AspNetCore.Http.PathString pathBase = default(Microsoft.AspNetCore.Http.PathString), Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.LinkGeneratorRouteValuesAddressExtensions.GetUriByRouteValues(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, string? routeName, object? values, string! scheme, Microsoft.AspNetCore.Http.HostString host, Microsoft.AspNetCore.Http.PathString pathBase = default(Microsoft.AspNetCore.Http.PathString), Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\n```\n\n----------------------------------------\n\nTITLE: Reading Form Data Asynchronously in ASP.NET Core\nDESCRIPTION: This extension method allows reading form data from an HTTP request asynchronously, with options for form configuration and cancellation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.RequestFormReaderExtensions.ReadFormAsync(this Microsoft.AspNetCore.Http.HttpRequest! request, Microsoft.AspNetCore.Http.Features.FormOptions! options, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Http.IFormCollection!>!\n```\n\n----------------------------------------\n\nTITLE: Incrementing Patch Version in Versions.props for ASP.NET Core\nDESCRIPTION: This XML diff shows how to increment the AspNetCorePatchVersion in the eng/Versions.props file. It's a crucial step in preparing for a new servicing update, ensuring the correct version is reflected in the build process.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/PreparingPatchUpdates.md#2025-04-08_snippet_0\n\nLANGUAGE: XML\nCODE:\n```\n-  <AspNetCorePatchVersion>7</AspNetCorePatchVersion>\n+  <AspNetCorePatchVersion>8</AspNetCorePatchVersion>\n```\n\n----------------------------------------\n\nTITLE: Declaring FileBufferingReadStream Class in C#\nDESCRIPTION: Defines a FileBufferingReadStream class for buffering file content in memory or on disk, with various constructors and properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/WebUtilities/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.WebUtilities.FileBufferingReadStream\nMicrosoft.AspNetCore.WebUtilities.FileBufferingReadStream.FileBufferingReadStream(System.IO.Stream! inner, int memoryThreshold) -> void\nMicrosoft.AspNetCore.WebUtilities.FileBufferingReadStream.FileBufferingReadStream(System.IO.Stream! inner, int memoryThreshold, long? bufferLimit, string! tempFileDirectory) -> void\nMicrosoft.AspNetCore.WebUtilities.FileBufferingReadStream.FileBufferingReadStream(System.IO.Stream! inner, int memoryThreshold, long? bufferLimit, string! tempFileDirectory, System.Buffers.ArrayPool<byte>! bytePool) -> void\nMicrosoft.AspNetCore.WebUtilities.FileBufferingReadStream.FileBufferingReadStream(System.IO.Stream! inner, int memoryThreshold, long? bufferLimit, System.Func<string!>! tempFileDirectoryAccessor) -> void\nMicrosoft.AspNetCore.WebUtilities.FileBufferingReadStream.FileBufferingReadStream(System.IO.Stream! inner, int memoryThreshold, long? bufferLimit, System.Func<string!>! tempFileDirectoryAccessor, System.Buffers.ArrayPool<byte>! bytePool) -> void\nMicrosoft.AspNetCore.WebUtilities.FileBufferingReadStream.InMemory.get -> bool\nMicrosoft.AspNetCore.WebUtilities.FileBufferingReadStream.MemoryThreshold.get -> int\nMicrosoft.AspNetCore.WebUtilities.FileBufferingReadStream.TempFileName.get -> string?\n```\n\n----------------------------------------\n\nTITLE: Implementing MapCore Method for RouteBuilder in C#\nDESCRIPTION: Implements a MapCore method that serves as a core mapping function for route handlers in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsTodo_Has_Metadata.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Static Files Authentication in ASP.NET Core\nDESCRIPTION: Two approaches for securing static files: MapAuthenticatedFiles restricts access to only authenticated users, while MapImperativeFile uses authorization policies to control access based on user identity. Users can log in with any username but will only have access to directories matching their name.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/samples/StaticFilesAuth/README.md#2025-04-08_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nAuthSamples.StaticFilesAuth\n=================\n\nSample demonstrating restricting access to static files using Authentication and Authorization. There are two different approaches.\nLinks to each scenario are provided on the home page.\n\n1. For a given url path, allow only authenticated users to access static files. See /MapAuthenticatedFiles in Startup.cs.\n1. For a given url path, use an authorization policy to determine who should have access to specific files. See /MapImperativeFile in startup.cs.\n\nYou can log in with any user name. For the policy scenario the user will only have access to the directory matching their name.\n```\n\n----------------------------------------\n\nTITLE: Configuring Endpoint Routing in ASP.NET Core\nDESCRIPTION: This code snippet shows how to configure endpoint routing in an ASP.NET Core application. It uses the UseRouting and UseEndpoints middleware to set up the routing infrastructure and map controllers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Certificate/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\napp.UseRouting();\n\napp.UseEndpoints(endpoints =>\n{\n    endpoints.MapControllers();\n});\n```\n\n----------------------------------------\n\nTITLE: Defining RedisCache Class in C#\nDESCRIPTION: Defines the RedisCache class implementing distributed caching with Redis. It includes methods for getting, setting, and removing cache entries, both synchronously and asynchronously.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.Dispose() -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.Get(string! key) -> byte[]?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.GetAsync(string! key, System.Threading.CancellationToken token = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<byte[]?>!\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.RedisCache(Microsoft.Extensions.Options.IOptions<Microsoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions!>! optionsAccessor) -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.Refresh(string! key) -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.RefreshAsync(string! key, System.Threading.CancellationToken token = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.Remove(string! key) -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.RemoveAsync(string! key, System.Threading.CancellationToken token = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.Set(string! key, byte[]! value, Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions! options) -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.SetAsync(string! key, byte[]! value, Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions! options, System.Threading.CancellationToken token = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: HttpConnectionFactory Implementation in ASP.NET Core (C#)\nDESCRIPTION: Defines the HttpConnectionFactory class which is responsible for creating HTTP connections. It includes the constructor and a ConnectAsync method to establish connections to a specified endpoint.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Http.Connections.Client/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionFactory\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionFactory.ConnectAsync(System.Net.EndPoint! endPoint, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Connections.ConnectionContext!>\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnectionFactory.HttpConnectionFactory(Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions!>! options, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> void\n```\n\n----------------------------------------\n\nTITLE: Stream and Raw Result Handling\nDESCRIPTION: Classes for handling streaming operations and raw data results in SignalR. These include stream invocation, stream items, binding failures, and raw binary data handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.Protocol.RawResult\nMicrosoft.AspNetCore.SignalR.Protocol.RawResult.RawResult(System.Buffers.ReadOnlySequence<byte> rawBytes) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.RawResult.RawSerializedData.get -> System.Buffers.ReadOnlySequence<byte>\n\nMicrosoft.AspNetCore.SignalR.Protocol.StreamBindingFailureMessage\nMicrosoft.AspNetCore.SignalR.Protocol.StreamBindingFailureMessage.BindingFailure.get -> System.Runtime.ExceptionServices.ExceptionDispatchInfo!\nMicrosoft.AspNetCore.SignalR.Protocol.StreamBindingFailureMessage.Id.get -> string!\nMicrosoft.AspNetCore.SignalR.Protocol.StreamBindingFailureMessage.StreamBindingFailureMessage(string! id, System.Runtime.ExceptionServices.ExceptionDispatchInfo! bindingFailure) -> void\n\nMicrosoft.AspNetCore.SignalR.Protocol.StreamInvocationMessage\nMicrosoft.AspNetCore.SignalR.Protocol.StreamInvocationMessage.StreamInvocationMessage(string! invocationId, string! target, object?[]! arguments) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.StreamInvocationMessage.StreamInvocationMessage(string! invocationId, string! target, object?[]! arguments, string![]? streamIds) -> void\noverride Microsoft.AspNetCore.SignalR.Protocol.StreamInvocationMessage.ToString() -> string!\n\nMicrosoft.AspNetCore.SignalR.Protocol.StreamItemMessage\nMicrosoft.AspNetCore.SignalR.Protocol.StreamItemMessage.Item.get -> object?\nMicrosoft.AspNetCore.SignalR.Protocol.StreamItemMessage.Item.set -> void\nMicrosoft.AspNetCore.SignalR.Protocol.StreamItemMessage.StreamItemMessage(string! invocationId, object? item) -> void\noverride Microsoft.AspNetCore.SignalR.Protocol.StreamItemMessage.ToString() -> string!\n```\n\n----------------------------------------\n\nTITLE: Implementing Core Route Mapping in ASP.NET Core\nDESCRIPTION: Provides core route mapping functionality for endpoint builders, including support for HTTP methods and metadata handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/HandlesEndpointsWithAndWithoutDiagnostics.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding WebRenderer Dispose Method in C#\nDESCRIPTION: Overrides the Dispose method for the WebRenderer class in ASP.NET Core Components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Components.RenderTree.WebRenderer.Dispose(bool disposing) -> void\n```\n\n----------------------------------------\n\nTITLE: JS Interop for Root Components in ASP.NET Core\nDESCRIPTION: These methods handle the addition and removal of root components in JavaScript interop scenarios. They are part of the JSComponentInterop class.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.Web.Infrastructure.JSComponentInterop.AddRootComponent(string! identifier, string! domElementSelector) -> int\n```\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.Web.Infrastructure.JSComponentInterop.RemoveRootComponent(int componentId) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing HTML Helper Utility Methods in C#\nDESCRIPTION: These static methods provide utility functions for HTML helpers in ASP.NET Core MVC. They include methods for converting objects to dictionaries, handling HTML attributes, and working with form methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Mvc.ViewFeatures.HtmlHelper.AnonymousObjectToHtmlAttributes(object htmlAttributes) -> System.Collections.Generic.IDictionary<string, object>\nstatic Microsoft.AspNetCore.Mvc.ViewFeatures.HtmlHelper.GetFormMethodString(Microsoft.AspNetCore.Mvc.Rendering.FormMethod method) -> string\nstatic Microsoft.AspNetCore.Mvc.ViewFeatures.HtmlHelper.ObjectToDictionary(object value) -> System.Collections.Generic.IDictionary<string, object>\n```\n\n----------------------------------------\n\nTITLE: Initializing TagBuilder Class Constructors\nDESCRIPTION: Defines constructor methods for TagBuilder class that creates HTML elements programmatically. Includes copy constructor and name-based constructor.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Rendering.TagBuilder.TagBuilder(Microsoft.AspNetCore.Mvc.Rendering.TagBuilder! tagBuilder) -> void\nMicrosoft.AspNetCore.Mvc.Rendering.TagBuilder.TagBuilder(string! tagName) -> void\n```\n\n----------------------------------------\n\nTITLE: Controller Activation Interfaces\nDESCRIPTION: Interfaces defining controller activation and lifecycle management functionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Controllers.IControllerActivator\nMicrosoft.AspNetCore.Mvc.Controllers.IControllerActivator.Create(Microsoft.AspNetCore.Mvc.ControllerContext! context) -> object!\nMicrosoft.AspNetCore.Mvc.Controllers.IControllerActivator.Release(Microsoft.AspNetCore.Mvc.ControllerContext! context, object! controller) -> void\nMicrosoft.AspNetCore.Mvc.Controllers.IControllerActivator.ReleaseAsync(Microsoft.AspNetCore.Mvc.ControllerContext! context, object! controller) -> System.Threading.Tasks.ValueTask\n```\n\n----------------------------------------\n\nTITLE: Model Binding Message Provider Overrides in C#\nDESCRIPTION: Override definitions for model binding message providers that handle various validation and error messages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_33\n\nLANGUAGE: csharp\nCODE:\n```\noverride Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.DefaultModelBindingMessageProvider.AttemptedValueIsInvalidAccessor.get -> System.Func<string!, string!, string!>!\noverride Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.DefaultModelBindingMessageProvider.MissingBindRequiredValueAccessor.get -> System.Func<string!, string!>!\noverride Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.DefaultModelBindingMessageProvider.MissingKeyOrValueAccessor.get -> System.Func<string!>!\noverride Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.DefaultModelBindingMessageProvider.MissingRequestBodyRequiredValueAccessor.get -> System.Func<string!>!\n```\n\n----------------------------------------\n\nTITLE: Implementing Filtered HTTP Request Handler with Request and Response Parameters in ASP.NET Core\nDESCRIPTION: This async handler processes HTTP requests through filter pipelines with both request and response parameters. It creates a filter invocation context, executes the filter chain, and properly handles the result including null cases.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandlerFiltered(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var req_local = httpContext.Request;\n    var res_local = httpContext.Response;\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n    }\n    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.HttpRequest, global::Microsoft.AspNetCore.Http.HttpResponse>(httpContext, req_local, res_local));\n    if (result is not null)\n    {\n        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: CookieAuthenticationHandler FinishResponseAsync Method in C#\nDESCRIPTION: Virtual method definition for the FinishResponseAsync method in the CookieAuthenticationHandler class, which executes at the end of the authentication response process to finalize cookie creation and handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Cookies/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationHandler.FinishResponseAsync() -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Configuring File Result Buffer Size\nDESCRIPTION: Configuration constant defining the default buffer size for file result execution in ASP.NET Core MVC.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nconst Microsoft.AspNetCore.Mvc.Infrastructure.FileResultExecutorBase.BufferSize = 65536 -> int\n```\n\n----------------------------------------\n\nTITLE: Finalizing MapGet Endpoint Registration in ASP.NET Core\nDESCRIPTION: Completes the endpoint registration by casting the handler to the appropriate delegate type and calling the MapCore method with all necessary parameters. Handles routing pattern, HTTP verb, and metadata population.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nvar castHandler = Cast(handler, global::System.String (global::Microsoft.AspNetCore.Http.HttpContext arg0, global::Microsoft.AspNetCore.Http.Generators.Tests.MyBothBindAsyncStruct arg1) => throw null!);\nreturn MapCore(\n    endpoints,\n    pattern,\n    handler,\n    GetVerb,\n    populateMetadata,\n    createRequestDelegate,\n    castHandler.Method);\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Content Type Logger in ASP.NET Core\nDESCRIPTION: Defines a structured logger for unexpected JSON content type scenarios using LoggerMessage.Define. Creates a logging delegate that captures the unexpected content type received when JSON was expected.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Defining RenderModeEndpointProvider Abstract Class in C#\nDESCRIPTION: This abstract class defines methods for creating endpoint builders and checking support for render modes in ASP.NET Core Razor Components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Endpoints/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Components.Endpoints.Infrastructure.RenderModeEndpointProvider.GetEndpointBuilders(Microsoft.AspNetCore.Components.IComponentRenderMode! renderMode, Microsoft.AspNetCore.Builder.IApplicationBuilder! applicationBuilder) -> System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Routing.RouteEndpointBuilder!>!\nabstract Microsoft.AspNetCore.Components.Endpoints.Infrastructure.RenderModeEndpointProvider.Supports(Microsoft.AspNetCore.Components.IComponentRenderMode! renderMode) -> bool\n```\n\n----------------------------------------\n\nTITLE: Defining CustomTestContext Interface in C# for ASP.NET Core Testing\nDESCRIPTION: This code defines the CustomTestContext interface which extends IDisposable. It has a single property Factory that returns an IServiceProvider, enabling services to be accessed during testing. The interface is used as an abstraction for test environment implementations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Grpc/JsonTranscoding/src/Microsoft.AspNetCore.Grpc.JsonTranscoding/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Initializing PolicyHttpMessageHandler Constructor\nDESCRIPTION: Constructor overloads for PolicyHttpMessageHandler that accepts either a direct policy or a policy selector function for handling HTTP requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HttpClientFactory/Polly/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Http.PolicyHttpMessageHandler.PolicyHttpMessageHandler(Polly.IAsyncPolicy<System.Net.Http.HttpResponseMessage!>! policy) -> void\nMicrosoft.Extensions.Http.PolicyHttpMessageHandler.PolicyHttpMessageHandler(System.Func<System.Net.Http.HttpRequestMessage!, Polly.IAsyncPolicy<System.Net.Http.HttpResponseMessage!>!>! policySelector) -> void\n```\n\n----------------------------------------\n\nTITLE: User Authentication Token Store Interface\nDESCRIPTION: Interface for managing user authentication tokens including getting, setting, and removing tokens.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.IUserAuthenticationTokenStore<TUser>.GetTokenAsync(TUser! user, string! loginProvider, string! name, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<string?>!\nMicrosoft.AspNetCore.Identity.IUserAuthenticationTokenStore<TUser>.SetTokenAsync(TUser! user, string! loginProvider, string! name, string? value, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Identity.IUserAuthenticationTokenStore<TUser>.RemoveTokenAsync(TUser! user, string! loginProvider, string! name, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Action for Unexpected Non-Form Content Type in ASP.NET Core\nDESCRIPTION: This code defines a static readonly Action for logging unexpected non-form content types. It uses LoggerMessage.Define to create a structured log message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Razor Pages Core Response Methods\nDESCRIPTION: Core methods for generating HTTP responses in Razor Pages including Page(), BadRequest(), NotFound(), and basic Content responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.Page() -> Microsoft.AspNetCore.Mvc.RazorPages.PageResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.BadRequest() -> Microsoft.AspNetCore.Mvc.BadRequestResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.NotFound() -> Microsoft.AspNetCore.Mvc.NotFoundResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.Content(string! content) -> Microsoft.AspNetCore.Mvc.ContentResult!\n```\n\n----------------------------------------\n\nTITLE: Defining W3CLoggingFields Enumeration in ASP.NET Core\nDESCRIPTION: Definition of W3CLoggingFields enumeration with bit flags that control which fields are included in W3C format logs. The enumeration includes values for various HTTP request and response components with their corresponding numeric values.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpLogging/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.All = Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.Date | Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.Time | Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.UserName | Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.ServerName | Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.ConnectionInfoFields | Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.ProtocolStatus | Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.TimeTaken | Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.Cookie | Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.Request -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\n```\n\n----------------------------------------\n\nTITLE: DataAnnotationsValidator Class API for ASP.NET Core Blazor Forms\nDESCRIPTION: The DataAnnotationsValidator component enables validation using DataAnnotations attributes in Blazor forms. It connects to the EditContext to provide validation capabilities based on the data annotations defined in the model.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Forms/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Forms.DataAnnotationsValidator\nMicrosoft.AspNetCore.Components.Forms.DataAnnotationsValidator.DataAnnotationsValidator() -> void\noverride Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator.OnInitialized() -> void\noverride Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator.OnParametersSet() -> void\nvirtual Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator.Dispose(bool disposing) -> void\n```\n\n----------------------------------------\n\nTITLE: Adding New API Entry in PublicAPI.Unshipped.txt\nDESCRIPTION: Example of adding a new API entry to the PublicAPI.Unshipped.txt file. This demonstrates the format for declaring a new public API with nullable enable context.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/APIBaselines.md#2025-04-08_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n#nullable enable\nMicrosoft.AspNetCore.Builder.NewApplicationBuilder.New() -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Using Kestrel Server in ASP.NET Core\nDESCRIPTION: These methods enable the use of Kestrel server in an ASP.NET Core application. They can be called without parameters or with configuration options. The methods return IWebHostBuilder for method chaining.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Kestrel/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Hosting.WebHostBuilderKestrelExtensions.UseKestrel(this Microsoft.AspNetCore.Hosting.IWebHostBuilder! hostBuilder) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Hosting.WebHostBuilderKestrelExtensions.UseKestrel(this Microsoft.AspNetCore.Hosting.IWebHostBuilder! hostBuilder, System.Action<Microsoft.AspNetCore.Hosting.WebHostBuilderContext!, Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions!>! configureOptions) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Hosting.WebHostBuilderKestrelExtensions.UseKestrel(this Microsoft.AspNetCore.Hosting.IWebHostBuilder! hostBuilder, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions!>! options) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining SignalR Protocol Message Classes\nDESCRIPTION: Classes representing various types of messages exchanged in the SignalR protocol, including acknowledgments, cancellation, completion, invocation, and streaming. Each message type has specific properties related to its purpose.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.Protocol.AckMessage\nMicrosoft.AspNetCore.SignalR.Protocol.AckMessage.AckMessage(long sequenceId) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.AckMessage.SequenceId.get -> long\nMicrosoft.AspNetCore.SignalR.Protocol.AckMessage.SequenceId.set -> void\n\nMicrosoft.AspNetCore.SignalR.Protocol.CancelInvocationMessage\nMicrosoft.AspNetCore.SignalR.Protocol.CancelInvocationMessage.CancelInvocationMessage(string! invocationId) -> void\n\nMicrosoft.AspNetCore.SignalR.Protocol.CloseMessage\nMicrosoft.AspNetCore.SignalR.Protocol.CloseMessage.AllowReconnect.get -> bool\nMicrosoft.AspNetCore.SignalR.Protocol.CloseMessage.CloseMessage(string? error) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.CloseMessage.CloseMessage(string? error, bool allowReconnect) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.CloseMessage.Error.get -> string?\n\nMicrosoft.AspNetCore.SignalR.Protocol.CompletionMessage\nMicrosoft.AspNetCore.SignalR.Protocol.CompletionMessage.CompletionMessage(string! invocationId, string? error, object? result, bool hasResult) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.CompletionMessage.Error.get -> string?\nMicrosoft.AspNetCore.SignalR.Protocol.CompletionMessage.HasResult.get -> bool\nMicrosoft.AspNetCore.SignalR.Protocol.CompletionMessage.Result.get -> object?\n```\n\n----------------------------------------\n\nTITLE: Type Conversion Methods in BindConverter\nDESCRIPTION: Static methods for converting various data types with culture support. Includes conversions for primitive types, date/time types, and their nullable variants.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.BindConverter.TryConvertToBool(object? obj, System.Globalization.CultureInfo? culture, out bool value) -> bool\nstatic Microsoft.AspNetCore.Components.BindConverter.TryConvertToDateTime(object? obj, System.Globalization.CultureInfo? culture, out System.DateTime value) -> bool\n```\n\n----------------------------------------\n\nTITLE: JSON Serialization for HTTP Responses in ASP.NET Core\nDESCRIPTION: Serializes objects to JSON responses, handling type information and polymorphism. The method includes performance optimizations by using JsonTypeInfo for better serialization efficiency.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_NullableReturn.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining View Component Conventions in C#\nDESCRIPTION: These static methods and properties define conventions for view components in ASP.NET Core MVC. They include methods for getting component names, checking if a type is a component, and a constant for the view component suffix.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Mvc.ViewComponents.ViewComponentConventions.GetComponentFullName(System.Reflection.TypeInfo componentType) -> string\nstatic Microsoft.AspNetCore.Mvc.ViewComponents.ViewComponentConventions.GetComponentName(System.Reflection.TypeInfo componentType) -> string\nstatic Microsoft.AspNetCore.Mvc.ViewComponents.ViewComponentConventions.IsComponent(System.Reflection.TypeInfo typeInfo) -> bool\nstatic readonly Microsoft.AspNetCore.Mvc.ViewComponents.ViewComponentConventions.ViewComponentSuffix -> string\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Form Content Type Validation\nDESCRIPTION: Validates incoming form content type and either throws BadHttpRequestException or logs debug message when content type is unsupported.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Parameter Binding Failure in C#\nDESCRIPTION: This method handles parameter binding failures by either throwing a BadHttpRequestException or logging the failure. It takes the parameter type, name, and source value as inputs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Error Logging and Exception Throwing Helper in ASP.NET Core\nDESCRIPTION: Implements a helper class for logging errors or throwing exceptions based on configuration in ASP.NET Core. It provides methods for handling various error scenarios in request processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    // Additional methods omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Casting Delegate in ASP.NET Core\nDESCRIPTION: Generic method for casting a delegate to a specific delegate type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RedisCacheOptions Class in C#\nDESCRIPTION: Defines the RedisCacheOptions class for configuring Redis caching. It includes properties for connection configuration, instance name, and profiling options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.Configuration.get -> string?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.Configuration.set -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ConfigurationOptions.get -> StackExchange.Redis.ConfigurationOptions?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ConfigurationOptions.set -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ConnectionMultiplexerFactory.get -> System.Func<System.Threading.Tasks.Task<StackExchange.Redis.IConnectionMultiplexer!>!>?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ConnectionMultiplexerFactory.set -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.InstanceName.get -> string?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.InstanceName.set -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ProfilingSession.get -> System.Func<StackExchange.Redis.Profiling.ProfilingSession!>?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ProfilingSession.set -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.RedisCacheOptions() -> void\n```\n\n----------------------------------------\n\nTITLE: Defining Content Type Constants in ASP.NET Core\nDESCRIPTION: This generated code defines constants for various content types used in ASP.NET Core applications, including JSON, plaintext, and form data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsTodo_Has_Metadata.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Metadata Constants for ASP.NET Core in C#\nDESCRIPTION: This generated class defines constant arrays for common content types used in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsSameInterceptorsFromDifferentFiles.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Restoring Project Dependencies on Linux/Mac\nDESCRIPTION: Bash command to run the restore script on Linux or Mac, which installs required dotnet dependencies and sets up the repository.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/README.md#2025-04-08_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./restore.sh\n```\n\n----------------------------------------\n\nTITLE: Defining Web-Specific Event Arguments in C#\nDESCRIPTION: Defines various event argument classes for web-specific events such as clipboard operations, drag and drop, and focus events.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Web.ClipboardEventArgs\nMicrosoft.AspNetCore.Components.Web.ClipboardEventArgs.ClipboardEventArgs() -> void\nMicrosoft.AspNetCore.Components.Web.ClipboardEventArgs.Type.get -> string!\nMicrosoft.AspNetCore.Components.Web.ClipboardEventArgs.Type.set -> void\n\nMicrosoft.AspNetCore.Components.Web.DragEventArgs\nMicrosoft.AspNetCore.Components.Web.DragEventArgs.DataTransfer.get -> Microsoft.AspNetCore.Components.Web.DataTransfer!\nMicrosoft.AspNetCore.Components.Web.DragEventArgs.DataTransfer.set -> void\nMicrosoft.AspNetCore.Components.Web.DragEventArgs.DragEventArgs() -> void\n\nMicrosoft.AspNetCore.Components.Web.FocusEventArgs\nMicrosoft.AspNetCore.Components.Web.FocusEventArgs.FocusEventArgs() -> void\nMicrosoft.AspNetCore.Components.Web.FocusEventArgs.Type.get -> string?\nMicrosoft.AspNetCore.Components.Web.FocusEventArgs.Type.set -> void\n```\n\n----------------------------------------\n\nTITLE: MVC Filter Scope Constants\nDESCRIPTION: Static readonly constants defining the scope and order of MVC filters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Mvc.Filters.FilterScope.Action -> int\nstatic readonly Microsoft.AspNetCore.Mvc.Filters.FilterScope.Controller -> int\nstatic readonly Microsoft.AspNetCore.Mvc.Filters.FilterScope.First -> int\nstatic readonly Microsoft.AspNetCore.Mvc.Filters.FilterScope.Global -> int\nstatic readonly Microsoft.AspNetCore.Mvc.Filters.FilterScope.Last -> int\n```\n\n----------------------------------------\n\nTITLE: Defining Request Queue Mode Enum in C#\nDESCRIPTION: Enum defining the modes for HTTP.sys request queue initialization, allowing creation of new queues, attaching to existing ones, or both.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/HttpSys/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Server.HttpSys.RequestQueueMode\nMicrosoft.AspNetCore.Server.HttpSys.RequestQueueMode.Attach = 1 -> Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode\nMicrosoft.AspNetCore.Server.HttpSys.RequestQueueMode.Create = 0 -> Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode\nMicrosoft.AspNetCore.Server.HttpSys.RequestQueueMode.CreateOrAttach = 2 -> Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive that enables nullable reference type checking for the current file or project scope. This enforces strict null checking for reference types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpLogging/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: C# Interface and Class Declarations for ASP.NET Core Components\nDESCRIPTION: Comprehensive API surface for ASP.NET Core Components including event handling, component lifecycle, layouts and state management. Contains class constructors, property accessors and method signatures.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.IComponent\nMicrosoft.AspNetCore.Components.IComponent.Attach(Microsoft.AspNetCore.Components.RenderHandle renderHandle) -> void\nMicrosoft.AspNetCore.Components.IComponent.SetParametersAsync(Microsoft.AspNetCore.Components.ParameterView parameters) -> System.Threading.Tasks.Task!\n\nMicrosoft.AspNetCore.Components.EventCallback<TValue>\nMicrosoft.AspNetCore.Components.EventCallback<TValue>.EventCallback() -> void\nMicrosoft.AspNetCore.Components.EventCallback<TValue>.EventCallback(Microsoft.AspNetCore.Components.IHandleEvent? receiver, System.MulticastDelegate? delegate) -> void\n\nMicrosoft.AspNetCore.Components.LayoutComponentBase\nMicrosoft.AspNetCore.Components.LayoutComponentBase.Body.get -> Microsoft.AspNetCore.Components.RenderFragment?\nMicrosoft.AspNetCore.Components.LayoutComponentBase.Body.set -> void\nMicrosoft.AspNetCore.Components.LayoutComponentBase.LayoutComponentBase() -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring Code Signing Exclusion Patterns for ASP.NET Core\nDESCRIPTION: Defines patterns for files that should be excluded from the code signing process. Each line specifies a file pattern and provides a comment explaining why these files should not be signed.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/eng/SignCheckExclusionsFile.txt#2025-04-08_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n*apphost.exe;; Exclude the apphost because this is expected to be code-signed by customers after the SDK modifies it.\n*.binlog;; MSBuild binary logs are not signed though they are sometimes placed where validation thinks they should be.\n*.js;; We do not sign JavaScript files.\n*netfxca|*wixca|*wixdepca|*wixuiwixca;*.msi; We do not sign WiX content in our installers.\n*wixstdba.dll;*.exe;\n```\n\n----------------------------------------\n\nTITLE: HttpMethodAttribute Class Definition - C#\nDESCRIPTION: Base attribute for HTTP method constraints in routing with support for method names, templates, and ordering.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Routing.HttpMethodAttribute.HttpMethodAttribute(System.Collections.Generic.IEnumerable<string!>! httpMethods) -> void\nMicrosoft.AspNetCore.Mvc.Routing.HttpMethodAttribute.HttpMethodAttribute(System.Collections.Generic.IEnumerable<string!>! httpMethods, string? template) -> void\n```\n\n----------------------------------------\n\nTITLE: Overriding OnModelCreating in C# for Identity DbContexts\nDESCRIPTION: Overrides the OnModelCreating method in IdentityDbContext and IdentityUserContext to configure the database schema for identity tables.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityDbContext<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TRoleClaim, TUserToken>.OnModelCreating(Microsoft.EntityFrameworkCore.ModelBuilder! builder) -> void\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityUserContext<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.OnModelCreating(Microsoft.EntityFrameworkCore.ModelBuilder! builder) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining IHubProtocolResolver Interface in ASP.NET Core SignalR\nDESCRIPTION: Interface definition for the hub protocol resolver which is responsible for retrieving hub protocols by name and providing access to all available protocols.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.IHubProtocolResolver\nMicrosoft.AspNetCore.SignalR.IHubProtocolResolver.AllProtocols.get -> System.Collections.Generic.IReadOnlyList<Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol!>!\nMicrosoft.AspNetCore.SignalR.IHubProtocolResolver.GetProtocol(string! protocolName, System.Collections.Generic.IReadOnlyList<string!>? supportedProtocols) -> Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol?\n```\n\n----------------------------------------\n\nTITLE: FormTagHelper Class Signatures in ASP.NET Core MVC\nDESCRIPTION: API signatures for the FormTagHelper class that generates HTML form elements with routing capabilities. It provides properties for controller, action, route values, and form submission methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.TagHelpers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.Action.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.Action.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.Area.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.Area.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.Controller.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.Controller.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.FormTagHelper(Microsoft.AspNetCore.Mvc.ViewFeatures.IHtmlGenerator generator) -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.Fragment.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.Fragment.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.Generator.get -> Microsoft.AspNetCore.Mvc.ViewFeatures.IHtmlGenerator\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.Method.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.Method.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.Page.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.Page.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.PageHandler.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.PageHandler.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.Route.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.Route.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.RouteValues.get -> System.Collections.Generic.IDictionary<string, string>\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.RouteValues.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.ViewContext.get -> Microsoft.AspNetCore.Mvc.Rendering.ViewContext\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormTagHelper.ViewContext.set -> void\n```\n\n----------------------------------------\n\nTITLE: LabelTagHelper Class Signatures in ASP.NET Core MVC\nDESCRIPTION: API signatures for the LabelTagHelper class that generates HTML label elements bound to model properties. It uses model expressions to create appropriate label content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.TagHelpers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n~Microsoft.AspNetCore.Mvc.TagHelpers.LabelTagHelper.For.get -> Microsoft.AspNetCore.Mvc.ViewFeatures.ModelExpression\n~Microsoft.AspNetCore.Mvc.TagHelpers.LabelTagHelper.For.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.LabelTagHelper.Generator.get -> Microsoft.AspNetCore.Mvc.ViewFeatures.IHtmlGenerator\n~Microsoft.AspNetCore.Mvc.TagHelpers.LabelTagHelper.LabelTagHelper(Microsoft.AspNetCore.Mvc.ViewFeatures.IHtmlGenerator generator) -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.LabelTagHelper.ViewContext.get -> Microsoft.AspNetCore.Mvc.Rendering.ViewContext\n~Microsoft.AspNetCore.Mvc.TagHelpers.LabelTagHelper.ViewContext.set -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing LogOrThrowExceptionHelper Class in C#\nDESCRIPTION: This class handles logging or throwing exceptions based on configuration. It includes methods for various error scenarios in request processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    // ... (methods for handling different error scenarios)\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Non-Form Content Type in ASP.NET Core\nDESCRIPTION: This method handles unexpected non-form content types by either throwing a BadHttpRequestException or logging the error. It uses a predefined LoggerMessage for efficient logging of the unexpected content type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Non-Form Content Type in ASP.NET Core\nDESCRIPTION: Manages situations where a form content type was expected but a different content type was received. It throws a BadHttpRequestException with a 415 status code or logs a debug message depending on configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Windows Socket Address Types\nDESCRIPTION: References to core Windows socket address structure types SOCKADDR_IN and SOCKADDR_IN6 from the Windows HttpServer namespace, used for IPv4 and IPv6 addressing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Shared/test/Shared.Tests/NativeMethods.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// https://github.com/microsoft/cswin32\nWindows.Win32.Networking.HttpServer\nSOCKADDR_IN\nSOCKADDR_IN6\n```\n\n----------------------------------------\n\nTITLE: Defining Help Wanted Issue Structure in Markdown\nDESCRIPTION: This markdown snippet outlines the structure for a 'Help Wanted' issue in the ASP.NET Core repository. It includes sections for issue summary, potential design, code references, relevant documentation, important considerations, and additional notes for contributors.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/HelpWantedIssueSummaryCommentTemplate.md#2025-04-08_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n<!--\n\n**IMPORTANT**: As part of posting this comment, please make sure:\n- that the issue is properly labeled with both `area-` and `feature-` labels.\n- to apply one of the `Complexity: <value>` labels is applied to the issue [Simple | Medium | Hard]\n- for an issue which was marked with `Complexity: Simple` label, it may be a good fit for a first-time contributors to this repo.\n  If so, please also apply `good-first-issue` label.\n-->\n\n# Help Wanted\n\n## Issue Summary\n\n<!-- This section will be filled in by the engineers assigned to this  -->\n\n## Potential Design\n\n<!-- This section is meant to be used for a high level design of what a solution should look like and/or what direction should be taken to solving this problem. -->\n\n## Code References\n\n<!-- Links to classes / methods which are critical to understand for building out this solution, as these are relevant and will be used by the solution, as well as existing test cases that exercise this code -->\n\n## Relevant Documentation\n\n<!-- Links to relevant documentation which you think is relevant for handling this issue -->\n\n## Important Considerations\n\n<!-- List of additional gotchas the community member who will be handling this issue will need to consider when working on the solution -->\n\n## Additional Notes\n- If the change you are going to make will include a **public API change** in the framework, then the change will need to go through our [API Review Process](/docs/APIReviewProcess.md). Please read this process to take any necessary steps, to avoid any potential delays down the road with accepting this change.\n- If this is your first contribution to the repo, you may find it useful to learn [How to build the repo](/docs/BuildFromSource.md)\n- Please note, that the changes will be considered for the vNext version of the framework by default. That is, after the change gets merged in main, it will be available only in the next preview release of the framework and will be shipped in the upcoming major release of the product.\n```\n\n----------------------------------------\n\nTITLE: WebSocketClient Class Definition\nDESCRIPTION: Client for testing WebSocket connections in ASP.NET Core applications. Allows configuration of WebSocket requests and connections.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/TestHost/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class WebSocketClient\n{\n    public Action<HttpRequest> ConfigureRequest { get; set; }\n    public IList<string> SubProtocols { get; }\n    \n    public Task<WebSocket> ConnectAsync(Uri uri, CancellationToken cancellationToken)\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive that enables nullable reference type checking for better null safety. This helps catch potential null reference exceptions at compile time.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/netstandard2.1/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive that enables nullable reference type checking, requiring explicit null handling in C# code that follows this directive.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable References - C#\nDESCRIPTION: Directive that enables nullable reference type checks in C# code. This helps catch potential null reference issues at compile time.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Application Main Entry Point\nDESCRIPTION: Main entry point that builds and runs the web host.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Tools/Microsoft.dotnet-openapi/test/TestContent/Startup.cs.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic static void Main(string[] args)\n{\n    var host = CreateWebHostBuilder(args)\n        .Build();\n\n    host.Run();\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Required Parameter Not Provided in C#\nDESCRIPTION: This method handles cases where a required parameter is not provided. It either throws a BadHttpRequestException or logs the issue, depending on the configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sort Direction Enumeration\nDESCRIPTION: Enumeration defining possible sort directions for grid columns.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/QuickGrid/Microsoft.AspNetCore.Components.QuickGrid/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.QuickGrid.SortDirection {\n    Auto = 0,\n    Ascending = 1,\n    Descending = 2\n}\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Performance Results for Object Pool Implementations\nDESCRIPTION: Extensive benchmark results comparing the 'Default' (original) pool implementation with the 'Scaled' (ConcurrentQueue-based) implementation across multiple scenarios including single-threaded and multi-threaded operations, different pool sizes, and various usage patterns.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/ObjectPool/perf/Microbenchmarks/README.md#2025-04-08_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nBenchmarkDotNet=v0.13.2, OS=Windows 11 (10.0.22621.819)\nIntel Core i7-9700K CPU 3.60GHz (Coffee Lake), 1 CPU, 8 logical and 8 physical cores\n.NET SDK=7.0.100\n  [Host] : .NET 7.0.0 (7.0.22.51805), X64 RyuJIT AVX2\n\nJob=MediumRun  Toolchain=InProcessEmitToolchain  IterationCount=15\nLaunchCount=2  WarmupCount=10\n\n|          Method |    Pool |     Mean |    Error |   StdDev | Allocated |\n|---------------- |-------- |---------:|---------:|---------:|----------:|\n| GetReturnSingle | Default | 14.85 ns | 2.542 ns | 0.139 ns |         - |\n| GetReturnSingle |  Scaled | 13.87 ns | 3.672 ns | 0.201 ns |         - |\n\n|         Method | ThreadCount |    Pool |       Mean |       Error |    StdDev | Allocated |\n|--------------- |------------ |-------- |-----------:|------------:|----------:|----------:|\n| GetReturnMulti |           1 | Default |   236.8 ns |    14.93 ns |   0.82 ns |         - |\n| GetReturnMulti |           1 |  Scaled |   230.5 ns |    31.11 ns |   1.70 ns |         - |\n| GetReturnMulti |           2 | Default |   311.6 ns |    83.49 ns |   4.58 ns |         - |\n| GetReturnMulti |           2 |  Scaled |   271.8 ns |    74.50 ns |   4.08 ns |         - |\n| GetReturnMulti |           4 | Default |   561.3 ns |   523.72 ns |  28.71 ns |         - |\n| GetReturnMulti |           4 |  Scaled |   692.5 ns |   167.71 ns |   9.19 ns |         - |\n| GetReturnMulti |           8 | Default |   857.2 ns | 1,892.29 ns | 103.72 ns |         - |\n| GetReturnMulti |           8 |  Scaled | 1,021.1 ns |   500.68 ns |  27.44 ns |         - |\n\n|            Method | Count |    Pool |            Mean |         Error |       StdDev | Allocated |\n|------------------ |------ |-------- |----------------:|--------------:|-------------:|----------:|\n| DrainRefillSingle |     8 | Default |        253.3 ns |       9.31 ns |      0.51 ns |         - |\n| DrainRefillSingle |     8 |  Scaled |        227.9 ns |       3.57 ns |      0.20 ns |         - |\n| DrainRefillSingle |    16 | Default |        901.8 ns |     109.49 ns |      6.00 ns |         - |\n| DrainRefillSingle |    16 |  Scaled |        455.1 ns |      45.04 ns |      2.47 ns |         - |\n| DrainRefillSingle |    64 | Default |     14,087.7 ns |     709.81 ns |     38.91 ns |         - |\n| DrainRefillSingle |    64 |  Scaled |      1,855.6 ns |     240.62 ns |     13.19 ns |         - |\n| DrainRefillSingle |   256 | Default |    212,392.1 ns |  15,057.03 ns |    825.33 ns |         - |\n| DrainRefillSingle |   256 |  Scaled |      7,490.5 ns |     278.66 ns |     15.27 ns |         - |\n| DrainRefillSingle |  1024 | Default |  3,350,706.9 ns | 324,499.03 ns | 17,786.89 ns |       5 B |\n| DrainRefillSingle |  1024 |  Scaled |     29,987.0 ns |   1,420.77 ns |     77.88 ns |         - |\n| DrainRefillSingle |  2048 | Default | 13,269,695.8 ns | 814,400.01 ns | 44,640.01 ns |      20 B |\n| DrainRefillSingle |  2048 |  Scaled |     66,323.3 ns |  11,331.39 ns |    621.11 ns |         - |\n\n|           Method | Count | ThreadCount |    Pool |              Mean |             Error |         StdDev | Allocated |\n|----------------- |------ |------------ |-------- |------------------:|------------------:|---------------:|----------:|\n| DrainRefillMulti |     8 |           1 | Default |      3,402.040 ns |       600.7019 ns |     32.9265 ns |         - |\n| DrainRefillMulti |     8 |           1 |  Scaled |      3,340.664 ns |       603.0542 ns |     33.0554 ns |         - |\n| DrainRefillMulti |     8 |           2 | Default |      2,342.273 ns |     1,601.9624 ns |     87.8090 ns |         - |\n| DrainRefillMulti |     8 |           2 |  Scaled |      2,243.490 ns |     1,048.4364 ns |     57.4683 ns |         - |\n| DrainRefillMulti |     8 |           4 | Default |      1,369.241 ns |       552.3366 ns |     30.2754 ns |         - |\n| DrainRefillMulti |     8 |           4 |  Scaled |      1,013.460 ns |     2,311.3719 ns |    126.6941 ns |         - |\n| DrainRefillMulti |     8 |           8 | Default |          2.490 ns |         0.0310 ns |      0.0017 ns |         - |\n| DrainRefillMulti |     8 |           8 |  Scaled |          2.490 ns |         0.0176 ns |      0.0010 ns |         - |\n| DrainRefillMulti |    16 |           1 | Default |      7,696.936 ns |     1,441.3538 ns |     79.0055 ns |         - |\n| DrainRefillMulti |    16 |           1 |  Scaled |      6,976.167 ns |       677.5599 ns |     37.1393 ns |         - |\n| DrainRefillMulti |    16 |           2 | Default |      4,672.361 ns |        89.7377 ns |      4.9188 ns |         - |\n| DrainRefillMulti |    16 |           2 |  Scaled |      4,462.518 ns |       784.9351 ns |     43.0249 ns |         - |\n| DrainRefillMulti |    16 |           4 | Default |      3,027.048 ns |       806.3016 ns |     44.1961 ns |         - |\n| DrainRefillMulti |    16 |           4 |  Scaled |      2,524.434 ns |     1,692.4096 ns |     92.7667 ns |         - |\n| DrainRefillMulti |    16 |           8 | Default |      2,359.546 ns |       139.8285 ns |      7.6645 ns |         - |\n| DrainRefillMulti |    16 |           8 |  Scaled |      1,318.973 ns |     2,819.4887 ns |    154.5457 ns |         - |\n| DrainRefillMulti |    64 |           1 | Default |     42,156.917 ns |     6,252.2089 ns |    342.7047 ns |         - |\n| DrainRefillMulti |    64 |           1 |  Scaled |     34,420.998 ns |     4,824.3074 ns |    264.4366 ns |         - |\n| DrainRefillMulti |    64 |           2 | Default |     20,528.296 ns |    10,638.3506 ns |    583.1239 ns |         - |\n| DrainRefillMulti |    64 |           2 |  Scaled |     19,258.943 ns |     1,403.3149 ns |     76.9204 ns |         - |\n| DrainRefillMulti |    64 |           4 | Default |     10,090.506 ns |     1,897.5224 ns |    104.0096 ns |         - |\n| DrainRefillMulti |    64 |           4 |  Scaled |     10,361.626 ns |     1,210.3394 ns |     66.3428 ns |         - |\n| DrainRefillMulti |    64 |           8 | Default |      6,266.454 ns |     1,319.7780 ns |     72.3415 ns |         - |\n| DrainRefillMulti |    64 |           8 |  Scaled |      5,802.875 ns |     2,609.1042 ns |    143.0138 ns |         - |\n| DrainRefillMulti |   256 |           1 | Default |    329,837.142 ns |    28,180.8139 ns |  1,544.6855 ns |         - |\n| DrainRefillMulti |   256 |           1 |  Scaled |    118,653.739 ns |     5,552.4422 ns |    304.3481 ns |         - |\n| DrainRefillMulti |   256 |           2 | Default |     76,942.582 ns |   156,667.0744 ns |  8,587.4510 ns |         - |\n| DrainRefillMulti |   256 |           2 |  Scaled |     76,145.129 ns |    27,993.7132 ns |  1,534.4299 ns |         - |\n| DrainRefillMulti |   256 |           4 | Default |     38,844.476 ns |     5,150.0739 ns |    282.2929 ns |         - |\n| DrainRefillMulti |   256 |           4 |  Scaled |     42,601.213 ns |    18,958.2889 ns |  1,039.1678 ns |         - |\n| DrainRefillMulti |   256 |           8 | Default |     21,718.325 ns |     1,174.3632 ns |     64.3708 ns |         - |\n| DrainRefillMulti |   256 |           8 |  Scaled |     24,667.206 ns |    15,298.1144 ns |    838.5413 ns |         - |\n| DrainRefillMulti |  1024 |           1 | Default |  3,931,928.906 ns |   502,418.7402 ns | 27,539.2665 ns |       5 B |\n| DrainRefillMulti |  1024 |           1 |  Scaled |    475,052.637 ns |    62,820.3506 ns |  3,443.3954 ns |         - |\n| DrainRefillMulti |  1024 |           2 | Default |    428,420.475 ns |   949,652.4645 ns | 52,053.6560 ns |         - |\n| DrainRefillMulti |  1024 |           2 |  Scaled |    312,404.215 ns |    31,360.8510 ns |  1,718.9941 ns |         - |\n| DrainRefillMulti |  1024 |           4 | Default |    153,662.158 ns |    25,638.8645 ns |  1,405.3527 ns |         - |\n| DrainRefillMulti |  1024 |           4 |  Scaled |    158,768.604 ns |    68,297.3126 ns |  3,743.6062 ns |         - |\n| DrainRefillMulti |  1024 |           8 | Default |     86,047.257 ns |       495.9489 ns |     27.1846 ns |         - |\n| DrainRefillMulti |  1024 |           8 |  Scaled |     88,594.971 ns |     8,521.3088 ns |    467.0817 ns |         - |\n| DrainRefillMulti |  2048 |           1 | Default | 14,744,884.896 ns |   582,454.6067 ns | 31,926.3024 ns |      10 B |\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Message for Non-Form Content Type in ASP.NET Core\nDESCRIPTION: Creates a structured logger message definition for unexpected non-form content types. This allows for consistent debug logging when a request contains an unsupported form media type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitBodyParam_ComplexReturn_Snapshot.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Defining IRemoteAuthenticationBuilder Interface in C#\nDESCRIPTION: Defines the IRemoteAuthenticationBuilder interface for configuring remote authentication services in ASP.NET Core WebAssembly applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<TRemoteAuthenticationState, TAccount>\nMicrosoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<TRemoteAuthenticationState, TAccount>.Services.get -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Overriding User Query Methods in ASP.NET Core Identity\nDESCRIPTION: This snippet shows the method signatures for overriding user query operations in ASP.NET Core Identity. It includes methods for finding users by email, ID, login, and name.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.FindByEmailAsync(string! normalizedEmail, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<TUser?>!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.FindByIdAsync(string! userId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<TUser?>!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.FindByLoginAsync(string! loginProvider, string! providerKey, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<TUser?>!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.FindByNameAsync(string! normalizedUserName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<TUser?>!\n```\n\n----------------------------------------\n\nTITLE: Declaring FormReader Class in C#\nDESCRIPTION: Defines a FormReader class for parsing form data from strings or streams, with methods for reading form data and individual key-value pairs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/WebUtilities/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.WebUtilities.FormReader\nMicrosoft.AspNetCore.WebUtilities.FormReader.Dispose() -> void\nMicrosoft.AspNetCore.WebUtilities.FormReader.FormReader(string! data) -> void\nMicrosoft.AspNetCore.WebUtilities.FormReader.FormReader(string! data, System.Buffers.ArrayPool<char>! charPool) -> void\nMicrosoft.AspNetCore.WebUtilities.FormReader.FormReader(System.IO.Stream! stream) -> void\nMicrosoft.AspNetCore.WebUtilities.FormReader.FormReader(System.IO.Stream! stream, System.Text.Encoding! encoding) -> void\nMicrosoft.AspNetCore.WebUtilities.FormReader.FormReader(System.IO.Stream! stream, System.Text.Encoding! encoding, System.Buffers.ArrayPool<char>! charPool) -> void\nMicrosoft.AspNetCore.WebUtilities.FormReader.KeyLengthLimit.get -> int\nMicrosoft.AspNetCore.WebUtilities.FormReader.KeyLengthLimit.set -> void\nMicrosoft.AspNetCore.WebUtilities.FormReader.ReadForm() -> System.Collections.Generic.Dictionary<string!, Microsoft.Extensions.Primitives.StringValues>!\nMicrosoft.AspNetCore.WebUtilities.FormReader.ReadFormAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<System.Collections.Generic.Dictionary<string!, Microsoft.Extensions.Primitives.StringValues>!>!\nMicrosoft.AspNetCore.WebUtilities.FormReader.ReadNextPair() -> System.Collections.Generic.KeyValuePair<string!, string!>?\nMicrosoft.AspNetCore.WebUtilities.FormReader.ReadNextPairAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<System.Collections.Generic.KeyValuePair<string!, string!>?>!\nMicrosoft.AspNetCore.WebUtilities.FormReader.ValueCountLimit.get -> int\nMicrosoft.AspNetCore.WebUtilities.FormReader.ValueCountLimit.set -> void\nMicrosoft.AspNetCore.WebUtilities.FormReader.ValueLengthLimit.get -> int\nMicrosoft.AspNetCore.WebUtilities.FormReader.ValueLengthLimit.set -> void\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Non-Form Content Type in C#\nDESCRIPTION: Method to handle cases where the content type doesn't match expected form media type. Includes both exception throwing and logging functionality based on configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Content Type Constants for ASP.NET Core - C#\nDESCRIPTION: Defines constant arrays for common content types used in HTTP requests and responses. Includes JSON, plaintext, form file, and form URL-encoded content types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitBodyParam_ComplexReturn_Snapshot.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a custom attribute for method interception that can be applied to methods with AllowMultiple set to true. This attribute is used in the context of ASP.NET Core request delegation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_QueryNotPresent.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cleaning Repository Assets in Git\nDESCRIPTION: Command to clean the repository from any assets that could remain from previous versions. This is recommended when switching branches or updating the working branch.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\ngit clean -xdff\n```\n\n----------------------------------------\n\nTITLE: Defining BaseConnectionContext Abstract Class in C#\nDESCRIPTION: Defines the abstract BaseConnectionContext class with methods for aborting connections and properties for connection ID, features, and items.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Connections.BaseConnectionContext.Abort() -> void\nabstract Microsoft.AspNetCore.Connections.BaseConnectionContext.Abort(Microsoft.AspNetCore.Connections.ConnectionAbortedException! abortReason) -> void\nabstract Microsoft.AspNetCore.Connections.BaseConnectionContext.ConnectionId.get -> string!\nabstract Microsoft.AspNetCore.Connections.BaseConnectionContext.ConnectionId.set -> void\nabstract Microsoft.AspNetCore.Connections.BaseConnectionContext.Features.get -> Microsoft.AspNetCore.Http.Features.IFeatureCollection!\nabstract Microsoft.AspNetCore.Connections.BaseConnectionContext.Items.get -> System.Collections.Generic.IDictionary<object!, object?>!\nabstract Microsoft.AspNetCore.Connections.BaseConnectionContext.Items.set -> void\n```\n\n----------------------------------------\n\nTITLE: ImageTagHelper Class Signatures in ASP.NET Core MVC\nDESCRIPTION: API signatures for the ImageTagHelper class that enhances HTML img elements. It handles file versioning, caching, and source URL generation for image elements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.TagHelpers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n~Microsoft.AspNetCore.Mvc.TagHelpers.ImageTagHelper.Cache.get -> Microsoft.Extensions.Caching.Memory.IMemoryCache\n~Microsoft.AspNetCore.Mvc.TagHelpers.ImageTagHelper.HostingEnvironment.get -> Microsoft.AspNetCore.Hosting.IWebHostEnvironment\n~Microsoft.AspNetCore.Mvc.TagHelpers.ImageTagHelper.ImageTagHelper(Microsoft.AspNetCore.Hosting.IWebHostEnvironment hostingEnvironment, Microsoft.AspNetCore.Mvc.Razor.Infrastructure.TagHelperMemoryCacheProvider cacheProvider, Microsoft.AspNetCore.Mvc.ViewFeatures.IFileVersionProvider fileVersionProvider, System.Text.Encodings.Web.HtmlEncoder htmlEncoder, Microsoft.AspNetCore.Mvc.Routing.IUrlHelperFactory urlHelperFactory) -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.ImageTagHelper.ImageTagHelper(Microsoft.AspNetCore.Mvc.ViewFeatures.IFileVersionProvider fileVersionProvider, System.Text.Encodings.Web.HtmlEncoder htmlEncoder, Microsoft.AspNetCore.Mvc.Routing.IUrlHelperFactory urlHelperFactory) -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.ImageTagHelper.Src.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.ImageTagHelper.Src.set -> void\n```\n\n----------------------------------------\n\nTITLE: Running Autobahn WebSocket Tests with PowerShell\nDESCRIPTION: PowerShell command to execute the RunAutobahnTests.ps1 script against a specified WebSocket server URL. The script runs Autobahn test cases and outputs reports to the autobahnreports directory by default.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/WebSockets/test/ConformanceTests/AutobahnTestApp/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> .\\scripts\\RunAutobahnTests.ps1 -ServerUrl ws://server:1234\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in C#\nDESCRIPTION: This method handles cases where reading a parameter from the request body as a form fails. It throws a BadHttpRequestException or logs the issue, including the exception details.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running E2E Tests with Trimming Property Set\nDESCRIPTION: Alternative commands to test WebAssembly trimming by building with the TestTrimmedOrMultithreadingApps property and then running tests without rebuilding.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/README.md#2025-04-08_snippet_12\n\nLANGUAGE: powershell\nCODE:\n```\ndotnet build /p:TestTrimmedOrMultithreadingApps=true\ndotnet test --no-build\n```\n\n----------------------------------------\n\nTITLE: Implementing Response Execution for Various Return Types\nDESCRIPTION: Defines a method that executes different response types, handling IResult objects, strings, and JSON-serializable objects differently. This provides flexible response generation based on handler return types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsValidationProblemResult_Has_Metadata.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n        private static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n        {\n            if (obj is IResult r)\n            {\n                return r.ExecuteAsync(httpContext);\n            }\n            else if (obj is string s)\n            {\n                return httpContext.Response.WriteAsync(s);\n            }\n            else\n            {\n                return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n            }\n        }\n```\n\n----------------------------------------\n\nTITLE: Creating Minimal WebHost Configuration in ASP.NET Core\nDESCRIPTION: This code snippet demonstrates how to create a minimal WebHostBuilder configuration for an ASP.NET Core application. It includes setting the content root directory and adding default configuration settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/test/testroot/wwwroot/Static Web/Static Web.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar webHostBuilder = new WebHostBuilder()\n    .UseContentRoot(Directory.GetCurrentDirectory())\n    .ConfigureAppConfiguration(_ => { });\n```\n\n----------------------------------------\n\nTITLE: Enabling nullable reference types in C#\nDESCRIPTION: This directive enables C#'s nullable reference type feature, which helps catch potential null reference exceptions during compilation by making reference type variables non-nullable by default.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/TestHost/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Decoding Message with Headers in MessagePack\nDESCRIPTION: Illustrates the encoding and decoding of a message with headers in the SignalR MessagePack protocol. It shows how headers are represented as a map following the message type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_17\n\nLANGUAGE: MessagePack\nCODE:\n```\n0x96 0x01 0x82 0xa1 0x78 0xa1 0x79 0xa1 0x7a 0xa1 0x7a 0xa3 0x78 0x79 0x7a 0xa6 0x6d 0x65 0x74 0x68 0x6f 0x64 0x91 0x2a 0x90\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive that enables nullable reference type checking for the current file or project scope. This helps catch potential null reference exceptions at compile time.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Metadata/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Adding Authentication State Deserialization in ASP.NET Core WebAssembly\nDESCRIPTION: Extension method to register authentication state deserialization services in the dependency injection container. This method allows configuring how authentication state is deserialized from storage in WebAssembly applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.WebAssemblyAuthenticationServiceCollectionExtensions.AddAuthenticationStateDeserialization(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Components.WebAssembly.Authentication.AuthenticationStateDeserializationOptions!>? configure = null) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a sealed attribute class used for method interception with version and data parameters. This is part of the compiler-generated code infrastructure.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitBodyParam_ComplexReturn_Snapshot.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class InterceptsLocationAttribute : Attribute\n{\n    public InterceptsLocationAttribute(int version, string data)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AnalysisBuilder Class for ASP.NET Core Middleware Analysis in C#\nDESCRIPTION: This snippet defines the AnalysisBuilder class, which is used to build an application pipeline with middleware analysis capabilities. It includes methods for adding middleware, accessing application services, and building the final request delegate.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/MiddlewareAnalysis/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.MiddlewareAnalysis.AnalysisBuilder\nMicrosoft.AspNetCore.MiddlewareAnalysis.AnalysisBuilder.AnalysisBuilder(Microsoft.AspNetCore.Builder.IApplicationBuilder! inner) -> void\nMicrosoft.AspNetCore.MiddlewareAnalysis.AnalysisBuilder.ApplicationServices.get -> System.IServiceProvider!\nMicrosoft.AspNetCore.MiddlewareAnalysis.AnalysisBuilder.ApplicationServices.set -> void\nMicrosoft.AspNetCore.MiddlewareAnalysis.AnalysisBuilder.Build() -> Microsoft.AspNetCore.Http.RequestDelegate!\nMicrosoft.AspNetCore.MiddlewareAnalysis.AnalysisBuilder.New() -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\nMicrosoft.AspNetCore.MiddlewareAnalysis.AnalysisBuilder.Properties.get -> System.Collections.Generic.IDictionary<string!, object?>!\nMicrosoft.AspNetCore.MiddlewareAnalysis.AnalysisBuilder.ServerFeatures.get -> Microsoft.AspNetCore.Http.Features.IFeatureCollection!\nMicrosoft.AspNetCore.MiddlewareAnalysis.AnalysisBuilder.Use(System.Func<Microsoft.AspNetCore.Http.RequestDelegate!, Microsoft.AspNetCore.Http.RequestDelegate!>! middleware) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Generating Request Delegate for GET Request with Custom Binding\nDESCRIPTION: This method generates a request delegate for handling GET requests with custom parameter binding. It includes metadata population, request handling, and optional filtering.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        // ... (metadata population logic)\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        // ... (request delegate creation logic)\n    };\n    var castHandler = Cast(handler, global::System.String (global::Microsoft.AspNetCore.Http.Generators.Tests.MyBindAsyncRecord? arg0) => throw null!);\n    return MapCore(\n        endpoints,\n        pattern,\n        handler,\n        GetVerb,\n        populateMetadata,\n        createRequestDelegate,\n        castHandler.Method);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MapCore Helper Method for Route Registration\nDESCRIPTION: Defines a core helper method that maps routes to handlers with specific HTTP methods. It delegates to RouteHandlerServices to create the actual route handler builder.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsValidationProblemResult_Has_Metadata.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n        internal static RouteHandlerBuilder MapCore(\n            this IEndpointRouteBuilder routes,\n            string pattern,\n            Delegate handler,\n            IEnumerable<string>? httpMethods,\n            MetadataPopulator populateMetadata,\n            RequestDelegateFactoryFunc createRequestDelegate,\n            MethodInfo methodInfo)\n        {\n            return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n        }\n```\n\n----------------------------------------\n\nTITLE: LogOrThrowExceptionHelper Class for Request Delegate Generation\nDESCRIPTION: A utility class that handles logging or throwing exceptions during request processing based on configuration. It contains methods for different error scenarios like invalid JSON, parameter binding failures, and content type mismatches, with consistent error messaging.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsString_Has_Metadata.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n    {\n        private readonly ILogger? _rdgLogger;\n        private readonly bool _shouldThrow;\n\n        public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n        {\n            var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n            _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n            _shouldThrow = options?.ThrowOnBadRequest ?? false;\n        }\n\n        public void RequestBodyIOException(IOException exception)\n        {\n            if (_rdgLogger != null)\n            {\n                _requestBodyIOException(_rdgLogger, exception);\n            }\n        }\n\n        private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n            LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n        public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n        {\n            if (_shouldThrow)\n            {\n                var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n                throw new BadHttpRequestException(message, exception);\n            }\n\n            if (_rdgLogger != null)\n            {\n                _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n            }\n        }\n\n        private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n            LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n\n        public void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n        {\n            if (_shouldThrow)\n            {\n                var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n                throw new BadHttpRequestException(message);\n            }\n\n            if (_rdgLogger != null)\n            {\n                _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n            }\n        }\n\n        private static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n            LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n\n        public void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n        {\n            if (_shouldThrow)\n            {\n                var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n                throw new BadHttpRequestException(message);\n            }\n\n            if (_rdgLogger != null)\n            {\n                _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n            }\n        }\n\n        private static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n            LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n\n        public void ImplicitBodyNotProvided(string parameterName)\n        {\n            if (_shouldThrow)\n            {\n                var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n                throw new BadHttpRequestException(message);\n            }\n\n            if (_rdgLogger != null)\n            {\n                _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n            }\n        }\n\n        private static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n            LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n\n        public void UnexpectedJsonContentType(string? contentType)\n        {\n            if (_shouldThrow)\n            {\n                var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n                throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n            }\n\n            if (_rdgLogger != null)\n            {\n                _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n            }\n        }\n\n        private static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n            LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n\n        public void UnexpectedNonFormContentType(string? contentType)\n        {\n            if (_shouldThrow)\n            {\n                var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n                throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n            }\n\n            if (_rdgLogger != null)\n            {\n                _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n            }\n        }\n\n        private static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n            LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n\n        public void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n        {\n            if (_shouldThrow)\n            {\n                var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n                throw new BadHttpRequestException(message, exception);\n            }\n\n            if (_rdgLogger != null)\n            {\n                _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n            }\n        }\n\n        private static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n            LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n    }\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft.AspNetCore.TestHost Package with dotnet CLI\nDESCRIPTION: Command to install the Microsoft.AspNetCore.TestHost NuGet package using the dotnet CLI. This package is required for setting up isolated middleware testing in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/TestHost/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.TestHost\n```\n\n----------------------------------------\n\nTITLE: WebSocketAcceptContext Class Definition in C#\nDESCRIPTION: Class for configuring WebSocket acceptance parameters including compression, keep-alive settings, and sub-protocols.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Features/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nclass WebSocketAcceptContext {\n    public bool DangerousEnableCompression { get; set; }\n    public bool DisableServerContextTakeover { get; set; }\n    public TimeSpan? KeepAliveTimeout { get; set; }\n    public int ServerMaxWindowBits { get; set; }\n    public virtual TimeSpan? KeepAliveInterval { get; set; }\n    public virtual string? SubProtocol { get; set; }\n    public WebSocketAcceptContext();\n}\n```\n\n----------------------------------------\n\nTITLE: Building Blazor Components\nDESCRIPTION: PowerShell command to build the Components directory containing Blazor framework code.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/README.md#2025-04-08_snippet_6\n\nLANGUAGE: powershell\nCODE:\n```\n./src/Components/build.cmd\n```\n\n----------------------------------------\n\nTITLE: Core Type References in ObjectPool Documentation\nDESCRIPTION: Reference to core types in the object pooling system including ObjectPool<T> for managing pooled objects, IPooledObjectPolicy<T> for defining object creation and return policies, and ObjectPoolProvider for creating object pools.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/ObjectPool/Readme.md#2025-04-08_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nObjectPool<T> - This represents a pool of objects. This is used to get and return pooled objects.\nIPooledObjectPolicy<T> - This policy defines how pooled objects are created and returned.\nObjectPoolProvider - This represents a provider of ObjectPool<T>. This is used to create object pools based on an IPooledObjectPolicy<T>.\n```\n\n----------------------------------------\n\nTITLE: Defining RevalidatingServerAuthenticationStateProvider Abstract Class in C#\nDESCRIPTION: Abstract class for server authentication state provider with revalidation functionality. Includes an abstract property for revalidation interval and a method for validating authentication state.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Components.Server.RevalidatingServerAuthenticationStateProvider.RevalidationInterval.get -> System.TimeSpan\nabstract Microsoft.AspNetCore.Components.Server.RevalidatingServerAuthenticationStateProvider.ValidateAuthenticationStateAsync(Microsoft.AspNetCore.Components.Authorization.AuthenticationState! authenticationState, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>!\n```\n\n----------------------------------------\n\nTITLE: Configuring Authorization for Folders and Pages in ASP.NET Core Razor Pages\nDESCRIPTION: Extension methods for PageConventionCollection that configure authorization for standard pages and folders. These methods allow developers to require authentication with optional policy specification for Razor Pages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.PageConventionCollectionExtensions.AuthorizeFolder(this Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection! conventions, string! folderPath) -> Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection!\nstatic Microsoft.Extensions.DependencyInjection.PageConventionCollectionExtensions.AuthorizeFolder(this Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection! conventions, string! folderPath, string! policy) -> Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection!\nstatic Microsoft.Extensions.DependencyInjection.PageConventionCollectionExtensions.AuthorizePage(this Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection! conventions, string! pageName) -> Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection!\nstatic Microsoft.Extensions.DependencyInjection.PageConventionCollectionExtensions.AuthorizePage(this Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection! conventions, string! pageName, string! policy) -> Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection!\n```\n\n----------------------------------------\n\nTITLE: InputRadio and InputRadioGroup Components API\nDESCRIPTION: API signatures for InputRadio<TValue> and InputRadioGroup<TValue> components which work together to render radio button groups in forms, including properties for attributes, element references, and values.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Forms.InputRadio<TValue>\nMicrosoft.AspNetCore.Components.Forms.InputRadio<TValue>.AdditionalAttributes.get -> System.Collections.Generic.IReadOnlyDictionary<string!, object!>?\nMicrosoft.AspNetCore.Components.Forms.InputRadio<TValue>.AdditionalAttributes.set -> void\nMicrosoft.AspNetCore.Components.Forms.InputRadio<TValue>.Element.get -> Microsoft.AspNetCore.Components.ElementReference?\nMicrosoft.AspNetCore.Components.Forms.InputRadio<TValue>.Element.set -> void\nMicrosoft.AspNetCore.Components.Forms.InputRadio<TValue>.InputRadio() -> void\nMicrosoft.AspNetCore.Components.Forms.InputRadio<TValue>.Name.get -> string?\nMicrosoft.AspNetCore.Components.Forms.InputRadio<TValue>.Name.set -> void\nMicrosoft.AspNetCore.Components.Forms.InputRadio<TValue>.Value.get -> TValue?\nMicrosoft.AspNetCore.Components.Forms.InputRadio<TValue>.Value.set -> void\nMicrosoft.AspNetCore.Components.Forms.InputRadioGroup<TValue>\nMicrosoft.AspNetCore.Components.Forms.InputRadioGroup<TValue>.ChildContent.get -> Microsoft.AspNetCore.Components.RenderFragment?\nMicrosoft.AspNetCore.Components.Forms.InputRadioGroup<TValue>.ChildContent.set -> void\nMicrosoft.AspNetCore.Components.Forms.InputRadioGroup<TValue>.InputRadioGroup() -> void\nMicrosoft.AspNetCore.Components.Forms.InputRadioGroup<TValue>.Name.get -> string?\nMicrosoft.AspNetCore.Components.Forms.InputRadioGroup<TValue>.Name.set -> void\n```\n\n----------------------------------------\n\nTITLE: Health Check Service Abstract Method Definition in C#\nDESCRIPTION: Abstract method definition for CheckHealthAsync in the HealthCheckService class, which executes health checks based on an optional predicate filter and cancellation token.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HealthChecks/HealthChecks/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckService.CheckHealthAsync(System.Func<Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration!, bool>? predicate, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<Microsoft.Extensions.Diagnostics.HealthChecks.HealthReport!>!\n```\n\n----------------------------------------\n\nTITLE: Handling Implicit Body Not Provided in C#\nDESCRIPTION: This method handles cases where an implicit body is inferred for a parameter but no body is provided. It throws a BadHttpRequestException or logs the issue.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic void ImplicitBodyNotProvided(string parameterName)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C# for ASP.NET Core\nDESCRIPTION: This directive enables nullable reference type analysis for the entire project or file. It allows the compiler to perform static analysis to detect potential null reference exceptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebView/WebView/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Running Tests in dotnet/aspnetcore with PowerShell\nDESCRIPTION: Commands to run tests for specific projects within the dotnet/aspnetcore repository.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Shared/runtime/ReadMe.SharedCode.md#2025-04-08_snippet_4\n\nLANGUAGE: PowerShell\nCODE:\n```\n(aspnetcore) PS D:\\github\\aspnetcore\\src\\Shared\\test\\Shared.Tests> dotnet test\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\n(aspnetcore) PS D:\\github\\aspnetcore\\src\\servers\\Kestrel\\core\\test> dotnet test\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Authorization Handler Methods in C#\nDESCRIPTION: Abstract method signatures for authorization handlers that process requirements with or without a resource. These methods are implemented by derived classes to handle specific authorization requirements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Authorization.AuthorizationHandler<TRequirement, TResource>.HandleRequirementAsync(Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext! context, TRequirement requirement, TResource resource) -> System.Threading.Tasks.Task!\n```\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Authorization.AuthorizationHandler<TRequirement>.HandleRequirementAsync(Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext! context, TRequirement requirement) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Server-Sent Events Protocol Format Example\nDESCRIPTION: Demonstrates the format of Server-Sent Events (SSE) protocol with multiple events. Shows how keys can be duplicated with values concatenated using newlines, and how events are separated by blank lines.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/TransportProtocols.md#2025-04-08_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nfoo: bar\nbaz: boz\nbaz: biz\nquz: qoz\nbaz: flarg\n\nfoo: boz\n\n\n```\n\n----------------------------------------\n\nTITLE: Running E2E Tests\nDESCRIPTION: Command to run the End-to-End tests for the Blazor components using dotnet test.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/README.md#2025-04-08_snippet_10\n\nLANGUAGE: powershell\nCODE:\n```\ndotnet test ./src/Components/test/E2ETest\n```\n\n----------------------------------------\n\nTITLE: Installing SQL Cache Tool in .NET\nDESCRIPTION: Command to install the dotnet-sql-cache tool globally, which is required for setting up the cache table in SQL Server.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/SqlServer/test/README.md#2025-04-08_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndotnet tool install --global dotnet-sql-cache\n```\n\n----------------------------------------\n\nTITLE: Azure SignalR Server Execution\nDESCRIPTION: Command to run the server using Azure SignalR service with a connection string.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/perf/benchmarkapps/Crankier/Readme.md#2025-04-08_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- server --azure-signalr-connectionstring Endpoint=https://your-url.service.signalr.net;AccessKey=yourAccessKey;Version=1.0;\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: This directive enables nullable reference types for the entire file or project. When enabled, the compiler performs null-state analysis and generates warnings for potential null reference exceptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Html.Abstractions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Request Handling and JSON Response Processing in C#\nDESCRIPTION: Implements core methods for processing HTTP requests and responses, including JSON serialization and error handling. Handles different response types including IResult, string, and JSON objects.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_QueryNotPresent.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Circuit Handler Order in Blazor Server\nDESCRIPTION: Property getter in CircuitHandler that determines the order of execution in the circuit handler pipeline. Handlers with lower Order values are executed before handlers with higher values.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandler.Order.get -> int\n```\n\n----------------------------------------\n\nTITLE: Runtime Helper Methods for Event Binding\nDESCRIPTION: Utility methods for creating event callbacks and bind setters in Blazor components. Provides type inference and async operation support.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.CompilerServices.RuntimeHelpers.CreateInferredEventCallback<T>(object! receiver, Microsoft.AspNetCore.Components.EventCallback<T> callback, T value) -> Microsoft.AspNetCore.Components.EventCallback<T>\nstatic Microsoft.AspNetCore.Components.CompilerServices.RuntimeHelpers.CreateInferredBindSetter<T>(System.Action<T?>! callback, T value) -> System.Func<T, System.Threading.Tasks.Task!>!\n```\n\n----------------------------------------\n\nTITLE: Extending ElementReference with FocusAsync Methods in C#\nDESCRIPTION: Adds extension methods to ElementReference for focusing an element asynchronously, with an option to prevent scrolling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.ElementReferenceExtensions.FocusAsync(this Microsoft.AspNetCore.Components.ElementReference elementReference) -> System.Threading.Tasks.ValueTask\nstatic Microsoft.AspNetCore.Components.ElementReferenceExtensions.FocusAsync(this Microsoft.AspNetCore.Components.ElementReference elementReference, bool preventScroll) -> System.Threading.Tasks.ValueTask\n```\n\n----------------------------------------\n\nTITLE: Interface Definition IAttributeAdapter\nDESCRIPTION: Core interface for validation attribute adapters in ASP.NET Core MVC. Provides contract for getting error messages during validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.DataAnnotations/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.DataAnnotations.IAttributeAdapter.GetErrorMessage(Microsoft.AspNetCore.Mvc.ModelBinding.Validation.ModelValidationContextBase! validationContext) -> string!\n```\n\n----------------------------------------\n\nTITLE: Writing JSON Responses in ASP.NET Core\nDESCRIPTION: This method writes JSON responses using the provided JsonTypeInfo. It handles different runtime types and uses appropriate serialization options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_MultipleStringParam_StringReturn.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Virtual Disposal Method for WebViewManager\nDESCRIPTION: Virtual method for asynchronous disposal of resources that derived WebViewManager classes can override to clean up platform-specific resources.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebView/WebView/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.WebView.WebViewManager.DisposeAsyncCore() -> System.Threading.Tasks.ValueTask\n```\n\n----------------------------------------\n\nTITLE: Authentication Handler Virtual Methods\nDESCRIPTION: Core authentication handler methods for managing authentication events, challenges, and forbidden responses. Includes initialization and event handling functionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authentication.AuthenticationHandler<TOptions>.CreateEventsAsync() -> System.Threading.Tasks.Task<object!>!\n\nvirtual Microsoft.AspNetCore.Authentication.AuthenticationHandler<TOptions>.HandleChallengeAsync(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties) -> System.Threading.Tasks.Task!\n\nvirtual Microsoft.AspNetCore.Authentication.AuthenticationHandler<TOptions>.HandleForbiddenAsync(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Configuring Google Authentication with External Claims in ASP.NET Core\nDESCRIPTION: Key steps to integrate Google authentication with external claims handling: adding Google Plus scope for additional data, mapping gender claim from Google identity, copying claims during user registration, and managing access tokens through SaveTokens functionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/samples/Identity.ExternalClaims/README.md#2025-04-08_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n1. Configure a google OAuth2 project\\n2. Update Startup.cs AddGoogle()'s options with ClientId and ClientSecret\\n3. Run the app and click on MyClaims tab\\n4. Login via Google button\\n5. Redirects to /Home/MyClaims to output user claims\n```\n\n----------------------------------------\n\nTITLE: FormActionTagHelper Class Signatures in ASP.NET Core MVC\nDESCRIPTION: API signatures for the FormActionTagHelper class which handles form submission destinations in ASP.NET Core MVC. The helper provides properties for specifying controllers, routes, pages, and fragments for form actions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.TagHelpers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormActionTagHelper.Controller.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormActionTagHelper.FormActionTagHelper(Microsoft.AspNetCore.Mvc.Routing.IUrlHelperFactory urlHelperFactory) -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormActionTagHelper.Fragment.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormActionTagHelper.Fragment.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormActionTagHelper.Page.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormActionTagHelper.Page.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormActionTagHelper.PageHandler.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormActionTagHelper.PageHandler.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormActionTagHelper.Route.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormActionTagHelper.Route.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormActionTagHelper.RouteValues.get -> System.Collections.Generic.IDictionary<string, string>\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormActionTagHelper.RouteValues.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormActionTagHelper.UrlHelperFactory.get -> Microsoft.AspNetCore.Mvc.Routing.IUrlHelperFactory\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormActionTagHelper.ViewContext.get -> Microsoft.AspNetCore.Mvc.Rendering.ViewContext\n~Microsoft.AspNetCore.Mvc.TagHelpers.FormActionTagHelper.ViewContext.set -> void\n```\n\n----------------------------------------\n\nTITLE: Bidirectional WebTransport Stream Example in C#\nDESCRIPTION: This example demonstrates waiting for a bidirectional stream, reading data from it, reversing the data, and writing it back to the stream. It includes WebTransport session setup and stream management.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/WebTransport.md#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.WebHost.ConfigureKestrel((context, options) =>\n{\n    // Port configured for WebTransport\n    options.Listen(IPAddress.Any, 5007, listenOptions =>\n    {\n        listenOptions.UseHttps(GenerateManualCertificate());\n        listenOptions.UseConnectionLogging();\n        listenOptions.Protocols = HttpProtocols.Http1AndHttp2AndHttp3;\n    });\n});\nvar host = builder.Build();\n\nhost.Run(async (context) =>\n{\n    var feature = context.Features.GetRequiredFeature<IHttpWebTransportFeature>();\n    if (!feature.IsWebTransportRequest)\n    {\n        return;\n    }\n    var session = await feature.AcceptAsync(CancellationToken.None);\n\n    ConnectionContext? stream = null;\n    IStreamDirectionFeature? direction = null;\n    while (true)\n    {\n        // wait until we get a stream\n        stream = await session.AcceptStreamAsync(CancellationToken.None);\n        if (stream is not null)\n        {\n\n            // check that the stream is bidirectional. If yes, keep going, otherwise\n            // dispose its resources and keep waiting.\n            direction = stream.Features.GetRequiredFeature<IStreamDirectionFeature>();\n            if (direction.CanRead && direction.CanWrite)\n            {\n                break;\n            }\n            else\n            {\n                await stream.DisposeAsync();\n            }\n        }\n        else\n        {\n            // if a stream is null, this means that the session failed to get the next one.\n            // Thus, the session has ended or some other issue has occurred. We end the\n            // connection in this case.\n            return;\n        }\n    }\n\n    var inputPipe = stream!.Transport.Input;\n    var outputPipe = stream!.Transport.Output;\n\n    // read some data from the stream into the memory\n    var length = await inputPipe.AsStream().ReadAsync(memory);\n\n    // slice to only keep the relevant parts of the memory\n    var outputMemory = memory[..length];\n\n    // do some operations on the contents of the data\n    outputMemory.Span.Reverse();\n\n    // write back the data to the stream\n    await outputPipe.WriteAsync(outputMemory);\n});\n\nawait host.RunAsync();\n```\n\n----------------------------------------\n\nTITLE: PageModel Route Redirection Methods\nDESCRIPTION: Methods for handling permanent and preserve-method route redirections with optional route names, values and fragments.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.RedirectToRoutePermanent(string? routeName) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.RedirectToRoutePermanent(string? routeName, object? routeValues) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.RedirectToRoutePermanent(string? routeName, object? routeValues, string? fragment) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.RedirectToRoutePermanent(string? routeName, string? fragment) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.RedirectToRoutePermanentPreserveMethod(string? routeName = null, object? routeValues = null, string? fragment = null) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.RedirectToRoutePreserveMethod(string? routeName = null, object? routeValues = null, string? fragment = null) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\n```\n\n----------------------------------------\n\nTITLE: Handling Unsupported Media Types in Form Body Model Binding (C#)\nDESCRIPTION: This snippet handles cases where an unsupported media type is encountered during form body model binding. It throws a BadHttpRequestException or logs the error depending on configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsSameInterceptorsFromDifferentFiles.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nvar message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\nthrow new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n\nif (_rdgLogger != null)\n{\n    _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n}\n\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in ASP.NET Core\nDESCRIPTION: Method for processing invalid form request bodies. It handles cases where the framework fails to bind form data to a parameter, either throwing an exception with details or logging the failure.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitBodyParam_ComplexReturn_Snapshot.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IUserIdProvider Interface in ASP.NET Core SignalR\nDESCRIPTION: Interface for providing user ID extraction from a hub connection context, allowing applications to customize how user identities are determined for SignalR connections.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.IUserIdProvider\nMicrosoft.AspNetCore.SignalR.IUserIdProvider.GetUserId(Microsoft.AspNetCore.SignalR.HubConnectionContext! connection) -> string?\n```\n\n----------------------------------------\n\nTITLE: Abstract Method for Attaching Root Component to Browser DOM\nDESCRIPTION: Abstract method in WebRenderer for attaching a Blazor component to a DOM element in the browser. Takes a component ID and DOM element selector as parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Components.RenderTree.WebRenderer.AttachRootComponentToBrowser(int componentId, string! domElementSelector) -> void\n```\n\n----------------------------------------\n\nTITLE: OpenID Connect Default Constants and Properties\nDESCRIPTION: Static readonly string constants used in OpenID Connect authentication, including keys for challenge properties, authentication properties, and other default values used throughout the authentication flow.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectChallengeProperties.MaxAgeKey -> string!\nstatic readonly Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectChallengeProperties.PromptKey -> string!\nstatic readonly Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectDefaults.AuthenticationPropertiesKey -> string!\nstatic readonly Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectDefaults.CookieNoncePrefix -> string!\nstatic readonly Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectDefaults.DisplayName -> string!\nstatic readonly Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectDefaults.RedirectUriForCodePropertiesKey -> string!\nstatic readonly Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectDefaults.UserstatePropertiesKey -> string!\n```\n\n----------------------------------------\n\nTITLE: Configuring MVC Middleware\nDESCRIPTION: Adds MVC middleware to the application pipeline with default routing configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Tools/Microsoft.dotnet-openapi/test/TestContent/Startup.cs.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\napp.UseMvcWithDefaultRoute();\n```\n\n----------------------------------------\n\nTITLE: Setting environment variables for ASP.NET Core template generation\nDESCRIPTION: This snippet shows how to set the necessary environment variables for generating ASP.NET Core templates. It updates the PATH and sets the DOTNET_ROOT variable.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/ProjectTemplates/README-BASELINES.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\nset PATH=c:\\git\\dotnet\\aspnetcore\\.dotnet\\;%PATH%\n```\n\nLANGUAGE: powershell\nCODE:\n```\nset DOTNET_ROOT=c:\\git\\dotnet\\aspnetcore\\.dotnet\n```\n\n----------------------------------------\n\nTITLE: Helix Timeout Configuration in XML\nDESCRIPTION: XML configuration setting the default timeout value for Helix test jobs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/ProjectTemplates/README.md#2025-04-08_snippet_2\n\nLANGUAGE: XML\nCODE:\n```\n<HelixTimeout>00:45:00</HelixTimeout>\n```\n\n----------------------------------------\n\nTITLE: Cookie Policy Middleware Implementation\nDESCRIPTION: The middleware class that enforces cookie policies in the ASP.NET Core request pipeline. It intercepts cookie operations and applies configured policies regarding HttpOnly, Secure flags, and consent requirements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/CookiePolicy/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.CookiePolicy.CookiePolicyMiddleware\nMicrosoft.AspNetCore.CookiePolicy.CookiePolicyMiddleware.CookiePolicyMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Builder.CookiePolicyOptions!>! options) -> void\nMicrosoft.AspNetCore.CookiePolicy.CookiePolicyMiddleware.CookiePolicyMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Builder.CookiePolicyOptions!>! options, Microsoft.Extensions.Logging.ILoggerFactory! factory) -> void\nMicrosoft.AspNetCore.CookiePolicy.CookiePolicyMiddleware.Invoke(Microsoft.AspNetCore.Http.HttpContext! context) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.CookiePolicy.CookiePolicyMiddleware.Options.get -> Microsoft.AspNetCore.Builder.CookiePolicyOptions!\nMicrosoft.AspNetCore.CookiePolicy.CookiePolicyMiddleware.Options.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining OpenAPI Schema Definitions in ASP.NET Core\nDESCRIPTION: A comprehensive OpenAPI specification that defines API endpoints and data models for an ASP.NET Core application. It includes object schemas with inheritance, polymorphic discrimination, references between objects, and various data types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/test/Microsoft.AspNetCore.OpenApi.Tests/Integration/snapshots/OpenApi3_1/OpenApiDocumentIntegrationTests.VerifyOpenApiDocument_documentName=schemas-by-ref.verified.txt#2025-04-08_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"components\": {\n    \"schemas\": {\n      \"Account\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\"\n          },\n          \"name\": {\n            \"type\": \"string\"\n          }\n        }\n      },\n      \"AddressDto\": {\n        \"required\": [\n          \"relatedLocation\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"relatedLocation\": {\n            \"$ref\": \"#/components/schemas/LocationDto\"\n          }\n        }\n      },\n      \"Category\": {\n        \"required\": [\n          \"name\",\n          \"parent\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\"\n          },\n          \"parent\": {\n            \"$ref\": \"#/components/schemas/Category\"\n          },\n          \"tags\": { }\n        }\n      },\n      \"ChildObject\": {\n        \"required\": [\n          \"parent\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\"\n          },\n          \"parent\": {\n            \"$ref\": \"#/components/schemas/ParentObject\"\n          }\n        }\n      },\n      \"ContainerType\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"seq1\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"string\"\n              }\n            }\n          },\n          \"seq2\": {\n            \"type\": \"array\",\n            \"items\": { }\n          }\n        }\n      },\n      \"Item\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": { },\n          \"value\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\"\n          }\n        }\n      },\n      \"LocationContainer\": {\n        \"required\": [\n          \"location\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"location\": {\n            \"$ref\": \"#/components/schemas/LocationDto\"\n          }\n        }\n      },\n      \"LocationDto\": {\n        \"required\": [\n          \"address\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"address\": {\n            \"$ref\": \"#/components/schemas/AddressDto\"\n          }\n        }\n      },\n      \"ParentObject\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\"\n          },\n          \"children\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/ChildObject\"\n            }\n          }\n        }\n      },\n      \"Person\": {\n        \"required\": [\n          \"discriminator\"\n        ],\n        \"type\": \"object\",\n        \"anyOf\": [\n          {\n            \"$ref\": \"#/components/schemas/PersonStudent\"\n          },\n          {\n            \"$ref\": \"#/components/schemas/PersonTeacher\"\n          }\n        ],\n        \"discriminator\": {\n          \"propertyName\": \"discriminator\",\n          \"mapping\": {\n            \"student\": \"#/components/schemas/PersonStudent\",\n            \"teacher\": \"#/components/schemas/PersonTeacher\"\n          }\n        }\n      },\n      \"PersonStudent\": {\n        \"properties\": {\n          \"discriminator\": {\n            \"enum\": [\n              \"student\"\n            ],\n            \"type\": \"string\"\n          },\n          \"gpa\": {\n            \"type\": \"number\",\n            \"format\": \"double\"\n          }\n        }\n      },\n      \"PersonTeacher\": {\n        \"required\": [\n          \"subject\"\n        ],\n        \"properties\": {\n          \"discriminator\": {\n            \"enum\": [\n              \"teacher\"\n            ],\n            \"type\": \"string\"\n          },\n          \"subject\": {\n            \"type\": \"string\"\n          }\n        }\n      },\n      \"Product\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\"\n          },\n          \"name\": {\n            \"type\": \"string\"\n          }\n        }\n      },\n      \"Root\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"item1\": {\n            \"$ref\": \"#/components/schemas/Item\"\n          },\n          \"item2\": {\n            \"$ref\": \"#/components/schemas/Item\"\n          }\n        }\n      },\n      \"Shape\": {\n        \"required\": [\n          \"$type\"\n        ],\n        \"type\": \"object\",\n        \"anyOf\": [\n          {\n            \"$ref\": \"#/components/schemas/ShapeTriangle\"\n          },\n          {\n            \"$ref\": \"#/components/schemas/ShapeSquare\"\n          }\n        ],\n        \"discriminator\": {\n          \"propertyName\": \"$type\",\n          \"mapping\": {\n            \"triangle\": \"#/components/schemas/ShapeTriangle\",\n            \"square\": \"#/components/schemas/ShapeSquare\"\n          }\n        }\n      },\n      \"ShapeSquare\": {\n        \"properties\": {\n          \"$type\": {\n            \"enum\": [\n              \"square\"\n            ],\n            \"type\": \"string\"\n          },\n          \"area\": {\n            \"type\": \"number\",\n            \"format\": \"double\"\n          },\n          \"color\": {\n            \"type\": \"string\"\n          },\n          \"sides\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\"\n          }\n        }\n      },\n      \"ShapeTriangle\": {\n        \"properties\": {\n          \"$type\": {\n            \"enum\": [\n              \"triangle\"\n            ],\n            \"type\": \"string\"\n          },\n          \"hypotenuse\": {\n            \"type\": \"number\",\n            \"format\": \"double\"\n          },\n          \"color\": {\n            \"type\": \"string\"\n          },\n          \"sides\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\"\n          }\n        }\n      },\n      \"Tag\": {\n        \"required\": [\n          \"name\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\"\n          }\n        }\n      },\n      \"Triangle\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"hypotenuse\": {\n            \"type\": \"number\",\n            \"format\": \"double\"\n          },\n          \"color\": {\n            \"type\": \"string\"\n          },\n          \"sides\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\"\n          }\n        }\n      },\n      \"WeatherForecastBase\": {\n        \"required\": [\n          \"$type\"\n        ],\n        \"type\": \"object\",\n        \"anyOf\": [\n          {\n            \"$ref\": \"#/components/schemas/WeatherForecastBaseWeatherForecastWithCity\"\n          },\n          {\n            \"$ref\": \"#/components/schemas/WeatherForecastBaseWeatherForecastWithTimeSeries\"\n          },\n          {\n            \"$ref\": \"#/components/schemas/WeatherForecastBaseWeatherForecastWithLocalNews\"\n          }\n        ],\n        \"discriminator\": {\n          \"propertyName\": \"$type\",\n          \"mapping\": {\n            \"0\": \"#/components/schemas/WeatherForecastBaseWeatherForecastWithCity\",\n            \"1\": \"#/components/schemas/WeatherForecastBaseWeatherForecastWithTimeSeries\",\n            \"2\": \"#/components/schemas/WeatherForecastBaseWeatherForecastWithLocalNews\"\n          }\n        }\n      },\n      \"WeatherForecastBaseWeatherForecastWithCity\": {\n        \"required\": [\n          \"city\"\n        ],\n        \"properties\": {\n          \"$type\": {\n            \"enum\": [\n              0\n            ],\n            \"type\": \"integer\"\n          },\n          \"city\": {\n            \"type\": \"string\"\n          }\n        }\n      },\n      \"WeatherForecastBaseWeatherForecastWithLocalNews\": {\n        \"required\": [\n          \"news\"\n        ],\n        \"properties\": {\n          \"$type\": {\n            \"enum\": [\n              2\n            ],\n            \"type\": \"integer\"\n          },\n          \"news\": {\n            \"type\": \"string\"\n          }\n        }\n      },\n      \"WeatherForecastBaseWeatherForecastWithTimeSeries\": {\n        \"required\": [\n          \"summary\"\n        ],\n        \"properties\": {\n          \"$type\": {\n            \"enum\": [\n              1\n            ],\n            \"type\": \"integer\"\n          },\n          \"date\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          },\n          \"temperatureC\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\"\n          },\n          \"summary\": {\n            \"type\": \"string\"\n          }\n        }\n      }\n    }\n  },\n  \"tags\": [\n    {\n      \"name\": \"Sample\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Extending IJSComponentConfiguration with RegisterForJavaScript Methods in C#\nDESCRIPTION: Adds extension methods to IJSComponentConfiguration for registering components for JavaScript interop.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.Web.JSComponentConfigurationExtensions.RegisterForJavaScript(this Microsoft.AspNetCore.Components.Web.IJSComponentConfiguration! configuration, System.Type! componentType, string! identifier) -> void\nstatic Microsoft.AspNetCore.Components.Web.JSComponentConfigurationExtensions.RegisterForJavaScript(this Microsoft.AspNetCore.Components.Web.IJSComponentConfiguration! configuration, System.Type! componentType, string! identifier, string! javaScriptInitializer) -> void\nstatic Microsoft.AspNetCore.Components.Web.JSComponentConfigurationExtensions.RegisterForJavaScript<TComponent>(this Microsoft.AspNetCore.Components.Web.IJSComponentConfiguration! configuration, string! identifier) -> void\nstatic Microsoft.AspNetCore.Components.Web.JSComponentConfigurationExtensions.RegisterForJavaScript<TComponent>(this Microsoft.AspNetCore.Components.Web.IJSComponentConfiguration! configuration, string! identifier, string! javaScriptInitializer) -> void\n```\n\n----------------------------------------\n\nTITLE: Declaring IISServerOptions Class in C#\nDESCRIPTION: This class defines configuration options for IIS Server in ASP.NET Core, including properties for authentication, request body size, and synchronous I/O.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/IIS/IIS/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Builder.IISServerOptions\nMicrosoft.AspNetCore.Builder.IISServerOptions.AllowSynchronousIO.get -> bool\nMicrosoft.AspNetCore.Builder.IISServerOptions.AllowSynchronousIO.set -> void\nMicrosoft.AspNetCore.Builder.IISServerOptions.AuthenticationDisplayName.get -> string?\nMicrosoft.AspNetCore.Builder.IISServerOptions.AuthenticationDisplayName.set -> void\nMicrosoft.AspNetCore.Builder.IISServerOptions.AutomaticAuthentication.get -> bool\nMicrosoft.AspNetCore.Builder.IISServerOptions.AutomaticAuthentication.set -> void\nMicrosoft.AspNetCore.Builder.IISServerOptions.IISServerOptions() -> void\nMicrosoft.AspNetCore.Builder.IISServerOptions.MaxRequestBodyBufferSize.get -> int\nMicrosoft.AspNetCore.Builder.IISServerOptions.MaxRequestBodyBufferSize.set -> void\nMicrosoft.AspNetCore.Builder.IISServerOptions.MaxRequestBodySize.get -> long?\nMicrosoft.AspNetCore.Builder.IISServerOptions.MaxRequestBodySize.set -> void\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants for ASP.NET Core Request Handling\nDESCRIPTION: Defines constants for common content types used in HTTP requests and responses. These constants are used for content negotiation and request validation throughout the framework.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Post_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining OAuthOptions class in C# for ASP.NET Core\nDESCRIPTION: This snippet defines the OAuthOptions class, which inherits from RemoteAuthenticationOptions. It includes properties specific to OAuth configuration such as ClientId, ClientSecret, AuthorizationEndpoint, and TokenEndpoint.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/JwtBearer/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n/// <summary>\n/// Configuration options for <see cref=\"OAuthHandler{T}\"/>.\n/// </summary>\n/// <typeparam name=\"TOptions\">The type of the options instance.</typeparam>\npublic class OAuthOptions<TOptions> : RemoteAuthenticationOptions where TOptions : OAuthOptions<TOptions>, new()\n{\n    /// <summary>\n    /// Gets or sets the provider-assigned client id.\n    /// </summary>\n    public string? ClientId { get; set; }\n\n    /// <summary>\n    /// Gets or sets the provider-assigned client secret.\n    /// </summary>\n    public string? ClientSecret { get; set; }\n\n    /// <summary>\n    /// Gets or sets the URI where the client will be redirected to authenticate.\n    /// </summary>\n    public string? AuthorizationEndpoint { get; set; }\n\n    /// <summary>\n    /// Gets or sets the URI the middleware will access to exchange the OAuth token.\n    /// </summary>\n    public string? TokenEndpoint { get; set; }\n\n    /// <summary>\n    /// Gets or sets the URI the middleware will access to obtain the user information.\n    /// </summary>\n    public string? UserInformationEndpoint { get; set; }\n\n    /// <summary>\n    /// Gets or sets the URI the middleware will use as the callback path.\n    /// </summary>\n    public PathString CallbackPath { get; set; }\n\n    /// <summary>\n    /// Gets the sets of OAuth endpoints used to authenticate against the provider.\n    /// </summary>\n    public OAuthChallengeProperties AuthenticationProperties { get; } = new OAuthChallengeProperties();\n\n    /// <summary>\n    /// Gets or sets the <see cref=\"OAuthScope\"/>s used to authenticate against the provider.\n    /// </summary>\n    public ICollection<string> Scope { get; } = new HashSet<string>(StringComparer.Ordinal);\n\n    /// <summary>\n    /// Gets or sets the list of permissions to request.\n    /// </summary>\n    public ICollection<string> Permissions { get; } = new HashSet<string>(StringComparer.Ordinal);\n\n    /// <summary>\n    /// Gets or sets the name of the parameter used to append scope values to authorize request.\n    /// </summary>\n    public string ScopeSeparator { get; set; } = OAuthConstants.ScopeSeparator;\n\n    /// <summary>\n    /// Gets or sets a value indicating whether HTTPS is required for the metadata address or authority.\n    /// The default is true. This should be disabled only in development environments.\n    /// </summary>\n    public bool RequireHttpsMetadata { get; set; } = true;\n\n    /// <summary>\n    /// Enables the retrieval of user claims from the UserInformationEndpoint.\n    /// </summary>\n    public bool RetrieveUserDetails { get; set; } = true;\n\n    /// <summary>\n    /// Gets or sets if PKCE should be used.\n    /// </summary>\n    public bool UsePkce { get; set; } = false;\n\n    /// <summary>\n    /// Initializes a new <see cref=\"OAuthOptions{TOptions}\"/>.\n    /// </summary>\n    protected OAuthOptions()\n    {\n        OptionsType = typeof(TOptions);\n    }\n\n    /// <summary>\n    /// Builds a challenge URL that will be used to challenge the user.\n    /// </summary>\n    /// <param name=\"properties\">Additional authentication properties.</param>\n    /// <param name=\"redirectUri\">The redirect URI to use for the challenge.</param>\n    /// <returns>The challenge URL.</returns>\n    public virtual string BuildChallengeUrl(AuthenticationProperties? properties, string redirectUri)\n    {\n        var parameters = AuthenticationProperties.BuildChallengeUrl(properties);\n\n        parameters.Add(OAuthConstants.RedirectUri, redirectUri);\n\n        var scope = properties?.GetParameter<ICollection<string>>(OAuthConstants.ScopeKey) ?? Scope;\n        if (scope.Count > 0)\n        {\n            parameters[OAuthConstants.Scope] = string.Join(ScopeSeparator, scope);\n        }\n\n        var permissions = properties?.GetParameter<ICollection<string>>(OAuthConstants.PermissionsKey) ?? Permissions;\n        if (permissions.Count > 0)\n        {\n            parameters[OAuthConstants.Permissions] = string.Join(\",\", permissions);\n        }\n\n        return QueryHelpers.AddQueryString(AuthorizationEndpoint!, parameters!);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GrpcJsonTranscodingMetadata Class in C#\nDESCRIPTION: Class that holds metadata for gRPC JSON transcoding, containing method descriptor and HTTP rule information for transcoding configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Grpc/JsonTranscoding/src/Microsoft.AspNetCore.Grpc.JsonTranscoding/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class GrpcJsonTranscodingMetadata\n{\n    public GrpcJsonTranscodingMetadata(Google.Protobuf.Reflection.MethodDescriptor methodDescriptor, Google.Api.HttpRule httpRule)\n    public Google.Api.HttpRule HttpRule { get; }\n    public Google.Protobuf.Reflection.MethodDescriptor MethodDescriptor { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Example SQL Server Connection String\nDESCRIPTION: Sample connection string for connecting to a LocalDB instance with the CacheTestDb database using Windows authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/SqlServer/test/README.md#2025-04-08_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n\"Server=(localdb)\\MSSQLLocalDB;Database=CacheTestDb;Trusted_Connection=True;\"\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Disposal of SignalR HubConnection in C#\nDESCRIPTION: Implements the DisposeAsync method for HubConnection, allowing for asynchronous cleanup of resources when the connection is no longer needed.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.SignalR.Client.HubConnection.DisposeAsync() -> System.Threading.Tasks.ValueTask\n```\n\n----------------------------------------\n\nTITLE: Writing Handshake Request Message in SignalR Protocol\nDESCRIPTION: Static method to write a HandshakeRequestMessage to an IBufferWriter<byte> output in the SignalR protocol.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.WriteRequestMessage(Microsoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage! requestMessage, System.Buffers.IBufferWriter<byte>! output) -> void\n```\n\n----------------------------------------\n\nTITLE: Extending IBrowserFile with RequestImageFileAsync Method in C#\nDESCRIPTION: Adds an extension method to IBrowserFile for requesting an image file with specified format, max width, and max height.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.Forms.BrowserFileExtensions.RequestImageFileAsync(this Microsoft.AspNetCore.Components.Forms.IBrowserFile! browserFile, string! format, int maxWidth, int maxHeight) -> System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Components.Forms.IBrowserFile!>\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected JSON Content Type in ASP.NET Core (C#)\nDESCRIPTION: This method handles cases where an unexpected JSON content type is received. It can throw an exception or log the error based on configuration. It takes the content type as input.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Post_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedJsonContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft.AspNetCore.OpenApi Package Using .NET CLI\nDESCRIPTION: Command to install the Microsoft.AspNetCore.OpenApi NuGet package using the .NET CLI. This is the first step to add OpenAPI document generation capabilities to an ASP.NET Core application.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.OpenApi\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in ASP.NET Core (C#)\nDESCRIPTION: This method handles cases where reading a parameter from the request body as a form fails. It can throw an exception or log the error based on configuration. It takes the parameter type, name, and the exception as inputs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Post_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Identity Provider Resolver in ASP.NET Core\nDESCRIPTION: This snippet defines a custom IdentityProviderResolver class that implements IIdentityProviderResolver. It demonstrates how to resolve the identity provider based on the OpenIdConnectMessage and HttpContext.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PublicAPI/net462/PublicAPI.Unshipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class CustomIdentityProviderResolver : IIdentityProviderResolver\n{\n    public string? Resolve(OpenIdConnectMessage message, HttpContext context)\n    {\n        // Custom logic to determine the identity provider\n        return \"https://login.microsoftonline.com/tenantId/v2.0\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Bash Command to Generate Required Files\nDESCRIPTION: This Bash command generates required files before building projects without using build.cmd or build.sh. It skips building managed components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/BuildErrors.md#2025-04-08_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh --no-build-managed\n```\n\n----------------------------------------\n\nTITLE: Handling Parameter Binding Failure in ASP.NET Core\nDESCRIPTION: This method handles cases where parameter binding fails. It either throws a BadHttpRequestException or logs the failure, depending on the configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Benchmark from Directory of Swagger Files in C#\nDESCRIPTION: This command uses the Swaggatherer CLI tool to generate a benchmark from a directory containing multiple Swagger JSON files. It recursively searches for .json files in the specified directory and generates a single benchmark output file.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/tools/Swaggatherer/README.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ndotnet run -- -d /some/directory -o MyGeneratedBenchark.generated.cs\n```\n\n----------------------------------------\n\nTITLE: Fixing Nested Type Warning Formatting in XML\nDESCRIPTION: Example of manual formatting fix needed for compiler-generated nested types in warning suppression files, replacing braces with angle brackets.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Trimming.md#2025-04-08_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n- LegacyRouteTableFactory.&lt;&gt;c.{Create}b__2_1(System.Reflection.Assembly)\n+ LegacyRouteTableFactory.&lt;&gt;c.&lt;Create&gt;b__2_1(System.Reflection.Assembly)\n```\n\n----------------------------------------\n\nTITLE: Action Filter Event Data Classes in C#\nDESCRIPTION: Defines event data classes for monitoring action filter execution including BeforeActionFilterOnActionExecuted, BeforeActionFilterOnActionExecuting, and BeforeActionFilterOnActionExecution events\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Diagnostics.BeforeActionFilterOnActionExecutedEventData.BeforeActionFilterOnActionExecutedEventData(Microsoft.AspNetCore.Mvc.Abstractions.ActionDescriptor! actionDescriptor, Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext! actionExecutedContext, Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata! filter) -> void\nMicrosoft.AspNetCore.Mvc.Diagnostics.BeforeActionFilterOnActionExecutedEventData.Filter.get -> Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata!\n```\n\n----------------------------------------\n\nTITLE: Delete Cookie Context for Cookie Operations\nDESCRIPTION: Context class used during cookie delete operations, providing access to the current HttpContext, cookie options, and consent information. Used by the OnDeleteCookie callback in CookiePolicyOptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/CookiePolicy/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.CookiePolicy.DeleteCookieContext\nMicrosoft.AspNetCore.CookiePolicy.DeleteCookieContext.Context.get -> Microsoft.AspNetCore.Http.HttpContext!\nMicrosoft.AspNetCore.CookiePolicy.DeleteCookieContext.CookieName.get -> string!\nMicrosoft.AspNetCore.CookiePolicy.DeleteCookieContext.CookieName.set -> void\nMicrosoft.AspNetCore.CookiePolicy.DeleteCookieContext.CookieOptions.get -> Microsoft.AspNetCore.Http.CookieOptions!\nMicrosoft.AspNetCore.CookiePolicy.DeleteCookieContext.DeleteCookieContext(Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Http.CookieOptions! options, string! name) -> void\nMicrosoft.AspNetCore.CookiePolicy.DeleteCookieContext.HasConsent.get -> bool\nMicrosoft.AspNetCore.CookiePolicy.DeleteCookieContext.IsConsentNeeded.get -> bool\nMicrosoft.AspNetCore.CookiePolicy.DeleteCookieContext.IssueCookie.get -> bool\nMicrosoft.AspNetCore.CookiePolicy.DeleteCookieContext.IssueCookie.set -> void\n```\n\n----------------------------------------\n\nTITLE: Using FileContentResult in ASP.NET Core Controllers\nDESCRIPTION: Shows how to return file content through the File method on controllers by using FileContentResult in an ASP.NET Core application.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/test/WebSites/FilesWebSite/readme.md#2025-04-08_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nThis web site illustrates how to use `FileContentResult` via `File` method on the controller. It also demonstrates\nhow to write and register a custom `FileSender` middleware.\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet12 Method for ASP.NET Core Endpoint Routing\nDESCRIPTION: This method registers a GET endpoint with parameter binding using BindAsync for implicit static abstract interfaces. It creates a request delegate that handles parameter validation, endpoint filtering, and response formatting.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet12(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"httpContext\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"myBindAsyncParam\", parameters[1], hasTryParse: false, hasBindAsync: true, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n        Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n        var handler = Cast(del, global::System.String (global::Microsoft.AspNetCore.Http.HttpContext arg0, global::Microsoft.AspNetCore.Http.Generators.Tests.BindAsyncFromImplicitStaticAbstractInterface arg1) => throw null!);\n        EndpointFilterDelegate? filteredInvocation = null;\n        var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n        var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n        var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n        var jsonSerializerOptions = jsonOptions.SerializerOptions;\n        jsonSerializerOptions.MakeReadOnly();\n        var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n        var parameters = del.Method.GetParameters();\n\n        if (options.EndpointBuilder.FilterFactories.Count > 0)\n        {\n            filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n            {\n                if (ic.HttpContext.Response.StatusCode == 400)\n                {\n                    return ValueTask.FromResult<object?>(Results.Empty);\n                }\n                return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.HttpContext>(0)!, ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.BindAsyncFromImplicitStaticAbstractInterface>(1)!));\n            },\n            options.EndpointBuilder,\n            handler.Method);\n        }\n\n        async Task RequestHandler(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            var httpContext_local = httpContext;\n            var myBindAsyncParam_local = await BindAsync<global::Microsoft.AspNetCore.Http.Generators.Tests.BindAsyncFromImplicitStaticAbstractInterface>(httpContext, parameters[1]);\n            if (myBindAsyncParam_local == null)\n            {\n                logOrThrowExceptionHelper.RequiredParameterNotProvided(\"BindAsyncFromImplicitStaticAbstractInterface\", \"myBindAsyncParam\", \"BindAsyncFromImplicitStaticAbstractInterface.BindAsync(HttpContext, ParameterInfo)\");\n                wasParamCheckFailure = true;\n                myBindAsyncParam_local = default!;\n            }\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n                return;\n            }\n            var result = handler(httpContext_local, myBindAsyncParam_local);\n            if (result is string)\n            {\n                httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n            }\n            else\n            {\n                httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n            }\n            await httpContext.Response.WriteAsync(result);\n        }\n\n        async Task RequestHandlerFiltered(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            var httpContext_local = httpContext;\n            var myBindAsyncParam_local = await BindAsync<global::Microsoft.AspNetCore.Http.Generators.Tests.BindAsyncFromImplicitStaticAbstractInterface>(httpContext, parameters[1]);\n            if (myBindAsyncParam_local == null)\n            {\n                logOrThrowExceptionHelper.RequiredParameterNotProvided(\"BindAsyncFromImplicitStaticAbstractInterface\", \"myBindAsyncParam\", \"BindAsyncFromImplicitStaticAbstractInterface.BindAsync(HttpContext, ParameterInfo)\");\n                wasParamCheckFailure = true;\n                myBindAsyncParam_local = default!;\n            }\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n            }\n            var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.HttpContext, global::Microsoft.AspNetCore.Http.Generators.Tests.BindAsyncFromImplicitStaticAbstractInterface>(httpContext, httpContext_local, myBindAsyncParam_local));\n            if (result is not null)\n            {\n                await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n            }\n        }\n\n        RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\n        var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\n        return new RequestDelegateResult(targetDelegate, metadata);\n    };\n    var castHandler = Cast(handler, global::System.String (global::Microsoft.AspNetCore.Http.HttpContext arg0, global::Microsoft.AspNetCore.Http.Generators.Tests.BindAsyncFromImplicitStaticAbstractInterface arg1) => throw null!);\n    return MapCore(\n        endpoints,\n        pattern,\n        handler,\n        GetVerb,\n        populateMetadata,\n        createRequestDelegate,\n        castHandler.Method);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IStreamAbortFeature Interface in C#\nDESCRIPTION: This snippet defines the IStreamAbortFeature interface with a method to abort writing to a stream with an error code and reason.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Connections.Features.IStreamAbortFeature.AbortWrite(long errorCode, Microsoft.AspNetCore.Connections.ConnectionAbortedException! abortReason) -> void\n```\n\n----------------------------------------\n\nTITLE: Helix Test Runner Timeout Log Example\nDESCRIPTION: Example of the timeout message that appears in the test runner log when a test exceeds the configured timeout period.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/ProjectTemplates/README.md#2025-04-08_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n19:54:18.888, 4653892436493, datacollector.dll, The specified inactivity time of 15 minutes has elapsed. Collecting hang dumps from testhost and its child processes\n```\n\n----------------------------------------\n\nTITLE: HttpRequest Virtual Properties in ASP.NET Core\nDESCRIPTION: Defines virtual properties for HTTP request handling including body reading and route value management\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\nvirtual Microsoft.AspNetCore.Http.HttpRequest.BodyReader.get -> System.IO.Pipelines.PipeReader!\nvirtual Microsoft.AspNetCore.Http.HttpRequest.RouteValues.get -> Microsoft.AspNetCore.Routing.RouteValueDictionary!\nvirtual Microsoft.AspNetCore.Http.HttpRequest.RouteValues.set -> void\n```\n\n----------------------------------------\n\nTITLE: Registering Blazor Component as Custom Element\nDESCRIPTION: Extension method for registering a Blazor component as a custom HTML element using a specified identifier. This enables the component to be used as a custom element in HTML markup.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/CustomElements/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nRegisterCustomElement<TComponent>(this Microsoft.AspNetCore.Components.Web.IJSComponentConfiguration! configuration, string! identifier) -> void\n```\n\n----------------------------------------\n\nTITLE: Determining JSON Type Info Compatibility in ASP.NET Core\nDESCRIPTION: Helper method to determine if a JSON type info should be used with a given runtime type. Used during JSON serialization to ensure proper type handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/RequestDelegateValidateGeneratedFormCode.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n```\n\n----------------------------------------\n\nTITLE: Request Delegate Factory Implementation in C#\nDESCRIPTION: Implements the core request delegate generation logic including parameter binding, metadata handling, and request processing. Handles both filtered and unfiltered request scenarios with support for JSON serialization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsDifferentInterceptorsFromSameLocation.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Certificate Authentication Event Handlers in ASP.NET Core\nDESCRIPTION: Virtual event handlers for managing certificate authentication events including validation, failure, and challenge scenarios.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Certificate/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authentication.Certificate.CertificateAuthenticationEvents.AuthenticationFailed(Microsoft.AspNetCore.Authentication.Certificate.CertificateAuthenticationFailedContext! context) -> System.Threading.Tasks.Task!\n\nvirtual Microsoft.AspNetCore.Authentication.Certificate.CertificateAuthenticationEvents.CertificateValidated(Microsoft.AspNetCore.Authentication.Certificate.CertificateValidatedContext! context) -> System.Threading.Tasks.Task!\n\nvirtual Microsoft.AspNetCore.Authentication.Certificate.CertificateAuthenticationEvents.Challenge(Microsoft.AspNetCore.Authentication.Certificate.CertificateChallengeContext! context) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Running Tests for ASP.NET Core Security Components in PowerShell\nDESCRIPTION: Command to run tests for the ASP.NET Core security components. This should be executed inside the security directory of the ASP.NET Core project.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/README.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd -t\n```\n\n----------------------------------------\n\nTITLE: Defining RequestLocalizationServiceCollectionExtensions Methods in C#\nDESCRIPTION: Defines extension methods for IServiceCollection to add request localization services.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.RequestLocalizationServiceCollectionExtensions.AddRequestLocalization(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Builder.RequestLocalizationOptions!>! configureOptions) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.RequestLocalizationServiceCollectionExtensions.AddRequestLocalization<TService>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Builder.RequestLocalizationOptions!, TService!>! configureOptions) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: JSON Response Processing Utilities\nDESCRIPTION: Collection of utility methods for handling JSON serialization and response writing in ASP.NET Core. Includes polymorphism checking and type-safe JSON writing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: ProgressEventArgs Class for ASP.NET Core Blazor Events\nDESCRIPTION: Defines the ProgressEventArgs class for progress events in Blazor. Contains properties for tracking loading progress of resources, including flags for length computability and loaded amount.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Web.ProgressEventArgs\nMicrosoft.AspNetCore.Components.Web.ProgressEventArgs.LengthComputable.get -> bool\nMicrosoft.AspNetCore.Components.Web.ProgressEventArgs.LengthComputable.set -> void\nMicrosoft.AspNetCore.Components.Web.ProgressEventArgs.Loaded.get -> long\n```\n\n----------------------------------------\n\nTITLE: Defining ShowRecoveryCodesModel OnGet Method in ASP.NET Core Identity UI\nDESCRIPTION: Implementation of the OnGet method for the ShowRecoveryCodesModel class, which returns an IActionResult. This method would typically be called when a user navigates to the recovery codes page in the Identity UI.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.UI.V4.Pages.Account.Manage.Internal.ShowRecoveryCodesModel.OnGet() -> Microsoft.AspNetCore.Mvc.IActionResult!\n```\n\n----------------------------------------\n\nTITLE: JSON Type Compatibility Check for Serialization in ASP.NET Core\nDESCRIPTION: Determines if the provided JsonTypeInfo should be used with a given runtime type. It handles null values and checks for type compatibility or known polymorphism.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\n----------------------------------------\n\nTITLE: Defining RemoteUserAccount Class in C#\nDESCRIPTION: Defines the RemoteUserAccount class with properties for storing additional user account information in ASP.NET Core WebAssembly authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount.AdditionalProperties.get -> System.Collections.Generic.IDictionary<string!, object!>!\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount.AdditionalProperties.set -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount.RemoteUserAccount() -> void\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocation Attribute in C#\nDESCRIPTION: Defines a sealed attribute class that can be applied to methods with multiple instances. Used for intercepting method locations in the runtime compiler.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Post_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Redis Options Configuration Class\nDESCRIPTION: Configuration options class for Redis connection settings including connection string and custom connection factory.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/StackExchangeRedis/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class RedisOptions\n{\n    public ConfigurationOptions Configuration { get; set; }\n    public Func<TextWriter, Task<IConnectionMultiplexer>>? ConnectionFactory { get; set; }\n    public RedisOptions() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Authentication Methods\nDESCRIPTION: Virtual methods handling various authentication scenarios including 2FA, recovery codes, and external provider authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Identity.UI.V4.Pages.Account.Internal.LoginWith2faModel.OnGetAsync(bool rememberMe, string? returnUrl = null) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult!>!\nvirtual Microsoft.AspNetCore.Identity.UI.V4.Pages.Account.Internal.LoginWithRecoveryCodeModel.OnGetAsync(string? returnUrl = null) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult!>!\n```\n\n----------------------------------------\n\nTITLE: Running Tests for ASP.NET Core Negotiate Authentication\nDESCRIPTION: Command to run tests for the project from within the parent security directory using PowerShell build script with test flag.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Negotiate/src/README.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd -t\n```\n\n----------------------------------------\n\nTITLE: Running Tests for Twitter Authentication Project in ASP.NET Core using PowerShell\nDESCRIPTION: PowerShell command to run the tests for the Twitter Authentication project from within the parent 'security' directory. The -t flag indicates that tests should be executed after building.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Twitter/src/README.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd -t\n```\n\n----------------------------------------\n\nTITLE: Implementing RedirectHttpResult in ASP.NET Core\nDESCRIPTION: API signatures for the RedirectHttpResult class, which returns a redirect response to the specified URL with options for permanent redirects, local URL validation, and method preservation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.RedirectHttpResult\nMicrosoft.AspNetCore.Http.HttpResults.RedirectHttpResult.AcceptLocalUrlOnly.get -> bool\nMicrosoft.AspNetCore.Http.HttpResults.RedirectHttpResult.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.RedirectHttpResult.Permanent.get -> bool\nMicrosoft.AspNetCore.Http.HttpResults.RedirectHttpResult.PreserveMethod.get -> bool\nMicrosoft.AspNetCore.Http.HttpResults.RedirectHttpResult.Url.get -> string!\n```\n\n----------------------------------------\n\nTITLE: Overriding Validation Component Methods in C#\nDESCRIPTION: Overrides the BuildRenderTree and OnParametersSet methods for ValidationMessage<TValue> and ValidationSummary components in ASP.NET Core Forms.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Components.Forms.ValidationMessage<TValue>.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder! builder) -> void\noverride Microsoft.AspNetCore.Components.Forms.ValidationMessage<TValue>.OnParametersSet() -> void\noverride Microsoft.AspNetCore.Components.Forms.ValidationSummary.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder! builder) -> void\noverride Microsoft.AspNetCore.Components.Forms.ValidationSummary.OnParametersSet() -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring Polly Wait and Retry Policy for HttpClient in C#\nDESCRIPTION: This snippet demonstrates how to add a transient HTTP error policy to an HttpClient using Polly. It configures a wait and retry policy that will retry failed requests up to 3 times with a 600ms delay between attempts.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HttpClientFactory/Polly/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Services.AddHttpClient(\"PollyWaitAndRetry\")\n    .AddTransientHttpErrorPolicy(policyBuilder =>\n        policyBuilder.WaitAndRetryAsync(\n            retryCount: 3,\n            retryNumber => TimeSpan.FromMilliseconds(600)));\n```\n\n----------------------------------------\n\nTITLE: HttpMethods Utility Class in ASP.NET Core\nDESCRIPTION: Utility methods for working with HTTP method names in ASP.NET Core, including method equality checking, canonicalization, and standard method name constants.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.HttpMethods.Equals(string! methodA, string! methodB) -> bool\nstatic Microsoft.AspNetCore.Http.HttpMethods.GetCanonicalizedValue(string! method) -> string!\nstatic Microsoft.AspNetCore.Http.HttpMethods.IsConnect(string! method) -> bool\nstatic Microsoft.AspNetCore.Http.HttpMethods.IsDelete(string! method) -> bool\nstatic Microsoft.AspNetCore.Http.HttpMethods.IsGet(string! method) -> bool\nstatic Microsoft.AspNetCore.Http.HttpMethods.IsHead(string! method) -> bool\nstatic Microsoft.AspNetCore.Http.HttpMethods.IsOptions(string! method) -> bool\nstatic Microsoft.AspNetCore.Http.HttpMethods.IsPatch(string! method) -> bool\nstatic Microsoft.AspNetCore.Http.HttpMethods.IsPost(string! method) -> bool\nstatic Microsoft.AspNetCore.Http.HttpMethods.IsPut(string! method) -> bool\nstatic Microsoft.AspNetCore.Http.HttpMethods.IsTrace(string! method) -> bool\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic JSON Patch Support in ASP.NET Core\nDESCRIPTION: Basic setup to enable JSON Patch support using Newtonsoft.Json in Program.cs\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Features/JsonPatch/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers()\n    .AddNewtonsoftJson();\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata for Request Processing\nDESCRIPTION: Implements IParameterBindingMetadata to store information about parameter binding capabilities and requirements. Tracks whether parameters can be bound using TryParse, BindAsync, or are optional.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Metadata for Endpoint Parameters in ASP.NET Core\nDESCRIPTION: Populates metadata for endpoint parameters, specifying binding sources, response types, and content types. Sets up route parameter binding with parameter metadata.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitSource_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nMetadataPopulator populateMetadata = (methodInfo, options) =>\n{\n    Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n    Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n    options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n    var parameters = methodInfo.GetParameters();\n    options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"routeValue\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n    options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n    return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n};\n```\n\n----------------------------------------\n\nTITLE: HTTP Static Constants in ASP.NET Core\nDESCRIPTION: Static readonly fields providing HTTP-related constants in ASP.NET Core, including empty collections, HTTP method names, and protocol strings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Http.EndpointMetadataCollection.Empty -> Microsoft.AspNetCore.Http.EndpointMetadataCollection!\nstatic readonly Microsoft.AspNetCore.Http.FragmentString.Empty -> Microsoft.AspNetCore.Http.FragmentString\nstatic readonly Microsoft.AspNetCore.Http.HttpMethods.Connect -> string!\nstatic readonly Microsoft.AspNetCore.Http.HttpMethods.Delete -> string!\nstatic readonly Microsoft.AspNetCore.Http.HttpMethods.Get -> string!\nstatic readonly Microsoft.AspNetCore.Http.HttpMethods.Head -> string!\nstatic readonly Microsoft.AspNetCore.Http.HttpMethods.Options -> string!\nstatic readonly Microsoft.AspNetCore.Http.HttpMethods.Patch -> string!\nstatic readonly Microsoft.AspNetCore.Http.HttpMethods.Post -> string!\nstatic readonly Microsoft.AspNetCore.Http.HttpMethods.Put -> string!\nstatic readonly Microsoft.AspNetCore.Http.HttpMethods.Trace -> string!\nstatic readonly Microsoft.AspNetCore.Http.HttpProtocol.Http09 -> string!\nstatic readonly Microsoft.AspNetCore.Http.HttpProtocol.Http10 -> string!\nstatic readonly Microsoft.AspNetCore.Http.HttpProtocol.Http11 -> string!\nstatic readonly Microsoft.AspNetCore.Http.HttpProtocol.Http2 -> string!\nstatic readonly Microsoft.AspNetCore.Http.HttpProtocol.Http3 -> string!\nstatic readonly Microsoft.AspNetCore.Http.PathString.Empty -> Microsoft.AspNetCore.Http.PathString\nstatic readonly Microsoft.AspNetCore.Http.QueryString.Empty -> Microsoft.AspNetCore.Http.QueryString\n```\n\n----------------------------------------\n\nTITLE: Using dotnet-getdocument CLI Tool\nDESCRIPTION: Command to display help information for the dotnet-getdocument tool. This command shows available options and usage instructions for generating OpenAPI documentation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Tools/dotnet-getdocument/README.md#2025-04-08_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndotnet \".../dotnet-getdocument.dll\" --help\n```\n\n----------------------------------------\n\nTITLE: Defining LoginWith2faModel for ASP.NET Core Identity UI V5\nDESCRIPTION: This snippet defines the LoginWith2faModel class and its nested InputModel for ASP.NET Core Identity UI version 5. It includes properties for managing two-factor authentication login information and user input.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWith2faModel\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWith2faModel.Input.get -> Microsoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWith2faModel.InputModel!\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWith2faModel.Input.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWith2faModel.InputModel\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWith2faModel.InputModel.InputModel() -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWith2faModel.InputModel.RememberMachine.get -> bool\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWith2faModel.InputModel.RememberMachine.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWith2faModel.InputModel.TwoFactorCode.get -> string!\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWith2faModel.InputModel.TwoFactorCode.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWith2faModel.LoginWith2faModel() -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWith2faModel.RememberMe.get -> bool\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWith2faModel.RememberMe.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWith2faModel.ReturnUrl.get -> string?\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.LoginWith2faModel.ReturnUrl.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Message for Invalid Form Request Body in C#\nDESCRIPTION: This snippet defines a LoggerMessage for logging when reading a parameter from the request body as a form fails. It uses LogLevel.Debug and creates an EventId for the message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n    LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: PointerEventArgs Class for ASP.NET Core Blazor Events\nDESCRIPTION: Defines the PointerEventArgs class for pointer events in Blazor. Contains properties for pointer input devices (mouse, touch, pen) including dimensions, pressure, tilt, and pointer type information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs.Height.get -> float\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs.Height.set -> void\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs.IsPrimary.get -> bool\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs.IsPrimary.set -> void\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs.PointerEventArgs() -> void\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs.PointerId.get -> long\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs.PointerId.set -> void\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs.PointerType.get -> string!\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs.PointerType.set -> void\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs.Pressure.get -> float\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs.Pressure.set -> void\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs.TiltX.get -> float\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs.TiltX.set -> void\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs.TiltY.get -> float\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs.TiltY.set -> void\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs.Width.get -> float\nMicrosoft.AspNetCore.Components.Web.PointerEventArgs.Width.set -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing ExceptionHandlerMiddleware in C#\nDESCRIPTION: This code defines the ExceptionHandlerMiddleware class, which is responsible for handling exceptions in the ASP.NET Core pipeline. It includes the constructor and the Invoke method for processing HTTP requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware\nMicrosoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware.ExceptionHandlerMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Builder.ExceptionHandlerOptions!>! options, System.Diagnostics.DiagnosticListener! diagnosticListener) -> void\nMicrosoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware.Invoke(Microsoft.AspNetCore.Http.HttpContext! context) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: JSON Response Writing Helper Methods in C#\nDESCRIPTION: Helper methods for writing JSON responses with type checking and polymorphism support. Includes utilities for handling JSON type information and runtime type validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_NoParam_StringReturn.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\n----------------------------------------\n\nTITLE: Defining Form Request Body Error Logger in ASP.NET Core\nDESCRIPTION: Configures a LoggerMessage definition for logging invalid form request body errors. Uses structured logging with parameter type and name as template variables.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n            LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft.AspNetCore.Mvc.NewtonsoftJson Package with dotnet CLI\nDESCRIPTION: Command to install the Microsoft.AspNetCore.Mvc.NewtonsoftJson package using the dotnet CLI. This adds the package to your ASP.NET Core project, enabling Newtonsoft.Json integration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.NewtonsoftJson/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.Mvc.NewtonsoftJson\n```\n\n----------------------------------------\n\nTITLE: Resource Filter Event Data Classes in C#\nDESCRIPTION: Defines event data classes for monitoring resource filter execution including before/after resource execution events\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Diagnostics.BeforeResourceFilterOnResourceExecutionEventData.BeforeResourceFilterOnResourceExecutionEventData(Microsoft.AspNetCore.Mvc.Abstractions.ActionDescriptor! actionDescriptor, Microsoft.AspNetCore.Mvc.Filters.ResourceExecutingContext! resourceExecutingContext, Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata! filter) -> void\n```\n\n----------------------------------------\n\nTITLE: Running Tests for Microsoft Account Authentication\nDESCRIPTION: Command to run tests for the Microsoft Account Authentication project from within the security directory.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/MicrosoftAccount/src/README.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd -t\n```\n\n----------------------------------------\n\nTITLE: Defining Twitter Authentication Constants in C#\nDESCRIPTION: Defines constant values for Twitter authentication, including the authentication scheme and display name.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Twitter/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.Authentication.Twitter.TwitterDefaults.AuthenticationScheme = \"Twitter\" -> string!\nstatic readonly Microsoft.AspNetCore.Authentication.Twitter.TwitterDefaults.DisplayName -> string\n```\n\n----------------------------------------\n\nTITLE: Conflict Response Methods in ASP.NET Core ControllerBase (C#)\nDESCRIPTION: Methods to return HTTP 409 Conflict responses, indicating a request conflict with the current state of the server. These methods support returning empty responses, model state errors, or custom error objects.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Conflict() -> Microsoft.AspNetCore.Mvc.ConflictResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Conflict(Microsoft.AspNetCore.Mvc.ModelBinding.ModelStateDictionary! modelState) -> Microsoft.AspNetCore.Mvc.ConflictObjectResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Conflict(object? error) -> Microsoft.AspNetCore.Mvc.ConflictObjectResult!\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft.AspNetCore.Mvc.Testing Package with .NET CLI\nDESCRIPTION: Command to install the Microsoft.AspNetCore.Mvc.Testing package using the .NET CLI. This package is required for writing integration tests for ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Testing/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.Mvc.Testing\n```\n\n----------------------------------------\n\nTITLE: Defining HubException Class in ASP.NET Core SignalR (C#)\nDESCRIPTION: The HubException class definition for SignalR, used to represent errors that occur during hub operations. This exception can be thrown by server hub methods and will be passed to the client.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.HubException\nMicrosoft.AspNetCore.SignalR.HubException.HubException() -> void\nMicrosoft.AspNetCore.SignalR.HubException.HubException(string? message) -> void\nMicrosoft.AspNetCore.SignalR.HubException.HubException(string? message, System.Exception? innerException) -> void\nMicrosoft.AspNetCore.SignalR.HubException.HubException(System.Runtime.Serialization.SerializationInfo! info, System.Runtime.Serialization.StreamingContext context) -> void\n```\n\n----------------------------------------\n\nTITLE: Overriding Routing Component Methods in C#\nDESCRIPTION: Overrides the BuildRenderTree, OnAfterRenderAsync, OnParametersSet, OnInitialized methods for FocusOnNavigate and NavLink components in ASP.NET Core Routing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Components.Routing.FocusOnNavigate.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder! builder) -> void\noverride Microsoft.AspNetCore.Components.Routing.FocusOnNavigate.OnAfterRenderAsync(bool firstRender) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.Components.Routing.FocusOnNavigate.OnParametersSet() -> void\noverride Microsoft.AspNetCore.Components.Routing.NavLink.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder! builder) -> void\noverride Microsoft.AspNetCore.Components.Routing.NavLink.OnInitialized() -> void\noverride Microsoft.AspNetCore.Components.Routing.NavLink.OnParametersSet() -> void\n```\n\n----------------------------------------\n\nTITLE: Building Filter Delegate for Endpoint in ASP.NET Core\nDESCRIPTION: This method builds a filter delegate for an endpoint by applying route handler filters in reverse order.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HealthCheckRegistration Class in C#\nDESCRIPTION: This class represents the registration of a health check. It includes properties for name, factory, failure status, tags, timeout, and other configuration options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HealthChecks/Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration.Delay.get -> System.TimeSpan?\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration.Delay.set -> void\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration.Factory.get -> System.Func<System.IServiceProvider!, Microsoft.Extensions.Diagnostics.HealthChecks.IHealthCheck!>!\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration.Factory.set -> void\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration.FailureStatus.get -> Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration.FailureStatus.set -> void\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration.HealthCheckRegistration(string! name, Microsoft.Extensions.Diagnostics.HealthChecks.IHealthCheck! instance, Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus? failureStatus, System.Collections.Generic.IEnumerable<string!>? tags) -> void\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration.HealthCheckRegistration(string! name, Microsoft.Extensions.Diagnostics.HealthChecks.IHealthCheck! instance, Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus? failureStatus, System.Collections.Generic.IEnumerable<string!>? tags, System.TimeSpan? timeout) -> void\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration.HealthCheckRegistration(string! name, System.Func<System.IServiceProvider!, Microsoft.Extensions.Diagnostics.HealthChecks.IHealthCheck!>! factory, Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus? failureStatus, System.Collections.Generic.IEnumerable<string!>? tags) -> void\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration.HealthCheckRegistration(string! name, System.Func<System.IServiceProvider!, Microsoft.Extensions.Diagnostics.HealthChecks.IHealthCheck!>! factory, Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus? failureStatus, System.Collections.Generic.IEnumerable<string!>? tags, System.TimeSpan? timeout) -> void\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration.Name.get -> string!\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration.Name.set -> void\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration.Period.get -> System.TimeSpan?\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration.Period.set -> void\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration.Tags.get -> System.Collections.Generic.ISet<string!>!\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration.Timeout.get -> System.TimeSpan\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration.Timeout.set -> void\n```\n\n----------------------------------------\n\nTITLE: Password Management Models in ASP.NET Core Identity UI\nDESCRIPTION: Defines models for password-related operations including ChangePasswordModel and ResetPasswordModel with properties for old/new passwords and confirmation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Manage.Internal.ChangePasswordModel.InputModel\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Manage.Internal.ChangePasswordModel.InputModel.OldPassword.get -> string!\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Manage.Internal.ChangePasswordModel.InputModel.NewPassword.get -> string!\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Manage.Internal.ChangePasswordModel.InputModel.ConfirmPassword.get -> string?\n```\n\n----------------------------------------\n\nTITLE: Building Endpoint Filter Delegate in ASP.NET Core\nDESCRIPTION: Constructs a filtered invocation delegate for endpoints with filter factories. The delegate handles status codes, parameter validation, and result execution based on the filter chain execution results.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nif (options.EndpointBuilder.FilterFactories.Count > 0)\n{\n    filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n    {\n        if (ic.HttpContext.Response.StatusCode == 400)\n        {\n            return ValueTask.FromResult<object?>(Results.Empty);\n        }\n        return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.HttpContext>(0)!, ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.MyBothBindAsyncStruct>(1)!));\n    },\n    options.EndpointBuilder,\n    handler.Method);\n}\n```\n\n----------------------------------------\n\nTITLE: Registry Repository Implementation\nDESCRIPTION: Virtual methods for managing XML elements in the Windows Registry, including storage, retrieval, and deletion operations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.DataProtection.Repositories.RegistryXmlRepository.DeleteElements(System.Action<System.Collections.Generic.IReadOnlyCollection<Microsoft.AspNetCore.DataProtection.Repositories.IDeletableElement!>!>! chooseElements) -> bool\nvirtual Microsoft.AspNetCore.DataProtection.Repositories.RegistryXmlRepository.GetAllElements() -> System.Collections.Generic.IReadOnlyCollection<System.Xml.Linq.XElement!>!\nvirtual Microsoft.AspNetCore.DataProtection.Repositories.RegistryXmlRepository.StoreElement(System.Xml.Linq.XElement! element, string! friendlyName) -> void\n```\n\n----------------------------------------\n\nTITLE: ISession Interface Definition in C#\nDESCRIPTION: Interface for managing HTTP session state with methods for storing and retrieving session data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Features/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\ninterface ISession {\n    string Id { get; }\n    bool IsAvailable { get; }\n    IEnumerable<string> Keys { get; }\n    void Clear();\n    Task CommitAsync(CancellationToken cancellationToken = default);\n    Task LoadAsync(CancellationToken cancellationToken = default);\n    void Remove(string key);\n    void Set(string key, byte[] value);\n    bool TryGetValue(string key, out byte[] value);\n}\n```\n\n----------------------------------------\n\nTITLE: Building the Facebook Authentication Project in PowerShell\nDESCRIPTION: Command to build the Facebook Authentication project from the parent 'security' directory.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Facebook/src/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: Form Content Type Validation in C#\nDESCRIPTION: Validates that the content type is a supported form media type. Returns 415 Unsupported Media Type status if validation fails.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_QueryNotPresent.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding InputRadio<TValue> and InputRadioGroup<TValue> Component Methods in C#\nDESCRIPTION: Overrides the BuildRenderTree, OnParametersSet, and TryParseValueFromString methods for InputRadio<TValue> and InputRadioGroup<TValue> components in ASP.NET Core Forms.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Components.Forms.InputRadio<TValue>.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder! builder) -> void\noverride Microsoft.AspNetCore.Components.Forms.InputRadio<TValue>.OnParametersSet() -> void\noverride Microsoft.AspNetCore.Components.Forms.InputRadioGroup<TValue>.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder! builder) -> void\noverride Microsoft.AspNetCore.Components.Forms.InputRadioGroup<TValue>.OnParametersSet() -> void\noverride Microsoft.AspNetCore.Components.Forms.InputRadioGroup<TValue>.TryParseValueFromString(string? value, out TValue result, out string? validationErrorMessage) -> bool\n```\n\n----------------------------------------\n\nTITLE: Model Binding Context Abstract Methods in C#\nDESCRIPTION: Abstract method declarations for ModelBindingContext class that define core model binding functionality including nested scoping, model state management, and value provider access.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Mvc.ModelBinding.ModelBindingContext.ActionContext.get -> Microsoft.AspNetCore.Mvc.ActionContext!\nabstract Microsoft.AspNetCore.Mvc.ModelBinding.ModelBindingContext.ActionContext.set -> void\nabstract Microsoft.AspNetCore.Mvc.ModelBinding.ModelBindingContext.BinderModelName.get -> string?\nabstract Microsoft.AspNetCore.Mvc.ModelBinding.ModelBindingContext.EnterNestedScope() -> Microsoft.AspNetCore.Mvc.ModelBinding.ModelBindingContext.NestedScope\n```\n\n----------------------------------------\n\nTITLE: Defining Invalid Form Request Body Logger in ASP.NET Core\nDESCRIPTION: Defines a structured logger for invalid form request body scenarios using LoggerMessage.Define. Creates a logging delegate that captures parameter type and name details for form parsing failures.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n    LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Running BaselineGenerator Manual Update\nDESCRIPTION: Command to manually generate baseline files after updating Baseline.xml with package versions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/eng/tools/BaselineGenerator/README.md#2025-04-08_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ndotnet run\n```\n\n----------------------------------------\n\nTITLE: Disabling Git Status Check in PowerShell\nDESCRIPTION: PowerShell command to disable git status checking for each prompt, improving performance in the dotnet/aspnetcore repository.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Submodules.md#2025-04-08_snippet_9\n\nLANGUAGE: powershell\nCODE:\n```\n$GitPromptSettings.EnableFileStatus = $false\n```\n\n----------------------------------------\n\nTITLE: Implementing OWIN Middleware in C#\nDESCRIPTION: Example of a basic OWIN middleware implementation that returns a 'Hello World' response. The middleware handles the OWIN environment dictionary, sets response headers, and writes the response body.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Owin/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic Task OwinHello(IDictionary<string, object> environment)\n{\n    var responseText = \"Hello World via OWIN\";\n    var responseBytes = Encoding.UTF8.GetBytes(responseText);\n\n    // OWIN Environment Keys: https://owin.org/spec/spec/owin-1.0.0.html\n    var responseStream = (Stream)environment[\"owin.ResponseBody\"];\n    var responseHeaders = (IDictionary<string, string[]>)environment[\"owin.ResponseHeaders\"];\n\n    responseHeaders[\"Content-Length\"] = [responseBytes.Length.ToString(CultureInfo.InvariantCulture)];\n    responseHeaders[\"Content-Type\"] = [\"text/plain\"];\n\n    return responseStream.WriteAsync(responseBytes, 0, responseBytes.Length);\n}\n```\n\n----------------------------------------\n\nTITLE: Form Value Provider Overrides in C#\nDESCRIPTION: Override implementations for form value providers, including methods for prefix checking and value retrieval.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_32\n\nLANGUAGE: csharp\nCODE:\n```\noverride Microsoft.AspNetCore.Mvc.ModelBinding.FormValueProvider.ContainsPrefix(string! prefix) -> bool\noverride Microsoft.AspNetCore.Mvc.ModelBinding.FormValueProvider.GetValue(string! key) -> Microsoft.AspNetCore.Mvc.ModelBinding.ValueProviderResult\noverride Microsoft.AspNetCore.Mvc.ModelBinding.JQueryFormValueProvider.GetValue(string! key) -> Microsoft.AspNetCore.Mvc.ModelBinding.ValueProviderResult\noverride Microsoft.AspNetCore.Mvc.ModelBinding.JQueryValueProvider.ContainsPrefix(string! prefix) -> bool\noverride Microsoft.AspNetCore.Mvc.ModelBinding.JQueryValueProvider.GetValue(string! key) -> Microsoft.AspNetCore.Mvc.ModelBinding.ValueProviderResult\n```\n\n----------------------------------------\n\nTITLE: Configuring Helix Test Runner Timeout in C#\nDESCRIPTION: Shows the configuration of test timeout parameters in the RunTestsAsync method. Sets a 15-minute timeout for test execution with blame tracking and diagnostic logging enabled.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/ProjectTemplates/README.md#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic async Task<int> RunTestsAsync()\n{\n    ...\n        var commonTestArgs = $\"test {Options.Target} --diag:{diagLog} --logger xunit --logger \\\"console;verbosity=normal\\\" \" +\n                                \"--blame-crash --blame-hang-timeout 15m\";\n```\n\n----------------------------------------\n\nTITLE: Installing Certificate Authentication Package\nDESCRIPTION: Command to install the Microsoft.AspNetCore.Authentication.Certificate NuGet package using the .NET CLI.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Certificate/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.Authentication.Certificate\n```\n\n----------------------------------------\n\nTITLE: Creating Inbound Activity Handler for Blazor Server Circuit\nDESCRIPTION: Virtual method in CircuitHandler that creates a function to handle inbound circuit activity. Takes a next delegate in the middleware pipeline and returns a function that processes CircuitInboundActivityContext.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandler.CreateInboundActivityHandler(System.Func<Microsoft.AspNetCore.Components.Server.Circuits.CircuitInboundActivityContext!, System.Threading.Tasks.Task!>! next) -> System.Func<Microsoft.AspNetCore.Components.Server.Circuits.CircuitInboundActivityContext!, System.Threading.Tasks.Task!>!\n```\n\n----------------------------------------\n\nTITLE: View Components API Structure\nDESCRIPTION: Core interface and class definitions for ASP.NET Core MVC view components and view engines. Includes methods for executing view components and managing view data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ViewComponents.ViewViewComponentResult.ExecuteAsync(ViewComponentContext context)\nMicrosoft.AspNetCore.Mvc.ViewEngines.IViewEngine.FindView(ActionContext context, string viewName, bool isMainPage)\nMicrosoft.AspNetCore.Mvc.ViewEngines.IView.RenderAsync(ViewContext context)\n```\n\n----------------------------------------\n\nTITLE: Serializing Twitter Request Tokens in C#\nDESCRIPTION: Defines the RequestTokenSerializer class for serializing and deserializing Twitter request tokens, including methods for reading and writing token data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Twitter/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.Twitter.RequestTokenSerializer\nMicrosoft.AspNetCore.Authentication.Twitter.RequestTokenSerializer.RequestTokenSerializer() -> void\nstatic Microsoft.AspNetCore.Authentication.Twitter.RequestTokenSerializer.Read(System.IO.BinaryReader reader) -> Microsoft.AspNetCore.Authentication.Twitter.RequestToken\nstatic Microsoft.AspNetCore.Authentication.Twitter.RequestTokenSerializer.Write(System.IO.BinaryWriter writer, Microsoft.AspNetCore.Authentication.Twitter.RequestToken token) -> void\nvirtual Microsoft.AspNetCore.Authentication.Twitter.RequestTokenSerializer.Deserialize(byte[] data) -> Microsoft.AspNetCore.Authentication.Twitter.RequestToken\nvirtual Microsoft.AspNetCore.Authentication.Twitter.RequestTokenSerializer.Serialize(Microsoft.AspNetCore.Authentication.Twitter.RequestToken model) -> byte[]\n```\n\n----------------------------------------\n\nTITLE: Defining HealthStatus Enum in C#\nDESCRIPTION: This enum defines the possible health statuses: Unhealthy, Degraded, and Healthy.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HealthChecks/Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthStatus\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthStatus.Degraded = 1 -> Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthStatus.Healthy = 2 -> Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthStatus.Unhealthy = 0 -> Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus\n```\n\n----------------------------------------\n\nTITLE: Default Timeout Constants for SignalR HubConnection in C#\nDESCRIPTION: Defines static readonly fields for default timeout values used in SignalR HubConnection, including handshake timeout, keep-alive interval, and server timeout.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.SignalR.Client.HubConnection.DefaultHandshakeTimeout -> System.TimeSpan\nstatic readonly Microsoft.AspNetCore.SignalR.Client.HubConnection.DefaultKeepAliveInterval -> System.TimeSpan\nstatic readonly Microsoft.AspNetCore.SignalR.Client.HubConnection.DefaultServerTimeout -> System.TimeSpan\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Class in C#\nDESCRIPTION: This snippet defines a sealed class ParameterBindingMetadata that implements IParameterBindingMetadata. It stores metadata about parameter binding, including the parameter name, type information, and binding capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in System.Runtime.CompilerServices\nDESCRIPTION: Auto-generated attribute class used for method interception, takes version and data parameters. This is used to mark methods that intercept other methods at specific locations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_TakesCustomMetadataEmitter_Has_Metadata.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Boolean Binders with Task Support in ASP.NET Core Components\nDESCRIPTION: Extension method for EventCallbackFactory that creates data binding callbacks for boolean values in Blazor components. This method specifically supports asynchronous setters that return a Task rather than void.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<bool, System.Threading.Tasks.Task!>! setter, bool existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\n```\n\n----------------------------------------\n\nTITLE: Running Tests for Facebook Authentication Project in PowerShell\nDESCRIPTION: Command to run tests for the Facebook Authentication project from the parent 'security' directory.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Facebook/src/README.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd -t\n```\n\n----------------------------------------\n\nTITLE: Security Stamp Validator Class Definition\nDESCRIPTION: Class definition for SecurityStampValidator that handles security stamp validation in ASP.NET Core Identity. Includes constructor, properties, and dependencies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.SecurityStampValidator<TUser>.SecurityStampValidator(\n    Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Identity.SecurityStampValidatorOptions!>! options,\n    Microsoft.AspNetCore.Identity.SignInManager<TUser!>! signInManager,\n    Microsoft.AspNetCore.Authentication.ISystemClock! clock,\n    Microsoft.Extensions.Logging.ILoggerFactory! logger) -> void\n```\n\n----------------------------------------\n\nTITLE: Mapping GET Endpoint with MapGet6 Extension in ASP.NET Core\nDESCRIPTION: Implementation of MapGet6 extension method that maps a GET endpoint with parameter binding, metadata population, and request delegate creation. Handles string return types with appropriate content negotiation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n%INTERCEPTSLOCATIONATTRIBUTE%\ninternal static RouteHandlerBuilder MapGet6(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"httpContext\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"myBindAsyncParam\", parameters[1], hasTryParse: false, hasBindAsync: true, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n```\n\n----------------------------------------\n\nTITLE: Event Callback Factory Binder Extensions\nDESCRIPTION: Extension methods for creating strongly-typed event bindings with culture support. Handles various numeric and boolean data types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<bool>! setter, bool existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\n```\n\n----------------------------------------\n\nTITLE: Helix Job Status Output\nDESCRIPTION: Example console output showing Helix job execution status across different platforms including job IDs and work item completion statistics.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Helix.md#2025-04-08_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n  Sending Job to Ubuntu.1804.Amd64.Open...\n  Sent Helix Job; see work items at https://helix.dot.net/api/jobs/c1b425c8-0fef-4cba-9dee-29344d7a61b8/workitems?api-version=2019-06-17\n  Sending Job to Windows.11.Amd64.ClientPre.Open...\n  Sent Helix Job; see work items at https://helix.dot.net/api/jobs/1fc117ce-d52a-4ea4-8896-3c289fdf8e17/workitems?api-version=2019-06-17\n  Sending Job to OSX.1014.Amd64.Open...\n  Sent Helix Job; see work items at https://helix.dot.net/api/jobs/53e2ca23-9efd-4299-8a8f-d9271265aeaa/workitems?api-version=2019-06-17\n  Waiting for completion of job 1fc117ce-d52a-4ea4-8896-3c289fdf8e17 on Windows.11.Amd64.ClientPre.Open\n  Waiting for completion of job c1b425c8-0fef-4cba-9dee-29344d7a61b8 on Ubuntu.1804.Amd64.Open\n  Waiting for completion of job 53e2ca23-9efd-4299-8a8f-d9271265aeaa on OSX.1014.Amd64.Open\n  Job 53e2ca23-9efd-4299-8a8f-d9271265aeaa on OSX.1014.Amd64.Open is completed with 139 finished work items.\n  Job c1b425c8-0fef-4cba-9dee-29344d7a61b8 on Ubuntu.1804.Amd64.Open is completed with 138 finished work items.\n  Job 1fc117ce-d52a-4ea4-8896-3c289fdf8e17 on Windows.11.Amd64.ClientPre.Open is completed with 170 finished work items.\n```\n\n----------------------------------------\n\nTITLE: Defining Created Result Methods in C#\nDESCRIPTION: These methods create Created (HTTP 201) results with optional URI and value parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.Created() -> Microsoft.AspNetCore.Http.HttpResults.Created!\nstatic Microsoft.AspNetCore.Http.TypedResults.Created(string? uri) -> Microsoft.AspNetCore.Http.HttpResults.Created!\nstatic Microsoft.AspNetCore.Http.TypedResults.Created(System.Uri? uri) -> Microsoft.AspNetCore.Http.HttpResults.Created!\nstatic Microsoft.AspNetCore.Http.TypedResults.Created<TValue>(string? uri, TValue? value) -> Microsoft.AspNetCore.Http.HttpResults.Created<TValue>!\nstatic Microsoft.AspNetCore.Http.TypedResults.Created<TValue>(System.Uri? uri, TValue? value) -> Microsoft.AspNetCore.Http.HttpResults.Created<TValue>!\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Message for Implicit Body Not Provided in C#\nDESCRIPTION: This snippet defines a LoggerMessage for logging when an implicit body is not provided. It uses LogLevel.Debug and creates an EventId for the message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n```\n\n----------------------------------------\n\nTITLE: Typed Server-Sent Events Factory Methods\nDESCRIPTION: Collection of static methods for creating strongly-typed SSE results with support for custom types and event types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.ServerSentEvents(System.Collections.Generic.IAsyncEnumerable<string!>! values, string? eventType = null) -> Microsoft.AspNetCore.Http.HttpResults.ServerSentEventsResult<string!>!\nstatic Microsoft.AspNetCore.Http.TypedResults.ServerSentEvents<T>(System.Collections.Generic.IAsyncEnumerable<System.Net.ServerSentEvents.SseItem<T>>! values) -> Microsoft.AspNetCore.Http.HttpResults.ServerSentEventsResult<T>!\nstatic Microsoft.AspNetCore.Http.TypedResults.ServerSentEvents<T>(System.Collections.Generic.IAsyncEnumerable<T>! values, string? eventType = null) -> Microsoft.AspNetCore.Http.HttpResults.ServerSentEventsResult<T>!\n```\n\n----------------------------------------\n\nTITLE: Building Endpoint Filter Delegate in ASP.NET Core\nDESCRIPTION: This method constructs an endpoint filter delegate by applying a series of filter factories to an initial filtered invocation. It uses the endpoint builder and method info to create the filter context.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Using dotnet CLI Commands After Activation\nDESCRIPTION: Commands showing how to use dotnet CLI commands directly after activating the local .NET SDK.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/BuildFromSource.md#2025-04-08_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# Linux or Mac\nsource activate.sh\ndotnet build\ndotnet test --filter \"MySpecificUnitTest\"\n```\n\nLANGUAGE: powershell\nCODE:\n```\n# Windows\n. ./activate.ps1\ndotnet build\ndotnet test --filter \"MySpecificUnitTest\"\n```\n\n----------------------------------------\n\nTITLE: Named Pipe Transport Options Class Definition\nDESCRIPTION: Class containing configuration options for Named Pipe transport, including buffer sizes, listener queue count, and pipe security settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Transport.NamedPipes/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Server.Kestrel.Transport.NamedPipes.NamedPipeTransportOptions\n{\n    public NamedPipeTransportOptions() -> void\n    public long? MaxReadBufferSize { get; set; }\n    public long? MaxWriteBufferSize { get; set; }\n    public int ListenerQueueCount { get; set; }\n    public bool CurrentUserOnly { get; set; }\n    public System.IO.Pipes.PipeSecurity? PipeSecurity { get; set; }\n    public System.Func<CreateNamedPipeServerStreamContext!, System.IO.Pipes.NamedPipeServerStream!>! CreateNamedPipeServerStream { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Virtual Properties for ModelMetadata in C#\nDESCRIPTION: Declares virtual properties for the ModelMetadata class, including BoundConstructor, BoundConstructorInvoker, BoundConstructorParameters, and ContainerMetadata. These properties allow customization of model metadata handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata.BoundConstructor.get -> Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata?\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata.BoundConstructorInvoker.get -> System.Func<object?[]!, object!>?\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata.BoundConstructorParameters.get -> System.Collections.Generic.IReadOnlyList<Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata!>?\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata.ContainerMetadata.get -> Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata?\n```\n\n----------------------------------------\n\nTITLE: Skip Helix Queues Configuration in XML\nDESCRIPTION: XML configuration for skipping specific Helix test queues in project file. Used to exclude certain platforms from test execution.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/ProjectTemplates/README.md#2025-04-08_snippet_1\n\nLANGUAGE: XML\nCODE:\n```\n<SkipHelixQueues>\n    $(HelixQueueArmDebian12);\n</SkipHelixQueues>\n```\n\n----------------------------------------\n\nTITLE: Adding Summary Comment Link to Issue Description\nDESCRIPTION: Example of the markdown text that should be added to the bottom of an issue description to provide a direct link to the summary comment. This helps with discoverability when there are many comments in the issue.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/HelpWantedProcess.md#2025-04-08_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n**Summary Comment** : https://github.com/dotnet/aspnetcore/issues/51912#issuecomment-1801246403\n```\n\n----------------------------------------\n\nTITLE: Adding MVC Localization to IMvcCoreBuilder in C#\nDESCRIPTION: This snippet shows multiple overloads of the AddMvcLocalization extension method for IMvcCoreBuilder. These methods allow configuration of localization options, data annotations localization, and view location expansion format.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.MvcLocalizationMvcCoreBuilderExtensions.AddMvcLocalization(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder! builder, Microsoft.AspNetCore.Mvc.Razor.LanguageViewLocationExpanderFormat format, System.Action<Microsoft.AspNetCore.Mvc.DataAnnotations.MvcDataAnnotationsLocalizationOptions!>? dataAnnotationsLocalizationOptionsSetupAction) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.MvcLocalizationMvcCoreBuilderExtensions.AddMvcLocalization(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder! builder, System.Action<Microsoft.AspNetCore.Mvc.DataAnnotations.MvcDataAnnotationsLocalizationOptions!>? dataAnnotationsLocalizationOptionsSetupAction) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.MvcLocalizationMvcCoreBuilderExtensions.AddMvcLocalization(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder! builder, System.Action<Microsoft.Extensions.Localization.LocalizationOptions!>? localizationOptionsSetupAction) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.MvcLocalizationMvcCoreBuilderExtensions.AddMvcLocalization(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder! builder, System.Action<Microsoft.Extensions.Localization.LocalizationOptions!>? localizationOptionsSetupAction, Microsoft.AspNetCore.Mvc.Razor.LanguageViewLocationExpanderFormat format) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.MvcLocalizationMvcCoreBuilderExtensions.AddMvcLocalization(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder! builder, System.Action<Microsoft.Extensions.Localization.LocalizationOptions!>? localizationOptionsSetupAction, Microsoft.AspNetCore.Mvc.Razor.LanguageViewLocationExpanderFormat format, System.Action<Microsoft.AspNetCore.Mvc.DataAnnotations.MvcDataAnnotationsLocalizationOptions!>? dataAnnotationsLocalizationOptionsSetupAction) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.MvcLocalizationMvcCoreBuilderExtensions.AddMvcLocalization(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder! builder, System.Action<Microsoft.Extensions.Localization.LocalizationOptions!>? localizationOptionsSetupAction, System.Action<Microsoft.AspNetCore.Mvc.DataAnnotations.MvcDataAnnotationsLocalizationOptions!>? dataAnnotationsLocalizationOptionsSetupAction) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining Parameter Binding Failure Logger in ASP.NET Core\nDESCRIPTION: Defines a structured logger action for parameter binding failures using LoggerMessage.Define. This creates an optimized logging delegate that captures parameter type, name, and source value information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n    LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Virtual Methods in ResourceManagerStringLocalizer in C#\nDESCRIPTION: Defines virtual methods for getting localized strings in the ResourceManagerStringLocalizer class.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Localization/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.Extensions.Localization.ResourceManagerStringLocalizer.GetAllStrings(bool includeParentCultures) -> System.Collections.Generic.IEnumerable<Microsoft.Extensions.Localization.LocalizedString!>!\nvirtual Microsoft.Extensions.Localization.ResourceManagerStringLocalizer.this[string! name, params object![]! arguments].get -> Microsoft.Extensions.Localization.LocalizedString!\nvirtual Microsoft.Extensions.Localization.ResourceManagerStringLocalizer.this[string! name].get -> Microsoft.Extensions.Localization.LocalizedString!\n```\n\n----------------------------------------\n\nTITLE: Running SignalR Build Script (Unix)\nDESCRIPTION: Executes the build script for SignalR on Unix-based systems. This script automatically installs the necessary .NET SDK version and builds the project.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/GettingStarted.md#2025-04-08_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbuild.sh\n```\n\n----------------------------------------\n\nTITLE: Extending JSON Serialization for HTTP Responses in C#\nDESCRIPTION: This snippet extends JSON serialization for HTTP responses, including methods to check for known polymorphism and determine if a specific type should be used.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_NoParam_StringReturn_WithFilter.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nreturn HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n\nreturn response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\n----------------------------------------\n\nTITLE: Defining SpaOptions Class in C#\nDESCRIPTION: Defines the SpaOptions class with properties for configuring SPA options in ASP.NET Core. Includes settings for default pages, static file options, development server port, and package manager commands.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Spa/SpaServices.Extensions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SpaServices.SpaOptions\nMicrosoft.AspNetCore.SpaServices.SpaOptions.SpaOptions() -> void\nMicrosoft.AspNetCore.SpaServices.SpaOptions.DefaultPage.get -> Microsoft.AspNetCore.Http.PathString\nMicrosoft.AspNetCore.SpaServices.SpaOptions.DefaultPage.set -> void\nMicrosoft.AspNetCore.SpaServices.SpaOptions.DefaultPageStaticFileOptions.get -> Microsoft.AspNetCore.Builder.StaticFileOptions?\nMicrosoft.AspNetCore.SpaServices.SpaOptions.DefaultPageStaticFileOptions.set -> void\nMicrosoft.AspNetCore.SpaServices.SpaOptions.DevServerPort.get -> int\nMicrosoft.AspNetCore.SpaServices.SpaOptions.DevServerPort.set -> void\nMicrosoft.AspNetCore.SpaServices.SpaOptions.PackageManagerCommand.get -> string!\nMicrosoft.AspNetCore.SpaServices.SpaOptions.PackageManagerCommand.set -> void\nMicrosoft.AspNetCore.SpaServices.SpaOptions.SourcePath.get -> string?\nMicrosoft.AspNetCore.SpaServices.SpaOptions.SourcePath.set -> void\nMicrosoft.AspNetCore.SpaServices.SpaOptions.StartupTimeout.get -> System.TimeSpan\nMicrosoft.AspNetCore.SpaServices.SpaOptions.StartupTimeout.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining Filter Attribute Methods for ASP.NET Core MVC\nDESCRIPTION: These methods define the behavior of various filter attributes in ASP.NET Core MVC, including action filters, exception filters, and result filters. They provide hooks for executing code before and after action execution and result processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_64\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute.OnActionExecuted(Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext! context) -> void\nvirtual Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute.OnActionExecuting(Microsoft.AspNetCore.Mvc.Filters.ActionExecutingContext! context) -> void\nvirtual Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute.OnActionExecutionAsync(Microsoft.AspNetCore.Mvc.Filters.ActionExecutingContext! context, Microsoft.AspNetCore.Mvc.Filters.ActionExecutionDelegate! next) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute.OnResultExecuted(Microsoft.AspNetCore.Mvc.Filters.ResultExecutedContext! context) -> void\nvirtual Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute.OnResultExecuting(Microsoft.AspNetCore.Mvc.Filters.ResultExecutingContext! context) -> void\nvirtual Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute.OnResultExecutionAsync(Microsoft.AspNetCore.Mvc.Filters.ResultExecutingContext! context, Microsoft.AspNetCore.Mvc.Filters.ResultExecutionDelegate! next) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Mvc.Filters.ExceptionFilterAttribute.OnException(Microsoft.AspNetCore.Mvc.Filters.ExceptionContext! context) -> void\nvirtual Microsoft.AspNetCore.Mvc.Filters.ExceptionFilterAttribute.OnExceptionAsync(Microsoft.AspNetCore.Mvc.Filters.ExceptionContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Mvc.Filters.ResultFilterAttribute.OnResultExecuted(Microsoft.AspNetCore.Mvc.Filters.ResultExecutedContext! context) -> void\nvirtual Microsoft.AspNetCore.Mvc.Filters.ResultFilterAttribute.OnResultExecuting(Microsoft.AspNetCore.Mvc.Filters.ResultExecutingContext! context) -> void\nvirtual Microsoft.AspNetCore.Mvc.Filters.ResultFilterAttribute.OnResultExecutionAsync(Microsoft.AspNetCore.Mvc.Filters.ResultExecutingContext! context, Microsoft.AspNetCore.Mvc.Filters.ResultExecutionDelegate! next) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Running OpenID Connect Authentication Tests\nDESCRIPTION: Command to execute the test suite for the OpenID Connect authentication project using PowerShell build script with test flag.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/README.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd -t\n```\n\n----------------------------------------\n\nTITLE: Error Response in ASP.NET Core Transport Protocol\nDESCRIPTION: JSON response that contains an error message explaining why the negotiation failed. Indicates that the client should stop attempting to establish a connection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/TransportProtocols.md#2025-04-08_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"error\": \"This connection is not allowed.\"\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Core Route Handler in ASP.NET Core\nDESCRIPTION: This method maps a route handler to an endpoint using the provided pattern, handler, and metadata. It's an internal method used by the routing system.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Authorization Results in C#\nDESCRIPTION: This snippet defines methods for creating success and failure authorization results. It provides flexibility in specifying the reason for authorization failure.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Authorization.AuthorizationResult.Failed() -> Microsoft.AspNetCore.Authorization.AuthorizationResult!\nstatic Microsoft.AspNetCore.Authorization.AuthorizationResult.Failed(Microsoft.AspNetCore.Authorization.AuthorizationFailure! failure) -> Microsoft.AspNetCore.Authorization.AuthorizationResult!\nstatic Microsoft.AspNetCore.Authorization.AuthorizationResult.Success() -> Microsoft.AspNetCore.Authorization.AuthorizationResult!\n```\n\n----------------------------------------\n\nTITLE: Form Request Body Logger Definition\nDESCRIPTION: Defines a logger action for invalid form request body with debug level logging and event ID 8.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleComplexTypeParam_StringReturn.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n    LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Body Logger in ASP.NET Core\nDESCRIPTION: Creates a structured logger for missing implicit body scenarios using LoggerMessage.Define. This establishes a logging delegate that captures the parameter name for which a body was expected but not provided.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n```\n\n----------------------------------------\n\nTITLE: HtmlLocalizer<TResource> Class Methods in C#\nDESCRIPTION: This snippet shows the virtual methods of the generic HtmlLocalizer<TResource> class, which is used for HTML localization with a specific resource type. It includes methods for getting localized strings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.Localization.HtmlLocalizer<TResource>.GetAllStrings(bool includeParentCultures) -> System.Collections.Generic.IEnumerable<Microsoft.Extensions.Localization.LocalizedString!>!\nvirtual Microsoft.AspNetCore.Mvc.Localization.HtmlLocalizer<TResource>.GetString(string! name) -> Microsoft.Extensions.Localization.LocalizedString!\nvirtual Microsoft.AspNetCore.Mvc.Localization.HtmlLocalizer<TResource>.GetString(string! name, params object![]! arguments) -> Microsoft.Extensions.Localization.LocalizedString!\nvirtual Microsoft.AspNetCore.Mvc.Localization.HtmlLocalizer<TResource>.this[string! name, params object![]! arguments].get -> Microsoft.AspNetCore.Mvc.Localization.LocalizedHtmlString!\nvirtual Microsoft.AspNetCore.Mvc.Localization.HtmlLocalizer<TResource>.this[string! name].get -> Microsoft.AspNetCore.Mvc.Localization.LocalizedHtmlString!\n```\n\n----------------------------------------\n\nTITLE: Form Content Type Validation in C#\nDESCRIPTION: Validates that the request content type matches expected form media type. Throws status 415 for unsupported media types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: JSON Content Type Validation in C#\nDESCRIPTION: Validates that the request content type matches expected JSON format. Throws status 415 for unsupported media types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedJsonContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Value Provider Implementation\nDESCRIPTION: Implements value provider functionality including ValueProviderResult and ValueProviderException classes. These handle value processing and error cases in model binding.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic class ValueProviderResult\n{\n    public CultureInfo Culture { get; }\n    public string? FirstValue { get; }\n    public int Length { get; }\n    public StringValues Values { get; }\n    \n    public ValueProviderResult();\n    public ValueProviderResult(StringValues values);\n    public ValueProviderResult(StringValues values, CultureInfo? culture);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DataProtectorTokenProvider<TUser> in C#\nDESCRIPTION: Definition of DataProtectorTokenProvider<TUser> class, which is responsible for generating and validating tokens for user operations in ASP.NET Core Identity. It includes constructor and property definitions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.DataProtectorTokenProvider<TUser>\nMicrosoft.AspNetCore.Identity.DataProtectorTokenProvider<TUser>.DataProtectorTokenProvider(Microsoft.AspNetCore.DataProtection.IDataProtectionProvider! dataProtectionProvider, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Identity.DataProtectionTokenProviderOptions!>! options, Microsoft.Extensions.Logging.ILogger<Microsoft.AspNetCore.Identity.DataProtectorTokenProvider<TUser!>!>! logger) -> void\nMicrosoft.AspNetCore.Identity.DataProtectorTokenProvider<TUser>.Logger.get -> Microsoft.Extensions.Logging.ILogger<Microsoft.AspNetCore.Identity.DataProtectorTokenProvider<TUser!>!>!\nMicrosoft.AspNetCore.Identity.DataProtectorTokenProvider<TUser>.Name.get -> string!\nMicrosoft.AspNetCore.Identity.DataProtectorTokenProvider<TUser>.Options.get -> Microsoft.AspNetCore.Identity.DataProtectionTokenProviderOptions!\nMicrosoft.AspNetCore.Identity.DataProtectorTokenProvider<TUser>.Protector.get -> Microsoft.AspNetCore.DataProtection.IDataProtector!\n```\n\n----------------------------------------\n\nTITLE: Redis Hub Lifetime Manager Class Definition\nDESCRIPTION: Generic class that manages SignalR hub connections using Redis as a backplane. Handles connection lifetime, group management, and message distribution.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/StackExchangeRedis/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.StackExchangeRedis.RedisHubLifetimeManager<THub>\n```\n\n----------------------------------------\n\nTITLE: Defining RedisCache Class for ASP.NET Core\nDESCRIPTION: Defines the RedisCache class implementing cache operations for StackExchange Redis in ASP.NET Core. It includes methods for getting, setting, removing, and refreshing cache entries, with both synchronous and asynchronous versions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.Dispose() -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.Get(string! key) -> byte[]?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.GetAsync(string! key, System.Threading.CancellationToken token = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<byte[]?>!\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.RedisCache(Microsoft.Extensions.Options.IOptions<Microsoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions!>! optionsAccessor) -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.Refresh(string! key) -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.RefreshAsync(string! key, System.Threading.CancellationToken token = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.Remove(string! key) -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.RemoveAsync(string! key, System.Threading.CancellationToken token = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.Set(string! key, byte[]! value, Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions! options) -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCache.SetAsync(string! key, byte[]! value, Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions! options, System.Threading.CancellationToken token = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: TagMode Enum Definition\nDESCRIPTION: Defines the rendering mode for HTML tags in Razor TagHelpers. Specifies whether tags should be self-closing, have both start and end tags, or only start tags.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Razor/Razor/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Razor.TagHelpers.TagMode.SelfClosing = 1\nMicrosoft.AspNetCore.Razor.TagHelpers.TagMode.StartTagAndEndTag = 0\nMicrosoft.AspNetCore.Razor.TagHelpers.TagMode.StartTagOnly = 2\n```\n\n----------------------------------------\n\nTITLE: Running SignalR Build Script (Windows)\nDESCRIPTION: Executes the build script for SignalR on Windows systems. This script automatically installs the necessary .NET SDK version and builds the project.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/GettingStarted.md#2025-04-08_snippet_0\n\nLANGUAGE: batch\nCODE:\n```\nbuild.cmd\n```\n\n----------------------------------------\n\nTITLE: Type Compatibility Check for JSON Serialization in ASP.NET Core\nDESCRIPTION: Determines if a JSON type info should be used with a specific runtime type for serialization. Supports null values and polymorphic types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\n----------------------------------------\n\nTITLE: Defining WebRenderer Class in C#\nDESCRIPTION: Defines the WebRenderer class for rendering components in a web context. It includes methods for adding root components and managing renderer IDs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.RenderTree.WebRenderer\nMicrosoft.AspNetCore.Components.RenderTree.WebRenderer.AddRootComponent(System.Type! componentType, string! domElementSelector) -> int\nMicrosoft.AspNetCore.Components.RenderTree.WebRenderer.RendererId.get -> int\nMicrosoft.AspNetCore.Components.RenderTree.WebRenderer.RendererId.init -> void\nMicrosoft.AspNetCore.Components.RenderTree.WebRenderer.WebRenderer(System.IServiceProvider! serviceProvider, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory, System.Text.Json.JsonSerializerOptions! jsonOptions, Microsoft.AspNetCore.Components.Web.Infrastructure.JSComponentInterop! jsComponentInterop) -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring Authentication Scheme Builder in C# for ASP.NET Core\nDESCRIPTION: This code defines the AuthenticationSchemeBuilder class, which is used to configure authentication schemes. It includes properties for the scheme's name, handler type, display name, and various options for handling authentication challenges and forbid responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class AuthenticationSchemeBuilder\n{\n    public AuthenticationSchemeBuilder(string name, Type handlerType)\n    {\n        if (name == null)\n        {\n            throw new ArgumentNullException(nameof(name));\n        }\n        if (handlerType == null)\n        {\n            throw new ArgumentNullException(nameof(handlerType));\n        }\n\n        Name = name;\n        HandlerType = handlerType;\n    }\n\n    public string Name { get; }\n\n    public Type HandlerType { get; }\n\n    public string? DisplayName { get; set; }\n\n    public Func<IOwinContext, Task>? SendChallenge { get; set; }\n\n    public Func<IOwinContext, Task>? SendForbid { get; set; }\n\n    public AuthenticationScheme Build() => new AuthenticationScheme(Name, DisplayName, HandlerType);\n}\n```\n\n----------------------------------------\n\nTITLE: Building HttpSys Project in PowerShell\nDESCRIPTION: This command builds the HttpSys project from source. It should be run inside the project directory.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/HttpSys/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: Documenting Razor Pages Test Website Structure\nDESCRIPTION: Markdown documentation explaining the purpose of the RazorPagesWebSite test project used for functional testing of ASP.NET Core Razor Pages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/test/WebSites/RazorPagesWebSite/readme.md#2025-04-08_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nRazorPagesWebSite\n===\n\nThis web site is used for functional tests of the Razor Pages feature of MVC.\n```\n\n----------------------------------------\n\nTITLE: Defining CookieContainerHandler Class Methods\nDESCRIPTION: HTTP message handler implementation for managing cookie containers in ASP.NET Core MVC testing\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Testing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Testing.Handlers.CookieContainerHandler.Container.get -> System.Net.CookieContainer!\nMicrosoft.AspNetCore.Mvc.Testing.Handlers.CookieContainerHandler.CookieContainerHandler() -> void\nMicrosoft.AspNetCore.Mvc.Testing.Handlers.CookieContainerHandler.CookieContainerHandler(System.Net.CookieContainer! cookieContainer) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing Authorization Handler Interface in C#\nDESCRIPTION: Interface definition for authorization handlers that evaluate authorization requirements asynchronously.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.IAuthorizationHandler.HandleAsync(Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext! context) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Building Endpoint Filter Delegate Chain in ASP.NET Core\nDESCRIPTION: Constructs a chain of endpoint filters by iterating through filter factories in reverse order and applying them to the initial filtered invocation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleComplexTypeParam_StringReturn.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Identity UI Navigation Management\nDESCRIPTION: Static methods for managing navigation in Identity UI pages, including ARIA attributes and CSS classes for different account management sections.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Identity.UI.V5.Pages.Account.Manage.Internal.ManageNavPages.AriaCurrent(Microsoft.AspNetCore.Mvc.Rendering.ViewContext! viewContext, string! page) -> string?\nstatic Microsoft.AspNetCore.Identity.UI.V5.Pages.Account.Manage.Internal.ManageNavPages.PageNavClass(Microsoft.AspNetCore.Mvc.Rendering.ViewContext! viewContext, string! page) -> string?\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a custom attribute 'InterceptsLocationAttribute' used for method interception in the System.Runtime.CompilerServices namespace.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute for Method Interception in C#\nDESCRIPTION: Defines a compiler-generated attribute used for method interception in ASP.NET Core. This attribute is applied to methods and accepts version and data parameters for intercepting method locations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a sealed attribute class used for method interception with version and data parameters. This is part of the compiler services namespace.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_NoParam_StringReturn.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core HTTP Infrastructure Types\nDESCRIPTION: Core HTTP types including ConnectionInfo, CookieBuilder, and exception classes for handling HTTP-related functionality in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nMicrosoft.AspNetCore.Http.BadHttpRequestException\nMicrosoft.AspNetCore.Http.BadHttpRequestException.BadHttpRequestException(string! message) -> void\nMicrosoft.AspNetCore.Http.ConnectionInfo\nMicrosoft.AspNetCore.Http.CookieBuilder\n```\n\n----------------------------------------\n\nTITLE: Mapping Core Route Handler in ASP.NET Core\nDESCRIPTION: Internal method for mapping a route handler to an endpoint. It takes various parameters including the route pattern, handler delegate, and HTTP methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft Account Authentication Package in .NET\nDESCRIPTION: Command to install the Microsoft.AspNetCore.Authentication.MicrosoftAccount NuGet package using the .NET CLI.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/MicrosoftAccount/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.Authentication.MicrosoftAccount\n```\n\n----------------------------------------\n\nTITLE: JSON Response Writer Implementation in ASP.NET Core\nDESCRIPTION: Handles writing JSON responses with polymorphism support and type checking. Uses JsonTypeInfo to determine serialization approach.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleComplexTypeParam_StringReturn.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Twitter Access Tokens in C#\nDESCRIPTION: Defines the AccessToken class for storing and managing Twitter access tokens, including properties for screen name and user ID.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Twitter/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.Twitter.AccessToken\nMicrosoft.AspNetCore.Authentication.Twitter.AccessToken.AccessToken() -> void\nMicrosoft.AspNetCore.Authentication.Twitter.AccessToken.ScreenName.get -> string!\nMicrosoft.AspNetCore.Authentication.Twitter.AccessToken.ScreenName.set -> void\nMicrosoft.AspNetCore.Authentication.Twitter.AccessToken.UserId.get -> string!\nMicrosoft.AspNetCore.Authentication.Twitter.AccessToken.UserId.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining IHttpAuthenticationFeature Interface in ASP.NET Core\nDESCRIPTION: This code snippet defines the IHttpAuthenticationFeature interface in the Microsoft.AspNetCore.Http.Features.Authentication namespace. It provides a property for accessing and setting the user's ClaimsPrincipal.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Features/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Features.Authentication.IHttpAuthenticationFeature\nMicrosoft.AspNetCore.Http.Features.Authentication.IHttpAuthenticationFeature.User.get -> System.Security.Claims.ClaimsPrincipal?\nMicrosoft.AspNetCore.Http.Features.Authentication.IHttpAuthenticationFeature.User.set -> void\n```\n\n----------------------------------------\n\nTITLE: JSRuntime Abstract Method Declarations in C#\nDESCRIPTION: Core abstract methods that must be implemented by JSRuntime classes to enable JavaScript interoperability. These methods handle invoking JavaScript functions and processing callback results from JavaScript to .NET.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/JSInterop/Microsoft.JSInterop/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\nabstract Microsoft.JSInterop.JSInProcessRuntime.InvokeJS(string! identifier, string? argsJson, Microsoft.JSInterop.JSCallResultType resultType, long targetInstanceId) -> string?\nabstract Microsoft.JSInterop.JSRuntime.BeginInvokeJS(long taskId, string! identifier, string? argsJson, Microsoft.JSInterop.JSCallResultType resultType, long targetInstanceId) -> void\nabstract Microsoft.JSInterop.JSRuntime.EndInvokeDotNet(Microsoft.JSInterop.Infrastructure.DotNetInvocationInfo invocationInfo, in Microsoft.JSInterop.Infrastructure.DotNetInvocationResult invocationResult) -> void\n```\n\n----------------------------------------\n\nTITLE: NullHtmlEncoder Unicode Processing Methods\nDESCRIPTION: Method signatures for handling Unicode scalar encoding in the NullHtmlEncoder class. Includes methods for trying to encode Unicode scalars and checking if encoding will occur.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Razor/Razor/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\noverride Microsoft.AspNetCore.Razor.TagHelpers.NullHtmlEncoder.TryEncodeUnicodeScalar(int unicodeScalar, char* buffer, int bufferLength, out int numberOfCharactersWritten) -> bool\noverride Microsoft.AspNetCore.Razor.TagHelpers.NullHtmlEncoder.WillEncode(int unicodeScalar) -> bool\n```\n\n----------------------------------------\n\nTITLE: Overriding DefaultConnectionContext Methods in C#\nDESCRIPTION: This snippet contains method overrides for the DefaultConnectionContext class, including getters and setters for Items, LocalEndPoint, RemoteEndPoint, and Transport properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.Items.get -> System.Collections.Generic.IDictionary<object!, object?>!\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.Items.set -> void\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.LocalEndPoint.get -> System.Net.EndPoint?\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.LocalEndPoint.set -> void\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.RemoteEndPoint.get -> System.Net.EndPoint?\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.RemoteEndPoint.set -> void\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.Transport.get -> System.IO.Pipelines.IDuplexPipe!\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.Transport.set -> void\n```\n\n----------------------------------------\n\nTITLE: Error Logging and Exception Handling in ASP.NET Core\nDESCRIPTION: This helper class provides methods for logging errors or throwing exceptions during request processing. It handles various scenarios like IO exceptions, invalid JSON, parameter binding failures, and content type mismatches.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    // ... (methods for different error scenarios)\n}\n```\n\n----------------------------------------\n\nTITLE: Error Logging and Exception Handling in ASP.NET Core\nDESCRIPTION: This helper class provides methods for logging errors or throwing exceptions during request processing. It handles various scenarios like IO exceptions, invalid JSON, parameter binding failures, and content type mismatches.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    // ... (methods for different error scenarios)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HealthCheckContext Class in C#\nDESCRIPTION: This class represents the context for a health check operation. It includes a property for the health check registration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HealthChecks/Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckContext\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckContext.HealthCheckContext() -> void\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckContext.Registration.get -> Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckRegistration!\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckContext.Registration.set -> void\n```\n\n----------------------------------------\n\nTITLE: Authentication Challenge Methods in ASP.NET Core ControllerBase (C#)\nDESCRIPTION: Methods to return authentication challenges to the client. These methods prompt the user to authenticate with specific authentication schemes and optionally provide authentication properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Challenge(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, params string![]! authenticationSchemes) -> Microsoft.AspNetCore.Mvc.ChallengeResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Challenge(params string![]! authenticationSchemes) -> Microsoft.AspNetCore.Mvc.ChallengeResult!\n```\n\n----------------------------------------\n\nTITLE: Running Tests for the WsFederation Authentication Project\nDESCRIPTION: Command to execute the test suite for the WsFederation authentication project. This should be run from the parent 'security' directory with the -t flag to trigger test execution.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/WsFederation/src/README.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd -t\n```\n\n----------------------------------------\n\nTITLE: Configuring NuGet Sources for .NET 10 Daily Builds\nDESCRIPTION: XML configuration for NuGet.Config file to enable .NET 10 daily builds. Specifies package sources including the dotnet10 Azure DevOps feed and NuGet.org.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/DailyBuilds.md#2025-04-08_snippet_2\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n    <packageSources>\n        <clear />\n        <add key=\"dotnet10\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet10/nuget/v3/index.json\" />\n        <add key=\"NuGet.org\" value=\"https://api.nuget.org/v3/index.json\" />\n    </packageSources>\n</configuration>\n```\n\n----------------------------------------\n\nTITLE: WebApplicationFactoryClientOptions Class Definition\nDESCRIPTION: Configuration options for WebApplicationFactory clients including redirect handling and cookie management settings\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Testing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Testing.WebApplicationFactoryClientOptions.AllowAutoRedirect.get -> bool\nMicrosoft.AspNetCore.Mvc.Testing.WebApplicationFactoryClientOptions.BaseAddress.get -> System.Uri!\nMicrosoft.AspNetCore.Mvc.Testing.WebApplicationFactoryClientOptions.HandleCookies.get -> bool\nMicrosoft.AspNetCore.Mvc.Testing.WebApplicationFactoryClientOptions.MaxAutomaticRedirections.get -> int\n```\n\n----------------------------------------\n\nTITLE: DefaultAuthorizationHandlerContextFactory Class Definition in C#\nDESCRIPTION: Definition of the DefaultAuthorizationHandlerContextFactory class that creates AuthorizationHandlerContext instances.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.DefaultAuthorizationHandlerContextFactory\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.DefaultAuthorizationHandlerContextFactory.DefaultAuthorizationHandlerContextFactory() -> void\n```\n\n----------------------------------------\n\nTITLE: LinkParser and MatcherPolicy Extensions for ASP.NET Core Routing\nDESCRIPTION: Extensions for LinkParser to parse paths by endpoint name, and utility methods for MatcherPolicy to detect dynamic endpoints. These methods are used in the ASP.NET Core routing infrastructure.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName(this Microsoft.AspNetCore.Routing.LinkParser! parser, string! endpointName, Microsoft.AspNetCore.Http.PathString path) -> Microsoft.AspNetCore.Routing.RouteValueDictionary?\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.MatcherPolicy.ContainsDynamicEndpoints(System.Collections.Generic.IReadOnlyList<Microsoft.AspNetCore.Http.Endpoint!>! endpoints) -> bool\n```\n\n----------------------------------------\n\nTITLE: JSON Type Information Polymorphism Check\nDESCRIPTION: Extension method that determines if the JsonTypeInfo has known polymorphism based on type properties or explicit polymorphism options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n```\n\n----------------------------------------\n\nTITLE: Checking for Known Polymorphism in JsonTypeInfo\nDESCRIPTION: Determines if a JsonTypeInfo has known polymorphism based on its type characteristics.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n```\n\n----------------------------------------\n\nTITLE: Defining IHtmlGenerator Interface Methods in C#\nDESCRIPTION: This snippet outlines the method signatures for the IHtmlGenerator interface, which is responsible for generating HTML elements in ASP.NET Core MVC views.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ViewFeatures.IHtmlGenerator.GenerateRouteLink(Microsoft.AspNetCore.Mvc.Rendering.ViewContext viewContext, string linkText, string routeName, string protocol, string hostName, string fragment, object routeValues, object htmlAttributes) -> Microsoft.AspNetCore.Mvc.Rendering.TagBuilder\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ViewFeatures.IHtmlGenerator.GenerateSelect(Microsoft.AspNetCore.Mvc.Rendering.ViewContext viewContext, Microsoft.AspNetCore.Mvc.ViewFeatures.ModelExplorer modelExplorer, string optionLabel, string expression, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Mvc.Rendering.SelectListItem> selectList, bool allowMultiple, object htmlAttributes) -> Microsoft.AspNetCore.Mvc.Rendering.TagBuilder\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants for HTTP Responses in ASP.NET Core\nDESCRIPTION: Defines common content type constants used throughout the ASP.NET Core framework for different types of HTTP responses like JSON, plaintext, form data, and form URL-encoded content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleNullableStringParam_WithEmptyQueryStringValueProvided_StringReturn.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GET Endpoint Mapping for ASP.NET Core\nDESCRIPTION: This snippet defines a method for mapping GET endpoints in ASP.NET Core, including metadata population and request delegate creation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet4(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        options.EndpointBuilder.Metadata.Add(new AcceptsMetadata(contentTypes: GeneratedMetadataConstants.JsonContentType));\n    };\n```\n\n----------------------------------------\n\nTITLE: Resolving HTTP Request Body as Typed Object in ASP.NET Core\nDESCRIPTION: Attempts to read and deserialize the request body into a strongly-typed object. Handles validation, content type checking, and error reporting for JSON deserialization failures.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static async ValueTask<(bool, T?)> TryResolveBodyAsync<T>(HttpContext httpContext, LogOrThrowExceptionHelper logOrThrowExceptionHelper, bool allowEmpty, string parameterTypeName, string parameterName, JsonTypeInfo<T> jsonTypeInfo, bool isInferred = false)\n{\n    var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();\n    T? bodyValue = default;\n    var bodyValueSet = false;\n\n    if (feature?.CanHaveBody == true)\n    {\n        if (!httpContext.Request.HasJsonContentType())\n        {\n            logOrThrowExceptionHelper.UnexpectedJsonContentType(httpContext.Request.ContentType);\n            httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;\n            return (false, default);\n        }\n        try\n        {\n            bodyValue = await httpContext.Request.ReadFromJsonAsync(jsonTypeInfo);\n            bodyValueSet = bodyValue != null;\n        }\n        catch (BadHttpRequestException badHttpRequestException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(badHttpRequestException);\n            httpContext.Response.StatusCode = badHttpRequestException.StatusCode;\n            return (false, default);\n        }\n        catch (IOException ioException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(ioException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n        catch (System.Text.Json.JsonException jsonException)\n        {\n            logOrThrowExceptionHelper.InvalidJsonRequestBody(parameterTypeName, parameterName, jsonException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n    }\n\n    if (!allowEmpty && !bodyValueSet)\n    {\n        if (!isInferred)\n        {\n            logOrThrowExceptionHelper.RequiredParameterNotProvided(parameterTypeName, parameterName, \"body\");\n        }\n        else\n        {\n            logOrThrowExceptionHelper.ImplicitBodyNotProvided(parameterName);\n        }\n        httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n        return (false, bodyValue);\n    }\n\n    return (true, bodyValue);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Filtered Request Handler in ASP.NET Core\nDESCRIPTION: Implementation of a filtered request handler that processes HTTP requests with endpoint filters. Binds parameters asynchronously, sets status codes for validation failures, and handles result execution.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandlerFiltered(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var myBindAsyncParam_local = await global::Microsoft.AspNetCore.Http.Generators.Tests.MyNullableBindAsyncStruct.BindAsync(httpContext, parameters[0]);\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n    }\n    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.MyNullableBindAsyncStruct?>(httpContext, myBindAsyncParam_local));\n    if (result is not null)\n    {\n        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP.sys Timeout Manager Class in C#\nDESCRIPTION: Class for configuring various HTTP.sys timeouts, including entity body, connection idle, header wait, and minimum send bytes per second settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/HttpSys/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Server.HttpSys.TimeoutManager\nMicrosoft.AspNetCore.Server.HttpSys.TimeoutManager.DrainEntityBody.get -> System.TimeSpan\nMicrosoft.AspNetCore.Server.HttpSys.TimeoutManager.DrainEntityBody.set -> void\nMicrosoft.AspNetCore.Server.HttpSys.TimeoutManager.EntityBody.get -> System.TimeSpan\nMicrosoft.AspNetCore.Server.HttpSys.TimeoutManager.EntityBody.set -> void\nMicrosoft.AspNetCore.Server.HttpSys.TimeoutManager.HeaderWait.get -> System.TimeSpan\nMicrosoft.AspNetCore.Server.HttpSys.TimeoutManager.HeaderWait.set -> void\nMicrosoft.AspNetCore.Server.HttpSys.TimeoutManager.IdleConnection.get -> System.TimeSpan\nMicrosoft.AspNetCore.Server.HttpSys.TimeoutManager.IdleConnection.set -> void\nMicrosoft.AspNetCore.Server.HttpSys.TimeoutManager.MinSendBytesPerSecond.get -> long\nMicrosoft.AspNetCore.Server.HttpSys.TimeoutManager.MinSendBytesPerSecond.set -> void\nMicrosoft.AspNetCore.Server.HttpSys.TimeoutManager.RequestQueue.get -> System.TimeSpan\nMicrosoft.AspNetCore.Server.HttpSys.TimeoutManager.RequestQueue.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining Static Methods for HealthCheckResult in C#\nDESCRIPTION: These static methods provide convenient ways to create HealthCheckResult instances for different health statuses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HealthChecks/Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult.Degraded(string? description = null, System.Exception? exception = null, System.Collections.Generic.IReadOnlyDictionary<string!, object!>? data = null) -> Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult\nstatic Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult.Healthy(string? description = null, System.Collections.Generic.IReadOnlyDictionary<string!, object!>? data = null) -> Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult\nstatic Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult.Unhealthy(string? description = null, System.Exception? exception = null, System.Collections.Generic.IReadOnlyDictionary<string!, object!>? data = null) -> Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult\n```\n\n----------------------------------------\n\nTITLE: Implementing MediaTypeHeaderValue Class in C#\nDESCRIPTION: Defines the MediaTypeHeaderValue class for handling Media-Type headers, including various properties and methods for media type manipulation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Headers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Net.Http.Headers.MediaTypeHeaderValue\nMicrosoft.Net.Http.Headers.MediaTypeHeaderValue.Boundary.get -> Microsoft.Extensions.Primitives.StringSegment\nMicrosoft.Net.Http.Headers.MediaTypeHeaderValue.Boundary.set -> void\nMicrosoft.Net.Http.Headers.MediaTypeHeaderValue.Charset.get -> Microsoft.Extensions.Primitives.StringSegment\nMicrosoft.Net.Http.Headers.MediaTypeHeaderValue.Charset.set -> void\n// ... (additional properties and methods)\n```\n\n----------------------------------------\n\nTITLE: Defining StackExchangeRedisCacheServiceCollectionExtensions in C#\nDESCRIPTION: Defines extension methods for IServiceCollection to add Redis caching services. It includes a method for configuring and adding Redis caching to the dependency injection container.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.DependencyInjection.StackExchangeRedisCacheServiceCollectionExtensions\nstatic Microsoft.Extensions.DependencyInjection.StackExchangeRedisCacheServiceCollectionExtensions.AddStackExchangeRedisCache(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions!>! setupAction) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Request Error Logging Helper\nDESCRIPTION: Helper class for logging or throwing exceptions during request processing. Handles various error scenarios like invalid JSON, parameter binding failures, and missing required parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    // Additional methods omitted for brevity...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AuthorizationResult in C#\nDESCRIPTION: This class represents the result of an authorization evaluation, indicating whether the authorization succeeded or failed.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationResult\nMicrosoft.AspNetCore.Authorization.AuthorizationResult.Failure.get -> Microsoft.AspNetCore.Authorization.AuthorizationFailure?\nMicrosoft.AspNetCore.Authorization.AuthorizationResult.Succeeded.get -> bool\n```\n\n----------------------------------------\n\nTITLE: Creating Twitter Authentication Tickets in C#\nDESCRIPTION: Defines the TwitterCreatingTicketContext class for creating authentication tickets during the Twitter authentication process, including properties for access token, user details, and other relevant information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Twitter/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterCreatingTicketContext\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterCreatingTicketContext.AccessToken.get -> string!\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterCreatingTicketContext.AccessTokenSecret.get -> string!\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterCreatingTicketContext.ScreenName.get -> string!\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterCreatingTicketContext.TwitterCreatingTicketContext(Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Authentication.AuthenticationScheme! scheme, Microsoft.AspNetCore.Authentication.Twitter.TwitterOptions! options, System.Security.Claims.ClaimsPrincipal! principal, Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, string! userId, string! screenName, string! accessToken, string! accessTokenSecret, System.Text.Json.JsonElement user) -> void\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterCreatingTicketContext.User.get -> System.Text.Json.JsonElement\nMicrosoft.AspNetCore.Authentication.Twitter.TwitterCreatingTicketContext.UserId.get -> string!\n```\n\n----------------------------------------\n\nTITLE: Illustrating New Dependency Flow After Consolidation\nDESCRIPTION: Demonstrates the new dependency flow between runtime, aspnetcore, SDK, extensions, and aspnetcore-tooling after the consolidation process.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/tooling-consolidation.md#2025-04-08_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nruntime +--> aspnetcore +--> SDK\n        \\               \\\n         +-> extensions -+-> aspnetcore-tooling\n```\n\n----------------------------------------\n\nTITLE: Running Helix Tests Locally with PowerShell\nDESCRIPTION: PowerShell command to execute Helix tests for a specific test project. This script handles restoration, publishing, and uploading the job to Helix.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Helix.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n.\\eng\\scripts\\RunHelix.ps1 -Project path\\mytestproject.csproj\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Methods for UserStoreBase with Role Management in C#\nDESCRIPTION: This snippet defines additional abstract methods for the UserStoreBase class that include role management functionality. It includes methods for adding users to roles, finding roles, and querying users in roles.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Stores/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.AddToRoleAsync(TUser! user, string! normalizedRoleName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.FindRoleAsync(string! normalizedRoleName, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TRole?>!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.FindUserRoleAsync(TKey userId, TKey roleId, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TUserRole?>!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.GetRolesAsync(TUser! user, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<System.Collections.Generic.IList<string!>!>!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.GetUsersInRoleAsync(string! normalizedRoleName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<System.Collections.Generic.IList<TUser!>!>!\n```\n\n----------------------------------------\n\nTITLE: Defining AuthorizationOptions in C#\nDESCRIPTION: This class represents the options for configuring authorization in ASP.NET Core applications, including default policies and policy management methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.AddPolicy(string! name, Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy) -> void\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.AddPolicy(string! name, System.Action<Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!>! configurePolicy) -> void\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.AuthorizationOptions() -> void\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.DefaultPolicy.get -> Microsoft.AspNetCore.Authorization.AuthorizationPolicy!\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.DefaultPolicy.set -> void\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.FallbackPolicy.get -> Microsoft.AspNetCore.Authorization.AuthorizationPolicy?\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.FallbackPolicy.set -> void\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.GetPolicy(string! name) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicy?\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.InvokeHandlersAfterFailure.get -> bool\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.InvokeHandlersAfterFailure.set -> void\n```\n\n----------------------------------------\n\nTITLE: Exception Classes for HTTP Connections in ASP.NET Core (C#)\nDESCRIPTION: Defines exception classes for HTTP connection failures, including NoTransportSupportedException and TransportFailedException with their constructors and properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Http.Connections.Client/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Connections.Client.NoTransportSupportedException\nMicrosoft.AspNetCore.Http.Connections.Client.NoTransportSupportedException.NoTransportSupportedException(string! message) -> void\nMicrosoft.AspNetCore.Http.Connections.Client.TransportFailedException\nMicrosoft.AspNetCore.Http.Connections.Client.TransportFailedException.TransportFailedException(string! transportType, string! message, System.Exception? innerException = null) -> void\nMicrosoft.AspNetCore.Http.Connections.Client.TransportFailedException.TransportType.get -> string!\n```\n\n----------------------------------------\n\nTITLE: Defining Form Content Type Logger in ASP.NET Core\nDESCRIPTION: Creates a structured logger for unexpected form content type scenarios using LoggerMessage.Define. Establishes a logging delegate that captures the unexpected content type received when a form content type was expected.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: JSON Type Polymorphism Detection Extension Methods\nDESCRIPTION: Extension methods to determine if a JsonTypeInfo has known polymorphism options or should be used with a specific runtime type. These help optimize JSON serialization in ASP.NET Core API responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\n----------------------------------------\n\nTITLE: User Management Methods in ASP.NET Core Identity\nDESCRIPTION: Virtual methods for managing users in ASP.NET Core Identity, including authentication, password management, and user claims.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Identity.UserManager<TUser>.CreateAsync(TUser! user) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\nvirtual Microsoft.AspNetCore.Identity.UserManager<TUser>.AddPasswordAsync(TUser! user, string! password) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\nvirtual Microsoft.AspNetCore.Identity.UserManager<TUser>.CheckPasswordAsync(TUser! user, string! password) -> System.Threading.Tasks.Task<bool>!\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata in ASP.NET Core\nDESCRIPTION: Represents metadata for binding parameters in request handlers. Tracks properties like parameter name, reflection info, binding capabilities (TryParse, BindAsync), and optionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NavLink Component in C#\nDESCRIPTION: Defines the NavLink component for creating navigation links in ASP.NET Core applications. It includes properties for managing active states and CSS classes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Routing.NavLink\nMicrosoft.AspNetCore.Components.Routing.NavLink.ActiveClass.get -> string?\nMicrosoft.AspNetCore.Components.Routing.NavLink.ActiveClass.set -> void\nMicrosoft.AspNetCore.Components.Routing.NavLink.AdditionalAttributes.get -> System.Collections.Generic.IReadOnlyDictionary<string!, object!>?\nMicrosoft.AspNetCore.Components.Routing.NavLink.AdditionalAttributes.set -> void\nMicrosoft.AspNetCore.Components.Routing.NavLink.ChildContent.get -> Microsoft.AspNetCore.Components.RenderFragment?\nMicrosoft.AspNetCore.Components.Routing.NavLink.ChildContent.set -> void\nMicrosoft.AspNetCore.Components.Routing.NavLink.CssClass.get -> string?\nMicrosoft.AspNetCore.Components.Routing.NavLink.CssClass.set -> void\nMicrosoft.AspNetCore.Components.Routing.NavLink.Dispose() -> void\nMicrosoft.AspNetCore.Components.Routing.NavLink.Match.get -> Microsoft.AspNetCore.Components.Routing.NavLinkMatch\nMicrosoft.AspNetCore.Components.Routing.NavLink.Match.set -> void\nMicrosoft.AspNetCore.Components.Routing.NavLink.NavLink() -> void\n```\n\n----------------------------------------\n\nTITLE: OptionTagHelper Class Signatures in ASP.NET Core MVC\nDESCRIPTION: API signatures for the OptionTagHelper class that generates HTML option elements for select lists. It handles value generation and selection state based on the associated model.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.TagHelpers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n~Microsoft.AspNetCore.Mvc.TagHelpers.OptionTagHelper.Generator.get -> Microsoft.AspNetCore.Mvc.ViewFeatures.IHtmlGenerator\n~Microsoft.AspNetCore.Mvc.TagHelpers.OptionTagHelper.OptionTagHelper(Microsoft.AspNetCore.Mvc.ViewFeatures.IHtmlGenerator generator) -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.OptionTagHelper.Value.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.OptionTagHelper.Value.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.OptionTagHelper.ViewContext.get -> Microsoft.AspNetCore.Mvc.Rendering.ViewContext\n```\n\n----------------------------------------\n\nTITLE: EmptyHttpResult Instance Property in ASP.NET Core\nDESCRIPTION: Static accessor for the singleton instance of EmptyHttpResult, which represents an empty HTTP result in ASP.NET Core's minimal API endpoints.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.HttpResults.EmptyHttpResult.Instance.get -> Microsoft.AspNetCore.Http.HttpResults.EmptyHttpResult!\n```\n\n----------------------------------------\n\nTITLE: AccessToken Class Definition in C#\nDESCRIPTION: Class definition for managing access tokens including properties for expiration, granted scopes, and token value.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.AccessToken\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.AccessToken.AccessToken() -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.AccessToken.Expires.get -> System.DateTimeOffset\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.AccessToken.Expires.set -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.AccessToken.GrantedScopes.get -> System.Collections.Generic.IReadOnlyList<string!>!\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.AccessToken.GrantedScopes.set -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.AccessToken.Value.get -> string!\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.AccessToken.Value.set -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring Database Error Page Middleware in ASP.NET Core (C#)\nDESCRIPTION: Extension methods for adding Database Error Page middleware to the ASP.NET Core request pipeline. This middleware displays detailed database error information during development when Entity Framework migrations are pending or database connections fail.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics.EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.DatabaseErrorPageExtensions.UseDatabaseErrorPage(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.DatabaseErrorPageExtensions.UseDatabaseErrorPage(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app, Microsoft.AspNetCore.Builder.DatabaseErrorPageOptions! options) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected JSON Content Type in ASP.NET Core\nDESCRIPTION: Manages cases where an unexpected JSON content type is received. Takes content type as input and either throws a 415 status code exception or logs the error.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndPut_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedJsonContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for ASP.NET Core Build Artifacts\nDESCRIPTION: Directory tree showing the organization of build outputs including installers, logs, packages, symbols, and Visual Studio extensions. Artifacts are grouped by type and configuration with detailed explanations of file types and their intended usage.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Artifacts.md#2025-04-08_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nartifacts/\n  installers/\n    $(Configuration)/\n      *.msi            = Windows installers\n      *.deb, *.rpm     = Linux installers\n      *.zip, *.tar.gz  = archives versions of installers\n  log/\n    runningProcesses*.txt = Process list from just before build completed\n    runningProcesses*.bak = Process list from two minutes before runningProcesses*.txt files were written\n    *.binlog           = Binary logs for a few build phases e.g. site extension build\n    **/\n      *.log            = Log files for test runs and individual tests\n    $(Configuration)/\n      *.binlog         = Binary logs for most build phases\n  packages/\n    $(Configuration)/\n      Shipping/        = Packages which are intended for use by customers. These, along with installers, represent the 'product'.\n        *.nupkg        = NuGet packages which ship to nuget.org\n        *.jar          = Java packages which ship to Maven Central and others\n        *.tgz          = NPM packages which ship to npmjs.org\n      NonShipping/\n        *.nupkg        = NuGet packages for internal use only. Used to hand off bits to Microsoft partner teams. Not intended for use by customers.\n  symbols/\n    $(Configuration)/\n      $(TargetFramework)/\n        *.pdb          = Loose symbol files for symbol server publication. Special cases where *.symbols.nupkg packaging is cumbersome.\n  VSSetup/\n    $(Configuration)/\n      *.vsix           = Visual Studio extensions. None currently exist.\n```\n\n----------------------------------------\n\nTITLE: Implementing Simple Event Pattern in C#\nDESCRIPTION: Shows a simplified event implementation for cases with simple payloads and no counter integration. Demonstrates direct event writing with basic enabled state checking.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/EventSourceAndCounters.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[Event(eventId: 42, Level = EventLevel.Informational)]\npublic void SomethingHappened(string payloadValue)\n{\n  if (IsEnabled(EventLevel.Informational, EventKeywords.None))\n  {\n    WriteEvent(42, payloadValue);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IHealthCheck Interface in C#\nDESCRIPTION: This interface defines the contract for implementing a health check. It includes a method for checking health asynchronously.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HealthChecks/Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Diagnostics.HealthChecks.IHealthCheck\nMicrosoft.Extensions.Diagnostics.HealthChecks.IHealthCheck.CheckHealthAsync(Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckContext! context, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult>!\n```\n\n----------------------------------------\n\nTITLE: Defining AuthenticationFailedContext Class in C#\nDESCRIPTION: This class represents the context for authentication failure in OpenID Connect. It includes properties for the exception and protocol message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthenticationFailedContext\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthenticationFailedContext.AuthenticationFailedContext(Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Authentication.AuthenticationScheme! scheme, Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectOptions! options) -> void\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthenticationFailedContext.Exception.get -> System.Exception!\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthenticationFailedContext.Exception.set -> void\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthenticationFailedContext.ProtocolMessage.get -> Microsoft.IdentityModel.Protocols.OpenIdConnect.OpenIdConnectMessage!\nMicrosoft.AspNetCore.Authentication.OpenIdConnect.AuthenticationFailedContext.ProtocolMessage.set -> void\n```\n\n----------------------------------------\n\nTITLE: Mapping Core Route Handler in ASP.NET Core\nDESCRIPTION: This method maps a route handler to the endpoint route builder. It takes various parameters including the route pattern, handler delegate, HTTP methods, and functions for populating metadata and creating the request delegate.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Class for ASP.NET Core Request Delegation\nDESCRIPTION: Implementation of IParameterBindingMetadata that stores information about request parameter binding, including parameter name, type information, parsing capabilities, and optionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Navigation Management Methods in ASP.NET Core Blazor\nDESCRIPTION: Virtual methods for managing navigation in Blazor applications, including handling location changes, navigation locking, and page refreshing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.NavigationManager.EnsureInitialized() -> void\nvirtual Microsoft.AspNetCore.Components.NavigationManager.HandleLocationChangingHandlerException(System.Exception! ex, Microsoft.AspNetCore.Components.Routing.LocationChangingContext! context) -> void\nvirtual Microsoft.AspNetCore.Components.NavigationManager.NavigateToCore(string! uri, bool forceLoad) -> void\nvirtual Microsoft.AspNetCore.Components.NavigationManager.NavigateToCore(string! uri, Microsoft.AspNetCore.Components.NavigationOptions options) -> void\nvirtual Microsoft.AspNetCore.Components.NavigationManager.Refresh(bool forceReload = false) -> void\nvirtual Microsoft.AspNetCore.Components.NavigationManager.SetNavigationLockState(bool value) -> void\n```\n\n----------------------------------------\n\nTITLE: Building Endpoint Filter Chain in ASP.NET Core\nDESCRIPTION: Creates an endpoint filter chain by applying filters in reverse order. It processes the endpoint builder's filter factories to create a composite filter delegate.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping GET Request with Optional and Required Parameters in ASP.NET Core\nDESCRIPTION: This snippet defines a method to map a GET request with both optional and required service parameters. It includes metadata population and request delegate creation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitServiceParam_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet2(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"svc\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: true));\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"svcs\", parameters[1], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n        Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n        var handler = Cast(del, global::System.String (global::Microsoft.AspNetCore.Http.Generators.Tests.TestService? arg0, global::System.Collections.Generic.IEnumerable<global::Microsoft.AspNetCore.Http.Generators.Tests.TestService> arg1) => throw null!);\n        EndpointFilterDelegate? filteredInvocation = null;\n        var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n        var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n        var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n        var jsonSerializerOptions = jsonOptions.SerializerOptions;\n        jsonSerializerOptions.MakeReadOnly();\n        var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n\n        if (options.EndpointBuilder.FilterFactories.Count > 0)\n        {\n            filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n            {\n                if (ic.HttpContext.Response.StatusCode == 400)\n                {\n                    return ValueTask.FromResult<object?>(Results.Empty);\n                }\n                return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.TestService?>(0)!, ic.GetArgument<global::System.Collections.Generic.IEnumerable<global::Microsoft.AspNetCore.Http.Generators.Tests.TestService>>(1)!));\n            },\n            options.EndpointBuilder,\n            handler.Method);\n        }\n\n        Task RequestHandler(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            // Endpoint Parameter: svc (Type = Microsoft.AspNetCore.Http.Generators.Tests.TestService?, IsOptional = True, IsParsable = False, IsArray = False, Source = Service)\n            var svc_local = httpContext.RequestServices.GetService<global::Microsoft.AspNetCore.Http.Generators.Tests.TestService?>();;\n            // Endpoint Parameter: svcs (Type = System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Http.Generators.Tests.TestService>, IsOptional = False, IsParsable = False, IsArray = False, Source = Service)\n        }\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TagHelperContent Class in C#\nDESCRIPTION: This snippet defines the TagHelperContent class and its derived DefaultTagHelperContent class. These classes are used to manage the content of tag helpers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Razor/Razor.Runtime/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Razor.TagHelpers.TagHelperContent\nMicrosoft.AspNetCore.Razor.TagHelpers.TagHelperContent.TagHelperContent() -> void\noverride Microsoft.AspNetCore.Razor.TagHelpers.DefaultTagHelperContent.IsEmptyOrWhiteSpace.get -> bool\noverride Microsoft.AspNetCore.Razor.TagHelpers.DefaultTagHelperContent.IsModified.get -> bool\noverride Microsoft.AspNetCore.Razor.TagHelpers.DefaultTagHelperContent.Reinitialize() -> void\n```\n\n----------------------------------------\n\nTITLE: Delegate Casting Utility in ASP.NET Core\nDESCRIPTION: Helper method that casts a generic delegate to a specific delegate type. This is used during endpoint registration to ensure type safety.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n```\n\n----------------------------------------\n\nTITLE: Authentication Handler Classes in C#\nDESCRIPTION: Definitions for authorization message handlers and authentication state management classes with their respective methods and properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.AuthorizationMessageHandler\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.AuthorizationMessageHandler.AuthorizationMessageHandler(IAccessTokenProvider! provider, NavigationManager! navigation) -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.AuthorizationMessageHandler.ConfigureHandler(IEnumerable<string!>! authorizedUrls, IEnumerable<string!>? scopes = null, string? returnUrl = null) -> AuthorizationMessageHandler!\n\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.BaseAddressAuthorizationMessageHandler\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.BaseAddressAuthorizationMessageHandler.BaseAddressAuthorizationMessageHandler(IAccessTokenProvider! provider, NavigationManager! navigationManager) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining AnalysisStartupFilter for ASP.NET Core Middleware Analysis in C#\nDESCRIPTION: This snippet defines the AnalysisStartupFilter class, which is used to configure the application's middleware pipeline with analysis capabilities. It includes a Configure method that wraps the existing middleware configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/MiddlewareAnalysis/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.MiddlewareAnalysis.AnalysisStartupFilter\nMicrosoft.AspNetCore.MiddlewareAnalysis.AnalysisStartupFilter.AnalysisStartupFilter() -> void\nMicrosoft.AspNetCore.MiddlewareAnalysis.AnalysisStartupFilter.Configure(System.Action<Microsoft.AspNetCore.Builder.IApplicationBuilder!>! next) -> System.Action<Microsoft.AspNetCore.Builder.IApplicationBuilder!>!\n```\n\n----------------------------------------\n\nTITLE: Executing Async Response in ASP.NET Core\nDESCRIPTION: This method handles the execution of different types of responses asynchronously. It supports IResult, string, and JSON responses, choosing the appropriate write method based on the response type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CacheControlHeaderValue Class in C#\nDESCRIPTION: Defines the CacheControlHeaderValue class with properties for various cache control directives.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Headers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Net.Http.Headers.CacheControlHeaderValue\nMicrosoft.Net.Http.Headers.CacheControlHeaderValue.CacheControlHeaderValue() -> void\nMicrosoft.Net.Http.Headers.CacheControlHeaderValue.Extensions.get -> System.Collections.Generic.IList<Microsoft.Net.Http.Headers.NameValueHeaderValue!>!\nMicrosoft.Net.Http.Headers.CacheControlHeaderValue.MaxAge.get -> System.TimeSpan?\nMicrosoft.Net.Http.Headers.CacheControlHeaderValue.MaxAge.set -> void\n// ... (additional properties)\n```\n\n----------------------------------------\n\nTITLE: Route Constraint and Default Value Processing in ASP.NET Core\nDESCRIPTION: These static methods handle the processing of route constraints and default values for ASP.NET Core routing. They work with route templates and inline constraint resolvers to build the necessary dictionaries for route matching.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.RouteBase.GetConstraints(Microsoft.AspNetCore.Routing.IInlineConstraintResolver! inlineConstraintResolver, Microsoft.AspNetCore.Routing.Template.RouteTemplate! parsedTemplate, System.Collections.Generic.IDictionary<string!, object!>? constraints) -> System.Collections.Generic.IDictionary<string!, Microsoft.AspNetCore.Routing.IRouteConstraint!>!\n\nstatic Microsoft.AspNetCore.Routing.RouteBase.GetDefaults(Microsoft.AspNetCore.Routing.Template.RouteTemplate! parsedTemplate, Microsoft.AspNetCore.Routing.RouteValueDictionary? defaults) -> Microsoft.AspNetCore.Routing.RouteValueDictionary!\n```\n\n----------------------------------------\n\nTITLE: Displaying MVC Diagnostic Codes in Markdown\nDESCRIPTION: A markdown table listing MVC-specific diagnostic codes (MVC1000-MVC1006) with their corresponding descriptions. These codes cover various MVC-related warnings and best practices.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/list-of-diagnostics.md#2025-04-08_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n### MVC (`MVC1000` - `MVC1006`)\n\n| Diagnostic ID     | Description |\n| :---------------- | :---------- |\n|  __`MVC1000`__ | Use of IHtmlHelper.{0} should be avoided |\n|  __`MVC1001`__ | Filters cannot be applied to page handler methods |\n|  __`MVC1002`__ | Route attributes cannot be applied to page handler methods |\n|  __`MVC1003`__ | Route attributes cannot be applied to page models |\n|  __`MVC1004`__ | Rename model bound parameter |\n|  __`MVC1005`__ | Cannot use UseMvc with Endpoint Routing |\n|  __`MVC1006`__ | Methods containing TagHelpers must be async and return Task |\n```\n\n----------------------------------------\n\nTITLE: Defining IHealthCheckPublisher Interface in C#\nDESCRIPTION: This interface defines the contract for publishing health reports. It includes a method for publishing health reports asynchronously.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HealthChecks/Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Diagnostics.HealthChecks.IHealthCheckPublisher\nMicrosoft.Extensions.Diagnostics.HealthChecks.IHealthCheckPublisher.PublishAsync(Microsoft.Extensions.Diagnostics.HealthChecks.HealthReport! report, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining WsFederation Authentication Events in C#\nDESCRIPTION: This snippet defines the WsFederationEvents class with virtual methods for various authentication events. These events can be overridden to customize the authentication process.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/WsFederation/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n~virtual Microsoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.AuthenticationFailed(Microsoft.AspNetCore.Authentication.WsFederation.AuthenticationFailedContext context) -> System.Threading.Tasks.Task\n~virtual Microsoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.MessageReceived(Microsoft.AspNetCore.Authentication.WsFederation.MessageReceivedContext context) -> System.Threading.Tasks.Task\n~virtual Microsoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.RedirectToIdentityProvider(Microsoft.AspNetCore.Authentication.WsFederation.RedirectContext context) -> System.Threading.Tasks.Task\n~virtual Microsoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.RemoteSignOut(Microsoft.AspNetCore.Authentication.WsFederation.RemoteSignOutContext context) -> System.Threading.Tasks.Task\n~virtual Microsoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.SecurityTokenReceived(Microsoft.AspNetCore.Authentication.WsFederation.SecurityTokenReceivedContext context) -> System.Threading.Tasks.Task\n~virtual Microsoft.AspNetCore.Authentication.WsFederation.WsFederationEvents.SecurityTokenValidated(Microsoft.AspNetCore.Authentication.WsFederation.SecurityTokenValidatedContext context) -> System.Threading.Tasks.Task\n```\n\n----------------------------------------\n\nTITLE: ClientErrorResultFilterConvention Class Definition in ASP.NET Core MVC\nDESCRIPTION: A convention that applies client error result filters to actions in the MVC application model.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ClientErrorResultFilterConvention\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ClientErrorResultFilterConvention.Apply(Microsoft.AspNetCore.Mvc.ApplicationModels.ActionModel! action) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ClientErrorResultFilterConvention.ClientErrorResultFilterConvention() -> void\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Implementation\nDESCRIPTION: Implements IParameterBindingMetadata interface to store parameter binding information including name, type info, and binding capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n    public bool HasTryParse { get; }\n    public bool HasBindAsync { get; }\n    public ParameterInfo ParameterInfo { get; }\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core HTTP Abstract Classes and Status Codes\nDESCRIPTION: Defines abstract members and status code constants for handling HTTP requests and responses in ASP.NET Core applications. Includes connection info, request/response objects, websocket management, and standard HTTP status codes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\nabstract Microsoft.AspNetCore.Builder.EndpointBuilder.Build() -> Microsoft.AspNetCore.Http.Endpoint!\nabstract Microsoft.AspNetCore.Http.ConnectionInfo.ClientCertificate.get -> System.Security.Cryptography.X509Certificates.X509Certificate2?\nabstract Microsoft.AspNetCore.Http.ConnectionInfo.ClientCertificate.set -> void\nabstract Microsoft.AspNetCore.Http.ConnectionInfo.GetClientCertificateAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<System.Security.Cryptography.X509Certificates.X509Certificate2?>!\n// ... Additional abstract members and status code constants...\n```\n\n----------------------------------------\n\nTITLE: Determining JSON Type Info Usage (C#)\nDESCRIPTION: This extension method determines if a JsonTypeInfo should be used with a given runtime type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\n----------------------------------------\n\nTITLE: Implementing Request Delegate Factory with Parameter Binding\nDESCRIPTION: Generates a request delegate that handles HTTP GET requests with parameter binding support. Includes metadata population, parameter validation, and response type handling for both string and JSON responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nRequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n{\n    Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n    Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n    Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n    Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n    var handler = Cast(del, global::System.String (global::Microsoft.AspNetCore.Http.HttpContext arg0, global::Microsoft.AspNetCore.Http.Generators.Tests.MySimpleBindAsyncRecord? arg1) => throw null!);\n    EndpointFilterDelegate? filteredInvocation = null;\n    var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n    var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n    var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n    var jsonSerializerOptions = jsonOptions.SerializerOptions;\n    jsonSerializerOptions.MakeReadOnly();\n    var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding User-Role Management Methods in ASP.NET Core Identity\nDESCRIPTION: This snippet demonstrates the method signatures for overriding user-role management operations in ASP.NET Core Identity. It includes methods for adding users to roles and managing user claims and logins.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.AddClaimsAsync(TUser! user, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim!>! claims, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.AddLoginAsync(TUser! user, Microsoft.AspNetCore.Identity.UserLoginInfo! login, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.AddToRoleAsync(TUser! user, string! normalizedRoleName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.AddUserTokenAsync(TUserToken! token) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Content Type Logger in ASP.NET Core\nDESCRIPTION: Defines a structured logger action for unsupported JSON content types using LoggerMessage.Define. This creates an optimized logging delegate that captures the actual content type provided.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: WebViewManager Class API for Blazor WebView\nDESCRIPTION: The WebViewManager class API that handles Blazor component lifecycle, messaging, navigation, and resource loading in WebView implementations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebView/WebView/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.WebView.WebViewManager\nMicrosoft.AspNetCore.Components.WebView.WebViewManager.AddRootComponentAsync(System.Type! componentType, string! selector, Microsoft.AspNetCore.Components.ParameterView parameters) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Components.WebView.WebViewManager.Dispatcher.get -> Microsoft.AspNetCore.Components.Dispatcher!\nMicrosoft.AspNetCore.Components.WebView.WebViewManager.DisposeAsync() -> System.Threading.Tasks.ValueTask\nMicrosoft.AspNetCore.Components.WebView.WebViewManager.MessageReceived(System.Uri! sourceUri, string! message) -> void\nMicrosoft.AspNetCore.Components.WebView.WebViewManager.Navigate(string! url) -> void\nMicrosoft.AspNetCore.Components.WebView.WebViewManager.RemoveRootComponentAsync(string! selector) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Components.WebView.WebViewManager.TryDispatchAsync(System.Action<System.IServiceProvider!>! workItem) -> System.Threading.Tasks.Task<bool>!\nMicrosoft.AspNetCore.Components.WebView.WebViewManager.TryGetResponseContent(string! uri, bool allowFallbackOnHostPage, out int statusCode, out string! statusMessage, out System.IO.Stream! content, out System.Collections.Generic.IDictionary<string!, string!>! headers) -> bool\nMicrosoft.AspNetCore.Components.WebView.WebViewManager.WebViewManager(System.IServiceProvider! provider, Microsoft.AspNetCore.Components.Dispatcher! dispatcher, System.Uri! appBaseUri, Microsoft.Extensions.FileProviders.IFileProvider! fileProvider, Microsoft.AspNetCore.Components.Web.JSComponentConfigurationStore! jsComponents, string! hostPageRelativePath) -> void\n```\n\n----------------------------------------\n\nTITLE: Extension Methods for IGrpcServerBuilder in C#\nDESCRIPTION: Extension methods for adding JSON transcoding support to gRPC server builder, with options for basic and configured setup.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Grpc/JsonTranscoding/src/Microsoft.AspNetCore.Grpc.JsonTranscoding/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic static class GrpcJsonTranscodingServiceExtensions\n{\n    public static IGrpcServerBuilder AddJsonTranscoding(this IGrpcServerBuilder builder);\n    public static IGrpcServerBuilder AddJsonTranscoding(this IGrpcServerBuilder builder, Action<GrpcJsonTranscodingOptions> configureOptions);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Content Type Logger Message in ASP.NET Core\nDESCRIPTION: Static field that defines a structured logging message for unexpected JSON content types. Uses LoggerMessage.Define to create a reusable logging delegate with a specific event ID and log level.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Defining RazorPagesOptions Configuration - C#\nDESCRIPTION: Configuration options class for Razor Pages including conventions and root directory settings. Used during startup to configure Razor Pages behavior.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class RazorPagesOptions\n{\n    public PageConventionCollection Conventions { get; }\n    public string RootDirectory { get; set; }\n    public RazorPagesOptions() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RazorComponentResult Classes in C#\nDESCRIPTION: These classes define HTTP results for Razor Components in ASP.NET Core, including options for component type, parameters, and rendering behavior.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Endpoints/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.RazorComponentResult\nMicrosoft.AspNetCore.Http.HttpResults.RazorComponentResult.ComponentType.get -> System.Type!\nMicrosoft.AspNetCore.Http.HttpResults.RazorComponentResult.ContentType.get -> string?\nMicrosoft.AspNetCore.Http.HttpResults.RazorComponentResult.ContentType.set -> void\nMicrosoft.AspNetCore.Http.HttpResults.RazorComponentResult.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.RazorComponentResult.Parameters.get -> System.Collections.Generic.IReadOnlyDictionary<string!, object?>!\nMicrosoft.AspNetCore.Http.HttpResults.RazorComponentResult.PreventStreamingRendering.get -> bool\nMicrosoft.AspNetCore.Http.HttpResults.RazorComponentResult.PreventStreamingRendering.set -> void\nMicrosoft.AspNetCore.Http.HttpResults.RazorComponentResult.RazorComponentResult(System.Type! componentType) -> void\nMicrosoft.AspNetCore.Http.HttpResults.RazorComponentResult.RazorComponentResult(System.Type! componentType, object! parameters) -> void\nMicrosoft.AspNetCore.Http.HttpResults.RazorComponentResult.RazorComponentResult(System.Type! componentType, System.Collections.Generic.IReadOnlyDictionary<string!, object?>! parameters) -> void\nMicrosoft.AspNetCore.Http.HttpResults.RazorComponentResult.StatusCode.get -> int?\nMicrosoft.AspNetCore.Http.HttpResults.RazorComponentResult.StatusCode.set -> void\n\nMicrosoft.AspNetCore.Http.HttpResults.RazorComponentResult<TComponent>\nMicrosoft.AspNetCore.Http.HttpResults.RazorComponentResult<TComponent>.RazorComponentResult() -> void\nMicrosoft.AspNetCore.Http.HttpResults.RazorComponentResult<TComponent>.RazorComponentResult(object! parameters) -> void\nMicrosoft.AspNetCore.Http.HttpResults.RazorComponentResult<TComponent>.RazorComponentResult(System.Collections.Generic.IReadOnlyDictionary<string!, object?>! parameters) -> void\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive that enables nullable reference type checking for improved null safety in C# code. When enabled, the compiler performs static analysis to help prevent null reference exceptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Twitter/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Creating Trimming Test Project Configuration\nDESCRIPTION: XML configuration for setting up a new trimming test project in ASP.NET Core, specifying test console app source files.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Trimming.md#2025-04-08_snippet_2\n\nLANGUAGE: xml\nCODE:\n```\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <ItemGroup>\n    <TestConsoleAppSourceFiles Include=\"MyTest.cs\">\n  </ItemGroup>\n</Project>\n```\n\n----------------------------------------\n\nTITLE: Delegate Casting Helper in ASP.NET Core\nDESCRIPTION: A generic helper method for casting delegates to a specific delegate type. Used in route mapping to ensure proper handler signatures.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/RequestDelegateValidateGeneratedFormCode.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n```\n\n----------------------------------------\n\nTITLE: Sign-Out Session State Management in ASP.NET Core WebAssembly\nDESCRIPTION: Virtual methods for managing sign-out session state in WebAssembly applications. These methods handle setting and validating sign-out state during the authentication lifecycle.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.WebAssembly.Authentication.SignOutSessionStateManager.SetSignOutState() -> System.Threading.Tasks.ValueTask\n```\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.WebAssembly.Authentication.SignOutSessionStateManager.ValidateSignOutState() -> System.Threading.Tasks.Task<bool>!\n```\n\n----------------------------------------\n\nTITLE: AllowAnonymousAttribute Class Definition in C#\nDESCRIPTION: Definition of the AllowAnonymousAttribute class that allows anonymous access to actions or controllers, bypassing authorization requirements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AllowAnonymousAttribute\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AllowAnonymousAttribute.AllowAnonymousAttribute() -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing Parameter Binding Metadata in ASP.NET Core\nDESCRIPTION: Sealed class implementing IParameterBindingMetadata, used to store metadata about parameter binding in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ApiDescription Class Members in C#\nDESCRIPTION: Class member definitions for ApiDescription class that provides metadata about an API endpoint including HTTP method, path, parameters, and supported formats.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ApiExplorer.ApiDescription.ActionDescriptor.get -> Microsoft.AspNetCore.Mvc.Abstractions.ActionDescriptor!\nMicrosoft.AspNetCore.Mvc.ApiExplorer.ApiDescription.ActionDescriptor.set -> void\nMicrosoft.AspNetCore.Mvc.ApiExplorer.ApiDescription.ApiDescription() -> void\nMicrosoft.AspNetCore.Mvc.ApiExplorer.ApiDescription.GroupName.get -> string?\nMicrosoft.AspNetCore.Mvc.ApiExplorer.ApiDescription.GroupName.set -> void\n```\n\n----------------------------------------\n\nTITLE: Building the OAuth Authentication Project in PowerShell\nDESCRIPTION: Command to build the Microsoft.AspNetCore.Authentication.OAuth project from within the parent 'security' directory. This is a simplified approach for building a subset of the ASP.NET Core codebase.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OAuth/src/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C# for ASP.NET Core\nDESCRIPTION: This code snippet enables nullable reference types for the entire file in an ASP.NET Core project. It uses the #nullable enable directive, which is a C# 8.0 feature that helps catch potential null reference exceptions at compile-time.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Stores/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining HealthReportEntry Class in C#\nDESCRIPTION: This class represents an entry in a health report. It includes properties for status, description, duration, exception, data, and tags.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HealthChecks/Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthReportEntry\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthReportEntry.Data.get -> System.Collections.Generic.IReadOnlyDictionary<string!, object!>!\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthReportEntry.Description.get -> string?\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthReportEntry.Duration.get -> System.TimeSpan\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthReportEntry.Exception.get -> System.Exception?\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthReportEntry.HealthReportEntry() -> void\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthReportEntry.HealthReportEntry(Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus status, string? description, System.TimeSpan duration, System.Exception? exception, System.Collections.Generic.IReadOnlyDictionary<string!, object!>? data) -> void\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthReportEntry.HealthReportEntry(Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus status, string? description, System.TimeSpan duration, System.Exception? exception, System.Collections.Generic.IReadOnlyDictionary<string!, object!>? data, System.Collections.Generic.IEnumerable<string!>? tags = null) -> void\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthReportEntry.Status.get -> Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthReportEntry.Tags.get -> System.Collections.Generic.IEnumerable<string!>!\n```\n\n----------------------------------------\n\nTITLE: Executing and Writing HTTP Response in ASP.NET Core\nDESCRIPTION: Handles the execution of a returned object and writes it to the HTTP response. It supports IResult interfaces, string responses, and JSON serialization for other object types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Render Mode to Razor Components Endpoint in C#\nDESCRIPTION: Helper method to add a render mode to a RazorComponentsEndpointConventionBuilder. It takes a render mode as a parameter.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Endpoints/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.Endpoints.Infrastructure.ComponentEndpointConventionBuilderHelper.AddRenderMode(Microsoft.AspNetCore.Builder.RazorComponentsEndpointConventionBuilder! builder, Microsoft.AspNetCore.Components.IComponentRenderMode! renderMode) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining IStatefulReconnectFeature Interface in C#\nDESCRIPTION: Provides methods for handling stateful reconnection in connections, including disabling reconnect and notifying on reconnection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Connections.Abstractions.IStatefulReconnectFeature\nMicrosoft.AspNetCore.Connections.Abstractions.IStatefulReconnectFeature.DisableReconnect() -> void\nMicrosoft.AspNetCore.Connections.Abstractions.IStatefulReconnectFeature.OnReconnected(System.Func<System.IO.Pipelines.PipeWriter!, System.Threading.Tasks.Task!>! notifyOnReconnect) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining Content Type Constants in ASP.NET Core C#\nDESCRIPTION: Defines readonly string arrays for common content types used in HTTP requests and responses, including JSON, plaintext, form data, and URL-encoded form content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_NullableReturn.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic static readonly string[] JsonContentType = new [] { \"application/json\" };\npublic static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\npublic static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\npublic static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n```\n\n----------------------------------------\n\nTITLE: Adding QuickGrid EF Adapter to Service Collection in C#\nDESCRIPTION: Extension method that adds QuickGrid Entity Framework adapter services to the ASP.NET Core dependency injection container. This enables QuickGrid functionality with Entity Framework in the application.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/QuickGrid/Microsoft.AspNetCore.Components.QuickGrid.EntityFrameworkAdapter/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\nMicrosoft.Extensions.DependencyInjection.EntityFrameworkAdapterServiceCollectionExtensions\nstatic Microsoft.Extensions.DependencyInjection.EntityFrameworkAdapterServiceCollectionExtensions.AddQuickGridEntityFrameworkAdapter(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> void\n```\n\n----------------------------------------\n\nTITLE: Invalid Form Request Body Handler\nDESCRIPTION: Handles invalid form data in request body by throwing BadHttpRequestException or logging the error. Includes parameter type and name information in the error message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleEnumParam_StringReturn.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive to enable nullable reference type checks in C# code. This enforces more strict null checking at compile time.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Updating Specific Submodule to Latest Remote Version\nDESCRIPTION: Command to update a specific submodule (EntityFrameworkCore in this example) to the latest version in its remote repository.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Submodules.md#2025-04-08_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngit submodule update --remote modules/EntityFrameworkCore/\n```\n\n----------------------------------------\n\nTITLE: Defining MapMethods Extension for Endpoint Route Builder\nDESCRIPTION: An extension method for IEndpointRouteBuilder that maps HTTP methods to handler delegates. It handles parameter binding, metadata population, JSON serialization, and endpoint filtering for ASP.NET Core request handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Get_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n        %INTERCEPTSLOCATIONATTRIBUTE%\n        internal static RouteHandlerBuilder MapMethods0(\n            this IEndpointRouteBuilder endpoints,\n            [StringSyntax(\"Route\")] string pattern,\n            IEnumerable<string> httpMethods,\n            Delegate handler)\n        {\n            MetadataPopulator populateMetadata = (methodInfo, options) =>\n            {\n                Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n                Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n                options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n                var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n                var serviceProviderIsService = serviceProvider.GetRequiredService<IServiceProviderIsService>();\n                var jsonBodyOrServiceTypeTuples = new (bool, Type)[] {\n                    #nullable disable\n                    (false, typeof(global::System.String[])),\n                    #nullable enable\n                };\n                foreach (var (isOptional, type) in jsonBodyOrServiceTypeTuples)\n                {\n                    if (!serviceProviderIsService.IsService(type))\n                    {\n                        options.EndpointBuilder.Metadata.Add(new AcceptsMetadata(type: type, isOptional: isOptional, contentTypes: GeneratedMetadataConstants.JsonContentType));\n                        break;\n                    }\n                }\n                var parameters = methodInfo.GetParameters();\n                options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n                options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n                return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n            };\n            RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n            {\n                Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n                Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n                Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n                Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n                var handler = Cast(del, global::System.String (global::System.String[] arg0) => throw null!);\n                EndpointFilterDelegate? filteredInvocation = null;\n                var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n                var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n                var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n                var jsonSerializerOptions = jsonOptions.SerializerOptions;\n                jsonSerializerOptions.MakeReadOnly();\n                var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n\n                if (options.EndpointBuilder.FilterFactories.Count > 0)\n                {\n                    filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n                    {\n                        if (ic.HttpContext.Response.StatusCode == 400)\n                        {\n                            return ValueTask.FromResult<object?>(Results.Empty);\n                        }\n                        return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::System.String[]>(0)!));\n                    },\n                    options.EndpointBuilder,\n                    handler.Method);\n                }\n\n                async Task RequestHandler(HttpContext httpContext)\n                {\n                    var wasParamCheckFailure = false;\n                    // Endpoint Parameter: p (Type = string[], IsOptional = False, IsParsable = False, IsArray = True, Source = JsonBodyOrQuery)\n                    global::System.String[] p_local = null!;\n                    if (options.DisableInferBodyFromParameters)\n                    {\n                        var p_raw = httpContext.Request.Query[\"p\"];\n                        p_local = p_raw!;\n                    }\n                    else\n                    {\n                        var p_JsonTypeInfo = (JsonTypeInfo<global::System.String[]>)jsonOptions.SerializerOptions.GetTypeInfo(typeof(global::System.String[]));\n                        var p_resolveBodyResult = await GeneratedRouteBuilderExtensionsCore.TryResolveBodyAsync<global::System.String[]>(httpContext, logOrThrowExceptionHelper, false, \"string[]\", \"p\", p_JsonTypeInfo);\n                        p_local = p_resolveBodyResult.Item2!;\n                        if (!p_resolveBodyResult.Item1)\n                        {\n                            return;\n                        }\n                    }\n\n                    if (wasParamCheckFailure)\n                    {\n                        httpContext.Response.StatusCode = 400;\n                        return;\n                    }\n                    var result = handler(p_local);\n                    if (result is string)\n                    {\n                        httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n                    }\n                    else\n                    {\n                        httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n                    }\n                    await httpContext.Response.WriteAsync(result);\n                }\n\n                async Task RequestHandlerFiltered(HttpContext httpContext)\n                {\n                    var wasParamCheckFailure = false;\n                    // Endpoint Parameter: p (Type = string[], IsOptional = False, IsParsable = False, IsArray = True, Source = JsonBodyOrQuery)\n                    global::System.String[] p_local = null!;\n                    if (options.DisableInferBodyFromParameters)\n                    {\n                        var p_raw = httpContext.Request.Query[\"p\"];\n                        p_local = p_raw!;\n                    }\n                    else\n                    {\n                        var p_JsonTypeInfo = (JsonTypeInfo<global::System.String[]>)jsonOptions.SerializerOptions.GetTypeInfo(typeof(global::System.String[]));\n                        var p_resolveBodyResult = await GeneratedRouteBuilderExtensionsCore.TryResolveBodyAsync<global::System.String[]>(httpContext, logOrThrowExceptionHelper, false, \"string[]\", \"p\", p_JsonTypeInfo);\n                        p_local = p_resolveBodyResult.Item2!;\n                        if (!p_resolveBodyResult.Item1)\n                        {\n                            return;\n                        }\n                    }\n\n                    if (wasParamCheckFailure)\n                    {\n                        httpContext.Response.StatusCode = 400;\n                    }\n                    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::System.String[]>(httpContext, p_local));\n                    if (result is not null)\n                    {\n\n```\n\n----------------------------------------\n\nTITLE: Mapping SignalR Hubs to Endpoints in ASP.NET Core\nDESCRIPTION: Extension methods for mapping SignalR hubs to endpoints in ASP.NET Core routing. These methods allow configuring hub endpoints with optional connection settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/SignalR/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.HubEndpointRouteBuilderExtensions.MapHub<THub>(this Microsoft.AspNetCore.Routing.IEndpointRouteBuilder! endpoints, string! pattern) -> Microsoft.AspNetCore.Builder.HubEndpointConventionBuilder!\nstatic Microsoft.AspNetCore.Builder.HubEndpointRouteBuilderExtensions.MapHub<THub>(this Microsoft.AspNetCore.Routing.IEndpointRouteBuilder! endpoints, string! pattern, System.Action<Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions!>? configureOptions) -> Microsoft.AspNetCore.Builder.HubEndpointConventionBuilder!\n```\n\n----------------------------------------\n\nTITLE: Creating String Binders in ASP.NET Core Components\nDESCRIPTION: Extension method for EventCallbackFactory that creates data binding callbacks for string values in Blazor components. This method handles converting input values from form elements to string properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<string?>! setter, string! existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants for HTTP Response Headers\nDESCRIPTION: Defines common content type constants used for HTTP responses in a generated metadata class. These constants are used for setting Content-Type headers in HTTP responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: URL Validation Helper Method\nDESCRIPTION: Static method to validate if a URL is local to the application.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.HttpResults.RedirectHttpResult.IsLocalUrl(string? url) -> bool\n```\n\n----------------------------------------\n\nTITLE: Logging and Exception Handling Helper in C#\nDESCRIPTION: This snippet defines a LogOrThrowExceptionHelper class that provides methods for logging or throwing exceptions based on configuration. It handles various error scenarios in request processing and parameter binding.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n\n    public void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n\n    public void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n\n    public void ImplicitBodyNotProvided(string parameterName)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n\n    public void UnexpectedJsonContentType(string? contentType)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n            throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n\n```\n\n----------------------------------------\n\nTITLE: Session Management Extensions in ASP.NET Core\nDESCRIPTION: Extension methods for managing session state including getting and setting string and integer values\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.SessionExtensions.GetString(this Microsoft.AspNetCore.Http.ISession! session, string! key) -> string?\nstatic Microsoft.AspNetCore.Http.SessionExtensions.SetString(this Microsoft.AspNetCore.Http.ISession! session, string! key, string! value) -> void\n```\n\n----------------------------------------\n\nTITLE: StreamAsync Extension Methods for SignalR HubConnection\nDESCRIPTION: Collection of overloaded extension methods for streaming data from a SignalR hub as an IAsyncEnumerable. Supports varying numbers of arguments (0-10) and returns a typed async enumerable stream.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.StreamAsync<TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, object? arg1, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Collections.Generic.IAsyncEnumerable<TResult>!\n```\n\n----------------------------------------\n\nTITLE: Defining EncryptionAlgorithm Enum in C#\nDESCRIPTION: This enum defines various encryption algorithms supported by the Data Protection API, including different AES variants with CBC and GCM modes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm.AES_128_CBC = 0 -> Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm.AES_128_GCM = 3 -> Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm.AES_192_CBC = 1 -> Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm.AES_192_GCM = 4 -> Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm.AES_256_CBC = 2 -> Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm.AES_256_GCM = 5 -> Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm\n```\n\n----------------------------------------\n\nTITLE: Configuring Endpoint Routing for Razor Pages in ASP.NET Core\nDESCRIPTION: Extension method for IEndpointRouteBuilder that adds Razor Pages endpoints to the routing pipeline. This method enables Razor Pages in an ASP.NET Core application and returns a builder for further customization of endpoints.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.RazorPagesEndpointRouteBuilderExtensions.MapRazorPages(this Microsoft.AspNetCore.Routing.IEndpointRouteBuilder! endpoints) -> Microsoft.AspNetCore.Builder.PageActionEndpointConventionBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining RequestCulture Class in C#\nDESCRIPTION: Defines the RequestCulture class for representing the selected culture for a request.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Localization.RequestCulture\nMicrosoft.AspNetCore.Localization.RequestCulture.Culture.get -> System.Globalization.CultureInfo!\nMicrosoft.AspNetCore.Localization.RequestCulture.RequestCulture(string! culture) -> void\nMicrosoft.AspNetCore.Localization.RequestCulture.RequestCulture(string! culture, string! uiCulture) -> void\nMicrosoft.AspNetCore.Localization.RequestCulture.RequestCulture(System.Globalization.CultureInfo! culture) -> void\nMicrosoft.AspNetCore.Localization.RequestCulture.RequestCulture(System.Globalization.CultureInfo! culture, System.Globalization.CultureInfo! uiCulture) -> void\nMicrosoft.AspNetCore.Localization.RequestCulture.UICulture.get -> System.Globalization.CultureInfo!\n```\n\n----------------------------------------\n\nTITLE: Mapping Core Routes in ASP.NET Core\nDESCRIPTION: Internal method for mapping HTTP route patterns to delegate handlers. It orchestrates the connection between a URL pattern, handler method, HTTP methods, and metadata population.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Routes with Core Implementation in ASP.NET Core\nDESCRIPTION: Defines the MapCore method for creating route handlers based on patterns and delegate handlers. This method is the foundation for route mapping in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in ASP.NET Core (C#)\nDESCRIPTION: Handles cases where the request body cannot be correctly parsed as form data. The method either throws a BadHttpRequestException with the original exception as inner exception or logs the failure with details about the parameter that could not be read.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Get_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Type Checking in C#\nDESCRIPTION: Directive that enables nullable reference type checking for the current file or project scope. This helps catch potential null reference exceptions at compile time.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net462/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Building ASP.NET Core Data Protection Project\nDESCRIPTION: Instructions for building the DataProtection project from source. It references the main BuildFromSource.md file for detailed steps.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/README.md#2025-04-08_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n### Build\n\nTo build this specific project from source, follow the instructions [on building the project](../../docs/BuildFromSource.md#step-3-build-the-repo).\n```\n\n----------------------------------------\n\nTITLE: OAuth Claim Action Implementations\nDESCRIPTION: Override implementations for various claim actions that process JSON data into identity claims\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OAuth/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Authentication.OAuth.Claims.CustomJsonClaimAction.Run(System.Text.Json.JsonElement userData, System.Security.Claims.ClaimsIdentity! identity, string! issuer) -> void\noverride Microsoft.AspNetCore.Authentication.OAuth.Claims.DeleteClaimAction.Run(System.Text.Json.JsonElement userData, System.Security.Claims.ClaimsIdentity! identity, string! issuer) -> void\noverride Microsoft.AspNetCore.Authentication.OAuth.Claims.JsonKeyClaimAction.Run(System.Text.Json.JsonElement userData, System.Security.Claims.ClaimsIdentity! identity, string! issuer) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining IInvocationBinder Interface for SignalR\nDESCRIPTION: Interface that provides methods for binding invocation parameters and return types. Used to resolve parameter types for method invocations and return types for streaming operations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.IInvocationBinder\nMicrosoft.AspNetCore.SignalR.IInvocationBinder.GetParameterTypes(string! methodName) -> System.Collections.Generic.IReadOnlyList<System.Type!>!\nMicrosoft.AspNetCore.SignalR.IInvocationBinder.GetReturnType(string! invocationId) -> System.Type!\nMicrosoft.AspNetCore.SignalR.IInvocationBinder.GetStreamItemType(string! streamId) -> System.Type!\n```\n\n----------------------------------------\n\nTITLE: Mapping Core Route Handler in ASP.NET Core\nDESCRIPTION: This method maps a route handler to an endpoint in ASP.NET Core. It takes various parameters including the route pattern, handler delegate, HTTP methods, and metadata populator.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants for ASP.NET Core Request Handling\nDESCRIPTION: Defines constants for various content types used in HTTP requests and responses, including JSON, plaintext, form data, and multipart form data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WebAssemblyHostConfiguration in C#\nDESCRIPTION: Defines the WebAssemblyHostConfiguration class with methods for managing configuration in WebAssembly applications. This class provides functionality for adding configuration sources, building configurations, and managing configuration sections.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostConfiguration\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostConfiguration.Add(Microsoft.Extensions.Configuration.IConfigurationSource! source) -> Microsoft.Extensions.Configuration.IConfigurationBuilder!\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostConfiguration.Build() -> Microsoft.Extensions.Configuration.IConfigurationRoot!\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostConfiguration.Dispose() -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostConfiguration.GetReloadToken() -> Microsoft.Extensions.Primitives.IChangeToken!\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostConfiguration.GetSection(string! key) -> Microsoft.Extensions.Configuration.IConfigurationSection!\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostConfiguration.Reload() -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostConfiguration.this[string! key].get -> string?\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostConfiguration.this[string! key].set -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHostConfiguration.WebAssemblyHostConfiguration() -> void\n```\n\n----------------------------------------\n\nTITLE: Negotiate Response (Version 0) in ASP.NET Core Transport Protocol\nDESCRIPTION: JSON response from the negotiate endpoint when using protocol version 0. Contains connectionId, negotiateVersion, and availableTransports properties that the client uses to establish a persistent connection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/TransportProtocols.md#2025-04-08_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"connectionId\":\"807809a5-31bf-470d-9e23-afaee35d8a0d\",\n  \"negotiateVersion\":0,\n  \"availableTransports\":[\n    {\n      \"transport\": \"WebSockets\",\n      \"transferFormats\": [ \"Text\", \"Binary\" ]\n    },\n    {\n      \"transport\": \"ServerSentEvents\",\n      \"transferFormats\": [ \"Text\" ]\n    },\n    {\n      \"transport\": \"LongPolling\",\n      \"transferFormats\": [ \"Text\", \"Binary\" ]\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Component Lifecycle and Rendering Methods in ASP.NET Core\nDESCRIPTION: These virtual methods handle component lifecycle events such as disposal and value formatting. They also include methods for rendering child components and writing component HTML.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.Forms.InputBase<TValue>.Dispose(bool disposing) -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.HtmlRendering.Infrastructure.StaticHtmlRenderer.WriteComponentHtml(int componentId, System.IO.TextWriter! output) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing RootComponentMappingCollection Class in C#\nDESCRIPTION: Defines the RootComponentMappingCollection class with methods for adding and managing root component mappings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.RootComponentMappingCollection\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.RootComponentMappingCollection.Add(System.Type! componentType, string! selector) -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.RootComponentMappingCollection.Add(System.Type! componentType, string! selector, Microsoft.AspNetCore.Components.ParameterView parameters) -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.RootComponentMappingCollection.Add<TComponent>(string! selector) -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.RootComponentMappingCollection.AddRange(System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Components.WebAssembly.Hosting.RootComponentMapping>! items) -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.RootComponentMappingCollection.JSComponents.get -> Microsoft.AspNetCore.Components.Web.JSComponentConfigurationStore!\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.RootComponentMappingCollection.RootComponentMappingCollection() -> void\n```\n\n----------------------------------------\n\nTITLE: JSON Response Writing with Type Information in ASP.NET Core\nDESCRIPTION: Writes an object as JSON to the HTTP response using provided type information. Handles polymorphic types and optimizes serialization based on type compatibility.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Local Redirection Methods in PageModel\nDESCRIPTION: Methods for handling local redirections within the application, including permanent redirects and method preservation options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.LocalRedirect(string! localUrl) -> Microsoft.AspNetCore.Mvc.LocalRedirectResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.LocalRedirectPermanent(string! localUrl) -> Microsoft.AspNetCore.Mvc.LocalRedirectResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.LocalRedirectPermanentPreserveMethod(string! localUrl) -> Microsoft.AspNetCore.Mvc.LocalRedirectResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.LocalRedirectPreserveMethod(string! localUrl) -> Microsoft.AspNetCore.Mvc.LocalRedirectResult!\n```\n\n----------------------------------------\n\nTITLE: Defining Static Fields in C#\nDESCRIPTION: Defines static readonly fields for default cookie name and null provider culture result.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Localization.CookieRequestCultureProvider.DefaultCookieName -> string!\nstatic readonly Microsoft.AspNetCore.Localization.RequestCultureProvider.NullProviderCultureResult -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Localization.ProviderCultureResult?>!\n```\n\n----------------------------------------\n\nTITLE: Defining ErrorModel for ASP.NET Core Identity UI V4\nDESCRIPTION: This snippet defines the ErrorModel class for ASP.NET Core Identity UI version 4. It includes methods for handling GET requests and properties for managing request IDs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.UI.V4.Pages.Internal.ErrorModel.OnGet() -> void\nMicrosoft.AspNetCore.Identity.UI.V4.Pages.Internal.ErrorModel.RequestId.get -> string?\nMicrosoft.AspNetCore.Identity.UI.V4.Pages.Internal.ErrorModel.RequestId.set -> void\nMicrosoft.AspNetCore.Identity.UI.V4.Pages.Internal.ErrorModel.ShowRequestId.get -> bool\n```\n\n----------------------------------------\n\nTITLE: Defining UserStoreBase Class in C#\nDESCRIPTION: Defines the UserStoreBase class for managing user data in ASP.NET Core Identity. It includes methods for disposing, error handling, and basic user operations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Stores/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>\nMicrosoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.Dispose() -> void\nMicrosoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.ErrorDescriber.get -> Microsoft.AspNetCore.Identity.IdentityErrorDescriber!\nMicrosoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.ErrorDescriber.set -> void\nMicrosoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.ThrowIfDisposed() -> void\nMicrosoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.UserStoreBase(Microsoft.AspNetCore.Identity.IdentityErrorDescriber! describer) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining RemoteAuthenticatorViewCore<TAuthenticationState> Class in C#\nDESCRIPTION: Defines the RemoteAuthenticatorViewCore<TAuthenticationState> class with various properties and methods for handling remote authentication in ASP.NET Core WebAssembly applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticatorViewCore<TAuthenticationState>.LogOutFailed.set -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticatorViewCore<TAuthenticationState>.LogOutSucceeded.get -> Microsoft.AspNetCore.Components.RenderFragment!\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticatorViewCore<TAuthenticationState>.LogOutSucceeded.set -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticatorViewCore<TAuthenticationState>.OnLogInSucceeded.get -> Microsoft.AspNetCore.Components.EventCallback<TAuthenticationState!>\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticatorViewCore<TAuthenticationState>.OnLogInSucceeded.set -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticatorViewCore<TAuthenticationState>.OnLogOutSucceeded.get -> Microsoft.AspNetCore.Components.EventCallback<TAuthenticationState!>\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticatorViewCore<TAuthenticationState>.OnLogOutSucceeded.set -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticatorViewCore<TAuthenticationState>.Registering.get -> Microsoft.AspNetCore.Components.RenderFragment?\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticatorViewCore<TAuthenticationState>.Registering.set -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticatorViewCore<TAuthenticationState>.RemoteAuthenticatorViewCore() -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticatorViewCore<TAuthenticationState>.UserProfile.get -> Microsoft.AspNetCore.Components.RenderFragment?\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticatorViewCore<TAuthenticationState>.UserProfile.set -> void\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: This directive enables nullable reference types for the entire file or project. It helps catch potential null reference errors at compile-time rather than runtime.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpOverrides/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Building Azure App Service Integration Projects in PowerShell\nDESCRIPTION: Command to build the Azure App Service integration projects from source. This assumes all prerequisites have been set up and the command is run from the project directory.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Azure/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: Defining OpenAPI Pet Store Endpoints and Models\nDESCRIPTION: OpenAPI 2.0 specification defining a pet store API with endpoints for creating, reading, updating and deleting pets, as well as specialized operations like image uploads and status filtering. Includes comprehensive request/response schemas and data models for Pets, Categories, Images and Tags.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Tools/Microsoft.dotnet-openapi/test/TestContent/openapi.json.txt#2025-04-08_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"x-generator\": \"NSwag v11.17.15.0 (NJsonSchema v9.10.53.0 (Newtonsoft.Json v10.0.0.0))\",\n  \"openapi\": \"2.0\",\n  \"info\": {\n    \"title\": \"My Title\",\n    \"version\": \"1.0.0\"\n  },\n  \"host\": \"localhost:44370\",\n  \"schemes\": [\n    \"https\"\n  ],\n  \"consumes\": [\n    \"application/json\",\n    \"application/json-patch+json\",\n    \"text/json\",\n    \"application/*+json\",\n    \"multipart/form-data\"\n  ],\n  \"produces\": [\n    \"application/json\"\n  ],\n  \"paths\": {\n    \"/pet\": {\n      \"post\": {\n        \"tags\": [\n          \"Pet\"\n        ],\n        \"operationId\": \"Pet_AddPet\",\n        \"consumes\": [\n          \"application/json\"\n        ],\n        \"parameters\": [\n          {\n            \"name\": \"pet\",\n            \"in\": \"body\",\n            \"required\": true,\n            \"schema\": {\n              \"$ref\": \"#/definitions/Pet\"\n            },\n            \"x-nullable\": true\n          }\n        ],\n        \"responses\": {\n          \"204\": {\n            \"description\": \"\"\n          },\n          \"400\": {\n            \"x-nullable\": true,\n            \"description\": \"\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/SerializableError\"\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SignalR Invocation Failure Message Classes\nDESCRIPTION: Message classes for representing binding failures during invocation or streaming operations. Contains information about the failure, including exception details and target method or stream ID.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationBindingFailureMessage\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationBindingFailureMessage.BindingFailure.get -> System.Runtime.ExceptionServices.ExceptionDispatchInfo!\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationBindingFailureMessage.InvocationBindingFailureMessage(string? invocationId, string! target, System.Runtime.ExceptionServices.ExceptionDispatchInfo! bindingFailure) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationBindingFailureMessage.Target.get -> string!\n\nMicrosoft.AspNetCore.SignalR.Protocol.StreamBindingFailureMessage\nMicrosoft.AspNetCore.SignalR.Protocol.StreamBindingFailureMessage.BindingFailure.get -> System.Runtime.ExceptionServices.ExceptionDispatchInfo!\nMicrosoft.AspNetCore.SignalR.Protocol.StreamBindingFailureMessage.Id.get -> string!\nMicrosoft.AspNetCore.SignalR.Protocol.StreamBindingFailureMessage.StreamBindingFailureMessage(string! id, System.Runtime.ExceptionServices.ExceptionDispatchInfo! bindingFailure) -> void\n```\n\n----------------------------------------\n\nTITLE: Creating Binders for Various Data Types in ASP.NET Core Components\nDESCRIPTION: This code snippet shows the method signatures for the CreateBinder extension methods that generate EventCallback instances for different data types. These methods are used internally by Blazor to implement two-way data binding (@bind directives) between form elements and component properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<bool?, System.Threading.Tasks.Task!>! setter, bool? existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<decimal, System.Threading.Tasks.Task!>! setter, decimal existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<decimal?, System.Threading.Tasks.Task!>! setter, decimal? existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<double, System.Threading.Tasks.Task!>! setter, double existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<double?, System.Threading.Tasks.Task!>! setter, double? existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<float, System.Threading.Tasks.Task!>! setter, float existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<float?, System.Threading.Tasks.Task!>! setter, float? existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<int, System.Threading.Tasks.Task!>! setter, int existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<int?, System.Threading.Tasks.Task!>! setter, int? existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<long, System.Threading.Tasks.Task!>! setter, long existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<long?, System.Threading.Tasks.Task!>! setter, long? existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<short, System.Threading.Tasks.Task!>! setter, short existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<short?, System.Threading.Tasks.Task!>! setter, short? existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<string?, System.Threading.Tasks.Task!>! setter, string! existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<System.DateOnly, System.Threading.Tasks.Task!>! setter, System.DateOnly existingValue, string! format, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<System.DateOnly, System.Threading.Tasks.Task!>! setter, System.DateOnly existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<System.DateOnly?, System.Threading.Tasks.Task!>! setter, System.DateOnly? existingValue, string! format, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<System.DateOnly?, System.Threading.Tasks.Task!>! setter, System.DateOnly? existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<System.DateTime, System.Threading.Tasks.Task!>! setter, System.DateTime existingValue, string! format, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<System.DateTime, System.Threading.Tasks.Task!>! setter, System.DateTime existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<System.DateTime?, System.Threading.Tasks.Task!>! setter, System.DateTime? existingValue, string! format, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<System.DateTime?, System.Threading.Tasks.Task!>! setter, System.DateTime? existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<System.DateTimeOffset, System.Threading.Tasks.Task!>! setter, System.DateTimeOffset existingValue, string! format, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<System.DateTimeOffset, System.Threading.Tasks.Task!>! setter, System.DateTimeOffset existingValue, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants in C#\nDESCRIPTION: This snippet defines a static class with constants for various content types used in HTTP communication, including JSON, plaintext, form data, and URL-encoded form content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Installing EntityFrameworkCore HealthChecks Package via CLI\nDESCRIPTION: Command to install the Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore package using the .NET CLI.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HealthChecks.EntityFrameworkCore/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore\n```\n\n----------------------------------------\n\nTITLE: Building the SignalR Project on MacOS/Linux\nDESCRIPTION: Command to build the ASP.NET Core SignalR project on MacOS or Linux systems using bash. This will compile the entire project including Java and TypeScript components unless specified otherwise.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/README.md#2025-04-08_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ ./build.sh\n```\n\n----------------------------------------\n\nTITLE: Implementing DataProtectionAdvancedExtensions in C#\nDESCRIPTION: This snippet defines static extension methods for ITimeLimitedDataProtector, providing additional functionality for protecting and unprotecting data with various overloads and time-based limitations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/Extensions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionAdvancedExtensions.Protect(this Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector! protector, byte[]! plaintext, System.TimeSpan lifetime) -> byte[]!\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionAdvancedExtensions.Protect(this Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector! protector, string! plaintext, System.DateTimeOffset expiration) -> string!\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionAdvancedExtensions.Protect(this Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector! protector, string! plaintext, System.TimeSpan lifetime) -> string!\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionAdvancedExtensions.ToTimeLimitedDataProtector(this Microsoft.AspNetCore.DataProtection.IDataProtector! protector) -> Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector!\nstatic Microsoft.AspNetCore.DataProtection.DataProtectionAdvancedExtensions.Unprotect(this Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector! protector, string! protectedData, out System.DateTimeOffset expiration) -> string!\n```\n\n----------------------------------------\n\nTITLE: Defining GrpcJsonSettings Class in C#\nDESCRIPTION: Class that contains configuration options for JSON serialization in gRPC transcoding, including settings for handling default values, enums, indentation, and int64 values.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Grpc/JsonTranscoding/src/Microsoft.AspNetCore.Grpc.JsonTranscoding/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class GrpcJsonSettings\n{\n    public bool IgnoreDefaultValues { get; set; }\n    public bool WriteEnumsAsIntegers { get; set; }\n    public bool WriteIndented { get; set; }\n    public bool WriteInt64sAsStrings { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AuthorizeAttribute in C#\nDESCRIPTION: This attribute is used to require authorization for controllers or action methods in ASP.NET Core applications. It allows specifying authentication schemes, policies, and roles for authorization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute.AuthenticationSchemes.get -> string?\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute.AuthenticationSchemes.set -> void\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute.AuthorizeAttribute() -> void\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute.AuthorizeAttribute(string! policy) -> void\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute.Policy.get -> string?\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute.Policy.set -> void\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute.Roles.get -> string?\nMicrosoft.AspNetCore.Authorization.AuthorizeAttribute.Roles.set -> void\n```\n\n----------------------------------------\n\nTITLE: RouteDataRequestCultureProvider Class API Surface in ASP.NET Core\nDESCRIPTION: Defines the API surface for the RouteDataRequestCultureProvider class which extracts culture information from ASP.NET Core route data. Includes constructor, property accessors for RouteDataStringKey and UIRouteDataStringKey, and an override for DetermineProviderCultureResult method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization.Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n~override Microsoft.AspNetCore.Localization.Routing.RouteDataRequestCultureProvider.DetermineProviderCultureResult(Microsoft.AspNetCore.Http.HttpContext httpContext) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Localization.ProviderCultureResult>\nMicrosoft.AspNetCore.Localization.Routing.RouteDataRequestCultureProvider\nMicrosoft.AspNetCore.Localization.Routing.RouteDataRequestCultureProvider.RouteDataRequestCultureProvider() -> void\nMicrosoft.AspNetCore.Localization.Routing.RouteDataRequestCultureProvider.RouteDataStringKey.get -> string!\nMicrosoft.AspNetCore.Localization.Routing.RouteDataRequestCultureProvider.RouteDataStringKey.set -> void\nMicrosoft.AspNetCore.Localization.Routing.RouteDataRequestCultureProvider.UIRouteDataStringKey.get -> string!\nMicrosoft.AspNetCore.Localization.Routing.RouteDataRequestCultureProvider.UIRouteDataStringKey.set -> void\noverride Microsoft.AspNetCore.Localization.Routing.RouteDataRequestCultureProvider.DetermineProviderCultureResult(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Localization.ProviderCultureResult?>!\n```\n\n----------------------------------------\n\nTITLE: Defining Secret Class in C# for ASP.NET Core Data Protection\nDESCRIPTION: This snippet defines the Secret class in the Microsoft.AspNetCore.DataProtection namespace. It includes constructors for different input types, methods for writing the secret into buffers, and properties for accessing the secret's length.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.DataProtection.Secret\nMicrosoft.AspNetCore.DataProtection.Secret.Dispose() -> void\nMicrosoft.AspNetCore.DataProtection.Secret.Length.get -> int\nMicrosoft.AspNetCore.DataProtection.Secret.Secret(byte* secret, int secretLength) -> void\nMicrosoft.AspNetCore.DataProtection.Secret.Secret(byte[]! value) -> void\nMicrosoft.AspNetCore.DataProtection.Secret.Secret(Microsoft.AspNetCore.DataProtection.ISecret! secret) -> void\nMicrosoft.AspNetCore.DataProtection.Secret.Secret(System.ArraySegment<byte> value) -> void\nMicrosoft.AspNetCore.DataProtection.Secret.WriteSecretIntoBuffer(byte* buffer, int bufferLength) -> void\nMicrosoft.AspNetCore.DataProtection.Secret.WriteSecretIntoBuffer(System.ArraySegment<byte> buffer) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining RegisterConfirmationModel for ASP.NET Core Identity UI V5\nDESCRIPTION: This snippet defines the RegisterConfirmationModel class for ASP.NET Core Identity UI version 5. It includes properties for managing registration confirmation information and display options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.RegisterConfirmationModel\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.RegisterConfirmationModel.DisplayConfirmAccountLink.get -> bool\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.RegisterConfirmationModel.DisplayConfirmAccountLink.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.RegisterConfirmationModel.Email.get -> string?\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.RegisterConfirmationModel.Email.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.RegisterConfirmationModel.EmailConfirmationUrl.get -> string?\n```\n\n----------------------------------------\n\nTITLE: Request Body Deserialization in ASP.NET Core\nDESCRIPTION: Attempts to deserialize a request body into a strongly-typed object. Handles various error conditions including IO exceptions, JSON parsing errors, and empty bodies, with appropriate HTTP status code responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Post_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static async ValueTask<(bool, T?)> TryResolveBodyAsync<T>(HttpContext httpContext, LogOrThrowExceptionHelper logOrThrowExceptionHelper, bool allowEmpty, string parameterTypeName, string parameterName, JsonTypeInfo<T> jsonTypeInfo, bool isInferred = false)\n{\n    var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();\n    T? bodyValue = default;\n    var bodyValueSet = false;\n\n    if (feature?.CanHaveBody == true)\n    {\n        if (!httpContext.Request.HasJsonContentType())\n        {\n            logOrThrowExceptionHelper.UnexpectedJsonContentType(httpContext.Request.ContentType);\n            httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;\n            return (false, default);\n        }\n        try\n        {\n            bodyValue = await httpContext.Request.ReadFromJsonAsync(jsonTypeInfo);\n            bodyValueSet = bodyValue != null;\n        }\n        catch (BadHttpRequestException badHttpRequestException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(badHttpRequestException);\n            httpContext.Response.StatusCode = badHttpRequestException.StatusCode;\n            return (false, default);\n        }\n        catch (IOException ioException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(ioException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n        catch (System.Text.Json.JsonException jsonException)\n        {\n            logOrThrowExceptionHelper.InvalidJsonRequestBody(parameterTypeName, parameterName, jsonException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n    }\n\n    if (!allowEmpty && !bodyValueSet)\n    {\n        if (!isInferred)\n        {\n            logOrThrowExceptionHelper.RequiredParameterNotProvided(parameterTypeName, parameterName, \"body\");\n        }\n        else\n        {\n            logOrThrowExceptionHelper.ImplicitBodyNotProvided(parameterName);\n        }\n        httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n        return (false, bodyValue);\n    }\n\n    return (true, bodyValue);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring RequestDelegate for Route Parameter Binding in ASP.NET Core\nDESCRIPTION: Creates a RequestHandler that extracts and validates a route parameter from the request. Validates if the parameter is correctly configured in the route pattern.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitSource_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nTask RequestHandler(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    // Endpoint Parameter: routeValue (Type = string, IsOptional = False, IsParsable = False, IsArray = False, Source = Route)\n    if (options?.RouteParameterNames?.Contains(\"routeValue\", StringComparer.OrdinalIgnoreCase) != true)\n    {\n        throw new InvalidOperationException($\"'routeValue' is not a route parameter.\");\n    }\n    var routeValue_raw = (string?)httpContext.Request.RouteValues[\"routeValue\"];\n    if (routeValue_raw == null)\n    {\n        wasParamCheckFailure = true;\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable References in C#\nDESCRIPTION: Directive to enable nullable reference type checking in C# code. This enforces more strict null-checking and helps prevent null reference exceptions at compile time.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/StackExchangeRedis/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Running Tests on Windows\nDESCRIPTION: Command to run tests for the ASP.NET Core SignalR project on Windows systems using PowerShell. The -t flag indicates that tests should be executed after building the project.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/README.md#2025-04-08_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd -t\n```\n\n----------------------------------------\n\nTITLE: Generic Delegate Casting in C#\nDESCRIPTION: This method casts a Delegate to a specified type T, where T is also a Delegate.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n```\n\n----------------------------------------\n\nTITLE: HubException Class Implementation\nDESCRIPTION: Exception class specific to SignalR hubs. This exception type is used to handle and propagate errors that occur during hub method invocations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.HubException\nMicrosoft.AspNetCore.SignalR.HubException.HubException() -> void\nMicrosoft.AspNetCore.SignalR.HubException.HubException(string? message) -> void\nMicrosoft.AspNetCore.SignalR.HubException.HubException(string? message, System.Exception? innerException) -> void\nMicrosoft.AspNetCore.SignalR.HubException.HubException(System.Runtime.Serialization.SerializationInfo! info, System.Runtime.Serialization.StreamingContext context) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Message for Unexpected Non-Form Content Type in C#\nDESCRIPTION: This snippet defines a LoggerMessage for logging when an unexpected non-form content type is received. It uses LogLevel.Debug and creates an EventId for the message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants for API Responses in ASP.NET Core\nDESCRIPTION: Defines standard content type constants for various response formats including JSON, plaintext, form data, and URL-encoded form content. These are used throughout the request pipeline for content negotiation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Class in C#\nDESCRIPTION: Defines metadata for parameter binding including name, type information, and binding capabilities. Used for request parameter processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n    public bool HasTryParse { get; }\n    public bool HasBindAsync { get; }\n    public ParameterInfo ParameterInfo { get; }\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing IParsable<T> in C#\nDESCRIPTION: This method attempts to parse a string value into an IParsable<T> type using the TryParse method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nprivate static bool TryParseExplicit<T>(string? s, IFormatProvider? provider, [MaybeNullWhen(returnValue: false)] out T result) where T: IParsable<T>\n    => T.TryParse(s, provider, out result);\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet1 Extension Method for HTTP GET Endpoint Registration\nDESCRIPTION: Defines an alternative MapGet extension method that maps HTTP GET requests to handler delegates. This implementation focuses on metadata population for the endpoint but has a simplified structure compared to MapGet0.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitServiceParam_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n        %INTERCEPTSLOCATIONATTRIBUTE%\n        internal static RouteHandlerBuilder MapGet1(\n            this IEndpointRouteBuilder endpoints,\n            [StringSyntax(\"Route\")] string pattern,\n            Delegate handler)\n        {\n            MetadataPopulator populateMetadata = (methodInfo, options) =>\n            {\n                Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n                Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n                options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n                var parameters = methodInfo.GetParameters();\n                options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"svc\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n                options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n\n\n```\n\n----------------------------------------\n\nTITLE: CompilationFailure Class Definition\nDESCRIPTION: Class definition for handling compilation failures in ASP.NET Core, including source file information, compiled content, and diagnostic messages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Diagnostics.CompilationFailure.CompilationFailure(string? sourceFilePath, string? sourceFileContent, string? compiledContent, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Diagnostics.DiagnosticMessage?>? messages, string? failureSummary) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing ViewExecutor Class in C#\nDESCRIPTION: Defines the ViewExecutor class with properties and methods for executing views in ASP.NET Core MVC.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ViewExecutor\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ViewExecutor.DiagnosticListener.get -> System.Diagnostics.DiagnosticListener!\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ViewExecutor.ExecuteAsync(Microsoft.AspNetCore.Mvc.Rendering.ViewContext! viewContext, string? contentType, int? statusCode) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ViewExecutor.ModelMetadataProvider.get -> Microsoft.AspNetCore.Mvc.ModelBinding.IModelMetadataProvider?\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ViewExecutor.TempDataFactory.get -> Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataDictionaryFactory?\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ViewExecutor.ViewEngine.get -> Microsoft.AspNetCore.Mvc.ViewEngines.IViewEngine!\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ViewExecutor.ViewExecutor(Microsoft.AspNetCore.Mvc.Infrastructure.IHttpResponseStreamWriterFactory! writerFactory, Microsoft.AspNetCore.Mvc.ViewEngines.ICompositeViewEngine! viewEngine, System.Diagnostics.DiagnosticListener! diagnosticListener) -> void\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ViewExecutor.ViewExecutor(Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Mvc.MvcViewOptions!>! viewOptions, Microsoft.AspNetCore.Mvc.Infrastructure.IHttpResponseStreamWriterFactory! writerFactory, Microsoft.AspNetCore.Mvc.ViewEngines.ICompositeViewEngine! viewEngine, Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataDictionaryFactory! tempDataFactory, System.Diagnostics.DiagnosticListener! diagnosticListener, Microsoft.AspNetCore.Mvc.ModelBinding.IModelMetadataProvider! modelMetadataProvider) -> void\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ViewExecutor.ViewOptions.get -> Microsoft.AspNetCore.Mvc.MvcViewOptions?\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ViewExecutor.WriterFactory.get -> Microsoft.AspNetCore.Mvc.Infrastructure.IHttpResponseStreamWriterFactory!\n```\n\n----------------------------------------\n\nTITLE: Defining Virtual Properties for ActionDescriptor in C#\nDESCRIPTION: Declares virtual getter and setter for the DisplayName property of ActionDescriptor class. This allows for customization of how action names are displayed.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.Abstractions.ActionDescriptor.DisplayName.get -> string?\nvirtual Microsoft.AspNetCore.Mvc.Abstractions.ActionDescriptor.DisplayName.set -> void\n```\n\n----------------------------------------\n\nTITLE: StringBuilder Pool Implementation\nDESCRIPTION: Specialized implementation for pooling StringBuilder objects with configurable initial and maximum capacities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/ObjectPool/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.ObjectPool.StringBuilderPooledObjectPolicy\nMicrosoft.Extensions.ObjectPool.StringBuilderPooledObjectPolicy.InitialCapacity.get -> int\nMicrosoft.Extensions.ObjectPool.StringBuilderPooledObjectPolicy.MaximumRetainedCapacity.get -> int\nMicrosoft.Extensions.ObjectPool.StringBuilderPooledObjectPolicy.StringBuilderPooledObjectPolicy() -> void\n```\n\n----------------------------------------\n\nTITLE: HTTPS Requirement Methods in ASP.NET Core MVC\nDESCRIPTION: Virtual methods from the RequireHttpsAttribute class that enforce HTTPS requirements. These methods determine how non-HTTPS requests are handled during request authorization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_69\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RequireHttpsAttribute.HandleNonHttpsRequest(Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext! filterContext) -> void\nvirtual Microsoft.AspNetCore.Mvc.RequireHttpsAttribute.OnAuthorization(Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext! filterContext) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing EphemeralDataProtectionProvider in C#\nDESCRIPTION: This class provides an implementation of a data protection provider that creates non-persisted keys for protecting data, suitable for ephemeral scenarios.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.DataProtection.EphemeralDataProtectionProvider\nMicrosoft.AspNetCore.DataProtection.EphemeralDataProtectionProvider.CreateProtector(string! purpose) -> Microsoft.AspNetCore.DataProtection.IDataProtector!\nMicrosoft.AspNetCore.DataProtection.EphemeralDataProtectionProvider.EphemeralDataProtectionProvider() -> void\nMicrosoft.AspNetCore.DataProtection.EphemeralDataProtectionProvider.EphemeralDataProtectionProvider(Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing EphemeralDataProtectionProvider in C#\nDESCRIPTION: This class provides an implementation of a data protection provider that creates non-persisted keys for protecting data, suitable for ephemeral scenarios.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.DataProtection.EphemeralDataProtectionProvider\nMicrosoft.AspNetCore.DataProtection.EphemeralDataProtectionProvider.CreateProtector(string! purpose) -> Microsoft.AspNetCore.DataProtection.IDataProtector!\nMicrosoft.AspNetCore.DataProtection.EphemeralDataProtectionProvider.EphemeralDataProtectionProvider() -> void\nMicrosoft.AspNetCore.DataProtection.EphemeralDataProtectionProvider.EphemeralDataProtectionProvider(Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> void\n```\n\n----------------------------------------\n\nTITLE: ViewContext Constructor Implementations\nDESCRIPTION: Defines constructors for ViewContext class that manages view execution context including view data, temp data, and writer settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Rendering.ViewContext.ViewContext() -> void\nMicrosoft.AspNetCore.Mvc.Rendering.ViewContext.ViewContext(Microsoft.AspNetCore.Mvc.ActionContext! actionContext, Microsoft.AspNetCore.Mvc.ViewEngines.IView! view, Microsoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary! viewData, Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataDictionary! tempData, System.IO.TextWriter! writer, Microsoft.AspNetCore.Mvc.ViewFeatures.HtmlHelperOptions! htmlHelperOptions) -> void\nMicrosoft.AspNetCore.Mvc.Rendering.ViewContext.ViewContext(Microsoft.AspNetCore.Mvc.Rendering.ViewContext! viewContext, Microsoft.AspNetCore.Mvc.ViewEngines.IView! view, Microsoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary! viewData, System.IO.TextWriter! writer) -> void\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: This directive enables nullable reference type checking in C# code. When enabled, the compiler performs static analysis to help prevent null reference exceptions by tracking variables that might be null.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HostFiltering/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Building ASP.NET Core Authentication Components\nDESCRIPTION: Command to build the authentication components from source within the security directory.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core Routing Extension Methods\nDESCRIPTION: Collection of static extension methods for ASP.NET Core routing configuration, including route mapping, endpoint conventions, filtering, and OpenAPI documentation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute(this Microsoft.AspNetCore.Routing.IRouteBuilder! routeBuilder, string? name, string? template, object? defaults, object? constraints, object? dataTokens) -> Microsoft.AspNetCore.Routing.IRouteBuilder!\n\nstatic Microsoft.AspNetCore.Builder.RouteShortCircuitEndpointConventionBuilderExtensions.ShortCircuit(this Microsoft.AspNetCore.Builder.IEndpointConventionBuilder! builder, int? statusCode = null) -> Microsoft.AspNetCore.Builder.IEndpointConventionBuilder!\n\nstatic Microsoft.AspNetCore.Builder.RoutingBuilderExtensions.UseRouter(this Microsoft.AspNetCore.Builder.IApplicationBuilder! builder, Microsoft.AspNetCore.Routing.IRouter! router) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Getting Successful Handshake Data in SignalR Protocol\nDESCRIPTION: Static method to retrieve the successful handshake data as a ReadOnlySpan<byte> for a given IHubProtocol in the SignalR protocol.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.GetSuccessfulHandshake(Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol! protocol) -> System.ReadOnlySpan<byte>\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected JSON Content Type in ASP.NET Core\nDESCRIPTION: This method checks for unexpected JSON content types, throwing a BadHttpRequestException or logging the error based on configuration. It uses a predefined LoggerMessage for efficient logging.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedJsonContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Logging and Exception Handling Helper in ASP.NET Core\nDESCRIPTION: Helper class for logging errors and optionally throwing exceptions in ASP.NET Core request processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n\n    public void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n\n    public void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n\n    public void ImplicitBodyNotProvided(string parameterName)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n\n    public void UnexpectedJsonContentType(string? contentType)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n            throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n}\n```\n\n----------------------------------------\n\nTITLE: Using Help Command with ASP.NET Core Tools\nDESCRIPTION: Example showing how to access the help documentation for a specific ASP.NET Core tool by adding the --help flag. This provides detailed information about the tool's usage and available options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Tools/README.md#2025-04-08_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ndotnet dev-certs --help\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a custom attribute 'InterceptsLocationAttribute' used for method interception in the System.Runtime.CompilerServices namespace.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending IServiceCollection with AddSupplyValueFromFormProvider Method in C#\nDESCRIPTION: Adds an extension method to IServiceCollection for adding a supply value from form provider.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.Forms.Mapping.SupplyParameterFromFormServiceCollectionExtensions.AddSupplyValueFromFormProvider(this Microsoft.Extensions.DependencyInjection.IServiceCollection! serviceCollection) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Handling Connection Events in Azure SignalR Service\nDESCRIPTION: This code snippet demonstrates how to handle connection events when using Azure SignalR Service. It shows the implementation of OnConnected and OnDisconnected methods in a hub class.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/WindowsServices/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class ChatHub : Hub\n{\n    public override Task OnConnectedAsync()\n    {\n        // Handle connection event\n        return base.OnConnectedAsync();\n    }\n\n    public override Task OnDisconnectedAsync(Exception? exception)\n    {\n        // Handle disconnection event\n        return base.OnDisconnectedAsync(exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Cast Method in C#\nDESCRIPTION: Implements a generic Cast method used for casting delegates to specific types within the route builder extensions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsSameInterceptorsFromDifferentFiles.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n```\n\n----------------------------------------\n\nTITLE: W3CLoggingFields Compound Field Definitions in ASP.NET Core\nDESCRIPTION: Definitions of compound fields in the W3CLoggingFields enumeration that combine multiple individual fields. These groupings provide convenient ways to enable sets of related logging fields.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpLogging/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.Request = Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.Method | Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.UriStem | Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.UriQuery | Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.ProtocolVersion | Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.RequestHeaders -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.RequestHeaders = Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.Host | Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.UserAgent | Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.Referer -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\n```\n\n----------------------------------------\n\nTITLE: Implementing OWIN Environment in C#\nDESCRIPTION: Defines the OwinEnvironment class with various constructors and methods for managing OWIN environment features.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Owin/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Owin.OwinEnvironment.FeatureMap.FeatureMap(System.Type featureInterface, System.Func<object, object> getter) -> void\nMicrosoft.AspNetCore.Owin.OwinEnvironment.FeatureMap.FeatureMap(System.Type featureInterface, System.Func<object, object> getter, System.Action<object, object> setter) -> void\nMicrosoft.AspNetCore.Owin.OwinEnvironment.FeatureMap.FeatureMap(System.Type featureInterface, System.Func<object, object> getter, System.Func<object> defaultFactory) -> void\nMicrosoft.AspNetCore.Owin.OwinEnvironment.FeatureMap.FeatureMap(System.Type featureInterface, System.Func<object, object> getter, System.Func<object> defaultFactory, System.Action<object, object> setter) -> void\nMicrosoft.AspNetCore.Owin.OwinEnvironment.FeatureMap.FeatureMap(System.Type featureInterface, System.Func<object, object> getter, System.Func<object> defaultFactory, System.Action<object, object> setter, System.Func<object> featureFactory) -> void\nMicrosoft.AspNetCore.Owin.OwinEnvironment.FeatureMap<TFeature>.FeatureMap(System.Func<TFeature, object> getter) -> void\nMicrosoft.AspNetCore.Owin.OwinEnvironment.FeatureMap<TFeature>.FeatureMap(System.Func<TFeature, object> getter, System.Action<TFeature, object> setter) -> void\nMicrosoft.AspNetCore.Owin.OwinEnvironment.FeatureMap<TFeature>.FeatureMap(System.Func<TFeature, object> getter, System.Func<object> defaultFactory) -> void\nMicrosoft.AspNetCore.Owin.OwinEnvironment.FeatureMap<TFeature>.FeatureMap(System.Func<TFeature, object> getter, System.Func<object> defaultFactory, System.Action<TFeature, object> setter) -> void\nMicrosoft.AspNetCore.Owin.OwinEnvironment.FeatureMap<TFeature>.FeatureMap(System.Func<TFeature, object> getter, System.Func<object> defaultFactory, System.Action<TFeature, object> setter, System.Func<TFeature> featureFactory) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining MVC Diagnostic Event Constants\nDESCRIPTION: Constants defining event names for ASP.NET Core MVC diagnostic events used for logging and telemetry.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nconst Microsoft.AspNetCore.Mvc.Diagnostics.BeforeControllerActionMethodEventData.EventName = \"Microsoft.AspNetCore.Mvc.BeforeControllerActionMethod\" -> string!\nconst Microsoft.AspNetCore.Mvc.Diagnostics.BeforeExceptionFilterOnException.EventName = \"Microsoft.AspNetCore.Mvc.BeforeOnException\" -> string!\nconst Microsoft.AspNetCore.Mvc.Diagnostics.EventData.EventNamespace = \"Microsoft.AspNetCore.Mvc.\" -> string!\n```\n\n----------------------------------------\n\nTITLE: Configuring ASP.NET Core Identity Services\nDESCRIPTION: Configuration code for setting up Identity services in Program.cs, including authentication, authorization, and Entity Framework stores. This setup enables user authentication and management features in the application.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Services.AddDefaultIdentity<IdentityUser>()\n    .AddEntityFrameworkStores<ApplicationDbContext>();\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapRazorPages();\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocationAttribute for Method Interception in C#\nDESCRIPTION: Defines a sealed attribute class that marks methods for interception. This attribute is used in the compiler-generated code to enable method interception, accepting version and data parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\nfile sealed class InterceptsLocationAttribute : Attribute\n{\n    public InterceptsLocationAttribute(int version, string data)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining WebEncoderOptions class in C#\nDESCRIPTION: Defines the WebEncoderOptions class with properties for configuring text encoder settings in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/WebEncoders/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.WebEncoders.WebEncoderOptions\nMicrosoft.Extensions.WebEncoders.WebEncoderOptions.TextEncoderSettings.get -> System.Text.Encodings.Web.TextEncoderSettings?\nMicrosoft.Extensions.WebEncoders.WebEncoderOptions.TextEncoderSettings.set -> void\nMicrosoft.Extensions.WebEncoders.WebEncoderOptions.WebEncoderOptions() -> void\n```\n\n----------------------------------------\n\nTITLE: Installing ASP.NET Core Identity UI Package\nDESCRIPTION: Command to install the Microsoft.AspNetCore.Identity.UI NuGet package using the .NET CLI.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.Identity.UI\n```\n\n----------------------------------------\n\nTITLE: Template Column Implementation\nDESCRIPTION: Template-based column definition allowing custom content rendering for grid cells.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/QuickGrid/Microsoft.AspNetCore.Components.QuickGrid/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.QuickGrid.TemplateColumn<TGridItem> {\n    RenderFragment<TGridItem> ChildContent { get; set; }\n    void TemplateColumn()\n    override bool IsSortableByDefault()\n    override GridSort<TGridItem>? SortBy { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Cleaning NPM Cache to Resolve EPERM Error\nDESCRIPTION: Clears the NPM cache to resolve the 'EPERM: operation not permitted, rename' error that may occur after a fresh NodeJS installation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/GettingStarted.md#2025-04-08_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm cache clean\n```\n\n----------------------------------------\n\nTITLE: Personal Data Management Methods\nDESCRIPTION: Virtual methods for managing user personal data including download, deletion, and general management operations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Identity.UI.V4.Pages.Account.Manage.Internal.DeletePersonalDataModel.OnGet() -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult!>!\nvirtual Microsoft.AspNetCore.Identity.UI.V4.Pages.Account.Manage.Internal.DownloadPersonalDataModel.OnPostAsync() -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult!>!\n```\n\n----------------------------------------\n\nTITLE: Request Handling Error Logger Implementation in C#\nDESCRIPTION: Helper class for logging and throwing exceptions during request processing. Handles various error scenarios including invalid JSON, parameter binding failures, and content type mismatches.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_NoParam_StringReturn.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n\n    public void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n\n    public void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n\n    public void ImplicitBodyNotProvided(string parameterName)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n\n    public void UnexpectedJsonContentType(string? contentType)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n            throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n\n    public void UnexpectedNonFormContentType(string? contentType)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n            throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n\n    public void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Polymorphism Detection for JSON Serialization in ASP.NET Core\nDESCRIPTION: Determines if a JsonTypeInfo instance has known polymorphism characteristics. This helps optimize serialization by identifying types that won't need runtime type resolution.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Post_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Form Content Types in ASP.NET Core\nDESCRIPTION: Method that handles unexpected form content types by either throwing a BadHttpRequestException with status code 415 (Unsupported Media Type) or logging a debug message. Similar to the JSON handler but specific to form data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Response Writing Methods in C#\nDESCRIPTION: Fragment of extension methods for writing JSON responses in ASP.NET Core. These methods handle type checking and polymorphism to determine the appropriate serialization approach.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsString_Has_Metadata.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nreturn HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n            }\n\n            return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n```\n\n----------------------------------------\n\nTITLE: Connection Feature Interfaces\nDESCRIPTION: Interface definitions for various connection features including endpoint management, heartbeat, lifetime, metrics and transport capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Connections.Features.IConnectionEndPointFeature\nMicrosoft.AspNetCore.Connections.Features.IConnectionEndPointFeature.LocalEndPoint.get -> System.Net.EndPoint?\nMicrosoft.AspNetCore.Connections.Features.IConnectionEndPointFeature.LocalEndPoint.set -> void\nMicrosoft.AspNetCore.Connections.Features.IConnectionEndPointFeature.RemoteEndPoint.get -> System.Net.EndPoint?\nMicrosoft.AspNetCore.Connections.Features.IConnectionEndPointFeature.RemoteEndPoint.set -> void\n```\n\n----------------------------------------\n\nTITLE: Accepting WebTransport Stream in C#\nDESCRIPTION: This code shows how to accept an incoming WebTransport stream. It waits for the next stream and returns a ConnectionContext instance. Streams are processed in order, and the method blocks if no streams are pending.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/WebTransport.md#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar connectionContext = await session.AcceptStreamAsync(CancellationToken token);\n```\n\n----------------------------------------\n\nTITLE: IInvocationBinder Interface Definition\nDESCRIPTION: Interface for binding method invocations in SignalR. It provides methods to retrieve parameter types, return types, and stream item types when processing SignalR messages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.IInvocationBinder\nMicrosoft.AspNetCore.SignalR.IInvocationBinder.GetParameterTypes(string! methodName) -> System.Collections.Generic.IReadOnlyList<System.Type!>!\nMicrosoft.AspNetCore.SignalR.IInvocationBinder.GetReturnType(string! invocationId) -> System.Type!\nMicrosoft.AspNetCore.SignalR.IInvocationBinder.GetStreamItemType(string! streamId) -> System.Type!\nMicrosoft.AspNetCore.SignalR.IInvocationBinder.GetTarget(System.ReadOnlySpan<byte> utf8Bytes) -> string?\n```\n\n----------------------------------------\n\nTITLE: Implementing OWIN WebSocket Adapters in C#\nDESCRIPTION: Defines classes for adapting WebSocket functionality to the OWIN environment.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Owin/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Owin.OwinWebSocketAcceptContext.Options.get -> System.Collections.Generic.IDictionary<string, object>\nMicrosoft.AspNetCore.Owin.OwinWebSocketAcceptContext.OwinWebSocketAcceptContext(System.Collections.Generic.IDictionary<string, object> options) -> void\nMicrosoft.AspNetCore.Owin.OwinWebSocketAdapter.OwinWebSocketAdapter(System.Collections.Generic.IDictionary<string, object> websocketContext, string subProtocol) -> void\nMicrosoft.AspNetCore.Owin.WebSocketAcceptAdapter.WebSocketAcceptAdapter(System.Collections.Generic.IDictionary<string, object> env, System.Func<Microsoft.AspNetCore.Http.WebSocketAcceptContext, System.Threading.Tasks.Task<System.Net.WebSockets.WebSocket>> accept) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining CookieRequestCultureProvider Static Methods in C#\nDESCRIPTION: Defines static methods for creating and parsing cookie values for request culture.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Localization.CookieRequestCultureProvider.MakeCookieValue(Microsoft.AspNetCore.Localization.RequestCulture! requestCulture) -> string!\nstatic Microsoft.AspNetCore.Localization.CookieRequestCultureProvider.ParseCookieValue(string! value) -> Microsoft.AspNetCore.Localization.ProviderCultureResult?\n```\n\n----------------------------------------\n\nTITLE: Implementing ExecuteReturnAsync for HTTP Response Processing in C#\nDESCRIPTION: Handles execution of response objects in ASP.NET Core endpoints. It either executes IResult implementations directly or handles string responses with appropriate serialization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n        private static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n        {\n            if (obj is IResult r)\n            {\n                return r.ExecuteAsync(httpContext);\n            }\n            else if (obj is string s)\n            {\n\n```\n\n----------------------------------------\n\nTITLE: Creating JsonSerializer in NewtonsoftJsonOutputFormatter in ASP.NET Core MVC\nDESCRIPTION: This virtual method creates a Newtonsoft.Json.JsonSerializer instance based on the provided OutputFormatterWriteContext. It's used for customizing the serialization process when formatting HTTP responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.NewtonsoftJson/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.Formatters.NewtonsoftJsonOutputFormatter.CreateJsonSerializer(Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterWriteContext! context) -> Newtonsoft.Json.JsonSerializer!\n```\n\n----------------------------------------\n\nTITLE: HTML5 Boilerplate License Notice\nDESCRIPTION: This snippet contains the full text of the license notice for HTML5 Boilerplate, which is included in the ASP.NET Core project. It grants permission to use, modify, and distribute the software under certain conditions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/THIRD-PARTY-NOTICES.txt#2025-04-08_snippet_1\n\nLANGUAGE: Plaintext\nCODE:\n```\n\"Copyright (c) HTML5 Boilerplate\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"\"Software\"\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"\"AS IS\"\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\"\n```\n\n----------------------------------------\n\nTITLE: Authentication Core Service Collection Extensions\nDESCRIPTION: Extension methods for adding authentication core services to the dependency injection container.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Authentication.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.AuthenticationCoreServiceCollectionExtensions.AddAuthenticationCore(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.AuthenticationCoreServiceCollectionExtensions.AddAuthenticationCore(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Authentication.AuthenticationOptions!>! configureOptions) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: UserStore and UserOnlyStore Context Accessors\nDESCRIPTION: Context property getter implementations for UserStore and UserOnlyStore classes that provide access to the Entity Framework Core database context.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserOnlyStore<TUser, TContext, TKey, TUserClaim, TUserLogin, TUserToken>.Context.get -> TContext!\nvirtual Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.Context.get -> TContext!\n```\n\n----------------------------------------\n\nTITLE: Defining LocalRedirect Result Method in C#\nDESCRIPTION: This method creates a local redirect result with options for permanence and method preservation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.LocalRedirect(string! localUrl, bool permanent = false, bool preserveMethod = false) -> Microsoft.AspNetCore.Http.HttpResults.RedirectHttpResult!\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocationAttribute for ASP.NET Core Method Interception\nDESCRIPTION: Defines a sealed attribute class that allows for method interception. It takes a version and data string parameters. This is part of the compiler-generated code for ASP.NET Core routing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\nfile sealed class InterceptsLocationAttribute : Attribute\n{\n    public InterceptsLocationAttribute(int version, string data)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Authorization in Dependency Injection for C#\nDESCRIPTION: This snippet provides extension methods for adding and configuring authorization services in the dependency injection container. It allows for customization of authorization options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.AuthorizationServiceCollectionExtensions.AddAuthorizationCore(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.AuthorizationServiceCollectionExtensions.AddAuthorizationCore(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Authorization.AuthorizationOptions!>! configure) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Implementing Helper Methods for Route Handling in C#\nDESCRIPTION: Includes utility methods for casting delegates, building filter delegates, and executing return values asynchronously in the context of route handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsString_Has_Metadata.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    // Filter delegate building logic\n}\n\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    // Async execution logic for different return types\n}\n\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    // JSON response writing logic\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Delegate Type Casting in ASP.NET Core\nDESCRIPTION: Utility method for safely casting a generic Delegate to a specific delegate type T. This enables type-safe handling of various delegate signatures in the routing system.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pagination in QuickGrid with C#\nDESCRIPTION: This snippet defines the PaginationState and Paginator classes, which handle pagination logic and UI rendering for the QuickGrid component.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/QuickGrid/Microsoft.AspNetCore.Components.QuickGrid/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.QuickGrid.PaginationState\nMicrosoft.AspNetCore.Components.QuickGrid.PaginationState.CurrentPageIndex.get -> int\nMicrosoft.AspNetCore.Components.QuickGrid.PaginationState.ItemsPerPage.get -> int\nMicrosoft.AspNetCore.Components.QuickGrid.PaginationState.ItemsPerPage.set -> void\nMicrosoft.AspNetCore.Components.QuickGrid.PaginationState.LastPageIndex.get -> int?\nMicrosoft.AspNetCore.Components.QuickGrid.PaginationState.PaginationState() -> void\nMicrosoft.AspNetCore.Components.QuickGrid.PaginationState.SetCurrentPageIndexAsync(int pageIndex) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Components.QuickGrid.PaginationState.TotalItemCount.get -> int?\nMicrosoft.AspNetCore.Components.QuickGrid.PaginationState.TotalItemCountChanged -> System.EventHandler<int?>?\nMicrosoft.AspNetCore.Components.QuickGrid.Paginator\nMicrosoft.AspNetCore.Components.QuickGrid.Paginator.Dispose() -> void\nMicrosoft.AspNetCore.Components.QuickGrid.Paginator.Paginator() -> void\nMicrosoft.AspNetCore.Components.QuickGrid.Paginator.State.get -> Microsoft.AspNetCore.Components.QuickGrid.PaginationState!\nMicrosoft.AspNetCore.Components.QuickGrid.Paginator.State.set -> void\nMicrosoft.AspNetCore.Components.QuickGrid.Paginator.SummaryTemplate.get -> Microsoft.AspNetCore.Components.RenderFragment?\nMicrosoft.AspNetCore.Components.QuickGrid.Paginator.SummaryTemplate.set -> void\n```\n\n----------------------------------------\n\nTITLE: Running Error Page Generation Script in PowerShell\nDESCRIPTION: Command for executing the GeneratePage.ps1 script that generates the ErrorPage.Designer.cs file from Views/ErrorPage.cshtml template. This script should be run after making changes to the error page template.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Shared/ErrorPage/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n.\\GeneratePage.ps1\n```\n\n----------------------------------------\n\nTITLE: UserLoginInfo Constructor Signature Changes in ASP.NET Core Identity\nDESCRIPTION: Shows the modification of the UserLoginInfo constructor signature where the third parameter name is changed from 'displayName' to 'providerDisplayName' while maintaining the same parameter type and nullability constraints.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Core/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\nMicrosoft.AspNetCore.Identity.UserLoginInfo.UserLoginInfo(string! loginProvider, string! providerKey, string? displayName) -> void\nMicrosoft.AspNetCore.Identity.UserLoginInfo.UserLoginInfo(string! loginProvider, string! providerKey, string? providerDisplayName) -> void\n```\n\n----------------------------------------\n\nTITLE: NewtonsoftJson Input/Output Formatter Constructors\nDESCRIPTION: Constructor definitions for JSON formatters that handle request/response serialization using Newtonsoft.Json in ASP.NET Core MVC.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.NewtonsoftJson/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic NewtonsoftJsonInputFormatter(ILogger logger, JsonSerializerSettings serializerSettings, ArrayPool<char> charPool, ObjectPoolProvider objectPoolProvider, MvcOptions options, MvcNewtonsoftJsonOptions jsonOptions)\n\npublic NewtonsoftJsonOutputFormatter(JsonSerializerSettings serializerSettings, ArrayPool<char> charPool, MvcOptions mvcOptions)\n\npublic NewtonsoftJsonOutputFormatter(JsonSerializerSettings serializerSettings, ArrayPool<char> charPool, MvcOptions mvcOptions, MvcNewtonsoftJsonOptions? jsonOptions)\n```\n\n----------------------------------------\n\nTITLE: Defining ApplicationBuilderExtensions Methods in C#\nDESCRIPTION: Defines extension methods for IApplicationBuilder to configure request localization middleware.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.ApplicationBuilderExtensions.UseRequestLocalization(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.ApplicationBuilderExtensions.UseRequestLocalization(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app, Microsoft.AspNetCore.Builder.RequestLocalizationOptions! options) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.ApplicationBuilderExtensions.UseRequestLocalization(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app, params string![]! cultures) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.ApplicationBuilderExtensions.UseRequestLocalization(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app, System.Action<Microsoft.AspNetCore.Builder.RequestLocalizationOptions!>! optionsAction) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Implementing MapCore Method for RouteBuilder in C#\nDESCRIPTION: Defines a MapCore method that serves as a core implementation for mapping routes in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_NoParam_StringReturn_WithFilter.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IdentityUser Class in C#\nDESCRIPTION: Defines the IdentityUser class and its generic version for representing users in ASP.NET Core Identity. It includes constructors and properties for user management.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Stores/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.IdentityUser\nMicrosoft.AspNetCore.Identity.IdentityUser.IdentityUser() -> void\nMicrosoft.AspNetCore.Identity.IdentityUser.IdentityUser(string! userName) -> void\nMicrosoft.AspNetCore.Identity.IdentityUser<TKey>\nMicrosoft.AspNetCore.Identity.IdentityUser<TKey>.IdentityUser() -> void\nMicrosoft.AspNetCore.Identity.IdentityUser<TKey>.IdentityUser(string! userName) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing Route Handler Mapping with Request Delegate Generation in ASP.NET Core\nDESCRIPTION: Maps route patterns to handler methods, configuring endpoint metadata and creating appropriate request delegates. The implementation supports parameter binding, filtering, and response generation with proper content type handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_NullableReturn.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive to enable nullable reference type checking, which helps catch potential null reference exceptions at compile time. This is a C# 8.0+ feature that enforces more strict null checking.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Extensions/Features/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining ConnectionHandler Abstract Class in C#\nDESCRIPTION: Provides an abstract base for handling connections, with a method for handling connected connections asynchronously.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Connections.ConnectionHandler.OnConnectedAsync(Microsoft.AspNetCore.Connections.ConnectionContext! connection) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Overriding User Management Methods in ASP.NET Core Identity EntityFrameworkCore\nDESCRIPTION: This snippet shows the signatures of overridden methods in the UserStore class for managing users, roles, claims, and logins. These methods interact with the underlying EntityFrameworkCore database to perform CRUD operations on user-related data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.FindByNameAsync(string! normalizedUserName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<TUser?>!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.FindRoleAsync(string! normalizedRoleName, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TRole?>!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.FindTokenAsync(TUser! user, string! loginProvider, string! name, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TUserToken?>!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.FindUserAsync(TKey userId, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TUser?>!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.FindUserLoginAsync(string! loginProvider, string! providerKey, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TUserLogin?>!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.FindUserLoginAsync(TKey userId, string! loginProvider, string! providerKey, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TUserLogin?>!\n\noverride Microsoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.FindUserRoleAsync(TKey userId, TKey roleId, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TUserRole?>!\n```\n\n----------------------------------------\n\nTITLE: Implementing Parameter Binding Metadata in ASP.NET Core\nDESCRIPTION: This class implements the IParameterBindingMetadata interface to provide metadata for parameter binding in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: DiagnosticMessage Class Definition\nDESCRIPTION: Class for representing diagnostic messages with source file location information and formatted message content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Diagnostics.DiagnosticMessage.DiagnosticMessage(string? message, string? formattedMessage, string? filePath, int startLine, int startColumn, int endLine, int endColumn) -> void\n```\n\n----------------------------------------\n\nTITLE: Checking for Defined Attributes in C#\nDESCRIPTION: This method checks if a specific attribute type is defined on either the construction parameter or the underlying property.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic override bool IsDefined(Type attributeType, bool inherit)\n{\n    return (_constructionParameterInfo is not null && _constructionParameterInfo.IsDefined(attributeType, inherit)) ||\n        _underlyingProperty.IsDefined(attributeType, inherit);\n}\n```\n\n----------------------------------------\n\nTITLE: Unexpected JSON Content Type Handling in C#\nDESCRIPTION: Handles cases where an unexpected JSON content type is received. Includes logging logic using ILogger and conditional throwing of BadHttpRequestException.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_MultipleStringParam_StringReturn.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nif (_rdgLogger != null)\n{\n    _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n}\n\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Methods for StackExchange Redis Cache in ASP.NET Core\nDESCRIPTION: Defines extension methods for adding StackExchange Redis cache to the ASP.NET Core dependency injection container. It includes a method for configuring the Redis cache options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.DependencyInjection.StackExchangeRedisCacheServiceCollectionExtensions\nstatic Microsoft.Extensions.DependencyInjection.StackExchangeRedisCacheServiceCollectionExtensions.AddStackExchangeRedisCache(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions!>! setupAction) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Defining HeaderQuality Constants in C#\nDESCRIPTION: Defines constant values for header quality matching in the Microsoft.Net.Http.Headers namespace.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Headers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.Net.Http.Headers.HeaderQuality.Match = 1 -> double\nconst Microsoft.Net.Http.Headers.HeaderQuality.NoMatch = 0 -> double\n```\n\n----------------------------------------\n\nTITLE: OpenAPI Schema Definition with Schema References\nDESCRIPTION: Comprehensive OpenAPI schema definition that describes multiple API endpoints with schema references, response types, and request parameters. Contains endpoint definitions for handling primitive types, collections, and custom objects.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/test/Microsoft.AspNetCore.OpenApi.Tests/Integration/snapshots/OpenApi3_1/OpenApiDocumentIntegrationTests.VerifyOpenApiDocument_documentName=schemas-by-ref.verified.txt#2025-04-08_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"openapi\": \"3.1.1\",\n  \"info\": {\n    \"title\": \"Sample | schemas-by-ref\",\n    \"version\": \"1.0.0\"\n  },\n  \"paths\": {\n    \"/schemas-by-ref/typed-results\": {\n      \"get\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/Triangle\"\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"/schemas-by-ref/multiple-results\": {\n      \"get\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/Triangle\"\n                }\n              }\n            }\n          },\n          \"404\": {\n            \"description\": \"Not Found\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    // Additional paths truncated for brevity\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DelegatingTimer Class in C# for HTTP Logging\nDESCRIPTION: A class that implements ITimer by wrapping another ITimer instance and executing an action when disposed. This allows HTTP logging code to be notified when a timer is no longer needed. The implementation includes standard timer operations that delegate to the inner timer.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/netstandard2.0/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n\nusing System;\nusing Microsoft.Extensions.Internal;\n\nnamespace Microsoft.AspNetCore.HttpLogging;\n\ninternal sealed class DelegatingTimer : ITimer\n{\n    private readonly ITimer _innerTimer;\n    private readonly Action _onDispose;\n\n    public DelegatingTimer(ITimer innerTimer, Action onDispose)\n    {\n        _innerTimer = innerTimer;\n        _onDispose = onDispose;\n    }\n\n    public void Change(TimeSpan dueTime, TimeSpan period)\n    {\n        _innerTimer.Change(dueTime, period);\n    }\n\n    public void Dispose()\n    {\n        _innerTimer.Dispose();\n        _onDispose();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Testing Projects from Command Line\nDESCRIPTION: Commands to build and test projects in Linux/Mac and Windows environments using local build scripts.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/BuildFromSource.md#2025-04-08_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# Linux or Mac\n./build.sh\n./build.sh -test\n```\n\nLANGUAGE: powershell\nCODE:\n```\n# Windows\n./build.cmd\n./build.cmd -test\n```\n\n----------------------------------------\n\nTITLE: Implementing StringLocalizerExtensions in C#\nDESCRIPTION: Extension methods for IStringLocalizer interface providing convenient access to localized strings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Localization/Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.Localization.StringLocalizerExtensions.GetAllStrings(this Microsoft.Extensions.Localization.IStringLocalizer! stringLocalizer) -> System.Collections.Generic.IEnumerable<Microsoft.Extensions.Localization.LocalizedString!>!\nstatic Microsoft.Extensions.Localization.StringLocalizerExtensions.GetString(this Microsoft.Extensions.Localization.IStringLocalizer! stringLocalizer, string! name) -> Microsoft.Extensions.Localization.LocalizedString!\nstatic Microsoft.Extensions.Localization.StringLocalizerExtensions.GetString(this Microsoft.Extensions.Localization.IStringLocalizer! stringLocalizer, string! name, params object![]! arguments) -> Microsoft.Extensions.Localization.LocalizedString!\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants Definition in C#\nDESCRIPTION: Defines static constants for common HTTP content types used in request/response handling. Includes JSON, plaintext, form data, and URL-encoded form content types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: InferParameterBindingInfoConvention Class Definition in ASP.NET Core MVC\nDESCRIPTION: A convention that infers parameter binding information based on the parameter type and metadata. It supports dependency on model metadata provider and service provider for determining binding behavior.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ApplicationModels.InferParameterBindingInfoConvention\nMicrosoft.AspNetCore.Mvc.ApplicationModels.InferParameterBindingInfoConvention.Apply(Microsoft.AspNetCore.Mvc.ApplicationModels.ActionModel! action) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.InferParameterBindingInfoConvention.InferParameterBindingInfoConvention(Microsoft.AspNetCore.Mvc.ModelBinding.IModelMetadataProvider! modelMetadataProvider) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.InferParameterBindingInfoConvention.InferParameterBindingInfoConvention(Microsoft.AspNetCore.Mvc.ModelBinding.IModelMetadataProvider! modelMetadataProvider, Microsoft.Extensions.DependencyInjection.IServiceProviderIsService! serviceProviderIsService) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Auto-generated attribute class definition for method interception used in ASP.NET Core routing. The attribute takes version and data parameters and can be applied multiple times to methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nfile sealed class InterceptsLocationAttribute : Attribute\n{\n    public InterceptsLocationAttribute(int version, string data)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: A preprocessor directive that enables nullable reference type checking for the current file. This improves type safety by making reference type nullability explicit.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Configuration.KeyPerFile/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing GraphQLQueryBuilder Class in C#\nDESCRIPTION: Defines a class for building GraphQL queries with support for fields, arguments, variables, and aliases. The class uses a fluent interface pattern for constructing queries and manages serialization of query components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/StackExchangeRedis/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: File System Repository Implementation\nDESCRIPTION: Virtual methods for managing XML elements in the file system, including storage, retrieval, and deletion operations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository.DeleteElements(System.Action<System.Collections.Generic.IReadOnlyCollection<Microsoft.AspNetCore.DataProtection.Repositories.IDeletableElement!>!>! chooseElements) -> bool\nvirtual Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository.GetAllElements() -> System.Collections.Generic.IReadOnlyCollection<System.Xml.Linq.XElement!>!\nvirtual Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository.StoreElement(System.Xml.Linq.XElement! element, string! friendlyName) -> void\n```\n\n----------------------------------------\n\nTITLE: Adding Razor Pages Support to MVC Core in ASP.NET Core\nDESCRIPTION: Extension methods for IMvcCoreBuilder that add Razor Pages support to the MVC Core system. These methods register the necessary services for Razor Pages to function and allow optional configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.MvcRazorPagesMvcCoreBuilderExtensions.AddRazorPages(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder! builder) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder!\nstatic Microsoft.Extensions.DependencyInjection.MvcRazorPagesMvcCoreBuilderExtensions.AddRazorPages(this Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder! builder, System.Action<Microsoft.AspNetCore.Mvc.RazorPages.RazorPagesOptions!>! setupAction) -> Microsoft.Extensions.DependencyInjection.IMvcCoreBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining Header Propagation Context Class in C#\nDESCRIPTION: Class definition for HeaderPropagationContext that holds information about HTTP context and header values for propagation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HeaderPropagation/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.HeaderPropagation.HeaderPropagationContext.HeaderName.get -> string!\nMicrosoft.AspNetCore.HeaderPropagation.HeaderPropagationContext.HeaderPropagationContext() -> void\nMicrosoft.AspNetCore.HeaderPropagation.HeaderPropagationContext.HeaderPropagationContext(Microsoft.AspNetCore.Http.HttpContext! httpContext, string! headerName, Microsoft.Extensions.Primitives.StringValues headerValue) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing C# Methods for SignalR Protocol Examples\nDESCRIPTION: A collection of C# methods demonstrating different invocation patterns supported by the SignalR protocol, including single result methods, streaming methods, error handling cases, and upload streaming functionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic int Add(int x, int y)\n{\n    return x + y;\n}\n\npublic int SingleResultFailure(int x, int y)\n{\n    throw new Exception(\"It didn't work!\");\n}\n\npublic IEnumerable<int> Batched(int count)\n{\n    for (var i = 0; i < count; i++)\n    {\n        yield return i;\n    }\n}\n\npublic async IAsyncEnumerable<int> Stream(int count)\n{\n    for (var i = 0; i < count; i++)\n    {\n        await Task.Delay(10);\n        yield return i;\n    }\n}\n\npublic async IAsyncEnumerable<int> StreamFailure(int count)\n{\n    for (var i = 0; i < count; i++)\n    {\n        await Task.Delay(10);\n        yield return i;\n    }\n    throw new Exception(\"Ran out of data!\");\n}\n\nprivate List<string> _callers = new List<string>();\npublic void NonBlocking(string caller)\n{\n    _callers.Add(caller);\n}\n\npublic async Task<int> AddStream(IAsyncEnumerable<int> stream)\n{\n    int sum = 0;\n    await foreach(var item in stream)\n    {\n        sum += item;\n    }\n    return sum;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining InsertOrAppendAttribute Class in C#\nDESCRIPTION: This snippet defines the InsertOrAppendAttribute class in the Microsoft.Web.Xdt.Extensions namespace. It includes a constructor, methods for getting attribute names and argument values, and an override for the Apply method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SiteExtensions/Microsoft.Web.Xdt.Extensions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n~Microsoft.Web.Xdt.Extensions.InsertOrAppendAttribute.AttributeName.get -> string\n~Microsoft.Web.Xdt.Extensions.InsertOrAppendAttribute.GetArgumentValue(string name) -> string\nMicrosoft.Web.Xdt.Extensions.InsertOrAppendAttribute\nMicrosoft.Web.Xdt.Extensions.InsertOrAppendAttribute.InsertOrAppendAttribute() -> void\noverride Microsoft.Web.Xdt.Extensions.InsertOrAppendAttribute.Apply() -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocation Attribute in C#\nDESCRIPTION: Defines a sealed attribute class for method interception with version and data parameters. Used for compile-time method interception in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nfile sealed class InterceptsLocationAttribute : Attribute\n{\n    public InterceptsLocationAttribute(int version, string data)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Action Descriptor Class Definition in C#\nDESCRIPTION: Class definition for ActionDescriptor that contains properties for routing, constraints, and endpoint metadata in ASP.NET Core MVC routing system.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Abstractions.ActionDescriptor\nMicrosoft.AspNetCore.Mvc.Abstractions.ActionDescriptor.ActionConstraints.get -> System.Collections.Generic.IList<Microsoft.AspNetCore.Mvc.ActionConstraints.IActionConstraintMetadata!>?\nMicrosoft.AspNetCore.Mvc.Abstractions.ActionDescriptor.ActionConstraints.set -> void\nMicrosoft.AspNetCore.Mvc.Abstractions.ActionDescriptor.ActionDescriptor() -> void\n```\n\n----------------------------------------\n\nTITLE: Excluding Clients from All Connections in ASP.NET Core SignalR\nDESCRIPTION: These methods allow excluding specific clients from all connections. They provide overloads for excluding up to 8 individual connection IDs or a collection of connection IDs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.HubClientsExtensions.AllExcept<T>(this Microsoft.AspNetCore.SignalR.IHubClients<T>! hubClients, string! excludedConnectionId1) -> T\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.HubClientsExtensions.AllExcept<T>(this Microsoft.AspNetCore.SignalR.IHubClients<T>! hubClients, System.Collections.Generic.IEnumerable<string!>! excludedConnectionIds) -> T\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: This directive enables C# nullable reference types feature, which helps prevent null reference exceptions by making nullability part of the type system. When enabled, reference types are non-nullable by default and must be explicitly marked as nullable with the '?' operator.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Features/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Displaying Area Owners Table in Markdown\nDESCRIPTION: This code snippet is a markdown table that lists area labels, their owners, documentation owners, and descriptions for the dotnet/aspnetcore repository. It provides a comprehensive overview of different areas of responsibility within the project.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/area-owners.md#2025-04-08_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| area label                                                                                                                    | Owners                                                                                                                                                                                                                     | Doc Owners | Description                                                                                                                                                            |\n| ----------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **[area-auth](https://github.com/dotnet/aspnetcore/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-auth)**                         | [@joperezr](https://github.com/joperezr) [@mikekistler](https://github.com/mikekistler) [@halter73](https://github.com/halter73) [@mackinnonbuck](https://github.com/mackinnonbuck)                                        | [@Rick-Anderson](https://github.com/Rick-Anderson) | Authn, Authz, OAuth, OIDC, Bearer                                                                                                                                      |\n| **[area-blazor](https://github.com/dotnet/aspnetcore/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-blazor)**                     | [@lewing](https://github.com/lewing) [@danroth27](https://github.com/danroth27) [@aspnet-blazor-eng](https://github.com/aspnet-blazor-eng)                                                                                 | [@guardrex](https://github.com/guardrex)  | Blazor, Razor Components (WASM issues may be moved to dotnet/runtime repo)                                                                                             |\n| **[area-commandlinetools](https://github.com/dotnet/aspnetcore/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-commandlinetools)** | [@adityamandaleeka](https://github.com/adityamandaleeka) [@mikekistler](https://github.com/mikekistler) [@captainsafia](https://github.com/captainsafia)                                                                   | [@Rick-Anderson](https://github.com/Rick-Anderson) | Command line tools, dotnet-dev-certs, dotnet-user-jwts, and OpenAPI                                                                                                    |\n| **[area-dataprotection](https://github.com/dotnet/aspnetcore/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-dataprotection)**     | [@adityamandaleeka](https://github.com/adityamandaleeka) [@DeagleGross](https://github.com/DeagleGross)                                                                                                                    | [@Rick-Anderson](https://github.com/Rick-Anderson) | DataProtection                                                                                                                                                         |\n| **[area-grpc](https://github.com/dotnet/aspnetcore/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-grpc)**                         | [@adityamandaleeka](https://github.com/adityamandaleeka) [@mikekistler](https://github.com/mikekistler) [@jamesnk](https://github.com/jamesnk) [@mgravell](https://github.com/mgravell)                                    | [@wadepickett](https://github.com/wadepickett)  | GRPC wire-up, templates (library itself is  https://github.com/grpc/grpc-dotnet)                                                                                       |\n| **[area-healthchecks](https://github.com/dotnet/aspnetcore/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-healthchecks)**         | [@adityamandaleeka](https://github.com/adityamandaleeka) [@samsp-msft](https://github.com/samsp-msft) [@brennanconroy](https://github.com/brennanconroy)                                                                   | [@Rick-Anderson](https://github.com/Rick-Anderson) | Healthchecks (some bugs also in Extensions repo)                                                                                                                       |\n| **[area-hosting](https://github.com/dotnet/aspnetcore/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-hosting)**                   | [@joperezr](https://github.com/joperezr) [@danroth27](https://github.com/danroth27) [@halter73](https://github.com/halter73)                                                                                               | [@Rick-Anderson](https://github.com/Rick-Anderson) | Includes Hosting                                                                                                                                                       |\n| **[area-identity](https://github.com/dotnet/aspnetcore/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-identity)**                 | [@joperezr](https://github.com/joperezr) [@mikekistler](https://github.com/mikekistler) [@halter73](https://github.com/halter73) [@mackinnonbuck](https://github.com/mackinnonbuck)                                        | [@Rick-Anderson](https://github.com/Rick-Anderson) | Identity and providers                                                                                                                                                 |\n| **[area-infrastructure](https://github.com/dotnet/aspnetcore/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-infrastructure)**     | [@joperezr](https://github.com/joperezr) [@wtgodbe](https://github.com/wtgodbe)                                                                                                                                            | [@Rick-Anderson](https://github.com/Rick-Anderson) | MSBuild projects/targets, build scripts, CI, Installers and shared framework                                                                                           |\n| **[area-middleware](https://github.com/dotnet/aspnetcore/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-middleware)**             | [@adityamandaleeka](https://github.com/adityamandaleeka) [@samsp-msft](https://github.com/samsp-msft) [@brennanconroy](https://github.com/brennanconroy)                                                                   | [@Rick-Anderson](https://github.com/Rick-Anderson) | URL rewrite, redirect, response cache/compression, session, caching, and other general middlewares                                                                     |\n| **[area-minimal](https://github.com/dotnet/aspnetcore/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-minimal)**                   | [@adityamandaleeka](https://github.com/adityamandaleeka) [@mikekistler](https://github.com/mikekistler) [@captainsafia](https://github.com/captainsafia) [@mitchdenny](https://github.com/mitchdenny)                      | [@wadepickett](https://github.com/wadepickett)  | Includes minimal APIs, endpoint filters, parameter binding, request delegate generator etc                                                                             |\n| **[area-mvc](https://github.com/dotnet/aspnetcore/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-mvc)**                           | [@adityamandaleeka](https://github.com/adityamandaleeka) [@mikekistler](https://github.com/mikekistler) [@captainsafia](https://github.com/captainsafia)                                                                   | [@Rick-Anderson](https://github.com/Rick-Anderson) | MVC, Actions and Controllers, Localization, CORS, most templates                                                                                                       |\n| **[area-networking](https://github.com/dotnet/aspnetcore/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-networking)**             | [@adityamandaleeka](https://github.com/adityamandaleeka) [@samsp-msft](https://github.com/samsp-msft) [@brennanconroy](https://github.com/brennanconroy) [@DeagleGross](https://github.com/DeagleGross)                    | [@Rick-Anderson](https://github.com/Rick-Anderson) | Includes Kestrel/servers, protocols such as HTTP/2, HTTP3, YARP, jsonpatch, bedrock, websockets, http client factory, http abstractions, networking aspects of caching |\n| **[area-perf](https://github.com/dotnet/aspnetcore/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-perf)**                         | [@joperezr](https://github.com/joperezr) [@sebastienros](https://github.com/sebastienros)                                                                                                                                  | [@Rick-Anderson](https://github.com/Rick-Anderson) | Autofiled performance bugs, perf infra.                                                                                                                                |\n| **[area-routing](https://github.com/dotnet/aspnetcore/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-routing)**                   | [@joperezr](https://github.com/joperezr) [@danroth27](https://github.com/danroth27) [@halter73](https://github.com/halter73) [@JamesNK](https://github.com/JamesNK) ([@javiercn](https://github.com/javiercn)  consulting) | [@Rick-Anderson](https://github.com/Rick-Anderson) | Routing                                                                                                                                                                |\n```\n\n----------------------------------------\n\nTITLE: Defining Facebook Authentication Constants\nDESCRIPTION: Defines constant values used for Facebook authentication including the authentication scheme name, endpoints, and display name.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Facebook/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.Authentication.Facebook.FacebookDefaults.AuthenticationScheme = \"Facebook\" -> string!\n```\n\n----------------------------------------\n\nTITLE: Defining IRequestCultureProvider Interface in C#\nDESCRIPTION: This interface defines a contract for providers that can determine the culture information of an HTTP request. It contains a method to determine the request culture with a specified fallback handler.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HealthChecks/HealthChecks/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: MultiSelectList Constructor Implementations - ASP.NET Core MVC\nDESCRIPTION: Constructor overloads for creating MultiSelectList instances with various parameters to support dropdown lists with multiple selection capability.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Rendering.MultiSelectList {\n    MultiSelectList(IEnumerable items);\n    MultiSelectList(IEnumerable items, string dataValueField, string dataTextField);\n    MultiSelectList(IEnumerable items, string dataValueField, string dataTextField, IEnumerable selectedValues);\n    MultiSelectList(IEnumerable items, string dataValueField, string dataTextField, IEnumerable selectedValues, string dataGroupField);\n    MultiSelectList(IEnumerable items, IEnumerable selectedValues);\n}\n```\n\n----------------------------------------\n\nTITLE: Filtered Request Handler for String Route Parameter\nDESCRIPTION: Implements filtered request handling with async processing for endpoints accepting a string route parameter. Includes parameter validation and filtered invocation of the handler.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitSource_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nasync Task RequestHandlerFiltered(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var value_raw = value_RouteOrQueryResolver(httpContext);\n    if (value_raw is StringValues { Count: 0 })\n    {\n        wasParamCheckFailure = true;\n        logOrThrowExceptionHelper.RequiredParameterNotProvided(\"string\", \"value\", \"route or query string\");\n    }\n    var value_temp = (string?)value_raw;\n    string value_local = value_temp!;\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n    }\n    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::System.String>(httpContext, value_local!));\n    if (result is not null)\n    {\n        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending IServiceCollection for Middleware Options in ASP.NET Core\nDESCRIPTION: This snippet defines extension methods for IServiceCollection to configure HTTPS redirection and HSTS options. It allows for easy setup of these options in the application's startup configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/SqlServer/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Microsoft.Extensions.DependencyInjection;\n\n/// <summary>\n/// Extension methods for the HttpsRedirection middleware.\n/// </summary>\npublic static class HttpsPolicyServiceCollectionExtensions\n{\n    /// <summary>\n    /// Adds HTTPS redirection services.\n    /// </summary>\n    /// <param name=\"services\">The <see cref=\"IServiceCollection\"/> for adding services.</param>\n    /// <returns></returns>\n    public static IServiceCollection AddHttpsRedirection(this IServiceCollection services)\n    {\n        if (services == null)\n        {\n            throw new ArgumentNullException(nameof(services));\n        }\n\n        services.AddOptions();\n        return services;\n    }\n\n    /// <summary>\n    /// Adds HTTPS redirection services and configures the <see cref=\"HttpsRedirectionOptions\"/>.\n    /// </summary>\n    /// <param name=\"services\">The <see cref=\"IServiceCollection\"/> for adding services.</param>\n    /// <param name=\"configureOptions\">A delegate to configure the <see cref=\"HttpsRedirectionOptions\"/>.</param>\n    /// <returns></returns>\n    public static IServiceCollection AddHttpsRedirection(this IServiceCollection services, Action<HttpsRedirectionOptions> configureOptions)\n    {\n        if (services == null)\n        {\n            throw new ArgumentNullException(nameof(services));\n        }\n        if (configureOptions == null)\n        {\n            throw new ArgumentNullException(nameof(configureOptions));\n        }\n\n        services.Configure(configureOptions);\n        return services.AddHttpsRedirection();\n    }\n\n    /// <summary>\n    /// Adds HSTS services.\n    /// </summary>\n    /// <param name=\"services\">The <see cref=\"IServiceCollection\"/> for adding services.</param>\n    /// <returns></returns>\n    public static IServiceCollection AddHsts(this IServiceCollection services)\n    {\n        if (services == null)\n        {\n            throw new ArgumentNullException(nameof(services));\n        }\n\n        services.AddOptions();\n        return services;\n    }\n\n    /// <summary>\n    /// Adds HSTS services and configures the <see cref=\"HstsOptions\"/>.\n    /// </summary>\n    /// <param name=\"services\">The <see cref=\"IServiceCollection\"/> for adding services.</param>\n    /// <param name=\"configureOptions\">A delegate to configure the <see cref=\"HstsOptions\"/>.</param>\n    /// <returns></returns>\n    public static IServiceCollection AddHsts(this IServiceCollection services, Action<HstsOptions> configureOptions)\n    {\n        if (services == null)\n        {\n            throw new ArgumentNullException(nameof(services));\n        }\n        if (configureOptions == null)\n        {\n            throw new ArgumentNullException(nameof(configureOptions));\n        }\n\n        services.Configure(configureOptions);\n        return services.AddHsts();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cookie Policy Configuration Options\nDESCRIPTION: Configuration class for cookie policy settings, including consent requirements, HTTP only policy, secure cookie policy, and minimum SameSite policy. These options control how the middleware processes cookies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/CookiePolicy/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.CheckConsentNeeded.get -> System.Func<Microsoft.AspNetCore.Http.HttpContext!, bool>?\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.CheckConsentNeeded.set -> void\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.ConsentCookie.get -> Microsoft.AspNetCore.Http.CookieBuilder!\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.ConsentCookie.set -> void\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.ConsentCookieValue.get -> string!\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.ConsentCookieValue.set -> void\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.CookiePolicyOptions() -> void\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.HttpOnly.get -> Microsoft.AspNetCore.CookiePolicy.HttpOnlyPolicy\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.HttpOnly.set -> void\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.MinimumSameSitePolicy.get -> Microsoft.AspNetCore.Http.SameSiteMode\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.MinimumSameSitePolicy.set -> void\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.OnAppendCookie.get -> System.Action<Microsoft.AspNetCore.CookiePolicy.AppendCookieContext!>?\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.OnAppendCookie.set -> void\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.OnDeleteCookie.get -> System.Action<Microsoft.AspNetCore.CookiePolicy.DeleteCookieContext!>?\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.OnDeleteCookie.set -> void\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.Secure.get -> Microsoft.AspNetCore.Http.CookieSecurePolicy\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.Secure.set -> void\n```\n\n----------------------------------------\n\nTITLE: Cookie Policy Configuration Options\nDESCRIPTION: Configuration class for cookie policy settings, including consent requirements, HTTP only policy, secure cookie policy, and minimum SameSite policy. These options control how the middleware processes cookies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/CookiePolicy/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.CheckConsentNeeded.get -> System.Func<Microsoft.AspNetCore.Http.HttpContext!, bool>?\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.CheckConsentNeeded.set -> void\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.ConsentCookie.get -> Microsoft.AspNetCore.Http.CookieBuilder!\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.ConsentCookie.set -> void\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.ConsentCookieValue.get -> string!\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.ConsentCookieValue.set -> void\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.CookiePolicyOptions() -> void\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.HttpOnly.get -> Microsoft.AspNetCore.CookiePolicy.HttpOnlyPolicy\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.HttpOnly.set -> void\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.MinimumSameSitePolicy.get -> Microsoft.AspNetCore.Http.SameSiteMode\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.MinimumSameSitePolicy.set -> void\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.OnAppendCookie.get -> System.Action<Microsoft.AspNetCore.CookiePolicy.AppendCookieContext!>?\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.OnAppendCookie.set -> void\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.OnDeleteCookie.get -> System.Action<Microsoft.AspNetCore.CookiePolicy.DeleteCookieContext!>?\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.OnDeleteCookie.set -> void\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.Secure.get -> Microsoft.AspNetCore.Http.CookieSecurePolicy\nMicrosoft.AspNetCore.Builder.CookiePolicyOptions.Secure.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining ICorsPolicyProvider Interface in C#\nDESCRIPTION: Defines the ICorsPolicyProvider interface with a method to asynchronously retrieve a CORS policy based on the HTTP context and policy name.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Cors.Infrastructure.ICorsPolicyProvider.GetPolicyAsync(Microsoft.AspNetCore.Http.HttpContext! context, string? policyName) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Cors.Infrastructure.CorsPolicy?>!\n```\n\n----------------------------------------\n\nTITLE: NamedPipeEndPoint and UriEndPoint Method Overrides\nDESCRIPTION: Override implementations for common object methods in NamedPipeEndPoint and UriEndPoint classes including Equals, GetHashCode, and ToString.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/netstandard2.1/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Connections.NamedPipeEndPoint.Equals(object? obj) -> bool\noverride Microsoft.AspNetCore.Connections.NamedPipeEndPoint.GetHashCode() -> int\noverride Microsoft.AspNetCore.Connections.NamedPipeEndPoint.ToString() -> string!\noverride Microsoft.AspNetCore.Connections.UriEndPoint.ToString() -> string!\n```\n\n----------------------------------------\n\nTITLE: MVC Diagnostic Event Constants in C#\nDESCRIPTION: Constant definitions for various MVC diagnostic event names used in the framework.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.Mvc.Diagnostics.AfterViewComponentEventData.EventName = \"Microsoft.AspNetCore.Mvc.AfterViewComponent\" -> string\nconst Microsoft.AspNetCore.Mvc.Diagnostics.AfterViewEventData.EventName = \"Microsoft.AspNetCore.Mvc.AfterView\" -> string\n```\n\n----------------------------------------\n\nTITLE: TempData Serialization Interface Definition in C#\nDESCRIPTION: Abstract interface definitions for serializing and deserializing TempData in ASP.NET Core MVC.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Mvc.ViewFeatures.Infrastructure.TempDataSerializer.Deserialize(byte[] unprotectedData) -> System.Collections.Generic.IDictionary<string, object>\nabstract Microsoft.AspNetCore.Mvc.ViewFeatures.Infrastructure.TempDataSerializer.Serialize(System.Collections.Generic.IDictionary<string, object> values) -> byte[]\n```\n\n----------------------------------------\n\nTITLE: Displaying Request Delegate Generator Diagnostic Codes in Markdown\nDESCRIPTION: A markdown table listing Request Delegate Generator-specific diagnostic codes (RDG001-RDG010) with their corresponding descriptions. These codes address issues related to route patterns, endpoint handlers, and parameter resolution.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/list-of-diagnostics.md#2025-04-08_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n### Request Delegate Generator  (`RDG001-RDG004`)\n\n| Diagnostic ID     | Description |\n| :---------------- | :---------- |\n|  __`RDG001`__ | Unable to resolve route pattern |\n|  __`RDG002`__ | Unable to resolve endpoint handler |\n|  __`RDG003`__ | Unable to resolve parameter |\n|  __`RDG004`__ | Unable to resolve anonymous type |\n|  __`RDG005`__ | Invalid abstract type |\n|  __`RDG006`__ | Invalid constructor parameters |\n|  __`RDG007`__ | No valid constructor found |\n|  __`RDG008`__ | Multiple public constructors found |\n|  __`RDG009`__ | Invalid nested AsParameters |\n|  __`RDG010`__ | Unexpected nullable type |\n```\n\n----------------------------------------\n\nTITLE: Defining IIS Environment Feature Interface in C#\nDESCRIPTION: This interface defines properties for accessing IIS environment information in ASP.NET Core applications, including application paths, IIS version, and site details.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/IIS/IIS/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Server.IIS.IIISEnvironmentFeature\nMicrosoft.AspNetCore.Server.IIS.IIISEnvironmentFeature.AppConfigPath.get -> string!\nMicrosoft.AspNetCore.Server.IIS.IIISEnvironmentFeature.ApplicationId.get -> string!\nMicrosoft.AspNetCore.Server.IIS.IIISEnvironmentFeature.ApplicationPhysicalPath.get -> string!\nMicrosoft.AspNetCore.Server.IIS.IIISEnvironmentFeature.ApplicationVirtualPath.get -> string!\nMicrosoft.AspNetCore.Server.IIS.IIISEnvironmentFeature.AppPoolConfigFile.get -> string!\nMicrosoft.AspNetCore.Server.IIS.IIISEnvironmentFeature.AppPoolId.get -> string!\nMicrosoft.AspNetCore.Server.IIS.IIISEnvironmentFeature.IISVersion.get -> System.Version!\nMicrosoft.AspNetCore.Server.IIS.IIISEnvironmentFeature.SiteId.get -> uint\nMicrosoft.AspNetCore.Server.IIS.IIISEnvironmentFeature.SiteName.get -> string!\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Action for Invalid Form Request Bodies\nDESCRIPTION: Creates a static logger action using LoggerMessage.Define to handle failed form parameter parsing. This implementation accepts parameter type and name as arguments and optimizes logging performance.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n    LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Handling Parameter Binding Failures in ASP.NET Core\nDESCRIPTION: Handles cases where parameter binding fails, throwing BadHttpRequestException if configured or logging the failure at Debug level.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ErrorContext Class Definition\nDESCRIPTION: Class for maintaining context about errors, including HTTP context and exception information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Diagnostics.ErrorContext.ErrorContext(Microsoft.AspNetCore.Http.HttpContext! httpContext, System.Exception! exception) -> void\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C# for ASP.NET Core\nDESCRIPTION: This directive enables nullable reference types, which helps catch potential null reference exceptions at compile-time. It's typically used at the top of C# files or in a project-wide context.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Configuring NuGet Sources for .NET 8 Daily Builds\nDESCRIPTION: XML configuration for NuGet.Config file to enable .NET 8 daily builds. Specifies package sources including the dotnet8 Azure DevOps feed and NuGet.org.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/DailyBuilds.md#2025-04-08_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n    <packageSources>\n        <clear />\n        <add key=\"dotnet8\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8/nuget/v3/index.json\" />\n        <add key=\"NuGet.org\" value=\"https://api.nuget.org/v3/index.json\" />\n    </packageSources>\n</configuration>\n```\n\n----------------------------------------\n\nTITLE: Defining Negotiate Authentication Constants\nDESCRIPTION: Defines the default authentication scheme constant for Negotiate authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Negotiate/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.Authentication.Negotiate.NegotiateDefaults.AuthenticationScheme = \"Negotiate\"\n```\n\n----------------------------------------\n\nTITLE: Handling Parameter Binding Failures in ASP.NET Core\nDESCRIPTION: Handles cases where parameter binding fails, throwing BadHttpRequestException if configured or logging the failure at Debug level.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: JSRuntime Core Methods\nDESCRIPTION: Core virtual methods for JavaScript runtime operations including in-process JS invocation, byte array handling, and stream operations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/JSInterop/Microsoft.JSInterop/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.JSInterop.JSInProcessRuntime.InvokeJS(string! identifier, string? argsJson) -> string?\nvirtual Microsoft.JSInterop.JSRuntime.BeginInvokeJS(long taskId, string! identifier, string? argsJson) -> void\nvirtual Microsoft.JSInterop.JSRuntime.ReadJSDataAsStreamAsync(Microsoft.JSInterop.IJSStreamReference! jsStreamReference, long totalLength, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<System.IO.Stream!>!\nvirtual Microsoft.JSInterop.JSRuntime.ReceiveByteArray(int id, byte[]! data) -> void\nvirtual Microsoft.JSInterop.JSRuntime.SendByteArray(int id, byte[]! data) -> void\nvirtual Microsoft.JSInterop.JSRuntime.TransmitStreamAsync(long streamId, Microsoft.JSInterop.DotNetStreamReference! dotNetStreamReference) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining Parameter Binding Failure Logger in ASP.NET Core (C#)\nDESCRIPTION: Defines a structured logging action for parameter binding failures. Uses LoggerMessage.Define to create a reusable logging delegate with the appropriate log level, event ID, and message template for consistent logging of binding failures.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Get_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n    LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C# for ASP.NET Core\nDESCRIPTION: Directive that enables nullable reference type annotations for this source file, ensuring null-safety checks by the compiler for reference types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PublicAPI/netstandard2.0/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing ResourceManagerStringLocalizerFactory Class in C#\nDESCRIPTION: Defines a factory class for creating ResourceManagerStringLocalizer instances.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Localization/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Localization.ResourceManagerStringLocalizerFactory.Create(string! baseName, string! location) -> Microsoft.Extensions.Localization.IStringLocalizer!\nMicrosoft.Extensions.Localization.ResourceManagerStringLocalizerFactory.Create(System.Type! resourceSource) -> Microsoft.Extensions.Localization.IStringLocalizer!\nMicrosoft.Extensions.Localization.ResourceManagerStringLocalizerFactory.ResourceManagerStringLocalizerFactory(Microsoft.Extensions.Options.IOptions<Microsoft.Extensions.Localization.LocalizationOptions!>! localizationOptions, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining ICorsService Interface in C#\nDESCRIPTION: Specifies the ICorsService interface with methods for applying CORS results and evaluating CORS policies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Cors.Infrastructure.ICorsService\nMicrosoft.AspNetCore.Cors.Infrastructure.ICorsService.ApplyResult(Microsoft.AspNetCore.Cors.Infrastructure.CorsResult! result, Microsoft.AspNetCore.Http.HttpResponse! response) -> void\nMicrosoft.AspNetCore.Cors.Infrastructure.ICorsService.EvaluatePolicy(Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Cors.Infrastructure.CorsPolicy! policy) -> Microsoft.AspNetCore.Cors.Infrastructure.CorsResult!\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Non-Form Content Type in ASP.NET Core\nDESCRIPTION: This method handles cases where an unexpected non-form content type is received. It either throws a BadHttpRequestException with a 415 status code or logs the issue.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a custom attribute 'InterceptsLocationAttribute' used for method interception. This attribute is file-scoped and can be applied to methods multiple times.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building JavaScript Assets\nDESCRIPTION: NPM command to build all JavaScript assets required by the repository, including SignalR components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/README.md#2025-04-08_snippet_5\n\nLANGUAGE: powershell\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: HTTP Response Writing Extensions in ASP.NET Core\nDESCRIPTION: Extension methods for writing string content to HTTP responses with optional encoding and cancellation token support.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.HttpResponseWritingExtensions.WriteAsync(this Microsoft.AspNetCore.Http.HttpResponse! response, string! text, System.Text.Encoding! encoding, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nstatic Microsoft.AspNetCore.Http.HttpResponseWritingExtensions.WriteAsync(this Microsoft.AspNetCore.Http.HttpResponse! response, string! text, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining HubProtocolConstants Message Types in ASP.NET Core SignalR (C#)\nDESCRIPTION: Constants defining the numeric type identifiers for different message types in the SignalR protocol. These constants are used to identify the type of message being sent or received in the protocol.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.AckMessageType = 8 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.CancelInvocationMessageType = 5 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.CloseMessageType = 7 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.CompletionMessageType = 3 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.InvocationMessageType = 1 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.PingMessageType = 6 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.SequenceMessageType = 9 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.StreamInvocationMessageType = 4 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.StreamItemMessageType = 2 -> int\n```\n\n----------------------------------------\n\nTITLE: Generated Metadata Constants for ASP.NET Core\nDESCRIPTION: This generated class contains constant arrays for common content types used in ASP.NET Core applications. These constants are used for content negotiation and request/response handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Form Content Type Handler in C#\nDESCRIPTION: Handles cases where the content type is not a supported form media type. Returns 415 Unsupported Media Type status code when throwing exceptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive that enables nullable reference type checking in C#. This helps catch potential null reference exceptions at compile time rather than runtime.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/Http.Connections.Common/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Initializing Submodules in Existing Clone\nDESCRIPTION: Command to initialize and update all submodules in an existing clone of the ASP.NET Core repository.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Submodules.md#2025-04-08_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit submodule update --init\n```\n\n----------------------------------------\n\nTITLE: Mapping Unique JSON Key Claims\nDESCRIPTION: Extension methods for mapping unique JSON keys to claims in OpenID Connect authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Authentication.ClaimActionCollectionUniqueExtensions.MapUniqueJsonKey(this Microsoft.AspNetCore.Authentication.OAuth.Claims.ClaimActionCollection! collection, string! claimType, string! jsonKey) -> void\nstatic Microsoft.AspNetCore.Authentication.ClaimActionCollectionUniqueExtensions.MapUniqueJsonKey(this Microsoft.AspNetCore.Authentication.OAuth.Claims.ClaimActionCollection! collection, string! claimType, string! jsonKey, string! valueType) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing MapMethods Route Handler in ASP.NET Core\nDESCRIPTION: Implements a route handler extension method for mapping HTTP methods with metadata population and request delegation. Handles JSON body parsing, parameter binding, and response generation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Post_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapMethods0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    IEnumerable<string> httpMethods,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n        var serviceProviderIsService = serviceProvider.GetRequiredService<IServiceProviderIsService>();\n        var jsonBodyOrServiceTypeTuples = new (bool, Type)[] {\n            #nullable disable\n            (false, typeof(global::System.String[])),\n            #nullable enable\n        };\n        foreach (var (isOptional, type) in jsonBodyOrServiceTypeTuples)\n        {\n            if (!serviceProviderIsService.IsService(type))\n            {\n                options.EndpointBuilder.Metadata.Add(new AcceptsMetadata(type: type, isOptional: isOptional, contentTypes: GeneratedMetadataConstants.JsonContentType));\n                break;\n            }\n        }\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n```\n\n----------------------------------------\n\nTITLE: Setting Application Name for HostBuilder in C#\nDESCRIPTION: This extension method sets the application name for the HostBuilder. It adds the application name to the host configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Owin/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic static IHostBuilder UseApplicationName(this IHostBuilder builder, string applicationName)\n{\n    if (builder == null)\n    {\n        throw new ArgumentNullException(nameof(builder));\n    }\n\n    if (string.IsNullOrEmpty(applicationName))\n    {\n        throw new ArgumentException(Resources.ArgumentCannotBeNullOrEmpty, nameof(applicationName));\n    }\n\n    return builder.ConfigureHostConfiguration(configBuilder =>\n    {\n        configBuilder.AddInMemoryCollection(new[]\n        {\n            new KeyValuePair<string, string>(HostDefaults.ApplicationKey, applicationName)\n        });\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: HtmlAttributeValueStyle Enum Definition\nDESCRIPTION: Specifies the style for rendering HTML attribute values, including options for double quotes, single quotes, no quotes, or minimized attributes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Razor/Razor/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.DoubleQuotes = 0\nMicrosoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.SingleQuotes = 1\nMicrosoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.NoQuotes = 2\nMicrosoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.Minimized = 3\n```\n\n----------------------------------------\n\nTITLE: Defining CORS Constants in C#\nDESCRIPTION: Declares static readonly string constants for various CORS-related headers and special values used in CORS operations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Cors.Infrastructure.CorsConstants.AccessControlAllowCredentials -> string!\nstatic readonly Microsoft.AspNetCore.Cors.Infrastructure.CorsConstants.AccessControlAllowHeaders -> string!\nstatic readonly Microsoft.AspNetCore.Cors.Infrastructure.CorsConstants.AccessControlAllowMethods -> string!\nstatic readonly Microsoft.AspNetCore.Cors.Infrastructure.CorsConstants.AccessControlAllowOrigin -> string!\nstatic readonly Microsoft.AspNetCore.Cors.Infrastructure.CorsConstants.AccessControlExposeHeaders -> string!\nstatic readonly Microsoft.AspNetCore.Cors.Infrastructure.CorsConstants.AccessControlMaxAge -> string!\nstatic readonly Microsoft.AspNetCore.Cors.Infrastructure.CorsConstants.AccessControlRequestHeaders -> string!\nstatic readonly Microsoft.AspNetCore.Cors.Infrastructure.CorsConstants.AccessControlRequestMethod -> string!\nstatic readonly Microsoft.AspNetCore.Cors.Infrastructure.CorsConstants.AnyHeader -> string!\nstatic readonly Microsoft.AspNetCore.Cors.Infrastructure.CorsConstants.AnyMethod -> string!\nstatic readonly Microsoft.AspNetCore.Cors.Infrastructure.CorsConstants.AnyOrigin -> string!\nstatic readonly Microsoft.AspNetCore.Cors.Infrastructure.CorsConstants.Origin -> string!\nstatic readonly Microsoft.AspNetCore.Cors.Infrastructure.CorsConstants.PreflightHttpMethod -> string!\n```\n\n----------------------------------------\n\nTITLE: Defining ModelBinderFactoryContext Class in ASP.NET Core\nDESCRIPTION: A C# class definition for ModelBinderFactoryContext which serves as a context object passed to the IModelBinderFactory's CreateBinder method. It contains a nullable BindingInfo property that provides metadata about how the model should be bound.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Schema for SerializableError Object in Pet Store API\nDESCRIPTION: This snippet defines the JSON schema for a SerializableError object. It allows for additional properties of any type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Tools/Microsoft.dotnet-openapi/test/TestContent/openapi.json.txt#2025-04-08_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"type\": \"object\",\n  \"additionalProperties\": false,\n  \"allOf\": [\n    {\n      \"type\": \"object\",\n      \"additionalProperties\": {}\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Authentication Default Path Constants in ASP.NET Core WebAssembly\nDESCRIPTION: Static constants defining default paths for authentication-related operations in WebAssembly applications. These constants provide standard paths for login, logout, and profile actions that can be used in route configurations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationDefaults.LoginCallbackPath -> string!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationDefaults.LoginFailedPath -> string!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationDefaults.LoginPath -> string!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationDefaults.LogoutCallbackPath -> string!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationDefaults.LogoutFailedPath -> string!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationDefaults.LogoutPath -> string!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationDefaults.LogoutSucceededPath -> string!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationDefaults.ProfilePath -> string!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationDefaults.RegisterPath -> string!\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C# for ASP.NET Core\nDESCRIPTION: This directive enables nullable reference types, a C# feature that helps prevent null reference exceptions by making nullability explicit in the type system. When enabled, reference types are non-nullable by default, and nullable reference types must be explicitly declared.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/EntityFrameworkCore/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Registering ASP.NET Core MVC Components via Extension Methods in C#\nDESCRIPTION: Defines service collection extension methods for registering different MVC components in ASP.NET Core applications. These extension methods provide various ways to configure MVC services including Controllers, Views, and Razor Pages, with options for custom configuration through action delegates.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\nMicrosoft.Extensions.DependencyInjection.MvcServiceCollectionExtensions\nstatic Microsoft.Extensions.DependencyInjection.MvcServiceCollectionExtensions.AddControllers(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\nstatic Microsoft.Extensions.DependencyInjection.MvcServiceCollectionExtensions.AddControllers(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Mvc.MvcOptions!>? configure) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\nstatic Microsoft.Extensions.DependencyInjection.MvcServiceCollectionExtensions.AddControllersWithViews(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\nstatic Microsoft.Extensions.DependencyInjection.MvcServiceCollectionExtensions.AddControllersWithViews(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Mvc.MvcOptions!>? configure) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\nstatic Microsoft.Extensions.DependencyInjection.MvcServiceCollectionExtensions.AddMvc(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\nstatic Microsoft.Extensions.DependencyInjection.MvcServiceCollectionExtensions.AddMvc(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Mvc.MvcOptions!>! setupAction) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\nstatic Microsoft.Extensions.DependencyInjection.MvcServiceCollectionExtensions.AddRazorPages(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\nstatic Microsoft.Extensions.DependencyInjection.MvcServiceCollectionExtensions.AddRazorPages(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Mvc.RazorPages.RazorPagesOptions!>? configure) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining Non-Form Content Type Logger Message in C#\nDESCRIPTION: Defines a logger message for unexpected non-form content type scenarios with debug level logging and event ID 7.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Implementing ContentDispositionHeaderValue Class in C#\nDESCRIPTION: Defines the ContentDispositionHeaderValue class for handling Content-Disposition headers, including file-related properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Headers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Net.Http.Headers.ContentDispositionHeaderValue\nMicrosoft.Net.Http.Headers.ContentDispositionHeaderValue.ContentDispositionHeaderValue(Microsoft.Extensions.Primitives.StringSegment dispositionType) -> void\nMicrosoft.Net.Http.Headers.ContentDispositionHeaderValue.CreationDate.get -> System.DateTimeOffset?\nMicrosoft.Net.Http.Headers.ContentDispositionHeaderValue.CreationDate.set -> void\n// ... (additional properties and methods)\n```\n\n----------------------------------------\n\nTITLE: Configuring Content Root for HostBuilder in C#\nDESCRIPTION: This extension method sets the content root for the HostBuilder. It handles both absolute and relative paths, resolving relative paths against the current directory.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Owin/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic static IHostBuilder UseContentRoot(this IHostBuilder builder, string contentRoot)\n{\n    if (builder == null)\n    {\n        throw new ArgumentNullException(nameof(builder));\n    }\n\n    if (string.IsNullOrEmpty(contentRoot))\n    {\n        throw new ArgumentException(Resources.ArgumentCannotBeNullOrEmpty, nameof(contentRoot));\n    }\n\n    contentRoot = Path.GetFullPath(contentRoot);\n    if (!Directory.Exists(contentRoot))\n    {\n        throw new DirectoryNotFoundException(contentRoot);\n    }\n\n    return builder.ConfigureHostConfiguration(configBuilder =>\n    {\n        configBuilder.AddInMemoryCollection(new[]\n        {\n            new KeyValuePair<string, string>(HostDefaults.ContentRootKey, contentRoot)\n        });\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Components to be Deleted\nDESCRIPTION: Specifies the component that will be deleted during the consolidation process.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/tooling-consolidation.md#2025-04-08_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nRazorPageGenerator\n```\n\n----------------------------------------\n\nTITLE: AuthorizationServiceExtensions Class in C#\nDESCRIPTION: Declaration of the AuthorizationServiceExtensions class that provides extension methods for the IAuthorizationService interface.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationServiceExtensions\n```\n\n----------------------------------------\n\nTITLE: HtmlRenderer Methods for Component Rendering in ASP.NET Core\nDESCRIPTION: Defines HtmlRenderer class methods for rendering components to HTML. These methods allow rendering components by type or generic parameter with optional parameter values, returning HTML root components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Web.HtmlRenderer.RenderComponentAsync(System.Type! componentType, Microsoft.AspNetCore.Components.ParameterView parameters) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Components.Web.HtmlRendering.HtmlRootComponent>!\nMicrosoft.AspNetCore.Components.Web.HtmlRenderer.RenderComponentAsync<TComponent>() -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Components.Web.HtmlRendering.HtmlRootComponent>!\nMicrosoft.AspNetCore.Components.Web.HtmlRenderer.RenderComponentAsync<TComponent>(Microsoft.AspNetCore.Components.ParameterView parameters) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Components.Web.HtmlRendering.HtmlRootComponent>!\n```\n\n----------------------------------------\n\nTITLE: Generic Delegate Casting in ASP.NET Core\nDESCRIPTION: Utility method for casting delegates to specific delegate types. This method is used during route handler registration to ensure type compatibility.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Post_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Helper Implementation\nDESCRIPTION: Core HTML helper classes for generating HTML content and handling forms in ASP.NET Core MVC views. Includes configuration options and form context management.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic class HtmlHelperOptions\n{\n    public bool ClientValidationEnabled { get; set; }\n    public FormInputRenderMode FormInputRenderMode { get; set; }\n    public Html5DateRenderingMode Html5DateRenderingMode { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Authentication Scheme in C# for ASP.NET Core\nDESCRIPTION: This code snippet defines the AuthenticationScheme class, which represents a configured authentication scheme. It includes properties for the scheme's name, display name, and handler type, as well as a method to create an instance of the handler.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class AuthenticationScheme\n{\n    public AuthenticationScheme(string name, string? displayName, Type handlerType)\n    {\n        if (name == null)\n        {\n            throw new ArgumentNullException(nameof(name));\n        }\n        if (handlerType == null)\n        {\n            throw new ArgumentNullException(nameof(handlerType));\n        }\n        if (!typeof(IAuthenticationHandler).IsAssignableFrom(handlerType))\n        {\n            throw new ArgumentException(\"handlerType must implement IAuthenticationHandler.\", nameof(handlerType));\n        }\n\n        Name = name;\n        DisplayName = displayName;\n        HandlerType = handlerType;\n    }\n\n    public string Name { get; }\n\n    public string? DisplayName { get; }\n\n    public Type HandlerType { get; }\n\n    public IAuthenticationHandler CreateHandler(IServiceProvider services)\n    {\n        return (IAuthenticationHandler)services.GetRequiredService(HandlerType);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Response Methods in PageModel Class\nDESCRIPTION: Virtual methods in the PageModel class for generating HTTP responses, including BadRequest, Challenge, Content, File, and Forbid response types with various overloads.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.BadRequest() -> Microsoft.AspNetCore.Mvc.BadRequestResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.BadRequest(Microsoft.AspNetCore.Mvc.ModelBinding.ModelStateDictionary! modelState) -> Microsoft.AspNetCore.Mvc.BadRequestObjectResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.BadRequest(object! error) -> Microsoft.AspNetCore.Mvc.BadRequestObjectResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.Challenge() -> Microsoft.AspNetCore.Mvc.ChallengeResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.Challenge(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties) -> Microsoft.AspNetCore.Mvc.ChallengeResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.Challenge(Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties, params string![]! authenticationSchemes) -> Microsoft.AspNetCore.Mvc.ChallengeResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.Challenge(params string![]! authenticationSchemes) -> Microsoft.AspNetCore.Mvc.ChallengeResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.Content(string! content) -> Microsoft.AspNetCore.Mvc.ContentResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.Content(string! content, Microsoft.Net.Http.Headers.MediaTypeHeaderValue? contentType) -> Microsoft.AspNetCore.Mvc.ContentResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.Content(string! content, string! contentType) -> Microsoft.AspNetCore.Mvc.ContentResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.Content(string! content, string! contentType, System.Text.Encoding! contentEncoding) -> Microsoft.AspNetCore.Mvc.ContentResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.File(byte[]! fileContents, string! contentType) -> Microsoft.AspNetCore.Mvc.FileContentResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.File(byte[]! fileContents, string! contentType, string? fileDownloadName) -> Microsoft.AspNetCore.Mvc.FileContentResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.File(string! virtualPath, string! contentType) -> Microsoft.AspNetCore.Mvc.VirtualFileResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.File(string! virtualPath, string! contentType, string? fileDownloadName) -> Microsoft.AspNetCore.Mvc.VirtualFileResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.File(System.IO.Stream! fileStream, string! contentType) -> Microsoft.AspNetCore.Mvc.FileStreamResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.File(System.IO.Stream! fileStream, string! contentType, string? fileDownloadName) -> Microsoft.AspNetCore.Mvc.FileStreamResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.Forbid() -> Microsoft.AspNetCore.Mvc.ForbidResult!\n```\n\n----------------------------------------\n\nTITLE: Installing project dependencies with dotnet\nDESCRIPTION: Command to restore and build the project, which installs necessary dependencies for the ASP.NET Core templates.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/StaticFiles/test/UnitTests/SubFolder/Empty.txt#2025-04-08_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndotnet build\n```\n\n----------------------------------------\n\nTITLE: Writing JSON Responses in ASP.NET Core HTTP Handlers\nDESCRIPTION: Handles writing JSON responses with support for polymorphism. This method analyzes the runtime type of the value to determine the appropriate serialization approach, using either type-specific JsonTypeInfo or falling back to generic serialization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_StringArrayParam.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Running IIS Tests with PowerShell\nDESCRIPTION: Command to execute the test suite for the IIS project using PowerShell build script with test flag.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/IIS/README.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd -t\n```\n\n----------------------------------------\n\nTITLE: Adding Request Timeouts to Service Collection in ASP.NET Core\nDESCRIPTION: These extension methods add request timeout services to the dependency injection container, with an optional configuration action.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.RequestTimeoutsIServiceCollectionExtensions.AddRequestTimeouts(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.RequestTimeoutsIServiceCollectionExtensions.AddRequestTimeouts(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Http.Timeouts.RequestTimeoutOptions!>! configure) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Defining AllowAnonymousAttribute in C#\nDESCRIPTION: This attribute is used to allow anonymous access to controllers or action methods in ASP.NET Core, bypassing authorization checks.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AllowAnonymousAttribute\nMicrosoft.AspNetCore.Authorization.AllowAnonymousAttribute.AllowAnonymousAttribute() -> void\n```\n\n----------------------------------------\n\nTITLE: Generating Request Delegate Metadata in ASP.NET Core\nDESCRIPTION: This snippet creates metadata for a request delegate, including parameter binding and response type information. It sets up the endpoint builder with the necessary metadata for processing requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\noptions.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"Service\", new PropertyAsParameterInfo(false, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParameterRecordStructWithJsonBodyOrService)!.GetProperty(\"Service\")!), hasTryParse: false, hasBindAsync: false, isOptional: false));\noptions.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\nreturn new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n```\n\n----------------------------------------\n\nTITLE: Building Filter Delegate for ASP.NET Core Endpoints (C#)\nDESCRIPTION: This method builds a filter delegate by applying route handler filters in reverse order.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Link HTML Helpers in ASP.NET Core MVC\nDESCRIPTION: Extension methods for generating HTML anchor elements with route-based and action-based links. These methods support routing parameters and HTML attributes customization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperLinkExtensions.ActionLink(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper helper, string linkText, string actionName) -> Microsoft.AspNetCore.Html.IHtmlContent\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperLinkExtensions.RouteLink(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper htmlHelper, string linkText, string routeName) -> Microsoft.AspNetCore.Html.IHtmlContent\n```\n\n----------------------------------------\n\nTITLE: Implementing ApplyHotReloadDeltas Method in C#\nDESCRIPTION: Defines a static method ApplyHotReloadDeltas within the WebAssemblyHotReload class. This method takes an array of Delta objects and a logging level, and returns an array of LogEntry objects. It is responsible for applying the hot reload changes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.WebAssembly.HotReload.WebAssemblyHotReload.ApplyHotReloadDeltas(Microsoft.AspNetCore.Components.WebAssembly.HotReload.WebAssemblyHotReload.Delta[]! deltas, int loggingLevel) -> Microsoft.AspNetCore.Components.WebAssembly.HotReload.WebAssemblyHotReload.LogEntry[]!\n```\n\n----------------------------------------\n\nTITLE: Opening Unidirectional WebTransport Stream in C#\nDESCRIPTION: This snippet demonstrates how to open a new unidirectional stream from the server to the client. It returns a ConnectionContext instance representing the new stream.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/WebTransport.md#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nvar connectionContext = await session.OpenUnidirectionalStreamAsync(CancellationToken token);\n```\n\n----------------------------------------\n\nTITLE: Defining ConnectionContext Abstract Class in C#\nDESCRIPTION: Extends BaseConnectionContext to include a Transport property of type IDuplexPipe for handling bidirectional communication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Connections.ConnectionContext.Transport.get -> System.IO.Pipelines.IDuplexPipe!\nabstract Microsoft.AspNetCore.Connections.ConnectionContext.Transport.set -> void\n```\n\n----------------------------------------\n\nTITLE: ConnectionBuilderExtensions Static Methods in C#\nDESCRIPTION: This snippet contains static extension methods for the IConnectionBuilder interface, including Run, Use, and UseConnectionHandler methods. These methods are used to configure the connection pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.Run(this Microsoft.AspNetCore.Connections.IConnectionBuilder! connectionBuilder, System.Func<Microsoft.AspNetCore.Connections.ConnectionContext!, System.Threading.Tasks.Task!>! middleware) -> Microsoft.AspNetCore.Connections.IConnectionBuilder!\nstatic Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.Use(this Microsoft.AspNetCore.Connections.IConnectionBuilder! connectionBuilder, System.Func<Microsoft.AspNetCore.Connections.ConnectionContext!, Microsoft.AspNetCore.Connections.ConnectionDelegate!, System.Threading.Tasks.Task!>! middleware) -> Microsoft.AspNetCore.Connections.IConnectionBuilder!\nstatic Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.Use(this Microsoft.AspNetCore.Connections.IConnectionBuilder! connectionBuilder, System.Func<Microsoft.AspNetCore.Connections.ConnectionContext!, System.Func<System.Threading.Tasks.Task!>!, System.Threading.Tasks.Task!>! middleware) -> Microsoft.AspNetCore.Connections.IConnectionBuilder!\nstatic Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.UseConnectionHandler<TConnectionHandler>(this Microsoft.AspNetCore.Connections.IConnectionBuilder! connectionBuilder) -> Microsoft.AspNetCore.Connections.IConnectionBuilder!\n```\n\n----------------------------------------\n\nTITLE: Named Pipe Server Stream Context Class\nDESCRIPTION: Context class for creating Named Pipe server streams, containing endpoint information, pipe options, and security settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Transport.NamedPipes/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Server.Kestrel.Transport.NamedPipes.CreateNamedPipeServerStreamContext\n{\n    public CreateNamedPipeServerStreamContext() -> void\n    public Microsoft.AspNetCore.Connections.NamedPipeEndPoint! NamedPipeEndPoint { get; init; }\n    public System.IO.Pipes.PipeOptions PipeOptions { get; init; }\n    public System.IO.Pipes.PipeSecurity? PipeSecurity { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Static Assets for Razor Components in C#\nDESCRIPTION: Extends RazorComponentsEndpointConventionBuilder to configure static assets for Razor Components. It allows specifying an optional manifest path.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Endpoints/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.RazorComponentsEndpointConventionBuilderExtensions.WithStaticAssets(this Microsoft.AspNetCore.Builder.RazorComponentsEndpointConventionBuilder! builder, string? manifestPath = null) -> Microsoft.AspNetCore.Builder.RazorComponentsEndpointConventionBuilder!\n```\n\n----------------------------------------\n\nTITLE: Displaying Alphanumeric Character Set\nDESCRIPTION: A string containing all numbers (0-9) followed by lowercase letters (a-z) and uppercase letters (A-Z) in sequence.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/StaticFiles/test/FunctionalTests/SubFolder/ranges.txt#2025-04-08_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n```\n\n----------------------------------------\n\nTITLE: Implementing ManagedAuthenticatedEncryptorFactory in C#\nDESCRIPTION: This class implements the IAuthenticatedEncryptorFactory interface, providing a method to create encryptor instances based on a given key.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.ManagedAuthenticatedEncryptorFactory\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.ManagedAuthenticatedEncryptorFactory.CreateEncryptorInstance(Microsoft.AspNetCore.DataProtection.KeyManagement.IKey! key) -> Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor?\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.ManagedAuthenticatedEncryptorFactory.ManagedAuthenticatedEncryptorFactory(Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> void\n```\n\n----------------------------------------\n\nTITLE: Domain and Port Based URL Rewrite Rules for Apache\nDESCRIPTION: Apache rewrite rules that redirect all requests to www.example.com if either the host is not www.example.com or the port is not 5000. Uses HTTP 302 temporary redirect.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Rewrite/sample/Rewrite.txt#2025-04-08_snippet_0\n\nLANGUAGE: apache\nCODE:\n```\nRewriteCond %{HTTP_HOST}   !^www\\.example\\.com [NC,OR]\nRewriteCond %{SERVER_PORT} !^5000$\nRewriteRule ^/(.*)         http://www.example.com/$1 [L,R=302]\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Implementation in ASP.NET Core\nDESCRIPTION: Implements parameter binding metadata container for storing parameter information including name, type info, and binding capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleComplexTypeParam_StringReturn.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n    public bool HasTryParse { get; }\n    public bool HasBindAsync { get; }\n    public ParameterInfo ParameterInfo { get; }\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SignalR Streaming Message Classes\nDESCRIPTION: Message classes for streaming operations in SignalR. Includes message types for initiating streams and sending stream items, with properties for invocation IDs, targets, arguments, and stream content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.Protocol.StreamInvocationMessage\nMicrosoft.AspNetCore.SignalR.Protocol.StreamInvocationMessage.StreamInvocationMessage(string! invocationId, string! target, object?[]! arguments) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.StreamInvocationMessage.StreamInvocationMessage(string! invocationId, string! target, object?[]! arguments, string![]? streamIds) -> void\n\nMicrosoft.AspNetCore.SignalR.Protocol.StreamItemMessage\nMicrosoft.AspNetCore.SignalR.Protocol.StreamItemMessage.Item.get -> object?\nMicrosoft.AspNetCore.SignalR.Protocol.StreamItemMessage.Item.set -> void\nMicrosoft.AspNetCore.SignalR.Protocol.StreamItemMessage.StreamItemMessage(string! invocationId, object? item) -> void\n```\n\n----------------------------------------\n\nTITLE: Documentation Table Structure in Markdown\nDESCRIPTION: Markdown table structure listing various documentation files in the ASP.NET Core repository along with their purposes and target audiences.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/README.md#2025-04-08_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Documentation        | What is it about?   | Who is it for?      |\n|--------------------------------------------------------------------------|-------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------|\n| [API review process](APIReviewProcess.md)      | Outlines the process for reviewing API changes in ASP.NET Core          | Anyone looking to understand the process for making API changes to ASP.NET Core      |\n| [Artifacts structure](Artifacts.md)            | Outlines the artifacts produced by the build  | Anyone looking to understand artifacts produced from an Azure DevOps build          |\n```\n\n----------------------------------------\n\nTITLE: Executing Return Values in ASP.NET Core (C#)\nDESCRIPTION: This method handles the execution of return values, supporting IResult, string, and JSON serialization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining WebAssemblyHotReload LogEntry Class in C#\nDESCRIPTION: Defines the LogEntry class within the WebAssemblyHotReload namespace, including properties for log message and severity. This class is used for logging during the hot reload process.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.WebAssembly.HotReload.WebAssemblyHotReload.LogEntry\nMicrosoft.AspNetCore.Components.WebAssembly.HotReload.WebAssemblyHotReload.LogEntry.LogEntry() -> void\nMicrosoft.AspNetCore.Components.WebAssembly.HotReload.WebAssemblyHotReload.LogEntry.Message.get -> string!\nMicrosoft.AspNetCore.Components.WebAssembly.HotReload.WebAssemblyHotReload.LogEntry.Message.init -> void\nMicrosoft.AspNetCore.Components.WebAssembly.HotReload.WebAssemblyHotReload.LogEntry.Severity.get -> int\nMicrosoft.AspNetCore.Components.WebAssembly.HotReload.WebAssemblyHotReload.LogEntry.Severity.init -> void\n```\n\n----------------------------------------\n\nTITLE: Building Individual Projects in dotnet/runtime with PowerShell\nDESCRIPTION: Commands to build specific projects within the dotnet/runtime repository.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Shared/runtime/ReadMe.SharedCode.md#2025-04-08_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS D:\\github\\dotnet\\src\\libraries\\Common\\tests> dotnet build\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS D:\\github\\dotnet\\src\\libraries\\System.Net.Http\\src> dotnet build\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP.sys Exception Overrides in C#\nDESCRIPTION: Override for the ErrorCode property in HttpSysException class that provides HTTP.sys-specific error codes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/HttpSys/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Server.HttpSys.HttpSysException.ErrorCode.get -> int\n```\n\n----------------------------------------\n\nTITLE: Extending Authentication Builder for Twitter in C#\nDESCRIPTION: Defines extension methods for the AuthenticationBuilder class to add Twitter authentication to the application, including various overloads for configuration options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Twitter/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.TwitterExtensions.AddTwitter(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder builder) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder\nstatic Microsoft.Extensions.DependencyInjection.TwitterExtensions.AddTwitter(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder builder, string authenticationScheme, string displayName, System.Action<Microsoft.AspNetCore.Authentication.Twitter.TwitterOptions> configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder\nstatic Microsoft.Extensions.DependencyInjection.TwitterExtensions.AddTwitter(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder builder, string authenticationScheme, System.Action<Microsoft.AspNetCore.Authentication.Twitter.TwitterOptions> configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder\nstatic Microsoft.Extensions.DependencyInjection.TwitterExtensions.AddTwitter(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder builder, System.Action<Microsoft.AspNetCore.Authentication.Twitter.TwitterOptions> configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder\n```\n\n----------------------------------------\n\nTITLE: AuthenticationStateProvider Abstract Method\nDESCRIPTION: Defines the abstract method for getting authentication state asynchronously in the AuthenticationStateProvider class.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Authorization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Components.Authorization.AuthenticationStateProvider.GetAuthenticationStateAsync() -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Components.Authorization.AuthenticationState!>!\n```\n\n----------------------------------------\n\nTITLE: Razor Pages RedirectToPage Methods in PageBase Class\nDESCRIPTION: Collection of virtual methods in the PageBase class for redirecting to a specified page. Methods include various overloads supporting permanent redirects, HTTP method preservation, and different parameter combinations for page routing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.RedirectToPagePermanent(string? pageName, object? routeValues) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.RedirectToPagePermanent(string? pageName, string? pageHandler) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.RedirectToPagePermanent(string? pageName, string? pageHandler, object? routeValues) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.RedirectToPagePermanent(string? pageName, string? pageHandler, object? routeValues, string? fragment) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.RedirectToPagePermanent(string? pageName, string? pageHandler, string? fragment) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.RedirectToPagePermanentPreserveMethod(string? pageName = null, string? pageHandler = null, object? routeValues = null, string? fragment = null) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.RedirectToPagePreserveMethod(string? pageName = null, string? pageHandler = null, object? routeValues = null, string? fragment = null) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\n```\n\n----------------------------------------\n\nTITLE: OpenAPI 3.0.4 Schema Definition for User API\nDESCRIPTION: Defines the API specification for user management endpoints including GET /v2/users for retrieving user lists and POST /v2/users for creating users. Includes metadata like version, contact information, and external documentation links.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/test/Microsoft.AspNetCore.OpenApi.Tests/Integration/snapshots/OpenApi3_0/OpenApiDocumentIntegrationTests.VerifyOpenApiDocument_documentName=v2.verified.txt#2025-04-08_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"openapi\": \"3.0.4\",\n  \"info\": {\n    \"title\": \"Sample | v2\",\n    \"contact\": {\n      \"name\": \"OpenAPI Enthusiast\",\n      \"email\": \"iloveopenapi@example.com\"\n    },\n    \"license\": {\n      \"name\": \"MIT\"\n    },\n    \"version\": \"1.0.0\"\n  },\n  \"paths\": {\n    \"/v2/users\": {\n      \"get\": {\n        \"tags\": [\n          \"users\"\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"array\",\n                  \"items\": {\n                    \"type\": \"string\",\n                    \"externalDocs\": {\n                      \"description\": \"Documentation for this OpenAPI schema\",\n                      \"url\": \"https://example.com/api/docs/schemas/string\"\n                    }\n                  },\n                  \"externalDocs\": {\n                    \"description\": \"Documentation for this OpenAPI schema\",\n                    \"url\": \"https://example.com/api/docs/schemas/array\"\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"externalDocs\": {\n          \"description\": \"Documentation for this OpenAPI endpoint\",\n          \"url\": \"https://example.com/api/docs/operations/CreateUser\"\n        },\n        \"operationId\": \"CreateUser\",\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    }\n  },\n  \"tags\": [\n    {\n      \"name\": \"users\"\n    },\n    {\n      \"name\": \"Sample\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Building Filter Delegate Chain in ASP.NET Core\nDESCRIPTION: Constructs a chain of endpoint filters for request processing. It applies filter factories in reverse order to build the complete filter pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/RequestDelegateValidateGeneratedFormCode.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AcceptLanguageHeaderRequestCultureProvider Class in C#\nDESCRIPTION: Defines the AcceptLanguageHeaderRequestCultureProvider class with properties and methods for handling Accept-Language header-based culture selection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Localization.AcceptLanguageHeaderRequestCultureProvider.AcceptLanguageHeaderRequestCultureProvider() -> void\nMicrosoft.AspNetCore.Localization.AcceptLanguageHeaderRequestCultureProvider.MaximumAcceptLanguageHeaderValuesToTry.get -> int\nMicrosoft.AspNetCore.Localization.AcceptLanguageHeaderRequestCultureProvider.MaximumAcceptLanguageHeaderValuesToTry.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in System.Runtime.CompilerServices Namespace\nDESCRIPTION: Defines a sealed class attribute that intercepts method locations with versioning support. This attribute is used to mark methods for interception during code generation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitServiceParam_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Type Info Utility Methods in C#\nDESCRIPTION: This snippet contains utility methods for working with JsonTypeInfo, including checking for known polymorphism and determining if a type should be used with a given JsonTypeInfo.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n\nprivate static bool TryParseExplicit<T>(string? s, IFormatProvider? provider, [MaybeNullWhen(returnValue: false)] out T result) where T: IParsable<T>\n    => T.TryParse(s, provider, out result);\n```\n\n----------------------------------------\n\nTITLE: PathString Utilities and Operators in ASP.NET Core\nDESCRIPTION: Methods and operators for working with URL path strings in ASP.NET Core, including conversion, concatenation, and comparison operations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.PathString.FromUriComponent(string! uriComponent) -> Microsoft.AspNetCore.Http.PathString\nstatic Microsoft.AspNetCore.Http.PathString.FromUriComponent(System.Uri! uri) -> Microsoft.AspNetCore.Http.PathString\nstatic Microsoft.AspNetCore.Http.PathString.implicit operator Microsoft.AspNetCore.Http.PathString(string? s) -> Microsoft.AspNetCore.Http.PathString\nstatic Microsoft.AspNetCore.Http.PathString.implicit operator string!(Microsoft.AspNetCore.Http.PathString path) -> string!\nstatic Microsoft.AspNetCore.Http.PathString.operator !=(Microsoft.AspNetCore.Http.PathString left, Microsoft.AspNetCore.Http.PathString right) -> bool\nstatic Microsoft.AspNetCore.Http.PathString.operator +(Microsoft.AspNetCore.Http.PathString left, Microsoft.AspNetCore.Http.PathString right) -> Microsoft.AspNetCore.Http.PathString\nstatic Microsoft.AspNetCore.Http.PathString.operator +(Microsoft.AspNetCore.Http.PathString left, Microsoft.AspNetCore.Http.QueryString right) -> string!\nstatic Microsoft.AspNetCore.Http.PathString.operator +(Microsoft.AspNetCore.Http.PathString left, string? right) -> string!\nstatic Microsoft.AspNetCore.Http.PathString.operator +(string! left, Microsoft.AspNetCore.Http.PathString right) -> string!\nstatic Microsoft.AspNetCore.Http.PathString.operator ==(Microsoft.AspNetCore.Http.PathString left, Microsoft.AspNetCore.Http.PathString right) -> bool\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Form Content Type\nDESCRIPTION: Validates form content type in requests and handles unexpected types. Throws BadHttpRequestException for unsupported media types and logs debug messages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleEnumParam_StringReturn.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Non-Form Content Type in ASP.NET Core\nDESCRIPTION: Implements validation for form media types, throwing a BadHttpRequestException with status code 415 (Unsupported Media Type) or logging the error depending on configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n        {\n            if (_shouldThrow)\n            {\n                var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n                throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n            }\n\n            if (_rdgLogger != null)\n            {\n                _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n            }\n        }\n```\n\n----------------------------------------\n\nTITLE: Updating API Entry in PublicAPI.Unshipped.txt\nDESCRIPTION: Example of updating an API entry in the PublicAPI.Unshipped.txt file. This demonstrates how to remove the old API and add the updated API, including changes for nullable awareness.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/APIBaselines.md#2025-04-08_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n#nullable enable\n*REMOVED*Microsoft.AspNetCore.DataProtection.Infrastructure.IApplicationDiscriminator.Discriminator.get -> string!\nMicrosoft.AspNetCore.DataProtection.Infrastructure.IApplicationDiscriminator.Discriminator.get -> string?\n```\n\n----------------------------------------\n\nTITLE: Aborting WebTransport Stream in C#\nDESCRIPTION: This snippet demonstrates how to abort a WebTransport stream, which abruptly ends all data transmission over the stream. An optional aborted exception can be specified for logging.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/WebTransport.md#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nstream.Abort(ConnectionAbortedException exception);\n```\n\n----------------------------------------\n\nTITLE: Defining OpenAPI 3.0.4 Specification for Sample Forms API in JSON\nDESCRIPTION: This code snippet defines the complete OpenAPI 3.0.4 specification for a Sample Forms API. It includes path definitions for various form submission endpoints, component schemas, and tag information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/test/Microsoft.AspNetCore.OpenApi.Tests/Integration/snapshots/OpenApi3_0/OpenApiDocumentIntegrationTests.VerifyOpenApiDocument_documentName=forms.verified.txt#2025-04-08_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"openapi\": \"3.0.4\",\n  \"info\": {\n    \"title\": \"Sample | forms\",\n    \"version\": \"1.0.0\"\n  },\n  \"paths\": {\n    \"/forms/form-file\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"multipart/form-data\": {\n              \"schema\": {\n                \"required\": [\n                  \"resume\"\n                ],\n                \"type\": \"object\",\n                \"properties\": {\n                  \"resume\": {\n                    \"$ref\": \"#/components/schemas/IFormFile\"\n                  }\n                }\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/forms/form-files\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"multipart/form-data\": {\n              \"schema\": {\n                \"required\": [\n                  \"files\"\n                ],\n                \"type\": \"object\",\n                \"properties\": {\n                  \"files\": {\n                    \"$ref\": \"#/components/schemas/IFormFileCollection\"\n                  }\n                }\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/forms/form-file-multiple\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"multipart/form-data\": {\n              \"schema\": {\n                \"required\": [\n                  \"resume\",\n                  \"files\"\n                ],\n                \"type\": \"object\",\n                \"allOf\": [\n                  {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"resume\": {\n                        \"$ref\": \"#/components/schemas/IFormFile\"\n                      }\n                    }\n                  },\n                  {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"files\": {\n                        \"$ref\": \"#/components/schemas/IFormFileCollection\"\n                      }\n                    }\n                  }\n                ]\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/forms/form-todo\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"multipart/form-data\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/Todo\"\n              }\n            },\n            \"application/x-www-form-urlencoded\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/Todo\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/forms/forms-pocos-and-files\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"multipart/form-data\": {\n              \"schema\": {\n                \"required\": [\n                  \"file\"\n                ],\n                \"type\": \"object\",\n                \"allOf\": [\n                  {\n                    \"$ref\": \"#/components/schemas/Todo\"\n                  },\n                  {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"file\": {\n                        \"$ref\": \"#/components/schemas/IFormFile\"\n                      }\n                    }\n                  }\n                ]\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"IFormFile\": {\n        \"type\": \"string\",\n        \"format\": \"binary\"\n      },\n      \"IFormFileCollection\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"$ref\": \"#/components/schemas/IFormFile\"\n        }\n      },\n      \"Todo\": {\n        \"required\": [\n          \"id\",\n          \"title\",\n          \"completed\",\n          \"createdAt\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"integer\",\n            \"description\": \"The unique identifier of the to-do item.\",\n            \"format\": \"int32\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"The title of the to-do item.\"\n          },\n          \"completed\": {\n            \"type\": \"boolean\",\n            \"description\": \"Indicates whether the to-do item is completed.\"\n          },\n          \"createdAt\": {\n            \"type\": \"string\",\n            \"description\": \"The date and time when the to-do item was created.\",\n            \"format\": \"date-time\"\n          }\n        },\n        \"description\": \"Represents a to-do item.\"\n      }\n    }\n  },\n  \"tags\": [\n    {\n      \"name\": \"Sample\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP.sys Request Info Interface in C#\nDESCRIPTION: Interface for accessing HTTP.sys request information stored as a dictionary of binary data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/HttpSys/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Server.HttpSys.IHttpSysRequestInfoFeature\nMicrosoft.AspNetCore.Server.HttpSys.IHttpSysRequestInfoFeature.RequestInfo.get -> System.Collections.Generic.IReadOnlyDictionary<int, System.ReadOnlyMemory<byte>>!\n```\n\n----------------------------------------\n\nTITLE: Defining HttpTransportType Enum in C#\nDESCRIPTION: An enum defining the transport types available for HTTP connections in ASP.NET Core. Includes None, WebSockets, ServerSentEvents, and LongPolling options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/Http.Connections.Common/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Connections.HttpTransportType\nMicrosoft.AspNetCore.Http.Connections.HttpTransportType.None = 0 -> Microsoft.AspNetCore.Http.Connections.HttpTransportType\nMicrosoft.AspNetCore.Http.Connections.HttpTransportType.WebSockets = 1 -> Microsoft.AspNetCore.Http.Connections.HttpTransportType\nMicrosoft.AspNetCore.Http.Connections.HttpTransportType.ServerSentEvents = 2 -> Microsoft.AspNetCore.Http.Connections.HttpTransportType\nMicrosoft.AspNetCore.Http.Connections.HttpTransportType.LongPolling = 4 -> Microsoft.AspNetCore.Http.Connections.HttpTransportType\n```\n\n----------------------------------------\n\nTITLE: Endpoint Data Source Implementations\nDESCRIPTION: Override implementations for endpoint data sources including methods for retrieving endpoints and change tokens.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Routing.CompositeEndpointDataSource.Endpoints.get -> System.Collections.Generic.IReadOnlyList<Microsoft.AspNetCore.Http.Endpoint!>!\noverride Microsoft.AspNetCore.Routing.CompositeEndpointDataSource.GetChangeToken() -> Microsoft.Extensions.Primitives.IChangeToken!\n```\n\n----------------------------------------\n\nTITLE: Upgrading to WebSocket Connection in C# for ASP.NET Core\nDESCRIPTION: This asynchronous method attempts to upgrade the current HTTP connection to a WebSocket connection. It uses the WebSocketManager to accept the WebSocket request with optional sub-protocols.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Transport.NamedPipes/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic static Task<WebSocket> AcceptWebSocketAsync(this HttpContext context, string? subProtocol = null)\n{\n    if (context == null)\n    {\n        throw new ArgumentNullException(nameof(context));\n    }\n\n    return context.WebSockets.AcceptWebSocketAsync(subProtocol);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WebAssemblyHost Class in C#\nDESCRIPTION: Defines the WebAssemblyHost class with methods for configuration, running, and disposing of the host.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHost\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHost.Configuration.get -> Microsoft.Extensions.Configuration.IConfiguration!\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHost.DisposeAsync() -> System.Threading.Tasks.ValueTask\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.WebAssemblyHost.RunAsync() -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Response Caching Options Configuration in C#\nDESCRIPTION: Configuration options for response caching middleware, including size limits and path sensitivity settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ResponseCaching/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.ResponseCaching.ResponseCachingOptions.MaximumBodySize.get -> long\nMicrosoft.AspNetCore.ResponseCaching.ResponseCachingOptions.MaximumBodySize.set -> void\nMicrosoft.AspNetCore.ResponseCaching.ResponseCachingOptions.ResponseCachingOptions() -> void\nMicrosoft.AspNetCore.ResponseCaching.ResponseCachingOptions.SizeLimit.get -> long\nMicrosoft.AspNetCore.ResponseCaching.ResponseCachingOptions.SizeLimit.set -> void\nMicrosoft.AspNetCore.ResponseCaching.ResponseCachingOptions.UseCaseSensitivePaths.get -> bool\nMicrosoft.AspNetCore.ResponseCaching.ResponseCachingOptions.UseCaseSensitivePaths.set -> void\n```\n\n----------------------------------------\n\nTITLE: JSON Response Writing with Source Generation Support in ASP.NET Core\nDESCRIPTION: Writes JSON responses with optimized serialization using source-generated JSON serialization. Includes trimming annotations to ensure compatibility with AOT compilation scenarios.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive to enable nullable reference type checking in C# code, which helps catch potential null reference exceptions at compile time.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Core/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing WebHost Builder Extensions for HTTP.sys in C#\nDESCRIPTION: Extension methods for IWebHostBuilder that enable configuring HTTP.sys as the server for ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/HttpSys/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Hosting.WebHostBuilderHttpSysExtensions.UseHttpSys(this Microsoft.AspNetCore.Hosting.IWebHostBuilder! hostBuilder) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\nstatic Microsoft.AspNetCore.Hosting.WebHostBuilderHttpSysExtensions.UseHttpSys(this Microsoft.AspNetCore.Hosting.IWebHostBuilder! hostBuilder, System.Action<Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions!>! options) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft.AspNetCore.Identity.EntityFrameworkCore via .NET CLI\nDESCRIPTION: Command to install the Microsoft.AspNetCore.Identity.EntityFrameworkCore package using the .NET CLI. This is the first step to integrate Identity with Entity Framework Core in your ASP.NET Core application.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/EntityFrameworkCore/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore\n```\n\n----------------------------------------\n\nTITLE: Logging Unexpected Non-Form Content Type in ASP.NET Core\nDESCRIPTION: Defines a logger message for unexpected form content types using LoggerMessage.Define. This captures the content type and outputs a debug-level message with event ID 7.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n            LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Methods for Authorization Configuration in C#\nDESCRIPTION: Declares static extension methods for configuring authorization in ASP.NET Core applications, including middleware and endpoint conventions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Policy/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Authorization.Policy.PolicyAuthorizationResult.Challenge() -> Microsoft.AspNetCore.Authorization.Policy.PolicyAuthorizationResult!\nstatic Microsoft.AspNetCore.Authorization.Policy.PolicyAuthorizationResult.Forbid() -> Microsoft.AspNetCore.Authorization.Policy.PolicyAuthorizationResult!\nstatic Microsoft.AspNetCore.Authorization.Policy.PolicyAuthorizationResult.Forbid(Microsoft.AspNetCore.Authorization.AuthorizationFailure? authorizationFailure) -> Microsoft.AspNetCore.Authorization.Policy.PolicyAuthorizationResult!\nstatic Microsoft.AspNetCore.Authorization.Policy.PolicyAuthorizationResult.Success() -> Microsoft.AspNetCore.Authorization.Policy.PolicyAuthorizationResult!\nstatic Microsoft.AspNetCore.Builder.AuthorizationAppBuilderExtensions.UseAuthorization(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.AuthorizationEndpointConventionBuilderExtensions.AllowAnonymous<TBuilder>(this TBuilder builder) -> TBuilder\nstatic Microsoft.AspNetCore.Builder.AuthorizationEndpointConventionBuilderExtensions.RequireAuthorization<TBuilder>(this TBuilder builder) -> TBuilder\nstatic Microsoft.AspNetCore.Builder.AuthorizationEndpointConventionBuilderExtensions.RequireAuthorization<TBuilder>(this TBuilder builder, Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy) -> TBuilder\nstatic Microsoft.AspNetCore.Builder.AuthorizationEndpointConventionBuilderExtensions.RequireAuthorization<TBuilder>(this TBuilder builder, params Microsoft.AspNetCore.Authorization.IAuthorizeData![]! authorizeData) -> TBuilder\nstatic Microsoft.AspNetCore.Builder.AuthorizationEndpointConventionBuilderExtensions.RequireAuthorization<TBuilder>(this TBuilder builder, params string![]! policyNames) -> TBuilder\nstatic Microsoft.AspNetCore.Builder.AuthorizationEndpointConventionBuilderExtensions.RequireAuthorization<TBuilder>(this TBuilder builder, System.Action<Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!>! configurePolicy) -> TBuilder\nstatic Microsoft.Extensions.DependencyInjection.PolicyServiceCollectionExtensions.AddAuthorization(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.PolicyServiceCollectionExtensions.AddAuthorization(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Authorization.AuthorizationOptions!>! configure) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.PolicyServiceCollectionExtensions.AddAuthorizationBuilder(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.AspNetCore.Authorization.AuthorizationBuilder!\nstatic Microsoft.Extensions.DependencyInjection.PolicyServiceCollectionExtensions.AddAuthorizationPolicyEvaluator(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Building Microsoft.AspNetCore.App Runtime Project in Bash\nDESCRIPTION: This Bash command builds the Microsoft.AspNetCore.App shared framework project to resolve issues with missing runtime components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/BuildErrors.md#2025-04-08_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh --projects \"$PWD/src/Framework/App.Runtime/src/Microsoft.AspNetCore.App.Runtime.csproj\"\n```\n\n----------------------------------------\n\nTITLE: Running Tests on MacOS/Linux\nDESCRIPTION: Command to run tests for the ASP.NET Core SignalR project on MacOS or Linux systems using bash. The -t flag indicates that tests should be executed after building the project.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/README.md#2025-04-08_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ ./build.sh -t\n```\n\n----------------------------------------\n\nTITLE: SameSiteMode Enum Definition in C#\nDESCRIPTION: Enumeration defining SameSite cookie attribute values for cookie security policy configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Features/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nenum SameSiteMode {\n    Unspecified = -1,\n    None = 0,\n    Lax = 1,\n    Strict = 2\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NegotiateProtocol Class in C#\nDESCRIPTION: A class providing methods to parse and write negotiation responses for HTTP connections. Used during the SignalR connection establishment process.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/Http.Connections.Common/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Connections.NegotiateProtocol\nstatic Microsoft.AspNetCore.Http.Connections.NegotiateProtocol.ParseResponse(System.ReadOnlySpan<byte> content) -> Microsoft.AspNetCore.Http.Connections.NegotiationResponse!\nstatic Microsoft.AspNetCore.Http.Connections.NegotiateProtocol.WriteResponse(Microsoft.AspNetCore.Http.Connections.NegotiationResponse! response, System.Buffers.IBufferWriter<byte>! output) -> void\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Non-Form Content Type in ASP.NET Core\nDESCRIPTION: This method checks if the content type is supported for form requests. If not, it throws a BadHttpRequestException or logs a debug message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ModelStateDictionary Class API\nDESCRIPTION: Core class for managing model binding state and validation results in ASP.NET Core MVC applications. Provides methods for adding errors, checking validation state, and managing model values.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class ModelStateDictionary\n{\n    public ModelStateEntry Root { get; }\n    public bool TryAddModelError(string key, string errorMessage);\n    public void SetModelValue(string key, object rawValue, string attemptedValue);\n    public bool TryGetValue(string key, out ModelStateEntry value);\n    public ModelValidationState ValidationState { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Logging Invalid Form Request Body in ASP.NET Core\nDESCRIPTION: Defines a logger message for invalid form request bodies using LoggerMessage.Define. This captures parameter type and name information and outputs a debug-level message with event ID 8.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n            LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft.AspNetCore.Authentication.Negotiate Package\nDESCRIPTION: Command to install the Microsoft.AspNetCore.Authentication.Negotiate package via the .NET CLI.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Negotiate/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.Authentication.Negotiate\n```\n\n----------------------------------------\n\nTITLE: Implementing SerializedMessage Class in ASP.NET Core SignalR\nDESCRIPTION: Class representing a message serialized with a specific protocol, containing the protocol name and the serialized binary data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.SerializedMessage\nMicrosoft.AspNetCore.SignalR.SerializedMessage.ProtocolName.get -> string!\nMicrosoft.AspNetCore.SignalR.SerializedMessage.Serialized.get -> System.ReadOnlyMemory<byte>\nMicrosoft.AspNetCore.SignalR.SerializedMessage.SerializedMessage() -> void\nMicrosoft.AspNetCore.SignalR.SerializedMessage.SerializedMessage(string! protocolName, System.ReadOnlyMemory<byte> serialized) -> void\n```\n\n----------------------------------------\n\nTITLE: Server-Sent Events Result Type Definition\nDESCRIPTION: Generic type definition for Server-Sent Events result class with execution and status code functionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.ServerSentEventsResult<T>\nMicrosoft.AspNetCore.Http.HttpResults.ServerSentEventsResult<T>.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.ServerSentEventsResult<T>.StatusCode.get -> int?\n```\n\n----------------------------------------\n\nTITLE: XML Repository Interface Definitions in C#\nDESCRIPTION: Interfaces for XML-based key storage repositories including basic XML storage operations and deletable repository functionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IXmlRepository {\n    IReadOnlyCollection<XElement> GetAllElements();\n    void StoreElement(XElement element, string friendlyName);\n}\n\npublic interface IDeletableXmlRepository {\n    bool DeleteElements(Action<IReadOnlyCollection<IDeletableElement>> chooseElements);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Action for Non-Form Content Type Errors\nDESCRIPTION: Creates a static logger action using LoggerMessage.Define to handle unexpected non-form content types. This implementation optimizes logging performance by pre-compiling the log message template.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft.AspNetCore.Components.WebAssembly.Authentication Package Using .NET CLI\nDESCRIPTION: Command to install the Microsoft.AspNetCore.Components.WebAssembly.Authentication NuGet package via the .NET CLI. This package is required to implement client-side authentication in Blazor WebAssembly applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.Components.WebAssembly.Authentication\n```\n\n----------------------------------------\n\nTITLE: Removing API Entry in PublicAPI.Unshipped.txt\nDESCRIPTION: Example of adding an entry for a removed API in the PublicAPI.Unshipped.txt file. This shows how to mark an API as removed using the *REMOVED* prefix.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/APIBaselines.md#2025-04-08_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n#nullable enable\n*REMOVED*Microsoft.Builder.OldApplicationBuilder.New() -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Installing Google Authentication Package using .NET CLI\nDESCRIPTION: Command to install the Microsoft.AspNetCore.Authentication.Google NuGet package into an ASP.NET Core project using the .NET CLI.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Google/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.Authentication.Google\n```\n\n----------------------------------------\n\nTITLE: Configuring Azure AD JWT Authentication in ASP.NET Core\nDESCRIPTION: This code snippet shows how to set up JWT authentication with Azure Active Directory in an ASP.NET Core application. It configures the authentication middleware with the necessary parameters for token validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Abstractions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing MapCore Method for IEndpointRouteBuilder in C#\nDESCRIPTION: Implements the MapCore method for IEndpointRouteBuilder, which is a core method used by other mapping extensions to configure route handlers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsSameInterceptorsFromDifferentFiles.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Virtual Validation Methods in C#\nDESCRIPTION: These virtual methods provide default implementations for asynchronous validation of parameters, properties, and types in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Http.Validation.ValidatableParameterInfo.ValidateAsync(object? value, Microsoft.AspNetCore.Http.Validation.ValidateContext! context, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Http.Validation.ValidatablePropertyInfo.ValidateAsync(object? value, Microsoft.AspNetCore.Http.Validation.ValidateContext! context, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Http.Validation.ValidatableTypeInfo.ValidateAsync(object? value, Microsoft.AspNetCore.Http.Validation.ValidateContext! context, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Razor Pages File Handling Methods\nDESCRIPTION: Methods for serving files through Razor Pages, including virtual files, physical files, and file streams with content type specifications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.File(byte[]! fileContents, string! contentType) -> Microsoft.AspNetCore.Mvc.FileContentResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.File(string! virtualPath, string! contentType) -> Microsoft.AspNetCore.Mvc.VirtualFileResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.PhysicalFile(string! physicalPath, string! contentType) -> Microsoft.AspNetCore.Mvc.PhysicalFileResult!\n```\n\n----------------------------------------\n\nTITLE: Overriding HttpResponseStreamWriter Methods in C#\nDESCRIPTION: This snippet contains override method declarations for the HttpResponseStreamWriter class, including methods for writing characters and lines to the stream.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/WebUtilities/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.Dispose(bool disposing) -> void\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.DisposeAsync() -> System.Threading.Tasks.ValueTask\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.Encoding.get -> System.Text.Encoding!\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.Flush() -> void\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.FlushAsync() -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.Write(char value) -> void\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.Write(char[]! values, int index, int count) -> void\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.Write(string? value) -> void\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.Write(System.ReadOnlySpan<char> value) -> void\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.WriteAsync(char value) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.WriteAsync(char[]! values, int index, int count) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.WriteAsync(string? value) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.WriteAsync(System.ReadOnlyMemory<char> value, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.WriteLine(System.ReadOnlySpan<char> value) -> void\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.WriteLineAsync(char value) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.WriteLineAsync(char[]! values, int index, int count) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.WriteLineAsync(string? value) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.WebUtilities.HttpResponseStreamWriter.WriteLineAsync(System.ReadOnlyMemory<char> value, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: FileExtensionContentTypeProvider in ASP.NET Core\nDESCRIPTION: Provider that maps file extensions to MIME content types. It implements IContentTypeProvider and uses a dictionary to map file extensions to their corresponding content types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/StaticFiles/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.StaticFiles.FileExtensionContentTypeProvider.FileExtensionContentTypeProvider() -> void\nMicrosoft.AspNetCore.StaticFiles.FileExtensionContentTypeProvider.FileExtensionContentTypeProvider(System.Collections.Generic.IDictionary<string!, string!>! mapping) -> void\nMicrosoft.AspNetCore.StaticFiles.FileExtensionContentTypeProvider.Mappings.get -> System.Collections.Generic.IDictionary<string!, string!>!\nMicrosoft.AspNetCore.StaticFiles.FileExtensionContentTypeProvider.TryGetContentType(string! subpath, out string! contentType) -> bool\n```\n\n----------------------------------------\n\nTITLE: Configuring NuGet Sources for .NET 9 Daily Builds\nDESCRIPTION: XML configuration for NuGet.Config file to enable .NET 9 daily builds. Specifies package sources including the dotnet9 Azure DevOps feed and NuGet.org.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/DailyBuilds.md#2025-04-08_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n    <packageSources>\n        <clear />\n        <add key=\"dotnet9\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet9/nuget/v3/index.json\" />\n        <add key=\"NuGet.org\" value=\"https://api.nuget.org/v3/index.json\" />\n    </packageSources>\n</configuration>\n```\n\n----------------------------------------\n\nTITLE: Nullable Enable Directive in C#\nDESCRIPTION: Enables nullable reference types for the entire file, which helps with null-safety by making the compiler aware of which reference types can be null.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net10.0/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Handling Unsupported JSON Content Type in ASP.NET Core\nDESCRIPTION: Handles cases where a JSON media type was expected but an unsupported content type was provided. Returns a 415 Unsupported Media Type status code when throwing exceptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedJsonContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Bodies in ASP.NET Core\nDESCRIPTION: Processes cases where the request body couldn't be parsed as a form for a specific parameter. Based on configuration, it either throws a BadHttpRequestException with the original exception or logs a debug message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing and Returning HTTP Response in ASP.NET Core\nDESCRIPTION: This method handles the execution and return of HTTP responses. It checks the type of the result object and writes the appropriate response, including JSON serialization for complex objects.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Activating Local .NET Environment on Linux/Mac\nDESCRIPTION: Bash command to activate the locally installed .NET environment, necessary before running tests on Linux or Mac.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/README.md#2025-04-08_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nsource activate.sh\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft.AspNetCore.Authentication.OpenIdConnect via NuGet\nDESCRIPTION: This command installs the Microsoft.AspNetCore.Authentication.OpenIdConnect package using the .NET CLI.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.Authentication.OpenIdConnect\n```\n\n----------------------------------------\n\nTITLE: Defining Empty and Extensions Properties in C#\nDESCRIPTION: These properties provide access to Empty result and result extensions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.Empty.get -> Microsoft.AspNetCore.Http.HttpResults.EmptyHttpResult!\nstatic Microsoft.AspNetCore.Http.TypedResults.Extensions.get -> Microsoft.AspNetCore.Http.IResultExtensions!\n```\n\n----------------------------------------\n\nTITLE: Defining IHostContextContainer Interface in ASP.NET Core Server Abstractions\nDESCRIPTION: Generic interface that allows server implementations to access and manipulate a host context. The interface provides get and set methods for a nullable host context of generic type TContext.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Server.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\nMicrosoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>\nMicrosoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.HostContext.get -> TContext?\nMicrosoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.HostContext.set -> void\n```\n\n----------------------------------------\n\nTITLE: ParameterModel and ParameterModelBase Class Definitions in ASP.NET Core MVC\nDESCRIPTION: Model classes that represent action parameters and provide base functionality for parameter models. Includes properties for parameter name, type, binding info, and action references.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModel\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModel.Action.get -> Microsoft.AspNetCore.Mvc.ApplicationModels.ActionModel!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModel.Action.set -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModel.Attributes.get -> System.Collections.Generic.IReadOnlyList<object!>!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModel.DisplayName.get -> string!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModel.ParameterInfo.get -> System.Reflection.ParameterInfo!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModel.ParameterModel(Microsoft.AspNetCore.Mvc.ApplicationModels.ParameterModel! other) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModel.ParameterModel(System.Reflection.ParameterInfo! parameterInfo, System.Collections.Generic.IReadOnlyList<object!>! attributes) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModel.ParameterName.get -> string!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModel.ParameterName.set -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModel.Properties.get -> System.Collections.Generic.IDictionary<object!, object?>!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModelBase\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModelBase.Attributes.get -> System.Collections.Generic.IReadOnlyList<object!>!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModelBase.BindingInfo.get -> Microsoft.AspNetCore.Mvc.ModelBinding.BindingInfo?\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModelBase.BindingInfo.set -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModelBase.Name.get -> string!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModelBase.Name.set -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModelBase.ParameterModelBase(Microsoft.AspNetCore.Mvc.ApplicationModels.ParameterModelBase! other) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModelBase.ParameterModelBase(System.Type! parameterType, System.Collections.Generic.IReadOnlyList<object!>! attributes) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ParameterModelBase.ParameterType.get -> System.Type!\n```\n\n----------------------------------------\n\nTITLE: Defining Content Type Logger Message in C#\nDESCRIPTION: Defines a logger message for unexpected content type scenarios with debug level logging and event ID 6.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nLoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Defining Content Type Constants for ASP.NET Core Request Processing\nDESCRIPTION: A static class that defines content type constants for JSON, plaintext, form file, and form submissions used in request processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Classes for Request Timeouts in ASP.NET Core\nDESCRIPTION: Extension method classes for configuring request timeouts in ASP.NET Core. These extensions allow for setting up timeout policies for endpoints and the application builder pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Builder.RequestTimeoutsIApplicationBuilderExtensions\nMicrosoft.AspNetCore.Builder.RequestTimeoutsIEndpointConventionBuilderExtensions\n```\n\n----------------------------------------\n\nTITLE: JSON Polymorphism Detection for Type Information\nDESCRIPTION: Determines if a JsonTypeInfo instance can handle polymorphic serialization based on type characteristics. Used to select the appropriate serialization path for response objects.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n```\n\n----------------------------------------\n\nTITLE: Defining Form Request Body Logger in ASP.NET Core\nDESCRIPTION: Defines a structured logger action for invalid form request body using LoggerMessage.Define. This creates an optimized logging delegate that captures the parameter type, name, and the exception that occurred.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n    LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive that enables nullable reference type checking for improved null safety in C# code. This helps catch potential null reference exceptions at compile time.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/WebUtilities/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Accessing HttpConnectionFeature in C# for ASP.NET Core\nDESCRIPTION: This method retrieves the HttpConnectionFeature from the HttpContext. It returns the feature if present, or null if not available.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Transport.NamedPipes/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static HttpConnectionFeature? GetHttpConnectionFeature(this HttpContext context)\n{\n    return context.Features.Get<HttpConnectionFeature>();\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Type Information Helpers in ASP.NET Core\nDESCRIPTION: These extension methods help determine if a JsonTypeInfo has known polymorphism and if it should be used with a given runtime type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_NullableStringArrayParam.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\n----------------------------------------\n\nTITLE: Initializing Static Variables for Generated Route Builder in ASP.NET Core\nDESCRIPTION: Defines static fields used by the GeneratedRouteBuilderExtensionsCore class, including fallback JSON options and HTTP verb arrays for GET requests. These are used as defaults when processing HTTP requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_QueryNotPresent.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static readonly JsonOptions FallbackJsonOptions = new();\nprivate static readonly string[] GetVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Get };\n```\n\n----------------------------------------\n\nTITLE: Building ASP.NET Core Cookie Authentication\nDESCRIPTION: Command to build the Cookie Authentication project from within the parent security directory.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Cookies/src/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: Arcade Template Directory Structure\nDESCRIPTION: Directory structure showing the organization of template files in the eng/common directory, including both templates and templates-official paths with their respective shim, logic, and redirect files.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/eng/common/template-guidance.md#2025-04-08_snippet_1\n\nLANGUAGE: text\nCODE:\n```\neng\\common\\\n    [templates || templates-official]\\\n        job\\\n            job.yml                          (shim + artifact publishing logic)\n            onelocbuild.yml                  (shim)\n            publish-build-assets.yml         (shim)\n            source-build.yml                 (shim)\n            source-index-stage1.yml          (shim)\n        jobs\\\n            codeql-build.yml                 (shim)\n            jobs.yml                         (shim)\n            source-build.yml                 (shim)\n        post-build\\\n            post-build.yml                   (shim)\n            common-variabls.yml              (shim)\n            setup-maestro-vars.yml           (shim)\n        steps\\\n            publish-build-artifacts.yml      (logic)\n            publish-pipeline-artifacts.yml   (logic)\n            component-governance.yml         (shim)\n            generate-sbom.yml                (shim)\n            publish-logs.yml                 (shim)\n            retain-build.yml                 (shim)\n            send-to-helix.yml                (shim)\n            source-build.yml                 (shim)\n        variables\\\n            pool-providers.yml               (logic + redirect)\n            sdl-variables.yml                (logic)\n    core-templates\\\n        job\\\n            job.yml                          (logic)\n            onelocbuild.yml                  (logic)\n            publish-build-assets.yml         (logic)\n            source-build.yml                 (logic)\n            source-index-stage1.yml          (logic)\n        jobs\\\n            codeql-build.yml                 (logic)\n            jobs.yml                         (logic)\n            source-build.yml                 (logic)\n        post-build\\\n            common-variabls.yml              (logic)\n            post-build.yml                   (logic)\n            setup-maestro-vars.yml           (logic)\n        steps\\\n            component-governance.yml         (logic)\n            generate-sbom.yml                (logic)\n            publish-build-artifacts.yml      (redirect)\n            publish-logs.yml                 (logic)\n            publish-pipeline-artifacts.yml   (redirect)\n            retain-build.yml                 (logic)\n            send-to-helix.yml                (logic)\n            source-build.yml                 (logic)\n        variables\\\n            pool-providers.yml               (redirect)\n```\n\n----------------------------------------\n\nTITLE: Declaring Metadata and Validation Interfaces in C#\nDESCRIPTION: These interfaces define contracts for disabling validation, producing response type metadata, and validating information in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Metadata.IDisableValidationMetadata\nMicrosoft.AspNetCore.Http.Metadata.IProducesResponseTypeMetadata.Description.get -> string?\nMicrosoft.AspNetCore.Http.Validation.IValidatableInfo\nMicrosoft.AspNetCore.Http.Validation.IValidatableInfo.ValidateAsync(object? value, Microsoft.AspNetCore.Http.Validation.ValidateContext! context, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.Validation.IValidatableInfoResolver\nMicrosoft.AspNetCore.Http.Validation.IValidatableInfoResolver.TryGetValidatableParameterInfo(System.Reflection.ParameterInfo! parameterInfo, out Microsoft.AspNetCore.Http.Validation.IValidatableInfo? validatableInfo) -> bool\nMicrosoft.AspNetCore.Http.Validation.IValidatableInfoResolver.TryGetValidatableTypeInfo(System.Type! type, out Microsoft.AspNetCore.Http.Validation.IValidatableInfo? validatableInfo) -> bool\n```\n\n----------------------------------------\n\nTITLE: Defining FileHandleEndPoint Class in C#\nDESCRIPTION: This snippet defines the FileHandleEndPoint class with properties for file handle and file handle type, along with constructors.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Connections.FileHandleEndPoint\nMicrosoft.AspNetCore.Connections.FileHandleEndPoint.FileHandle.get -> ulong\nMicrosoft.AspNetCore.Connections.FileHandleEndPoint.FileHandleEndPoint(ulong fileHandle, Microsoft.AspNetCore.Connections.FileHandleType fileHandleType) -> void\nMicrosoft.AspNetCore.Connections.FileHandleEndPoint.FileHandleType.get -> Microsoft.AspNetCore.Connections.FileHandleType\n```\n\n----------------------------------------\n\nTITLE: Checking for Known Polymorphism in JsonTypeInfo\nDESCRIPTION: This extension method checks if a JsonTypeInfo has known polymorphism based on the type's properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n```\n\n----------------------------------------\n\nTITLE: Azure Blob Logger Options API\nDESCRIPTION: Configuration options for Azure Blob logging including blob name and file name format customization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Logging.AzureAppServices/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n~Microsoft.Extensions.Logging.AzureAppServices.AzureBlobLoggerOptions.BlobName.get -> string\n~Microsoft.Extensions.Logging.AzureAppServices.AzureBlobLoggerOptions.BlobName.set -> void\n~Microsoft.Extensions.Logging.AzureAppServices.AzureBlobLoggerOptions.FileNameFormat.get -> System.Func<Microsoft.Extensions.Logging.AzureAppServices.AzureBlobLoggerContext, string>\n~Microsoft.Extensions.Logging.AzureAppServices.AzureBlobLoggerOptions.FileNameFormat.set -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring Web Hosts with IHostBuilder Extensions in ASP.NET Core\nDESCRIPTION: Extension methods for IHostBuilder that allow configuring a web host with various options. These methods enable integration between the generic hosting model and the web-specific hosting infrastructure.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureSlimWebHost(this Microsoft.Extensions.Hosting.IHostBuilder! builder, System.Action<Microsoft.AspNetCore.Hosting.IWebHostBuilder!>! configure, System.Action<Microsoft.Extensions.Hosting.WebHostBuilderOptions!>! configureWebHostBuilder) -> Microsoft.Extensions.Hosting.IHostBuilder!\nstatic Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost(this Microsoft.Extensions.Hosting.IHostBuilder! builder, System.Action<Microsoft.AspNetCore.Hosting.IWebHostBuilder!>! configure) -> Microsoft.Extensions.Hosting.IHostBuilder!\nstatic Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost(this Microsoft.Extensions.Hosting.IHostBuilder! builder, System.Action<Microsoft.AspNetCore.Hosting.IWebHostBuilder!>! configure, System.Action<Microsoft.Extensions.Hosting.WebHostBuilderOptions!>! configureWebHostBuilder) -> Microsoft.Extensions.Hosting.IHostBuilder!\n```\n\n----------------------------------------\n\nTITLE: Connection Handler Implementation\nDESCRIPTION: Abstract connection handler class defining the core connection handling functionality with async connection management.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Connections.ConnectionHandler.OnConnectedAsync(Microsoft.AspNetCore.Connections.ConnectionContext! connection) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: HttpAuthenticationFeature in ASP.NET Core\nDESCRIPTION: Feature providing authentication capabilities to HTTP requests in ASP.NET Core. It holds the ClaimsPrincipal representing the authenticated user and is used by authentication middleware.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Features.Authentication.HttpAuthenticationFeature\nMicrosoft.AspNetCore.Http.Features.Authentication.HttpAuthenticationFeature.HttpAuthenticationFeature() -> void\nMicrosoft.AspNetCore.Http.Features.Authentication.HttpAuthenticationFeature.User.get -> System.Security.Claims.ClaimsPrincipal?\nMicrosoft.AspNetCore.Http.Features.Authentication.HttpAuthenticationFeature.User.set -> void\n```\n\n----------------------------------------\n\nTITLE: Creating Claims Principal from Account in ASP.NET Core WebAssembly\nDESCRIPTION: Virtual method for creating a ClaimsPrincipal from an account in WebAssembly authentication. This method is part of the AccountClaimsPrincipalFactory class and is responsible for converting account data to claims.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.WebAssembly.Authentication.AccountClaimsPrincipalFactory<TAccount>.CreateUserAsync(TAccount! account, Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationUserOptions! options) -> System.Threading.Tasks.ValueTask<System.Security.Claims.ClaimsPrincipal!>\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive that enables nullable reference type checking, requiring explicit null checks and helping prevent null reference exceptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Razor/Razor/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing StatusCodeHttpResult in ASP.NET Core\nDESCRIPTION: API signatures for the StatusCodeHttpResult class, which returns a response with the specified status code and no content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.StatusCodeHttpResult\nMicrosoft.AspNetCore.Http.HttpResults.StatusCodeHttpResult.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.StatusCodeHttpResult.StatusCode.get -> int\n```\n\n----------------------------------------\n\nTITLE: Defining LoggerMessage for Form Parameter Reading Failure\nDESCRIPTION: Creates a structured logger message definition for cases where reading form parameters from the request body fails. Takes parameter type and name as arguments and logs at Debug level with EventId 8.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_NullableStringArrayParam.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nLoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Defining Constants for FormReader and MultipartReader in C#\nDESCRIPTION: Declares constant values for key length limits, value count limits, and header limits used in FormReader and MultipartReader classes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/WebUtilities/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.WebUtilities.FormReader.DefaultKeyLengthLimit = 2048 -> int\nconst Microsoft.AspNetCore.WebUtilities.FormReader.DefaultValueCountLimit = 1024 -> int\nconst Microsoft.AspNetCore.WebUtilities.FormReader.DefaultValueLengthLimit = 4194304 -> int\nconst Microsoft.AspNetCore.WebUtilities.MultipartReader.DefaultHeadersCountLimit = 16 -> int\nconst Microsoft.AspNetCore.WebUtilities.MultipartReader.DefaultHeadersLengthLimit = 16384 -> int\n```\n\n----------------------------------------\n\nTITLE: Compiling ASP.NET Core Solution in Release Mode (Batch)\nDESCRIPTION: This command compiles the ASP.NET Core solution in Release configuration to ensure Kestrel is available in release mode.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/HttpSys/perf/Microbenchmarks/README.md#2025-04-08_snippet_0\n\nLANGUAGE: batch\nCODE:\n```\nbuild.cmd /p:Configuration=Release\n```\n\n----------------------------------------\n\nTITLE: Defining OWIN Environment Feature Interface in C#\nDESCRIPTION: Defines the IOwinEnvironmentFeature interface with a property for accessing the OWIN environment dictionary.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Owin/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Owin.IOwinEnvironmentFeature.Environment.get -> System.Collections.Generic.IDictionary<string, object>\nMicrosoft.AspNetCore.Owin.IOwinEnvironmentFeature.Environment.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining DataProtectionKey Entity Class in ASP.NET Core\nDESCRIPTION: Declaration of the DataProtectionKey class which represents data protection keys stored in a database. It includes properties for Id, Xml content of the key, and a FriendlyName for easier identification.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\nMicrosoft.AspNetCore.DataProtection.EntityFrameworkCore.DataProtectionKey\nMicrosoft.AspNetCore.DataProtection.EntityFrameworkCore.DataProtectionKey.DataProtectionKey() -> void\nMicrosoft.AspNetCore.DataProtection.EntityFrameworkCore.DataProtectionKey.FriendlyName.get -> string?\nMicrosoft.AspNetCore.DataProtection.EntityFrameworkCore.DataProtectionKey.FriendlyName.set -> void\nMicrosoft.AspNetCore.DataProtection.EntityFrameworkCore.DataProtectionKey.Id.get -> int\nMicrosoft.AspNetCore.DataProtection.EntityFrameworkCore.DataProtectionKey.Id.set -> void\nMicrosoft.AspNetCore.DataProtection.EntityFrameworkCore.DataProtectionKey.Xml.get -> string?\nMicrosoft.AspNetCore.DataProtection.EntityFrameworkCore.DataProtectionKey.Xml.set -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing MapCore Method for ASP.NET Core Route Handler Building\nDESCRIPTION: Implements the core mapping functionality for ASP.NET Core route handlers. This method acts as a bridge between user-defined route patterns and the underlying ASP.NET Core routing system.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Nullable Description Properties in ASP.NET Core MVC API Documentation\nDESCRIPTION: Defines nullable string Description property signatures for various ASP.NET Core MVC attributes that provide API documentation. These properties allow developers to specify human-readable descriptions for API responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\nMicrosoft.AspNetCore.Mvc.ApiExplorer.IApiResponseMetadataProvider.Description.get -> string?\nMicrosoft.AspNetCore.Mvc.ProducesAttribute.Description.get -> string?\nMicrosoft.AspNetCore.Mvc.ProducesAttribute.Description.set -> void\nMicrosoft.AspNetCore.Mvc.ProducesDefaultResponseTypeAttribute.Description.get -> string?\nMicrosoft.AspNetCore.Mvc.ProducesDefaultResponseTypeAttribute.Description.set -> void\nMicrosoft.AspNetCore.Mvc.ProducesResponseTypeAttribute.Description.get -> string?\nMicrosoft.AspNetCore.Mvc.ProducesResponseTypeAttribute.Description.set -> void\n```\n\n----------------------------------------\n\nTITLE: Using DefaultFiles Middleware in ASP.NET Core\nDESCRIPTION: Extension methods for configuring the DefaultFiles middleware in ASP.NET Core applications. These methods allow serving default files like index.html when a directory is requested.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/StaticFiles/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.DefaultFilesExtensions.UseDefaultFiles(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.DefaultFilesExtensions.UseDefaultFiles(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app, Microsoft.AspNetCore.Builder.DefaultFilesOptions! options) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.DefaultFilesExtensions.UseDefaultFiles(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app, string! requestPath) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Adding gRPC Swagger Extensions Methods in C#\nDESCRIPTION: Defines extension methods for configuring Swagger to work with gRPC services. Includes methods for including XML documentation comments from gRPC service definitions and registering necessary services in the ASP.NET Core dependency injection container.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Grpc/JsonTranscoding/src/Microsoft.AspNetCore.Grpc.Swagger/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\nMicrosoft.Extensions.DependencyInjection.GrpcSwaggerGenOptionsExtensions\nMicrosoft.Extensions.DependencyInjection.GrpcSwaggerServiceExtensions\nstatic Microsoft.Extensions.DependencyInjection.GrpcSwaggerGenOptionsExtensions.IncludeGrpcXmlComments(this Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions! swaggerGenOptions, string! filePath) -> void\nstatic Microsoft.Extensions.DependencyInjection.GrpcSwaggerGenOptionsExtensions.IncludeGrpcXmlComments(this Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions! swaggerGenOptions, string! filePath, bool includeControllerXmlComments) -> void\nstatic Microsoft.Extensions.DependencyInjection.GrpcSwaggerGenOptionsExtensions.IncludeGrpcXmlComments(this Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions! swaggerGenOptions, System.Func<System.Xml.XPath.XPathDocument!>! xmlDocFactory) -> void\nstatic Microsoft.Extensions.DependencyInjection.GrpcSwaggerGenOptionsExtensions.IncludeGrpcXmlComments(this Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions! swaggerGenOptions, System.Func<System.Xml.XPath.XPathDocument!>! xmlDocFactory, bool includeControllerXmlComments) -> void\nstatic Microsoft.Extensions.DependencyInjection.GrpcSwaggerServiceExtensions.AddGrpcSwagger(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Defining Header Propagation Message Handler in C#\nDESCRIPTION: Message handler implementation for processing and propagating headers in HTTP requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HeaderPropagation/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.HeaderPropagation.HeaderPropagationMessageHandler.HeaderPropagationMessageHandler(Microsoft.AspNetCore.HeaderPropagation.HeaderPropagationMessageHandlerOptions! options, Microsoft.AspNetCore.HeaderPropagation.HeaderPropagationValues! values) -> void\n~override Microsoft.AspNetCore.HeaderPropagation.HeaderPropagationMessageHandler.SendAsync(System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Net.Http.HttpResponseMessage>\n```\n\n----------------------------------------\n\nTITLE: DefaultConnectionContext Property Overrides\nDESCRIPTION: Override implementations for DefaultConnectionContext properties including Items, EndPoints, and Transport handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.Items.get -> System.Collections.Generic.IDictionary<object!, object?>!\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.Items.set -> void\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.LocalEndPoint.get -> System.Net.EndPoint?\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.LocalEndPoint.set -> void\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.RemoteEndPoint.get -> System.Net.EndPoint?\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.RemoteEndPoint.set -> void\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.Transport.get -> System.IO.Pipelines.IDuplexPipe!\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.Transport.set -> void\n```\n\n----------------------------------------\n\nTITLE: Invalid Form Request Body Handler in C#\nDESCRIPTION: Handles invalid form request body scenarios by either throwing a BadHttpRequestException or logging the error based on configuration. Takes parameter type name, parameter name, and the exception as inputs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/RequestDelegateValidateGeneratedFormCode.generated.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling C# Nullable Reference Types\nDESCRIPTION: This directive enables C# nullable reference types for the file, requiring explicit handling of null values and helping prevent null reference exceptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Headers/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: JSON Type Info Extension Methods for Polymorphism Handling\nDESCRIPTION: Helper methods that determine whether specific JsonTypeInfo instances can be used with runtime types, handling polymorphism cases. These methods check if the type is sealed, a value type, or has explicit polymorphism options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_StringArrayParam.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants Definition\nDESCRIPTION: Defines constant arrays for common HTTP content types used in request/response handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Server Command Help Usage\nDESCRIPTION: Shows help documentation for the server command which runs a web host with a SignalR Hub endpoint on /echo. Includes options for log level and Azure SignalR connection string.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/perf/benchmarkapps/Crankier/Readme.md#2025-04-08_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n> dotnet run -- help server\n\nUsage:  server [options]\n\nOptions:\n  --log <LOG_LEVEL>                                     The LogLevel to use.\n  --azure-signalr-connectionstring <CONNECTION_STRING>  Azure SignalR Connection string to use\n\n```\n\n----------------------------------------\n\nTITLE: Defining HostingEnvironmentExtensions Class in C#\nDESCRIPTION: Provides extension methods for IHostingEnvironment to check the current environment.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Hosting.HostingEnvironmentExtensions.IsDevelopment(this Microsoft.AspNetCore.Hosting.IHostingEnvironment! hostingEnvironment) -> bool\nstatic Microsoft.AspNetCore.Hosting.HostingEnvironmentExtensions.IsEnvironment(this Microsoft.AspNetCore.Hosting.IHostingEnvironment! hostingEnvironment, string! environmentName) -> bool\nstatic Microsoft.AspNetCore.Hosting.HostingEnvironmentExtensions.IsProduction(this Microsoft.AspNetCore.Hosting.IHostingEnvironment! hostingEnvironment) -> bool\nstatic Microsoft.AspNetCore.Hosting.HostingEnvironmentExtensions.IsStaging(this Microsoft.AspNetCore.Hosting.IHostingEnvironment! hostingEnvironment) -> bool\n```\n\n----------------------------------------\n\nTITLE: Implementing GraphQLHttpMiddlewareOptions Class in C#\nDESCRIPTION: Defines the configuration options for GraphQL HTTP middleware in ASP.NET Core. This class includes properties for specifying the endpoint path, authentication requirements, execution behavior, and other middleware settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HealthChecks/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining WebAssemblyHostEnvironment Interface in C#\nDESCRIPTION: Defines the IWebAssemblyHostEnvironment interface with properties for BaseAddress and Environment.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.IWebAssemblyHostEnvironment\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.IWebAssemblyHostEnvironment.BaseAddress.get -> string!\nMicrosoft.AspNetCore.Components.WebAssembly.Hosting.IWebAssemblyHostEnvironment.Environment.get -> string!\n```\n\n----------------------------------------\n\nTITLE: Using CORS Attributes\nDESCRIPTION: Demonstrates using EnableCors and DisableCors attributes to control CORS behavior at the controller or action level.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[EnableCors(\"PolicyName\")]\npublic class ApiController : ControllerBase\n{\n    [DisableCors]\n    public IActionResult SensitiveAction()\n    {\n        return Ok();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: WebAssemblyJSRuntime Method Declarations in C#\nDESCRIPTION: Declares the public interface for WebAssemblyJSRuntime class, including methods for synchronous and asynchronous JavaScript invocation, .NET invocation handling, and byte array transmission.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/JSInterop/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n~override Microsoft.JSInterop.WebAssembly.WebAssemblyJSRuntime.BeginInvokeJS(long asyncHandle, string identifier, string argsJson, Microsoft.JSInterop.JSCallResultType resultType, long targetInstanceId) -> void\n~override Microsoft.JSInterop.WebAssembly.WebAssemblyJSRuntime.InvokeJS(string identifier, string argsJson, Microsoft.JSInterop.JSCallResultType resultType, long targetInstanceId) -> string\nMicrosoft.JSInterop.WebAssembly.WebAssemblyJSRuntime\nMicrosoft.JSInterop.WebAssembly.WebAssemblyJSRuntime.WebAssemblyJSRuntime() -> void\noverride Microsoft.JSInterop.WebAssembly.WebAssemblyJSRuntime.BeginInvokeJS(long asyncHandle, string! identifier, string? argsJson, Microsoft.JSInterop.JSCallResultType resultType, long targetInstanceId) -> void\noverride Microsoft.JSInterop.WebAssembly.WebAssemblyJSRuntime.EndInvokeDotNet(Microsoft.JSInterop.Infrastructure.DotNetInvocationInfo callInfo, in Microsoft.JSInterop.Infrastructure.DotNetInvocationResult dispatchResult) -> void\noverride Microsoft.JSInterop.WebAssembly.WebAssemblyJSRuntime.InvokeJS(string! identifier, string? argsJson, Microsoft.JSInterop.JSCallResultType resultType, long targetInstanceId) -> string!\noverride Microsoft.JSInterop.WebAssembly.WebAssemblyJSRuntime.SendByteArray(int id, byte[]! data) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing PolicyHttpMessageHandler SendAsync Method\nDESCRIPTION: Override implementation of SendAsync method for handling HTTP requests with policy execution.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HttpClientFactory/Polly/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.Extensions.Http.PolicyHttpMessageHandler.SendAsync(System.Net.Http.HttpRequestMessage! request, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Net.Http.HttpResponseMessage!>!\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet0 Extension Method for IEndpointRouteBuilder\nDESCRIPTION: An internal extension method for IEndpointRouteBuilder that maps HTTP GET requests to handler methods. It includes metadata population, parameter binding, route handling, and request filtering functionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n        %INTERCEPTSLOCATIONATTRIBUTE%\n        internal static RouteHandlerBuilder MapGet0(\n            this IEndpointRouteBuilder endpoints,\n            [StringSyntax(\"Route\")] string pattern,\n            Delegate handler)\n        {\n            MetadataPopulator populateMetadata = (methodInfo, options) =>\n            {\n                Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n                Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n                options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n                options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"HttpContext\", new PropertyAsParameterInfo(false, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue)!.GetProperty(\"HttpContext\")!, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue).GetConstructor(new[] { typeof(Microsoft.AspNetCore.Http.HttpContext), typeof(int) })?.GetParameters()[0]), hasTryParse: false, hasBindAsync: false, isOptional: false));\n                options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"Value\", new PropertyAsParameterInfo(true, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue)!.GetProperty(\"Value\")!, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue).GetConstructor(new[] { typeof(Microsoft.AspNetCore.Http.HttpContext), typeof(int) })?.GetParameters()[1]), hasTryParse: true, hasBindAsync: false, isOptional: true));\n                return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n            };\n            RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n            {\n                Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n                Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n                Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n                Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n                var handler = Cast(del, void (global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue arg0) => throw null!);\n                EndpointFilterDelegate? filteredInvocation = null;\n                var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n                var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n                var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n                var jsonSerializerOptions = jsonOptions.SerializerOptions;\n                jsonSerializerOptions.MakeReadOnly();\n                var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n\n                if (options.EndpointBuilder.FilterFactories.Count > 0)\n                {\n                    filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n                    {\n                        if (ic.HttpContext.Response.StatusCode == 400)\n                        {\n                            return ValueTask.FromResult<object?>(Results.Empty);\n                        }\n                        handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue>(0)!);\n                        return ValueTask.FromResult<object?>(Results.Empty);\n                    },\n                    options.EndpointBuilder,\n                    handler.Method);\n                }\n\n                Task RequestHandler(HttpContext httpContext)\n                {\n                    var wasParamCheckFailure = false;\n                    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)\n                                        var HttpContext_local = httpContext;\n                    // Endpoint Parameter: Value (Type = int, IsOptional = True, IsParsable = True, IsArray = False, Source = Route)\n                    if (options?.RouteParameterNames?.Contains(\"Value\", StringComparer.OrdinalIgnoreCase) != true)\n                    {\n                        throw new InvalidOperationException($\"'Value' is not a route parameter.\");\n                    }\n                    var Value_raw = (string?)httpContext.Request.RouteValues[\"Value\"];\n                    var Value_temp = (string?)Value_raw;\n                    global::System.Int32 Value_parsed_temp = default;\n                    if (GeneratedRouteBuilderExtensionsCore.TryParseExplicit<int>(Value_temp!, CultureInfo.InvariantCulture, out var Value_temp_parsed_non_nullable))\n                    {\n                        Value_parsed_temp = Value_temp_parsed_non_nullable;\n                    }\n                    else if (string.IsNullOrEmpty(Value_temp))\n                    {\n                        Value_parsed_temp = 42;\n                    }\n                    else\n                    {\n                        wasParamCheckFailure = true;\n                    }\n                    int Value_local = Value_parsed_temp!;\n\n                    var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue(HttpContext_local, Value_local);\n\n                    if (wasParamCheckFailure)\n                    {\n                        httpContext.Response.StatusCode = 400;\n                        return Task.CompletedTask;\n                    }\n                    handler(args_local);\n                    return Task.CompletedTask;\n                }\n\n                async Task RequestHandlerFiltered(HttpContext httpContext)\n                {\n                    var wasParamCheckFailure = false;\n                    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)\n                                        var HttpContext_local = httpContext;\n                    // Endpoint Parameter: Value (Type = int, IsOptional = True, IsParsable = True, IsArray = False, Source = Route)\n                    if (options?.RouteParameterNames?.Contains(\"Value\", StringComparer.OrdinalIgnoreCase) != true)\n                    {\n                        throw new InvalidOperationException($\"'Value' is not a route parameter.\");\n                    }\n                    var Value_raw = (string?)httpContext.Request.RouteValues[\"Value\"];\n                    var Value_temp = (string?)Value_raw;\n                    global::System.Int32 Value_parsed_temp = default;\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Message for Unexpected JSON Content Type in C#\nDESCRIPTION: This snippet defines a LoggerMessage for logging when an unexpected JSON content type is received. It uses LogLevel.Debug and creates an EventId for the message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Retrieving Custom Attribute Data in C#\nDESCRIPTION: This method retrieves custom attribute data from both a construction parameter and an underlying property, combining them into a single read-only list.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic override IList<CustomAttributeData> GetCustomAttributesData()\n{\n    var attributes = new List<CustomAttributeData>(\n        _constructionParameterInfo?.GetCustomAttributesData() ?? Array.Empty<CustomAttributeData>());\n    attributes.AddRange(_underlyingProperty.GetCustomAttributesData());\n\n    return attributes.AsReadOnly();\n}\n```\n\n----------------------------------------\n\nTITLE: Building the WsFederation Authentication Project\nDESCRIPTION: Command to build the WsFederation authentication project from source. This should be run from the parent 'security' directory to compile the project and its dependencies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/WsFederation/src/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in ASP.NET Core\nDESCRIPTION: Implements error handling for failed form parameter reading from request bodies. It captures parameter type and name information and either throws a BadHttpRequestException or logs the error based on configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n        {\n            if (_shouldThrow)\n            {\n                var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n                throw new BadHttpRequestException(message, exception);\n            }\n\n            if (_rdgLogger != null)\n            {\n                _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n            }\n        }\n```\n\n----------------------------------------\n\nTITLE: Implementing NullableAttributes Support for .NET Dependency Injection in C#\nDESCRIPTION: This code defines a static class with extension methods that handle nullable reference types in dependency injection scenarios. It ensures that proper type checking and casting happens when resolving services in a nullable context.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/Authentication.Msal/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Connection Context Abstract Methods in C#\nDESCRIPTION: Defines the abstract methods for BaseConnectionContext and ConnectionContext classes that provide the foundation for connection handling in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\nabstract Microsoft.AspNetCore.Connections.BaseConnectionContext.Abort() -> void\nabstract Microsoft.AspNetCore.Connections.BaseConnectionContext.Abort(Microsoft.AspNetCore.Connections.ConnectionAbortedException! abortReason) -> void\nabstract Microsoft.AspNetCore.Connections.BaseConnectionContext.ConnectionId.get -> string!\nabstract Microsoft.AspNetCore.Connections.BaseConnectionContext.ConnectionId.set -> void\nabstract Microsoft.AspNetCore.Connections.BaseConnectionContext.Features.get -> Microsoft.AspNetCore.Http.Features.IFeatureCollection!\nabstract Microsoft.AspNetCore.Connections.BaseConnectionContext.Items.get -> System.Collections.Generic.IDictionary<object!, object?>!\nabstract Microsoft.AspNetCore.Connections.BaseConnectionContext.Items.set -> void\nabstract Microsoft.AspNetCore.Connections.ConnectionContext.Transport.get -> System.IO.Pipelines.IDuplexPipe!\nabstract Microsoft.AspNetCore.Connections.ConnectionContext.Transport.set -> void\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: A compiler directive that enables nullable reference type annotations in C#. When enabled, reference types like string are non-nullable by default, and nullable reference types must be explicitly marked with a ? suffix.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Azure/AzureAppServices.HostingStartup/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining SignOutSessionStateManager Class in C#\nDESCRIPTION: Defines the SignOutSessionStateManager class for managing sign-out session state in ASP.NET Core WebAssembly authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.SignOutSessionStateManager\nMicrosoft.AspNetCore.Components.WebAssembly.Authentication.SignOutSessionStateManager.SignOutSessionStateManager(Microsoft.JSInterop.IJSRuntime! jsRuntime) -> void\n```\n\n----------------------------------------\n\nTITLE: Certificate Type Enumeration\nDESCRIPTION: Enumeration defining supported certificate types for authentication including self-signed and chained certificates\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Certificate/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.Certificate.CertificateTypes.All = Microsoft.AspNetCore.Authentication.Certificate.CertificateTypes.Chained | Microsoft.AspNetCore.Authentication.Certificate.CertificateTypes.SelfSigned\nMicrosoft.AspNetCore.Authentication.Certificate.CertificateTypes.Chained = 1\nMicrosoft.AspNetCore.Authentication.Certificate.CertificateTypes.SelfSigned = 2\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata in ASP.NET Core\nDESCRIPTION: This class implements IParameterBindingMetadata and stores information about parameter binding, including the parameter name, type information, and binding capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Methods for Registering WebView Services\nDESCRIPTION: Extension methods for IServiceCollection to add Blazor WebView services to the dependency injection container.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebView/WebView/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.DependencyInjection.ComponentsWebViewServiceCollectionExtensions\nstatic Microsoft.Extensions.DependencyInjection.ComponentsWebViewServiceCollectionExtensions.AddBlazorWebView(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Configuring Authentication Options in C# for ASP.NET Core\nDESCRIPTION: This code snippet defines a class AuthenticationOptions that configures various authentication settings including default schemes, challenge schemes, and forbid schemes. It also includes methods for registering authentication handlers and configuring authentication options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class AuthenticationOptions : IOptions<AuthenticationOptions>\n{\n    private readonly Dictionary<string, AuthenticationSchemeBuilder> _schemes;\n    private readonly List<AuthenticationSchemeBuilder> _schemesCopy;\n    private readonly Dictionary<string, object> _configureActions;\n\n    public AuthenticationOptions()\n    {\n        _schemes = new Dictionary<string, AuthenticationSchemeBuilder>(StringComparer.Ordinal);\n        _schemesCopy = new List<AuthenticationSchemeBuilder>();\n        _configureActions = new Dictionary<string, object>(StringComparer.Ordinal);\n    }\n\n    public string? DefaultAuthenticateScheme { get; set; }\n\n    public string? DefaultChallengeScheme { get; set; }\n\n    public string? DefaultForbidScheme { get; set; }\n\n    public string? DefaultScheme\n    {\n        get { return DefaultAuthenticateScheme; }\n        set\n        {\n            DefaultAuthenticateScheme = value;\n            DefaultChallengeScheme = value;\n            DefaultForbidScheme = value;\n            DefaultSignInScheme = value;\n            DefaultSignOutScheme = value;\n        }\n    }\n\n    public string? DefaultSignInScheme { get; set; }\n\n    public string? DefaultSignOutScheme { get; set; }\n\n    public string? RequireAuthenticatedSignIn { get; set; }\n\n    public IEnumerable<AuthenticationSchemeBuilder> Schemes => _schemesCopy;\n\n    AuthenticationOptions IOptions<AuthenticationOptions>.Value\n    {\n        get { return this; }\n    }\n\n    public void AddScheme<THandler>(string name, Action<AuthenticationSchemeBuilder>? configureBuilder)\n        where THandler : IAuthenticationHandler\n    {\n        if (name == null)\n        {\n            throw new ArgumentNullException(nameof(name));\n        }\n        if (_schemes.ContainsKey(name))\n        {\n            throw new InvalidOperationException(\"Scheme already exists: \" + name);\n        }\n\n        var builder = new AuthenticationSchemeBuilder(name, typeof(THandler));\n        configureBuilder?.Invoke(builder);\n        _schemes[name] = builder;\n        _schemesCopy.Add(builder);\n    }\n\n    public void AddScheme(string name, Type handlerType)\n    {\n        if (name == null)\n        {\n            throw new ArgumentNullException(nameof(name));\n        }\n        if (handlerType == null)\n        {\n            throw new ArgumentNullException(nameof(handlerType));\n        }\n        if (_schemes.ContainsKey(name))\n        {\n            throw new InvalidOperationException(\"Scheme already exists: \" + name);\n        }\n        _schemes[name] = new AuthenticationSchemeBuilder(name, handlerType);\n        _schemesCopy.Add(_schemes[name]);\n    }\n\n    public bool TryAddScheme<THandler>(string name, Action<AuthenticationSchemeBuilder>? configureBuilder)\n        where THandler : IAuthenticationHandler\n    {\n        if (name == null)\n        {\n            throw new ArgumentNullException(nameof(name));\n        }\n        if (_schemes.ContainsKey(name))\n        {\n            return false;\n        }\n\n        var builder = new AuthenticationSchemeBuilder(name, typeof(THandler));\n        configureBuilder?.Invoke(builder);\n        _schemes[name] = builder;\n        _schemesCopy.Add(builder);\n        return true;\n    }\n\n    public AuthenticationSchemeBuilder? GetSchemeBuilder(string name)\n    {\n        if (name == null)\n        {\n            throw new ArgumentNullException(nameof(name));\n        }\n\n        if (_schemes.TryGetValue(name, out var builder))\n        {\n            return builder;\n        }\n        return null;\n    }\n\n    public void RemoveScheme(string name)\n    {\n        if (name == null)\n        {\n            throw new ArgumentNullException(nameof(name));\n        }\n\n        if (_schemes.TryGetValue(name, out var builder))\n        {\n            _schemes.Remove(name);\n            _schemesCopy.Remove(builder);\n        }\n    }\n\n    public void RegisterConfigureHandler<TOptions>(string authenticationScheme, Action<TOptions, HttpContext> configureOptions)\n    {\n        _configureActions[authenticationScheme] = configureOptions;\n    }\n\n    public void RegisterConfigureHandler(string authenticationScheme, Action<object, HttpContext> configureOptions)\n    {\n        _configureActions[authenticationScheme] = configureOptions;\n    }\n\n    public Action<TOptions, HttpContext>? GetConfigureHandler<TOptions>(string authenticationScheme)\n    {\n        if (_configureActions.TryGetValue(authenticationScheme, out var configureAction))\n        {\n            return configureAction as Action<TOptions, HttpContext>;\n        }\n        return null;\n    }\n\n    public Func<AuthenticationScheme, object> ClaimsIssuer { get; set; } = (scheme) => scheme.Name;\n}\n```\n\n----------------------------------------\n\nTITLE: Launching Visual Studio for SignalR Development\nDESCRIPTION: Starts Visual Studio using a custom script to ensure proper project loading and configuration for SignalR development.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/GettingStarted.md#2025-04-08_snippet_2\n\nLANGUAGE: batch\nCODE:\n```\nstartvs.cmd\n```\n\n----------------------------------------\n\nTITLE: Adding Project Reference to Primary DotNetProjects List in Build.props\nDESCRIPTION: XML snippet showing the format for adding a new project directory to the primary DotNetProjects list in eng/Build.props. This list is used when BuildMainlyReferenceProviders is not set to true.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/AddingNewProjects.md#2025-04-08_snippet_1\n\nLANGUAGE: XML\nCODE:\n```\n<DotNetProjects Include=\"\n                      $(RepoRoot)src\\[YOUR FOLDER]\\**\\*.csproj;\n                      ...\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Required Parameters in ASP.NET Core\nDESCRIPTION: Handles cases where a required parameter was not provided from a specific source. This method either throws a BadHttpRequestException or logs the missing parameter based on configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Core Functionality for ASP.NET Core Routing\nDESCRIPTION: This method maps core functionality for ASP.NET Core routing, including pattern matching, HTTP method handling, and request delegate creation. It utilizes the RouteHandlerServices to perform the actual mapping.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitBodyParam_ComplexReturn_Snapshot.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: CacheControlHeaderValue Constants in C#\nDESCRIPTION: Static readonly string constants for various Cache-Control header directives.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Headers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.Net.Http.Headers.CacheControlHeaderValue.MaxAgeString -> string!\nstatic readonly Microsoft.Net.Http.Headers.CacheControlHeaderValue.MaxStaleString -> string!\nstatic readonly Microsoft.Net.Http.Headers.CacheControlHeaderValue.MinFreshString -> string!\nstatic readonly Microsoft.Net.Http.Headers.CacheControlHeaderValue.MustRevalidateString -> string!\nstatic readonly Microsoft.Net.Http.Headers.CacheControlHeaderValue.NoCacheString -> string!\nstatic readonly Microsoft.Net.Http.Headers.CacheControlHeaderValue.NoStoreString -> string!\nstatic readonly Microsoft.Net.Http.Headers.CacheControlHeaderValue.NoTransformString -> string!\nstatic readonly Microsoft.Net.Http.Headers.CacheControlHeaderValue.OnlyIfCachedString -> string!\nstatic readonly Microsoft.Net.Http.Headers.CacheControlHeaderValue.PrivateString -> string!\nstatic readonly Microsoft.Net.Http.Headers.CacheControlHeaderValue.ProxyRevalidateString -> string!\nstatic readonly Microsoft.Net.Http.Headers.CacheControlHeaderValue.PublicString -> string!\nstatic readonly Microsoft.Net.Http.Headers.CacheControlHeaderValue.SharedMaxAgeString -> string!\n```\n\n----------------------------------------\n\nTITLE: Installing Azure App Services Logging Package\nDESCRIPTION: Command to install the Microsoft.Extensions.Logging.AzureAppServices NuGet package using the .NET CLI.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Logging.AzureAppServices/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.Extensions.Logging.AzureAppServices\n```\n\n----------------------------------------\n\nTITLE: BaseConnectionContext Virtual Methods in C#\nDESCRIPTION: This snippet contains virtual methods for the BaseConnectionContext class, including getters and setters for ConnectionClosed, LocalEndPoint, and RemoteEndPoint properties, as well as a DisposeAsync method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.ConnectionClosed.get -> System.Threading.CancellationToken\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.ConnectionClosed.set -> void\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.DisposeAsync() -> System.Threading.Tasks.ValueTask\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.LocalEndPoint.get -> System.Net.EndPoint?\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.LocalEndPoint.set -> void\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.RemoteEndPoint.get -> System.Net.EndPoint?\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.RemoteEndPoint.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining ShouldMatch Method Signature in NavLink Class for ASP.NET Core Components Routing\nDESCRIPTION: Method signature for the virtual ShouldMatch method in the NavLink class that takes an absolute URI as a parameter and returns a boolean value. The method is marked as nullable enabled and requires a non-null URI parameter.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\nvirtual Microsoft.AspNetCore.Components.Routing.NavLink.ShouldMatch(string! uriAbsolute) -> bool\n```\n\n----------------------------------------\n\nTITLE: Implementing CorsService Methods in C#\nDESCRIPTION: Defines virtual methods for the CorsService class to apply CORS results and evaluate preflight and regular CORS requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Cors.Infrastructure.CorsService.ApplyResult(Microsoft.AspNetCore.Cors.Infrastructure.CorsResult! result, Microsoft.AspNetCore.Http.HttpResponse! response) -> void\nvirtual Microsoft.AspNetCore.Cors.Infrastructure.CorsService.EvaluatePreflightRequest(Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Cors.Infrastructure.CorsPolicy! policy, Microsoft.AspNetCore.Cors.Infrastructure.CorsResult! result) -> void\nvirtual Microsoft.AspNetCore.Cors.Infrastructure.CorsService.EvaluateRequest(Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Cors.Infrastructure.CorsPolicy! policy, Microsoft.AspNetCore.Cors.Infrastructure.CorsResult! result) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing CustomValidator Class for ASP.NET Core Validation in C#\nDESCRIPTION: This class implements IPropertyValidator to provide custom validation functionality. It contains methods for both synchronous and asynchronous validation, along with support for configurable error messages and validation contexts.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Authorization/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing CustomValidator Class for ASP.NET Core Validation in C#\nDESCRIPTION: This class implements IPropertyValidator to provide custom validation functionality. It contains methods for both synchronous and asynchronous validation, along with support for configurable error messages and validation contexts.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Authorization/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining EndpointDataSource Class in C# for ASP.NET Core\nDESCRIPTION: This code snippet defines an abstract class EndpointDataSource which is used to create and manage endpoints in ASP.NET Core applications. It includes methods for getting endpoints and change tokens.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Facebook/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n\npublic abstract class EndpointDataSource\n{\n    public abstract IReadOnlyList<Endpoint> Endpoints { get; }\n\n    public abstract IChangeToken GetChangeToken();\n\n    public virtual IReadOnlyList<Endpoint> GetGroupedEndpoints(RouteGroupContext context)\n    {\n        return Endpoints;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SqlServerCache Class in C#\nDESCRIPTION: Declares the SqlServerCache class with methods for getting, setting, removing, and refreshing cache entries. It implements distributed caching functionality using SQL Server as the backend.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/SqlServer/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCache\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCache.Get(string! key) -> byte[]?\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCache.GetAsync(string! key, System.Threading.CancellationToken token = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<byte[]?>!\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCache.Refresh(string! key) -> void\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCache.RefreshAsync(string! key, System.Threading.CancellationToken token = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCache.Remove(string! key) -> void\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCache.RemoveAsync(string! key, System.Threading.CancellationToken token = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCache.Set(string! key, byte[]! value, Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions! options) -> void\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCache.SetAsync(string! key, byte[]! value, Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions! options, System.Threading.CancellationToken token = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCache.SqlServerCache(Microsoft.Extensions.Options.IOptions<Microsoft.Extensions.Caching.SqlServer.SqlServerCacheOptions!>! options) -> void\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation via .NET CLI\nDESCRIPTION: Command to install the Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation package using the .NET CLI. This package enables runtime compilation of Razor views in ASP.NET Core MVC applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Razor.RuntimeCompilation/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation\n```\n\n----------------------------------------\n\nTITLE: Running Tests for HttpSys Project in PowerShell\nDESCRIPTION: This command runs the tests for the HttpSys project. It should be executed inside the project directory.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/HttpSys/README.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd -t\n```\n\n----------------------------------------\n\nTITLE: Adding Project Reference to Secondary DotNetProjects List in Build.props\nDESCRIPTION: XML snippet showing the format for adding a new project directory to the secondary DotNetProjects list in eng/Build.props. This list is used when BuildMainlyReferenceProviders is set to true, and specifically targets projects in src subdirectories.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/AddingNewProjects.md#2025-04-08_snippet_2\n\nLANGUAGE: XML\nCODE:\n```\n<DotNetProjects Include=\"\n                    $(RepoRoot)src\\[YOUR FOLDER]\\**\\src\\*.csproj;\n                    ...\n```\n\n----------------------------------------\n\nTITLE: Implementing WriteJsonResponseAsync Method in C#\nDESCRIPTION: Implements a WriteJsonResponseAsync method for serializing and writing JSON responses in ASP.NET Core. It includes suppression of certain warnings related to trimming and AOT compilation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsTodo_Has_Metadata.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n```\n\n----------------------------------------\n\nTITLE: Updating Trim Warning Baselines with Shell Command\nDESCRIPTION: Command to generate and update trimmer warning suppressions for ASP.NET Core projects. Updates WarningSuppressions.xml files.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Trimming.md#2025-04-08_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndotnet build /p:GenerateLinkerWarningSuppressions=true\n```\n\n----------------------------------------\n\nTITLE: Retrieving HTTP Context from SignalR Connections\nDESCRIPTION: Extension methods for retrieving the HttpContext from SignalR hub connections. These methods allow access to the underlying HTTP context of a SignalR connection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/SignalR/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.GetHttpContextExtensions.GetHttpContext(this Microsoft.AspNetCore.SignalR.HubCallerContext! connection) -> Microsoft.AspNetCore.Http.HttpContext?\nstatic Microsoft.AspNetCore.SignalR.GetHttpContextExtensions.GetHttpContext(this Microsoft.AspNetCore.SignalR.HubConnectionContext! connection) -> Microsoft.AspNetCore.Http.HttpContext?\n```\n\n----------------------------------------\n\nTITLE: Getting or Creating OpenAPI Schema in Document Transformer Context\nDESCRIPTION: Method in OpenApiDocumentTransformerContext to asynchronously retrieve or create an OpenAPI schema for a given type. Optionally accepts parameter description and cancellation token.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.OpenApi.OpenApiDocumentTransformerContext.GetOrCreateSchemaAsync(System.Type! type, Microsoft.AspNetCore.Mvc.ApiExplorer.ApiParameterDescription? parameterDescription = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<Microsoft.OpenApi.Models.OpenApiSchema!>!\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Authorization Service in C#\nDESCRIPTION: Constructor for the DefaultAuthorizationService class that handles authorization evaluation using provided policy providers, handlers and options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.DefaultAuthorizationService.DefaultAuthorizationService(Microsoft.AspNetCore.Authorization.IAuthorizationPolicyProvider! policyProvider, Microsoft.AspNetCore.Authorization.IAuthorizationHandlerProvider! handlers, Microsoft.Extensions.Logging.ILogger<Microsoft.AspNetCore.Authorization.DefaultAuthorizationService!>! logger, Microsoft.AspNetCore.Authorization.IAuthorizationHandlerContextFactory! contextFactory, Microsoft.AspNetCore.Authorization.IAuthorizationEvaluator! evaluator, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Authorization.AuthorizationOptions!>! options) -> void\n```\n\n----------------------------------------\n\nTITLE: Getting or Creating OpenAPI Schema in Operation Transformer Context\nDESCRIPTION: Method in OpenApiOperationTransformerContext to asynchronously retrieve or create an OpenAPI schema for a given type. Optionally accepts parameter description and cancellation token.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.OpenApi.OpenApiOperationTransformerContext.GetOrCreateSchemaAsync(System.Type! type, Microsoft.AspNetCore.Mvc.ApiExplorer.ApiParameterDescription? parameterDescription = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<Microsoft.OpenApi.Models.OpenApiSchema!>!\n```\n\n----------------------------------------\n\nTITLE: Writing JSON Response in ASP.NET Core\nDESCRIPTION: This method writes a JSON response using the provided JsonTypeInfo. It handles polymorphic types and uses the appropriate serialization method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RedisCacheOptions Class for ASP.NET Core\nDESCRIPTION: Defines the RedisCacheOptions class for configuring StackExchange Redis cache in ASP.NET Core. It includes properties for setting the Redis connection string, configuration options, instance name, and profiling session.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.Configuration.get -> string?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.Configuration.set -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ConfigurationOptions.get -> StackExchange.Redis.ConfigurationOptions?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ConfigurationOptions.set -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ConnectionMultiplexerFactory.get -> System.Func<System.Threading.Tasks.Task<StackExchange.Redis.IConnectionMultiplexer!>!>?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ConnectionMultiplexerFactory.set -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.InstanceName.get -> string?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.InstanceName.set -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ProfilingSession.get -> System.Func<StackExchange.Redis.Profiling.ProfilingSession!>?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ProfilingSession.set -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.RedisCacheOptions() -> void\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in System.Runtime.CompilerServices Namespace\nDESCRIPTION: Defines a file-sealed InterceptsLocationAttribute class used for method interception. This attribute is used to mark methods that intercept method calls at specific locations and can be applied multiple times.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HttpRequestIdentifierFeature in ASP.NET Core\nDESCRIPTION: Feature providing unique identifiers for HTTP requests in ASP.NET Core. It manages the trace identifier used for request correlation and logging throughout the request processing pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Features.HttpRequestIdentifierFeature\nMicrosoft.AspNetCore.Http.Features.HttpRequestIdentifierFeature.HttpRequestIdentifierFeature() -> void\nMicrosoft.AspNetCore.Http.Features.HttpRequestIdentifierFeature.TraceIdentifier.get -> string!\nMicrosoft.AspNetCore.Http.Features.HttpRequestIdentifierFeature.TraceIdentifier.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining GeneratedRouteBuilderExtensionsCore in Microsoft.AspNetCore.Http.Generated\nDESCRIPTION: A static class containing methods and helper fields for building route handlers in ASP.NET Core. It includes predefined HTTP verb arrays and internal mapping methods for handling HTTP requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nfile static class GeneratedRouteBuilderExtensionsCore\n    {\n        private static readonly JsonOptions FallbackJsonOptions = new();\n        private static readonly string[] GetVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Get };\n        private static readonly string[] PatchVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Patch };\n        private static readonly string[] PostVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Post };\n        private static readonly string[] PutVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Put };\n```\n\n----------------------------------------\n\nTITLE: HubProtocolConstants in ASP.NET Core SignalR\nDESCRIPTION: Constants defining message type identifiers used in the SignalR protocol. These integer values identify different types of messages exchanged between clients and servers in a SignalR connection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.AckMessageType = 8 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.CancelInvocationMessageType = 5 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.CloseMessageType = 7 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.CompletionMessageType = 3 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.InvocationMessageType = 1 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.PingMessageType = 6 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.SequenceMessageType = 9 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.StreamInvocationMessageType = 4 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.StreamItemMessageType = 2 -> int\n```\n\n----------------------------------------\n\nTITLE: Defining Content Type Constants for Request Binding in ASP.NET Core\nDESCRIPTION: Provides predefined content type arrays for common media types used in request binding. These constants are used throughout the framework for content negotiation and validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Required Parameter Logger in ASP.NET Core\nDESCRIPTION: Defines a structured logger action for missing required parameters using LoggerMessage.Define. This creates an optimized logging delegate that captures parameter type, name, and source information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n    LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n```\n\n----------------------------------------\n\nTITLE: SignalR Protocol Static Property Declarations in C#\nDESCRIPTION: Static readonly property declarations for common message instances in the SignalR protocol, including Empty CloseMessage, Empty HandshakeResponseMessage, and the PingMessage Instance.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.SignalR.Protocol.CloseMessage.Empty -> Microsoft.AspNetCore.SignalR.Protocol.CloseMessage!\nstatic readonly Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage.Empty -> Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage!\nstatic readonly Microsoft.AspNetCore.SignalR.Protocol.PingMessage.Instance -> Microsoft.AspNetCore.SignalR.Protocol.PingMessage!\n```\n\n----------------------------------------\n\nTITLE: Convention and Provider Interfaces in ASP.NET Core MVC\nDESCRIPTION: Interfaces for defining conventions that modify the MVC application model. Includes conventions for actions, controllers, parameters, and the overall application model.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IActionModelConvention\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IActionModelConvention.Apply(Microsoft.AspNetCore.Mvc.ApplicationModels.ActionModel! action) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IApiExplorerModel\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IApiExplorerModel.ApiExplorer.get -> Microsoft.AspNetCore.Mvc.ApplicationModels.ApiExplorerModel!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IApiExplorerModel.ApiExplorer.set -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IApplicationModelConvention\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IApplicationModelConvention.Apply(Microsoft.AspNetCore.Mvc.ApplicationModels.ApplicationModel! application) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IApplicationModelProvider\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IApplicationModelProvider.OnProvidersExecuted(Microsoft.AspNetCore.Mvc.ApplicationModels.ApplicationModelProviderContext! context) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IApplicationModelProvider.OnProvidersExecuting(Microsoft.AspNetCore.Mvc.ApplicationModels.ApplicationModelProviderContext! context) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IApplicationModelProvider.Order.get -> int\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IBindingModel\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IBindingModel.BindingInfo.get -> Microsoft.AspNetCore.Mvc.ModelBinding.BindingInfo?\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IBindingModel.BindingInfo.set -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ICommonModel\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ICommonModel.Attributes.get -> System.Collections.Generic.IReadOnlyList<object!>!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ICommonModel.MemberInfo.get -> System.Reflection.MemberInfo!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ICommonModel.Name.get -> string!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IControllerModelConvention\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IControllerModelConvention.Apply(Microsoft.AspNetCore.Mvc.ApplicationModels.ControllerModel! controller) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IFilterModel\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IFilterModel.Filters.get -> System.Collections.Generic.IList<Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata!>!\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IParameterModelBaseConvention\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IParameterModelBaseConvention.Apply(Microsoft.AspNetCore.Mvc.ApplicationModels.ParameterModelBase! parameter) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IParameterModelConvention\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IParameterModelConvention.Apply(Microsoft.AspNetCore.Mvc.ApplicationModels.ParameterModel! parameter) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IPropertyModel\nMicrosoft.AspNetCore.Mvc.ApplicationModels.IPropertyModel.Properties.get -> System.Collections.Generic.IDictionary<object!, object?>!\n```\n\n----------------------------------------\n\nTITLE: Vehicle Update Form with Validation\nDESCRIPTION: HTML form for updating vehicle details with built-in ASP.NET Core validation. Contains fields for VIN number (max 8 characters) and vehicle year (between 1980-2034). Includes data validation attributes and error message display.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/test/Mvc.FunctionalTests/compiler/resources/UpdateDealerVehicle_PopulatesPropertyErrorsInViews.txt#2025-04-08_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n<div>\n    <span class=\"bold\">TestCarDealer</span>\n    <em>SE</em>\n    <input data-val=\"true\" data-val-required=\"The Id field is required.\" id=\"Dealer_Id\" name=\"Dealer.Id\" type=\"hidden\" value=\"32\" />\n</div>\n<div class=\"validation-summary-errors\"><ul><li style=\"display:none\"></li>\n</ul></div>\n<form action=\"/dealers/32/update-vehicle?dealer.name=TestCarDealer&amp;dealer.location=SE\" method=\"post\">    <fieldset>\n        <input class=\"input-validation-error\" data-val=\"true\" data-val-length=\"The field Vin must be a string with a maximum length of 8.\" data-val-length-max=\"8\" data-val-required=\"The Vin field is required.\" id=\"Vehicle_Vin\" name=\"Vehicle.Vin\" type=\"text\" value=\"LongerThan8Chars\" />\n        <span class=\"field-validation-error\" data-valmsg-for=\"Vehicle.Vin\" data-valmsg-replace=\"true\">The field Vin must be a string with a maximum length of 8.</span>\n    </fieldset>\n    <fieldset>\n        <input class=\"input-validation-error text-box single-line\" data-val=\"true\" data-val-range=\"The field Year must be between 1980 and 2034.\" data-val-range-max=\"2034\" data-val-range-min=\"1980\" data-val-required=\"The Year field is required.\" id=\"Vehicle_Year\" name=\"Vehicle.Year\" type=\"number\" value=\"9001\" />\n        <span class=\"field-validation-error\" data-valmsg-for=\"Vehicle.Year\" data-valmsg-replace=\"true\">The field Year must be between 1980 and 2034.</span>\n    </fieldset>\n</form>\n```\n\n----------------------------------------\n\nTITLE: Declaring PanicExtensions Class in ASP.NET Core Diagnostics Namespace\nDESCRIPTION: Defines a static class named PanicExtensions within the Microsoft.AspNetCore.Diagnostics namespace with nullable enabled. This class serves as a container for extension methods related to application panic handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/Http.Connections/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Running SignalR Tests in Easy Mode\nDESCRIPTION: Steps to run JavaScript functional tests from the command line in easy mode. This involves restoring dependencies and using npm test.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/JSFunctionalTests.md#2025-04-08_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./build /t:Restore\n```\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh /t:Restore\n```\n\nLANGUAGE: bash\nCODE:\n```\ncd clients/ts/FunctionalTests\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm test\n```\n\n----------------------------------------\n\nTITLE: Static Asset Descriptors Resolution Method\nDESCRIPTION: Method to resolve static asset descriptors from a manifest path using the endpoint route builder.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/StaticAssets/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.StaticAssets.Infrastructure.StaticAssetsEndpointDataSourceHelper.ResolveStaticAssetDescriptors(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder! endpointRouteBuilder, string? manifestPath) -> System.Collections.Generic.IReadOnlyList<Microsoft.AspNetCore.StaticAssets.StaticAssetDescriptor!>!\n```\n\n----------------------------------------\n\nTITLE: Initializing WebApplication in ASP.NET Core\nDESCRIPTION: This code snippet demonstrates how to create and configure a WebApplication instance in ASP.NET Core. It includes setting up the web host, configuring services, and handling the application's request pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/CustomElements/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddRazorPages();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline.\nif (!app.Environment.IsDevelopment())\n{\n    app.UseExceptionHandler(\"/Error\");\n    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.\n    app.UseHsts();\n}\n\napp.UseHttpsRedirection();\napp.UseStaticFiles();\n\napp.UseRouting();\n\napp.UseAuthorization();\n\napp.MapRazorPages();\n\napp.Run();\n```\n\n----------------------------------------\n\nTITLE: Retrieving Endpoint Route Builder in C#\nDESCRIPTION: Helper method to get the IEndpointRouteBuilder from a RazorComponentsEndpointConventionBuilder.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Endpoints/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.Endpoints.Infrastructure.ComponentEndpointConventionBuilderHelper.GetEndpointRouteBuilder(Microsoft.AspNetCore.Builder.RazorComponentsEndpointConventionBuilder! builder) -> Microsoft.AspNetCore.Routing.IEndpointRouteBuilder!\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results Table for DrainRefillMulti Operation in ASP.NET Core\nDESCRIPTION: A markdown table showing performance benchmarks for the DrainRefillMulti operation with a buffer size of 2048 and varying concurrency levels (1-8) under different scheduling modes (Default and Scaled). The metrics include mean execution time in nanoseconds and memory allocation in bytes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/ObjectPool/perf/Microbenchmarks/README.md#2025-04-08_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| DrainRefillMulti |  2048 |           1 |  Scaled |    947,932.682 ns |    59,063.8970 ns |  3,237.4915 ns |       1 B |\n| DrainRefillMulti |  2048 |           2 | Default |  1,375,669.466 ns | 1,389,879.8763 ns | 76,184.0060 ns |       1 B |\n| DrainRefillMulti |  2048 |           2 |  Scaled |    614,905.078 ns |   207,382.6684 ns | 11,367.3438 ns |       1 B |\n| DrainRefillMulti |  2048 |           4 | Default |    738,090.462 ns | 1,812,923.2145 ns | 99,372.4388 ns |       1 B |\n| DrainRefillMulti |  2048 |           4 |  Scaled |    321,501.628 ns |    60,639.0375 ns |  3,323.8303 ns |         - |\n| DrainRefillMulti |  2048 |           8 | Default |    214,069.694 ns |   116,308.1865 ns |  6,375.2442 ns |         - |\n| DrainRefillMulti |  2048 |           8 |  Scaled |    175,667.798 ns |    15,600.4542 ns |    855.1135 ns |         - |\n```\n\n----------------------------------------\n\nTITLE: Running All ASP.NET Core Benchmarks\nDESCRIPTION: Command to run all available benchmarks using the wildcard (*) parameter. Requires Release configuration and target framework specification.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/perf/Microbenchmarks/readme.md#2025-04-08_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ndotnet run -c Release --framework <tfm> *\n```\n\n----------------------------------------\n\nTITLE: Determining JSON Type Compatibility in ASP.NET Core\nDESCRIPTION: Checks if provided JsonTypeInfo can be used with a given runtime type. Helps optimize JSON serialization by avoiding unnecessary type conversion when possible.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\n----------------------------------------\n\nTITLE: Mapping GET Request with Multiple Parameters in ASP.NET Core\nDESCRIPTION: This method maps a GET request to a handler that accepts multiple parameters, including an HttpContext and a custom BindAsync parameter. It demonstrates metadata population, parameter binding, and support for different response types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet4(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"httpContext\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"myBindAsyncParam\", parameters[1], hasTryParse: false, hasBindAsync: true, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n    };\n    // ... (implementation details)\n}\n```\n\n----------------------------------------\n\nTITLE: IWebTransportSession Interface Definition in C#\nDESCRIPTION: Defines the interface for WebTransport sessions in ASP.NET Core, providing methods for stream handling and session management. Includes functionality for accepting streams, opening unidirectional streams, and managing session state.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Features/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Features.IWebTransportSession\nMicrosoft.AspNetCore.Http.Features.IWebTransportSession.Abort(int errorCode) -> void\nMicrosoft.AspNetCore.Http.Features.IWebTransportSession.AcceptStreamAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Connections.ConnectionContext?>\nMicrosoft.AspNetCore.Http.Features.IWebTransportSession.OpenUnidirectionalStreamAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Connections.ConnectionContext?>\nMicrosoft.AspNetCore.Http.Features.IWebTransportSession.SessionId.get -> long\n```\n\n----------------------------------------\n\nTITLE: Defining Form Content Type Logger in ASP.NET Core\nDESCRIPTION: Defines a structured logger action for unsupported form content types using LoggerMessage.Define. This creates an optimized logging delegate that captures the actual content type provided.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Registering Persistent Service for Razor Components in C#\nDESCRIPTION: This method extends IRazorComponentsBuilder to register a persistent service with a specified render mode. It's generic, allowing for different types of persistent services to be registered.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Endpoints/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.RazorComponentsRazorComponentBuilderExtensions.RegisterPersistentService<TPersistentService>(this Microsoft.Extensions.DependencyInjection.IRazorComponentsBuilder! builder, Microsoft.AspNetCore.Components.IComponentRenderMode! renderMode) -> Microsoft.Extensions.DependencyInjection.IRazorComponentsBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining IHttpContextFeature Interface in C#\nDESCRIPTION: Defines the IHttpContextFeature interface with a property for accessing the HttpContext.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/Http.Connections/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Connections.Features.IHttpContextFeature\nMicrosoft.AspNetCore.Http.Connections.Features.IHttpContextFeature.HttpContext.get -> Microsoft.AspNetCore.Http.HttpContext?\nMicrosoft.AspNetCore.Http.Connections.Features.IHttpContextFeature.HttpContext.set -> void\n```\n\n----------------------------------------\n\nTITLE: Azure Blob Logger Context API\nDESCRIPTION: Defines the structure and properties for Azure Blob logging context including app name, identifier and timestamp information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Logging.AzureAppServices/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n~Microsoft.Extensions.Logging.AzureAppServices.AzureBlobLoggerContext.AppName.get -> string\n~Microsoft.Extensions.Logging.AzureAppServices.AzureBlobLoggerContext.AzureBlobLoggerContext(string appName, string identifier, System.DateTimeOffset timestamp) -> void\n~Microsoft.Extensions.Logging.AzureAppServices.AzureBlobLoggerContext.Identifier.get -> string\n```\n\n----------------------------------------\n\nTITLE: Extending IServiceCollection for WebEncoder configuration in C#\nDESCRIPTION: Defines extension methods for IServiceCollection to add and configure web encoders in the dependency injection container.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/WebEncoders/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.EncoderServiceCollectionExtensions.AddWebEncoders(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.EncoderServiceCollectionExtensions.AddWebEncoders(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.Extensions.WebEncoders.WebEncoderOptions!>! setupAction) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Adding Interactive Server Components to Razor Components in ASP.NET Core\nDESCRIPTION: Extension method for IRazorComponentsBuilder that adds interactive server component services. Enables server-side interactivity for Razor components with optional CircuitOptions configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.ServerRazorComponentsBuilderExtensions.AddInteractiveServerComponents(this Microsoft.Extensions.DependencyInjection.IRazorComponentsBuilder! builder, System.Action<Microsoft.AspNetCore.Components.Server.CircuitOptions!>? configure = null) -> Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder!\n```\n\n----------------------------------------\n\nTITLE: Request Delegate Factory Function for ASP.NET Core\nDESCRIPTION: Creates a request delegate factory function that sets up JSON options, builds filter delegates, and configures request handlers. It includes support for dependency injection, service provider resolution, and proper exception handling through helper services.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\nRequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n{\n    Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n    Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n    Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n    Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n    var handler = Cast(del, global::System.String (global::Microsoft.AspNetCore.Http.HttpContext arg0, global::Microsoft.AspNetCore.Http.Generators.Tests.MyBindAsyncFromInterfaceRecord? arg1) => throw null!);\n    EndpointFilterDelegate? filteredInvocation = null;\n    var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n    var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n    var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n    var jsonSerializerOptions = jsonOptions.SerializerOptions;\n    jsonSerializerOptions.MakeReadOnly();\n    var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n```\n\n----------------------------------------\n\nTITLE: Defining RequestLocalizationServiceCollectionExtensions Class in C#\nDESCRIPTION: Defines extension methods for adding request localization services to the dependency injection container.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.DependencyInjection.RequestLocalizationServiceCollectionExtensions\n```\n\n----------------------------------------\n\nTITLE: Executing Return Values in ASP.NET Core Endpoints\nDESCRIPTION: Handles different types of endpoint return values by executing IResult objects, writing strings directly, or serializing objects to JSON. This is the core response handling mechanism for minimal APIs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Filtered Request Handling with Header Parameters in ASP.NET Core\nDESCRIPTION: Implements an asynchronous request handler with endpoint filtering that extracts a header parameter, validates it, and processes the request through a filter pipeline before writing the response.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitSource_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nasync Task RequestHandlerFiltered(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    // Endpoint Parameter: headerValue (Type = string, IsOptional = False, IsParsable = False, IsArray = False, Source = Header)\n    var headerValue_raw = httpContext.Request.Headers[\"headerValue\"];\n    if (StringValues.IsNullOrEmpty(headerValue_raw))\n    {\n        wasParamCheckFailure = true;\n        logOrThrowExceptionHelper.RequiredParameterNotProvided(\"string\", \"headerValue\", \"header\");\n    }\n    var headerValue_temp = (string?)headerValue_raw;\n    string headerValue_local = headerValue_temp!;\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n    }\n    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::System.String>(httpContext, headerValue_local));\n    if (result is not null)\n    {\n        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ISignalRBuilder Interface\nDESCRIPTION: SignalR builder interface that provides access to the dependency injection service collection. Used during application startup to configure SignalR services.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.ISignalRBuilder\nMicrosoft.AspNetCore.SignalR.ISignalRBuilder.Services.get -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Defining CookieOptions Class in ASP.NET Core\nDESCRIPTION: This code snippet defines the CookieOptions class in the Microsoft.AspNetCore.Http namespace. It includes properties for various cookie attributes such as domain, expiration, security settings, and methods for creating cookie headers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Features/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.CookieOptions\nMicrosoft.AspNetCore.Http.CookieOptions.CookieOptions() -> void\nMicrosoft.AspNetCore.Http.CookieOptions.CookieOptions(Microsoft.AspNetCore.Http.CookieOptions! options) -> void\nMicrosoft.AspNetCore.Http.CookieOptions.CreateCookieHeader(string! name, string! value) -> Microsoft.Net.Http.Headers.SetCookieHeaderValue!\nMicrosoft.AspNetCore.Http.CookieOptions.Domain.get -> string?\nMicrosoft.AspNetCore.Http.CookieOptions.Domain.set -> void\nMicrosoft.AspNetCore.Http.CookieOptions.Expires.get -> System.DateTimeOffset?\nMicrosoft.AspNetCore.Http.CookieOptions.Expires.set -> void\nMicrosoft.AspNetCore.Http.CookieOptions.HttpOnly.get -> bool\nMicrosoft.AspNetCore.Http.CookieOptions.HttpOnly.set -> void\nMicrosoft.AspNetCore.Http.CookieOptions.IsEssential.get -> bool\nMicrosoft.AspNetCore.Http.CookieOptions.IsEssential.set -> void\nMicrosoft.AspNetCore.Http.CookieOptions.MaxAge.get -> System.TimeSpan?\nMicrosoft.AspNetCore.Http.CookieOptions.MaxAge.set -> void\nMicrosoft.AspNetCore.Http.CookieOptions.Path.get -> string?\nMicrosoft.AspNetCore.Http.CookieOptions.Path.set -> void\nMicrosoft.AspNetCore.Http.CookieOptions.Secure.get -> bool\nMicrosoft.AspNetCore.Http.CookieOptions.Secure.set -> void\nMicrosoft.AspNetCore.Http.CookieOptions.SameSite.get -> Microsoft.AspNetCore.Http.SameSiteMode\nMicrosoft.AspNetCore.Http.CookieOptions.SameSite.set -> void\n```\n\n----------------------------------------\n\nTITLE: Email Sender Interface Definition\nDESCRIPTION: Interface definition for sending emails in ASP.NET Core Identity, including methods for confirmation links and password reset codes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.IEmailSender<TUser>.SendConfirmationLinkAsync(TUser! user, string! email, string! confirmationLink) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Identity.IEmailSender<TUser>.SendPasswordResetLinkAsync(TUser! user, string! email, string! resetLink) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining StructuredLoggingOptions Class in C# with Nullable Reference Types\nDESCRIPTION: This code defines a configuration class for structured logging options in ASP.NET Core. It includes properties for controlling W3C trace context propagation and customizing logging templates with their default values.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/JSInterop/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing Complex Event Pattern in C#\nDESCRIPTION: Demonstrates the complete pattern for implementing an event with complex payload calculations and counter integration. Shows separation of event calculation and declaration methods, with proper checks for enabled states.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/EventSourceAndCounters.md#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[NonEvent]\npublic void SomethingHappened(ObjectNeededToCalculateThePayload p, AnotherObjectNeededToCalculateThePayload p2)\n{\n  if (IsEnabled())\n  {\n    _somethingsHappenedCounter.WriteMetric(1.0f);\n    if (IsEnabled(EventLevel.Informational, EventKeywords.None))\n    {\n      var payloadValue = CalculateThePayload(p);\n      SomethingHappened(payloadValue, p2.MorePayload, p2.SomeValue - p2.SomeOtherValue);\n    }\n  }\n}\n\n[Event(eventId: 42, Level = EventLevel.Informational)]\nprivate void SomethingHappened(string payloadValue, int anotherPayloadValue, double morePayload) => WriteEvent(42, payloadValue, anotherPayloadValue, morePayload);\n```\n\n----------------------------------------\n\nTITLE: Metadata Population for ASP.NET Core Endpoint in Request Delegation\nDESCRIPTION: Populates endpoint metadata for request delegation, including parameter binding information, response type metadata, and generated code attribution. This metadata is used during request processing to correctly bind parameters and interpret responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\nMetadataPopulator populateMetadata = (methodInfo, options) =>\n{\n    Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n    Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n    options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n    var parameters = methodInfo.GetParameters();\n    options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"httpContext\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n    options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"myBindAsyncParam\", parameters[1], hasTryParse: false, hasBindAsync: true, isOptional: false));\n    options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n    return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n};\n```\n\n----------------------------------------\n\nTITLE: Building Endpoint Filter Chain in ASP.NET Core\nDESCRIPTION: Constructs a filter pipeline for endpoint execution by applying filters in reverse order. Creates an endpoint filter context with method information and application services for each filter.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncDisposableStream wrapper class in C#\nDESCRIPTION: A class that wraps a Stream and implements IAsyncDisposable to ensure proper asynchronous disposal. It delegates all stream operations to the underlying stream while adding asynchronous disposal functionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/Server/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining Authorization Interfaces in C#\nDESCRIPTION: Declares interfaces for various components of the authorization system, including evaluators, handlers, policy providers, and requirements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.IAuthorizationEvaluator\nMicrosoft.AspNetCore.Authorization.IAuthorizationHandler\nMicrosoft.AspNetCore.Authorization.IAuthorizationHandlerContextFactory\nMicrosoft.AspNetCore.Authorization.IAuthorizationHandlerProvider\nMicrosoft.AspNetCore.Authorization.IAuthorizationPolicyProvider\nMicrosoft.AspNetCore.Authorization.IAuthorizationRequirement\nMicrosoft.AspNetCore.Authorization.IAuthorizationRequirementData\nMicrosoft.AspNetCore.Authorization.IAuthorizationService\n```\n\n----------------------------------------\n\nTITLE: Mapping Routes with Core Implementation in ASP.NET Core\nDESCRIPTION: Internal method for mapping routes in ASP.NET Core's minimal API. It takes a route pattern, handler delegate, HTTP methods, and other parameters to create a route handler.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Page Handler Selected Context in ASP.NET Core Razor Pages\nDESCRIPTION: Virtual properties for PageHandlerSelectedContext that provide access to action descriptor, handler instance, and handler method. This context is used when a page handler has been selected but not yet executed, allowing for filter intervention.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.Filters.PageHandlerSelectedContext.ActionDescriptor.get -> Microsoft.AspNetCore.Mvc.RazorPages.CompiledPageActionDescriptor!\nvirtual Microsoft.AspNetCore.Mvc.Filters.PageHandlerSelectedContext.HandlerInstance.get -> object!\nvirtual Microsoft.AspNetCore.Mvc.Filters.PageHandlerSelectedContext.HandlerMethod.get -> Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.HandlerMethodDescriptor?\nvirtual Microsoft.AspNetCore.Mvc.Filters.PageHandlerSelectedContext.HandlerMethod.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining HttpTransports Static Class in C#\nDESCRIPTION: A static class providing access to transport type constants, including a constant for all available HTTP transport types combined.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/Http.Connections.Common/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Connections.HttpTransports\nstatic readonly Microsoft.AspNetCore.Http.Connections.HttpTransports.All -> Microsoft.AspNetCore.Http.Connections.HttpTransportType\n```\n\n----------------------------------------\n\nTITLE: Defining SpaStaticFilesOptions Class in C#\nDESCRIPTION: Defines the SpaStaticFilesOptions class for configuring static file serving options for SPAs in ASP.NET Core. Includes a property for specifying the root path of static files.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Spa/SpaServices.Extensions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SpaServices.StaticFiles.SpaStaticFilesOptions\nMicrosoft.AspNetCore.SpaServices.StaticFiles.SpaStaticFilesOptions.SpaStaticFilesOptions() -> void\nMicrosoft.AspNetCore.SpaServices.StaticFiles.SpaStaticFilesOptions.RootPath.get -> string!\nMicrosoft.AspNetCore.SpaServices.StaticFiles.SpaStaticFilesOptions.RootPath.set -> void\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core Route Template API Example\nDESCRIPTION: Sample route template class members showing the structure of route templates, segments and parts in ASP.NET Core routing. This illustrates the object model used to represent URL patterns.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class RouteTemplate {\n    public IList<TemplateSegment> Segments { get; }\n    public IList<TemplatePart> Parameters { get; }\n    public string TemplateText { get; }\n    \n    public RouteTemplate(string template, List<TemplateSegment> segments);\n    public TemplatePart GetParameter(string name);\n    public TemplateSegment GetSegment(int index);\n    public RoutePattern ToRoutePattern();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Json Result Methods in C#\nDESCRIPTION: These methods create JSON results with various serialization options and status codes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.Json<TValue>(TValue? data, System.Text.Json.JsonSerializerOptions? options = null, string? contentType = null, int? statusCode = null) -> Microsoft.AspNetCore.Http.HttpResults.JsonHttpResult<TValue>!\nstatic Microsoft.AspNetCore.Http.TypedResults.Json<TValue>(TValue? data, System.Text.Json.Serialization.JsonSerializerContext! context, string? contentType = null, int? statusCode = null) -> Microsoft.AspNetCore.Http.HttpResults.JsonHttpResult<TValue>!\nstatic Microsoft.AspNetCore.Http.TypedResults.Json<TValue>(TValue? data, System.Text.Json.Serialization.Metadata.JsonTypeInfo<TValue>! jsonTypeInfo, string? contentType = null, int? statusCode = null) -> Microsoft.AspNetCore.Http.HttpResults.JsonHttpResult<TValue>!\n```\n\n----------------------------------------\n\nTITLE: Installing JSON Patch Packages via .NET CLI\nDESCRIPTION: Commands to install the required NuGet packages for JSON Patch support in ASP.NET Core\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Features/JsonPatch/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.JsonPatch\ndotnet add package Microsoft.AspNetCore.Mvc.NewtonsoftJson\n```\n\n----------------------------------------\n\nTITLE: Adding Package Sources to BaselineGenerator Commands\nDESCRIPTION: Optional command parameter to specify custom package sources when packages are not hosted on NuGet.org.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/eng/tools/BaselineGenerator/README.md#2025-04-08_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n--package-sources {source}\n```\n\n----------------------------------------\n\nTITLE: Defining WsFederation Authentication Constants in C#\nDESCRIPTION: This snippet defines constant values for the WsFederation authentication scheme and display name. These constants are used throughout the WsFederation authentication implementation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/WsFederation/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.Authentication.WsFederation.WsFederationDefaults.AuthenticationScheme = \"WsFederation\" -> string!\nconst Microsoft.AspNetCore.Authentication.WsFederation.WsFederationDefaults.DisplayName = \"WsFederation\" -> string!\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in System.Runtime.CompilerServices\nDESCRIPTION: A compiler-generated attribute used for method interception, allowing multiple attributes per method. Takes version and data string parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_StringArrayParam.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: AuthorizationOptions Class Definition in C#\nDESCRIPTION: Definition of the AuthorizationOptions class that configures the behavior of the authorization system, including default policies and handling of authorization failures.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.AddPolicy(string! name, Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy) -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.AddPolicy(string! name, System.Action<Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!>! configurePolicy) -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.AuthorizationOptions() -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.DefaultPolicy.get -> Microsoft.AspNetCore.Authorization.AuthorizationPolicy!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.DefaultPolicy.set -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.FallbackPolicy.get -> Microsoft.AspNetCore.Authorization.AuthorizationPolicy?\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.FallbackPolicy.set -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.GetPolicy(string! name) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicy?\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.InvokeHandlersAfterFailure.get -> bool\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.InvokeHandlersAfterFailure.set -> void\n```\n\n----------------------------------------\n\nTITLE: Invalid Form Request Body Handler\nDESCRIPTION: Handles invalid form request body scenarios by throwing BadHttpRequestException or logging the error based on configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleComplexTypeParam_StringReturn.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MapCore Method for Endpoint Route Building in ASP.NET Core\nDESCRIPTION: Maps a request delegate to a specific route pattern with custom HTTP methods. This is a core method used by the routing system to register endpoints with the application's request pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: ResponseCacheAttribute Class Definition - C#\nDESCRIPTION: Attribute for configuring response caching behavior including duration, location, and vary-by options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ResponseCacheAttribute.ResponseCacheAttribute() -> void\nMicrosoft.AspNetCore.Mvc.ResponseCacheAttribute.Duration.get -> int\nMicrosoft.AspNetCore.Mvc.ResponseCacheAttribute.Location.get -> Microsoft.AspNetCore.Mvc.ResponseCacheLocation\n```\n\n----------------------------------------\n\nTITLE: Abstract Method for Getting Antiforgery Token in C#\nDESCRIPTION: Abstract method that retrieves an antiforgery token from a state provider. Returns an optional AntiforgeryRequestToken that can be used to validate form submissions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Components.Forms.AntiforgeryStateProvider.GetAntiforgeryToken() -> Microsoft.AspNetCore.Components.Forms.AntiforgeryRequestToken?\n```\n\n----------------------------------------\n\nTITLE: Policy Registry Service Collection Extensions\nDESCRIPTION: Extension methods for IServiceCollection to register and configure Polly policy registries in the dependency injection container.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HttpClientFactory/Polly/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.PollyServiceCollectionExtensions.AddPolicyRegistry(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Polly.Registry.IPolicyRegistry<string!>!\nstatic Microsoft.Extensions.DependencyInjection.PollyServiceCollectionExtensions.AddPolicyRegistry(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, Polly.Registry.IPolicyRegistry<string!>! registry) -> Polly.Registry.IPolicyRegistry<string!>!\n```\n\n----------------------------------------\n\nTITLE: Defining GlobalJavaScriptBundle Class in C#\nDESCRIPTION: Defines the GlobalJavaScriptBundle class which extends GlobalBundle for JavaScript file bundling. It provides constructors for creating JavaScript bundles with different parameters and implements tag helpers for script references.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/Cryptography.Internal/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Socket Connection Factory Class Definition\nDESCRIPTION: Class definition for SocketConnectionContextFactory with methods for creating and disposing connection contexts.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Transport.Sockets/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass SocketConnectionContextFactory {\n    public SocketConnectionContextFactory(SocketConnectionFactoryOptions options, ILogger logger);\n    public ConnectionContext Create(Socket socket);\n    public void Dispose();\n}\n```\n\n----------------------------------------\n\nTITLE: Local Test Execution Commands\nDESCRIPTION: Commands to simulate test execution locally by publishing and running tests using VSTest.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Helix.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\ndotnet publish\ncd <the publish directory>\ndotnet vstest My.Tests.dll\n```\n\n----------------------------------------\n\nTITLE: Updating Helix Matrix Configuration for Active Release Branches\nDESCRIPTION: Reference to the helix-matrix.yml configuration file that needs to be updated in both main and release branches to list currently active release branches.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/UpdatingMajorVersionAndTFM.md#2025-04-08_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n.azure/pipelines/helix-matrix.yml#L12-L16\n```\n\n----------------------------------------\n\nTITLE: Aborting WebTransport Session in C#\nDESCRIPTION: This code shows how to abort a WebTransport session, which severs the connection with the client and aborts all streams. An optional error code can be specified.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/WebTransport.md#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nsession.Abort(int errorCode);\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants for ASP.NET Core\nDESCRIPTION: This generated code defines constants for common content types used in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_NullableStringArrayParam.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: ModelValidationState Enum Definition\nDESCRIPTION: Enumeration defining possible states for model validation results in ASP.NET Core MVC.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic enum ModelValidationState\n{\n    Unvalidated = 0,\n    Invalid = 1,\n    Valid = 2,\n    Skipped = 3\n}\n```\n\n----------------------------------------\n\nTITLE: RenderTreeFrame Property Definitions\nDESCRIPTION: Defines property getters for the RenderTreeFrame class that handle various aspects of component rendering including attributes, elements, and component references.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n~Microsoft.AspNetCore.Components.RenderTree.RenderTreeFrame.AttributeEventUpdatesAttributeName.get -> string\n~Microsoft.AspNetCore.Components.RenderTree.RenderTreeFrame.AttributeName.get -> string\n~Microsoft.AspNetCore.Components.RenderTree.RenderTreeFrame.AttributeValue.get -> object\n```\n\n----------------------------------------\n\nTITLE: MapGet Extension Method Implementation for ASP.NET Core Routing\nDESCRIPTION: Defines an extension method for IEndpointRouteBuilder that maps HTTP GET requests to a specified handler with a given route pattern. It includes metadata population and request delegate factory functionality for proper endpoint configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet18(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n```\n\n----------------------------------------\n\nTITLE: Creating SQL Server Cache Table\nDESCRIPTION: Command to create the cache table in SQL Server using the dotnet-sql-cache tool, which requires a connection string to an existing CacheTestDb database.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/SqlServer/test/README.md#2025-04-08_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndotnet sql-cache [connectionstring] dbo CacheTest\n```\n\n----------------------------------------\n\nTITLE: Creating Event Binders in ASP.NET Core Components\nDESCRIPTION: Extension methods for EventCallbackFactory to create binders for various data types including DateTimeOffset, TimeOnly, and generic types. These methods handle data binding and event callbacks in Blazor components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Func<System.DateTimeOffset?, System.Threading.Tasks.Task!>! setter, System.DateTimeOffset? existingValue, string! format, System.Globalization.CultureInfo? culture = null) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.ChangeEventArgs!>\n```\n\n----------------------------------------\n\nTITLE: Implementing MapCore Route Handler Builder Method in C#\nDESCRIPTION: Provides a core implementation for mapping routes in ASP.NET Core. It delegates to RouteHandlerServices.Map to create route handler builders with specified patterns, HTTP methods, and metadata populators.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n        internal static RouteHandlerBuilder MapCore(\n            this IEndpointRouteBuilder routes,\n            string pattern,\n            Delegate handler,\n            IEnumerable<string>? httpMethods,\n            MetadataPopulator populateMetadata,\n            RequestDelegateFactoryFunc createRequestDelegate,\n            MethodInfo methodInfo)\n        {\n            return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n        }\n```\n\n----------------------------------------\n\nTITLE: Handling Required Parameter Missing Errors in ASP.NET Core\nDESCRIPTION: Handles cases where a required parameter is not provided in the request. Depending on configuration, it either throws a BadHttpRequestException or logs a debug message with details about the missing parameter and its expected source.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Submodules After Cloning in Bash\nDESCRIPTION: Command to initialize and update submodules if the repository was initially cloned without the --recursive flag.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/BuildFromSource.md#2025-04-08_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit submodule update --init --recursive\n```\n\n----------------------------------------\n\nTITLE: Implementing HTTP Request Handling with Response Parameter in ASP.NET Core\nDESCRIPTION: This snippet shows the implementation of request handling logic that processes HTTP requests and returns string responses. It handles both filtered and unfiltered invocations, sets appropriate content types, and supports parameter validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nTask RequestHandler(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var res_local = httpContext.Response;\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n        return Task.CompletedTask;\n    }\n    var result = handler(res_local);\n    if (result is string)\n    {\n        httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n    }\n    else\n    {\n        httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n    }\n    return httpContext.Response.WriteAsync(result);\n}\n```\n\n----------------------------------------\n\nTITLE: Negotiate Response (Version 1) in ASP.NET Core Transport Protocol\nDESCRIPTION: JSON response from the negotiate endpoint when using protocol version 1. Contains connectionToken, connectionId, negotiateVersion, and availableTransports properties that the client uses to establish a persistent connection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/TransportProtocols.md#2025-04-08_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"connectionToken\":\"05265228-1e2c-46c5-82a1-6a5bcc3f0143\",\n  \"connectionId\":\"807809a5-31bf-470d-9e23-afaee35d8a0d\",\n  \"negotiateVersion\":1,\n  \"availableTransports\":[\n    {\n      \"transport\": \"WebSockets\",\n      \"transferFormats\": [ \"Text\", \"Binary\" ]\n    },\n    {\n      \"transport\": \"ServerSentEvents\",\n      \"transferFormats\": [ \"Text\" ]\n    },\n    {\n      \"transport\": \"LongPolling\",\n      \"transferFormats\": [ \"Text\", \"Binary\" ]\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Azure File Logger Options API\nDESCRIPTION: Configuration options for Azure File logging including file name, size limits and retention settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Logging.AzureAppServices/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n~Microsoft.Extensions.Logging.AzureAppServices.AzureFileLoggerOptions.FileName.get -> string\n~Microsoft.Extensions.Logging.AzureAppServices.AzureFileLoggerOptions.FileName.set -> void\nMicrosoft.Extensions.Logging.AzureAppServices.AzureFileLoggerOptions.FileSizeLimit.get -> int?\nMicrosoft.Extensions.Logging.AzureAppServices.AzureFileLoggerOptions.FileSizeLimit.set -> void\nMicrosoft.Extensions.Logging.AzureAppServices.AzureFileLoggerOptions.RetainedFileCountLimit.get -> int?\nMicrosoft.Extensions.Logging.AzureAppServices.AzureFileLoggerOptions.RetainedFileCountLimit.set -> void\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Non-Form Content Type in ASP.NET Core\nDESCRIPTION: This method handles cases where an unexpected non-form content type is received. It throws a BadHttpRequestException with a 415 status code if _shouldThrow is true, otherwise logs the event if a logger is available.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitServiceParam_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Core Route Handler in ASP.NET Core\nDESCRIPTION: Implements the core logic for mapping a route handler in ASP.NET Core. It takes various parameters including the route pattern, handler delegate, HTTP methods, and metadata populator to create a RouteHandlerBuilder.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Roslyn's Embedded Language Common Utilities Source\nDESCRIPTION: Link to the original Roslyn source code repository from which embedded syntax code was copied for use in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Framework/AspNetCoreAnalyzers/src/Analyzers/Infrastructure/EmbeddedSyntax/README.md#2025-04-08_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nhttps://github.com/dotnet/roslyn/tree/b0de0c8e00ebf85db3c3884f2d81dfc3cb2d5a9d/src/Workspaces/SharedUtilitiesAndExtensions/Compiler/Core/EmbeddedLanguages/Common\n```\n\n----------------------------------------\n\nTITLE: Creating Import Map from Resource Collection in C#\nDESCRIPTION: Static method to create an ImportMapDefinition from a ResourceAssetCollection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Endpoints/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.ImportMapDefinition.FromResourceCollection(Microsoft.AspNetCore.Components.ResourceAssetCollection! assets) -> Microsoft.AspNetCore.Components.ImportMapDefinition!\n```\n\n----------------------------------------\n\nTITLE: Detecting GraphQL Introspection Queries in C#\nDESCRIPTION: An extension method that determines whether a string contains a GraphQL introspection query. It implements detection by checking if the text includes the term '__schema' or '__type', which are indicators of introspection queries.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/Cryptography.Internal/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants for ASP.NET Core Request Processing\nDESCRIPTION: Static class containing predefined arrays of MIME types for common content types used in HTTP requests and responses. These constants are referenced during content negotiation and parameter binding.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_MultipleSpecialTypeParam_StringReturn.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Executing and Returning HTTP Responses in ASP.NET Core\nDESCRIPTION: Handles the execution of different response types including IResult, string, and JSON objects. It determines the appropriate way to write the response based on the object type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleNullableStringParam_WithEmptyQueryStringValueProvided_StringReturn.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Restoring Project Dependencies on Windows\nDESCRIPTION: PowerShell command to run the restore script on Windows, which installs required dotnet dependencies and sets up the repository.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/README.md#2025-04-08_snippet_4\n\nLANGUAGE: powershell\nCODE:\n```\n./restore.cmd\n```\n\n----------------------------------------\n\nTITLE: Response Caching Feature Implementation in C#\nDESCRIPTION: Implementation of ResponseCachingFeature class that provides configuration for response caching, including vary-by-query-keys functionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ResponseCaching/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.ResponseCaching.ResponseCachingFeature.ResponseCachingFeature() -> void\nMicrosoft.AspNetCore.ResponseCaching.ResponseCachingFeature.VaryByQueryKeys.get -> string![]?\nMicrosoft.AspNetCore.ResponseCaching.ResponseCachingFeature.VaryByQueryKeys.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP-related Interfaces in ASP.NET Core\nDESCRIPTION: This code snippet defines various interfaces related to HTTP features in ASP.NET Core, including IFormFeature, IHttpBodyControlFeature, IHttpConnectionFeature, and IHttpExtendedConnectFeature. These interfaces provide properties and methods for handling form data, request body control, connection information, and extended connect features.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Features/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Features.IFormFeature\nMicrosoft.AspNetCore.Http.Features.IFormFeature.Form.get -> Microsoft.AspNetCore.Http.IFormCollection?\nMicrosoft.AspNetCore.Http.Features.IFormFeature.Form.set -> void\nMicrosoft.AspNetCore.Http.Features.IFormFeature.HasFormContentType.get -> bool\nMicrosoft.AspNetCore.Http.Features.IFormFeature.ReadForm() -> Microsoft.AspNetCore.Http.IFormCollection!\nMicrosoft.AspNetCore.Http.Features.IFormFeature.ReadFormAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Http.IFormCollection!>!\n\nMicrosoft.AspNetCore.Http.Features.IHttpBodyControlFeature\nMicrosoft.AspNetCore.Http.Features.IHttpBodyControlFeature.AllowSynchronousIO.get -> bool\nMicrosoft.AspNetCore.Http.Features.IHttpBodyControlFeature.AllowSynchronousIO.set -> void\n\nMicrosoft.AspNetCore.Http.Features.IHttpConnectionFeature\nMicrosoft.AspNetCore.Http.Features.IHttpConnectionFeature.ConnectionId.get -> string!\nMicrosoft.AspNetCore.Http.Features.IHttpConnectionFeature.ConnectionId.set -> void\nMicrosoft.AspNetCore.Http.Features.IHttpConnectionFeature.LocalIpAddress.get -> System.Net.IPAddress?\nMicrosoft.AspNetCore.Http.Features.IHttpConnectionFeature.LocalIpAddress.set -> void\nMicrosoft.AspNetCore.Http.Features.IHttpConnectionFeature.LocalPort.get -> int\nMicrosoft.AspNetCore.Http.Features.IHttpConnectionFeature.LocalPort.set -> void\nMicrosoft.AspNetCore.Http.Features.IHttpConnectionFeature.RemoteIpAddress.get -> System.Net.IPAddress?\nMicrosoft.AspNetCore.Http.Features.IHttpConnectionFeature.RemoteIpAddress.set -> void\nMicrosoft.AspNetCore.Http.Features.IHttpConnectionFeature.RemotePort.get -> int\nMicrosoft.AspNetCore.Http.Features.IHttpConnectionFeature.RemotePort.set -> void\n\nMicrosoft.AspNetCore.Http.Features.IHttpExtendedConnectFeature\nMicrosoft.AspNetCore.Http.Features.IHttpExtendedConnectFeature.AcceptAsync() -> System.Threading.Tasks.ValueTask<System.IO.Stream!>\nMicrosoft.AspNetCore.Http.Features.IHttpExtendedConnectFeature.IsExtendedConnect.get -> bool\nMicrosoft.AspNetCore.Http.Features.IHttpExtendedConnectFeature.Protocol.get -> string?\n```\n\n----------------------------------------\n\nTITLE: Parsing StringWithQualityHeaderValue in C#\nDESCRIPTION: Static methods for parsing StringWithQualityHeaderValue from string input or lists of strings. Includes methods for strict parsing and try-parse variations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Headers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Net.Http.Headers.StringWithQualityHeaderValue.Parse(Microsoft.Extensions.Primitives.StringSegment input) -> Microsoft.Net.Http.Headers.StringWithQualityHeaderValue!\nstatic Microsoft.Net.Http.Headers.StringWithQualityHeaderValue.ParseList(System.Collections.Generic.IList<string!>? input) -> System.Collections.Generic.IList<Microsoft.Net.Http.Headers.StringWithQualityHeaderValue!>!\nstatic Microsoft.Net.Http.Headers.StringWithQualityHeaderValue.ParseStrictList(System.Collections.Generic.IList<string!>? input) -> System.Collections.Generic.IList<Microsoft.Net.Http.Headers.StringWithQualityHeaderValue!>!\nstatic Microsoft.Net.Http.Headers.StringWithQualityHeaderValue.TryParse(Microsoft.Extensions.Primitives.StringSegment input, out Microsoft.Net.Http.Headers.StringWithQualityHeaderValue? parsedValue) -> bool\nstatic Microsoft.Net.Http.Headers.StringWithQualityHeaderValue.TryParseList(System.Collections.Generic.IList<string!>? input, out System.Collections.Generic.IList<Microsoft.Net.Http.Headers.StringWithQualityHeaderValue!>? parsedValues) -> bool\nstatic Microsoft.Net.Http.Headers.StringWithQualityHeaderValue.TryParseStrictList(System.Collections.Generic.IList<string!>? input, out System.Collections.Generic.IList<Microsoft.Net.Http.Headers.StringWithQualityHeaderValue!>? parsedValues) -> bool\n```\n\n----------------------------------------\n\nTITLE: Utility Methods for ASP.NET Core Endpoint Processing - C#\nDESCRIPTION: Small utility methods for checking polymorphism, type matching, executing IResult objects, and populating endpoint metadata. These methods support the core request delegate functionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitBodyParam_ComplexReturn_Snapshot.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteAsyncExplicit(IResult result, HttpContext httpContext)\n    => result.ExecuteAsync(httpContext);\n```\n\nLANGUAGE: C#\nCODE:\n```\nprivate static void PopulateMetadataForEndpoint<T>(MethodInfo method, EndpointBuilder builder)\n    where T : IEndpointMetadataProvider\n{\n    T.PopulateMetadata(method, builder);\n}\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Implementation in ASP.NET Core\nDESCRIPTION: Class implementing IParameterBindingMetadata interface to store and provide access to parameter binding information. It captures details about parameter names, TryParse capabilities, and other binding-related properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_MultipleSpecialTypeParam_StringReturn.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Blazor Framework Files Middleware in ASP.NET Core\nDESCRIPTION: Extension methods for IApplicationBuilder that add middleware for serving Blazor WebAssembly framework files. These methods configure the application to serve the necessary files for Blazor WebAssembly applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.ComponentsWebAssemblyApplicationBuilderExtensions.UseBlazorFrameworkFiles(this Microsoft.AspNetCore.Builder.IApplicationBuilder! applicationBuilder) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.ComponentsWebAssemblyApplicationBuilderExtensions.UseBlazorFrameworkFiles(this Microsoft.AspNetCore.Builder.IApplicationBuilder! builder, Microsoft.AspNetCore.Http.PathString pathPrefix) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: CNG GCM Authenticated Encryptor Factory\nDESCRIPTION: Factory class for creating GCM-mode authenticated encryptors using the Windows Cryptography API: Next Generation (CNG).\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.CngGcmAuthenticatedEncryptorFactory.CngGcmAuthenticatedEncryptorFactory(Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> void\nMicrosoft.AspNetCore.DataProtection.AuthenticatedEncryption.CngGcmAuthenticatedEncryptorFactory.CreateEncryptorInstance(Microsoft.AspNetCore.DataProtection.KeyManagement.IKey! key) -> Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor?\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in ASP.NET Core\nDESCRIPTION: This method handles cases where there's a failure in reading a parameter from the request body as a form. It throws a BadHttpRequestException if _shouldThrow is true, otherwise logs the event if a logger is available.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitServiceParam_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a custom attribute InterceptsLocationAttribute used for method interception. This attribute is file-scoped and can be applied to methods multiple times.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_MultipleSpecialTypeParam_StringReturn.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Test Method in C#\nDESCRIPTION: Example of a conditional test method using attributes to skip specific platforms. Shows how to configure test execution based on operating system and Helix queue conditions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/ProjectTemplates/README.md#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[ConditionalFact]\n[OSSkipCondition(OperatingSystems.Linux | OperatingSystems.MacOSX)]\n[SkipOnHelix(\"cert failure\", Queues = \"All.OSX;\" + HelixConstants.Windows10Arm64)]\npublic async Task MvcTemplate_SingleFileExe()\n{\n```\n\n----------------------------------------\n\nTITLE: StringSyntax Route Annotation Example in C#\nDESCRIPTION: Shows the annotation applied to strings to enable route tooling functionality. This annotation signals to the tooling that the string contains a route pattern that should be analyzed.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Framework/AspNetCoreAnalyzers/src/Analyzers/RouteEmbeddedLanguage/README.md#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[StringSyntax(\"Route\")]\n```\n\n----------------------------------------\n\nTITLE: Request Body Binding in ASP.NET Core\nDESCRIPTION: Asynchronously attempts to bind the request body to a specified type. Handles content type validation, JSON deserialization, and various error conditions. Returns a tuple indicating success and the parsed value.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static async ValueTask<(bool, T?)> TryResolveBodyAsync<T>(HttpContext httpContext, LogOrThrowExceptionHelper logOrThrowExceptionHelper, bool allowEmpty, string parameterTypeName, string parameterName, JsonTypeInfo<T> jsonTypeInfo, bool isInferred = false)\n{\n    var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();\n    T? bodyValue = default;\n    var bodyValueSet = false;\n\n    if (feature?.CanHaveBody == true)\n    {\n        if (!httpContext.Request.HasJsonContentType())\n        {\n            logOrThrowExceptionHelper.UnexpectedJsonContentType(httpContext.Request.ContentType);\n            httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;\n            return (false, default);\n        }\n        try\n        {\n            bodyValue = await httpContext.Request.ReadFromJsonAsync(jsonTypeInfo);\n            bodyValueSet = bodyValue != null;\n        }\n        catch (BadHttpRequestException badHttpRequestException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(badHttpRequestException);\n            httpContext.Response.StatusCode = badHttpRequestException.StatusCode;\n            return (false, default);\n        }\n        catch (IOException ioException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(ioException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n        catch (System.Text.Json.JsonException jsonException)\n        {\n            logOrThrowExceptionHelper.InvalidJsonRequestBody(parameterTypeName, parameterName, jsonException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n    }\n\n    if (!allowEmpty && !bodyValueSet)\n    {\n        if (!isInferred)\n        {\n            logOrThrowExceptionHelper.RequiredParameterNotProvided(parameterTypeName, parameterName, \"body\");\n        }\n        else\n        {\n            logOrThrowExceptionHelper.ImplicitBodyNotProvided(parameterName);\n        }\n        httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n        return (false, bodyValue);\n    }\n\n    return (true, bodyValue);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RenderTreeBuilder Methods in C#\nDESCRIPTION: This snippet shows method signatures for the RenderTreeBuilder class, which is used to construct render trees for Blazor components. It includes methods for adding attributes, components, and content to the render tree.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddAttribute<TArgument>(int sequence, string! name, Microsoft.AspNetCore.Components.EventCallback<TArgument> value) -> void\nMicrosoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddComponentParameter(int sequence, string! name, object? value) -> void\nMicrosoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddComponentReferenceCapture(int sequence, System.Action<object!>! componentReferenceCaptureAction) -> void\nMicrosoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddComponentRenderMode(Microsoft.AspNetCore.Components.IComponentRenderMode? renderMode) -> void\nMicrosoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddContent(int sequence, Microsoft.AspNetCore.Components.MarkupString markupContent) -> void\nMicrosoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddContent(int sequence, Microsoft.AspNetCore.Components.MarkupString? markupContent) -> void\nMicrosoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddContent(int sequence, Microsoft.AspNetCore.Components.RenderFragment? fragment) -> void\nMicrosoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddContent(int sequence, object? textContent) -> void\nMicrosoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddContent(int sequence, string? textContent) -> void\nMicrosoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddContent<TValue>(int sequence, Microsoft.AspNetCore.Components.RenderFragment<TValue>? fragment, TValue value) -> void\n```\n\n----------------------------------------\n\nTITLE: File Operations in ASP.NET Core HTTP Response\nDESCRIPTION: Extension methods for sending files in HTTP responses with support for offset, count, and cancellation tokens\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.SendFileResponseExtensions.SendFileAsync(this Microsoft.AspNetCore.Http.HttpResponse! response, string! fileName, long offset, long? count, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Polymorphism Detection for JSON Serialization in ASP.NET Core\nDESCRIPTION: Helper method that determines if a JSON type info object has known polymorphism, which affects serialization behavior. Checks if the type is sealed, a value type, or has explicit polymorphism options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n```\n\n----------------------------------------\n\nTITLE: Checking for Known Polymorphism in JSON Type Info (C#)\nDESCRIPTION: This extension method checks if a JsonTypeInfo has known polymorphism based on type characteristics.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n```\n\n----------------------------------------\n\nTITLE: Decoding CancelInvocation Message in MessagePack\nDESCRIPTION: Illustrates the structure and decoding of a CancelInvocation message in the SignalR MessagePack protocol. It includes message type, headers, and invocation ID.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_11\n\nLANGUAGE: MessagePack\nCODE:\n```\n0x93 0x05 0x80 0xa3 0x78 0x79 0x7a\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C# ASP.NET Core Project\nDESCRIPTION: This directive enables nullable reference types for the entire project or file. It allows the compiler to perform static analysis to help prevent null reference exceptions by treating reference types as non-nullable by default.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/EntityFrameworkCore/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive that enables nullable reference type annotations in C# 8.0 and above, providing compile-time null safety checks.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/ObjectPool/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core MVC Action Result Overrides\nDESCRIPTION: Method overrides for various MVC action result types including formatting and execution behaviors\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Mvc.AcceptedAtActionResult.OnFormatting(Microsoft.AspNetCore.Mvc.ActionContext! context) -> void\noverride Microsoft.AspNetCore.Mvc.AcceptedAtRouteResult.OnFormatting(Microsoft.AspNetCore.Mvc.ActionContext! context) -> void\noverride Microsoft.AspNetCore.Mvc.AcceptedResult.OnFormatting(Microsoft.AspNetCore.Mvc.ActionContext! context) -> void\n```\n\n----------------------------------------\n\nTITLE: Resolving Route or Query Parameters in ASP.NET Core in C#\nDESCRIPTION: This method creates a function to resolve a parameter value from either route values or query string in an ASP.NET Core request.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsSameInterceptorsFromDifferentFiles.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Func<HttpContext, StringValues> ResolveFromRouteOrQuery(string parameterName, IEnumerable<string>? routeParameterNames)\n{\n    return routeParameterNames?.Contains(parameterName, StringComparer.OrdinalIgnoreCase) == true\n        ? (httpContext) => new StringValues((string?)httpContext.Request.RouteValues[parameterName])\n        : (httpContext) => httpContext.Request.Query[parameterName];\n}\n```\n\n----------------------------------------\n\nTITLE: Running Specific ASP.NET Core Benchmark (Shell)\nDESCRIPTION: This command runs a specific benchmark using the dotnet CLI. It uses the Release configuration and filters the benchmarks to run using the provided parameter.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/HttpSys/perf/Microbenchmarks/README.md#2025-04-08_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ndotnet run -c Release --filter RequestHeaderBenchmarks*\n```\n\n----------------------------------------\n\nTITLE: Running SignalR Tests on SauceLabs\nDESCRIPTION: Command to run tests on SauceLabs for cross-browser testing. Requires SauceLabs account and environment variables to be set.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/JSFunctionalTests.md#2025-04-08_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./build /t:Restore\n```\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh /t:Restore\n```\n\nLANGUAGE: bash\nCODE:\n```\ncd clients/ts/FunctionalTests\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm run sauce\n```\n\n----------------------------------------\n\nTITLE: JSON Response Writing with Type Information\nDESCRIPTION: Writes JSON responses using the appropriate serialization configuration, handling runtime type differences and polymorphism. Includes compiler suppression attributes for trimming and AOT compatibility.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AsyncState Generic Class in C#\nDESCRIPTION: A generic class for managing asynchronous state with nullable reference types enabled. It includes type constraints ensuring state is a reference type that can be null.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Grpc/JsonTranscoding/src/Microsoft.AspNetCore.Grpc.Swagger/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Route Handler in ASP.NET Core\nDESCRIPTION: Generated code for handling HTTP GET requests in ASP.NET Core, including metadata population and request delegate creation with support for filters and JSON serialization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsVoid_Has_No_Metadata.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        // ... [truncated for brevity]\n    };\n    var castHandler = Cast(handler, void () => throw null!);\n    return MapCore(\n        endpoints,\n        pattern,\n        handler,\n        GetVerb,\n        populateMetadata,\n        createRequestDelegate,\n        castHandler.Method);\n}\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Class in C#\nDESCRIPTION: Implements parameter binding metadata storage for request handling. Stores information about parameter names, types, parsing capabilities, and optional status.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n    public bool HasTryParse { get; }\n    public bool HasBindAsync { get; }\n    public ParameterInfo ParameterInfo { get; }\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BuildFilterDelegate Method in C#\nDESCRIPTION: Implements a BuildFilterDelegate method to construct a filter delegate for endpoint filtering in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsTodo_Has_Metadata.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining KeyPerFileConfigurationBuilderExtensions Class in C#\nDESCRIPTION: Defines extension methods for IConfigurationBuilder to add KeyPerFile configuration. Provides overloads for different configuration options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Configuration.KeyPerFile/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Configuration.KeyPerFileConfigurationBuilderExtensions\nstatic Microsoft.Extensions.Configuration.KeyPerFileConfigurationBuilderExtensions.AddKeyPerFile(this Microsoft.Extensions.Configuration.IConfigurationBuilder! builder, string! directoryPath) -> Microsoft.Extensions.Configuration.IConfigurationBuilder!\nstatic Microsoft.Extensions.Configuration.KeyPerFileConfigurationBuilderExtensions.AddKeyPerFile(this Microsoft.Extensions.Configuration.IConfigurationBuilder! builder, string! directoryPath, bool optional) -> Microsoft.Extensions.Configuration.IConfigurationBuilder!\nstatic Microsoft.Extensions.Configuration.KeyPerFileConfigurationBuilderExtensions.AddKeyPerFile(this Microsoft.Extensions.Configuration.IConfigurationBuilder! builder, string! directoryPath, bool optional, bool reloadOnChange) -> Microsoft.Extensions.Configuration.IConfigurationBuilder!\nstatic Microsoft.Extensions.Configuration.KeyPerFileConfigurationBuilderExtensions.AddKeyPerFile(this Microsoft.Extensions.Configuration.IConfigurationBuilder! builder, System.Action<Microsoft.Extensions.Configuration.KeyPerFile.KeyPerFileConfigurationSource!>! configureSource) -> Microsoft.Extensions.Configuration.IConfigurationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Redis Cache Service Collection Extension\nDESCRIPTION: Extension method for IServiceCollection to add Redis cache services to the dependency injection container.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PublicAPI/net8.0/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.StackExchangeRedisCacheServiceCollectionExtensions.AddStackExchangeRedisCache(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions!>! setupAction) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Adding Interactive WebAssembly Components to Razor Components Builder\nDESCRIPTION: Extension method for IRazorComponentsBuilder that adds services required for interactive WebAssembly components. This configures the necessary services for WebAssembly-based interactive components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.WebAssemblyRazorComponentsBuilderExtensions.AddInteractiveWebAssemblyComponents(this Microsoft.Extensions.DependencyInjection.IRazorComponentsBuilder! builder) -> Microsoft.Extensions.DependencyInjection.IRazorComponentsBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining Parameter Binding Failure Logger in ASP.NET Core\nDESCRIPTION: Defines a structured logger for parameter binding failures using LoggerMessage.Define. This creates a reusable logging delegate that efficiently captures parameter type, parameter name, and source value with minimal allocation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n    LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Running Specific ASP.NET Core Benchmark\nDESCRIPTION: Command to run a specific benchmark by name. It requires specifying the target framework moniker (tfm) and the benchmark name as a filter.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/perf/Microbenchmarks/readme.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ndotnet run -c Release --framework <tfm> --filter <benchmark_name>\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in ASP.NET Core\nDESCRIPTION: Processes errors that occur when failing to read form parameters from the request body. Either throws a BadHttpRequestException with details or logs the issue depending on configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Authorization Requirements in C#\nDESCRIPTION: Defines various authorization requirements such as assertion, claims, deny anonymous, name, and roles requirements. These are used to build authorization policies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.Infrastructure.AssertionRequirement\nMicrosoft.AspNetCore.Authorization.Infrastructure.ClaimsAuthorizationRequirement\nMicrosoft.AspNetCore.Authorization.Infrastructure.DenyAnonymousAuthorizationRequirement\nMicrosoft.AspNetCore.Authorization.Infrastructure.NameAuthorizationRequirement\nMicrosoft.AspNetCore.Authorization.Infrastructure.OperationAuthorizationRequirement\nMicrosoft.AspNetCore.Authorization.Infrastructure.RolesAuthorizationRequirement\n```\n\n----------------------------------------\n\nTITLE: HostString Utilities in ASP.NET Core\nDESCRIPTION: Methods for working with HTTP Host headers in ASP.NET Core, including creation from URI components, pattern matching, and equality operators.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.HostString.FromUriComponent(string! uriComponent) -> Microsoft.AspNetCore.Http.HostString\nstatic Microsoft.AspNetCore.Http.HostString.FromUriComponent(System.Uri! uri) -> Microsoft.AspNetCore.Http.HostString\nstatic Microsoft.AspNetCore.Http.HostString.MatchesAny(Microsoft.Extensions.Primitives.StringSegment value, System.Collections.Generic.IList<Microsoft.Extensions.Primitives.StringSegment>! patterns) -> bool\nstatic Microsoft.AspNetCore.Http.HostString.operator !=(Microsoft.AspNetCore.Http.HostString left, Microsoft.AspNetCore.Http.HostString right) -> bool\nstatic Microsoft.AspNetCore.Http.HostString.operator ==(Microsoft.AspNetCore.Http.HostString left, Microsoft.AspNetCore.Http.HostString right) -> bool\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core View Resolution Path Structure\nDESCRIPTION: File path structure showing the organization of MVC views including layout, view start, index page, components and partial views. Demonstrates the conventional folder hierarchy and file naming patterns used in ASP.NET Core MVC applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/test/Mvc.FunctionalTests/compiler/resources/ViewEngineController.ViewWithPaths.txt#2025-04-08_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n<Layout>\n    /Views/ViewWithPaths/_Layout.cshtml\n    /Views/ViewWithPaths/Index.cshtml\n</Layout>\n<ViewStart>\n    /Views/ViewWithPaths/_ViewStart.cshtml\n    /Views/ViewWithPaths/Index.cshtml\n</ViewStart>\n<Index>\n    /Views/ViewWithPaths/Index.cshtml\n    /Views/ViewWithPaths/Index.cshtml\n    <component>\n/Views/Shared/Components/ComponentForViewWithPaths/Default.cshtml\n/Views/Shared/Components/ComponentForViewWithPaths/Default.cshtml\n</component>\n    <Partial>\n/Views/ViewWithPaths/_Partial.cshtml\n/Views/ViewWithPaths/_Partial.cshtml\n</Partial>\n</Index>\n```\n\n----------------------------------------\n\nTITLE: Antiforgery Metadata Implementation\nDESCRIPTION: Implements IAntiforgeryMetadata interface to handle antiforgery validation requirements for requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/RequestDelegateValidateGeneratedFormCode.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class AntiforgeryMetadata : IAntiforgeryMetadata\n{\n    public static readonly IAntiforgeryMetadata ValidationRequired = new AntiforgeryMetadata(true);\n\n    public AntiforgeryMetadata(bool requiresValidation)\n    {\n        RequiresValidation = requiresValidation;\n    }\n\n    public bool RequiresValidation { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Integration Tests with WebApplicationFactory in ASP.NET Core\nDESCRIPTION: Example C# test class that uses WebApplicationFactory to bootstrap an ASP.NET Core application for integration testing. The class demonstrates how to create an HTTP client from the factory and test multiple endpoints using xUnit's Theory attribute.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Testing/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class BasicTests\n    : IClassFixture<WebApplicationFactory<Program>>\n{\n    private readonly WebApplicationFactory<Program> _factory;\n\n    public BasicTests(WebApplicationFactory<Program> factory)\n    {\n        _factory = factory;\n    }\n\n    [Theory]\n    [InlineData(\"/\")]\n    [InlineData(\"/Index\")]\n    [InlineData(\"/About\")]\n    [InlineData(\"/Privacy\")]\n    [InlineData(\"/Contact\")]\n    public async Task Get_EndpointsReturnSuccessAndCorrectContentType(string url)\n    {\n        // Arrange\n        var client = _factory.CreateClient();\n\n        // Act\n        var response = await client.GetAsync(url);\n\n        // Assert\n        response.EnsureSuccessStatusCode(); // Status Code 200-299\n        Assert.Equal(\"text/html; charset=utf-8\",\n            response.Content.Headers.ContentType.ToString());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EmbeddedResourceFileInfo Class in C#\nDESCRIPTION: This snippet defines the EmbeddedResourceFileInfo class, which represents an embedded resource file. It includes methods for creating read streams and properties for file information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/FileProviders/Embedded/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.FileProviders.Embedded.EmbeddedResourceFileInfo\nMicrosoft.Extensions.FileProviders.Embedded.EmbeddedResourceFileInfo.CreateReadStream() -> System.IO.Stream!\nMicrosoft.Extensions.FileProviders.Embedded.EmbeddedResourceFileInfo.EmbeddedResourceFileInfo(System.Reflection.Assembly! assembly, string! resourcePath, string! name, System.DateTimeOffset lastModified) -> void\nMicrosoft.Extensions.FileProviders.Embedded.EmbeddedResourceFileInfo.Exists.get -> bool\nMicrosoft.Extensions.FileProviders.Embedded.EmbeddedResourceFileInfo.IsDirectory.get -> bool\nMicrosoft.Extensions.FileProviders.Embedded.EmbeddedResourceFileInfo.LastModified.get -> System.DateTimeOffset\nMicrosoft.Extensions.FileProviders.Embedded.EmbeddedResourceFileInfo.Length.get -> long\nMicrosoft.Extensions.FileProviders.Embedded.EmbeddedResourceFileInfo.Name.get -> string!\nMicrosoft.Extensions.FileProviders.Embedded.EmbeddedResourceFileInfo.PhysicalPath.get -> string?\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Message for Unexpected JSON Content Type in C#\nDESCRIPTION: Creates a logger message for unexpected JSON content types using LoggerMessage.Define. This is used to log debug messages when an unsupported JSON media type is received.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nLoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Validation Methods in C#\nDESCRIPTION: These abstract methods are defined to retrieve validation attributes for parameters and properties in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Http.Validation.ValidatableParameterInfo.GetValidationAttributes() -> System.ComponentModel.DataAnnotations.ValidationAttribute![]!\nabstract Microsoft.AspNetCore.Http.Validation.ValidatablePropertyInfo.GetValidationAttributes() -> System.ComponentModel.DataAnnotations.ValidationAttribute![]!\n```\n\n----------------------------------------\n\nTITLE: Request Body Parsing in ASP.NET Core\nDESCRIPTION: Handles parsing and validation of JSON request bodies with error handling and logging support.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Get_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static async ValueTask<(bool, T?)> TryResolveBodyAsync<T>(HttpContext httpContext, LogOrThrowExceptionHelper logOrThrowExceptionHelper, bool allowEmpty, string parameterTypeName, string parameterName, JsonTypeInfo<T> jsonTypeInfo, bool isInferred = false)\n{\n    var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();\n    T? bodyValue = default;\n    var bodyValueSet = false;\n\n    if (feature?.CanHaveBody == true)\n    {\n        if (!httpContext.Request.HasJsonContentType())\n        {\n            logOrThrowExceptionHelper.UnexpectedJsonContentType(httpContext.Request.ContentType);\n            httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;\n            return (false, default);\n        }\n        try\n        {\n            bodyValue = await httpContext.Request.ReadFromJsonAsync(jsonTypeInfo);\n            bodyValueSet = bodyValue != null;\n        }\n        catch (BadHttpRequestException badHttpRequestException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(badHttpRequestException);\n            httpContext.Response.StatusCode = badHttpRequestException.StatusCode;\n            return (false, default);\n        }\n        catch (IOException ioException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(ioException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n        catch (System.Text.Json.JsonException jsonException)\n        {\n            logOrThrowExceptionHelper.InvalidJsonRequestBody(parameterTypeName, parameterName, jsonException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n    }\n\n    if (!allowEmpty && !bodyValueSet)\n    {\n        if (!isInferred)\n        {\n            logOrThrowExceptionHelper.RequiredParameterNotProvided(parameterTypeName, parameterName, \"body\");\n        }\n        else\n        {\n            logOrThrowExceptionHelper.ImplicitBodyNotProvided(parameterName);\n        }\n        httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n        return (false, bodyValue);\n    }\n\n    return (true, bodyValue);\n}\n```\n\n----------------------------------------\n\nTITLE: LinkTagHelper Class Signatures in ASP.NET Core MVC\nDESCRIPTION: API signatures for the LinkTagHelper class that generates HTML link elements for CSS stylesheets. It supports fallback scripts, globbing patterns, and file versioning.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.TagHelpers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.Cache.get -> Microsoft.Extensions.Caching.Memory.IMemoryCache\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.FallbackHref.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.FallbackHref.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.FallbackHrefExclude.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.FallbackHrefExclude.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.FallbackHrefInclude.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.FallbackHrefInclude.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.FallbackTestClass.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.FallbackTestClass.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.FallbackTestProperty.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.FallbackTestProperty.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.FallbackTestValue.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.FallbackTestValue.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.GlobbingUrlBuilder.get -> Microsoft.AspNetCore.Mvc.TagHelpers.GlobbingUrlBuilder\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.GlobbingUrlBuilder.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.HostingEnvironment.get -> Microsoft.AspNetCore.Hosting.IWebHostEnvironment\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.Href.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.Href.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.HrefExclude.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.HrefExclude.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.HrefInclude.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.HrefInclude.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.JavaScriptEncoder.get -> System.Text.Encodings.Web.JavaScriptEncoder\n~Microsoft.AspNetCore.Mvc.TagHelpers.LinkTagHelper.LinkTagHelper(Microsoft.AspNetCore.Hosting.IWebHostEnvironment hostingEnvironment, Microsoft.AspNetCore.Mvc.Razor.Infrastructure.TagHelperMemoryCacheProvider cacheProvider, Microsoft.AspNetCore.Mvc.ViewFeatures.IFileVersionProvider fileVersionProvider, System.Text.Encodings.Web.HtmlEncoder htmlEncoder, System.Text.Encodings.Web.JavaScriptEncoder javaScriptEncoder, Microsoft.AspNetCore.Mvc.Routing.IUrlHelperFactory urlHelperFactory) -> void\n```\n\n----------------------------------------\n\nTITLE: Disposing Server Authentication State Provider in Blazor\nDESCRIPTION: Virtual method that handles resource cleanup for the RevalidatingServerAuthenticationStateProvider. Implements the dispose pattern to free managed and unmanaged resources.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.Server.RevalidatingServerAuthenticationStateProvider.Dispose(bool disposing) -> void\n```\n\n----------------------------------------\n\nTITLE: Rendering ASP.NET Core Page with View Components and Partial Views\nDESCRIPTION: This HTML/Razor template displays product information for laptops in the North region, showing cached content with correlation IDs across different page components. It demonstrates how view components, partial views, and cached content work together in an ASP.NET Core application.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/test/Mvc.FunctionalTests/compiler/resources/CacheTagHelper_CanCachePortionsOfViewsPartialViewsAndViewComponents.Assert1.txt#2025-04-08_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n<h2>Category: Laptops</h2>\n<h2>Region: North</h2>\n\n    <h2>Cached content</h2>\n    Locations closest to your locale:\n\nNorthWest Store\n<div>CorrelationId in View Component: 1</div>\n\n    <partial-title>Listing items</partial-title>\n\nCached Content for Laptops\n<div>CorrelationId in Partial: 1</div>\n\n    <div>CorrelationId in Splash: 1</div>\n```\n\n----------------------------------------\n\nTITLE: Property-Based Parameter Info Implementation\nDESCRIPTION: Custom implementation of ParameterInfo that wraps a PropertyInfo, used for parameter binding and metadata handling in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class PropertyAsParameterInfo : ParameterInfo\n{\n    private readonly PropertyInfo _underlyingProperty;\n    private readonly ParameterInfo? _constructionParameterInfo;\n\n    public PropertyAsParameterInfo(bool isOptional, PropertyInfo propertyInfo)\n    {\n        Debug.Assert(propertyInfo != null, \"PropertyInfo must be provided.\");\n\n        AttrsImpl = (ParameterAttributes)propertyInfo.Attributes;\n        NameImpl = propertyInfo.Name;\n        MemberImpl = propertyInfo;\n        ClassImpl = propertyInfo.PropertyType;\n\n        PositionImpl = -1;\n\n        _underlyingProperty = propertyInfo;\n        IsOptional = isOptional;\n    }\n\n    public PropertyAsParameterInfo(bool isOptional, PropertyInfo property, ParameterInfo? parameterInfo)\n        : this(isOptional, property)\n    {\n        _constructionParameterInfo = parameterInfo;\n    }\n\n    public override bool HasDefaultValue\n        => _constructionParameterInfo is not null && _constructionParameterInfo.HasDefaultValue;\n    public override object? DefaultValue\n        => _constructionParameterInfo?.DefaultValue;\n    public override int MetadataToken => _underlyingProperty.MetadataToken;\n    public override object? RawDefaultValue\n        => _constructionParameterInfo?.RawDefaultValue;\n\n    public override object[] GetCustomAttributes(Type attributeType, bool inherit)\n    {\n        var constructorAttributes = _constructionParameterInfo?.GetCustomAttributes(attributeType, inherit);\n\n        if (constructorAttributes == null || constructorAttributes is { Length: 0 })\n        {\n            return _underlyingProperty.GetCustomAttributes(attributeType, inherit);\n        }\n\n        var propertyAttributes = _underlyingProperty.GetCustomAttributes(attributeType, inherit);\n\n        var mergedAttributes = new Attribute[constructorAttributes.Length + propertyAttributes.Length];\n        Array.Copy(constructorAttributes, mergedAttributes, constructorAttributes.Length);\n        Array.Copy(propertyAttributes, 0, mergedAttributes, constructorAttributes.Length, propertyAttributes.Length);\n\n        return mergedAttributes;\n    }\n\n    public override object[] GetCustomAttributes(bool inherit)\n    {\n        var constructorAttributes = _constructionParameterInfo?.GetCustomAttributes(inherit);\n\n        if (constructorAttributes == null || constructorAttributes is { Length: 0 })\n        {\n            return _underlyingProperty.GetCustomAttributes(inherit);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HtmlLocalizerFactory Class Methods in C#\nDESCRIPTION: This snippet shows the virtual methods of the HtmlLocalizerFactory class, which is used for creating IHtmlLocalizer instances. It includes methods for creating localizers based on resource name and type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.Localization.HtmlLocalizerFactory.Create(string! baseName, string! location) -> Microsoft.AspNetCore.Mvc.Localization.IHtmlLocalizer!\nvirtual Microsoft.AspNetCore.Mvc.Localization.HtmlLocalizerFactory.Create(System.Type! resourceSource) -> Microsoft.AspNetCore.Mvc.Localization.IHtmlLocalizer!\n```\n\n----------------------------------------\n\nTITLE: Defining IRequestDecompressionProvider Interface in C#\nDESCRIPTION: This interface defines a method for getting a decompression stream from an HttpContext. It's part of the Microsoft.AspNetCore.RequestDecompression namespace.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/RequestDecompression/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.RequestDecompression.IRequestDecompressionProvider.GetDecompressionStream(Microsoft.AspNetCore.Http.HttpContext! context) -> System.IO.Stream?\n```\n\n----------------------------------------\n\nTITLE: Processing Request Body in ASP.NET Core\nDESCRIPTION: Handles reading and parsing JSON request body content with error handling and validation. Supports optional parameters and content type verification.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static async ValueTask<(bool, T?)> TryResolveBodyAsync<T>(HttpContext httpContext, LogOrThrowExceptionHelper logOrThrowExceptionHelper, bool allowEmpty, string parameterTypeName, string parameterName, JsonTypeInfo<T> jsonTypeInfo, bool isInferred = false)\n{\n    var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();\n    T? bodyValue = default;\n    var bodyValueSet = false;\n\n    if (feature?.CanHaveBody == true)\n    {\n        if (!httpContext.Request.HasJsonContentType())\n        {\n            logOrThrowExceptionHelper.UnexpectedJsonContentType(httpContext.Request.ContentType);\n            httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;\n            return (false, default);\n        }\n        try\n        {\n            bodyValue = await httpContext.Request.ReadFromJsonAsync(jsonTypeInfo);\n            bodyValueSet = bodyValue != null;\n        }\n        catch (BadHttpRequestException badHttpRequestException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(badHttpRequestException);\n            httpContext.Response.StatusCode = badHttpRequestException.StatusCode;\n            return (false, default);\n        }\n        catch (IOException ioException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(ioException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n        catch (System.Text.Json.JsonException jsonException)\n        {\n            logOrThrowExceptionHelper.InvalidJsonRequestBody(parameterTypeName, parameterName, jsonException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n    }\n\n    if (!allowEmpty && !bodyValueSet)\n    {\n        if (!isInferred)\n        {\n            logOrThrowExceptionHelper.RequiredParameterNotProvided(parameterTypeName, parameterName, \"body\");\n        }\n        else\n        {\n            logOrThrowExceptionHelper.ImplicitBodyNotProvided(parameterName);\n        }\n        httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n        return (false, bodyValue);\n    }\n\n    return (true, bodyValue);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MapMethods0 Extension Method in C#\nDESCRIPTION: Extends IEndpointRouteBuilder with a MapMethods0 method for custom request handling. It includes metadata population, request delegate creation, and parameter binding for HTTP methods and handlers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndGet_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedRouteBuilderExtensionsCore\n{\n    private static readonly JsonOptions FallbackJsonOptions = new();\n\n    %INTERCEPTSLOCATIONATTRIBUTE%\n    internal static RouteHandlerBuilder MapMethods0(\n        this IEndpointRouteBuilder endpoints,\n        [StringSyntax(\"Route\")] string pattern,\n        IEnumerable<string> httpMethods,\n        Delegate handler)\n    {\n        MetadataPopulator populateMetadata = (methodInfo, options) =>\n        {\n            // ... (metadata population logic)\n        };\n        RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n        {\n            // ... (request delegate creation logic)\n        };\n\n        // ... (request handling logic)\n    }\n\n    // ... (additional helper methods)\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive that enables nullable reference type checking for C# code. When enabled, the compiler performs static analysis to identify potential null reference issues.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Spa/SpaServices.Extensions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive that enables nullable reference type checks for better null safety. This helps catch potential null reference exceptions at compile time rather than runtime.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/Abstractions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: HttpLoggingServicesExtensions in ASP.NET Core\nDESCRIPTION: Extension methods for IServiceCollection that register HTTP logging and W3C logging services in the dependency injection container, with optional configuration actions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpLogging/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.HttpLoggingServicesExtensions.AddHttpLogging(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.HttpLoggingServicesExtensions.AddHttpLogging(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.HttpLogging.HttpLoggingOptions!>! configureOptions) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.HttpLoggingServicesExtensions.AddHttpLoggingInterceptor<T>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.HttpLoggingServicesExtensions.AddW3CLogging(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.HttpLogging.W3CLoggerOptions!>! configureOptions) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Parameter Value Resolution from Route or Query\nDESCRIPTION: Returns a function that resolves parameter values from either route values or query string based on whether the parameter name appears in route parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static Func<HttpContext, StringValues> ResolveFromRouteOrQuery(string parameterName, IEnumerable<string>? routeParameterNames)\n{\n    return routeParameterNames?.Contains(parameterName, StringComparer.OrdinalIgnoreCase) == true\n        ? (httpContext) => new StringValues((string?)httpContext.Request.RouteValues[parameterName])\n        : (httpContext) => httpContext.Request.Query[parameterName];\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Microsoft.AspNetCore.Components.WebAssembly.DevServer Reference to Project File\nDESCRIPTION: This XML snippet shows how to add the Microsoft.AspNetCore.Components.WebAssembly.DevServer package reference to your project file (.csproj) with the PrivateAssets attribute set to 'all'.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/DevServer/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\n<PackageReference Include=\"Microsoft.AspNetCore.Components.WebAssembly.DevServer\" Version=\"...\" PrivateAssets=\"all\" />\n```\n\n----------------------------------------\n\nTITLE: HTTP Context Binding for Model Types in ASP.NET Core\nDESCRIPTION: Generic method for binding model types from HTTP context. Works with types that implement IBindableFromHttpContext<T> interface, enabling custom model binding implementations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_NullableReturn.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static ValueTask<T?> BindAsync<T>(HttpContext context, ParameterInfo parameter)\n    where T : class, IBindableFromHttpContext<T>\n{\n    return T.BindAsync(context, parameter);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocationAttribute for Method Interception in C#\nDESCRIPTION: Defines an attribute used for intercepting method calls at specific locations in code. This attribute is part of the compiler-generated code for ASP.NET Core's request handling pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_NullableReturn.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Result Filter Event Data Classes in C#\nDESCRIPTION: Defines event data classes for monitoring result filter execution including before/after result execution events\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Diagnostics.BeforeResultFilterOnResultExecutedEventData.BeforeResultFilterOnResultExecutedEventData(Microsoft.AspNetCore.Mvc.Abstractions.ActionDescriptor! actionDescriptor, Microsoft.AspNetCore.Mvc.Filters.ResultExecutedContext! resultExecutedContext, Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata! filter) -> void\n```\n\n----------------------------------------\n\nTITLE: Batching Logger Options API\nDESCRIPTION: Configuration options for batched logging including queue size, batch size, flush period and scoping settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Logging.AzureAppServices/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Logging.AzureAppServices.BatchingLoggerOptions.BackgroundQueueSize.get -> int?\nMicrosoft.Extensions.Logging.AzureAppServices.BatchingLoggerOptions.BackgroundQueueSize.set -> void\nMicrosoft.Extensions.Logging.AzureAppServices.BatchingLoggerOptions.BatchSize.get -> int?\nMicrosoft.Extensions.Logging.AzureAppServices.BatchingLoggerOptions.BatchSize.set -> void\nMicrosoft.Extensions.Logging.AzureAppServices.BatchingLoggerOptions.FlushPeriod.get -> System.TimeSpan\nMicrosoft.Extensions.Logging.AzureAppServices.BatchingLoggerOptions.FlushPeriod.set -> void\nMicrosoft.Extensions.Logging.AzureAppServices.BatchingLoggerOptions.IncludeScopes.get -> bool\nMicrosoft.Extensions.Logging.AzureAppServices.BatchingLoggerOptions.IncludeScopes.set -> void\nMicrosoft.Extensions.Logging.AzureAppServices.BatchingLoggerOptions.IsEnabled.get -> bool\nMicrosoft.Extensions.Logging.AzureAppServices.BatchingLoggerOptions.IsEnabled.set -> void\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants for API Metadata\nDESCRIPTION: Static class containing commonly used content type constants for API metadata. These are used for content negotiation and request/response type hints.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP.sys Request Timing Interface in C#\nDESCRIPTION: Interface for accessing HTTP.sys request timing information, providing methods to retrieve timestamps and calculate elapsed time between different stages of request processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/HttpSys/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Server.HttpSys.IHttpSysRequestTimingFeature\nMicrosoft.AspNetCore.Server.HttpSys.IHttpSysRequestTimingFeature.Timestamps.get -> System.ReadOnlySpan<long>\nMicrosoft.AspNetCore.Server.HttpSys.IHttpSysRequestTimingFeature.TryGetElapsedTime(Microsoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType startingTimestampType, Microsoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType endingTimestampType, out System.TimeSpan elapsed) -> bool\nMicrosoft.AspNetCore.Server.HttpSys.IHttpSysRequestTimingFeature.TryGetTimestamp(Microsoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType timestampType, out long timestamp) -> bool\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: The directive enables nullable reference type checking for the file. This feature helps developers avoid null reference exceptions by making nullability part of the type system and requiring explicit null handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/BearerToken/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Route Constraint Matching in ASP.NET Core\nDESCRIPTION: This static method performs route constraint matching in ASP.NET Core. It evaluates the constraints against the provided route values and HTTP context to determine if a route matches the current request.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.RouteConstraintMatcher.Match(System.Collections.Generic.IDictionary<string!, Microsoft.AspNetCore.Routing.IRouteConstraint!>! constraints, Microsoft.AspNetCore.Routing.RouteValueDictionary! routeValues, Microsoft.AspNetCore.Http.HttpContext! httpContext, Microsoft.AspNetCore.Routing.IRouter! route, Microsoft.AspNetCore.Routing.RouteDirection routeDirection, Microsoft.Extensions.Logging.ILogger! logger) -> bool\n```\n\n----------------------------------------\n\nTITLE: Logger Provider Implementations\nDESCRIPTION: Concrete implementations of logger providers for Azure Blob storage, file system, and batching capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Logging.AzureAppServices/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n~Microsoft.Extensions.Logging.AzureAppServices.BatchingLoggerProvider.CreateLogger(string categoryName) -> Microsoft.Extensions.Logging.ILogger\n~Microsoft.Extensions.Logging.AzureAppServices.BlobLoggerProvider.BlobLoggerProvider(Microsoft.Extensions.Options.IOptionsMonitor<Microsoft.Extensions.Logging.AzureAppServices.AzureBlobLoggerOptions> options) -> void\n~Microsoft.Extensions.Logging.AzureAppServices.FileLoggerProvider.FileLoggerProvider(Microsoft.Extensions.Options.IOptionsMonitor<Microsoft.Extensions.Logging.AzureAppServices.AzureFileLoggerOptions> options) -> void\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Implicit Body in ASP.NET Core\nDESCRIPTION: Manages scenarios where an implicit body parameter is expected but no request body was provided. It suggests using a Service instead and either throws a BadHttpRequestException or logs a debug message based on configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic void ImplicitBodyNotProvided(string parameterName)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Parameter Binding Metadata Class in ASP.NET Core C#\nDESCRIPTION: Defines a sealed class for storing parameter binding metadata including name, parameter info, and binding capabilities. This class helps the request delegate generator understand how to bind parameters from HTTP requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_NullableReturn.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Message for Unexpected Non-Form Content Type\nDESCRIPTION: Creates a static logger message definition for when an unsupported form media type is received. Uses LoggerMessage.Define to optimize logging performance.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Extension Method for ASP.NET Core Endpoint Routing\nDESCRIPTION: Implements a MapGet extension method for IEndpointRouteBuilder to handle HTTP GET requests. This method supports parameter binding, response serialization, filtering, and metadata generation for routing endpoints.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n%INTERCEPTSLOCATIONATTRIBUTE%\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: true));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(global::System.String[]), contentTypes: GeneratedMetadataConstants.JsonContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n        Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n        var handler = Cast(del, global::System.String[] (global::System.String[]? arg0= default) => throw null!);\n        EndpointFilterDelegate? filteredInvocation = null;\n        var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n        var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n        var jsonSerializerOptions = jsonOptions.SerializerOptions;\n        jsonSerializerOptions.MakeReadOnly();\n        var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n        var responseJsonTypeInfo =  (JsonTypeInfo<global::System.String[]?>)jsonSerializerOptions.GetTypeInfo(typeof(global::System.String[]));\n\n        if (options.EndpointBuilder.FilterFactories.Count > 0)\n        {\n            filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n            {\n                if (ic.HttpContext.Response.StatusCode == 400)\n                {\n                    return ValueTask.FromResult<object?>(Results.Empty);\n                }\n                return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::System.String[]?>(0)!));\n            },\n            options.EndpointBuilder,\n            handler.Method);\n        }\n\n        Task RequestHandler(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            // Endpoint Parameter: p (Type = string[]?, IsOptional = True, IsParsable = False, IsArray = True, Source = Query)\n            var p_raw = httpContext.Request.Query[\"p\"];\n            var p_temp = p_raw.ToArray();\n            string[] p_local = p_temp!;\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n                return Task.CompletedTask;\n            }\n            var result = handler(p_local);\n            return GeneratedRouteBuilderExtensionsCore.WriteJsonResponseAsync(httpContext.Response, result, responseJsonTypeInfo);\n        }\n\n        async Task RequestHandlerFiltered(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            // Endpoint Parameter: p (Type = string[]?, IsOptional = True, IsParsable = False, IsArray = True, Source = Query)\n            var p_raw = httpContext.Request.Query[\"p\"];\n            var p_temp = p_raw.ToArray();\n            string[] p_local = p_temp!;\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n            }\n            var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::System.String[]?>(httpContext, p_local));\n            if (result is not null)\n            {\n                await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n            }\n        }\n\n        RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\n        var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\n        return new RequestDelegateResult(targetDelegate, metadata);\n    };\n    var castHandler = Cast(handler, global::System.String[] (global::System.String[]? arg0= default) => throw null!);\n    return MapCore(\n        endpoints,\n        pattern,\n        handler,\n        GetVerb,\n        populateMetadata,\n        createRequestDelegate,\n        castHandler.Method);\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C# for ASP.NET Core\nDESCRIPTION: This directive enables nullable reference types for the entire file or project, enhancing null safety and helping to prevent null reference exceptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DefaultBuilder/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Required Parameters in ASP.NET Core (C#)\nDESCRIPTION: Handles cases where a required parameter was not provided in the request. This method either throws a BadHttpRequestException with a descriptive message or logs the issue based on configuration settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Get_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Null Cache Dependency Singleton in C#\nDESCRIPTION: Defines a static ExtendedCacheEntryHelper class with a NullDependency property that returns a singleton instance of a null cache dependency. The property is initialized with a static constructor approach to ensure thread-safe singleton instantiation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Kestrel/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: CookieBuilder Virtual Properties in ASP.NET Core\nDESCRIPTION: Defines virtual properties for configuring HTTP cookies including HttpOnly, security settings, expiration, path and SameSite attributes\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.HttpOnly.get -> bool\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.HttpOnly.set -> void\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.IsEssential.get -> bool\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.IsEssential.set -> void\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.MaxAge.get -> System.TimeSpan?\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.MaxAge.set -> void\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.Name.get -> string?\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.Name.set -> void\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.Path.get -> string?\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.Path.set -> void\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.SameSite.get -> Microsoft.AspNetCore.Http.SameSiteMode\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.SameSite.set -> void\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.SecurePolicy.get -> Microsoft.AspNetCore.Http.CookieSecurePolicy\nvirtual Microsoft.AspNetCore.Http.CookieBuilder.SecurePolicy.set -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring Azure SignalR Service in ASP.NET Core SignalR\nDESCRIPTION: This code snippet shows how to configure Azure SignalR Service in an ASP.NET Core application. It includes setting up the connection string, adding the SignalR service, and configuring options for Azure SignalR Service.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/WindowsServices/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class Startup\n{\n    public void ConfigureServices(IServiceCollection services)\n    {\n        services.AddSignalR()\n            .AddAzureSignalR(options =>\n            {\n                options.ConnectionString = Configuration[\"Azure:SignalR:ConnectionString\"];\n                options.ServerStickyMode = ServerStickyMode.Required;\n            });\n    }\n\n    public void Configure(IApplicationBuilder app)\n    {\n        app.UseRouting();\n        app.UseEndpoints(endpoints =>\n        {\n            endpoints.MapHub<ChatHub>(\"/chat\");\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Site Extension Packages for Previous Major Version\nDESCRIPTION: Example of the version entries that need to be added to Dependencies.props for the new site extension packages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/UpdatingMajorVersionAndTFM.md#2025-04-08_snippet_3\n\nLANGUAGE: xml\nCODE:\n```\n<PropertyGroup>\n  <!-- entries similar to these -->\n</PropertyGroup>\n```\n\n----------------------------------------\n\nTITLE: Creating and Returning Request Delegate Result in ASP.NET Core\nDESCRIPTION: Sets up the final request delegate based on whether filtering is enabled and returns the result with appropriate metadata. This code completes the request delegate factory function by selecting the appropriate handler and finalizing the result.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nRequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\nvar metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\nreturn new RequestDelegateResult(targetDelegate, metadata);\n};\nvar castHandler = Cast(handler, void (global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType arg0) => throw null!);\nreturn MapCore(\n    endpoints,\n    pattern,\n    handler,\n    GetVerb,\n    populateMetadata,\n    createRequestDelegate,\n    castHandler.Method);\n```\n\n----------------------------------------\n\nTITLE: Configuring CORS Policy with Extension Methods in C#\nDESCRIPTION: This code snippet defines extension methods for ICorsPolicyBuilder to configure CORS policies. It includes methods for setting allowed origins, headers, and methods, as well as enabling credentials and exposing headers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Building ASP.NET Core Solution in Release Mode\nDESCRIPTION: Compiles the solution in Release configuration to ensure Kestrel is available in release mode\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/perf/Microbenchmarks/README.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nbuild.cmd /p:Configuration=Release\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Message for Unexpected Content Type\nDESCRIPTION: Creates a static logger message definition for when an unsupported JSON media type is received. This is part of the content type validation system.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\nLoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Template Reference in Markdown\nDESCRIPTION: Shows inline code formatting for referencing the Empty project template type\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/repro.md#2025-04-08_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n`Empty*`\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive to enable nullable reference type checking in the C# code. This helps the compiler detect potential null reference exceptions at compile time rather than runtime.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Forms/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining Form Content Type Logger Message in ASP.NET Core\nDESCRIPTION: Creates a structured logger message for cases where an unexpected non-form content type is received. The logger captures the content type and logs at debug level with a specific event ID.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Endpoint Filter Interface Definition\nDESCRIPTION: Interface definition for endpoint filters in ASP.NET Core that can intercept and modify HTTP request processing\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.IEndpointFilter.InvokeAsync(Microsoft.AspNetCore.Http.EndpointFilterInvocationContext! context, Microsoft.AspNetCore.Http.EndpointFilterDelegate! next) -> System.Threading.Tasks.ValueTask<object?>\n```\n\n----------------------------------------\n\nTITLE: Implementing ArgumentEscaper Utility Class in C#\nDESCRIPTION: This code defines the ArgumentEscaper class with methods for escaping individual arguments and combining multiple arguments. It handles special characters and spaces to ensure proper command-line argument formatting.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/JSInterop/Microsoft.JSInterop/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n\nnamespace Microsoft.Extensions.CommandLineUtils;\n\ninternal static class ArgumentEscaper\n{\n    /// <summary>\n    /// Undo the processing which took place to create string[] args in Main,\n    /// so that the next process will receive the same string[] args\n    /// </summary>\n    /// <param name=\"args\"></param>\n    /// <returns></returns>\n    public static string EscapeAndConcatenateArgArrayForProcessStart(IEnumerable<string> args)\n    {\n        return string.Join(\" \", EscapeArgArray(args));\n    }\n\n    /// <summary>\n    /// Undo the processing which took place to create string[] args in Main,\n    /// so that the next process will receive the same string[] args\n    /// </summary>\n    /// <param name=\"args\"></param>\n    /// <returns></returns>\n    public static IEnumerable<string> EscapeArgArray(IEnumerable<string> args)\n    {\n        return args.Select(EscapeArg);\n    }\n\n    /// <summary>\n    /// Escapes a set of command line arguments for new process start.\n    /// </summary>\n    /// <param name=\"args\"></param>\n    /// <returns></returns>\n    public static string EscapeAndConcatenateArgArrayForCmdProcessStart(IEnumerable<string> args)\n    {\n        return string.Join(\" \", args.Select(EscapeArgForCmdProcessStart));\n    }\n\n    private static string EscapeArg(string arg)\n    {\n        // http://stackoverflow.com/questions/5510758/escape-command-line-arguments-in-c-sharp\n        // http://msdn.microsoft.com/en-us/library/17w5ykft.aspx\n        // http://msdn.microsoft.com/en-us/library/bb776391.aspx\n\n        if (string.IsNullOrEmpty(arg))\n        {\n            return \"\";\n        }\n\n        if (!arg.Contains(\" \") && !arg.Contains(\"\\t\") && !arg.Contains(\"\\n\") && !arg.Contains(\"\\v\") && !arg.Contains('\"'))\n        {\n            return arg;\n        }\n\n        var sb = new StringBuilder();\n\n        sb.Append('\"');\n\n        for (int i = 0; i < arg.Length; ++i)\n        {\n            var backslashes = 0;\n\n            while (i < arg.Length && arg[i] == '\\\\')\n            {\n                backslashes++;\n                i++;\n            }\n\n            if (i == arg.Length)\n            {\n                sb.Append('\\\\', backslashes * 2);\n            }\n            else if (arg[i] == '\"')\n            {\n                sb.Append('\\\\', backslashes * 2 + 1);\n                sb.Append('\"');\n            }\n            else\n            {\n                sb.Append('\\\\', backslashes);\n                sb.Append(arg[i]);\n            }\n        }\n\n        sb.Append('\"');\n\n        return sb.ToString();\n    }\n\n    private static string EscapeArgForCmdProcessStart(string arg)\n    {\n        // this is a workaround for the command line parsing behavior of \n        // System.Diagnostics.Process.Start() which does not interpret arguments\n        // surrounded by quotation marks as single arguments if they contain \n        // spaces.\n        // \n        // http://stackoverflow.com/questions/5510758/escape-command-line-arguments-in-c-sharp\n        // http://stackoverflow.com/questions/15909650/launch-command-prompt-as-separate-user\n\n        if (string.IsNullOrEmpty(arg))\n        {\n            return \"\";\n        }\n\n        if (arg.Contains(' ') || arg.Contains('\"'))\n        {\n            return '\"' + arg.Replace(\"\\\"\", \"\\\"\\\"\") + '\"';\n        }\n\n        return arg;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Endpoint Filter Delegate in ASP.NET Core\nDESCRIPTION: Constructs an endpoint filter delegate by applying a series of filter factories to an initial filtered invocation. It iterates through the filter factories in reverse order, creating a chain of filters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Data from WebTransport Stream in C#\nDESCRIPTION: This snippet demonstrates how to read data from a WebTransport stream. It reads data from the stream into a provided memory buffer and returns the number of bytes read.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/WebTransport.md#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nvar stream = connectionContext.Transport.Input.AsStream();\nvar length = await stream.ReadAsync(Memory<byte> memory);\n```\n\n----------------------------------------\n\nTITLE: StaticHtmlRenderer API for Server-Side Component Rendering\nDESCRIPTION: API signature for the StaticHtmlRenderer class which enables server-side rendering of Blazor components to HTML, including methods to begin rendering components with parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.HtmlRendering.Infrastructure.StaticHtmlRenderer\nMicrosoft.AspNetCore.Components.HtmlRendering.Infrastructure.StaticHtmlRenderer.BeginRenderingComponent(Microsoft.AspNetCore.Components.IComponent! component, Microsoft.AspNetCore.Components.ParameterView initialParameters) -> Microsoft.AspNetCore.Components.Web.HtmlRendering.HtmlRootComponent\nMicrosoft.AspNetCore.Components.HtmlRendering.Infrastructure.StaticHtmlRenderer.BeginRenderingComponent(System.Type! componentType, Microsoft.AspNetCore.Components.ParameterView initialParameters) -> Microsoft.AspNetCore.Components.Web.HtmlRendering.HtmlRootComponent\n```\n\n----------------------------------------\n\nTITLE: StaticHtmlRenderer API for Server-Side Component Rendering\nDESCRIPTION: API signature for the StaticHtmlRenderer class which enables server-side rendering of Blazor components to HTML, including methods to begin rendering components with parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.HtmlRendering.Infrastructure.StaticHtmlRenderer\nMicrosoft.AspNetCore.Components.HtmlRendering.Infrastructure.StaticHtmlRenderer.BeginRenderingComponent(Microsoft.AspNetCore.Components.IComponent! component, Microsoft.AspNetCore.Components.ParameterView initialParameters) -> Microsoft.AspNetCore.Components.Web.HtmlRendering.HtmlRootComponent\nMicrosoft.AspNetCore.Components.HtmlRendering.Infrastructure.StaticHtmlRenderer.BeginRenderingComponent(System.Type! componentType, Microsoft.AspNetCore.Components.ParameterView initialParameters) -> Microsoft.AspNetCore.Components.Web.HtmlRendering.HtmlRootComponent\n```\n\n----------------------------------------\n\nTITLE: Error Handling and Logging Helper for ASP.NET Core Request Processing\nDESCRIPTION: Helper class for consistent error handling during request processing, with configurable behavior to either log errors or throw exceptions. It includes specialized methods for common error scenarios in parameter binding and request body processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_MultipleSpecialTypeParam_StringReturn.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n\n    public void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n\n    public void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n\n    public void ImplicitBodyNotProvided(string parameterName)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n\n    public void UnexpectedJsonContentType(string? contentType)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n            throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n\n    public void UnexpectedNonFormContentType(string? contentType)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n            throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n\n    public void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic AcceptedAtRoute HTTP Result in C#\nDESCRIPTION: Defines a generic version of the AcceptedAtRoute class that can include a value of type TValue in the response. It includes properties for RouteName and an ExecuteAsync method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.AcceptedAtRoute<TValue>\nMicrosoft.AspNetCore.Http.HttpResults.AcceptedAtRoute<TValue>.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.AcceptedAtRoute<TValue>.RouteName.get -> string?\n```\n\n----------------------------------------\n\nTITLE: Request Delegate Factory Implementation in C#\nDESCRIPTION: Implements request delegate factory functionality with parameter binding, metadata population, and filtered request handling. Includes support for JSON serialization, error handling, and content type negotiation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_27\n\nLANGUAGE: csharp\nCODE:\n```\noptions.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\nreturn new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n```\n\nLANGUAGE: csharp\nCODE:\n```\nasync Task RequestHandler(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var myBindAsyncParam_local = await BindAsync<global::Microsoft.AspNetCore.Http.Generators.Tests.BindAsyncFromImplicitStaticAbstractInterface>(httpContext, parameters[0]);\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n        return;\n    }\n    var result = handler(myBindAsyncParam_local);\n    if (result is string)\n    {\n        httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n    }\n    else\n    {\n        httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n    }\n    await httpContext.Response.WriteAsync(result);\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nasync Task RequestHandlerFiltered(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var myBindAsyncParam_local = await BindAsync<global::Microsoft.AspNetCore.Http.Generators.Tests.BindAsyncFromImplicitStaticAbstractInterface>(httpContext, parameters[0]);\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n    }\n    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.BindAsyncFromImplicitStaticAbstractInterface?>(httpContext, myBindAsyncParam_local));\n    if (result is not null)\n    {\n        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C# ASP.NET Core\nDESCRIPTION: Directive that enables nullable reference type checking, enforcing strict null checks throughout the code file. This helps catch potential null reference exceptions at compile time.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in ASP.NET Core\nDESCRIPTION: Handles cases where parsing a form request body fails. Includes the original exception as the inner exception. Either throws a BadHttpRequestException or logs the error, depending on configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndGet_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: A C# directive that enables nullable reference type checking for improved null safety. This helps developers catch potential null reference issues during compilation rather than runtime.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Razor/Razor.Runtime/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: OpenAPI 3.1.1 Form Handling API Specification\nDESCRIPTION: Complete OpenAPI specification for a forms API that handles file uploads, multiple files, todo items, and combined POCO/file submissions. Includes path definitions, request schemas, and component definitions for IFormFile, IFormFileCollection, and Todo models.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/test/Microsoft.AspNetCore.OpenApi.Tests/Integration/snapshots/OpenApi3_1/OpenApiDocumentIntegrationTests.VerifyOpenApiDocument_documentName=forms.verified.txt#2025-04-08_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"openapi\": \"3.1.1\",\n  \"info\": {\n    \"title\": \"Sample | forms\",\n    \"version\": \"1.0.0\"\n  },\n  \"paths\": {\n    \"/forms/form-file\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"multipart/form-data\": {\n              \"schema\": {\n                \"required\": [\n                  \"resume\"\n                ],\n                \"type\": \"object\",\n                \"properties\": {\n                  \"resume\": {\n                    \"$ref\": \"#/components/schemas/IFormFile\"\n                  }\n                }\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/forms/form-files\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"multipart/form-data\": {\n              \"schema\": {\n                \"required\": [\n                  \"files\"\n                ],\n                \"type\": \"object\",\n                \"properties\": {\n                  \"files\": {\n                    \"$ref\": \"#/components/schemas/IFormFileCollection\"\n                  }\n                }\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/forms/form-file-multiple\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"multipart/form-data\": {\n              \"schema\": {\n                \"required\": [\n                  \"resume\",\n                  \"files\"\n                ],\n                \"type\": \"object\",\n                \"allOf\": [\n                  {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"resume\": {\n                        \"$ref\": \"#/components/schemas/IFormFile\"\n                      }\n                    }\n                  },\n                  {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"files\": {\n                        \"$ref\": \"#/components/schemas/IFormFileCollection\"\n                      }\n                    }\n                  }\n                ]\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/forms/form-todo\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"multipart/form-data\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/Todo\"\n              }\n            },\n            \"application/x-www-form-urlencoded\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/Todo\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/forms/forms-pocos-and-files\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"multipart/form-data\": {\n              \"schema\": {\n                \"required\": [\n                  \"file\"\n                ],\n                \"type\": \"object\",\n                \"allOf\": [\n                  {\n                    \"$ref\": \"#/components/schemas/Todo\"\n                  },\n                  {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"file\": {\n                        \"$ref\": \"#/components/schemas/IFormFile\"\n                      }\n                    }\n                  }\n                ]\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"IFormFile\": {\n        \"type\": \"string\",\n        \"format\": \"binary\"\n      },\n      \"IFormFileCollection\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"$ref\": \"#/components/schemas/IFormFile\"\n        }\n      },\n      \"Todo\": {\n        \"required\": [\n          \"id\",\n          \"title\",\n          \"completed\",\n          \"createdAt\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"integer\",\n            \"description\": \"The unique identifier of the to-do item.\",\n            \"format\": \"int32\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"The title of the to-do item.\"\n          },\n          \"completed\": {\n            \"type\": \"boolean\",\n            \"description\": \"Indicates whether the to-do item is completed.\"\n          },\n          \"createdAt\": {\n            \"type\": \"string\",\n            \"description\": \"The date and time when the to-do item was created.\",\n            \"format\": \"date-time\"\n          }\n        },\n        \"description\": \"Represents a to-do item.\"\n      }\n    }\n  },\n  \"tags\": [\n    {\n      \"name\": \"Sample\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Getting or Creating OpenAPI Schema in Schema Transformer Context\nDESCRIPTION: Method in OpenApiSchemaTransformerContext to asynchronously retrieve or create an OpenAPI schema for a given type. Optionally accepts parameter description and cancellation token.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.OpenApi.OpenApiSchemaTransformerContext.GetOrCreateSchemaAsync(System.Type! type, Microsoft.AspNetCore.Mvc.ApiExplorer.ApiParameterDescription? parameterDescription = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<Microsoft.OpenApi.Models.OpenApiSchema!>!\n```\n\n----------------------------------------\n\nTITLE: Parsing Binding Address in ASP.NET Core\nDESCRIPTION: This static method parses a string address into a BindingAddress object, which represents a parsed endpoint address.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.BindingAddress.Parse(string! address) -> Microsoft.AspNetCore.Http.BindingAddress!\n```\n\n----------------------------------------\n\nTITLE: Delegate Type Casting Helper\nDESCRIPTION: Generic helper method to cast delegates to specific delegate types safely.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitSource_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n```\n\n----------------------------------------\n\nTITLE: Building ASP.NET Core Security Components in PowerShell\nDESCRIPTION: Command to build the ASP.NET Core security components from source. This should be run inside the security directory of the ASP.NET Core project.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: Running Tests in dotnet/runtime with PowerShell\nDESCRIPTION: Commands to run tests for specific projects within the dotnet/runtime repository.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Shared/runtime/ReadMe.SharedCode.md#2025-04-08_snippet_2\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS D:\\github\\runtime\\src\\libraries\\Common\\tests> dotnet build /t:test\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS D:\\github\\runtime\\src\\libraries\\System.Net.Http\\tests\\UnitTests> dotnet build /t:test\n```\n\n----------------------------------------\n\nTITLE: Implementing UrlTestEncoder class in C#\nDESCRIPTION: Implements the UrlTestEncoder class with methods for encoding URL content in testing scenarios.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/WebEncoders/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.WebEncoders.Testing.UrlTestEncoder\nMicrosoft.Extensions.WebEncoders.Testing.UrlTestEncoder.UrlTestEncoder() -> void\noverride Microsoft.Extensions.WebEncoders.Testing.UrlTestEncoder.Encode(string! value) -> string!\noverride Microsoft.Extensions.WebEncoders.Testing.UrlTestEncoder.Encode(System.IO.TextWriter! output, char[]! value, int startIndex, int characterCount) -> void\noverride Microsoft.Extensions.WebEncoders.Testing.UrlTestEncoder.Encode(System.IO.TextWriter! output, string! value, int startIndex, int characterCount) -> void\noverride Microsoft.Extensions.WebEncoders.Testing.UrlTestEncoder.FindFirstCharacterToEncode(char* text, int textLength) -> int\noverride Microsoft.Extensions.WebEncoders.Testing.UrlTestEncoder.MaxOutputCharactersPerInputCharacter.get -> int\noverride Microsoft.Extensions.WebEncoders.Testing.UrlTestEncoder.TryEncodeUnicodeScalar(int unicodeScalar, char* buffer, int bufferLength, out int numberOfCharactersWritten) -> bool\noverride Microsoft.Extensions.WebEncoders.Testing.UrlTestEncoder.WillEncode(int unicodeScalar) -> bool\n```\n\n----------------------------------------\n\nTITLE: OpenAPI 3.1.1 Specification for ASP.NET Core API\nDESCRIPTION: Complete OpenAPI specification defining API endpoints, request/response schemas, and validation rules. Includes path parameters, form submissions, and component schemas for a Todo application.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/test/Microsoft.AspNetCore.OpenApi.Tests/Integration/snapshots/OpenApi3_1/OpenApiDocumentIntegrationTests.VerifyOpenApiDocument_documentName=controllers.verified.txt#2025-04-08_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"openapi\": \"3.1.1\",\n  \"info\": {\n    \"title\": \"Sample | controllers\",\n    \"version\": \"1.0.0\"\n  },\n  \"paths\": {\n    \"/getbyidandname/{id}/{name}\": {\n      \"get\": {\n        \"tags\": [\n          \"Test\"\n        ],\n        \"parameters\": [\n          {\n            \"name\": \"Id\",\n            \"in\": \"path\",\n            \"required\": true,\n            \"schema\": {\n              \"type\": \"integer\",\n              \"format\": \"int32\"\n            }\n          },\n          {\n            \"name\": \"Name\",\n            \"in\": \"path\",\n            \"required\": true,\n            \"schema\": {\n              \"minLength\": 5,\n              \"type\": \"string\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"text/plain\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              },\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              },\n              \"text/json\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"/gettypedresult\": {\n      \"get\": {\n        \"tags\": [\n          \"Test\"\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/MvcTodo\"\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"/forms\": {\n      \"post\": {\n        \"tags\": [\n          \"Test\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/x-www-form-urlencoded\": {\n              \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                  \"Title\": {\n                    \"type\": \"string\"\n                  },\n                  \"Description\": {\n                    \"type\": \"string\"\n                  },\n                  \"IsCompleted\": {\n                    \"type\": \"boolean\"\n                  }\n                }\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"MvcTodo\": {\n        \"required\": [\n          \"title\",\n          \"description\",\n          \"isCompleted\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"title\": {\n            \"type\": \"string\"\n          },\n          \"description\": {\n            \"type\": \"string\"\n          },\n          \"isCompleted\": {\n            \"type\": \"boolean\"\n          }\n        }\n      }\n    }\n  },\n  \"tags\": [\n    {\n      \"name\": \"Test\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Description Property in ApiResponseType Class with Nullable Support\nDESCRIPTION: Defines the getter and setter for the Description property in ApiResponseType class with nullable string support. This property likely holds the descriptive text for API response types in the API documentation generation system.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\nMicrosoft.AspNetCore.Mvc.ApiExplorer.ApiResponseType.Description.get -> string?\nMicrosoft.AspNetCore.Mvc.ApiExplorer.ApiResponseType.Description.set -> void\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive to enable nullable reference type checking at the file level. This enforces more strict null checking in C# code.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Rewrite/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining SPA Extension Methods in C#\nDESCRIPTION: Defines various extension methods for configuring and using SPA services in ASP.NET Core. Includes methods for using SPA middleware, proxying to development servers, and configuring Angular and React development servers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Spa/SpaServices.Extensions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.SpaApplicationBuilderExtensions.UseSpa(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app, System.Action<Microsoft.AspNetCore.SpaServices.ISpaBuilder!>! configuration) -> void\nstatic Microsoft.AspNetCore.Builder.SpaProxyingExtensions.UseProxyToSpaDevelopmentServer(this Microsoft.AspNetCore.SpaServices.ISpaBuilder! spaBuilder, string! baseUri) -> void\nstatic Microsoft.AspNetCore.Builder.SpaProxyingExtensions.UseProxyToSpaDevelopmentServer(this Microsoft.AspNetCore.SpaServices.ISpaBuilder! spaBuilder, System.Func<System.Threading.Tasks.Task<System.Uri!>!>! baseUriTaskFactory) -> void\nstatic Microsoft.AspNetCore.Builder.SpaProxyingExtensions.UseProxyToSpaDevelopmentServer(this Microsoft.AspNetCore.SpaServices.ISpaBuilder! spaBuilder, System.Uri! baseUri) -> void\nstatic Microsoft.AspNetCore.SpaServices.AngularCli.AngularCliMiddlewareExtensions.UseAngularCliServer(this Microsoft.AspNetCore.SpaServices.ISpaBuilder! spaBuilder, string! npmScript) -> void\nstatic Microsoft.AspNetCore.SpaServices.ReactDevelopmentServer.ReactDevelopmentServerMiddlewareExtensions.UseReactDevelopmentServer(this Microsoft.AspNetCore.SpaServices.ISpaBuilder! spaBuilder, string! npmScript) -> void\nstatic Microsoft.Extensions.DependencyInjection.SpaStaticFilesExtensions.AddSpaStaticFiles(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.SpaServices.StaticFiles.SpaStaticFilesOptions!>? configuration = null) -> void\nstatic Microsoft.Extensions.DependencyInjection.SpaStaticFilesExtensions.UseSpaStaticFiles(this Microsoft.AspNetCore.Builder.IApplicationBuilder! applicationBuilder) -> void\nstatic Microsoft.Extensions.DependencyInjection.SpaStaticFilesExtensions.UseSpaStaticFiles(this Microsoft.AspNetCore.Builder.IApplicationBuilder! applicationBuilder, Microsoft.AspNetCore.Builder.StaticFileOptions! options) -> void\n```\n\n----------------------------------------\n\nTITLE: Manual Implementation References for ASP.NET Core Classes\nDESCRIPTION: List of manually implemented classes in ASP.NET Core with references to corresponding GitHub issues and pull requests. Includes RenderTreeFrame for Components and PageParameterModel/PagePropertyModel for MVC.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/eng/GenAPI.exclusions.txt#2025-04-08_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# Manually implemented - https://github.com/dotnet/arcade/pull/2033\nT:Microsoft.AspNetCore.Components.RenderTree.RenderTreeFrame\n# Manually implemented - https://github.com/dotnet/arcade/issues/2066\nT:Microsoft.AspNetCore.Mvc.ApplicationModels.PageParameterModel\nT:Microsoft.AspNetCore.Mvc.ApplicationModels.PagePropertyModel\n```\n\n----------------------------------------\n\nTITLE: Cloning ASP.NET Core Repository with Submodules\nDESCRIPTION: Command to clone the ASP.NET Core repository including all submodules recursively.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Submodules.md#2025-04-08_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/dotnet/aspnetcore.git --recursive\n```\n\n----------------------------------------\n\nTITLE: Extending IWebHost with RunAsService Method for Windows Service Execution\nDESCRIPTION: This static class provides an extension method for IWebHost to run the web application as a Windows Service.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/WindowsServices/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Hosting.WindowsServices.WebHostWindowsServiceExtensions\nstatic Microsoft.AspNetCore.Hosting.WindowsServices.WebHostWindowsServiceExtensions.RunAsService(this Microsoft.AspNetCore.Hosting.IWebHost! host) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing OpenAPI Options Class in C#\nDESCRIPTION: Defines the OpenApiOptions class with methods for adding transformers and configuring OpenAPI behavior.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.OpenApi.OpenApiOptions.AddDocumentTransformer(Microsoft.AspNetCore.OpenApi.IOpenApiDocumentTransformer! transformer) -> Microsoft.AspNetCore.OpenApi.OpenApiOptions!\nMicrosoft.AspNetCore.OpenApi.OpenApiOptions.AddOperationTransformer(Microsoft.AspNetCore.OpenApi.IOpenApiOperationTransformer! transformer) -> Microsoft.AspNetCore.OpenApi.OpenApiOptions!\nMicrosoft.AspNetCore.OpenApi.OpenApiOptions.AddSchemaTransformer(Microsoft.AspNetCore.OpenApi.IOpenApiSchemaTransformer! transformer) -> Microsoft.AspNetCore.OpenApi.OpenApiOptions!\n```\n\n----------------------------------------\n\nTITLE: Handling Circuit Closed Event in Blazor Server\nDESCRIPTION: Virtual method in CircuitHandler that's called when a Blazor server circuit is closed. Provides a hook for custom logic when a circuit terminates.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandler.OnCircuitClosedAsync(Microsoft.AspNetCore.Components.Server.Circuits.Circuit! circuit, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Enabling Azure App Services Integration in ASP.NET Core Web Host\nDESCRIPTION: Extension method that configures an IWebHostBuilder to use Azure App Services integration. This enables ASP.NET Core applications to properly integrate with Azure App Services hosting environment features.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Azure/AzureAppServicesIntegration/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Hosting.AppServicesWebHostBuilderExtensions.UseAzureAppServices(this Microsoft.AspNetCore.Hosting.IWebHostBuilder! hostBuilder) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants in ASP.NET Core\nDESCRIPTION: This generated code defines constants for common content types used in HTTP requests and responses, including JSON, plain text, form data, and URL-encoded forms.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Entity Framework Core Services in ASP.NET Core\nDESCRIPTION: This code snippet shows how to add and configure Entity Framework Core services to an ASP.NET Core application's service collection. It includes options for enabling sensitive data logging and detailed errors.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n\nbuilder.Services.AddDbContext<ApplicationDbContext>(options =>\n    options.UseSqlServer(connectionString));\nbuilder.Services.AddDatabaseDeveloperPageExceptionFilter();\n\n// Enable sensitive data logging and detailed errors.\nbuilder.Services.AddDbContext<ApplicationDbContext>((sp, options) =>\n{\n    options.UseSqlServer(connectionString);\n    options.EnableSensitiveDataLogging();\n    options.EnableDetailedErrors();\n});\n```\n\n----------------------------------------\n\nTITLE: Property Column Definition in QuickGrid\nDESCRIPTION: Generic class definition for property-bound columns in QuickGrid with formatting and property expression support.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/QuickGrid/Microsoft.AspNetCore.Components.QuickGrid/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.QuickGrid.PropertyColumn<TGridItem, TProp> {\n    string? Format { get; set; }\n    Expression<Func<TGridItem, TProp>> Property { get; set; }\n    void PropertyColumn()\n}\n```\n\n----------------------------------------\n\nTITLE: Property Column Definition in QuickGrid\nDESCRIPTION: Generic class definition for property-bound columns in QuickGrid with formatting and property expression support.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/QuickGrid/Microsoft.AspNetCore.Components.QuickGrid/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.QuickGrid.PropertyColumn<TGridItem, TProp> {\n    string? Format { get; set; }\n    Expression<Func<TGridItem, TProp>> Property { get; set; }\n    void PropertyColumn()\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: This directive enables nullable reference type annotations in C#, allowing the compiler to perform static analysis to help prevent null reference exceptions. When enabled, reference types are non-nullable by default, and nullable reference types must be explicitly marked with a '?' suffix.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/WsFederation/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining Environment Constants in C#\nDESCRIPTION: Defines constants for common environment names used in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Hosting.EnvironmentName.Development -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.EnvironmentName.Production -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.EnvironmentName.Staging -> string!\n```\n\n----------------------------------------\n\nTITLE: Defining Environment Constants in C#\nDESCRIPTION: Defines constants for common environment names used in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Hosting.EnvironmentName.Development -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.EnvironmentName.Production -> string!\nstatic readonly Microsoft.AspNetCore.Hosting.EnvironmentName.Staging -> string!\n```\n\n----------------------------------------\n\nTITLE: Defining RazorCompiledItem Class in C#\nDESCRIPTION: Declaration of the RazorCompiledItem class in the Microsoft.AspNetCore.Razor.Hosting namespace. This class represents a compiled Razor item.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Razor/Razor.Runtime/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Razor.Hosting.RazorCompiledItem\nMicrosoft.AspNetCore.Razor.Hosting.RazorCompiledItem.RazorCompiledItem() -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling and Logging in ASP.NET Core Request Processing\nDESCRIPTION: A helper class that provides consistent error handling and logging for request processing, with support for either throwing exceptions or logging issues based on configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n\n    public void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n\n    public void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n\n    public void ImplicitBodyNotProvided(string parameterName)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n\n    public void UnexpectedJsonContentType(string? contentType)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n            throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n\n    public void UnexpectedNonFormContentType(string? contentType)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n            throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n\n    public void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n}\n```\n\n----------------------------------------\n\nTITLE: WebSocketManager Virtual Methods in ASP.NET Core\nDESCRIPTION: Defines virtual methods for WebSocket connection acceptance with optional configuration context\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\nvirtual Microsoft.AspNetCore.Http.WebSocketManager.AcceptWebSocketAsync() -> System.Threading.Tasks.Task<System.Net.WebSockets.WebSocket!>!\nvirtual Microsoft.AspNetCore.Http.WebSocketManager.AcceptWebSocketAsync(Microsoft.AspNetCore.Http.WebSocketAcceptContext! acceptContext) -> System.Threading.Tasks.Task<System.Net.WebSockets.WebSocket!>!\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a custom attribute 'InterceptsLocationAttribute' used for method interception. This attribute is applied to methods and can be used multiple times.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Enables nullable reference type checking using the #nullable enable directive. This enforces compile-time checks for potential null references, making code more reliable and safer.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ConcurrencyLimiter/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a custom attribute 'InterceptsLocationAttribute' used for method interception. This attribute is applied to methods and can be used multiple times.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsString_Has_Metadata.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ParameterBindingMetadata Class in C#\nDESCRIPTION: This class represents metadata for parameter binding, including information about TryParse and BindAsync methods, as well as optional parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Model Metadata Provider Abstract Methods in C#\nDESCRIPTION: Abstract method declarations for ModelMetadataProvider class that define methods for retrieving metadata about models, properties, and parameters in ASP.NET Core MVC.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadataProvider.GetMetadataForParameter(System.Reflection.ParameterInfo! parameter) -> Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata!\nabstract Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadataProvider.GetMetadataForProperties(System.Type! modelType) -> System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata!>!\nabstract Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadataProvider.GetMetadataForType(System.Type! modelType) -> Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata!\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive that enables nullable reference type checks in C# code. This improves type safety by making null-state analysis explicit in the compiler.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/RateLimiting/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining Authorization Handlers in C#\nDESCRIPTION: This snippet shows the signature for overriding HandleRequirementAsync methods in various authorization requirement classes. These methods are responsible for implementing the logic to determine if a user meets specific authorization requirements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Authorization.Infrastructure.NameAuthorizationRequirement.HandleRequirementAsync(Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext! context, Microsoft.AspNetCore.Authorization.Infrastructure.NameAuthorizationRequirement! requirement) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.Authorization.Infrastructure.RolesAuthorizationRequirement.HandleRequirementAsync(Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext! context, Microsoft.AspNetCore.Authorization.Infrastructure.RolesAuthorizationRequirement! requirement) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: DefaultSessionFeature in ASP.NET Core\nDESCRIPTION: Default implementation of session feature for ASP.NET Core. It provides a container for the ISession implementation, enabling session state management in HTTP requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Features.DefaultSessionFeature\nMicrosoft.AspNetCore.Http.Features.DefaultSessionFeature.DefaultSessionFeature() -> void\nMicrosoft.AspNetCore.Http.Features.DefaultSessionFeature.Session.get -> Microsoft.AspNetCore.Http.ISession!\nMicrosoft.AspNetCore.Http.Features.DefaultSessionFeature.Session.set -> void\n```\n\n----------------------------------------\n\nTITLE: Installing and Running T4 Template Generator for ASP.NET Core\nDESCRIPTION: Instructions for installing the dotnet-t4 tool globally and running it to generate code from T4 templates. This is used for code generation in the HTTP Results component.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> dotnet tool install -g dotnet-t4\n> t4 Http.Results\\ResultsCache.StatusCodes.tt\n```\n\n----------------------------------------\n\nTITLE: DefaultConnectionContext Property Overrides\nDESCRIPTION: Override declarations for properties in DefaultConnectionContext class including Items, EndPoints, and Transport properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/netstandard2.1/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.Items.get -> System.Collections.Generic.IDictionary<object!, object?>!\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.Items.set -> void\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.LocalEndPoint.get -> System.Net.EndPoint?\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.LocalEndPoint.set -> void\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.RemoteEndPoint.get -> System.Net.EndPoint?\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.RemoteEndPoint.set -> void\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.Transport.get -> System.IO.Pipelines.IDuplexPipe!\noverride Microsoft.AspNetCore.Connections.DefaultConnectionContext.Transport.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining FileHandleType Enumeration in C#\nDESCRIPTION: Enumeration defining types of file handles for connection endpoints. Includes Auto (0), Tcp (1), and Pipe (2) options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Connections.FileHandleType.Auto = 0\nMicrosoft.AspNetCore.Connections.FileHandleType.Tcp = 1\nMicrosoft.AspNetCore.Connections.FileHandleType.Pipe = 2\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive to enable nullable reference type checks in C# code. This enforces more strict null-checking at compile time.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Localization.Routing/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implicit Body Missing Handler in C#\nDESCRIPTION: Handles cases where an implicit body parameter is expected but no request body was provided. Suggests potential service usage as an alternative.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic void ImplicitBodyNotProvided(string parameterName)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Parameter Binding Metadata in C#\nDESCRIPTION: This class represents metadata for parameter binding in ASP.NET Core. It includes properties for the parameter name, type information, and binding capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a custom attribute InterceptsLocationAttribute used for method interception in the System.Runtime.CompilerServices namespace.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EndpointConfiguration Class in C#\nDESCRIPTION: This snippet defines the EndpointConfiguration class, which is used to configure endpoints in Kestrel, including HTTPS options and listen options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Server.Kestrel.EndpointConfiguration\nMicrosoft.AspNetCore.Server.Kestrel.EndpointConfiguration.ConfigSection.get -> Microsoft.Extensions.Configuration.IConfigurationSection!\nMicrosoft.AspNetCore.Server.Kestrel.EndpointConfiguration.HttpsOptions.get -> Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions!\nMicrosoft.AspNetCore.Server.Kestrel.EndpointConfiguration.IsHttps.get -> bool\nMicrosoft.AspNetCore.Server.Kestrel.EndpointConfiguration.ListenOptions.get -> Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions!\n```\n\n----------------------------------------\n\nTITLE: BaseConnectionContext Virtual Methods\nDESCRIPTION: Virtual method implementations for BaseConnectionContext including connection state management and endpoint handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.ConnectionClosed.get -> System.Threading.CancellationToken\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.ConnectionClosed.set -> void\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.DisposeAsync() -> System.Threading.Tasks.ValueTask\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.LocalEndPoint.get -> System.Net.EndPoint?\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.LocalEndPoint.set -> void\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.RemoteEndPoint.get -> System.Net.EndPoint?\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.RemoteEndPoint.set -> void\n```\n\n----------------------------------------\n\nTITLE: Querying Helix Job Data for Test Project Runtime Analysis\nDESCRIPTION: This Kusto query retrieves the top 20 longest-running test projects for a specific Helix job. It helps identify bottlenecks in test execution by showing which projects take the most time to complete.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Helix.md#2025-04-08_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nWorkItems\n| where JobName == \"bc108374-750c-4084-853e-bc5b9b0d553e\"\n| where Name != JobName\n| extend RunTime = Finished-Started\n| top 20 by RunTime desc\n| project FriendlyName, RunTime\n```\n\n----------------------------------------\n\nTITLE: Authorization Options Configuration Methods in C#\nDESCRIPTION: Methods for configuring authorization options, including adding policies and retrieving policies by name. These methods are used during application startup to configure authorization behavior.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.AddPolicy(string! name, Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy) -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.AddPolicy(string! name, System.Action<Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!>! configurePolicy) -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationOptions.GetPolicy(string! name) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicy?\n```\n\n----------------------------------------\n\nTITLE: Implementing MapCore Method for Route Handling in C#\nDESCRIPTION: Defines a MapCore method that serves as a central point for mapping routes. It utilizes RouteHandlerServices to create the actual route handler.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_MultipleSpecialTypeParam_StringReturn.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C# for ASP.NET Core\nDESCRIPTION: This directive enables nullable reference types for the entire file or project. It allows the compiler to perform static analysis to help prevent null reference exceptions by distinguishing between nullable and non-nullable reference types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/Cryptography.KeyDerivation/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive that enables nullable reference type checking at the file level. This enforces more strict null checking and helps prevent null reference exceptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Logging.AzureAppServices/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing FilterContext Class in C#\nDESCRIPTION: Base class implementation for filter contexts in ASP.NET Core MVC, providing common functionality for various filter types including authorization and exception handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Filters.FilterContext.FilterContext(Microsoft.AspNetCore.Mvc.ActionContext! actionContext, System.Collections.Generic.IList<Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata!>! filters) -> void\nMicrosoft.AspNetCore.Mvc.Filters.FilterContext.FindEffectivePolicy<TMetadata>() -> TMetadata\nMicrosoft.AspNetCore.Mvc.Filters.FilterContext.IsEffectivePolicy<TMetadata>(TMetadata policy) -> bool\n```\n\n----------------------------------------\n\nTITLE: WebSocket Connection Test\nDESCRIPTION: Command to test 10,000 WebSocket connections using 10 workers against a local server.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/perf/benchmarkapps/Crankier/Readme.md#2025-04-08_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- local --target-url https://localhost:5001/echo --workers 10\n```\n\n----------------------------------------\n\nTITLE: Updating Trimmer Warning Suppressions for .NET Project\nDESCRIPTION: This command builds the project and generates new linker warning suppressions. It updates the WarningSuppressions.xml files associated with the projects to baseline new trimmer warnings or remove resolved suppressions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/testassets/WasmLinkerTest/README.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet build /p:GenerateLinkerWarningSuppressions=true\n```\n\n----------------------------------------\n\nTITLE: Implementing PassThroughAuthorizationHandler in C#\nDESCRIPTION: Provides a pass-through authorization handler that can be used as a base for custom authorization handlers in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.Infrastructure.PassThroughAuthorizationHandler\nMicrosoft.AspNetCore.Authorization.Infrastructure.PassThroughAuthorizationHandler.HandleAsync(Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext! context) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Authorization.Infrastructure.PassThroughAuthorizationHandler.PassThroughAuthorizationHandler() -> void\nMicrosoft.AspNetCore.Authorization.Infrastructure.PassThroughAuthorizationHandler.PassThroughAuthorizationHandler(Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Authorization.AuthorizationOptions!>! options) -> void\n```\n\n----------------------------------------\n\nTITLE: OpenAPI 3.0.4 API Specification for ASP.NET Core Controllers\nDESCRIPTION: Complete OpenAPI specification defining API endpoints, request/response schemas, and component definitions. Includes paths for getting data by ID and name, retrieving typed results, and handling form submissions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/test/Microsoft.AspNetCore.OpenApi.Tests/Integration/snapshots/OpenApi3_0/OpenApiDocumentIntegrationTests.VerifyOpenApiDocument_documentName=controllers.verified.txt#2025-04-08_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"openapi\": \"3.0.4\",\n  \"info\": {\n    \"title\": \"Sample | controllers\",\n    \"version\": \"1.0.0\"\n  },\n  \"paths\": {\n    \"/getbyidandname/{id}/{name}\": {\n      \"get\": {\n        \"tags\": [\n          \"Test\"\n        ],\n        \"parameters\": [\n          {\n            \"name\": \"Id\",\n            \"in\": \"path\",\n            \"required\": true,\n            \"schema\": {\n              \"type\": \"integer\",\n              \"format\": \"int32\"\n            }\n          },\n          {\n            \"name\": \"Name\",\n            \"in\": \"path\",\n            \"required\": true,\n            \"schema\": {\n              \"minLength\": 5,\n              \"type\": \"string\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"text/plain\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              },\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              },\n              \"text/json\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"/gettypedresult\": {\n      \"get\": {\n        \"tags\": [\n          \"Test\"\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/MvcTodo\"\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"/forms\": {\n      \"post\": {\n        \"tags\": [\n          \"Test\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/x-www-form-urlencoded\": {\n              \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                  \"Title\": {\n                    \"type\": \"string\"\n                  },\n                  \"Description\": {\n                    \"type\": \"string\"\n                  },\n                  \"IsCompleted\": {\n                    \"type\": \"boolean\"\n                  }\n                }\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"MvcTodo\": {\n        \"required\": [\n          \"title\",\n          \"description\",\n          \"isCompleted\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"title\": {\n            \"type\": \"string\"\n          },\n          \"description\": {\n            \"type\": \"string\"\n          },\n          \"isCompleted\": {\n            \"type\": \"boolean\"\n          }\n        }\n      }\n    }\n  },\n  \"tags\": [\n    {\n      \"name\": \"Test\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Document Property in OpenAPI Operation Transformer Context\nDESCRIPTION: Property and initializer for accessing the OpenApiDocument in an OpenApiOperationTransformerContext. The property is nullable and can be initialized.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.OpenApi.OpenApiOperationTransformerContext.Document.get -> Microsoft.OpenApi.Models.OpenApiDocument?\nMicrosoft.AspNetCore.OpenApi.OpenApiOperationTransformerContext.Document.init -> void\n```\n\n----------------------------------------\n\nTITLE: Form Input HTML Helpers in ASP.NET Core MVC\nDESCRIPTION: Extension methods for generating HTML form input elements like radio buttons, text areas, and text boxes. These methods provide strongly-typed and string-based approaches for creating form controls.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperInputExtensions.RadioButton(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper htmlHelper, string expression, object value) -> Microsoft.AspNetCore.Html.IHtmlContent\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperInputExtensions.TextArea(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper htmlHelper, string expression) -> Microsoft.AspNetCore.Html.IHtmlContent\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperInputExtensions.TextBox(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper htmlHelper, string expression) -> Microsoft.AspNetCore.Html.IHtmlContent\n```\n\n----------------------------------------\n\nTITLE: HSTS Middleware Implementation in C#\nDESCRIPTION: Core implementation of the HSTS middleware including constructor and Invoke method. The middleware adds HTTP Strict Transport Security headers to responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpsPolicy/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class HstsMiddleware\n{\n    public HstsMiddleware(RequestDelegate next, IOptions<HstsOptions> options);\n    public HstsMiddleware(RequestDelegate next, IOptions<HstsOptions> options, ILoggerFactory loggerFactory);\n    public Task Invoke(HttpContext context);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NullSafeCollection Abstract Class in C#\nDESCRIPTION: Defines an abstract class that wraps collections and handles null values safely by treating null collections as empty collections. The class implements ICollection<T> and provides implementations that work correctly even when the wrapped collection is null.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/OutputCaching/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Helix Content Configuration in MSBuild\nDESCRIPTION: MSBuild configuration examples showing how to include additional content in Helix test payloads, with options for basic file inclusion and custom path mapping.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Helix.md#2025-04-08_snippet_3\n\nLANGUAGE: msbuild\nCODE:\n```\n<ItemGroup>\n  <HelixContent Include=\"$(RepoRoot)src\\KeepMe.js\"/>\n  <HelixContent Include=\"$(RepoRoot)src\\Project\\**\"/>\n</ItemGroup>\n```\n\nLANGUAGE: msbuild\nCODE:\n```\n<ItemGroup>\n  <HelixContent Include=\"$(RepoRoot)src\\KeepMe.js\" Link=\"$(MSBuildThisFileDirectory)\\myassets\\KeepMe.js\"/>\n  <HelixContent Include=\"$(RepoRoot)src\\Project\\**\" LinkBase=\"$(MSBuildThisFileDirectory)\\myassets\"/>\n</ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: Defining Virtual Properties for OutputFormatterContext Classes in C#\nDESCRIPTION: Declares virtual properties for OutputFormatterCanWriteContext and OutputFormatterWriteContext classes. These properties allow customization of content type handling and writer factory functionality in output formatting.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterCanWriteContext.ContentType.get -> Microsoft.Extensions.Primitives.StringSegment\nvirtual Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterCanWriteContext.ContentType.set -> void\nvirtual Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterCanWriteContext.ContentTypeIsServerDefined.get -> bool\nvirtual Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterCanWriteContext.ContentTypeIsServerDefined.set -> void\nvirtual Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterCanWriteContext.HttpContext.get -> Microsoft.AspNetCore.Http.HttpContext!\nvirtual Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterCanWriteContext.HttpContext.set -> void\nvirtual Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterCanWriteContext.Object.get -> object?\nvirtual Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterCanWriteContext.Object.set -> void\nvirtual Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterCanWriteContext.ObjectType.get -> System.Type?\nvirtual Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterCanWriteContext.ObjectType.set -> void\nvirtual Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterWriteContext.WriterFactory.get -> System.Func<System.IO.Stream!, System.Text.Encoding!, System.IO.TextWriter!>!\nvirtual Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterWriteContext.WriterFactory.set -> void\n```\n\n----------------------------------------\n\nTITLE: Building IIS Project with PowerShell\nDESCRIPTION: Command to build the IIS project from source using PowerShell build script.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/IIS/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: Fixing Formatting in Generated WarningSuppressions.xml\nDESCRIPTION: This diff shows how to manually correct formatting issues in the generated WarningSuppressions.xml file for compiler-generated nested types. It replaces curly braces with angle brackets in method names.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/testassets/WasmLinkerTest/README.md#2025-04-08_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n- LegacyRouteTableFactory.&lt;&gt;c.{Create}b__2_1(System.Reflection.Assembly)\n+ LegacyRouteTableFactory.&lt;&gt;c.&lt;Create&gt;b__2_1(System.Reflection.Assembly)\n```\n\n----------------------------------------\n\nTITLE: Connection Feature Interfaces in C#\nDESCRIPTION: Defines interfaces for various connection features like connection completion, endpoints, heartbeat, identifier, keepalive, lifetime management, metrics, socket access, and transport configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Connections.Abstractions.IStatefulReconnectFeature\nMicrosoft.AspNetCore.Connections.Abstractions.IStatefulReconnectFeature.DisableReconnect() -> void\nMicrosoft.AspNetCore.Connections.Abstractions.IStatefulReconnectFeature.OnReconnected(System.Func<System.IO.Pipelines.PipeWriter!, System.Threading.Tasks.Task!>! notifyOnReconnect) -> void\nMicrosoft.AspNetCore.Connections.Features.IConnectionCompleteFeature\nMicrosoft.AspNetCore.Connections.Features.IConnectionCompleteFeature.OnCompleted(System.Func<object!, System.Threading.Tasks.Task!>! callback, object! state) -> void\nMicrosoft.AspNetCore.Connections.Features.IConnectionEndPointFeature\nMicrosoft.AspNetCore.Connections.Features.IConnectionEndPointFeature.LocalEndPoint.get -> System.Net.EndPoint?\nMicrosoft.AspNetCore.Connections.Features.IConnectionEndPointFeature.LocalEndPoint.set -> void\nMicrosoft.AspNetCore.Connections.Features.IConnectionEndPointFeature.RemoteEndPoint.get -> System.Net.EndPoint?\nMicrosoft.AspNetCore.Connections.Features.IConnectionEndPointFeature.RemoteEndPoint.set -> void\nMicrosoft.AspNetCore.Connections.Features.IConnectionHeartbeatFeature\nMicrosoft.AspNetCore.Connections.Features.IConnectionHeartbeatFeature.OnHeartbeat(System.Action<object!>! action, object! state) -> void\nMicrosoft.AspNetCore.Connections.Features.IConnectionIdFeature\nMicrosoft.AspNetCore.Connections.Features.IConnectionIdFeature.ConnectionId.get -> string!\nMicrosoft.AspNetCore.Connections.Features.IConnectionIdFeature.ConnectionId.set -> void\nMicrosoft.AspNetCore.Connections.Features.IConnectionInherentKeepAliveFeature\nMicrosoft.AspNetCore.Connections.Features.IConnectionInherentKeepAliveFeature.HasInherentKeepAlive.get -> bool\nMicrosoft.AspNetCore.Connections.Features.IConnectionItemsFeature\nMicrosoft.AspNetCore.Connections.Features.IConnectionItemsFeature.Items.get -> System.Collections.Generic.IDictionary<object!, object?>!\nMicrosoft.AspNetCore.Connections.Features.IConnectionItemsFeature.Items.set -> void\nMicrosoft.AspNetCore.Connections.Features.IConnectionLifetimeFeature\nMicrosoft.AspNetCore.Connections.Features.IConnectionLifetimeFeature.Abort() -> void\nMicrosoft.AspNetCore.Connections.Features.IConnectionLifetimeFeature.ConnectionClosed.get -> System.Threading.CancellationToken\nMicrosoft.AspNetCore.Connections.Features.IConnectionLifetimeFeature.ConnectionClosed.set -> void\nMicrosoft.AspNetCore.Connections.Features.IConnectionLifetimeNotificationFeature\nMicrosoft.AspNetCore.Connections.Features.IConnectionLifetimeNotificationFeature.ConnectionClosedRequested.get -> System.Threading.CancellationToken\nMicrosoft.AspNetCore.Connections.Features.IConnectionLifetimeNotificationFeature.ConnectionClosedRequested.set -> void\nMicrosoft.AspNetCore.Connections.Features.IConnectionLifetimeNotificationFeature.RequestClose() -> void\nMicrosoft.AspNetCore.Connections.Features.IConnectionMetricsTagsFeature\nMicrosoft.AspNetCore.Connections.Features.IConnectionMetricsTagsFeature.Tags.get -> System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<string!, object?>>!\nMicrosoft.AspNetCore.Connections.Features.IConnectionNamedPipeFeature\nMicrosoft.AspNetCore.Connections.Features.IConnectionNamedPipeFeature.NamedPipe.get -> System.IO.Pipes.NamedPipeServerStream!\nMicrosoft.AspNetCore.Connections.Features.IConnectionSocketFeature\nMicrosoft.AspNetCore.Connections.Features.IConnectionSocketFeature.Socket.get -> System.Net.Sockets.Socket!\nMicrosoft.AspNetCore.Connections.Features.IConnectionTransportFeature\nMicrosoft.AspNetCore.Connections.Features.IConnectionTransportFeature.Transport.get -> System.IO.Pipelines.IDuplexPipe!\nMicrosoft.AspNetCore.Connections.Features.IConnectionTransportFeature.Transport.set -> void\nMicrosoft.AspNetCore.Connections.Features.IConnectionUserFeature\nMicrosoft.AspNetCore.Connections.Features.IConnectionUserFeature.User.get -> System.Security.Claims.ClaimsPrincipal?\nMicrosoft.AspNetCore.Connections.Features.IConnectionUserFeature.User.set -> void\nMicrosoft.AspNetCore.Connections.Features.IMemoryPoolFeature\nMicrosoft.AspNetCore.Connections.Features.IMemoryPoolFeature.MemoryPool.get -> System.Buffers.MemoryPool<byte>!\nMicrosoft.AspNetCore.Connections.Features.IPersistentStateFeature\nMicrosoft.AspNetCore.Connections.Features.IPersistentStateFeature.State.get -> System.Collections.Generic.IDictionary<object!, object?>!\nMicrosoft.AspNetCore.Connections.Features.IProtocolErrorCodeFeature\nMicrosoft.AspNetCore.Connections.Features.IProtocolErrorCodeFeature.Error.get -> long\nMicrosoft.AspNetCore.Connections.Features.IProtocolErrorCodeFeature.Error.set -> void\nMicrosoft.AspNetCore.Connections.Features.IStreamAbortFeature\nMicrosoft.AspNetCore.Connections.Features.IStreamAbortFeature.AbortRead(long errorCode, Microsoft.AspNetCore.Connections.ConnectionAbortedException! abortReason) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining OpenAPI 3.1.1 Specification for Sample API in JSON\nDESCRIPTION: This code snippet defines the complete OpenAPI 3.1.1 specification for a Sample API. It includes path definitions for handling arrays of GUIDs and managing todo items, along with component schemas and security schemes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/test/Microsoft.AspNetCore.OpenApi.Tests/Integration/snapshots/OpenApi3_1/OpenApiDocumentIntegrationTests.VerifyOpenApiDocument_documentName=v1.verified.txt#2025-04-08_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"openapi\": \"3.1.1\",\n  \"info\": {\n    \"title\": \"Sample | v1\",\n    \"version\": \"1.0.0\"\n  },\n  \"paths\": {\n    \"/v1/array-of-guids\": {\n      \"get\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"parameters\": [\n          {\n            \"name\": \"guids\",\n            \"in\": \"query\",\n            \"required\": true,\n            \"schema\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"string\",\n                \"format\": \"uuid\"\n              }\n            }\n          },\n          {\n            \"name\": \"X-Version\",\n            \"in\": \"header\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"default\": \"1.0\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"array\",\n                  \"items\": {\n                    \"type\": \"string\",\n                    \"format\": \"uuid\"\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"/v1/todos\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"summary\": \"Creates a new todo item.\",\n        \"parameters\": [\n          {\n            \"name\": \"X-Version\",\n            \"in\": \"header\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"default\": \"1.0\"\n            }\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/Todo\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/v1/todos/{id}\": {\n      \"get\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"description\": \"Returns a specific todo item.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"required\": true,\n            \"schema\": {\n              \"type\": \"integer\",\n              \"format\": \"int32\"\n            }\n          },\n          {\n            \"name\": \"X-Version\",\n            \"in\": \"header\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"default\": \"1.0\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/TodoWithDueDate\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"Todo\": {\n        \"required\": [\n          \"id\",\n          \"title\",\n          \"completed\",\n          \"createdAt\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"integer\",\n            \"description\": \"The unique identifier of the to-do item.\",\n            \"format\": \"int32\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"The title of the to-do item.\"\n          },\n          \"completed\": {\n            \"type\": \"boolean\",\n            \"description\": \"Indicates whether the to-do item is completed.\"\n          },\n          \"createdAt\": {\n            \"type\": \"string\",\n            \"description\": \"The date and time when the to-do item was created.\",\n            \"format\": \"date-time\"\n          }\n        },\n        \"description\": \"Represents a to-do item.\"\n      },\n      \"TodoWithDueDate\": {\n        \"required\": [\n          \"dueDate\",\n          \"id\",\n          \"title\",\n          \"completed\",\n          \"createdAt\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"dueDate\": {\n            \"type\": \"string\",\n            \"description\": \"The due date of the to-do item.\",\n            \"format\": \"date-time\"\n          },\n          \"id\": {\n            \"type\": \"integer\",\n            \"description\": \"The unique identifier of the to-do item.\",\n            \"format\": \"int32\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"The title of the to-do item.\"\n          },\n          \"completed\": {\n            \"type\": \"boolean\",\n            \"description\": \"Indicates whether the to-do item is completed.\"\n          },\n          \"createdAt\": {\n            \"type\": \"string\",\n            \"description\": \"The date and time when the to-do item was created.\",\n            \"format\": \"date-time\"\n          }\n        },\n        \"description\": \"Represents a to-do item with a due date.\"\n      }\n    },\n    \"securitySchemes\": {\n      \"Bearer\": {\n        \"type\": \"http\",\n        \"scheme\": \"bearer\",\n        \"bearerFormat\": \"Json Web Token\"\n      }\n    }\n  },\n  \"tags\": [\n    {\n      \"name\": \"Sample\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Building dotnet/runtime in PowerShell\nDESCRIPTION: Command to build the dotnet/runtime repository with specific configuration and subset.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Shared/runtime/ReadMe.SharedCode.md#2025-04-08_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS D:\\github\\runtime> .\\build.cmd -runtimeConfiguration Release  -subset clr+libs\n```\n\n----------------------------------------\n\nTITLE: Action Result and Filter Methods in ASP.NET Core MVC\nDESCRIPTION: Virtual methods for handling action results and applying filters. Includes methods for formatting object results and implementing the Produces attribute behavior during result execution.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_68\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ObjectResult.OnFormatting(Microsoft.AspNetCore.Mvc.ActionContext! context) -> void\nvirtual Microsoft.AspNetCore.Mvc.ProducesAttribute.OnResultExecuted(Microsoft.AspNetCore.Mvc.Filters.ResultExecutedContext! context) -> void\nvirtual Microsoft.AspNetCore.Mvc.ProducesAttribute.OnResultExecuting(Microsoft.AspNetCore.Mvc.Filters.ResultExecutingContext! context) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining SignalR Specific Message Classes\nDESCRIPTION: Specialized message classes for different SignalR operations including invocation, pinging, streaming, and raw data handling. Each class has specific properties relevant to its operation type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationMessage\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationMessage.InvocationMessage(string! target, object?[]! arguments) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationMessage.InvocationMessage(string? invocationId, string! target, object?[]! arguments) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationMessage.InvocationMessage(string? invocationId, string! target, object?[]! arguments, string![]? streamIds) -> void\n\nMicrosoft.AspNetCore.SignalR.Protocol.PingMessage\n\nMicrosoft.AspNetCore.SignalR.Protocol.RawResult\nMicrosoft.AspNetCore.SignalR.Protocol.RawResult.RawResult(System.Buffers.ReadOnlySequence<byte> rawBytes) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.RawResult.RawSerializedData.get -> System.Buffers.ReadOnlySequence<byte>\n\nMicrosoft.AspNetCore.SignalR.Protocol.SequenceMessage\nMicrosoft.AspNetCore.SignalR.Protocol.SequenceMessage.SequenceId.get -> long\nMicrosoft.AspNetCore.SignalR.Protocol.SequenceMessage.SequenceId.set -> void\nMicrosoft.AspNetCore.SignalR.Protocol.SequenceMessage.SequenceMessage(long sequenceId) -> void\n```\n\n----------------------------------------\n\nTITLE: Running Tests for Azure App Service Integration Projects in PowerShell\nDESCRIPTION: Command to run tests for the Azure App Service integration projects. This assumes all prerequisites have been set up and the command is run from the project directory.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Azure/README.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd -t\n```\n\n----------------------------------------\n\nTITLE: Building the SignalR Project on Windows\nDESCRIPTION: Command to build the ASP.NET Core SignalR project on Windows systems using PowerShell. This will compile the entire project including Java and TypeScript components unless specified otherwise.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: Defining OpenAPI Document Transformer Interface in C#\nDESCRIPTION: Defines the IOpenApiDocumentTransformer interface with a TransformAsync method for transforming OpenAPI documents.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.OpenApi.IOpenApiDocumentTransformer.TransformAsync(Microsoft.OpenApi.Models.OpenApiDocument! document, Microsoft.AspNetCore.OpenApi.OpenApiDocumentTransformerContext! context, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core OpenAPI Integration Extensions\nDESCRIPTION: Extension methods for configuring OpenAPI/Swagger documentation, including request/response types, descriptions, and content types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.OpenApiRouteHandlerBuilderExtensions.Accepts<TRequest>(this Microsoft.AspNetCore.Builder.RouteHandlerBuilder! builder, string! contentType, params string![]! additionalContentTypes) -> Microsoft.AspNetCore.Builder.RouteHandlerBuilder!\n\nstatic Microsoft.AspNetCore.Http.OpenApiRouteHandlerBuilderExtensions.Produces<TResponse>(this Microsoft.AspNetCore.Builder.RouteHandlerBuilder! builder, int statusCode = 200, string? contentType = null, params string![]! additionalContentTypes) -> Microsoft.AspNetCore.Builder.RouteHandlerBuilder!\n```\n\n----------------------------------------\n\nTITLE: Viewing Submodule Changes in Git Diff\nDESCRIPTION: Command to view changes in submodules compared to the last parent repository commit.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Submodules.md#2025-04-08_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit diff --submodule\n```\n\n----------------------------------------\n\nTITLE: HTTP Header Dictionary Implementation\nDESCRIPTION: Provides dictionary implementation for HTTP headers with specialized handling for content length and other common headers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic class HeaderDictionary {\n    public long? ContentLength { get; set; }\n    public int Count { get; }\n    \n    public void Add(string key, StringValues value);\n    public void Clear();\n    public bool ContainsKey(string key);\n    public bool Contains(KeyValuePair<string, StringValues> item);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining File Result Methods in C#\nDESCRIPTION: These methods create file results for byte arrays and streams with various options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.File(byte[]! fileContents, string? contentType = null, string? fileDownloadName = null, bool enableRangeProcessing = false, System.DateTimeOffset? lastModified = null, Microsoft.Net.Http.Headers.EntityTagHeaderValue? entityTag = null) -> Microsoft.AspNetCore.Http.HttpResults.FileContentHttpResult!\nstatic Microsoft.AspNetCore.Http.TypedResults.File(System.IO.Stream! fileStream, string? contentType = null, string? fileDownloadName = null, System.DateTimeOffset? lastModified = null, Microsoft.Net.Http.Headers.EntityTagHeaderValue? entityTag = null, bool enableRangeProcessing = false) -> Microsoft.AspNetCore.Http.HttpResults.FileStreamHttpResult!\n```\n\n----------------------------------------\n\nTITLE: Defining Authentication Challenge Result Method in C#\nDESCRIPTION: This method creates an authentication challenge result with optional properties and schemes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.Challenge(Microsoft.AspNetCore.Authentication.AuthenticationProperties? properties = null, System.Collections.Generic.IList<string!>? authenticationSchemes = null) -> Microsoft.AspNetCore.Http.HttpResults.ChallengeHttpResult!\n```\n\n----------------------------------------\n\nTITLE: Registering SignalR Client Event Handlers with 'On' Extension Methods in C#\nDESCRIPTION: Various overloads of the On extension method for HubConnection that allow registering callbacks for SignalR server-to-client method invocations. These methods support different numbers of generic parameters, return types, and both Action and Func delegates for synchronous and asynchronous handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2, T3, T4, T5, T6>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<T1, T2, T3, T4, T5, T6, System.Threading.Tasks.Task!>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2, T3, T4, T5, TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<T1, T2, T3, T4, T5, System.Threading.Tasks.Task<TResult>!>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2, T3, T4, T5, TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<T1, T2, T3, T4, T5, TResult>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2, T3, T4, T5>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Action<T1, T2, T3, T4, T5>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2, T3, T4, T5>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<T1, T2, T3, T4, T5, System.Threading.Tasks.Task!>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2, T3, T4, TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<T1, T2, T3, T4, System.Threading.Tasks.Task<TResult>!>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2, T3, T4, TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<T1, T2, T3, T4, TResult>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2, T3, T4>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Action<T1, T2, T3, T4>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2, T3, T4>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<T1, T2, T3, T4, System.Threading.Tasks.Task!>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2, T3, TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<T1, T2, T3, System.Threading.Tasks.Task<TResult>!>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2, T3, TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<T1, T2, T3, TResult>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2, T3>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Action<T1, T2, T3>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2, T3>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<T1, T2, T3, System.Threading.Tasks.Task!>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2, TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<T1, T2, System.Threading.Tasks.Task<TResult>!>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2, TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<T1, T2, TResult>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Action<T1, T2>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, T2>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<T1, T2, System.Threading.Tasks.Task!>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<T1, System.Threading.Tasks.Task<TResult>!>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1, TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<T1, TResult>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Action<T1>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<T1>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<T1, System.Threading.Tasks.Task!>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<System.Threading.Tasks.Task<TResult>!>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Func<TResult>! handler) -> System.IDisposable!\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.On<TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, System.Type![]! parameterTypes, System.Func<object?[]!, System.Threading.Tasks.Task<TResult>!>! handler) -> System.IDisposable!\n```\n\n----------------------------------------\n\nTITLE: Listing Available ASP.NET Core Benchmarks\nDESCRIPTION: Command to display an interactive list of all available benchmarks for selection. Requires Release configuration and target framework specification.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/perf/Microbenchmarks/readme.md#2025-04-08_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ndotnet run -c Release --framework <tfm>\n```\n\n----------------------------------------\n\nTITLE: Implementing Parameter Binding Metadata in ASP.NET Core\nDESCRIPTION: This class implements the IParameterBindingMetadata interface, providing information about parameter binding, including name, type, and parsing capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_MultipleStringParam_StringReturn.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting PowerShell Execution Policy in Windows\nDESCRIPTION: Command to update PowerShell execution policy to RemoteSigned for the current user, allowing local PowerShell scripts to run.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/BuildFromSource.md#2025-04-08_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n```\n\n----------------------------------------\n\nTITLE: Running All ASP.NET Core Benchmarks\nDESCRIPTION: Executes all available benchmarks in Release configuration using the 'All' parameter\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/perf/Microbenchmarks/README.md#2025-04-08_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ndotnet run -c Release All\n```\n\n----------------------------------------\n\nTITLE: Updating All Submodules to Latest Remote Version\nDESCRIPTION: Command to update all submodules to the latest version available in their respective remote repositories.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Submodules.md#2025-04-08_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit submodule update --remote\n```\n\n----------------------------------------\n\nTITLE: Defining ResourceLocationAttribute Class in C#\nDESCRIPTION: Creates an attribute class for specifying resource locations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Localization/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Localization.ResourceLocationAttribute.ResourceLocation.get -> string!\nMicrosoft.Extensions.Localization.ResourceLocationAttribute.ResourceLocationAttribute(string! resourceLocation) -> void\n```\n\n----------------------------------------\n\nTITLE: Retrieving Connection ID in C# for ASP.NET Core\nDESCRIPTION: This extension method retrieves the connection ID from the HttpContext. It checks for the presence of the IConnectionIdFeature and returns the ConnectionId if available.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Transport.NamedPipes/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic static string? GetConnectionId(this HttpContext context)\n{\n    return context.Features.Get<IConnectionIdFeature>()?.ConnectionId;\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Type Compatibility Check for Serialization\nDESCRIPTION: Determines if the JsonTypeInfo should be used with a given runtime type by checking type compatibility and polymorphism configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\n----------------------------------------\n\nTITLE: Long Polling Connection Test\nDESCRIPTION: Command to test 5,000 Long Polling connections against a local server.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/perf/benchmarkapps/Crankier/Readme.md#2025-04-08_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- local --target-url https://localhost:5001/echo --connections 5000 --transport LongPolling\n```\n\n----------------------------------------\n\nTITLE: Extending HttpContext for IIS Server Variables in C#\nDESCRIPTION: This static method extends HttpContext to retrieve IIS server variables in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/IIS/IIS/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Server.IIS.HttpContextExtensions.GetIISServerVariable(this Microsoft.AspNetCore.Http.HttpContext! context, string! variableName) -> string?\n```\n\n----------------------------------------\n\nTITLE: Installing WebAssembly Server Package with .NET CLI\nDESCRIPTION: Command to install the Microsoft.AspNetCore.Components.WebAssembly.Server NuGet package using the .NET CLI.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/Server/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.Components.WebAssembly.Server\n```\n\n----------------------------------------\n\nTITLE: Testing ASP.NET Core Certificate Authentication\nDESCRIPTION: Command to run tests for the certificate authentication project from within the parent security directory\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Certificate/src/README.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd -t\n```\n\n----------------------------------------\n\nTITLE: Building Microsoft.AspNetCore.App Runtime Project in PowerShell\nDESCRIPTION: This PowerShell command builds the Microsoft.AspNetCore.App shared framework project to resolve issues with missing runtime components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/BuildErrors.md#2025-04-08_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\n.\\build.cmd -projects src\\Framework\\App.Runtime\\src\\Microsoft.AspNetCore.App.Runtime.csproj\n```\n\n----------------------------------------\n\nTITLE: Database Error Page Middleware Implementation in ASP.NET Core (C#)\nDESCRIPTION: Middleware implementation that intercepts database-related exceptions and displays diagnostic information. Includes the constructor for dependency injection and the Invoke method that processes HTTP requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics.EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Diagnostics.EntityFrameworkCore.DatabaseErrorPageMiddleware.DatabaseErrorPageMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Builder.DatabaseErrorPageOptions!>! options) -> void\nvirtual Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore.DatabaseErrorPageMiddleware.Invoke(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining RouteBuilder Class in C#\nDESCRIPTION: This snippet defines the RouteBuilder class with properties and methods for building routes, including ApplicationBuilder, DefaultHandler, and Routes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Routing.RouteBuilder\nMicrosoft.AspNetCore.Routing.RouteBuilder.ApplicationBuilder.get -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\nMicrosoft.AspNetCore.Routing.RouteBuilder.Build() -> Microsoft.AspNetCore.Routing.IRouter!\nMicrosoft.AspNetCore.Routing.RouteBuilder.DefaultHandler.get -> Microsoft.AspNetCore.Routing.IRouter?\nMicrosoft.AspNetCore.Routing.RouteBuilder.DefaultHandler.set -> void\nMicrosoft.AspNetCore.Routing.RouteBuilder.RouteBuilder(Microsoft.AspNetCore.Builder.IApplicationBuilder! applicationBuilder) -> void\nMicrosoft.AspNetCore.Routing.RouteBuilder.RouteBuilder(Microsoft.AspNetCore.Builder.IApplicationBuilder! applicationBuilder, Microsoft.AspNetCore.Routing.IRouter? defaultHandler) -> void\nMicrosoft.AspNetCore.Routing.RouteBuilder.Routes.get -> System.Collections.Generic.IList<Microsoft.AspNetCore.Routing.IRouter!>!\nMicrosoft.AspNetCore.Routing.RouteBuilder.ServiceProvider.get -> System.IServiceProvider!\n```\n\n----------------------------------------\n\nTITLE: TestServer Class Methods and Properties\nDESCRIPTION: Core class for in-memory testing of ASP.NET Core applications. Provides methods for creating HTTP clients, handling requests, and managing server configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/TestHost/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class TestServer : IDisposable\n{\n    public bool AllowSynchronousIO { get; set; }\n    public Uri BaseAddress { get; set; }\n    public IFeatureCollection Features { get; }\n    public IWebHost Host { get; }\n    public bool PreserveExecutionContext { get; set; }\n    public IServiceProvider Services { get; }\n    \n    public HttpClient CreateClient()\n    public HttpMessageHandler CreateHandler()\n    public RequestBuilder CreateRequest(string path)\n    public WebSocketClient CreateWebSocketClient()\n    public void Dispose()\n}\n```\n\n----------------------------------------\n\nTITLE: Opening Components in Visual Studio\nDESCRIPTION: Optional PowerShell command to open the Components directory in Visual Studio for development.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/README.md#2025-04-08_snippet_7\n\nLANGUAGE: powershell\nCODE:\n```\n./src/Components/startvs.cmd\n```\n\n----------------------------------------\n\nTITLE: JSON Response Serialization in ASP.NET Core\nDESCRIPTION: Serializes objects to JSON and writes them to the HTTP response. Uses runtime type information and JSON type info to optimize serialization. Includes suppression attributes for trimming and AOT concerns.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Patch Input Formatter with System.Text.Json\nDESCRIPTION: Helper method to create a NewtonsoftJsonPatchInputFormatter while maintaining System.Text.Json as the default serializer\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Features/JsonPatch/src/PACKAGE.md#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nstatic NewtonsoftJsonPatchInputFormatter GetJsonPatchInputFormatter()\n{\n    var builder = new ServiceCollection()\n        .AddLogging()\n        .AddMvc()\n        .AddNewtonsoftJson()\n        .Services.BuildServiceProvider();\n\n    return builder\n        .GetRequiredService<IOptions<MvcOptions>>()\n        .Value\n        .InputFormatters\n        .OfType<NewtonsoftJsonPatchInputFormatter>()\n        .First();\n}\n```\n\n----------------------------------------\n\nTITLE: MSAL Cache Options Configuration in C#\nDESCRIPTION: The MsalCacheOptions class configures caching behavior for MSAL authentication tokens. It includes settings for cache location and cookie-based auth state storage, affecting how authentication state is persisted in the browser.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/Authentication.Msal/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalCacheOptions\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalCacheOptions.CacheLocation.get -> string?\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalCacheOptions.CacheLocation.set -> void\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalCacheOptions.MsalCacheOptions() -> void\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalCacheOptions.StoreAuthStateInCookie.get -> bool\nMicrosoft.Authentication.WebAssembly.Msal.Models.MsalCacheOptions.StoreAuthStateInCookie.set -> void\n```\n\n----------------------------------------\n\nTITLE: Installing Visual Studio with Required Components in Windows\nDESCRIPTION: Script to install or update Visual Studio with the components required for building ASP.NET Core projects.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/BuildFromSource.md#2025-04-08_snippet_3\n\nLANGUAGE: powershell\nCODE:\n```\n./eng/scripts/InstallVisualStudio.ps1 Enterprise Preview\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected JSON Content Type in ASP.NET Core (C#)\nDESCRIPTION: Handles cases where an unsupported JSON media type is received. Either throws a BadHttpRequestException with HTTP status 415 (Unsupported Media Type) or logs the issue with the unexpected content type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Get_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedJsonContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Request Delegate for GET Request in ASP.NET Core\nDESCRIPTION: This snippet defines a method to create a request delegate for handling GET requests. It includes parameter binding, metadata population, and request processing logic.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitServiceParam_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nRequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n{\n    Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n    Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n    Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n    Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n    var handler = Cast(del, global::System.String (global::System.Collections.Generic.IEnumerable<global::Microsoft.AspNetCore.Http.Generators.Tests.TestService> arg0) => throw null!);\n    EndpointFilterDelegate? filteredInvocation = null;\n    var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n    var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n    var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n    var jsonSerializerOptions = jsonOptions.SerializerOptions;\n    jsonSerializerOptions.MakeReadOnly();\n    var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n\n    if (options.EndpointBuilder.FilterFactories.Count > 0)\n    {\n        filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n        {\n            if (ic.HttpContext.Response.StatusCode == 400)\n            {\n                return ValueTask.FromResult<object?>(Results.Empty);\n            }\n            return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::System.Collections.Generic.IEnumerable<global::Microsoft.AspNetCore.Http.Generators.Tests.TestService>>(0)!));\n        },\n        options.EndpointBuilder,\n        handler.Method);\n    }\n\n    Task RequestHandler(HttpContext httpContext)\n    {\n        var wasParamCheckFailure = false;\n        // Endpoint Parameter: svc (Type = System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Http.Generators.Tests.TestService>, IsOptional = False, IsParsable = False, IsArray = False, Source = Service)\n        var svc_local = httpContext.RequestServices.GetRequiredService<global::System.Collections.Generic.IEnumerable<global::Microsoft.AspNetCore.Http.Generators.Tests.TestService>>();\n\n        if (wasParamCheckFailure)\n        {\n            httpContext.Response.StatusCode = 400;\n            return Task.CompletedTask;\n        }\n        var result = handler(svc_local);\n        if (result is string)\n        {\n            httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n        }\n        else\n        {\n            httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n        }\n        return httpContext.Response.WriteAsync(result);\n    }\n\n    async Task RequestHandlerFiltered(HttpContext httpContext)\n    {\n        var wasParamCheckFailure = false;\n        // Endpoint Parameter: svc (Type = System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Http.Generators.Tests.TestService>, IsOptional = False, IsParsable = False, IsArray = False, Source = Service)\n        var svc_local = httpContext.RequestServices.GetRequiredService<global::System.Collections.Generic.IEnumerable<global::Microsoft.AspNetCore.Http.Generators.Tests.TestService>>();\n\n        if (wasParamCheckFailure)\n        {\n            httpContext.Response.StatusCode = 400;\n        }\n        var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::System.Collections.Generic.IEnumerable<global::Microsoft.AspNetCore.Http.Generators.Tests.TestService>>(httpContext, svc_local));\n        if (result is not null)\n        {\n            await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n        }\n    }\n\n    RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\n    var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\n    return new RequestDelegateResult(targetDelegate, metadata);\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft.AspNetCore.Components.QuickGrid via dotnet CLI\nDESCRIPTION: This command installs the Microsoft.AspNetCore.Components.QuickGrid package using the dotnet CLI. It adds the package to the current project, enabling the use of the QuickGrid component in Blazor applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/QuickGrid/Microsoft.AspNetCore.Components.QuickGrid/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.Components.QuickGrid\n```\n\n----------------------------------------\n\nTITLE: Invoking ASP.NET Core CLI Tools\nDESCRIPTION: Examples of how to invoke the ASP.NET Core command-line tools as subcommands of the dotnet CLI. These commands provide access to development certificates, OpenAPI functionality, SQL cache management, and user secrets management.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Tools/README.md#2025-04-08_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndotnet dev-certs\ndotnet openapi\ndotnet sql-cache\ndotnet user-secrets\n```\n\n----------------------------------------\n\nTITLE: Detecting Required C# Language Version Override for Release Branch\nDESCRIPTION: Code reference to the C# language version configuration that needs to be modified in the previous release branch from 'preview' to a hardcoded version when updating to a new major version.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/UpdatingMajorVersionAndTFM.md#2025-04-08_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<LangVersion>preview</LangVersion>\n```\n\n----------------------------------------\n\nTITLE: Adding Dependency Entry in Version.Details.xml\nDESCRIPTION: Example XML configuration for adding a new package dependency in Version.Details.xml, showing how to specify package version, source repository, and commit SHA.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/ReferenceResolution.md#2025-04-08_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<ProductDependencies>\n  <!-- ... -->\n  <Dependency Name=\"System.Banana\" Version=\"0.0.1-beta-1\">\n    <Uri>https://github.com/dotnet/corefx</Uri>\n    <Sha>000000</Sha>\n  </Dependency>\n  <!-- ... -->\n</ProductDependencies>\n```\n\n----------------------------------------\n\nTITLE: Two-Factor Authentication Methods in ASP.NET Core Identity\nDESCRIPTION: Methods for managing two-factor authentication, including token generation and validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Identity.TotpSecurityStampBasedTokenProvider<TUser>.GenerateAsync(string! purpose, Microsoft.AspNetCore.Identity.UserManager<TUser!>! manager, TUser! user) -> System.Threading.Tasks.Task<string!>!\nvirtual Microsoft.AspNetCore.Identity.UserManager<TUser>.GenerateNewTwoFactorRecoveryCodesAsync(TUser! user, int number) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string!>?>!\n```\n\n----------------------------------------\n\nTITLE: Defining Advanced Route Constraints in ASP.NET Core\nDESCRIPTION: This code demonstrates advanced route pattern configuration with parameter constraints in ASP.NET Core. It shows how to specify data type constraints for route parameters including regex patterns, required parameters, and optional parameters with default values.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/StaticFiles/test/FunctionalTests/SubFolder/Empty.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nendpoints.MapControllerRoute(\n    name: \"blog\",\n    pattern: \"blog/{year:int}/{month:regex(^\\\\d{{2}}$)}/{slug}\",\n    defaults: new { controller = \"Blog\", action = \"Post\" },\n    constraints: new { year = @\"\\d{4}\" });\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft.AspNetCore.Components.WebAssembly.DevServer via .NET CLI\nDESCRIPTION: This command adds the Microsoft.AspNetCore.Components.WebAssembly.DevServer package to your project using the .NET CLI.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/DevServer/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.Components.WebAssembly.DevServer\n```\n\n----------------------------------------\n\nTITLE: Page Handler Executed Context in ASP.NET Core Razor Pages\nDESCRIPTION: Virtual properties for PageHandlerExecutedContext that provide access to action descriptor, execution status, exceptions, and results. This context is used after a page handler has executed to process the results and handle any exceptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.Filters.PageHandlerExecutedContext.ActionDescriptor.get -> Microsoft.AspNetCore.Mvc.RazorPages.CompiledPageActionDescriptor!\nvirtual Microsoft.AspNetCore.Mvc.Filters.PageHandlerExecutedContext.Canceled.get -> bool\nvirtual Microsoft.AspNetCore.Mvc.Filters.PageHandlerExecutedContext.Canceled.set -> void\nvirtual Microsoft.AspNetCore.Mvc.Filters.PageHandlerExecutedContext.Exception.get -> System.Exception?\nvirtual Microsoft.AspNetCore.Mvc.Filters.PageHandlerExecutedContext.Exception.set -> void\nvirtual Microsoft.AspNetCore.Mvc.Filters.PageHandlerExecutedContext.ExceptionDispatchInfo.get -> System.Runtime.ExceptionServices.ExceptionDispatchInfo?\nvirtual Microsoft.AspNetCore.Mvc.Filters.PageHandlerExecutedContext.ExceptionDispatchInfo.set -> void\nvirtual Microsoft.AspNetCore.Mvc.Filters.PageHandlerExecutedContext.ExceptionHandled.get -> bool\nvirtual Microsoft.AspNetCore.Mvc.Filters.PageHandlerExecutedContext.ExceptionHandled.set -> void\nvirtual Microsoft.AspNetCore.Mvc.Filters.PageHandlerExecutedContext.HandlerInstance.get -> object!\nvirtual Microsoft.AspNetCore.Mvc.Filters.PageHandlerExecutedContext.HandlerMethod.get -> Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.HandlerMethodDescriptor?\nvirtual Microsoft.AspNetCore.Mvc.Filters.PageHandlerExecutedContext.Result.get -> Microsoft.AspNetCore.Mvc.IActionResult?\nvirtual Microsoft.AspNetCore.Mvc.Filters.PageHandlerExecutedContext.Result.set -> void\n```\n\n----------------------------------------\n\nTITLE: Building ASP.NET Core Certificate Authentication\nDESCRIPTION: Command to build the certificate authentication project from within the parent security directory\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Certificate/src/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: Running Blazor WASM Benchmark with Custom Branch\nDESCRIPTION: Command to run benchmarks using Crank with custom branch specifications. Allows testing of local changes by specifying a custom git branch and build arguments.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/benchmarkapps/Wasm.Performance/README.md#2025-04-08_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncrank --config https://github.com/dotnet/aspnetcore/blob/main/src/Components/benchmarkapps/Wasm.Performance/benchmarks.compose.json?raw=true --config https://github.com/aspnet/Benchmarks/blob/main/scenarios/aspnet.profiles.yml?raw=true --scenario blazorwasmbenchmark --profile aspnet-perf-lin --application.buildArguments gitBranch=myLocalChanges --application.source.branchOrCommit myLocalChanges\n```\n\n----------------------------------------\n\nTITLE: Running Blazor WASM Benchmark with Custom Branch\nDESCRIPTION: Command to run benchmarks using Crank with custom branch specifications. Allows testing of local changes by specifying a custom git branch and build arguments.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/benchmarkapps/Wasm.Performance/README.md#2025-04-08_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncrank --config https://github.com/dotnet/aspnetcore/blob/main/src/Components/benchmarkapps/Wasm.Performance/benchmarks.compose.json?raw=true --config https://github.com/aspnet/Benchmarks/blob/main/scenarios/aspnet.profiles.yml?raw=true --scenario blazorwasmbenchmark --profile aspnet-perf-lin --application.buildArguments gitBranch=myLocalChanges --application.source.branchOrCommit myLocalChanges\n```\n\n----------------------------------------\n\nTITLE: Directory References in Markdown\nDESCRIPTION: Shows inline code formatting for referencing binary output directories that should be excluded from reproduction projects\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/repro.md#2025-04-08_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n`bin` and `obj`\n```\n\n----------------------------------------\n\nTITLE: Identity UI Logger Event IDs\nDESCRIPTION: Static readonly fields defining logging event IDs for various Identity UI operations like user creation, login, 2FA operations, and account management.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Identity.UI.LoggerEventIds.PersonalDataRequested -> Microsoft.Extensions.Logging.EventId\nstatic readonly Microsoft.AspNetCore.Identity.UI.LoggerEventIds.TwoFADisabled -> Microsoft.Extensions.Logging.EventId\nstatic readonly Microsoft.AspNetCore.Identity.UI.LoggerEventIds.TwoFAEnabled -> Microsoft.Extensions.Logging.EventId\nstatic readonly Microsoft.AspNetCore.Identity.UI.LoggerEventIds.UserCreated -> Microsoft.Extensions.Logging.EventId\n```\n\n----------------------------------------\n\nTITLE: Installing ASP.NET Core Data Protection Redis Package\nDESCRIPTION: Command to install the Microsoft.AspNetCore.DataProtection.StackExchangeRedis NuGet package using the .NET CLI.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/StackExchangeRedis/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.DataProtection.StackExchangeRedis\n```\n\n----------------------------------------\n\nTITLE: Configuring EF-aware IAsyncQueryExecutor in ASP.NET Core\nDESCRIPTION: This code snippet demonstrates how to register an EF-aware IAsyncQueryExecutor implementation by calling AddQuickGridEntityFrameworkAdapter on the service collection in Program.cs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/QuickGrid/Microsoft.AspNetCore.Components.QuickGrid.EntityFrameworkAdapter/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Services.AddQuickGridEntityFrameworkAdapter();\n```\n\n----------------------------------------\n\nTITLE: Exception Handling and Logging Helper for Request Processing in ASP.NET Core\nDESCRIPTION: Helper class that provides consistent error logging and exception throwing behavior for request processing errors. Supports configurable behavior between logging-only and exception-throwing modes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Testing ASP.NET Core Cookie Authentication\nDESCRIPTION: Command to run tests for the Cookie Authentication project from within the parent security directory.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Cookies/src/README.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd -t\n```\n\n----------------------------------------\n\nTITLE: Listing Components Remaining in aspnetcore-tooling\nDESCRIPTION: Enumerates the components and associated tests that will remain in aspnetcore-tooling after phase one of the consolidation process. These are primarily tooling-specific components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/tooling-consolidation.md#2025-04-08_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nMicrosoft.AspNetCore.Razor.LanguageServer.Common\nMicrosoft.AspNetCore.Razor.LanguageServer\nMicrosoft.AspNetCore.Razor.OmniSharpPlugin.StrongNamed\nMicrosoft.AspNetCore.Razor.OmniSharpPlugin\nMicrosoft.AspNetCore.Razor.VSCode.Extension\nMicrosoft.AspNetCore.Razor.VSCode\nMicrosoft.CodeAnalysis.Razor.Workspaces\nMicrosoft.CodeAnalysis.Remote.Razor\nMicrosoft.VisualStudio.Editor.Razor\nMicrosoft.VisualStudio.LanguageServerClient.Razor\nMicrosoft.VisualStudio.LanguageServices.Razor\nMicrosoft.VisualStudio.LiveShare.Razor\nMicrosoft.VisualStudio.Mac.LanguageServices.Razor\nMicrosoft.VisualStudio.Mac.RazorAddin\nMicrosoft.VisualStudio.RazorExtension\nRazorDeveloperTools\nrzls\n```\n\n----------------------------------------\n\nTITLE: Code Reference Format in Markdown\nDESCRIPTION: Demonstrates inline code formatting using markdown backticks to reference the term 'minimal reproduction project (repro)'\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/repro.md#2025-04-08_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n`minimal reproduction project (repro)`\n```\n\n----------------------------------------\n\nTITLE: Defining Invalid Form Request Body Logger in ASP.NET Core\nDESCRIPTION: Defines a structured logger for tracking failures when reading a parameter from the request body as a form. Creates a reusable logging delegate that formats a consistent message with parameter type and name at Debug level with EventId 8.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndGet_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n    LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Extending Endpoint Builder with OpenAPI in C#\nDESCRIPTION: Provides extension methods for IEndpointConventionBuilder to add OpenAPI support to endpoints.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.OpenApiEndpointConventionBuilderExtensions.WithOpenApi<TBuilder>(this TBuilder builder) -> TBuilder\nstatic Microsoft.AspNetCore.Builder.OpenApiEndpointConventionBuilderExtensions.WithOpenApi<TBuilder>(this TBuilder builder, System.Func<Microsoft.OpenApi.Models.OpenApiOperation!, Microsoft.OpenApi.Models.OpenApiOperation!>! configureOperation) -> TBuilder\n```\n\n----------------------------------------\n\nTITLE: Configuring Google Authentication in ASP.NET Core Program.cs\nDESCRIPTION: Code snippet demonstrating how to configure Google OAuth authentication in an ASP.NET Core application. This adds the authentication service and configures it with the Google client ID and secret from configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Google/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddAuthentication().AddGoogle(googleOptions =>\n{\n    googleOptions.ClientId = builder.Configuration[\"Authentication:Google:ClientId\"];\n    googleOptions.ClientSecret = builder.Configuration[\"Authentication:Google:ClientSecret\"];\n});\n```\n\n----------------------------------------\n\nTITLE: Building OpenID Connect Authentication Project\nDESCRIPTION: Command to build the OpenID Connect authentication project from within the security directory using PowerShell build script.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: Building ASP.NET Core Web Application with WebApplicationBuilder\nDESCRIPTION: Instructions for building the sample web project from the root directory. Different commands are provided for Windows and other platforms.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/test/WebSites/SimpleWebSiteWithWebApplicationBuilder/readme.md#2025-04-08_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n.\\build.cmd on Windows; ./build.sh elsewhere\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Schema for Category Object in Pet Store API\nDESCRIPTION: This snippet defines the JSON schema for a Category object. It specifies required fields, property types, and formats for the id and name properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Tools/Microsoft.dotnet-openapi/test/TestContent/openapi.json.txt#2025-04-08_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"type\": \"object\",\n  \"additionalProperties\": false,\n  \"required\": [\n    \"id\"\n  ],\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\",\n      \"format\": \"int32\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Specific ASP.NET Core Benchmark\nDESCRIPTION: Executes a single specified benchmark (RequestParsing example) in Release configuration\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/perf/Microbenchmarks/README.md#2025-04-08_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ndotnet run -c Release RequestParsing\n```\n\n----------------------------------------\n\nTITLE: Cookie Authentication Events Definition\nDESCRIPTION: Event handler properties for various cookie authentication events including sign-in, sign-out, and validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Cookies/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.Cookies.CookieAuthenticationEvents.OnSigningIn.get -> System.Func<Microsoft.AspNetCore.Authentication.Cookies.CookieSigningInContext!, System.Threading.Tasks.Task!>!\nMicrosoft.AspNetCore.Authentication.Cookies.CookieAuthenticationEvents.OnSignedIn.get -> System.Func<Microsoft.AspNetCore.Authentication.Cookies.CookieSignedInContext!, System.Threading.Tasks.Task!>!\nMicrosoft.AspNetCore.Authentication.Cookies.CookieAuthenticationEvents.OnSigningOut.get -> System.Func<Microsoft.AspNetCore.Authentication.Cookies.CookieSigningOutContext!, System.Threading.Tasks.Task!>!\nMicrosoft.AspNetCore.Authentication.Cookies.CookieAuthenticationEvents.OnValidatePrincipal.get -> System.Func<Microsoft.AspNetCore.Authentication.Cookies.CookieValidatePrincipalContext!, System.Threading.Tasks.Task!>!\n```\n\n----------------------------------------\n\nTITLE: Adding InternalsVisibleTo Reference in ASP.NET Core Project\nDESCRIPTION: XML snippet showing how to expose internal members to a test project by adding an InternalsVisibleTo item to a project file (.csproj). This allows test projects to access and test internal members of the main project.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/AddingNewProjects.md#2025-04-08_snippet_0\n\nLANGUAGE: XML\nCODE:\n```\n<ItemGroup>\n  <InternalsVisibleTo Include=\"Microsoft.AspNetCore.My.TestProject\" />\n\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Implicit Body in ASP.NET Core\nDESCRIPTION: This method handles cases where an implicit body is expected but not provided. It suggests using a Service instead and either throws a BadHttpRequestException or logs the issue.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic void ImplicitBodyNotProvided(string parameterName)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Implicit Body in ASP.NET Core\nDESCRIPTION: This method handles cases where an implicit body is expected but not provided. It suggests using a Service instead and either throws a BadHttpRequestException or logs the issue.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic void ImplicitBodyNotProvided(string parameterName)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Listing and Choosing ASP.NET Core Benchmarks\nDESCRIPTION: Command to run the benchmark tool without specifying a benchmark name. This will display a list of all available benchmarks and prompt the user to choose which ones to run.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/perf/Microbenchmarks/readme.md#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\ndotnet run -c Release --framework <tfm>\n```\n\n----------------------------------------\n\nTITLE: Applying Apache License 2.0 Boilerplate Notice\nDESCRIPTION: This snippet shows the boilerplate notice to apply the Apache License 2.0 to your work. It includes placeholders for copyright year and owner name.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/THIRD-PARTY-NOTICES.txt#2025-04-08_snippet_0\n\nLANGUAGE: Plaintext\nCODE:\n```\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n```\n\n----------------------------------------\n\nTITLE: OpenAPI 3.0.4 Schema Definition\nDESCRIPTION: Complete OpenAPI specification describing REST endpoints for XML operations including todos, projects, and board items. Includes detailed schema definitions with validation rules, examples, and response formats.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/test/Microsoft.AspNetCore.OpenApi.Tests/Integration/snapshots/OpenApi3_0/OpenApiDocumentIntegrationTests.VerifyOpenApiDocument_documentName=xml.verified.txt#2025-04-08_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"openapi\": \"3.0.4\",\n  \"info\": {\n    \"title\": \"Sample | xml\",\n    \"version\": \"1.0.0\"\n  },\n  \"paths\": {\n    \"/xml/type-with-examples\": {\n      \"get\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/TypeWithExamples\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/TypeWithExamples\"\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"/xml/todo\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/TodoFomInterface\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/xml/project\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/Project\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/xml/board\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/BoardItem\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/xml/project-record\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/ProjectRecord\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/xml/todo-with-description\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/TodoWithDescription\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/Xml\": {\n      \"get\": {\n        \"tags\": [\n          \"Xml\"\n        ],\n        \"parameters\": [\n          {\n            \"name\": \"name\",\n            \"in\": \"query\",\n            \"description\": \"The name of the person.\",\n            \"schema\": {\n              \"type\": \"string\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Returns the greeting.\",\n            \"content\": {\n              \"text/plain\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              },\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              },\n              \"text/json\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              }\n            }\n          }\n        }\n      },\n      \"post\": {\n        \"tags\": [\n          \"Xml\"\n        ],\n        \"requestBody\": {\n          \"description\": \"The todo to insert into the database.\",\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/Todo\"\n              }\n            },\n            \"text/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/Todo\"\n              }\n            },\n            \"application/*+json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/Todo\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"text/plain\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              },\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              },\n              \"text/json\": {\n                \"schema\": {\n                  \"type\": \"string\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"BoardItem\": {\n        \"required\": [\n          \"name\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\"\n          }\n        },\n        \"description\": \"An item on the board.\"\n      },\n      \"Project\": {\n        \"required\": [\n          \"name\",\n          \"description\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\"\n          },\n          \"description\": {\n            \"type\": \"string\"\n          }\n        },\n        \"description\": \"The project that contains Todo items.\"\n      },\n      \"ProjectRecord\": {\n        \"required\": [\n          \"name\",\n          \"description\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"The name of the project.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"The description of the project.\"\n          }\n        },\n        \"description\": \"The project that contains Todo items.\"\n      },\n      \"Todo\": {\n        \"required\": [\n          \"id\",\n          \"title\",\n          \"completed\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\"\n          },\n          \"title\": {\n            \"type\": \"string\"\n          },\n          \"completed\": {\n            \"type\": \"boolean\"\n          }\n        }\n      },\n      \"TodoFomInterface\": {\n        \"required\": [\n          \"name\",\n          \"description\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"integer\",\n            \"description\": \"The identifier of the todo.\",\n            \"format\": \"int32\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"The name of the todo.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"A description of the todo.\"\n          }\n        },\n        \"description\": \"This is a todo item.\"\n      },\n      \"TodoWithDescription\": {\n        \"required\": [\n          \"name\",\n          \"description\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"integer\",\n            \"description\": \"The identifier of the todo, overridden.\",\n            \"format\": \"int32\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"The name of the todo, overridden.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"Another description of the todo.\"\n          }\n        }\n      },\n      \"TypeWithExamples\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"booleanType\": {\n            \"type\": \"boolean\",\n            \"example\": true\n          },\n          \"integerType\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"example\": 42\n          },\n          \"longType\": {\n            \"type\": \"integer\",\n            \"format\": \"int64\",\n            \"example\": 1234567890123456789\n          },\n          \"doubleType\": {\n            \"type\": \"number\",\n            \"format\": \"double\",\n            \"example\": 3.14\n          },\n          \"floatType\": {\n            \"type\": \"number\",\n            \"format\": \"float\",\n            \"example\": 3.14\n          },\n          \"dateTimeType\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"example\": \"2022-01-01T00:00:00Z\"\n          },\n          \"dateOnlyType\": {\n            \"type\": \"string\",\n            \"format\": \"date\",\n            \"example\": \"2022-01-01\"\n          }\n        }\n      }\n    }\n  },\n  \"tags\": [\n    {\n      \"name\": \"Sample\"\n    },\n    {\n      \"name\": \"Xml\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in ASP.NET Core\nDESCRIPTION: This method handles cases where reading a parameter from the request body as a form fails. It either throws a BadHttpRequestException or logs the failure, including the exception details.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Marking Project for Inclusion in ASP.NET Core App (XML)\nDESCRIPTION: This XML snippet shows how to mark a project for inclusion in the ASP.NET Core shared framework. By setting the IsAspNetCoreApp property to true, the project will be considered for inclusion when generating the SharedFramework.Local.props file.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/SharedFramework.md#2025-04-08_snippet_0\n\nLANGUAGE: XML\nCODE:\n```\n<IsAspNetCoreApp>true</IsAspNetCoreApp>\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in ASP.NET Core\nDESCRIPTION: This method handles cases where reading a parameter from the request body as a form fails. It either throws a BadHttpRequestException or logs the failure, including the exception details.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Important Notice in Markdown\nDESCRIPTION: This snippet demonstrates how to create an important notice block in Markdown, specifically highlighting the process for reporting security-related issues.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/CONTRIBUTING.md#2025-04-08_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n> [!IMPORTANT]\n> **If you want to report a security-related issue, please see the `Reporting security issues and bugs` section below.**\n```\n\n----------------------------------------\n\nTITLE: Defining HtmlTargetElementAttribute Class in C#\nDESCRIPTION: This snippet defines the HtmlTargetElementAttribute class with its constructor and TagStructure property. It is used to specify the target HTML element for a tag helper.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Razor/Razor.Runtime/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Razor.TagHelpers.HtmlTargetElementAttribute.HtmlTargetElementAttribute() -> void\nMicrosoft.AspNetCore.Razor.TagHelpers.HtmlTargetElementAttribute.TagStructure.get -> Microsoft.AspNetCore.Razor.TagHelpers.TagStructure\nMicrosoft.AspNetCore.Razor.TagHelpers.HtmlTargetElementAttribute.TagStructure.set -> void\n```\n\n----------------------------------------\n\nTITLE: Displaying API Diagnostic Codes in Markdown\nDESCRIPTION: A markdown table listing API-specific diagnostic codes (API1000-API1003) with their corresponding descriptions. These codes address issues related to API action returns and model validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/list-of-diagnostics.md#2025-04-08_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n### API (`API1000-API1003`)\n\n| Diagnostic ID     | Description |\n| :---------------- | :---------- |\n|  __`API1000`__ | Action returns undeclared status code |\n|  __`API1001`__ | Action returns undeclared success result |\n|  __`API1002`__ | Action documents status code that is not returned |\n|  __`API1003`__ | Action methods on ApiController instances do not require explicit model validation check |\n```\n\n----------------------------------------\n\nTITLE: Implementing 1ES Pipeline Template with Multiple Outputs\nDESCRIPTION: Example showing how to implement a 1ES pipeline template with multiple outputs using Arcade's templates-official/jobs/jobs.yml. Demonstrates artifact publishing and security scan optimization by using Build.ArtifactStagingDirectory.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/eng/common/template-guidance.md#2025-04-08_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nextends:\n  template: azure-pipelines/MicroBuild.1ES.Official.yml@MicroBuildTemplate\n  parameters:\n    stages:\n    - stage: build\n      jobs:\n      - template: /eng/common/templates-official/jobs/jobs.yml@self\n        parameters:\n          # 1ES makes use of outputs to reduce security task injection overhead\n          templateContext:\n            outputs:\n            - output: pipelineArtifact\n              displayName: 'Publish logs from source'\n              continueOnError: true\n              condition: always()\n              targetPath: $(Build.ArtifactStagingDirectory)/artifacts/log\n              artifactName: Logs\n          jobs:\n          - job: Windows\n            steps:\n            - script: echo \"friendly neighborhood\" > artifacts/marvel/spiderman.txt\n          # copy build outputs to artifact staging directory for publishing\n          - task: CopyFiles@2\n              displayName: Gather build output\n              inputs:\n                SourceFolder: '$(Build.SourcesDirectory)/artifacts/marvel'\n                Contents: '**'\n                TargetFolder: '$(Build.ArtifactStagingDirectory)/artifacts/marvel'\n```\n\n----------------------------------------\n\nTITLE: Displaying Blazor Diagnostic Codes in Markdown\nDESCRIPTION: A markdown table listing Blazor-specific diagnostic codes (BL0001-BL0007) with their corresponding descriptions. These codes address component parameter issues and best practices in Blazor development.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/list-of-diagnostics.md#2025-04-08_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n### BL  (`BL0001-BL0007`)\n\n| Diagnostic ID     | Description |\n| :---------------- | :---------- |\n|  __`BL0001`__ | Component parameter should have public setters |\n|  __`BL0002`__ | Component has multiple CaptureUnmatchedValues parameters |\n|  __`BL0003`__ | Component parameter with CaptureUnmatchedValues has the wrong type |\n|  __`BL0004`__ | Component parameter should be public |\n|  __`BL0005`__ | Component parameter should not be set outside of its component |\n|  __`BL0006`__ | Do not use RenderTree types |\n|  __`BL0007`__ | Component parameters should be auto properties |\n```\n\n----------------------------------------\n\nTITLE: OpenAPI Shape Schema Definition\nDESCRIPTION: Defines a polymorphic shape schema using discriminator pattern with triangle and square implementations. Uses $type property for type discrimination between shape variants.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/test/Microsoft.AspNetCore.OpenApi.Tests/Integration/snapshots/OpenApi3_1/OpenApiDocumentIntegrationTests.VerifyOpenApiDocument_documentName=responses.verified.txt#2025-04-08_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"Shape\": {\n    \"required\": [\n      \"$type\"\n    ],\n    \"type\": \"object\",\n    \"anyOf\": [\n      {\n        \"$ref\": \"#/components/schemas/ShapeTriangle\"\n      },\n      {\n        \"$ref\": \"#/components/schemas/ShapeSquare\"\n      }\n    ],\n    \"discriminator\": {\n      \"propertyName\": \"$type\",\n      \"mapping\": {\n        \"triangle\": \"#/components/schemas/ShapeTriangle\",\n        \"square\": \"#/components/schemas/ShapeSquare\"\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: OpenAPI 3.0.4 Todo API Specification\nDESCRIPTION: Complete OpenAPI specification for a Todo API including endpoints for managing todo items and handling arrays of GUIDs. Defines data models, request/response schemas, and JWT bearer authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/test/Microsoft.AspNetCore.OpenApi.Tests/Integration/snapshots/OpenApi3_0/OpenApiDocumentIntegrationTests.VerifyOpenApiDocument_documentName=v1.verified.txt#2025-04-08_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"openapi\": \"3.0.4\",\n  \"info\": {\n    \"title\": \"Sample | v1\",\n    \"version\": \"1.0.0\"\n  },\n  \"paths\": {\n    \"/v1/array-of-guids\": {\n      \"get\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"parameters\": [\n          {\n            \"name\": \"guids\",\n            \"in\": \"query\",\n            \"required\": true,\n            \"schema\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"string\",\n                \"format\": \"uuid\"\n              }\n            }\n          },\n          {\n            \"name\": \"X-Version\",\n            \"in\": \"header\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"default\": \"1.0\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"array\",\n                  \"items\": {\n                    \"type\": \"string\",\n                    \"format\": \"uuid\"\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"/v1/todos\": {\n      \"post\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"summary\": \"Creates a new todo item.\",\n        \"parameters\": [\n          {\n            \"name\": \"X-Version\",\n            \"in\": \"header\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"default\": \"1.0\"\n            }\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/Todo\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    },\n    \"/v1/todos/{id}\": {\n      \"get\": {\n        \"tags\": [\n          \"Sample\"\n        ],\n        \"description\": \"Returns a specific todo item.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"required\": true,\n            \"schema\": {\n              \"type\": \"integer\",\n              \"format\": \"int32\"\n            }\n          },\n          {\n            \"name\": \"X-Version\",\n            \"in\": \"header\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"default\": \"1.0\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/TodoWithDueDate\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"Todo\": {\n        \"required\": [\n          \"id\",\n          \"title\",\n          \"completed\",\n          \"createdAt\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"integer\",\n            \"description\": \"The unique identifier of the to-do item.\",\n            \"format\": \"int32\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"The title of the to-do item.\"\n          },\n          \"completed\": {\n            \"type\": \"boolean\",\n            \"description\": \"Indicates whether the to-do item is completed.\"\n          },\n          \"createdAt\": {\n            \"type\": \"string\",\n            \"description\": \"The date and time when the to-do item was created.\",\n            \"format\": \"date-time\"\n          }\n        },\n        \"description\": \"Represents a to-do item.\"\n      },\n      \"TodoWithDueDate\": {\n        \"required\": [\n          \"dueDate\",\n          \"id\",\n          \"title\",\n          \"completed\",\n          \"createdAt\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"dueDate\": {\n            \"type\": \"string\",\n            \"description\": \"The due date of the to-do item.\",\n            \"format\": \"date-time\"\n          },\n          \"id\": {\n            \"type\": \"integer\",\n            \"description\": \"The unique identifier of the to-do item.\",\n            \"format\": \"int32\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"The title of the to-do item.\"\n          },\n          \"completed\": {\n            \"type\": \"boolean\",\n            \"description\": \"Indicates whether the to-do item is completed.\"\n          },\n          \"createdAt\": {\n            \"type\": \"string\",\n            \"description\": \"The date and time when the to-do item was created.\",\n            \"format\": \"date-time\"\n          }\n        },\n        \"description\": \"Represents a to-do item with a due date.\"\n      }\n    },\n    \"securitySchemes\": {\n      \"Bearer\": {\n        \"type\": \"http\",\n        \"scheme\": \"bearer\",\n        \"bearerFormat\": \"Json Web Token\"\n      }\n    }\n  },\n  \"tags\": [\n    {\n      \"name\": \"Sample\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: ConnectionBuilderExtensions Static Methods\nDESCRIPTION: Extension methods for IConnectionBuilder interface providing middleware configuration capabilities through Run and Use methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/netstandard2.1/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.Run(this Microsoft.AspNetCore.Connections.IConnectionBuilder! connectionBuilder, System.Func<Microsoft.AspNetCore.Connections.ConnectionContext!, System.Threading.Tasks.Task!>! middleware) -> Microsoft.AspNetCore.Connections.IConnectionBuilder!\nstatic Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.Use(this Microsoft.AspNetCore.Connections.IConnectionBuilder! connectionBuilder, System.Func<Microsoft.AspNetCore.Connections.ConnectionContext!, Microsoft.AspNetCore.Connections.ConnectionDelegate!, System.Threading.Tasks.Task!>! middleware) -> Microsoft.AspNetCore.Connections.IConnectionBuilder!\nstatic Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.Use(this Microsoft.AspNetCore.Connections.IConnectionBuilder! connectionBuilder, System.Func<Microsoft.AspNetCore.Connections.ConnectionContext!, System.Func<System.Threading.Tasks.Task!>!, System.Threading.Tasks.Task!>! middleware) -> Microsoft.AspNetCore.Connections.IConnectionBuilder!\nstatic Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.UseConnectionHandler<TConnectionHandler>(this Microsoft.AspNetCore.Connections.IConnectionBuilder! connectionBuilder) -> Microsoft.AspNetCore.Connections.IConnectionBuilder!\n```\n\n----------------------------------------\n\nTITLE: Implementing ExecuteReturnAsync Method in C#\nDESCRIPTION: Implements an ExecuteReturnAsync method to handle different types of return values from endpoint handlers in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsTodo_Has_Metadata.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Route Class Constructors in C#\nDESCRIPTION: This snippet defines constructors for the Route class with various parameter combinations for target, routeTemplate, defaults, constraints, and dataTokens.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Routing.Route.Route(Microsoft.AspNetCore.Routing.IRouter! target, string! routeTemplate, Microsoft.AspNetCore.Routing.IInlineConstraintResolver! inlineConstraintResolver) -> void\nMicrosoft.AspNetCore.Routing.Route.Route(Microsoft.AspNetCore.Routing.IRouter! target, string! routeTemplate, Microsoft.AspNetCore.Routing.RouteValueDictionary? defaults, System.Collections.Generic.IDictionary<string!, object!>? constraints, Microsoft.AspNetCore.Routing.RouteValueDictionary? dataTokens, Microsoft.AspNetCore.Routing.IInlineConstraintResolver! inlineConstraintResolver) -> void\nMicrosoft.AspNetCore.Routing.Route.Route(Microsoft.AspNetCore.Routing.IRouter! target, string? routeName, string? routeTemplate, Microsoft.AspNetCore.Routing.RouteValueDictionary? defaults, System.Collections.Generic.IDictionary<string!, object!>? constraints, Microsoft.AspNetCore.Routing.RouteValueDictionary? dataTokens, Microsoft.AspNetCore.Routing.IInlineConstraintResolver! inlineConstraintResolver) -> void\n```\n\n----------------------------------------\n\nTITLE: DefaultAuthorizationHandlerProvider Class Definition in C#\nDESCRIPTION: Definition of the DefaultAuthorizationHandlerProvider class that provides authorization handlers for processing authorization requirements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.DefaultAuthorizationHandlerProvider\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.DefaultAuthorizationHandlerProvider.DefaultAuthorizationHandlerProvider(System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.IAuthorizationHandler!>! handlers) -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.DefaultAuthorizationHandlerProvider.GetHandlersAsync(Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext! context) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.IAuthorizationHandler!>!>!\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet0 Method for ASP.NET Core Endpoint Routing\nDESCRIPTION: Generated implementation of the MapGet extension method for IEndpointRouteBuilder. This method handles the creation of HTTP GET endpoints with string parameter binding and string response handling, including metadata population and request delegate creation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsDifferentInterceptorsFromSameLocation.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n%INTERCEPTSLOCATIONATTRIBUTE%\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"name\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n        Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n        var handler = Cast(del, global::System.String (global::System.String arg0) => throw null!);\n        EndpointFilterDelegate? filteredInvocation = null;\n        var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n        var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n        var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n        var jsonSerializerOptions = jsonOptions.SerializerOptions;\n        jsonSerializerOptions.MakeReadOnly();\n        var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n        var name_RouteOrQueryResolver = GeneratedRouteBuilderExtensionsCore.ResolveFromRouteOrQuery(\"name\", options.RouteParameterNames);\n\n        if (options.EndpointBuilder.FilterFactories.Count > 0)\n        {\n            filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n            {\n                if (ic.HttpContext.Response.StatusCode == 400)\n                {\n                    return ValueTask.FromResult<object?>(Results.Empty);\n                }\n                return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::System.String>(0)!));\n            },\n            options.EndpointBuilder,\n            handler.Method);\n        }\n\n        Task RequestHandler(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            // Endpoint Parameter: name (Type = string, IsOptional = False, IsParsable = False, IsArray = False, Source = RouteOrQuery)\n            var name_raw = name_RouteOrQueryResolver(httpContext);\n            if (name_raw is StringValues { Count: 0 })\n            {\n                wasParamCheckFailure = true;\n                logOrThrowExceptionHelper.RequiredParameterNotProvided(\"string\", \"name\", \"route or query string\");\n            }\n            var name_temp = (string?)name_raw;\n            string name_local = name_temp!;\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n                return Task.CompletedTask;\n            }\n            var result = handler(name_local!);\n            if (result is string)\n            {\n                httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n            }\n            else\n            {\n                httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n            }\n            return httpContext.Response.WriteAsync(result);\n        }\n\n        async Task RequestHandlerFiltered(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            // Endpoint Parameter: name (Type = string, IsOptional = False, IsParsable = False, IsArray = False, Source = RouteOrQuery)\n            var name_raw = name_RouteOrQueryResolver(httpContext);\n            if (name_raw is StringValues { Count: 0 })\n            {\n                wasParamCheckFailure = true;\n                logOrThrowExceptionHelper.RequiredParameterNotProvided(\"string\", \"name\", \"route or query string\");\n            }\n            var name_temp = (string?)name_raw;\n            string name_local = name_temp!;\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n            }\n            var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::System.String>(httpContext, name_local!));\n            if (result is not null)\n            {\n                await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n            }\n        }\n\n        RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\n        var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\n        return new RequestDelegateResult(targetDelegate, metadata);\n    };\n    var castHandler = Cast(handler, global::System.String (global::System.String arg0) => throw null!);\n    return MapCore(\n        endpoints,\n        pattern,\n        handler,\n        GetVerb,\n        populateMetadata,\n        createRequestDelegate,\n        castHandler.Method);\n}\n```\n\n----------------------------------------\n\nTITLE: HttpResponse Virtual Methods and Properties in ASP.NET Core\nDESCRIPTION: Defines virtual methods and properties for HTTP response handling including response completion, callbacks, redirection, and resource disposal\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_24\n\nLANGUAGE: csharp\nCODE:\n```\nvirtual Microsoft.AspNetCore.Http.HttpResponse.BodyWriter.get -> System.IO.Pipelines.PipeWriter!\nvirtual Microsoft.AspNetCore.Http.HttpResponse.CompleteAsync() -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Http.HttpResponse.OnCompleted(System.Func<System.Threading.Tasks.Task!>! callback) -> void\nvirtual Microsoft.AspNetCore.Http.HttpResponse.OnStarting(System.Func<System.Threading.Tasks.Task!>! callback) -> void\nvirtual Microsoft.AspNetCore.Http.HttpResponse.Redirect(string! location) -> void\nvirtual Microsoft.AspNetCore.Http.HttpResponse.RegisterForDispose(System.IDisposable! disposable) -> void\nvirtual Microsoft.AspNetCore.Http.HttpResponse.RegisterForDisposeAsync(System.IAsyncDisposable! disposable) -> void\nvirtual Microsoft.AspNetCore.Http.HttpResponse.StartAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Writing Handshake Response Message in SignalR Protocol\nDESCRIPTION: Static method to write a HandshakeResponseMessage to an IBufferWriter<byte> output in the SignalR protocol.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.WriteResponseMessage(Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage! responseMessage, System.Buffers.IBufferWriter<byte>! output) -> void\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core View Layout Structure\nDESCRIPTION: Template structure showing category headers, cached content section, and correlation ID display across view components, partials, and splash elements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/test/Mvc.FunctionalTests/compiler/resources/CacheTagHelper_CanCachePortionsOfViewsPartialViewsAndViewComponents.Assert2.txt#2025-04-08_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n<h2>Category: Phones</h2>\n<h2>Region: North</h2>\n\n    <h2>Cached content</h2>\n    Locations closest to your locale:\n\nNorthWest Store\n<div>CorrelationId in View Component: 1</div>\n\n    <partial-title>Listing items</partial-title>\n\nCached Content for Phones\n<div>CorrelationId in Partial: 2</div>\n\n    <div>CorrelationId in Splash: 2</div>\n```\n\n----------------------------------------\n\nTITLE: Running ASP.NET Core Authentication Sample Steps\nDESCRIPTION: Step-by-step instructions for testing the authentication scheme selection functionality. Shows the flow between cookie-based authentication for web routes and API authentication for /api routes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/samples/PathSchemeSelection/README.md#2025-04-08_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n1. Run the app and click on the MyClaims tab, this should trigger a redirect to login.\n2. Login with any username and password, the sample just validates that any values are provided.\n3. You should be redirected back to /Home/MyClaims which will output a few user claims from the cookie\n4. Now try going to /api/Home/MyClaims which will output a different set of claims (from the Api scheme)\n```\n\n----------------------------------------\n\nTITLE: JavaScript Interop Interfaces and Configuration in ASP.NET Core\nDESCRIPTION: Defines interfaces and classes for JavaScript interoperability in Blazor. Includes IInternalWebJSInProcessRuntime, JSComponentConfigurationExtensions, and JSComponentConfigurationStore.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Web.Internal.IInternalWebJSInProcessRuntime\nMicrosoft.AspNetCore.Components.Web.Internal.IInternalWebJSInProcessRuntime.InvokeJS(string! identifier, string? argsJson, Microsoft.JSInterop.JSCallResultType resultType, long targetInstanceId) -> string!\nMicrosoft.AspNetCore.Components.Web.JSComponentConfigurationExtensions\nMicrosoft.AspNetCore.Components.Web.JSComponentConfigurationStore\nMicrosoft.AspNetCore.Components.Web.JSComponentConfigurationStore.JSComponentConfigurationStore() -> void\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Implicit Body in ASP.NET Core (C#)\nDESCRIPTION: Handles cases where an implicit body parameter was expected but not provided in the request. Either throws a BadHttpRequestException with a helpful message suggesting possible solutions or logs the issue.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Get_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic void ImplicitBodyNotProvided(string parameterName)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Type Info Polymorphism Checking in ASP.NET Core\nDESCRIPTION: Utility methods to determine if a JSON type info can handle polymorphic types. Checks if the type is sealed, a value type, or has explicit polymorphism options configured.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\n----------------------------------------\n\nTITLE: Endpoint Filter Delegation in ASP.NET Core Request Processing\nDESCRIPTION: Builds a filter delegation chain for request processing that handles status code checks and executes the handler. The filter delegate processes the HTTP context and returns appropriate results based on the execution status.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nif (options.EndpointBuilder.FilterFactories.Count > 0)\n{\n    filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n    {\n        if (ic.HttpContext.Response.StatusCode == 400)\n        {\n            return ValueTask.FromResult<object?>(Results.Empty);\n        }\n        handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListRecordStruct>(0)!);\n        return ValueTask.FromResult<object?>(Results.Empty);\n    },\n    options.EndpointBuilder,\n    handler.Method);\n}\n```\n\n----------------------------------------\n\nTITLE: TokenOptions Configuration Class\nDESCRIPTION: Configuration options for various token providers used in identity system including email confirmation, phone number change, and two-factor authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class TokenOptions {\n    public string AuthenticatorTokenProvider { get; set; }\n    public string EmailConfirmationTokenProvider { get; set; }\n    public string PasswordResetTokenProvider { get; set; }\n    public Dictionary<string, TokenProviderDescriptor> ProviderMap { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Filter Delegate Chain for ASP.NET Core Endpoint Filtering\nDESCRIPTION: Implements a method to build a chain of endpoint filters for ASP.NET Core request processing. This method applies filters in reverse order to create a nested execution pipeline for request handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Cookie Authentication Default Values in C#\nDESCRIPTION: Static readonly fields that define default values for cookie authentication configuration, including paths for login, logout, access denied, and cookie prefix.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Cookies/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationDefaults.AccessDeniedPath -> Microsoft.AspNetCore.Http.PathString\nstatic readonly Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationDefaults.CookiePrefix -> string!\nstatic readonly Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationDefaults.LoginPath -> Microsoft.AspNetCore.Http.PathString\nstatic readonly Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationDefaults.LogoutPath -> Microsoft.AspNetCore.Http.PathString\nstatic readonly Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationDefaults.ReturnUrlParameter -> string!\n```\n\n----------------------------------------\n\nTITLE: Defining ITimeLimitedDataProtector Interface in C#\nDESCRIPTION: This snippet defines the ITimeLimitedDataProtector interface, which extends data protection with time-limited functionality. It includes methods for creating protectors, protecting data with expiration, and unprotecting data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/Extensions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.DataProtection.ITimeLimitedDataProtector\nMicrosoft.AspNetCore.DataProtection.ITimeLimitedDataProtector.CreateProtector(string! purpose) -> Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector!\nMicrosoft.AspNetCore.DataProtection.ITimeLimitedDataProtector.Protect(byte[]! plaintext, System.DateTimeOffset expiration) -> byte[]!\nMicrosoft.AspNetCore.DataProtection.ITimeLimitedDataProtector.Unprotect(byte[]! protectedData, out System.DateTimeOffset expiration) -> byte[]!\n```\n\n----------------------------------------\n\nTITLE: Building ASP.NET Core Negotiate Authentication Project\nDESCRIPTION: Command to build the project from within the parent security directory using PowerShell build script.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Negotiate/src/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: Invocation and Stream Messages\nDESCRIPTION: Classes representing invocation and streaming operations in SignalR. These include invocation messages, stream items, binding failures, and sequence management messages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationBindingFailureMessage\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationBindingFailureMessage.BindingFailure.get -> System.Runtime.ExceptionServices.ExceptionDispatchInfo!\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationBindingFailureMessage.InvocationBindingFailureMessage(string? invocationId, string! target, System.Runtime.ExceptionServices.ExceptionDispatchInfo! bindingFailure) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationBindingFailureMessage.Target.get -> string!\n\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationMessage\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationMessage.InvocationMessage(string! target, object?[]! arguments) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationMessage.InvocationMessage(string? invocationId, string! target, object?[]! arguments) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.InvocationMessage.InvocationMessage(string? invocationId, string! target, object?[]! arguments, string![]? streamIds) -> void\noverride Microsoft.AspNetCore.SignalR.Protocol.InvocationMessage.ToString() -> string!\n\nMicrosoft.AspNetCore.SignalR.Protocol.SequenceMessage\nMicrosoft.AspNetCore.SignalR.Protocol.SequenceMessage.SequenceId.get -> long\nMicrosoft.AspNetCore.SignalR.Protocol.SequenceMessage.SequenceId.set -> void\nMicrosoft.AspNetCore.SignalR.Protocol.SequenceMessage.SequenceMessage(long sequenceId) -> void\n```\n\n----------------------------------------\n\nTITLE: Controller Link Generator Extensions for Path and URI Building in ASP.NET Core\nDESCRIPTION: Extensions for LinkGenerator to create paths and URIs for controllers and actions. These methods generate URLs based on controller and action names with options for customizing the resulting URL including scheme, host, path base, and fragment.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.ControllerLinkGeneratorExtensions.GetPathByAction(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, Microsoft.AspNetCore.Http.HttpContext! httpContext, string? action = null, string? controller = null, object? values = null, Microsoft.AspNetCore.Http.PathString? pathBase = null, Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\nstatic Microsoft.AspNetCore.Routing.ControllerLinkGeneratorExtensions.GetPathByAction(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, string! action, string! controller, object? values = null, Microsoft.AspNetCore.Http.PathString pathBase = default(Microsoft.AspNetCore.Http.PathString), Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\nstatic Microsoft.AspNetCore.Routing.ControllerLinkGeneratorExtensions.GetUriByAction(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, Microsoft.AspNetCore.Http.HttpContext! httpContext, string? action = null, string? controller = null, object? values = null, string? scheme = null, Microsoft.AspNetCore.Http.HostString? host = null, Microsoft.AspNetCore.Http.PathString? pathBase = null, Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\nstatic Microsoft.AspNetCore.Routing.ControllerLinkGeneratorExtensions.GetUriByAction(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, string! action, string! controller, object? values, string! scheme, Microsoft.AspNetCore.Http.HostString host, Microsoft.AspNetCore.Http.PathString pathBase = default(Microsoft.AspNetCore.Http.PathString), Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Class for ASP.NET Core - C#\nDESCRIPTION: Implementation of IParameterBindingMetadata that stores metadata about parameter binding. Includes information about the parameter name, type, binding capabilities like TryParse and BindAsync, and whether the parameter is optional.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitBodyParam_ComplexReturn_Snapshot.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Metadata Constants for ASP.NET Core (C#)\nDESCRIPTION: This generated class defines constant arrays for various content types used in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: RouteValueDictionary Creation Method in ASP.NET Core\nDESCRIPTION: Method for creating a RouteValueDictionary from an array of key-value pairs in ASP.NET Core routing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.RouteValueDictionary.FromArray(System.Collections.Generic.KeyValuePair<string!, object?>[]! items) -> Microsoft.AspNetCore.Routing.RouteValueDictionary!\n```\n\n----------------------------------------\n\nTITLE: Generating JSON-formatted lines for template-baselines.json\nDESCRIPTION: This bash script generates JSON-formatted lines for insertion into the template-baselines.json file. It finds all files in the project directory, excluding certain paths, and formats them for JSON insertion.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/ProjectTemplates/README-BASELINES.md#2025-04-08_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd src/ProjectTemplates/scripts\nexport PROJECT_NAME=MyBlazorApp\nfind $PROJECT_NAME -type f -not -path \"*/obj/*\" -not -path \"*/bin/*\" -not -path \"*/.publish/*\" | sed -e \"s/^$PROJECT_NAME\\//\" | sed -e \"s/$PROJECT_NAME/{ProjectName}/g\" | sed 's/.*/        \"&\",/' | sort -f\n```\n\n----------------------------------------\n\nTITLE: Defining AuthorizationMiddleware Class in C#\nDESCRIPTION: Defines the AuthorizationMiddleware class with multiple constructors and an Invoke method for handling authorization in the ASP.NET Core pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Policy/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationMiddleware\nMicrosoft.AspNetCore.Authorization.AuthorizationMiddleware.AuthorizationMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.AspNetCore.Authorization.IAuthorizationPolicyProvider! policyProvider) -> void\nMicrosoft.AspNetCore.Authorization.AuthorizationMiddleware.AuthorizationMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.AspNetCore.Authorization.IAuthorizationPolicyProvider! policyProvider, System.IServiceProvider! services) -> void\nMicrosoft.AspNetCore.Authorization.AuthorizationMiddleware.AuthorizationMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.AspNetCore.Authorization.IAuthorizationPolicyProvider! policyProvider, System.IServiceProvider! services, Microsoft.Extensions.Logging.ILogger<Microsoft.AspNetCore.Authorization.AuthorizationMiddleware!>! logger) -> void\nMicrosoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(Microsoft.AspNetCore.Http.HttpContext! context) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Extension Method in C#\nDESCRIPTION: Implements an extension method 'MapGet0' for IEndpointRouteBuilder to handle GET requests. It includes metadata population, request delegate creation, and parameter binding for routing and query string values.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        // ... (metadata population logic)\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        // ... (request delegate creation logic)\n    };\n    var castHandler = Cast(handler, global::System.Int32?[] (global::System.Int32?[]? arg0= default) => throw null!);\n    return MapCore(\n        endpoints,\n        pattern,\n        // ... (additional parameters)\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MapCore Method for Route Handler Builder in C#\nDESCRIPTION: Internal method to map routes and create route handler builders with support for HTTP methods, metadata population, and request delegate creation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndGet_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AuthenticationProperties Class in C#\nDESCRIPTION: Defines the AuthenticationProperties class with methods for managing authentication-related properties and parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Authentication.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.AllowRefresh.get -> bool?\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.AllowRefresh.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.AuthenticationProperties() -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.AuthenticationProperties(System.Collections.Generic.IDictionary<string!, string?>! items) -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.AuthenticationProperties(System.Collections.Generic.IDictionary<string!, string?>? items, System.Collections.Generic.IDictionary<string!, object?>? parameters) -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.Clone() -> Microsoft.AspNetCore.Authentication.AuthenticationProperties!\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.ExpiresUtc.get -> System.DateTimeOffset?\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.ExpiresUtc.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.GetBool(string! key) -> bool?\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.GetDateTimeOffset(string! key) -> System.DateTimeOffset?\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.GetParameter<T>(string! key) -> T?\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.GetString(string! key) -> string?\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.IsPersistent.get -> bool\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.IsPersistent.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.IssuedUtc.get -> System.DateTimeOffset?\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.IssuedUtc.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.Items.get -> System.Collections.Generic.IDictionary<string!, string?>!\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.Parameters.get -> System.Collections.Generic.IDictionary<string!, object?>!\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.RedirectUri.get -> string?\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.RedirectUri.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.SetBool(string! key, bool? value) -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.SetDateTimeOffset(string! key, System.DateTimeOffset? value) -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.SetParameter<T>(string! key, T value) -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationProperties.SetString(string! key, string? value) -> void\n```\n\n----------------------------------------\n\nTITLE: Parsing and Manipulating Cookie Headers in C#\nDESCRIPTION: Static methods for parsing and manipulating Cookie headers. Includes methods for parsing single headers, lists of headers, and strict parsing options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Headers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Net.Http.Headers.CookieHeaderValue.Parse(Microsoft.Extensions.Primitives.StringSegment input) -> Microsoft.Net.Http.Headers.CookieHeaderValue!\nstatic Microsoft.Net.Http.Headers.CookieHeaderValue.ParseList(System.Collections.Generic.IList<string!>? inputs) -> System.Collections.Generic.IList<Microsoft.Net.Http.Headers.CookieHeaderValue!>!\nstatic Microsoft.Net.Http.Headers.CookieHeaderValue.ParseStrictList(System.Collections.Generic.IList<string!>? inputs) -> System.Collections.Generic.IList<Microsoft.Net.Http.Headers.CookieHeaderValue!>!\nstatic Microsoft.Net.Http.Headers.CookieHeaderValue.TryParse(Microsoft.Extensions.Primitives.StringSegment input, out Microsoft.Net.Http.Headers.CookieHeaderValue? parsedValue) -> bool\nstatic Microsoft.Net.Http.Headers.CookieHeaderValue.TryParseList(System.Collections.Generic.IList<string!>? inputs, out System.Collections.Generic.IList<Microsoft.Net.Http.Headers.CookieHeaderValue!>? parsedValues) -> bool\nstatic Microsoft.Net.Http.Headers.CookieHeaderValue.TryParseStrictList(System.Collections.Generic.IList<string!>? inputs, out System.Collections.Generic.IList<Microsoft.Net.Http.Headers.CookieHeaderValue!>? parsedValues) -> bool\n```\n\n----------------------------------------\n\nTITLE: Implementing Request Body Resolution in C#\nDESCRIPTION: Async method to resolve and validate HTTP request body content with JSON deserialization and error handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndGet_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static async ValueTask<(bool, T?)> TryResolveBodyAsync<T>(HttpContext httpContext, LogOrThrowExceptionHelper logOrThrowExceptionHelper, bool allowEmpty, string parameterTypeName, string parameterName, JsonTypeInfo<T> jsonTypeInfo, bool isInferred = false)\n{\n    var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();\n    T? bodyValue = default;\n    var bodyValueSet = false;\n\n    if (feature?.CanHaveBody == true)\n    {\n        if (!httpContext.Request.HasJsonContentType())\n        {\n            logOrThrowExceptionHelper.UnexpectedJsonContentType(httpContext.Request.ContentType);\n            httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;\n            return (false, default);\n        }\n        try\n        {\n            bodyValue = await httpContext.Request.ReadFromJsonAsync(jsonTypeInfo);\n            bodyValueSet = bodyValue != null;\n        }\n        catch (BadHttpRequestException badHttpRequestException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(badHttpRequestException);\n            httpContext.Response.StatusCode = badHttpRequestException.StatusCode;\n            return (false, default);\n        }\n        catch (IOException ioException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(ioException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n        catch (System.Text.Json.JsonException jsonException)\n        {\n            logOrThrowExceptionHelper.InvalidJsonRequestBody(parameterTypeName, parameterName, jsonException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n    }\n\n    if (!allowEmpty && !bodyValueSet)\n    {\n        if (!isInferred)\n        {\n            logOrThrowExceptionHelper.RequiredParameterNotProvided(parameterTypeName, parameterName, \"body\");\n        }\n        else\n        {\n            logOrThrowExceptionHelper.ImplicitBodyNotProvided(parameterName);\n        }\n        httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n        return (false, bodyValue);\n    }\n\n    return (true, bodyValue);\n}\n```\n\n----------------------------------------\n\nTITLE: IResponseCookies Interface Definition in C#\nDESCRIPTION: Interface for managing HTTP response cookies with methods to append and delete cookies with optional configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Features/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\ninterface IResponseCookies {\n    void Append(string key, string value);\n    void Append(string key, string value, CookieOptions options);\n    void Append(ReadOnlySpan<KeyValuePair<string, string>> keyValuePairs, CookieOptions options);\n    void Delete(string key);\n    void Delete(string key, CookieOptions options);\n}\n```\n\n----------------------------------------\n\nTITLE: Performing Redirects in ASP.NET Core MVC Controllers\nDESCRIPTION: These methods provide various ways to perform redirects, including to URLs, actions, pages, and routes, with options for permanent redirects and preserving the HTTP method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_58\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Redirect(string! url) -> Microsoft.AspNetCore.Mvc.RedirectResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectPermanent(string! url) -> Microsoft.AspNetCore.Mvc.RedirectResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectPermanentPreserveMethod(string! url) -> Microsoft.AspNetCore.Mvc.RedirectResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectPreserveMethod(string! url) -> Microsoft.AspNetCore.Mvc.RedirectResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToAction() -> Microsoft.AspNetCore.Mvc.RedirectToActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToAction(string? actionName) -> Microsoft.AspNetCore.Mvc.RedirectToActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToAction(string? actionName, object? routeValues) -> Microsoft.AspNetCore.Mvc.RedirectToActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToAction(string? actionName, string? controllerName) -> Microsoft.AspNetCore.Mvc.RedirectToActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToAction(string? actionName, string? controllerName, object? routeValues) -> Microsoft.AspNetCore.Mvc.RedirectToActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToAction(string? actionName, string? controllerName, object? routeValues, string? fragment) -> Microsoft.AspNetCore.Mvc.RedirectToActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToAction(string? actionName, string? controllerName, string? fragment) -> Microsoft.AspNetCore.Mvc.RedirectToActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToActionPermanent(string? actionName) -> Microsoft.AspNetCore.Mvc.RedirectToActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToActionPermanent(string? actionName, object? routeValues) -> Microsoft.AspNetCore.Mvc.RedirectToActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToActionPermanent(string? actionName, string? controllerName) -> Microsoft.AspNetCore.Mvc.RedirectToActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToActionPermanent(string? actionName, string? controllerName, object? routeValues) -> Microsoft.AspNetCore.Mvc.RedirectToActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToActionPermanent(string? actionName, string? controllerName, object? routeValues, string? fragment) -> Microsoft.AspNetCore.Mvc.RedirectToActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToActionPermanent(string? actionName, string? controllerName, string? fragment) -> Microsoft.AspNetCore.Mvc.RedirectToActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToActionPermanentPreserveMethod(string? actionName = null, string? controllerName = null, object? routeValues = null, string? fragment = null) -> Microsoft.AspNetCore.Mvc.RedirectToActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToActionPreserveMethod(string? actionName = null, string? controllerName = null, object? routeValues = null, string? fragment = null) -> Microsoft.AspNetCore.Mvc.RedirectToActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToPage(string! pageName) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToPage(string! pageName, object? routeValues) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToPage(string! pageName, string? pageHandler) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToPage(string! pageName, string? pageHandler, object? routeValues) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToPage(string! pageName, string? pageHandler, object? routeValues, string? fragment) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToPage(string! pageName, string? pageHandler, string? fragment) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToPagePermanent(string! pageName) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToPagePermanent(string! pageName, object? routeValues) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToPagePermanent(string! pageName, string? pageHandler) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToPagePermanent(string! pageName, string? pageHandler, object? routeValues, string? fragment) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToPagePermanent(string! pageName, string? pageHandler, string? fragment) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToPagePermanentPreserveMethod(string! pageName, string? pageHandler = null, object? routeValues = null, string? fragment = null) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToPagePreserveMethod(string! pageName, string? pageHandler = null, object? routeValues = null, string? fragment = null) -> Microsoft.AspNetCore.Mvc.RedirectToPageResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToRoute(object? routeValues) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToRoute(string? routeName) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToRoute(string? routeName, object? routeValues) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToRoute(string? routeName, object? routeValues, string? fragment) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToRoute(string? routeName, string? fragment) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToRoutePermanent(object? routeValues) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToRoutePermanent(string? routeName) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToRoutePermanent(string? routeName, object? routeValues) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToRoutePermanent(string? routeName, object? routeValues, string? fragment) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToRoutePermanent(string? routeName, string? fragment) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToRoutePermanentPreserveMethod(string? routeName = null, object? routeValues = null, string? fragment = null) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.RedirectToRoutePreserveMethod(string? routeName = null, object? routeValues = null, string? fragment = null) -> Microsoft.AspNetCore.Mvc.RedirectToRouteResult!\n```\n\n----------------------------------------\n\nTITLE: Implementing GitHub PR Review Lambda Handler in C#\nDESCRIPTION: The Lambda function handler that processes GitHub webhook events for PR review app deployments. It validates the webhook signature, processes different PR events, and triggers deployments or cleanups based on the event type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/Protocols.Json/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Configuring Kestrel Core and HTTPS in ASP.NET Core\nDESCRIPTION: These methods provide specific configurations for Kestrel. UseKestrelCore sets up the core Kestrel server, while UseKestrelHttpsConfiguration configures HTTPS for Kestrel. Both methods extend IWebHostBuilder.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Kestrel/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Hosting.WebHostBuilderKestrelExtensions.UseKestrelCore(this Microsoft.AspNetCore.Hosting.IWebHostBuilder! hostBuilder) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Hosting.WebHostBuilderKestrelExtensions.UseKestrelHttpsConfiguration(this Microsoft.AspNetCore.Hosting.IWebHostBuilder! hostBuilder) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\n```\n\n----------------------------------------\n\nTITLE: Adding DbContext Health Check in ASP.NET Core\nDESCRIPTION: Extension method that adds a health check for a specified Entity Framework Core database context. The method allows for customization of the health check name, failure status, tags, and even a custom test query to verify database availability.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HealthChecks.EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.EntityFrameworkCoreHealthChecksBuilderExtensions.AddDbContextCheck<TContext>(this Microsoft.Extensions.DependencyInjection.IHealthChecksBuilder! builder, string? name = null, Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus? failureStatus = null, System.Collections.Generic.IEnumerable<string!>? tags = null, System.Func<TContext!, System.Threading.CancellationToken, System.Threading.Tasks.Task<bool>!>? customTestQuery = null) -> Microsoft.Extensions.DependencyInjection.IHealthChecksBuilder!\n```\n\n----------------------------------------\n\nTITLE: Implementing EntityTagHeaderValue Class in C#\nDESCRIPTION: Defines the EntityTagHeaderValue class for handling Entity-Tag headers, including constructors and comparison methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Headers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Net.Http.Headers.EntityTagHeaderValue\nMicrosoft.Net.Http.Headers.EntityTagHeaderValue.Compare(Microsoft.Net.Http.Headers.EntityTagHeaderValue? other, bool useStrongComparison) -> bool\nMicrosoft.Net.Http.Headers.EntityTagHeaderValue.EntityTagHeaderValue(Microsoft.Extensions.Primitives.StringSegment tag) -> void\nMicrosoft.Net.Http.Headers.EntityTagHeaderValue.EntityTagHeaderValue(Microsoft.Extensions.Primitives.StringSegment tag, bool isWeak) -> void\nMicrosoft.Net.Http.Headers.EntityTagHeaderValue.IsWeak.get -> bool\nMicrosoft.Net.Http.Headers.EntityTagHeaderValue.Tag.get -> Microsoft.Extensions.Primitives.StringSegment\n```\n\n----------------------------------------\n\nTITLE: Extending AuthenticationBuilder for WsFederation in C#\nDESCRIPTION: This snippet defines extension methods for AuthenticationBuilder to add WsFederation authentication. It provides various overloads to configure WsFederation options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/WsFederation/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n~static Microsoft.Extensions.DependencyInjection.WsFederationExtensions.AddWsFederation(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder builder) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder\n~static Microsoft.Extensions.DependencyInjection.WsFederationExtensions.AddWsFederation(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder builder, string authenticationScheme, string displayName, System.Action<Microsoft.AspNetCore.Authentication.WsFederation.WsFederationOptions> configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder\n~static Microsoft.Extensions.DependencyInjection.WsFederationExtensions.AddWsFederation(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder builder, string authenticationScheme, System.Action<Microsoft.AspNetCore.Authentication.WsFederation.WsFederationOptions> configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder\n~static Microsoft.Extensions.DependencyInjection.WsFederationExtensions.AddWsFederation(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder builder, System.Action<Microsoft.AspNetCore.Authentication.WsFederation.WsFederationOptions> configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder\n```\n\n----------------------------------------\n\nTITLE: Defining TransferFormat Enumeration in C#\nDESCRIPTION: Enumeration specifying supported transfer formats for connections. Supports Binary (1) and Text (2) formats.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Connections.TransferFormat.Binary = 1\nMicrosoft.AspNetCore.Connections.TransferFormat.Text = 2\n```\n\n----------------------------------------\n\nTITLE: Defining Accepted Result Methods in C#\nDESCRIPTION: These methods create Accepted (HTTP 202) results with optional URI and value parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.Accepted(string? uri) -> Microsoft.AspNetCore.Http.HttpResults.Accepted!\nstatic Microsoft.AspNetCore.Http.TypedResults.Accepted(System.Uri! uri) -> Microsoft.AspNetCore.Http.HttpResults.Accepted!\nstatic Microsoft.AspNetCore.Http.TypedResults.Accepted<TValue>(string? uri, TValue? value) -> Microsoft.AspNetCore.Http.HttpResults.Accepted<TValue>!\nstatic Microsoft.AspNetCore.Http.TypedResults.Accepted<TValue>(System.Uri! uri, TValue? value) -> Microsoft.AspNetCore.Http.HttpResults.Accepted<TValue>!\n```\n\n----------------------------------------\n\nTITLE: Configuring Route Handlers for ASP.NET Core Endpoints in C#\nDESCRIPTION: This snippet defines extension methods for IEndpointRouteBuilder to set up route handlers for different HTTP methods. It includes methods for handling GET, POST, PUT, DELETE, and PATCH requests, as well as a generic method for handling any HTTP method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PublicAPI/net8.0/PublicAPI.Unshipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic static RouteHandlerBuilder MapGet(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler)\n{\n    return endpoints.MapMethods(pattern, new[] { HttpMethods.Get }, handler);\n}\n\npublic static RouteHandlerBuilder MapPost(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler)\n{\n    return endpoints.MapMethods(pattern, new[] { HttpMethods.Post }, handler);\n}\n\npublic static RouteHandlerBuilder MapPut(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler)\n{\n    return endpoints.MapMethods(pattern, new[] { HttpMethods.Put }, handler);\n}\n\npublic static RouteHandlerBuilder MapDelete(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler)\n{\n    return endpoints.MapMethods(pattern, new[] { HttpMethods.Delete }, handler);\n}\n\npublic static RouteHandlerBuilder MapPatch(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler)\n{\n    return endpoints.MapMethods(pattern, new[] { HttpMethods.Patch }, handler);\n}\n\npublic static RouteHandlerBuilder Map(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler)\n{\n    return endpoints.MapMethods(pattern, (IEnumerable<string>)Array.Empty<string>(), handler);\n}\n\npublic static RouteHandlerBuilder MapMethods(this IEndpointRouteBuilder endpoints, string pattern, IEnumerable<string> httpMethods, Delegate handler)\n{\n    ArgumentNullException.ThrowIfNull(httpMethods);\n    ArgumentNullException.ThrowIfNull(handler);\n\n    var handlers = RequestDelegateFactory.CreateRequestDelegateResult(handler, EndpointFilterFactoryContext.NullInstance);\n    var routeHandlerBuilder = endpoints.Map(pattern, handlers.RequestDelegate)\n        .WithMetadata(handlers.EndpointMetadata)\n        .WithDisplayName($\"Delegate - {pattern}\");\n\n    var corsMetadata = routeHandlerBuilder.Metadata.GetCorsMetadata();\n    // Don't override CORS metadata set on a per handler basis.\n    if (corsMetadata is null)\n    {\n        // The CORS metadata is added directly to the endpoint instead of applying a convention to make it easier to constrain the method of the endpoint.\n        routeHandlerBuilder.Add(endpointBuilder => endpointBuilder.Metadata.Add(new CorsMetadata()));\n    }\n\n    if (httpMethods.Any())\n    {\n        routeHandlerBuilder.WithMetadata(new HttpMethodMetadata(httpMethods));\n    }\n\n    return new RouteHandlerBuilder(routeHandlerBuilder);\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive that enables nullable reference type checks. This enhances type safety by making reference type nullability explicit in the code.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Localization/Abstractions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Defining MinDataRate Class in C#\nDESCRIPTION: This snippet defines the MinDataRate class, which is used to set minimum data transfer rates for connections in Kestrel.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Server.Kestrel.Core.MinDataRate\nMicrosoft.AspNetCore.Server.Kestrel.Core.MinDataRate.BytesPerSecond.get -> double\nMicrosoft.AspNetCore.Server.Kestrel.Core.MinDataRate.GracePeriod.get -> System.TimeSpan\nMicrosoft.AspNetCore.Server.Kestrel.Core.MinDataRate.MinDataRate(double bytesPerSecond, System.TimeSpan gracePeriod) -> void\n```\n\n----------------------------------------\n\nTITLE: Including ASP.NET Core Project in SharedFx API\nDESCRIPTION: XML snippet showing how to mark a project for inclusion in the ASP.NET Core shared framework by adding the IsAspNetCoreApp property to the project file.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/AddingNewProjects.md#2025-04-08_snippet_3\n\nLANGUAGE: XML\nCODE:\n```\n<IsAspNetCoreApp>true</IsAspNetCoreApp>\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Action for Unexpected JSON Content Type in ASP.NET Core\nDESCRIPTION: This code defines a static readonly Action for logging unexpected JSON content types. It uses LoggerMessage.Define to create a structured log message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Configuration Options for Database Error Page and Migrations Endpoint (C#)\nDESCRIPTION: Property getters and setters for configuring the Database Error Page and Migrations Endpoint middlewares. These options control path routing and other behavior of the diagnostic components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics.EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Builder.DatabaseErrorPageOptions.DatabaseErrorPageOptions() -> void\nvirtual Microsoft.AspNetCore.Builder.DatabaseErrorPageOptions.MigrationsEndPointPath.get -> Microsoft.AspNetCore.Http.PathString\nvirtual Microsoft.AspNetCore.Builder.DatabaseErrorPageOptions.MigrationsEndPointPath.set -> void\nMicrosoft.AspNetCore.Builder.MigrationsEndPointOptions.MigrationsEndPointOptions() -> void\nstatic Microsoft.AspNetCore.Builder.MigrationsEndPointOptions.DefaultPath -> Microsoft.AspNetCore.Http.PathString\nvirtual Microsoft.AspNetCore.Builder.MigrationsEndPointOptions.Path.get -> Microsoft.AspNetCore.Http.PathString\nvirtual Microsoft.AspNetCore.Builder.MigrationsEndPointOptions.Path.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute for C# Method Interception\nDESCRIPTION: Defines a custom attribute 'InterceptsLocationAttribute' used for method interception. It is applied to methods and can be used multiple times.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Routes in ASP.NET Core (C#)\nDESCRIPTION: This method maps routes using the provided parameters, invoking the RouteHandlerServices.Map method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nreturn RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata in ASP.NET Core\nDESCRIPTION: This class represents metadata for parameter binding in ASP.NET Core. It includes information about the parameter name, type, and binding capabilities such as TryParse and BindAsync methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Breaking Change Reference Modification\nDESCRIPTION: Example showing how to handle breaking changes in package references by updating the project file with new dependencies and suppressing baseline references.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/ReferenceResolution.md#2025-04-08_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\n<!-- in Microsoft.AspNetCore.Banana.csproj -->\n  <ItemGroup>\n    <Reference Include=\"Microsoft.AspNetCore.BetterThanOrange\" /> <!-- the new dependency -->\n    <SuppressBaselineReference Include=\"Microsoft.AspNetCore.Orange\" /> <!-- suppress as a known breaking change -->\n  </ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: Implementing VirtualFileHttpResult in ASP.NET Core\nDESCRIPTION: API signatures for the VirtualFileHttpResult class, which returns a file from a virtual path with options for content type, range processing, and file metadata.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.VirtualFileHttpResult\nMicrosoft.AspNetCore.Http.HttpResults.VirtualFileHttpResult.ContentType.get -> string!\nMicrosoft.AspNetCore.Http.HttpResults.VirtualFileHttpResult.EnableRangeProcessing.get -> bool\nMicrosoft.AspNetCore.Http.HttpResults.VirtualFileHttpResult.EntityTag.get -> Microsoft.Net.Http.Headers.EntityTagHeaderValue?\nMicrosoft.AspNetCore.Http.HttpResults.VirtualFileHttpResult.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.VirtualFileHttpResult.FileDownloadName.get -> string?\nMicrosoft.AspNetCore.Http.HttpResults.VirtualFileHttpResult.FileLength.get -> long?\nMicrosoft.AspNetCore.Http.HttpResults.VirtualFileHttpResult.FileName.get -> string!\nMicrosoft.AspNetCore.Http.HttpResults.VirtualFileHttpResult.LastModified.get -> System.DateTimeOffset?\n```\n\n----------------------------------------\n\nTITLE: Building the SiteExtensions Project with PowerShell\nDESCRIPTION: Command to build the SiteExtensions project from within its directory using PowerShell. This is a simplified approach compared to the full build instructions referenced in the documentation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SiteExtensions/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core Request Handler Implementation\nDESCRIPTION: Implements async request handling logic with parameter binding, validation, and response generation. Supports both filtered and unfiltered request processing paths.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandler(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var httpContext_local = httpContext;\n    var myBindAsyncParam_local = await global::Microsoft.AspNetCore.Http.Generators.Tests.MySimpleBindAsyncRecord.BindAsync(httpContext);\n    if (myBindAsyncParam_local == null)\n    {\n        logOrThrowExceptionHelper.RequiredParameterNotProvided(\"MySimpleBindAsyncRecord\", \"myBindAsyncParam\", \"MySimpleBindAsyncRecord.BindAsync(HttpContext)\");\n        wasParamCheckFailure = true;\n        myBindAsyncParam_local = default!;\n    }\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n        return;\n    }\n    var result = handler(httpContext_local, myBindAsyncParam_local);\n    if (result is string)\n    {\n        httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering MSAL Authentication in ASP.NET Core Blazor WebAssembly\nDESCRIPTION: Extension methods for registering MSAL authentication services in a Blazor WebAssembly application. These methods configure the DI container with the necessary services for MSAL authentication, allowing different customization options through generic type parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/Authentication.Msal/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.MsalWebAssemblyServiceCollectionExtensions.AddMsalAuthentication(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationOptions<Microsoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions!>!>! configure) -> Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationState!, Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount!>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.MsalWebAssemblyServiceCollectionExtensions.AddMsalAuthentication<TRemoteAuthenticationState, TAccount>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationOptions<Microsoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions!>!>! configure) -> Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<TRemoteAuthenticationState!, TAccount!>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.MsalWebAssemblyServiceCollectionExtensions.AddMsalAuthentication<TRemoteAuthenticationState>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationOptions<Microsoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions!>!>! configure) -> Microsoft.Extensions.DependencyInjection.IRemoteAuthenticationBuilder<TRemoteAuthenticationState!, Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount!>!\n```\n\n----------------------------------------\n\nTITLE: Executing Return Value Asynchronously in ASP.NET Core\nDESCRIPTION: Handles the execution of different return types (IResult, string, or JSON) from an endpoint.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Logging and Exception Handling for Request Processing in C#\nDESCRIPTION: This class provides methods for logging or throwing exceptions during request processing in ASP.NET Core. It handles various scenarios such as IO exceptions, JSON parsing errors, parameter binding failures, and content type mismatches.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    // ... (other methods and logging definitions)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing JavaScriptTestEncoder class in C#\nDESCRIPTION: Implements the JavaScriptTestEncoder class with methods for encoding JavaScript content in testing scenarios.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/WebEncoders/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.WebEncoders.Testing.JavaScriptTestEncoder\nMicrosoft.Extensions.WebEncoders.Testing.JavaScriptTestEncoder.JavaScriptTestEncoder() -> void\noverride Microsoft.Extensions.WebEncoders.Testing.JavaScriptTestEncoder.Encode(string! value) -> string!\noverride Microsoft.Extensions.WebEncoders.Testing.JavaScriptTestEncoder.Encode(System.IO.TextWriter! output, char[]! value, int startIndex, int characterCount) -> void\noverride Microsoft.Extensions.WebEncoders.Testing.JavaScriptTestEncoder.Encode(System.IO.TextWriter! output, string! value, int startIndex, int characterCount) -> void\noverride Microsoft.Extensions.WebEncoders.Testing.JavaScriptTestEncoder.FindFirstCharacterToEncode(char* text, int textLength) -> int\noverride Microsoft.Extensions.WebEncoders.Testing.JavaScriptTestEncoder.MaxOutputCharactersPerInputCharacter.get -> int\noverride Microsoft.Extensions.WebEncoders.Testing.JavaScriptTestEncoder.TryEncodeUnicodeScalar(int unicodeScalar, char* buffer, int bufferLength, out int numberOfCharactersWritten) -> bool\noverride Microsoft.Extensions.WebEncoders.Testing.JavaScriptTestEncoder.WillEncode(int unicodeScalar) -> bool\n```\n\n----------------------------------------\n\nTITLE: Implementing Core Route Mapping in ASP.NET Core\nDESCRIPTION: Provides core functionality for mapping routes with handlers and metadata. Handles HTTP methods, metadata population, and request delegate creation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_NullableStringArrayParam.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Metadata Constants for Content Types in ASP.NET Core\nDESCRIPTION: Static class containing constant arrays for various content type strings used in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WebAssembly-specific Services and Infrastructure in C#\nDESCRIPTION: Defines classes and methods for WebAssembly-specific services and infrastructure, including lazy assembly loading and JavaScript interop methods. These components are essential for managing WebAssembly-specific functionality in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.WebAssembly.Services.LazyAssemblyLoader\nMicrosoft.AspNetCore.Components.WebAssembly.Services.LazyAssemblyLoader.LazyAssemblyLoader(Microsoft.JSInterop.IJSRuntime! jsRuntime) -> void\nMicrosoft.AspNetCore.Components.WebAssembly.Services.LazyAssemblyLoader.LoadAssembliesAsync(System.Collections.Generic.IEnumerable<string!>! assembliesToLoad) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<System.Reflection.Assembly!>!>!\nMicrosoft.AspNetCore.Components.WebAssembly.Infrastructure.JSInteropMethods\nstatic Microsoft.AspNetCore.Components.WebAssembly.Infrastructure.JSInteropMethods.NotifyLocationChanged(string! uri, bool isInterceptedLink) -> void\nstatic Microsoft.AspNetCore.Components.WebAssembly.Infrastructure.JSInteropMethods.NotifyLocationChanged(string! uri, string? state, bool isInterceptedLink) -> void\nstatic Microsoft.AspNetCore.Components.WebAssembly.Infrastructure.JSInteropMethods.NotifyLocationChangingAsync(string! uri, string? state, bool isInterceptedLink) -> System.Threading.Tasks.ValueTask<bool>\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Methods for UserStoreBase in C#\nDESCRIPTION: This snippet defines abstract methods for the UserStoreBase class, which handles user-related operations in ASP.NET Core Identity. It includes methods for CRUD operations on users, managing claims, logins, tokens, and roles.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Stores/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.AddClaimsAsync(TUser! user, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim!>! claims, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.AddLoginAsync(TUser! user, Microsoft.AspNetCore.Identity.UserLoginInfo! login, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.AddUserTokenAsync(TUserToken! token) -> System.Threading.Tasks.Task!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.CreateAsync(TUser! user, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.DeleteAsync(TUser! user, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.FindByEmailAsync(string! normalizedEmail, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<TUser?>!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.FindByIdAsync(string! userId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<TUser?>!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.FindByNameAsync(string! normalizedUserName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<TUser?>!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.FindTokenAsync(TUser! user, string! loginProvider, string! name, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TUserToken?>!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.FindUserAsync(TKey userId, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TUser?>!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.FindUserLoginAsync(string! loginProvider, string! providerKey, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TUserLogin?>!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.FindUserLoginAsync(TKey userId, string! loginProvider, string! providerKey, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TUserLogin?>!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.GetClaimsAsync(TUser! user, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<System.Collections.Generic.IList<System.Security.Claims.Claim!>!>!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.GetLoginsAsync(TUser! user, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<System.Collections.Generic.IList<Microsoft.AspNetCore.Identity.UserLoginInfo!>!>!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.GetUsersForClaimAsync(System.Security.Claims.Claim! claim, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<System.Collections.Generic.IList<TUser!>!>!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.RemoveClaimsAsync(TUser! user, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim!>! claims, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.RemoveLoginAsync(TUser! user, string! loginProvider, string! providerKey, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.RemoveUserTokenAsync(TUserToken! token) -> System.Threading.Tasks.Task!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.ReplaceClaimAsync(TUser! user, System.Security.Claims.Claim! claim, System.Security.Claims.Claim! newClaim, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.UpdateAsync(TUser! user, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult!>!\nabstract Microsoft.AspNetCore.Identity.UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>.Users.get -> System.Linq.IQueryable<TUser!>!\n```\n\n----------------------------------------\n\nTITLE: Component Lifecycle Methods in ASP.NET Core Blazor\nDESCRIPTION: Virtual methods defining the component lifecycle in Blazor, including initialization, parameter handling, rendering, and disposal. These methods provide hooks for custom component behavior at different stages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.ComponentBase.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder! builder) -> void\nvirtual Microsoft.AspNetCore.Components.ComponentBase.OnAfterRender(bool firstRender) -> void\nvirtual Microsoft.AspNetCore.Components.ComponentBase.OnAfterRenderAsync(bool firstRender) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Components.ComponentBase.OnInitialized() -> void\nvirtual Microsoft.AspNetCore.Components.ComponentBase.OnInitializedAsync() -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Components.ComponentBase.OnParametersSet() -> void\nvirtual Microsoft.AspNetCore.Components.ComponentBase.OnParametersSetAsync() -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Components.ComponentBase.SetParametersAsync(Microsoft.AspNetCore.Components.ParameterView parameters) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Components.ComponentBase.ShouldRender() -> bool\nvirtual Microsoft.AspNetCore.Components.OwningComponentBase.Dispose(bool disposing) -> void\n```\n\n----------------------------------------\n\nTITLE: Writing JSON Response in ASP.NET Core\nDESCRIPTION: Serializes an object to JSON and writes it to the HTTP response. It handles type-specific serialization using JsonTypeInfo and falls back to generic serialization if needed.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Using SignalR Client in C#\nDESCRIPTION: This code snippet demonstrates how to configure and use the SignalR client in a C# application. It shows creating a hub connection, setting up a message handler, and starting the connection asynchronously.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar connection = new HubConnectionBuilder()\n    .WithUrl(\"http://localhost:53353/Chat\")\n    .Build();\n\nconnection.On(\"ReceiveMessage\", (string user, string message) =>\n{\n    Console.WriteLine($\"{user}: {message}\");\n});\n\nawait connection.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining File Content Result Methods in C#\nDESCRIPTION: These methods create file content results with various options for content type, download name, and caching.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.Bytes(byte[]! contents, string? contentType = null, string? fileDownloadName = null, bool enableRangeProcessing = false, System.DateTimeOffset? lastModified = null, Microsoft.Net.Http.Headers.EntityTagHeaderValue? entityTag = null) -> Microsoft.AspNetCore.Http.HttpResults.FileContentHttpResult!\nstatic Microsoft.AspNetCore.Http.TypedResults.Bytes(System.ReadOnlyMemory<byte> contents, string? contentType = null, string? fileDownloadName = null, bool enableRangeProcessing = false, System.DateTimeOffset? lastModified = null, Microsoft.Net.Http.Headers.EntityTagHeaderValue? entityTag = null) -> Microsoft.AspNetCore.Http.HttpResults.FileContentHttpResult!\n```\n\n----------------------------------------\n\nTITLE: W3CLoggingFields Individual Field Definitions in ASP.NET Core\nDESCRIPTION: Definitions of individual fields in the W3CLoggingFields enumeration with their corresponding numeric bit values. These values are used to configure what information is included in W3C formatted logs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpLogging/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.ClientIpAddress = 4 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.ConnectionInfoFields = Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.ClientIpAddress | Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.ServerIpAddress | Microsoft.AspNetCore.HttpLogging.W3CLoggingFields.ServerPort -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.Cookie = 32768 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.Date = 1 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.Host = 8192 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.Method = 128 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.None = 0 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.ProtocolStatus = 1024 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.ProtocolVersion = 4096 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\nMicrosoft.AspNetCore.HttpLogging.W3CLoggingFields.Referer = 65536 -> Microsoft.AspNetCore.HttpLogging.W3CLoggingFields\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a custom attribute 'InterceptsLocationAttribute' used for method interception. This attribute is applied to methods and can be used multiple times.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_MultipleStringParam_StringReturn.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Implementation\nDESCRIPTION: Sealed class that implements IParameterBindingMetadata to store information about parameter binding capabilities like TryParse, BindAsync, and optionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Message for Invalid Form Request Body in ASP.NET Core\nDESCRIPTION: Creates a structured logger message definition for invalid form request bodies. This enables consistent debug logging when the framework fails to bind form data to specific parameter types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitBodyParam_ComplexReturn_Snapshot.generated.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n    LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Checking JSON Type Polymorphism in ASP.NET Core\nDESCRIPTION: Extension methods for JsonTypeInfo that determine whether a type has known polymorphism and whether a specific runtime type is compatible with the JSON type information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/HandlesEndpointsWithAndWithoutDiagnostics.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n            => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n\n        private static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n            => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\n----------------------------------------\n\nTITLE: Generating Endpoint Metadata for ASP.NET Core\nDESCRIPTION: This snippet creates metadata for an ASP.NET Core endpoint, including generated code attributes, content type metadata, and parameter binding information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nDebug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\noptions.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\noptions.EndpointBuilder.Metadata.Add(new AcceptsMetadata(contentTypes: GeneratedMetadataConstants.JsonContentType));\noptions.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"HttpContext\", new PropertyAsParameterInfo(false, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithImplicitFromBody)!.GetProperty(\"HttpContext\")!, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithImplicitFromBody).GetConstructor(new[] { typeof(Microsoft.AspNetCore.Http.HttpContext), typeof(Microsoft.AspNetCore.Http.Generators.Tests.TodoStruct) })?.GetParameters()[0]), hasTryParse: false, hasBindAsync: false, isOptional: false));\noptions.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"Todo\", new PropertyAsParameterInfo(false, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithImplicitFromBody)!.GetProperty(\"Todo\")!, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithImplicitFromBody).GetConstructor(new[] { typeof(Microsoft.AspNetCore.Http.HttpContext), typeof(Microsoft.AspNetCore.Http.Generators.Tests.TodoStruct) })?.GetParameters()[1]), hasTryParse: false, hasBindAsync: false, isOptional: false));\noptions.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\nreturn new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n```\n\n----------------------------------------\n\nTITLE: Defining KestrelConfigurationLoader Class in C#\nDESCRIPTION: This snippet defines the KestrelConfigurationLoader class, which is used to load and configure Kestrel server options from various sources.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader\nMicrosoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.AnyIPEndpoint(int port) -> Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader!\nMicrosoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.AnyIPEndpoint(int port, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions!>! configure) -> Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader!\nMicrosoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.Configuration.get -> Microsoft.Extensions.Configuration.IConfiguration!\n```\n\n----------------------------------------\n\nTITLE: Required Parameter Missing Handler\nDESCRIPTION: Handles cases where a required parameter is not provided in the request. Includes source information and implements both exception and logging logic.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_TakesCustomMetadataEmitter_Has_Metadata.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n    LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n```\n\n----------------------------------------\n\nTITLE: Defining IIS Server Authentication Scheme in C#\nDESCRIPTION: This constant defines the default authentication scheme for IIS Server in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/IIS/IIS/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.Server.IIS.IISServerDefaults.AuthenticationScheme = \"Windows\" -> string!\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: This directive enables nullable reference type checking for the C# compiler, which means non-nullable reference types must be initialized with non-null values. This helps prevent null reference exceptions by catching potential issues at compile time.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/SignalR/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Running PR Benchmark Command for ASP.NET Core\nDESCRIPTION: Example command to run a benchmark on a pull request using the JSON benchmark on the ASP.NET Citrine Linux environment, targeting the Kestrel component.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Benchmarks.md#2025-04-08_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n/benchmark json aspnet-citrine-lin kestrel\n```\n\n----------------------------------------\n\nTITLE: Implementing AuthorizationMessageHandler in C#\nDESCRIPTION: Implements the SendAsync method in the AuthorizationMessageHandler class for handling authorization in HTTP requests for ASP.NET Core WebAssembly authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Components.WebAssembly.Authentication.AuthorizationMessageHandler.SendAsync(System.Net.Http.HttpRequestMessage! request, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Net.Http.HttpResponseMessage!>!\n```\n\n----------------------------------------\n\nTITLE: Populating Metadata for ASP.NET Core Endpoint\nDESCRIPTION: This method populates metadata for an ASP.NET Core endpoint, including generated code attributes, accepts metadata, and parameter binding information. It uses reflection to analyze method parameters and sets up endpoint metadata.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitBodyParam_ComplexReturn_Snapshot.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMetadataPopulator populateMetadata = (methodInfo, options) =>\n{\n    Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n    Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n    options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n    options.EndpointBuilder.Metadata.Add(new AcceptsMetadata(type: typeof(global::Microsoft.AspNetCore.Http.Generators.Tests.Todo), isOptional: true, contentTypes: GeneratedMetadataConstants.JsonContentType));\n    var parameters = methodInfo.GetParameters();\n    options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"todo\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: true));\n    PopulateMetadataForEndpoint<global::Microsoft.AspNetCore.Http.HttpResults.Ok<global::Microsoft.AspNetCore.Http.Generators.Tests.Todo>>(methodInfo, options.EndpointBuilder);\n    return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Extension Method for RouteBuilder in C#\nDESCRIPTION: Implements a MapGet extension method for IEndpointRouteBuilder to handle HTTP GET requests. It includes metadata population, request delegate creation, and JSON response handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsTodo_Has_Metadata.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        // Metadata population logic\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        // Request delegate creation logic\n    };\n    var castHandler = Cast(handler, global::Microsoft.AspNetCore.Http.Generators.Tests.Todo () => throw null!);\n    return MapCore(\n        endpoints,\n        pattern,\n        handler,\n        GetVerb,\n        populateMetadata,\n        createRequestDelegate,\n        castHandler.Method);\n}\n```\n\n----------------------------------------\n\nTITLE: Hub Invocation Messages\nDESCRIPTION: Base classes and implementations for hub method invocations. These messages represent method calls and streaming operations on SignalR hubs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.Protocol.HubInvocationMessage\nMicrosoft.AspNetCore.SignalR.Protocol.HubInvocationMessage.Headers.get -> System.Collections.Generic.IDictionary<string!, string!>?\nMicrosoft.AspNetCore.SignalR.Protocol.HubInvocationMessage.Headers.set -> void\nMicrosoft.AspNetCore.SignalR.Protocol.HubInvocationMessage.HubInvocationMessage(string? invocationId) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.HubInvocationMessage.InvocationId.get -> string?\n\nMicrosoft.AspNetCore.SignalR.Protocol.HubMessage\nMicrosoft.AspNetCore.SignalR.Protocol.HubMessage.HubMessage() -> void\n\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.Arguments.get -> object?[]!\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.HubMethodInvocationMessage(string? invocationId, string! target, object?[]! arguments) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.HubMethodInvocationMessage(string? invocationId, string! target, object?[]! arguments, string![]? streamIds) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.StreamIds.get -> string![]?\nMicrosoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.Target.get -> string!\n```\n\n----------------------------------------\n\nTITLE: Overriding FileBufferingWriteStream Methods in C#\nDESCRIPTION: This snippet contains override method declarations for the FileBufferingWriteStream class, including methods for reading, seeking, and writing data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/WebUtilities/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.WebUtilities.FileBufferingWriteStream.ReadAsync(byte[]! buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<int>!\noverride Microsoft.AspNetCore.WebUtilities.FileBufferingWriteStream.ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<int>\noverride Microsoft.AspNetCore.WebUtilities.FileBufferingWriteStream.Seek(long offset, System.IO.SeekOrigin origin) -> long\noverride Microsoft.AspNetCore.WebUtilities.FileBufferingWriteStream.SetLength(long value) -> void\noverride Microsoft.AspNetCore.WebUtilities.FileBufferingWriteStream.Write(byte[]! buffer, int offset, int count) -> void\noverride Microsoft.AspNetCore.WebUtilities.FileBufferingWriteStream.WriteAsync(byte[]! buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\noverride Microsoft.AspNetCore.WebUtilities.FileBufferingWriteStream.WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask\n```\n\n----------------------------------------\n\nTITLE: Leak Tracking Pool Implementation\nDESCRIPTION: Object pool implementation with leak tracking capabilities for debugging and monitoring purposes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/ObjectPool/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.ObjectPool.LeakTrackingObjectPool<T>\nMicrosoft.Extensions.ObjectPool.LeakTrackingObjectPool<T>.LeakTrackingObjectPool(Microsoft.Extensions.ObjectPool.ObjectPool<T!>! inner) -> void\nMicrosoft.Extensions.ObjectPool.LeakTrackingObjectPoolProvider\nMicrosoft.Extensions.ObjectPool.LeakTrackingObjectPoolProvider.LeakTrackingObjectPoolProvider(Microsoft.Extensions.ObjectPool.ObjectPoolProvider! inner) -> void\n```\n\n----------------------------------------\n\nTITLE: Decoding Close Message in MessagePack\nDESCRIPTION: Demonstrates the decoding of a Close message in the SignalR MessagePack protocol. It includes message type and error message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_13\n\nLANGUAGE: MessagePack\nCODE:\n```\n0x92 0x07 0xa3 0x78 0x79 0x7a\n```\n\n----------------------------------------\n\nTITLE: WebWorker SignalR Connection Setup\nDESCRIPTION: Example of establishing a SignalR connection in a WebWorker context, showing script importing and connection setup with absolute URL requirement.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/ts/signalr/README.md#2025-04-08_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimportScripts('signalr.js');\n\nlet connection = new signalR.HubConnectionBuilder()\n    .withUrl(\"https://example.com/signalr/chat\")\n    .build();\n\nconnection.on(\"send\", data => {\n    console.log(data);\n});\n\nconnection.start()\n    .then(() => connection.invoke(\"send\", \"Hello\"));\n```\n\n----------------------------------------\n\nTITLE: Adding Configuration Provider to HostBuilder in C#\nDESCRIPTION: This extension method adds a configuration provider to the HostBuilder. It allows adding custom configuration sources to the application.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Owin/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic static IHostBuilder ConfigureHostConfiguration(this IHostBuilder builder, Action<IConfigurationBuilder> configureDelegate)\n{\n    return builder.ConfigureHostConfiguration((context, config) => configureDelegate(config));\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GenericHostBuilderExtensions Static Methods in C#\nDESCRIPTION: Defines static extension methods for the GenericHostBuilderExtensions class, providing methods to configure web host defaults.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DefaultBuilder/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Hosting.GenericHostBuilderExtensions\nstatic Microsoft.Extensions.Hosting.GenericHostBuilderExtensions.ConfigureWebHostDefaults(this Microsoft.Extensions.Hosting.IHostBuilder! builder, System.Action<Microsoft.AspNetCore.Hosting.IWebHostBuilder!>! configure) -> Microsoft.Extensions.Hosting.IHostBuilder!\nstatic Microsoft.Extensions.Hosting.GenericHostBuilderExtensions.ConfigureWebHostDefaults(this Microsoft.Extensions.Hosting.IHostBuilder! builder, System.Action<Microsoft.AspNetCore.Hosting.IWebHostBuilder!>! configure, System.Action<Microsoft.Extensions.Hosting.WebHostBuilderOptions!>! configureOptions) -> Microsoft.Extensions.Hosting.IHostBuilder!\n```\n\n----------------------------------------\n\nTITLE: Checking for Interactive Routing Acceptance in C#\nDESCRIPTION: Extension method for HttpContext to check if it accepts interactive routing for Razor Components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Endpoints/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.Routing.RazorComponentsEndpointHttpContextExtensions.AcceptsInteractiveRouting(this Microsoft.AspNetCore.Http.HttpContext! context) -> bool\n```\n\n----------------------------------------\n\nTITLE: Adding Endpoints API Explorer to ASP.NET Core Services\nDESCRIPTION: Extension method that adds the Endpoints API Explorer services to the service collection. This enables API exploration for Minimal API endpoints in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ApiExplorer/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.EndpointMetadataApiExplorerServiceCollectionExtensions.AddEndpointsApiExplorer(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Defining HubException Class in SignalR\nDESCRIPTION: Exception class for SignalR hub operations. Provides various constructors to create exceptions with different levels of detail, including support for serialization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.HubException\nMicrosoft.AspNetCore.SignalR.HubException.HubException() -> void\nMicrosoft.AspNetCore.SignalR.HubException.HubException(string? message) -> void\nMicrosoft.AspNetCore.SignalR.HubException.HubException(string? message, System.Exception? innerException) -> void\nMicrosoft.AspNetCore.SignalR.HubException.HubException(System.Runtime.Serialization.SerializationInfo! info, System.Runtime.Serialization.StreamingContext context) -> void\n```\n\n----------------------------------------\n\nTITLE: Request Handler with Content Negotiation in ASP.NET Core\nDESCRIPTION: This snippet shows a request handler that performs parameter binding, handles errors, and implements basic content negotiation. It sets the appropriate content type based on the result type (string or other) and writes the response asynchronously.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandler(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var myBindAsyncParam_local = await global::Microsoft.AspNetCore.Http.Generators.Tests.MySimpleBindAsyncRecord.BindAsync(httpContext);\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n        return;\n    }\n    var result = handler(myBindAsyncParam_local);\n    if (result is string)\n    {\n        httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n    }\n    else\n    {\n        httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n    }\n    await httpContext.Response.WriteAsync(result);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IServerIntegratedAuth Interface in ASP.NET Core\nDESCRIPTION: Interface that defines properties for server integrated authentication. It exposes a boolean to determine if authentication is enabled and a string property for the authentication scheme.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Server.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Hosting.Server.IServerIntegratedAuth\nMicrosoft.AspNetCore.Hosting.Server.IServerIntegratedAuth.AuthenticationScheme.get -> string!\nMicrosoft.AspNetCore.Hosting.Server.IServerIntegratedAuth.IsEnabled.get -> bool\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: This directive enables nullable reference type checking, which helps catch potential null reference exceptions at compile time. When enabled, reference types are non-nullable by default and must be explicitly marked as nullable using the '?' suffix when null values are allowed.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/IIS/IIS/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing UnprocessableEntity Result in ASP.NET Core\nDESCRIPTION: API signatures for the UnprocessableEntity class, which returns a 422 Unprocessable Entity response with no content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.UnprocessableEntity\nMicrosoft.AspNetCore.Http.HttpResults.UnprocessableEntity.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.UnprocessableEntity.StatusCode.get -> int\n```\n\n----------------------------------------\n\nTITLE: Using Generic UnprocessableEntity<TValue> in ASP.NET Core\nDESCRIPTION: API signatures for the generic UnprocessableEntity<TValue> class, which returns a 422 Unprocessable Entity response with a value of type TValue.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.UnprocessableEntity<TValue>\nMicrosoft.AspNetCore.Http.HttpResults.UnprocessableEntity<TValue>.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.UnprocessableEntity<TValue>.StatusCode.get -> int\nMicrosoft.AspNetCore.Http.HttpResults.UnprocessableEntity<TValue>.Value.get -> TValue?\n```\n\n----------------------------------------\n\nTITLE: Authentication Builder Extensions\nDESCRIPTION: Extension methods for adding certificate authentication to the authentication builder\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Certificate/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.CertificateAuthenticationAppBuilderExtensions.AddCertificate(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\nstatic Microsoft.Extensions.DependencyInjection.CertificateAuthenticationAppBuilderExtensions.AddCertificate(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, string! authenticationScheme) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Event Source in C# for ASP.NET Core\nDESCRIPTION: This snippet demonstrates the creation of a custom EventSource for Authentication in ASP.NET Core. It includes methods for tracking authentication middleware start, end, and failure events, as well as an EventCounter for measuring duration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/EventSourceAndCounters.md#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Diagnostics.Tracing;\nusing Microsoft.AspNetCore.Http;\n\nnamespace Microsoft.AspNetCore.Authentication.Internal\n{\n    [EventSource(Name = \"Microsoft-AspNetCore-Authentication\")]\n    public class AuthenticationEventSource : EventSource\n    {\n        public static readonly AuthenticationEventSource Log = new AuthenticationEventSource();\n        private readonly EventCounter _authenticationMiddlewareDuration;\n\n        private AuthenticationEventSource()\n        {\n            _authenticationMiddlewareDuration = new EventCounter(\"AuthenticationMiddlewareDuration\", this);\n        }\n\n        [NonEvent]\n        internal void AuthenticationMiddlewareStart(HttpContext context)\n        {\n            if (IsEnabled(EventLevel.Informational, EventKeywords.None))\n            {\n                AuthenticationMiddlewareStart(context.TraceIdentifier, context.Request.Path.Value);\n            }\n        }\n\n        [NonEvent]\n        internal void AuthenticationMiddlewareEnd(HttpContext context, TimeSpan duration)\n        {\n            if (IsEnabled())\n            {\n                _authenticationMiddlewareDuration.WriteMetric((float)duration.TotalMilliseconds);\n\n                if (IsEnabled(EventLevel.Informational, EventKeywords.None))\n                {\n                    AuthenticationMiddlewareEnd(context.TraceIdentifier, context.Request.Path.Value, duration.TotalMilliseconds);\n                }\n            }\n        }\n\n        [NonEvent]\n        internal void AuthenticationMiddlewareFailure(HttpContext context, Exception ex)\n        {\n            if(IsEnabled(EventLevel.Error, EventKeywords.None))\n            {\n                AuthenticationMiddlewareFailure(context.TraceIdentifier, context.Request.Path.Value, ex.GetType().FullName, ex.Message, ex.ToString());\n            }\n        }\n\n        [Event(eventId: 1, Level = EventLevel.Informational)]\n        private void AuthenticationMiddlewareStart(string traceIdentifier, string path) => WriteEvent(1, traceIdentifier, path);\n\n        [Event(eventId: 2, Level = EventLevel.Informational)]\n        private void AuthenticationMiddlewareEnd(string traceIdentifier, string path, double durationMilliseconds) => WriteEvent(2, traceIdentifier, path, durationMilliseconds);\n\n        [Event(eventId: 3, Level = EventLevel.Error)]\n        private void AuthenticationMiddlewareFailure(string traceIdentifier, string value, string exceptionTypeName, string message, string fullException) => WriteEvent(3, traceIdentifier, value, exceptionTypeName, message, fullException);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Object Pool Base Classes and Interfaces\nDESCRIPTION: Defines the core abstract classes and interfaces for object pooling, including ObjectPool<T>, ObjectPoolProvider, and IPooledObjectPolicy<T>.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/ObjectPool/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.Extensions.ObjectPool.ObjectPool<T>.Get() -> T!\nabstract Microsoft.Extensions.ObjectPool.ObjectPool<T>.Return(T! obj) -> void\nabstract Microsoft.Extensions.ObjectPool.ObjectPoolProvider.Create<T>(Microsoft.Extensions.ObjectPool.IPooledObjectPolicy<T!>! policy) -> Microsoft.Extensions.ObjectPool.ObjectPool<T!>!\nabstract Microsoft.Extensions.ObjectPool.PooledObjectPolicy<T>.Create() -> T\nabstract Microsoft.Extensions.ObjectPool.PooledObjectPolicy<T>.Return(T obj) -> bool\n```\n\n----------------------------------------\n\nTITLE: Extending Dependency Injection for Validation in C#\nDESCRIPTION: This static class provides an extension method to add validation services to the dependency injection container in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.DependencyInjection.ValidationServiceCollectionExtensions\nstatic Microsoft.Extensions.DependencyInjection.ValidationServiceCollectionExtensions.AddValidation(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Http.Validation.ValidationOptions!>? configureOptions = null) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Defining MultiplexedConnectionBuilder Class in C#\nDESCRIPTION: This snippet defines the MultiplexedConnectionBuilder class which implements IMultiplexedConnectionBuilder for building multiplexed connection pipelines.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Connections.MultiplexedConnectionBuilder\nMicrosoft.AspNetCore.Connections.MultiplexedConnectionBuilder.ApplicationServices.get -> System.IServiceProvider!\nMicrosoft.AspNetCore.Connections.MultiplexedConnectionBuilder.Build() -> Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate!\nMicrosoft.AspNetCore.Connections.MultiplexedConnectionBuilder.MultiplexedConnectionBuilder(System.IServiceProvider! applicationServices) -> void\nMicrosoft.AspNetCore.Connections.MultiplexedConnectionBuilder.Use(System.Func<Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate!, Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate!>! middleware) -> Microsoft.AspNetCore.Connections.IMultiplexedConnectionBuilder!\n```\n\n----------------------------------------\n\nTITLE: Redis Cache Options Configuration\nDESCRIPTION: Configuration options class for Redis cache including connection settings, instance naming, and profiling capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PublicAPI/net8.0/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.Configuration.get -> string?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.Configuration.set -> void\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ConfigurationOptions.get -> StackExchange.Redis.ConfigurationOptions?\nMicrosoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions.ConfigurationOptions.set -> void\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Content Type in ASP.NET Core\nDESCRIPTION: Defines logging behavior and exception handling for unexpected non-form content types in request processing. Uses LoggerMessage.Define for efficient logging of content type mismatches.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n            LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive that enables nullable reference type checking for the current file or project scope. When enabled, the compiler performs static analysis to help identify potential null reference issues.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/MicrosoftAccount/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: A compiler directive that enables nullable reference type annotations for improved null safety in C# code. When enabled, reference types are non-nullable by default, and nullable reference types must be explicitly marked with a '?' suffix.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics.EntityFrameworkCore/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: HTTP Header Value Classes and Methods\nDESCRIPTION: Comprehensive set of C# class definitions and methods for working with HTTP headers in ASP.NET Core. Includes classes for handling various header types with parsing, comparison, and string conversion capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Headers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Net.Http.Headers.MediaTypeHeaderValueComparer.Compare(Microsoft.Net.Http.Headers.MediaTypeHeaderValue? mediaType1, Microsoft.Net.Http.Headers.MediaTypeHeaderValue? mediaType2) -> int\n\nMicrosoft.Net.Http.Headers.NameValueHeaderValue.Copy() -> Microsoft.Net.Http.Headers.NameValueHeaderValue!\nMicrosoft.Net.Http.Headers.NameValueHeaderValue.CopyAsReadOnly() -> Microsoft.Net.Http.Headers.NameValueHeaderValue!\nMicrosoft.Net.Http.Headers.NameValueHeaderValue.GetUnescapedValue() -> Microsoft.Extensions.Primitives.StringSegment\n\nMicrosoft.Net.Http.Headers.SetCookieHeaderValue.SetCookieHeaderValue(Microsoft.Extensions.Primitives.StringSegment name) -> void\nMicrosoft.Net.Http.Headers.SetCookieHeaderValue.SetCookieHeaderValue(Microsoft.Extensions.Primitives.StringSegment name, Microsoft.Extensions.Primitives.StringSegment value) -> void\n\nstatic Microsoft.Net.Http.Headers.CacheControlHeaderValue.Parse(Microsoft.Extensions.Primitives.StringSegment input) -> Microsoft.Net.Http.Headers.CacheControlHeaderValue!\nstatic Microsoft.Net.Http.Headers.CacheControlHeaderValue.TryParse(Microsoft.Extensions.Primitives.StringSegment input, out Microsoft.Net.Http.Headers.CacheControlHeaderValue? parsedValue) -> bool\n```\n\n----------------------------------------\n\nTITLE: Implementing AuthorizationBuilder in C#\nDESCRIPTION: The AuthorizationBuilder class is used to configure authorization services in ASP.NET Core applications. It provides a fluent API for adding and configuring authorization policies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationBuilder\nMicrosoft.AspNetCore.Authorization.AuthorizationBuilder.AuthorizationBuilder(Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining StackExchangeRedisCacheServiceCollectionExtensions in C# for ASP.NET Core\nDESCRIPTION: Defines extension methods for IServiceCollection to add StackExchange Redis caching services to the dependency injection container in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.DependencyInjection.StackExchangeRedisCacheServiceCollectionExtensions\nstatic Microsoft.Extensions.DependencyInjection.StackExchangeRedisCacheServiceCollectionExtensions.AddStackExchangeRedisCache(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.Extensions.Caching.StackExchangeRedis.RedisCacheOptions!>! setupAction) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Defining IAuthorizationMiddlewareResultHandler Interface in C#\nDESCRIPTION: Declares the IAuthorizationMiddlewareResultHandler interface with a HandleAsync method for processing authorization results.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Policy/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.IAuthorizationMiddlewareResultHandler\nMicrosoft.AspNetCore.Authorization.IAuthorizationMiddlewareResultHandler.HandleAsync(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy, Microsoft.AspNetCore.Authorization.Policy.PolicyAuthorizationResult! authorizeResult) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Response Writing and JSON Serialization Utilities\nDESCRIPTION: Handles writing different types of responses including IResult objects, strings and JSON data. Includes special handling for polymorphic types and trimming suppression.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleEnumParam_StringReturn.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Streaming Data from SignalR Hub as Channel in C#\nDESCRIPTION: Implements core functionality for streaming data from a SignalR hub method as a ChannelReader, allowing for efficient consumption of streamed data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.SignalR.Client.HubConnection.StreamAsChannelCoreAsync(string! methodName, System.Type! returnType, object?[]! args, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<System.Threading.Channels.ChannelReader<object?>!>!\n```\n\n----------------------------------------\n\nTITLE: AuthorizationResult Class Definition in C#\nDESCRIPTION: Definition of the AuthorizationResult class that represents the outcome of an authorization operation, indicating success or providing failure details.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationResult\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationResult.Failure.get -> Microsoft.AspNetCore.Authorization.AuthorizationFailure?\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationResult.Succeeded.get -> bool\n```\n\n----------------------------------------\n\nTITLE: Writing JSON Response in ASP.NET Core\nDESCRIPTION: This method writes a JSON response asynchronously. It handles type-specific serialization and uses the appropriate JSON serialization options based on the runtime type of the value.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: TagHelperContent Abstract Methods\nDESCRIPTION: Abstract methods for the TagHelperContent class that handle appending, getting, and manipulating HTML content in tag helpers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Razor/Razor/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Razor.TagHelpers.TagHelperContent.Append(string unencoded) -> Microsoft.AspNetCore.Razor.TagHelpers.TagHelperContent\nabstract Microsoft.AspNetCore.Razor.TagHelpers.TagHelperContent.AppendHtml(Microsoft.AspNetCore.Html.IHtmlContent htmlContent) -> Microsoft.AspNetCore.Razor.TagHelpers.TagHelperContent\nabstract Microsoft.AspNetCore.Razor.TagHelpers.TagHelperContent.Clear() -> Microsoft.AspNetCore.Razor.TagHelpers.TagHelperContent\n```\n\n----------------------------------------\n\nTITLE: Exception Logging Helper in ASP.NET Core\nDESCRIPTION: Implements a helper class for logging or throwing exceptions based on configuration. It handles various error scenarios in request processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Route Handler Mapping Implementation in C#\nDESCRIPTION: Core method for mapping route handlers in ASP.NET Core. Handles route pattern matching and request delegation with metadata population.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Building ASP.NET Core Authorization Components in PowerShell\nDESCRIPTION: Command to build the ASP.NET Core authorization components from source. This should be run from the parent 'security' directory to properly build the authorization subsystem.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: Overriding HttpRequestStreamReader Methods in C#\nDESCRIPTION: This snippet contains override method declarations for the HttpRequestStreamReader class, including methods for reading characters and lines from the stream.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/WebUtilities/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.WebUtilities.HttpRequestStreamReader.Dispose(bool disposing) -> void\noverride Microsoft.AspNetCore.WebUtilities.HttpRequestStreamReader.Peek() -> int\noverride Microsoft.AspNetCore.WebUtilities.HttpRequestStreamReader.Read() -> int\noverride Microsoft.AspNetCore.WebUtilities.HttpRequestStreamReader.Read(char[]! buffer, int index, int count) -> int\noverride Microsoft.AspNetCore.WebUtilities.HttpRequestStreamReader.Read(System.Span<char> buffer) -> int\noverride Microsoft.AspNetCore.WebUtilities.HttpRequestStreamReader.ReadAsync(char[]! buffer, int index, int count) -> System.Threading.Tasks.Task<int>!\noverride Microsoft.AspNetCore.WebUtilities.HttpRequestStreamReader.ReadAsync(System.Memory<char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<int>\noverride Microsoft.AspNetCore.WebUtilities.HttpRequestStreamReader.ReadLine() -> string?\noverride Microsoft.AspNetCore.WebUtilities.HttpRequestStreamReader.ReadLineAsync() -> System.Threading.Tasks.Task<string?>!\noverride Microsoft.AspNetCore.WebUtilities.HttpRequestStreamReader.ReadToEndAsync() -> System.Threading.Tasks.Task<string!>!\n```\n\n----------------------------------------\n\nTITLE: Defining ExternalLoginModel for ASP.NET Core Identity UI V5\nDESCRIPTION: This snippet defines the ExternalLoginModel class and its nested InputModel for ASP.NET Core Identity UI version 5. It includes properties for managing external login information and user input.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ExternalLoginModel\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ExternalLoginModel.ErrorMessage.get -> string?\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ExternalLoginModel.ErrorMessage.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ExternalLoginModel.ExternalLoginModel() -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ExternalLoginModel.Input.get -> Microsoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ExternalLoginModel.InputModel!\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ExternalLoginModel.Input.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ExternalLoginModel.InputModel\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ExternalLoginModel.InputModel.Email.get -> string!\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ExternalLoginModel.InputModel.Email.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ExternalLoginModel.InputModel.InputModel() -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ExternalLoginModel.ProviderDisplayName.get -> string?\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ExternalLoginModel.ProviderDisplayName.set -> void\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ExternalLoginModel.ReturnUrl.get -> string?\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Internal.ExternalLoginModel.ReturnUrl.set -> void\n```\n\n----------------------------------------\n\nTITLE: JSON Response Writer Implementation\nDESCRIPTION: Handles writing JSON responses with support for polymorphic types and runtime type checking.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitSource_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: FieldIdentifier Structure API for ASP.NET Core Blazor Forms\nDESCRIPTION: The FieldIdentifier structure identifies a specific field within a form model. It combines the model object reference and field name to uniquely identify form fields for tracking changes and validation state.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Forms/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Forms.FieldIdentifier\nMicrosoft.AspNetCore.Components.Forms.FieldIdentifier.Equals(Microsoft.AspNetCore.Components.Forms.FieldIdentifier otherIdentifier) -> bool\nMicrosoft.AspNetCore.Components.Forms.FieldIdentifier.FieldIdentifier() -> void\nMicrosoft.AspNetCore.Components.Forms.FieldIdentifier.FieldIdentifier(object! model, string! fieldName) -> void\nMicrosoft.AspNetCore.Components.Forms.FieldIdentifier.FieldName.get -> string!\nMicrosoft.AspNetCore.Components.Forms.FieldIdentifier.Model.get -> object!\noverride Microsoft.AspNetCore.Components.Forms.FieldIdentifier.Equals(object? obj) -> bool\noverride Microsoft.AspNetCore.Components.Forms.FieldIdentifier.GetHashCode() -> int\nstatic Microsoft.AspNetCore.Components.Forms.FieldIdentifier.Create<TField>(System.Linq.Expressions.Expression<System.Func<TField>!>! accessor) -> Microsoft.AspNetCore.Components.Forms.FieldIdentifier\n```\n\n----------------------------------------\n\nTITLE: Generic AuthorizationHandler Classes in C#\nDESCRIPTION: Generic AuthorizationHandler class definitions for handling different types of authorization requirements, with or without resource-specific context.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationHandler<TRequirement, TResource>\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationHandler<TRequirement, TResource>.AuthorizationHandler() -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationHandler<TRequirement>\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationHandler<TRequirement>.AuthorizationHandler() -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring Request Timeouts for Endpoints in C#\nDESCRIPTION: These extension methods allow configuring request timeouts for endpoints using either a policy name or a specific timeout duration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.RequestTimeoutsIEndpointConventionBuilderExtensions.WithRequestTimeout(this Microsoft.AspNetCore.Builder.IEndpointConventionBuilder! builder, string! policyName) -> Microsoft.AspNetCore.Builder.IEndpointConventionBuilder!\nstatic Microsoft.AspNetCore.Builder.RequestTimeoutsIEndpointConventionBuilderExtensions.WithRequestTimeout(this Microsoft.AspNetCore.Builder.IEndpointConventionBuilder! builder, System.TimeSpan timeout) -> Microsoft.AspNetCore.Builder.IEndpointConventionBuilder!\n```\n\n----------------------------------------\n\nTITLE: Request Delegate Error Handling and Logging in ASP.NET Core\nDESCRIPTION: Provides consistent error handling and logging for request processing failures. This helper supports both throwing exceptions and logging based on configuration, with detailed error messages for different failure scenarios.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Post_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n}\n```\n\n----------------------------------------\n\nTITLE: MIT License Header for .NET Foundation Code\nDESCRIPTION: Standard license header indicating the code is licensed to the .NET Foundation under the MIT license. This header appears in most source files in the ASP.NET Core project.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/eng/LicenseHeader.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n```\n\n----------------------------------------\n\nTITLE: Implementing StatusCodePagesMiddleware in C#\nDESCRIPTION: This code defines the StatusCodePagesMiddleware class, which is responsible for handling HTTP status code responses in ASP.NET Core applications. It includes the constructor and the Invoke method for processing requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Diagnostics.StatusCodePagesMiddleware\nMicrosoft.AspNetCore.Diagnostics.StatusCodePagesMiddleware.Invoke(Microsoft.AspNetCore.Http.HttpContext! context) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Diagnostics.StatusCodePagesMiddleware.StatusCodePagesMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Builder.StatusCodePagesOptions!>! options) -> void\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft.AspNetCore.Components.QuickGrid.EntityFrameworkAdapter via dotnet CLI\nDESCRIPTION: This command adds the Microsoft.AspNetCore.Components.QuickGrid.EntityFrameworkAdapter package to your project using the dotnet CLI.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/QuickGrid/Microsoft.AspNetCore.Components.QuickGrid.EntityFrameworkAdapter/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.Components.QuickGrid.EntityFrameworkAdapter\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core Filtered Request Handler with Interface-Based Binding\nDESCRIPTION: Implements a filtered request handler with interface-based parameter binding. It handles parameter validation, sets appropriate status codes, and processes the request through the filter pipeline with proper context creation and result execution.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandlerFiltered(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var httpContext_local = httpContext;\n    var myBindAsyncParam_local = await global::Microsoft.AspNetCore.Http.Generators.Tests.IBindAsync<global::Microsoft.AspNetCore.Http.Generators.Tests.MyBindAsyncFromInterfaceRecord>.BindAsync(httpContext);\n    if (myBindAsyncParam_local == null)\n    {\n        logOrThrowExceptionHelper.RequiredParameterNotProvided(\"MyBindAsyncFromInterfaceRecord\", \"myBindAsyncParam\", \"MyBindAsyncFromInterfaceRecord.BindAsync(HttpContext)\");\n        wasParamCheckFailure = true;\n        myBindAsyncParam_local = default!;\n    }\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n    }\n    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.HttpContext, global::Microsoft.AspNetCore.Http.Generators.Tests.MyBindAsyncFromInterfaceRecord?>(httpContext, httpContext_local, myBindAsyncParam_local));\n    if (result is not null)\n    {\n        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Default Object Pool Implementation\nDESCRIPTION: Implementation of the default object pool with configurable maximum retention capacity.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/ObjectPool/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.ObjectPool.DefaultObjectPool<T>\nMicrosoft.Extensions.ObjectPool.DefaultObjectPool<T>.DefaultObjectPool(Microsoft.Extensions.ObjectPool.IPooledObjectPolicy<T!>! policy) -> void\nMicrosoft.Extensions.ObjectPool.DefaultObjectPool<T>.DefaultObjectPool(Microsoft.Extensions.ObjectPool.IPooledObjectPolicy<T!>! policy, int maximumRetained) -> void\n```\n\n----------------------------------------\n\nTITLE: Decoding Sequence Message in MessagePack\nDESCRIPTION: Demonstrates the decoding of a Sequence message in the SignalR MessagePack protocol. It includes message type and sequence ID.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_16\n\nLANGUAGE: MessagePack\nCODE:\n```\n0x92 0x09 0xcc 0x13\n```\n\n----------------------------------------\n\nTITLE: Mapping Core Route Handler in ASP.NET Core\nDESCRIPTION: This method maps a core route handler to the endpoint builder. It takes various parameters including the route pattern, handler delegate, HTTP methods, and metadata populator.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive that enables nullable reference type checking to help prevent null reference exceptions. This setting enforces strict null checking at compile time.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Google/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: FragmentString Operators in ASP.NET Core\nDESCRIPTION: Equality and inequality operators for comparing FragmentString objects in ASP.NET Core HTTP.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.FragmentString.operator !=(Microsoft.AspNetCore.Http.FragmentString left, Microsoft.AspNetCore.Http.FragmentString right) -> bool\nstatic Microsoft.AspNetCore.Http.FragmentString.operator ==(Microsoft.AspNetCore.Http.FragmentString left, Microsoft.AspNetCore.Http.FragmentString right) -> bool\n```\n\n----------------------------------------\n\nTITLE: Implementing LogOrThrowExceptionHelper for Error Handling in ASP.NET Core C#\nDESCRIPTION: A utility class that handles errors during request processing by either logging them or throwing exceptions based on configuration. It provides specialized error handling for various failure scenarios like JSON parsing errors, parameter binding failures, and content type validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_NullableReturn.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n\n    public void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n\n    public void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n\n    public void ImplicitBodyNotProvided(string parameterName)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n\n    public void UnexpectedJsonContentType(string? contentType)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n            throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n\n    public void UnexpectedNonFormContentType(string? contentType)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n            throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n\n    public void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Defining KestrelServerOptions Methods in C#\nDESCRIPTION: This snippet defines methods for configuring Kestrel server options, including listening on localhost, named pipes, and Unix sockets. It also includes properties for header encoding selection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.ListenLocalhost(int port, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions!>! configure) -> void\nMicrosoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.ListenNamedPipe(string! pipeName) -> void\nMicrosoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.ListenNamedPipe(string! pipeName, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions!>! configure) -> void\nMicrosoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.ListenUnixSocket(string! socketPath) -> void\nMicrosoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.ListenUnixSocket(string! socketPath, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions!>! configure) -> void\nMicrosoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.RequestHeaderEncodingSelector.get -> System.Func<string!, System.Text.Encoding?>!\nMicrosoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.RequestHeaderEncodingSelector.set -> void\nMicrosoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.ResponseHeaderEncodingSelector.get -> System.Func<string!, System.Text.Encoding?>!\nMicrosoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.ResponseHeaderEncodingSelector.set -> void\n```\n\n----------------------------------------\n\nTITLE: Certificate Extension Method\nDESCRIPTION: Extension method to check if an X509Certificate2 is self-signed\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Certificate/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Authentication.Certificate.X509Certificate2Extensions.IsSelfSigned(this System.Security.Cryptography.X509Certificates.X509Certificate2! certificate) -> bool\n```\n\n----------------------------------------\n\nTITLE: Form Content Type Validation in ASP.NET Core\nDESCRIPTION: Validates form submission content type headers, throwing BadHttpRequestException with 415 status code if invalid.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Decoding Close Message with Reconnect Option in MessagePack\nDESCRIPTION: Illustrates the decoding of a Close message with the AllowReconnect option in the SignalR MessagePack protocol. It includes message type, error message, and the reconnect flag.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_14\n\nLANGUAGE: MessagePack\nCODE:\n```\n0x93 0x07 0xa3 0x78 0x79 0x7a 0xc3\n```\n\n----------------------------------------\n\nTITLE: Decoding StreamInvocation Message in MessagePack\nDESCRIPTION: Demonstrates the decoding process of a StreamInvocation message in the SignalR MessagePack protocol. It includes a detailed breakdown of each byte in the message payload.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_6\n\nLANGUAGE: MessagePack\nCODE:\n```\n0x96 0x04 0x80 0xa3 0x78 0x79 0x7a 0xa6 0x6d 0x65 0x74 0x68 0x6f 0x64 0x91 0x2a 0x90\n```\n\n----------------------------------------\n\nTITLE: Defining IExceptionHandler Interface in C#\nDESCRIPTION: This snippet defines the IExceptionHandler interface, which provides a contract for implementing custom exception handlers in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Diagnostics.IExceptionHandler\nMicrosoft.AspNetCore.Diagnostics.IExceptionHandler.TryHandleAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext, System.Exception! exception, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<bool>\n```\n\n----------------------------------------\n\nTITLE: Implementing ViewResult Class in C#\nDESCRIPTION: Defines the ViewResult class with properties for representing the result of a view in ASP.NET Core MVC.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ViewResult\nMicrosoft.AspNetCore.Mvc.ViewResult.ContentType.get -> string?\nMicrosoft.AspNetCore.Mvc.ViewResult.ContentType.set -> void\nMicrosoft.AspNetCore.Mvc.ViewResult.Model.get -> object?\nMicrosoft.AspNetCore.Mvc.ViewResult.StatusCode.get -> int?\nMicrosoft.AspNetCore.Mvc.ViewResult.StatusCode.set -> void\nMicrosoft.AspNetCore.Mvc.ViewResult.TempData.get -> Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataDictionary!\nMicrosoft.AspNetCore.Mvc.ViewResult.TempData.set -> void\nMicrosoft.AspNetCore.Mvc.ViewResult.ViewData.get -> Microsoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary!\nMicrosoft.AspNetCore.Mvc.ViewResult.ViewData.set -> void\nMicrosoft.AspNetCore.Mvc.ViewResult.ViewEngine.get -> Microsoft.AspNetCore.Mvc.ViewEngines.IViewEngine?\nMicrosoft.AspNetCore.Mvc.ViewResult.ViewEngine.set -> void\nMicrosoft.AspNetCore.Mvc.ViewResult.ViewName.get -> string?\nMicrosoft.AspNetCore.Mvc.ViewResult.ViewName.set -> void\nMicrosoft.AspNetCore.Mvc.ViewResult.ViewResult() -> void\n```\n\n----------------------------------------\n\nTITLE: Unit Testing EventSources in C# for ASP.NET Core\nDESCRIPTION: This snippet shows how to write a unit test for an EventSource using the EventSourceTestBase class. It demonstrates setting up the test, collecting events, and asserting on the collected events using the EventAssert helper.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/EventSourceAndCounters.md#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// The base class MUST be used for EventSource testing because EventSources are global and parallel tests can cause issues.\n// The base class adds some code to handle that.\npublic class SomeTest : EventSourceTestBase\n{\n    [Fact]\n    public void TestName()\n    {\n        // Arrange: Explicitly register the event sources to listen to.\n        CollectFrom(\"Microsoft-AspNetCore-SomeEventSourceName\");\n\n        // Act: Do things that causes the events to be fired.\n        DoStuff();\n\n        // Assert: Get the collected events and assert that they match the expectations\n        var events = GetEvents();\n\n        // EventAssert is a helper for testing events. It's a little odd in that EventAssert.Event returns a \"builder\"\n        // that creates an Action<EventWrittenEventArgs> that will assert the things you configured when called.\n        // This pattern makes for clearer test code.\n        EventAssert.Collection(events,\n            EventAssert.Event(1, \"Test\", EventLevel.Informational),\n            EventAssert.Event(2, \"TestWithPayload\", EventLevel.Verbose)\n                .Payload(\"payload1\", 42)\n                .Payload(\"payload2\", 4.2));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Activating Environment Variables for ASP.NET Core Benchmarks\nDESCRIPTION: Commands to set environment variables using activation scripts for PowerShell and Bash. These scripts are located at the root of the repository.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/perf/Microbenchmarks/readme.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n. .\\activate.ps1\n```\n\nLANGUAGE: bash\nCODE:\n```\nactivate.sh\n```\n\n----------------------------------------\n\nTITLE: Defining Windows Authentication Scheme Constant in HttpSysDefaults\nDESCRIPTION: Declaration of a nullable-enabled constant string that defines the default authentication scheme for HttpSys as 'Windows'.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/HttpSys/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\nconst Microsoft.AspNetCore.Server.HttpSys.HttpSysDefaults.AuthenticationScheme = \"Windows\" -> string!\n```\n\n----------------------------------------\n\nTITLE: Implementing LogOrThrowExceptionHelper Class in C#\nDESCRIPTION: A sealed class that handles logging and exception throwing for request parameter binding errors. It provides methods for handling various error scenarios like invalid JSON, missing parameters, and invalid content types. The class uses dependency injection to obtain logging services and configuration options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_JsonBodyOrService_HandlesBothJsonAndService.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n\n    // Additional methods omitted for brevity\n```\n\n----------------------------------------\n\nTITLE: TagHelperAttribute Methods and Properties\nDESCRIPTION: Methods and properties for the TagHelperAttribute class that handle attribute manipulation and value access in tag helpers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Razor/Razor/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute.Name.get -> string\nMicrosoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute.Value.get -> object\nMicrosoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute.TagHelperAttribute(string name) -> void\nMicrosoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute.TagHelperAttribute(string name, object value) -> void\n```\n\n----------------------------------------\n\nTITLE: ModelMetadata Type and Property Methods in ASP.NET Core MVC\nDESCRIPTION: Virtual methods in the ModelMetadata class for retrieving metadata for types and properties. These methods support model binding and validation in ASP.NET Core MVC applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata.GetMetadataForProperties(System.Type! modelType) -> System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata!>!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata.GetMetadataForType(System.Type! modelType) -> Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata.HasValidators.get -> bool?\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata.PropertyValidationFilter.get -> Microsoft.AspNetCore.Mvc.ModelBinding.Validation.IPropertyValidationFilter?\n```\n\n----------------------------------------\n\nTITLE: Creating HTTP Results with Factory Methods in ASP.NET Core\nDESCRIPTION: Static factory methods for creating various HTTP results, including Accepted, AcceptedAtRoute, BadRequest, and content responses like Bytes and Challenge.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.HttpResults.EmptyHttpResult.Instance.get -> Microsoft.AspNetCore.Http.HttpResults.EmptyHttpResult! (forwarded, contained in Microsoft.AspNetCore.Http.Abstractions)\nstatic Microsoft.AspNetCore.Http.Results.Accepted(string? uri = null, object? value = null) -> Microsoft.AspNetCore.Http.IResult!\nstatic Microsoft.AspNetCore.Http.Results.Accepted<TValue>(string? uri = null, TValue? value = default(TValue?)) -> Microsoft.AspNetCore.Http.IResult!\nstatic Microsoft.AspNetCore.Http.Results.AcceptedAtRoute(string? routeName = null, object? routeValues = null, object? value = null) -> Microsoft.AspNetCore.Http.IResult!\nstatic Microsoft.AspNetCore.Http.Results.AcceptedAtRoute(string? routeName, Microsoft.AspNetCore.Routing.RouteValueDictionary? routeValues, object? value = null) -> Microsoft.AspNetCore.Http.IResult!\nstatic Microsoft.AspNetCore.Http.Results.AcceptedAtRoute<TValue>(string? routeName = null, object? routeValues = null, TValue? value = default(TValue?)) -> Microsoft.AspNetCore.Http.IResult!\nstatic Microsoft.AspNetCore.Http.Results.AcceptedAtRoute<TValue>(string? routeName, Microsoft.AspNetCore.Routing.RouteValueDictionary? routeValues, TValue? value = default(TValue?)) -> Microsoft.AspNetCore.Http.IResult!\nstatic Microsoft.AspNetCore.Http.Results.BadRequest(object? error = null) -> Microsoft.AspNetCore.Http.IResult!\nstatic Microsoft.AspNetCore.Http.Results.BadRequest<TValue>(TValue? error) -> Microsoft.AspNetCore.Http.IResult!\nstatic Microsoft.AspNetCore.Http.Results.Bytes(byte[]! contents, string? contentType = null, string? fileDownloadName = null, bool enableRangeProcessing = false, System.DateTimeOffset? lastModified = null, Microsoft.Net.Http.Headers.EntityTagHeaderValue? entityTag = null) -> Microsoft.AspNetCore.Http.IResult!\nstatic Microsoft.AspNetCore.Http.Results.Bytes(System.ReadOnlyMemory<byte> contents, string? contentType = null, string? fileDownloadName = null, bool enableRangeProcessing = false, System.DateTimeOffset? lastModified = null, Microsoft.Net.Http.Headers.EntityTagHeaderValue? entityTag = null) -> Microsoft.AspNetCore.Http.IResult!\nstatic Microsoft.AspNetCore.Http.Results.Challenge(Microsoft.AspNetCore.Authentication.AuthenticationProperties? properties = null, System.Collections.Generic.IList<string!>? authenticationSchemes = null) -> Microsoft.AspNetCore.Http.IResult!\nstatic Microsoft.AspNetCore.Http.Results.Conflict(object? error = null) -> Microsoft.AspNetCore.Http.IResult!\n```\n\n----------------------------------------\n\nTITLE: Required Attribute Adapter Implementation\nDESCRIPTION: Concrete implementation of attribute adapter for Required validation attribute with support for client-side validation and error messages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.DataAnnotations/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Mvc.DataAnnotations.RequiredAttributeAdapter.AddValidation(Microsoft.AspNetCore.Mvc.ModelBinding.Validation.ClientModelValidationContext! context) -> void\n\noverride Microsoft.AspNetCore.Mvc.DataAnnotations.RequiredAttributeAdapter.GetErrorMessage(Microsoft.AspNetCore.Mvc.ModelBinding.Validation.ModelValidationContextBase! validationContext) -> string!\n```\n\n----------------------------------------\n\nTITLE: Implementing ToString and Factory Methods for SignalR Messages (C#)\nDESCRIPTION: Override implementations of ToString() for various message types and static factory methods for creating CompletionMessage instances with different completion states.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.ToString() -> string!\noverride Microsoft.AspNetCore.SignalR.Protocol.InvocationMessage.ToString() -> string!\noverride Microsoft.AspNetCore.SignalR.Protocol.StreamInvocationMessage.ToString() -> string!\noverride Microsoft.AspNetCore.SignalR.Protocol.StreamItemMessage.ToString() -> string!\nstatic Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.Empty(string! invocationId) -> Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage!\nstatic Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.WithError(string! invocationId, string? error) -> Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage!\nstatic Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.WithResult(string! invocationId, object? payload) -> Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage!\n```\n\n----------------------------------------\n\nTITLE: Defining Ok Result Methods in C#\nDESCRIPTION: These methods create Ok (HTTP 200) results with optional value content.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.Ok() -> Microsoft.AspNetCore.Http.HttpResults.Ok!\nstatic Microsoft.AspNetCore.Http.TypedResults.Ok<TValue>(TValue? value) -> Microsoft.AspNetCore.Http.HttpResults.Ok<TValue>!\n```\n\n----------------------------------------\n\nTITLE: Formatting Example for API Review Submission in ASP.NET Core\nDESCRIPTION: This snippet demonstrates the proper formatting for API change descriptions during the review process, showing a good example with detailed context and a bad example that lacks sufficient explanation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/APIReviewProcess.md#2025-04-08_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nGood: This is the API for the widget factory, users use it in startup code to\nconfigure how their widgets work. We have an overload that accepts URI, but\nnot one that accepts string, so we're adding it for convenience.\n\nBad: Adding a string overload for Widget.ConfigureFactory.\n```\n\n----------------------------------------\n\nTITLE: Defining SignalR HubProtocolConstants in C#\nDESCRIPTION: Constants defining the message types used in the SignalR protocol. Each constant represents a different type of message that can be exchanged between clients and the hub.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.AckMessageType = 8 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.CancelInvocationMessageType = 5 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.CloseMessageType = 7 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.CompletionMessageType = 3 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.InvocationMessageType = 1 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.PingMessageType = 6 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.SequenceMessageType = 9 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.StreamInvocationMessageType = 4 -> int\nconst Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants.StreamItemMessageType = 2 -> int\n```\n\n----------------------------------------\n\nTITLE: Implementing GrpcJsonTranscodingOptions Class in C#\nDESCRIPTION: Configuration options class for gRPC JSON transcoding, allowing customization of JSON settings and type registry for message conversion.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Grpc/JsonTranscoding/src/Microsoft.AspNetCore.Grpc.JsonTranscoding/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class GrpcJsonTranscodingOptions\n{\n    public GrpcJsonSettings JsonSettings { get; set; }\n    public Google.Protobuf.Reflection.TypeRegistry TypeRegistry { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling and Logging for Request Delegates in ASP.NET Core\nDESCRIPTION: Helper class that provides consistent error handling for request processing. It conditionally logs errors or throws exceptions based on configuration, handling common scenarios like JSON parsing errors and parameter binding failures.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n\n    public void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n\n    public void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n\n    public void ImplicitBodyNotProvided(string parameterName)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n\n    public void UnexpectedJsonContentType(string? contentType)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n            throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n\n    public void UnexpectedNonFormContentType(string? contentType)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n            throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Root Directory for Razor Pages in ASP.NET Core\nDESCRIPTION: Extension method for IMvcBuilder that sets a custom root directory for Razor Pages. This allows developers to specify where in the project structure Razor Pages should be located.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.MvcRazorPagesMvcBuilderExtensions.WithRazorPagesRoot(this Microsoft.Extensions.DependencyInjection.IMvcBuilder! builder, string! rootDirectory) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in ASP.NET Core (C#)\nDESCRIPTION: This directive enables nullable reference types for the entire project or file. It helps in identifying potential null reference exceptions at compile-time, improving code quality and reducing runtime errors.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net10.0/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Required Parameter Validation in C#\nDESCRIPTION: Validates that required parameters are provided. Throws BadHttpRequestException if parameter is missing and throwing is enabled, or logs a debug message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_QueryNotPresent.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HtmlTargetElementAttribute Properties\nDESCRIPTION: Properties and constructor for the HtmlTargetElementAttribute class that defines how tag helpers target HTML elements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Razor/Razor/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nconst Microsoft.AspNetCore.Razor.TagHelpers.HtmlTargetElementAttribute.ElementCatchAllTarget = \"*\" -> string\nMicrosoft.AspNetCore.Razor.TagHelpers.HtmlTargetElementAttribute.Attributes.get -> string\nMicrosoft.AspNetCore.Razor.TagHelpers.HtmlTargetElementAttribute.Tag.get -> string\nMicrosoft.AspNetCore.Razor.TagHelpers.HtmlTargetElementAttribute.HtmlTargetElementAttribute(string tag) -> void\n```\n\n----------------------------------------\n\nTITLE: Extending HubOptions with AddFilter Methods in C#\nDESCRIPTION: Extension methods for HubOptions to add filters to SignalR hubs. These methods allow adding filters by type, instance, or generic type parameter.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.HubOptionsExtensions.AddFilter(this Microsoft.AspNetCore.SignalR.HubOptions! options, Microsoft.AspNetCore.SignalR.IHubFilter! hubFilter) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining IAllowAnonymous Interface in C#\nDESCRIPTION: Declares the IAllowAnonymous interface, which is likely used to mark endpoints or actions that allow anonymous access.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Metadata/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.IAllowAnonymous\n```\n\n----------------------------------------\n\nTITLE: Extending EventCallbackFactory with Web Event Create Methods in C#\nDESCRIPTION: Adds extension methods to EventCallbackFactory for creating event callbacks for various web events like clipboard, drag, error, focus, and keyboard events.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Components.Web.WebEventCallbackFactoryEventArgsExtensions.Create(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<Microsoft.AspNetCore.Components.Web.ClipboardEventArgs!>! callback) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.Web.ClipboardEventArgs!>\nstatic Microsoft.AspNetCore.Components.Web.WebEventCallbackFactoryEventArgsExtensions.Create(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<Microsoft.AspNetCore.Components.Web.DragEventArgs!>! callback) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.Web.DragEventArgs!>\nstatic Microsoft.AspNetCore.Components.Web.WebEventCallbackFactoryEventArgsExtensions.Create(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<Microsoft.AspNetCore.Components.Web.ErrorEventArgs!>! callback) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.Web.ErrorEventArgs!>\nstatic Microsoft.AspNetCore.Components.Web.WebEventCallbackFactoryEventArgsExtensions.Create(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<Microsoft.AspNetCore.Components.Web.FocusEventArgs!>! callback) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.Web.FocusEventArgs!>\nstatic Microsoft.AspNetCore.Components.Web.WebEventCallbackFactoryEventArgsExtensions.Create(this Microsoft.AspNetCore.Components.EventCallbackFactory! factory, object! receiver, System.Action<Microsoft.AspNetCore.Components.Web.KeyboardEventArgs!>! callback) -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.Web.KeyboardEventArgs!>\n```\n\n----------------------------------------\n\nTITLE: Defining ConfigureHostBuilder Class in C#\nDESCRIPTION: Defines the ConfigureHostBuilder class with methods for configuring the host, including app configuration, container configuration, and service provider factory setup.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DefaultBuilder/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Builder.ConfigureHostBuilder\nMicrosoft.AspNetCore.Builder.ConfigureHostBuilder.ConfigureAppConfiguration(System.Action<Microsoft.Extensions.Hosting.HostBuilderContext!, Microsoft.Extensions.Configuration.IConfigurationBuilder!>! configureDelegate) -> Microsoft.Extensions.Hosting.IHostBuilder!\nMicrosoft.AspNetCore.Builder.ConfigureHostBuilder.ConfigureContainer<TContainerBuilder>(System.Action<Microsoft.Extensions.Hosting.HostBuilderContext!, TContainerBuilder>! configureDelegate) -> Microsoft.Extensions.Hosting.IHostBuilder!\nMicrosoft.AspNetCore.Builder.ConfigureHostBuilder.ConfigureHostConfiguration(System.Action<Microsoft.Extensions.Configuration.IConfigurationBuilder!>! configureDelegate) -> Microsoft.Extensions.Hosting.IHostBuilder!\nMicrosoft.AspNetCore.Builder.ConfigureHostBuilder.ConfigureServices(System.Action<Microsoft.Extensions.Hosting.HostBuilderContext!, Microsoft.Extensions.DependencyInjection.IServiceCollection!>! configureDelegate) -> Microsoft.Extensions.Hosting.IHostBuilder!\nMicrosoft.AspNetCore.Builder.ConfigureHostBuilder.Properties.get -> System.Collections.Generic.IDictionary<object!, object!>!\nMicrosoft.AspNetCore.Builder.ConfigureHostBuilder.UseServiceProviderFactory<TContainerBuilder>(Microsoft.Extensions.DependencyInjection.IServiceProviderFactory<TContainerBuilder>! factory) -> Microsoft.Extensions.Hosting.IHostBuilder!\nMicrosoft.AspNetCore.Builder.ConfigureHostBuilder.UseServiceProviderFactory<TContainerBuilder>(System.Func<Microsoft.Extensions.Hosting.HostBuilderContext!, Microsoft.Extensions.DependencyInjection.IServiceProviderFactory<TContainerBuilder>!>! factory) -> Microsoft.Extensions.Hosting.IHostBuilder!\n```\n\n----------------------------------------\n\nTITLE: ConsumesConstraintForFormFileParameterConvention Class Definition in ASP.NET Core MVC\nDESCRIPTION: A convention that applies consumes constraints for form file parameters to actions in the MVC application model.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ConsumesConstraintForFormFileParameterConvention\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ConsumesConstraintForFormFileParameterConvention.Apply(Microsoft.AspNetCore.Mvc.ApplicationModels.ActionModel! action) -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.ConsumesConstraintForFormFileParameterConvention.ConsumesConstraintForFormFileParameterConvention() -> void\n```\n\n----------------------------------------\n\nTITLE: Defining Validation Problem Methods in ControllerBase for ASP.NET Core MVC\nDESCRIPTION: These methods provide ways to return validation problem results in ASP.NET Core MVC applications, allowing for customization of problem details and model state.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_63\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.ValidationProblem() -> Microsoft.AspNetCore.Mvc.ActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.ValidationProblem(Microsoft.AspNetCore.Mvc.ModelBinding.ModelStateDictionary! modelStateDictionary) -> Microsoft.AspNetCore.Mvc.ActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.ValidationProblem(Microsoft.AspNetCore.Mvc.ValidationProblemDetails! descriptor) -> Microsoft.AspNetCore.Mvc.ActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.ValidationProblem(string? detail = null, string? instance = null, int? statusCode = null, string? title = null, string? type = null, Microsoft.AspNetCore.Mvc.ModelBinding.ModelStateDictionary? modelStateDictionary = null, System.Collections.Generic.IDictionary<string!, object?>? extensions = null) -> Microsoft.AspNetCore.Mvc.ActionResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.ValidationProblem(string? detail, string? instance, int? statusCode, string? title, string? type, Microsoft.AspNetCore.Mvc.ModelBinding.ModelStateDictionary? modelStateDictionary) -> Microsoft.AspNetCore.Mvc.ActionResult!\n```\n\n----------------------------------------\n\nTITLE: Stream Response Body Feature Methods in ASP.NET Core\nDESCRIPTION: These virtual methods provide functionality for completing responses, disabling buffering, sending files, and starting asynchronous operations on stream response bodies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Http.StreamResponseBodyFeature.CompleteAsync() -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Http.StreamResponseBodyFeature.DisableBuffering() -> void\nvirtual Microsoft.AspNetCore.Http.StreamResponseBodyFeature.SendFileAsync(string! path, long offset, long? count, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Http.StreamResponseBodyFeature.StartAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Disable Validation Extension Method for ASP.NET Core Endpoint Builders\nDESCRIPTION: Static extension method that disables validation for an endpoint builder of generic type TBuilder. Returns the modified builder instance to support method chaining.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.ValidationEndpointConventionBuilderExtensions.DisableValidation<TBuilder>(this TBuilder builder) -> TBuilder\n```\n\n----------------------------------------\n\nTITLE: BaseConnectionContext Virtual Methods\nDESCRIPTION: Virtual method and property declarations for the BaseConnectionContext class defining core connection functionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/netstandard2.1/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.ConnectionClosed.get -> System.Threading.CancellationToken\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.ConnectionClosed.set -> void\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.DisposeAsync() -> System.Threading.Tasks.ValueTask\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.LocalEndPoint.get -> System.Net.EndPoint?\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.LocalEndPoint.set -> void\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.RemoteEndPoint.get -> System.Net.EndPoint?\nvirtual Microsoft.AspNetCore.Connections.BaseConnectionContext.RemoteEndPoint.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining NullHtmlEncoder Class in C#\nDESCRIPTION: This snippet defines the NullHtmlEncoder class with methods for encoding HTML. It provides a null implementation of HTML encoding.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Razor/Razor.Runtime/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Razor.TagHelpers.NullHtmlEncoder\noverride Microsoft.AspNetCore.Razor.TagHelpers.NullHtmlEncoder.FindFirstCharacterToEncode(char* text, int textLength) -> int\noverride Microsoft.AspNetCore.Razor.TagHelpers.NullHtmlEncoder.MaxOutputCharactersPerInputCharacter.get -> int\noverride Microsoft.AspNetCore.Razor.TagHelpers.NullHtmlEncoder.TryEncodeUnicodeScalar(int unicodeScalar, char* buffer, int bufferLength, out int numberOfCharactersWritten) -> bool\noverride Microsoft.AspNetCore.Razor.TagHelpers.NullHtmlEncoder.WillEncode(int unicodeScalar) -> bool\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Message for Invalid JSON Request Body in C#\nDESCRIPTION: This snippet defines a LoggerMessage for logging when a JSON request body fails to be read as a parameter. It uses LogLevel.Debug and creates an EventId for the message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nLoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n```\n\n----------------------------------------\n\nTITLE: ConcurrencyLimiter Middleware Implementation\nDESCRIPTION: Implementation of the middleware that enforces concurrency limits. It uses an IQueuePolicy to determine if requests should be queued, processed, or rejected based on current server load.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ConcurrencyLimiter/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.ConcurrencyLimiter.ConcurrencyLimiterMiddleware.ConcurrencyLimiterMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory, Microsoft.AspNetCore.ConcurrencyLimiter.IQueuePolicy! queue, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.ConcurrencyLimiter.ConcurrencyLimiterOptions!>! options) -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.ConcurrencyLimiter.ConcurrencyLimiterMiddleware.Invoke(Microsoft.AspNetCore.Http.HttpContext! context) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Extension Method for IEndpointRouteBuilder in C#\nDESCRIPTION: Implements a 'MapGet' extension method for IEndpointRouteBuilder to handle GET requests. It includes metadata population, request delegate creation, and parameter handling for query string parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_MultipleStringParam_StringReturn.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedRouteBuilderExtensionsCore\n{\n    private static readonly JsonOptions FallbackJsonOptions = new();\n    private static readonly string[] GetVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Get };\n\n    %INTERCEPTSLOCATIONATTRIBUTE%\n    internal static RouteHandlerBuilder MapGet0(\n        this IEndpointRouteBuilder endpoints,\n        [StringSyntax(\"Route\")] string pattern,\n        Delegate handler)\n    {\n        MetadataPopulator populateMetadata = (methodInfo, options) =>\n        {\n            // ... (metadata population logic)\n        };\n        RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n        {\n            // ... (request delegate creation logic)\n        };\n\n        Task RequestHandler(HttpContext httpContext)\n        {\n            // ... (request handling logic)\n        }\n\n        async Task RequestHandlerFiltered(HttpContext httpContext)\n        {\n            // ... (filtered request handling logic)\n        }\n\n        // ... (additional implementation details)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Alphanumeric Character Set\nDESCRIPTION: A string containing all digits (0-9) followed by lowercase (a-z) and uppercase (A-Z) letters of the English alphabet.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/StaticFiles/test/UnitTests/SubFolder/ranges.txt#2025-04-08_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n```\n\n----------------------------------------\n\nTITLE: SignalR HubProtocolExtensions Method Declaration in C#\nDESCRIPTION: Extension method declaration for IHubProtocol to convert a hub message to a byte array, facilitating message serialization in the SignalR protocol.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Protocol.HubProtocolExtensions.GetMessageBytes(this Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol! hubProtocol, Microsoft.AspNetCore.SignalR.Protocol.HubMessage! message) -> byte[]!\n```\n\n----------------------------------------\n\nTITLE: Adding Health Checks Service Extension for ASP.NET Core\nDESCRIPTION: Extension method that adds health check services to an IServiceCollection. Returns an IHealthChecksBuilder to allow further configuration of health check services.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HealthChecks/HealthChecks/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.HealthCheckServiceCollectionExtensions.AddHealthChecks(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IHealthChecksBuilder!\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet0 Extension Method for IEndpointRouteBuilder in C#\nDESCRIPTION: Defines a MapGet0 extension method for the IEndpointRouteBuilder interface that handles HTTP GET requests. It includes metadata population and request delegate factory creation for processing string array query parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n        %INTERCEPTSLOCATIONATTRIBUTE%\n        internal static RouteHandlerBuilder MapGet0(\n            this IEndpointRouteBuilder endpoints,\n            [StringSyntax(\"Route\")] string pattern,\n            Delegate handler)\n        {\n            MetadataPopulator populateMetadata = (methodInfo, options) =>\n            {\n                Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n                Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n                options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n                var parameters = methodInfo.GetParameters();\n                options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: true));\n                options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(global::System.String[]), contentTypes: GeneratedMetadataConstants.JsonContentType));\n                return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n            };\n            RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n            {\n                Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n                Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n                Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n                Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n                var handler = Cast(del, global::System.String[] (global::System.String[]? arg0= default) => throw null!);\n                EndpointFilterDelegate? filteredInvocation = null;\n                var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n                var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n                var jsonSerializerOptions = jsonOptions.SerializerOptions;\n                jsonSerializerOptions.MakeReadOnly();\n                var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n                var responseJsonTypeInfo =  (JsonTypeInfo<global::System.String[]?>)jsonSerializerOptions.GetTypeInfo(typeof(global::System.String[]));\n\n                if (options.EndpointBuilder.FilterFactories.Count > 0)\n                {\n                    filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n                    {\n                        if (ic.HttpContext.Response.StatusCode == 400)\n                        {\n                            return ValueTask.FromResult<object?>(Results.Empty);\n                        }\n                        return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::System.String[]?>(0)!));\n                    },\n                    options.EndpointBuilder,\n                    handler.Method);\n                }\n\n                Task RequestHandler(HttpContext httpContext)\n                {\n                    var wasParamCheckFailure = false;\n                    // Endpoint Parameter: p (Type = string[]?, IsOptional = True, IsParsable = False, IsArray = True, Source = Query)\n                    var p_raw = httpContext.Request.Query[\"p\"];\n                    var p_temp = p_raw.ToArray();\n                    string[] p_local = p_temp!;\n\n                    if (wasParamCheckFailure)\n                    {\n                        httpContext.Response.StatusCode = 400;\n                        return Task.CompletedTask;\n                    }\n                    var result = handler(p_local);\n                    return GeneratedRouteBuilderExtensionsCore.WriteJsonResponseAsync(httpContext.Response, result, responseJsonTypeInfo);\n                }\n\n                async Task RequestHandlerFiltered(HttpContext httpContext)\n                {\n                    var wasParamCheckFailure = false;\n                    // Endpoint Parameter: p (Type = string[]?, IsOptional = True, IsParsable = False, IsArray = True, Source = Query)\n                    var p_raw = httpContext.Request.Query[\"p\"];\n                    var p_temp = p_raw.ToArray();\n                    string[] p_local = p_temp!;\n\n                    if (wasParamCheckFailure)\n                    {\n                        httpContext.Response.StatusCode = 400;\n                    }\n                    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::System.String[]?>(httpContext, p_local));\n                    if (result is not null)\n                    {\n                        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n                    }\n                }\n\n                RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\n                var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\n                return new RequestDelegateResult(targetDelegate, metadata);\n            };\n            var castHandler = Cast(handler, global::System.String[] (global::System.String[]? arg0= default) => throw null!);\n            return MapCore(\n                endpoints,\n                pattern,\n                handler,\n                GetVerb,\n                populateMetadata,\n                createRequestDelegate,\n                castHandler.Method);\n        }\n```\n\n----------------------------------------\n\nTITLE: Running Authentication Tests\nDESCRIPTION: Command to run the test suite for authentication components using the build script with test flag.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/README.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd -t\n```\n\n----------------------------------------\n\nTITLE: OutputCachePolicyBuilder Methods for Configuring Cache Variation in ASP.NET Core\nDESCRIPTION: This snippet shows the available methods on OutputCachePolicyBuilder that allow configuring how cached responses vary based on different request parameters such as headers, host, query strings, route values, and custom values. These methods all return the builder instance to enable fluent chaining.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/OutputCaching/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder.SetVaryByHeader(string![]! headerNames) -> Microsoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder!\nMicrosoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder.SetVaryByHost(bool enabled) -> Microsoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder!\nMicrosoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder.SetVaryByQuery(string! queryKey, params string![]! queryKeys) -> Microsoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder!\nMicrosoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder.SetVaryByQuery(string![]! queryKeys) -> Microsoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder!\nMicrosoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder.SetVaryByRouteValue(string! routeValueName, params string![]! routeValueNames) -> Microsoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder!\nMicrosoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder.SetVaryByRouteValue(string![]! routeValueNames) -> Microsoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder!\n```\n\n----------------------------------------\n\nTITLE: URL Helper Extensions for Page and Route URL Generation in ASP.NET Core\nDESCRIPTION: Extension methods for the IUrlHelper interface to generate URLs for pages and routes. These methods provide various overloads with different parameter combinations to support flexible URL generation with optional protocol, host, fragment, and route values.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Mvc.UrlHelperExtensions.Page(this Microsoft.AspNetCore.Mvc.IUrlHelper! urlHelper, string? pageName, string? pageHandler, object? values, string? protocol) -> string?\nstatic Microsoft.AspNetCore.Mvc.UrlHelperExtensions.Page(this Microsoft.AspNetCore.Mvc.IUrlHelper! urlHelper, string? pageName, string? pageHandler, object? values, string? protocol, string? host) -> string?\nstatic Microsoft.AspNetCore.Mvc.UrlHelperExtensions.Page(this Microsoft.AspNetCore.Mvc.IUrlHelper! urlHelper, string? pageName, string? pageHandler, object? values, string? protocol, string? host, string? fragment) -> string?\nstatic Microsoft.AspNetCore.Mvc.UrlHelperExtensions.PageLink(this Microsoft.AspNetCore.Mvc.IUrlHelper! urlHelper, string? pageName = null, string? pageHandler = null, object? values = null, string? protocol = null, string? host = null, string? fragment = null) -> string?\nstatic Microsoft.AspNetCore.Mvc.UrlHelperExtensions.RouteUrl(this Microsoft.AspNetCore.Mvc.IUrlHelper! helper, object? values) -> string?\nstatic Microsoft.AspNetCore.Mvc.UrlHelperExtensions.RouteUrl(this Microsoft.AspNetCore.Mvc.IUrlHelper! helper, string? routeName) -> string?\nstatic Microsoft.AspNetCore.Mvc.UrlHelperExtensions.RouteUrl(this Microsoft.AspNetCore.Mvc.IUrlHelper! helper, string? routeName, object? values) -> string?\nstatic Microsoft.AspNetCore.Mvc.UrlHelperExtensions.RouteUrl(this Microsoft.AspNetCore.Mvc.IUrlHelper! helper, string? routeName, object? values, string? protocol) -> string?\nstatic Microsoft.AspNetCore.Mvc.UrlHelperExtensions.RouteUrl(this Microsoft.AspNetCore.Mvc.IUrlHelper! helper, string? routeName, object? values, string? protocol, string? host) -> string?\nstatic Microsoft.AspNetCore.Mvc.UrlHelperExtensions.RouteUrl(this Microsoft.AspNetCore.Mvc.IUrlHelper! helper, string? routeName, object? values, string? protocol, string? host, string? fragment) -> string?\n```\n\n----------------------------------------\n\nTITLE: InputTagHelper Class Signatures in ASP.NET Core MVC\nDESCRIPTION: API signatures for the InputTagHelper class that generates HTML input elements bound to model properties. It handles input type determination and value binding from model expressions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.TagHelpers/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n~Microsoft.AspNetCore.Mvc.TagHelpers.InputTagHelper.For.get -> Microsoft.AspNetCore.Mvc.ViewFeatures.ModelExpression\n~Microsoft.AspNetCore.Mvc.TagHelpers.InputTagHelper.For.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.InputTagHelper.Format.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.InputTagHelper.Format.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.InputTagHelper.FormName.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.InputTagHelper.FormName.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.InputTagHelper.Generator.get -> Microsoft.AspNetCore.Mvc.ViewFeatures.IHtmlGenerator\n~Microsoft.AspNetCore.Mvc.TagHelpers.InputTagHelper.GetInputType(Microsoft.AspNetCore.Mvc.ViewFeatures.ModelExplorer modelExplorer, out string inputTypeHint) -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.InputTagHelper.InputTagHelper(Microsoft.AspNetCore.Mvc.ViewFeatures.IHtmlGenerator generator) -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.InputTagHelper.InputTypeName.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.InputTagHelper.InputTypeName.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.InputTagHelper.Name.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.InputTagHelper.Name.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.InputTagHelper.Value.get -> string\n~Microsoft.AspNetCore.Mvc.TagHelpers.InputTagHelper.Value.set -> void\n~Microsoft.AspNetCore.Mvc.TagHelpers.InputTagHelper.ViewContext.get -> Microsoft.AspNetCore.Mvc.Rendering.ViewContext\n~Microsoft.AspNetCore.Mvc.TagHelpers.InputTagHelper.ViewContext.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining AuthenticationScheme and AuthenticationSchemeBuilder Classes in C#\nDESCRIPTION: Defines the AuthenticationScheme and AuthenticationSchemeBuilder classes for managing authentication schemes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Authentication.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.AuthenticationScheme\nMicrosoft.AspNetCore.Authentication.AuthenticationScheme.AuthenticationScheme(string! name, string? displayName, System.Type! handlerType) -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationScheme.DisplayName.get -> string?\nMicrosoft.AspNetCore.Authentication.AuthenticationScheme.HandlerType.get -> System.Type!\nMicrosoft.AspNetCore.Authentication.AuthenticationScheme.Name.get -> string!\nMicrosoft.AspNetCore.Authentication.AuthenticationSchemeBuilder\nMicrosoft.AspNetCore.Authentication.AuthenticationSchemeBuilder.AuthenticationSchemeBuilder(string! name) -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationSchemeBuilder.Build() -> Microsoft.AspNetCore.Authentication.AuthenticationScheme!\nMicrosoft.AspNetCore.Authentication.AuthenticationSchemeBuilder.DisplayName.get -> string?\nMicrosoft.AspNetCore.Authentication.AuthenticationSchemeBuilder.DisplayName.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationSchemeBuilder.HandlerType.get -> System.Type?\nMicrosoft.AspNetCore.Authentication.AuthenticationSchemeBuilder.HandlerType.set -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationSchemeBuilder.Name.get -> string!\n```\n\n----------------------------------------\n\nTITLE: Defining ITlsHandshakeFeature Interface in C#\nDESCRIPTION: This snippet defines the ITlsHandshakeFeature interface with properties for various TLS handshake details such as cipher algorithm, protocol, and negotiated cipher suite.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Connections.Features.ITlsHandshakeFeature\nMicrosoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.CipherAlgorithm.get -> System.Security.Authentication.CipherAlgorithmType\nMicrosoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.CipherStrength.get -> int\nMicrosoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.HashAlgorithm.get -> System.Security.Authentication.HashAlgorithmType\nMicrosoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.HashStrength.get -> int\nMicrosoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.HostName.get -> string!\nMicrosoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.KeyExchangeAlgorithm.get -> System.Security.Authentication.ExchangeAlgorithmType\nMicrosoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.KeyExchangeStrength.get -> int\nMicrosoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.NegotiatedCipherSuite.get -> System.Net.Security.TlsCipherSuite?\nMicrosoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.Protocol.get -> System.Security.Authentication.SslProtocols\n```\n\n----------------------------------------\n\nTITLE: Implementing Filtered HTTP Request Handling with Response Parameter in ASP.NET Core\nDESCRIPTION: This code handles filtered HTTP requests where middleware may intercept and modify the request processing. It uses endpoint filters to process the request, handles parameter validation, and executes the appropriate response writing logic.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandlerFiltered(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var res_local = httpContext.Response;\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n    }\n    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.HttpResponse>(httpContext, res_local));\n    if (result is not null)\n    {\n        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a custom attribute 'InterceptsLocationAttribute' used for method interception in ASP.NET Core routing. This attribute is applied to methods and can be used multiple times.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\nfile sealed class InterceptsLocationAttribute : Attribute\n{\n    public InterceptsLocationAttribute(int version, string data)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining WebApplication Static Methods in C#\nDESCRIPTION: Defines static methods for the WebApplication class, including methods for creating builders and applications with various configurations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DefaultBuilder/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.WebApplication.Create(string![]? args = null) -> Microsoft.AspNetCore.Builder.WebApplication!\nstatic Microsoft.AspNetCore.Builder.WebApplication.CreateBuilder() -> Microsoft.AspNetCore.Builder.WebApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.WebApplication.CreateBuilder(Microsoft.AspNetCore.Builder.WebApplicationOptions! options) -> Microsoft.AspNetCore.Builder.WebApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.WebApplication.CreateBuilder(string![]! args) -> Microsoft.AspNetCore.Builder.WebApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.WebApplication.CreateEmptyBuilder(Microsoft.AspNetCore.Builder.WebApplicationOptions! options) -> Microsoft.AspNetCore.Builder.WebApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.WebApplication.CreateSlimBuilder() -> Microsoft.AspNetCore.Builder.WebApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.WebApplication.CreateSlimBuilder(Microsoft.AspNetCore.Builder.WebApplicationOptions! options) -> Microsoft.AspNetCore.Builder.WebApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.WebApplication.CreateSlimBuilder(string![]! args) -> Microsoft.AspNetCore.Builder.WebApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Implementing XML Encryption in C# for ASP.NET Core Data Protection\nDESCRIPTION: This snippet defines classes and interfaces for XML encryption in the Microsoft.AspNetCore.DataProtection.XmlEncryption namespace. It includes implementations for certificate-based, DPAPI, and DPAPI-NG encryption methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/DataProtection/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.CertificateXmlEncryptor\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.CertificateXmlEncryptor.CertificateXmlEncryptor(string! thumbprint, Microsoft.AspNetCore.DataProtection.XmlEncryption.ICertificateResolver! certificateResolver, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> void\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.CertificateXmlEncryptor.CertificateXmlEncryptor(System.Security.Cryptography.X509Certificates.X509Certificate2! certificate, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> void\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.CertificateXmlEncryptor.Encrypt(System.Xml.Linq.XElement! plaintextElement) -> Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo!\n\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlEncryptor\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlEncryptor.DpapiNGXmlEncryptor(string! protectionDescriptorRule, Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags flags, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> void\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlEncryptor.Encrypt(System.Xml.Linq.XElement! plaintextElement) -> Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo!\n\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlEncryptor\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlEncryptor.DpapiXmlEncryptor(bool protectToLocalMachine, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> void\nMicrosoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlEncryptor.Encrypt(System.Xml.Linq.XElement! plaintextElement) -> Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo!\n```\n\n----------------------------------------\n\nTITLE: Configuring EF Core Diagnostics Middleware in ASP.NET Core\nDESCRIPTION: Configuration code for setting up the EF Core diagnostics middleware in Program.cs. Adds database developer page exception filter and configures middleware for development environment.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics.EntityFrameworkCore/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Services.AddDatabaseDeveloperPageExceptionFilter();\n\nvar app = builder.build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n    app.UseMigrationsEndPoint();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Cookie Policy Middleware in ASP.NET Core Applications\nDESCRIPTION: These extension methods allow adding Cookie Policy middleware to the ASP.NET Core request pipeline. The middleware enforces rules defined in CookiePolicyOptions for all cookies issued by the application.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/CookiePolicy/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.CookiePolicyAppBuilderExtensions.UseCookiePolicy(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.CookiePolicyAppBuilderExtensions.UseCookiePolicy(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app, Microsoft.AspNetCore.Builder.CookiePolicyOptions! options) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Adding Interactive WebAssembly Render Mode to Razor Components\nDESCRIPTION: Extension method for RazorComponentsEndpointConventionBuilder that adds support for interactive WebAssembly render mode. This allows components to be rendered using WebAssembly on the client.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.WebAssemblyRazorComponentsEndpointConventionBuilderExtensions.AddInteractiveWebAssemblyRenderMode(this Microsoft.AspNetCore.Builder.RazorComponentsEndpointConventionBuilder! builder, System.Action<Microsoft.AspNetCore.Components.WebAssembly.Server.WebAssemblyComponentsEndpointOptions!>? callback = null) -> Microsoft.AspNetCore.Builder.RazorComponentsEndpointConventionBuilder!\n```\n\n----------------------------------------\n\nTITLE: Implementing Core Mapping Logic for RouteBuilder in C#\nDESCRIPTION: Defines the MapCore method which is the central logic for mapping routes in ASP.NET Core. It uses RouteHandlerServices to create the actual route mapping.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsString_Has_Metadata.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract ClaimAction Class in C#\nDESCRIPTION: This snippet defines an abstract class ClaimAction with a Run method that processes JSON user data and adds claims to a ClaimsIdentity.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OAuth/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Authentication.OAuth.Claims.ClaimAction.Run(System.Text.Json.JsonElement userData, System.Security.Claims.ClaimsIdentity! identity, string! issuer) -> void\n```\n\n----------------------------------------\n\nTITLE: XML Formatter Class Definitions in ASP.NET Core\nDESCRIPTION: Core XML formatter classes for handling XML serialization and deserialization in ASP.NET Core MVC. Includes both DataContractSerializer and XmlSerializer implementations with configuration options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Formatters.Xml/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class XmlDataContractSerializerInputFormatter\n{\n    public XmlDataContractSerializerInputFormatter(MvcOptions options);\n    public int MaxDepth { get; set; }\n    public DataContractSerializerSettings SerializerSettings { get; set; }\n    public IList<IWrapperProviderFactory> WrapperProviderFactories { get; }\n    public XmlDictionaryReaderQuotas XmlDictionaryReaderQuotas { get; }\n}\n\npublic class XmlDataContractSerializerOutputFormatter\n{\n    public XmlDataContractSerializerOutputFormatter();\n    public XmlDataContractSerializerOutputFormatter(ILoggerFactory loggerFactory);\n    public DataContractSerializerSettings SerializerSettings { get; set; }\n    public IList<IWrapperProviderFactory> WrapperProviderFactories { get; }\n    public XmlWriterSettings WriterSettings { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Validation Classes in C#\nDESCRIPTION: These classes implement various validation-related functionalities for parameters, properties, and types in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Validation.ValidatableParameterInfo\nMicrosoft.AspNetCore.Http.Validation.ValidatableParameterInfo.ValidatableParameterInfo(System.Type! parameterType, string! name, string! displayName) -> void\nMicrosoft.AspNetCore.Http.Validation.ValidatablePropertyInfo\nMicrosoft.AspNetCore.Http.Validation.ValidatablePropertyInfo.ValidatablePropertyInfo(System.Type! declaringType, System.Type! propertyType, string! name, string! displayName) -> void\nMicrosoft.AspNetCore.Http.Validation.ValidatableTypeAttribute\nMicrosoft.AspNetCore.Http.Validation.ValidatableTypeAttribute.ValidatableTypeAttribute() -> void\nMicrosoft.AspNetCore.Http.Validation.ValidatableTypeInfo\nMicrosoft.AspNetCore.Http.Validation.ValidatableTypeInfo.ValidatableTypeInfo(System.Type! type, System.Collections.Generic.IReadOnlyList<Microsoft.AspNetCore.Http.Validation.ValidatablePropertyInfo!>! members) -> void\n```\n\n----------------------------------------\n\nTITLE: Authentication Middleware Implementation in C#\nDESCRIPTION: Implementation of the ASP.NET Core authentication middleware that processes authentication for incoming requests. Includes constructor and invoke method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.AuthenticationMiddleware.AuthenticationMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.AspNetCore.Authentication.IAuthenticationSchemeProvider! schemes) -> void\nMicrosoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(Microsoft.AspNetCore.Http.HttpContext! context) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Authentication.AuthenticationMiddleware.Schemes.get -> Microsoft.AspNetCore.Authentication.IAuthenticationSchemeProvider!\nMicrosoft.AspNetCore.Authentication.AuthenticationMiddleware.Schemes.set -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing SecurityTokenValidatedContext for WS-Federation Authentication in C#\nDESCRIPTION: This class represents the context when a security token is validated during WS-Federation authentication. It includes properties for the protocol message, security token, and a constructor for initializing the context.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/WsFederation/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.WsFederation.SecurityTokenValidatedContext\nMicrosoft.AspNetCore.Authentication.WsFederation.SecurityTokenValidatedContext.ProtocolMessage.get -> Microsoft.IdentityModel.Protocols.WsFederation.WsFederationMessage!\nMicrosoft.AspNetCore.Authentication.WsFederation.SecurityTokenValidatedContext.ProtocolMessage.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.SecurityTokenValidatedContext.SecurityToken.get -> Microsoft.IdentityModel.Tokens.SecurityToken?\nMicrosoft.AspNetCore.Authentication.WsFederation.SecurityTokenValidatedContext.SecurityToken.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.SecurityTokenValidatedContext.SecurityTokenValidatedContext(Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Authentication.AuthenticationScheme! scheme, Microsoft.AspNetCore.Authentication.WsFederation.WsFederationOptions! options, System.Security.Claims.ClaimsPrincipal! principal, Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties) -> void\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants Definition\nDESCRIPTION: Defines constants for common HTTP content types used in request processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/RequestDelegateValidateGeneratedFormCode.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment for HostBuilder in C#\nDESCRIPTION: This extension method sets the environment for the HostBuilder. It adds the environment name to the host configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Owin/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static IHostBuilder UseEnvironment(this IHostBuilder builder, string environment)\n{\n    if (builder == null)\n    {\n        throw new ArgumentNullException(nameof(builder));\n    }\n\n    if (string.IsNullOrEmpty(environment))\n    {\n        throw new ArgumentException(Resources.ArgumentCannotBeNullOrEmpty, nameof(environment));\n    }\n\n    return builder.ConfigureHostConfiguration(configBuilder =>\n    {\n        configBuilder.AddInMemoryCollection(new[]\n        {\n            new KeyValuePair<string, string>(HostDefaults.EnvironmentKey, environment)\n        });\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Static Factory Methods for CompletionMessage\nDESCRIPTION: Static factory methods to create different types of completion messages in SignalR. Provides convenient ways to create empty completions, completions with errors, or completions with results.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.Empty(string! invocationId) -> Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage!\nstatic Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.WithError(string! invocationId, string? error) -> Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage!\nstatic Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.WithResult(string! invocationId, object? payload) -> Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage!\n```\n\n----------------------------------------\n\nTITLE: Type Casting for Delegates in ASP.NET Core\nDESCRIPTION: Utility method to safely cast a Delegate to a specific delegate type. Used for converting handler functions to their appropriate delegate types during route mapping.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Parameter Binding Failure in ASP.NET Core (C#)\nDESCRIPTION: This method handles parameter binding failures by either throwing an exception or logging the error, depending on configuration. It takes the parameter type, name, and source value as inputs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Post_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MapPost5 Extension Method for ASP.NET Core Route Builder\nDESCRIPTION: Implements an extension method for IEndpointRouteBuilder to configure HTTP POST endpoints. This method sets up metadata population for the endpoint, including generating code attributes and parameter binding metadata for JSON request bodies.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\n%INTERCEPTSLOCATIONATTRIBUTE%\ninternal static RouteHandlerBuilder MapPost5(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        options.EndpointBuilder.Metadata.Add(new AcceptsMetadata(contentTypes: GeneratedMetadataConstants.JsonContentType));\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"Todo\", new PropertyAsParameterInfo(false, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParameterRecordStructWithJsonBodyOrService)!.GetProperty(\"Todo\")!), hasTryParse: false, hasBindAsync: false, isOptional: false));\n```\n\n----------------------------------------\n\nTITLE: Writing JSON Response in ASP.NET Core\nDESCRIPTION: This method handles writing JSON responses asynchronously, taking into account type information and polymorphism.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_NullableStringArrayParam.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Newtonsoft.Json in ASP.NET Core MVC Controllers\nDESCRIPTION: Example of using Newtonsoft.Json serialization in an ASP.NET Core MVC controller. The sample shows a controller with a POST action that accepts a model deserialized using Newtonsoft.Json via the [FromBody] attribute.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.NewtonsoftJson/src/PACKAGE.md#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing Microsoft.AspNetCore.Mvc;\nusing Newtonsoft.Json;\n\npublic class SampleController : Controller\n{\n    [HttpPost]\n    public IActionResult Post([FromBody] MyModel model)\n    {\n        // Your action logic here\n    }\n}\n\npublic class MyModel\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: SignIn Manager Implementation\nDESCRIPTION: Core implementation of SignInManager<TUser> providing methods for user authentication, sign-in operations, and two-factor authentication management.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvirtual Microsoft.AspNetCore.Identity.SignInManager<TUser>.SignInAsync(TUser! user, bool isPersistent, string? authenticationMethod = null) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Identity.SignInManager<TUser>.PasswordSignInAsync(string! userName, string! password, bool isPersistent, bool lockoutOnFailure) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.SignInResult!>!\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Extension Method for IEndpointRouteBuilder in C#\nDESCRIPTION: Implements a custom MapGet extension method for IEndpointRouteBuilder. This method handles GET requests with complex parameter parsing, metadata population, and JSON response serialization. It supports optional array parameters and includes error handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedRouteBuilderExtensionsCore\n{\n    private static readonly JsonOptions FallbackJsonOptions = new();\n    private static readonly string[] GetVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Get };\n\n    %INTERCEPTSLOCATIONATTRIBUTE%\n    internal static RouteHandlerBuilder MapGet0(\n        this IEndpointRouteBuilder endpoints,\n        [StringSyntax(\"Route\")] string pattern,\n        Delegate handler)\n    {\n        MetadataPopulator populateMetadata = (methodInfo, options) =>\n        {\n            // Metadata population logic\n        };\n        RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n        {\n            // Request delegate creation logic\n        };\n        var castHandler = Cast(handler, global::System.Int32?[] (global::System.Int32?[]? arg0= default) => throw null!);\n        return MapCore(\n            endpoints,\n            pattern,\n            // Additional parameters\n        );\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding InputSelect<TValue> Component Methods in C#\nDESCRIPTION: Overrides the BuildRenderTree, FormatValueAsString, and TryParseValueFromString methods for the InputSelect<TValue> component in ASP.NET Core Forms.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Components.Forms.InputSelect<TValue>.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder! builder) -> void\noverride Microsoft.AspNetCore.Components.Forms.InputSelect<TValue>.FormatValueAsString(TValue? value) -> string?\noverride Microsoft.AspNetCore.Components.Forms.InputSelect<TValue>.TryParseValueFromString(string? value, out TValue result, out string? validationErrorMessage) -> bool\n```\n\n----------------------------------------\n\nTITLE: HubProtocolExtensions Method for Message Serialization - C#\nDESCRIPTION: Extension method for IHubProtocol that converts a hub message to a byte array. This utility simplifies message serialization for transmission over the network.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Protocol.HubProtocolExtensions.GetMessageBytes(this Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol! hubProtocol, Microsoft.AspNetCore.SignalR.Protocol.HubMessage! message) -> byte[]!\n```\n\n----------------------------------------\n\nTITLE: Resolving Request Body in ASP.NET Core\nDESCRIPTION: This method attempts to resolve the request body asynchronously. It handles JSON content type validation, reads the body, and manages various exceptions that may occur during the process.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nprivate static async ValueTask<(bool, T?)> TryResolveBodyAsync<T>(HttpContext httpContext, LogOrThrowExceptionHelper logOrThrowExceptionHelper, bool allowEmpty, string parameterTypeName, string parameterName, JsonTypeInfo<T> jsonTypeInfo, bool isInferred = false)\n{\n    var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();\n    T? bodyValue = default;\n    var bodyValueSet = false;\n\n    if (feature?.CanHaveBody == true)\n    {\n        if (!httpContext.Request.HasJsonContentType())\n        {\n            logOrThrowExceptionHelper.UnexpectedJsonContentType(httpContext.Request.ContentType);\n            httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;\n            return (false, default);\n        }\n        try\n        {\n            bodyValue = await httpContext.Request.ReadFromJsonAsync(jsonTypeInfo);\n            bodyValueSet = bodyValue != null;\n        }\n        catch (BadHttpRequestException badHttpRequestException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(badHttpRequestException);\n            httpContext.Response.StatusCode = badHttpRequestException.StatusCode;\n            return (false, default);\n        }\n        catch (IOException ioException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(ioException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n        catch (System.Text.Json.JsonException jsonException)\n        {\n            logOrThrowExceptionHelper.InvalidJsonRequestBody(parameterTypeName, parameterName, jsonException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n    }\n\n    if (!allowEmpty && !bodyValueSet)\n    {\n        if (!isInferred)\n        {\n            logOrThrowExceptionHelper.RequiredParameterNotProvided(parameterTypeName, parameterName, \"body\");\n        }\n        else\n        {\n            logOrThrowExceptionHelper.ImplicitBodyNotProvided(parameterName);\n        }\n        httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n        return (false, bodyValue);\n    }\n\n    return (true, bodyValue);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Authentication Services Extension Methods\nDESCRIPTION: Extension methods for adding authentication services to the ASP.NET Core dependency injection container. Includes methods for configuring default authentication schemes and options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.AuthenticationServiceCollectionExtensions.AddAuthentication(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, string! defaultScheme) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.AuthenticationServiceCollectionExtensions.AddAuthentication(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Authentication.AuthenticationOptions!>! configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n```\n\n----------------------------------------\n\nTITLE: LogOrThrowExceptionHelper Class Implementation\nDESCRIPTION: A sealed helper class for managing request-related exceptions and logging. Handles various error scenarios like invalid JSON, parameter binding failures, and content type mismatches.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsValidationProblemResult_Has_Metadata.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    // Various error handling methods and their corresponding logger definitions\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    // Additional error handling methods...\n}\n```\n\n----------------------------------------\n\nTITLE: Decoding Completion Message with Void Result in MessagePack\nDESCRIPTION: Demonstrates the decoding of a Completion message with a void result in the SignalR MessagePack protocol. It includes message type, headers, invocation ID, and result kind.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_9\n\nLANGUAGE: MessagePack\nCODE:\n```\n0x94 0x03 0x80 0xa3 0x78 0x79 0x7a 0x02\n```\n\n----------------------------------------\n\nTITLE: Diagnostic Event Data Classes\nDESCRIPTION: Classes for capturing diagnostic data during controller action execution.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Diagnostics.AfterActionEventData\nMicrosoft.AspNetCore.Mvc.Diagnostics.AfterActionEventData.AfterActionEventData(Microsoft.AspNetCore.Mvc.Abstractions.ActionDescriptor! actionDescriptor, Microsoft.AspNetCore.Http.HttpContext! httpContext, Microsoft.AspNetCore.Routing.RouteData! routeData) -> void\nMicrosoft.AspNetCore.Mvc.Diagnostics.AfterActionFilterOnActionExecutedEventData\nMicrosoft.AspNetCore.Mvc.Diagnostics.AfterActionFilterOnActionExecutedEventData.AfterActionFilterOnActionExecutedEventData(Microsoft.AspNetCore.Mvc.Abstractions.ActionDescriptor! actionDescriptor, Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext! actionExecutedContext, Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata! filter) -> void\n```\n\n----------------------------------------\n\nTITLE: Error Boundary Logger Interface for ASP.NET Core Components\nDESCRIPTION: Defines the IErrorBoundaryLogger interface for logging exceptions in Blazor error boundaries. Provides the LogErrorAsync method to asynchronously log exceptions that occur within components.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Web.IErrorBoundaryLogger\nMicrosoft.AspNetCore.Components.Web.IErrorBoundaryLogger.LogErrorAsync(System.Exception! exception) -> System.Threading.Tasks.ValueTask\n```\n\n----------------------------------------\n\nTITLE: Implementing TryUpdateModelAsync Methods - C#\nDESCRIPTION: Async methods for model binding in Razor Pages. These methods allow updating model properties from HTTP request data with various filtering and validation options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic Task<bool> TryUpdateModelAsync<TModel>(\n    TModel model,\n    string name,\n    IValueProvider valueProvider,\n    Expression<Func<TModel, object?>>[] includeExpressions)\n{\n    // Implementation omitted\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling and Logging Helper for Request Processing\nDESCRIPTION: Provides consistent error handling and logging for request processing failures. Handles various error scenarios like invalid JSON, parameter binding failures, and missing required parameters with configurable exception throwing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n\n    public void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n\n    public void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n        LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n\n    public void ImplicitBodyNotProvided(string parameterName)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n            throw new BadHttpRequestException(message);\n        }\n\n        if (_rdgLogger != null)\n        {\n\n```\n\n----------------------------------------\n\nTITLE: Defining Form Validation Logger Message in C#\nDESCRIPTION: Creates a structured logger message template for cases where form parameter reading fails. Uses LoggerMessage.Define to create a performant logging delegate with type-safe parameters for parameter type and name.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleNullableStringParam_WithEmptyQueryStringValueProvided_StringReturn.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n            LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Handling Connection Down Event in Blazor Server\nDESCRIPTION: Virtual method in CircuitHandler that's called when a circuit loses its connection. Provides a hook for custom logic when the connection to a circuit is temporarily lost.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Server/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandler.OnConnectionDownAsync(Microsoft.AspNetCore.Components.Server.Circuits.Circuit! circuit, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: HTTP Result Interface Definition\nDESCRIPTION: Base interface for HTTP results that can be returned from endpoints\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.IResult.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining HealthCheckResult Class in C#\nDESCRIPTION: This class represents the result of a health check. It includes properties for status, description, exception, and additional data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/HealthChecks/Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult.Data.get -> System.Collections.Generic.IReadOnlyDictionary<string!, object!>!\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult.Description.get -> string?\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult.Exception.get -> System.Exception?\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult.HealthCheckResult() -> void\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult.HealthCheckResult(Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus status, string? description = null, System.Exception? exception = null, System.Collections.Generic.IReadOnlyDictionary<string!, object!>? data = null) -> void\nMicrosoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult.Status.get -> Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus\n```\n\n----------------------------------------\n\nTITLE: Defining ImportMap and ImportMapDefinition Classes in C#\nDESCRIPTION: These classes define structures for import maps in ASP.NET Core Razor Components, including imports, scopes, and integrity information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Endpoints/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.ImportMap\nMicrosoft.AspNetCore.Components.ImportMap.AdditionalAttributes.get -> System.Collections.Generic.IReadOnlyDictionary<string!, object!>?\nMicrosoft.AspNetCore.Components.ImportMap.AdditionalAttributes.set -> void\nMicrosoft.AspNetCore.Components.ImportMap.HttpContext.get -> Microsoft.AspNetCore.Http.HttpContext?\nMicrosoft.AspNetCore.Components.ImportMap.HttpContext.set -> void\nMicrosoft.AspNetCore.Components.ImportMap.ImportMap() -> void\nMicrosoft.AspNetCore.Components.ImportMap.ImportMapDefinition.get -> Microsoft.AspNetCore.Components.ImportMapDefinition?\nMicrosoft.AspNetCore.Components.ImportMap.ImportMapDefinition.set -> void\n\nMicrosoft.AspNetCore.Components.ImportMapDefinition\nMicrosoft.AspNetCore.Components.ImportMapDefinition.ImportMapDefinition(System.Collections.Generic.IReadOnlyDictionary<string!, string!>? imports, System.Collections.Generic.IReadOnlyDictionary<string!, System.Collections.Generic.IReadOnlyDictionary<string!, string!>!>? scopes, System.Collections.Generic.IReadOnlyDictionary<string!, string!>? integrity) -> void\nMicrosoft.AspNetCore.Components.ImportMapDefinition.Imports.get -> System.Collections.Generic.IReadOnlyDictionary<string!, string!>?\nMicrosoft.AspNetCore.Components.ImportMapDefinition.Integrity.get -> System.Collections.Generic.IReadOnlyDictionary<string!, string!>?\nMicrosoft.AspNetCore.Components.ImportMapDefinition.Scopes.get -> System.Collections.Generic.IReadOnlyDictionary<string!, System.Collections.Generic.IReadOnlyDictionary<string!, string!>!>?\n```\n\n----------------------------------------\n\nTITLE: JSON Response Writing with Type Information in ASP.NET Core\nDESCRIPTION: Writes JSON responses with proper handling of runtime type information. It includes suppressions for trimming and AOT warnings since it relies on the JsonSerializer's configuration to avoid reflection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive that enables nullable reference type checking, requiring explicit null handling for reference types. This helps catch potential null reference exceptions at compile time.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/MiddlewareAnalysis/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet1 Method for ASP.NET Core Endpoint Routing\nDESCRIPTION: Partial implementation of an alternative MapGet extension method for IEndpointRouteBuilder. This method appears to be a variation of the MapGet0 method with different parameter handling or response processing logic.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsDifferentInterceptorsFromSameLocation.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n%INTERCEPTSLOCATIONATTRIBUTE%\ninternal static RouteHandlerBuilder MapGet1(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n\n\n```\n\n----------------------------------------\n\nTITLE: Cascading Value Extension Methods in ASP.NET Core Blazor\nDESCRIPTION: Extension methods for adding cascading values to the service collection. These methods enable components to receive values from ancestors in the component hierarchy without explicit parameter passing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.CascadingValueServiceCollectionExtensions.AddCascadingValue<TValue>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! serviceCollection, string! name, System.Func<System.IServiceProvider!, TValue>! initialValueFactory) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.CascadingValueServiceCollectionExtensions.AddCascadingValue<TValue>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! serviceCollection, System.Func<System.IServiceProvider!, Microsoft.AspNetCore.Components.CascadingValueSource<TValue>!>! sourceFactory) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.CascadingValueServiceCollectionExtensions.AddCascadingValue<TValue>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! serviceCollection, System.Func<System.IServiceProvider!, TValue>! initialValueFactory) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.CascadingValueServiceCollectionExtensions.TryAddCascadingValue<TValue>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! serviceCollection, string! name, System.Func<System.IServiceProvider!, TValue>! valueFactory) -> void\nstatic Microsoft.Extensions.DependencyInjection.CascadingValueServiceCollectionExtensions.TryAddCascadingValue<TValue>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! serviceCollection, System.Func<System.IServiceProvider!, Microsoft.AspNetCore.Components.CascadingValueSource<TValue>!>! sourceFactory) -> void\nstatic Microsoft.Extensions.DependencyInjection.CascadingValueServiceCollectionExtensions.TryAddCascadingValue<TValue>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! serviceCollection, System.Func<System.IServiceProvider!, TValue>! valueFactory) -> void\n```\n\n----------------------------------------\n\nTITLE: URL Matching Components\nDESCRIPTION: Classes for URL matching and route tree construction including UrlMatchingNode and UrlMatchingTree.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Routing.Tree.UrlMatchingNode.UrlMatchingNode(int length) -> void\nMicrosoft.AspNetCore.Routing.Tree.UrlMatchingTree.UrlMatchingTree(int order) -> void\n```\n\n----------------------------------------\n\nTITLE: Basic Server Execution\nDESCRIPTION: Command to run the SignalR server with default settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/perf/benchmarkapps/Crankier/Readme.md#2025-04-08_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- server\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP.sys Request Timing Type Enum Values in C#\nDESCRIPTION: Enum values for HttpSysRequestTimingType that represent different stages in the TLS handshake and certificate processing pipeline in HTTP.sys.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/HttpSys/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType.TlsCertificateLoadStart = 2 -> Microsoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType\nMicrosoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType.TlsClientCertQueryEnd = 11 -> Microsoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType\nMicrosoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType.TlsClientCertQueryStart = 10 -> Microsoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType\nMicrosoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType.TlsHandshakeLeg1End = 5 -> Microsoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType\nMicrosoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType.TlsHandshakeLeg1Start = 4 -> Microsoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType\nMicrosoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType.TlsHandshakeLeg2End = 7 -> Microsoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType\nMicrosoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType.TlsHandshakeLeg2Start = 6 -> Microsoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType\n```\n\n----------------------------------------\n\nTITLE: DirectoryBrowserMiddleware Implementation in ASP.NET Core\nDESCRIPTION: Middleware that generates directory listings for requested directories when enabled. It uses a directory formatter (typically HTML) to display the contents of directories to users.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/StaticFiles/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.StaticFiles.DirectoryBrowserMiddleware.DirectoryBrowserMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.AspNetCore.Hosting.IWebHostEnvironment! hostingEnv, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Builder.DirectoryBrowserOptions!>! options) -> void\nMicrosoft.AspNetCore.StaticFiles.DirectoryBrowserMiddleware.DirectoryBrowserMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.AspNetCore.Hosting.IWebHostEnvironment! hostingEnv, System.Text.Encodings.Web.HtmlEncoder! encoder, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Builder.DirectoryBrowserOptions!>! options) -> void\nMicrosoft.AspNetCore.StaticFiles.DirectoryBrowserMiddleware.Invoke(Microsoft.AspNetCore.Http.HttpContext! context) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Implementing Request Handler for ASP.NET Core Endpoints\nDESCRIPTION: Defines the main request handler function that processes HTTP requests. It extracts parameters from the request context, performs validation, and either calls the handler directly or invokes it through endpoint filters if they are configured.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandler(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)\n                    var HttpContext_local = httpContext;\n    // Endpoint Parameter: Value (Type = Microsoft.AspNetCore.Http.Generators.Tests.AddsCustomParameterMetadataAsProperty, IsOptional = False, IsParsable = False, IsArray = False, Source = JsonBodyOrService)\n    var Value_resolveJsonBodyOrServiceResult = await Value_JsonBodyOrServiceResolver(httpContext, false);\n    if (!Value_resolveJsonBodyOrServiceResult.Item1)\n    {\n        return;\n    }\n    var Value_local = Value_resolveJsonBodyOrServiceResult.Item2!;\n\n    var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType(HttpContext_local, Value_local);\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n        return;\n    }\n    handler(args_local);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a sealed attribute class used for method interception with version and data parameters. This is part of the compiler services namespace.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsVoid_Has_No_Metadata.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ASP.NET Core MVC Infrastructure Classes\nDESCRIPTION: Concrete implementations of infrastructure interfaces including action descriptors, content executors, file handlers and redirect processors. These classes provide the core functionality for processing MVC requests and generating responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Infrastructure.ActionDescriptorCollection\nMicrosoft.AspNetCore.Mvc.Infrastructure.ContentResultExecutor\nMicrosoft.AspNetCore.Mvc.Infrastructure.DefaultOutputFormatterSelector\nMicrosoft.AspNetCore.Mvc.Infrastructure.DefaultProblemDetailsFactory\nMicrosoft.AspNetCore.Mvc.Infrastructure.FileContentResultExecutor\nMicrosoft.AspNetCore.Mvc.Infrastructure.FileResultExecutorBase\nMicrosoft.AspNetCore.Mvc.Infrastructure.FileStreamResultExecutor\nMicrosoft.AspNetCore.Mvc.Infrastructure.LocalRedirectResultExecutor\nMicrosoft.AspNetCore.Mvc.Infrastructure.ModelStateInvalidFilter\n```\n\n----------------------------------------\n\nTITLE: Defining ShowRecoveryCodesModel OnGet Method in ASP.NET Core Identity UI\nDESCRIPTION: The OnGet method implementation for the ShowRecoveryCodesModel class that returns an IActionResult. This method is called when the recovery codes page is requested via HTTP GET.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.UI.V5.Pages.Account.Manage.Internal.ShowRecoveryCodesModel.OnGet() -> Microsoft.AspNetCore.Mvc.IActionResult!\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected JSON Content Type Validation\nDESCRIPTION: Validates incoming JSON content type and either throws BadHttpRequestException or logs debug message when content type is unsupported.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedJsonContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Only Cookie Policy Enum\nDESCRIPTION: Enumeration defining options for HTTP only cookie policy enforcement. This controls whether cookies can be accessed by client-side scripts.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/CookiePolicy/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.CookiePolicy.HttpOnlyPolicy\nMicrosoft.AspNetCore.CookiePolicy.HttpOnlyPolicy.Always = 1 -> Microsoft.AspNetCore.CookiePolicy.HttpOnlyPolicy\nMicrosoft.AspNetCore.CookiePolicy.HttpOnlyPolicy.None = 0 -> Microsoft.AspNetCore.CookiePolicy.HttpOnlyPolicy\n```\n\n----------------------------------------\n\nTITLE: Creating Problem Details in ASP.NET Core MVC Controllers\nDESCRIPTION: These methods allow creating problem details responses with customizable status code, title, type, and other properties for error reporting.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_57\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Problem(string? detail = null, string? instance = null, int? statusCode = null, string? title = null, string? type = null, System.Collections.Generic.IDictionary<string!, object?>? extensions = null) -> Microsoft.AspNetCore.Mvc.ObjectResult!\nvirtual Microsoft.AspNetCore.Mvc.ControllerBase.Problem(string? detail, string? instance, int? statusCode, string? title, string? type) -> Microsoft.AspNetCore.Mvc.ObjectResult!\n```\n\n----------------------------------------\n\nTITLE: Defining WelcomePageMiddleware in C#\nDESCRIPTION: This snippet defines the WelcomePageMiddleware class, which is responsible for displaying a welcome page in ASP.NET Core applications. It includes the constructor and the Invoke method for processing requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Diagnostics.WelcomePageMiddleware\nMicrosoft.AspNetCore.Diagnostics.WelcomePageMiddleware.Invoke(Microsoft.AspNetCore.Http.HttpContext! context) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Diagnostics.WelcomePageMiddleware.WelcomePageMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Builder.WelcomePageOptions!>! options) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing AuthorizationPolicy and AuthorizationPolicyBuilder in C#\nDESCRIPTION: These classes are used to define and build authorization policies in ASP.NET Core applications. They allow for the specification of authentication schemes and authorization requirements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicy\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicy.AuthenticationSchemes.get -> System.Collections.Generic.IReadOnlyList<string!>!\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicy.AuthorizationPolicy(System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.IAuthorizationRequirement!>! requirements, System.Collections.Generic.IEnumerable<string!>! authenticationSchemes) -> void\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicy.Requirements.get -> System.Collections.Generic.IReadOnlyList<Microsoft.AspNetCore.Authorization.IAuthorizationRequirement!>!\n\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.AddAuthenticationSchemes(params string![]! schemes) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.AddRequirements(params Microsoft.AspNetCore.Authorization.IAuthorizationRequirement![]! requirements) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.AuthenticationSchemes.get -> System.Collections.Generic.IList<string!>!\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.AuthenticationSchemes.set -> void\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.AuthorizationPolicyBuilder(Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy) -> void\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.AuthorizationPolicyBuilder(params string![]! authenticationSchemes) -> void\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.Build() -> Microsoft.AspNetCore.Authorization.AuthorizationPolicy!\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.Combine(Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireAssertion(System.Func<Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext!, bool>! handler) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireAssertion(System.Func<Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext!, System.Threading.Tasks.Task<bool>!>! handler) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireAuthenticatedUser() -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireClaim(string! claimType) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireClaim(string! claimType, params string![]! allowedValues) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireClaim(string! claimType, System.Collections.Generic.IEnumerable<string!>! allowedValues) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.Requirements.get -> System.Collections.Generic.IList<Microsoft.AspNetCore.Authorization.IAuthorizationRequirement!>!\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.Requirements.set -> void\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireRole(params string![]! roles) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireRole(System.Collections.Generic.IEnumerable<string!>! roles) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireUserName(string! userName) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected JSON Content Type\nDESCRIPTION: Validates JSON content type in requests and logs unexpected types. Throws BadHttpRequestException for unsupported media types and logs debug messages using ILogger.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleEnumParam_StringReturn.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Implementing RemoteAuthenticatorViewCore Methods in C#\nDESCRIPTION: Implements the BuildRenderTree and OnParametersSetAsync methods in the RemoteAuthenticatorViewCore class for rendering and parameter handling in ASP.NET Core WebAssembly authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/WebAssembly.Authentication/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticatorViewCore<TAuthenticationState>.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder! builder) -> void\noverride Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticatorViewCore<TAuthenticationState>.OnParametersSetAsync() -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: IHubProtocol Interface and Extensions\nDESCRIPTION: Interface and extensions for implementing hub protocols in SignalR. This defines the contract for serializing and deserializing SignalR messages and provides protocol-specific functionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.SignalR.Protocol.HubProtocolExtensions\n\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.GetMessageBytes(Microsoft.AspNetCore.SignalR.Protocol.HubMessage! message) -> System.ReadOnlyMemory<byte>\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.IsVersionSupported(int version) -> bool\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.Name.get -> string!\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.TransferFormat.get -> Microsoft.AspNetCore.Connections.TransferFormat\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.TryParseMessage(ref System.Buffers.ReadOnlySequence<byte> input, Microsoft.AspNetCore.SignalR.IInvocationBinder! binder, out Microsoft.AspNetCore.SignalR.Protocol.HubMessage? message) -> bool\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.Version.get -> int\nMicrosoft.AspNetCore.SignalR.Protocol.IHubProtocol.WriteMessage(Microsoft.AspNetCore.SignalR.Protocol.HubMessage! message, System.Buffers.IBufferWriter<byte>! output) -> void\n```\n\n----------------------------------------\n\nTITLE: InputFile Component API in ASP.NET Core Forms\nDESCRIPTION: API signature for the InputFile component which handles file uploads in Blazor forms, including properties for AdditionalAttributes, Element reference, constructor, and the OnChange event.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Forms.InputFile\nMicrosoft.AspNetCore.Components.Forms.InputFile.AdditionalAttributes.get -> System.Collections.Generic.IDictionary<string!, object!>?\nMicrosoft.AspNetCore.Components.Forms.InputFile.AdditionalAttributes.set -> void\nMicrosoft.AspNetCore.Components.Forms.InputFile.Element.get -> Microsoft.AspNetCore.Components.ElementReference?\nMicrosoft.AspNetCore.Components.Forms.InputFile.Element.set -> void\nMicrosoft.AspNetCore.Components.Forms.InputFile.InputFile() -> void\nMicrosoft.AspNetCore.Components.Forms.InputFile.OnChange.get -> Microsoft.AspNetCore.Components.EventCallback<Microsoft.AspNetCore.Components.Forms.InputFileChangeEventArgs!>\nMicrosoft.AspNetCore.Components.Forms.InputFile.OnChange.set -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring Named Pipe Transport Extension Methods\nDESCRIPTION: Extension methods for IWebHostBuilder to enable and configure Named Pipe transport in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Transport.NamedPipes/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Hosting.WebHostBuilderNamedPipeExtensions.UseNamedPipes(this Microsoft.AspNetCore.Hosting.IWebHostBuilder! hostBuilder) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\n\nstatic Microsoft.AspNetCore.Hosting.WebHostBuilderNamedPipeExtensions.UseNamedPipes(this Microsoft.AspNetCore.Hosting.IWebHostBuilder! hostBuilder, System.Action<Microsoft.AspNetCore.Server.Kestrel.Transport.NamedPipes.NamedPipeTransportOptions!>! configureOptions) -> Microsoft.AspNetCore.Hosting.IWebHostBuilder!\n```\n\n----------------------------------------\n\nTITLE: Determining JSON Polymorphism Handling in ASP.NET Core\nDESCRIPTION: Helper methods to determine if a JsonTypeInfo has known polymorphism and whether it should be used with a particular runtime type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in ASP.NET Core\nDESCRIPTION: Handles cases where reading a form parameter from the request body failed. Captures the original exception and either throws a BadHttpRequestException or logs the error based on configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CORS Service Collection Extensions in C#\nDESCRIPTION: Provides extension methods for adding CORS services to the dependency injection container with optional setup actions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.CorsServiceCollectionExtensions.AddCors(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.CorsServiceCollectionExtensions.AddCors(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.Cors.Infrastructure.CorsOptions!>! setupAction) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Implementing Extension Methods for DataProtection Configuration in ASP.NET Core\nDESCRIPTION: Definition of extension methods for configuring DataProtection to use Entity Framework Core for key storage. The PersistKeysToDbContext method extends IDataProtectionBuilder to enable database storage of keys using a specific DbContext type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.DataProtection.EntityFrameworkCoreDataProtectionExtensions\nstatic Microsoft.AspNetCore.DataProtection.EntityFrameworkCoreDataProtectionExtensions.PersistKeysToDbContext<TContext>(this Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder! builder) -> Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder!\n```\n\n----------------------------------------\n\nTITLE: Overriding InputNumber<TValue> Component Methods in C#\nDESCRIPTION: Overrides the BuildRenderTree, FormatValueAsString, and TryParseValueFromString methods for the InputNumber<TValue> component in ASP.NET Core Forms.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/PublicAPI.Shipped.txt#2025-04-08_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.Components.Forms.InputNumber<TValue>.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder! builder) -> void\noverride Microsoft.AspNetCore.Components.Forms.InputNumber<TValue>.FormatValueAsString(TValue? value) -> string?\noverride Microsoft.AspNetCore.Components.Forms.InputNumber<TValue>.TryParseValueFromString(string? value, out TValue result, out string? validationErrorMessage) -> bool\n```\n\n----------------------------------------\n\nTITLE: Defining Form Content Type Logger Message in ASP.NET Core\nDESCRIPTION: Static field that defines a structured logging message for unexpected form content types. Creates a reusable logging delegate with event ID 7 and debug log level.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Writing JavaScript Test Suite for AbortSignal in ASP.NET Core\nDESCRIPTION: Example of a test suite for the AbortSignal functionality, demonstrating structure and naming conventions for tests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/JSUnitTests.md#2025-04-08_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndescribe(\"AbortSignal\", () => {\n    describe(\"aborted\", () => {\n        it(\"is false on initialization\", () => {\n            // ...\n        });\n\n        it(\"is true when aborted\", () => {\n            // ...\n        });\n    });\n\n    describe(\"onabort\", () => {\n        it(\"is called when abort is called\", () => {\n            // ...\n        });\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: RenderTreeBuilder Component Rendering API\nDESCRIPTION: Low-level API for building component render trees in Blazor, providing methods to add attributes, elements, and components to the rendering pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Components/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class RenderTreeBuilder\n{\n    public void AddAttribute(int sequence, string name);\n    public void AddAttribute(int sequence, string name, object? value);\n    public void AddAttribute(int sequence, string name, bool value);\n    public void AddAttribute(int sequence, string name, string? value);\n    public void AddAttribute(int sequence, string name, EventCallback value);\n    public void AddAttribute(int sequence, string name, MulticastDelegate? value);\n}\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants Definition\nDESCRIPTION: Defines constant arrays for common content type values used in HTTP communication including JSON, plaintext, and form data types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleEnumParam_StringReturn.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Command on Each Submodule\nDESCRIPTION: Generic command to execute a given command on each submodule in the repository.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Submodules.md#2025-04-08_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit submodule foreach '<command>'\n```\n\n----------------------------------------\n\nTITLE: AttributeRouteModel API Members in ASP.NET Core MVC\nDESCRIPTION: Public API members of the AttributeRouteModel class that allow setting order, suppressing link generation, suppressing path matching, and getting/setting the route template.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ApplicationModels.AttributeRouteModel.Order.set -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.AttributeRouteModel.SuppressLinkGeneration.get -> bool\nMicrosoft.AspNetCore.Mvc.ApplicationModels.AttributeRouteModel.SuppressLinkGeneration.set -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.AttributeRouteModel.SuppressPathMatching.get -> bool\nMicrosoft.AspNetCore.Mvc.ApplicationModels.AttributeRouteModel.SuppressPathMatching.set -> void\nMicrosoft.AspNetCore.Mvc.ApplicationModels.AttributeRouteModel.Template.get -> string?\nMicrosoft.AspNetCore.Mvc.ApplicationModels.AttributeRouteModel.Template.set -> void\n```\n\n----------------------------------------\n\nTITLE: Writing Focused JavaScript Tests with .only in ASP.NET Core\nDESCRIPTION: Example of using .only to run a single test within a test suite. This is useful for debugging specific tests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/JSUnitTests.md#2025-04-08_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndescribe(\"A suite of tests\", () => {\n    describe(\"A sub-suite of tests\", () => {\n        it.only(\"will run\", () => {\n\n        });\n\n        it(\"will not run\", () => {\n\n        });\n    });\n\n    describe(\"Another sub-suite of tests\", () => {\n        it(\"will not run either\", () => {\n\n        });\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Facebook Authentication in ASP.NET Core\nDESCRIPTION: Code snippet showing how to configure Facebook authentication in an ASP.NET Core application's Program.cs file. It adds authentication services and configures the Facebook options with app ID and secret from the application's configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Facebook/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddAuthentication()\n    .AddFacebook(options =>\n    {\n        options.AppId = Configuration[\"Authentication:Facebook:AppId\"];\n        options.AppSecret = Configuration[\"Authentication:Facebook:AppSecret\"];\n    });\n```\n\n----------------------------------------\n\nTITLE: Defining RoutePatternPartKind Enum in C#\nDESCRIPTION: This snippet defines the RoutePatternPartKind enum with values for Literal, Parameter, and Separator.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Routing.Patterns.RoutePatternPartKind\nMicrosoft.AspNetCore.Routing.Patterns.RoutePatternPartKind.Literal = 0 -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternPartKind\nMicrosoft.AspNetCore.Routing.Patterns.RoutePatternPartKind.Parameter = 1 -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternPartKind\nMicrosoft.AspNetCore.Routing.Patterns.RoutePatternPartKind.Separator = 2 -> Microsoft.AspNetCore.Routing.Patterns.RoutePatternPartKind\n```\n\n----------------------------------------\n\nTITLE: JSON Request Body Deserialization in ASP.NET Core\nDESCRIPTION: Attempts to read and deserialize the request body as JSON. Handles various error conditions like invalid content types, IO errors, and JSON parsing exceptions while providing appropriate HTTP status codes and logging.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static async ValueTask<(bool, T?)> TryResolveBodyAsync<T>(HttpContext httpContext, LogOrThrowExceptionHelper logOrThrowExceptionHelper, bool allowEmpty, string parameterTypeName, string parameterName, JsonTypeInfo<T> jsonTypeInfo, bool isInferred = false)\n{\n    var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();\n    T? bodyValue = default;\n    var bodyValueSet = false;\n\n    if (feature?.CanHaveBody == true)\n    {\n        if (!httpContext.Request.HasJsonContentType())\n        {\n            logOrThrowExceptionHelper.UnexpectedJsonContentType(httpContext.Request.ContentType);\n            httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;\n            return (false, default);\n        }\n        try\n        {\n            bodyValue = await httpContext.Request.ReadFromJsonAsync(jsonTypeInfo);\n            bodyValueSet = bodyValue != null;\n        }\n        catch (BadHttpRequestException badHttpRequestException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(badHttpRequestException);\n            httpContext.Response.StatusCode = badHttpRequestException.StatusCode;\n            return (false, default);\n        }\n        catch (IOException ioException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(ioException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n        catch (System.Text.Json.JsonException jsonException)\n        {\n            logOrThrowExceptionHelper.InvalidJsonRequestBody(parameterTypeName, parameterName, jsonException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n    }\n\n    if (!allowEmpty && !bodyValueSet)\n    {\n        if (!isInferred)\n        {\n            logOrThrowExceptionHelper.RequiredParameterNotProvided(parameterTypeName, parameterName, \"body\");\n        }\n        else\n        {\n            logOrThrowExceptionHelper.ImplicitBodyNotProvided(parameterName);\n        }\n        httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n        return (false, bodyValue);\n    }\n\n    return (true, bodyValue);\n}\n```\n\n----------------------------------------\n\nTITLE: AuthorizeViewCore Abstract Method\nDESCRIPTION: Defines the abstract method for retrieving authorization data in the AuthorizeViewCore class.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Authorization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Components.Authorization.AuthorizeViewCore.GetAuthorizeData() -> Microsoft.AspNetCore.Authorization.IAuthorizeData![]?\n```\n\n----------------------------------------\n\nTITLE: Setting Properties on ApiDescription in ASP.NET Core API Explorer\nDESCRIPTION: Extension method that sets a property of type T on an ApiDescription object. This method enables storing custom metadata on API descriptions for later retrieval.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ApiExplorer/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Mvc.ApiExplorer.ApiDescriptionExtensions.SetProperty<T>(this Microsoft.AspNetCore.Mvc.ApiExplorer.ApiDescription! apiDescription, T value) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing BuildFilterDelegate for Endpoint Filter Chain Construction\nDESCRIPTION: A method that builds a chain of endpoint filters by applying filter factories in reverse order, creating a nested filter pipeline for HTTP request processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_StringArrayParam.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core RequestHandler Implementation with BindAsync\nDESCRIPTION: Implements a request handler that binds parameters asynchronously using interface-based binding, validates the results, and processes the request with proper status code and content type handling. It supports both string and JSON response formatting.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_BindAsync_Snapshot.generated.txt#2025-04-08_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\nasync Task RequestHandler(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var httpContext_local = httpContext;\n    var myBindAsyncParam_local = await global::Microsoft.AspNetCore.Http.Generators.Tests.IBindAsync<global::Microsoft.AspNetCore.Http.Generators.Tests.MyBindAsyncFromInterfaceRecord>.BindAsync(httpContext);\n    if (myBindAsyncParam_local == null)\n    {\n        logOrThrowExceptionHelper.RequiredParameterNotProvided(\"MyBindAsyncFromInterfaceRecord\", \"myBindAsyncParam\", \"MyBindAsyncFromInterfaceRecord.BindAsync(HttpContext)\");\n        wasParamCheckFailure = true;\n        myBindAsyncParam_local = default!;\n    }\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n        return;\n    }\n    var result = handler(httpContext_local, myBindAsyncParam_local);\n    if (result is string)\n    {\n        httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n    }\n    else\n    {\n        httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n    }\n    await httpContext.Response.WriteAsync(result);\n```\n\n----------------------------------------\n\nTITLE: Declaring SignalR JSON Protocol Classes and Methods\nDESCRIPTION: API declarations for SignalR's JSON protocol implementation, including JsonHubProtocolOptions, JsonHubProtocol, and extension methods for dependency injection. Defines methods for message serialization, protocol version support, and configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/Protocols.Json/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\nMicrosoft.AspNetCore.SignalR.JsonHubProtocolOptions\nMicrosoft.AspNetCore.SignalR.JsonHubProtocolOptions.JsonHubProtocolOptions() -> void\nMicrosoft.AspNetCore.SignalR.JsonHubProtocolOptions.PayloadSerializerOptions.get -> System.Text.Json.JsonSerializerOptions!\nMicrosoft.AspNetCore.SignalR.JsonHubProtocolOptions.PayloadSerializerOptions.set -> void\nMicrosoft.AspNetCore.SignalR.Protocol.JsonHubProtocol\nMicrosoft.AspNetCore.SignalR.Protocol.JsonHubProtocol.GetMessageBytes(Microsoft.AspNetCore.SignalR.Protocol.HubMessage! message) -> System.ReadOnlyMemory<byte>\nMicrosoft.AspNetCore.SignalR.Protocol.JsonHubProtocol.IsVersionSupported(int version) -> bool\nMicrosoft.AspNetCore.SignalR.Protocol.JsonHubProtocol.JsonHubProtocol() -> void\nMicrosoft.AspNetCore.SignalR.Protocol.JsonHubProtocol.JsonHubProtocol(Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.SignalR.JsonHubProtocolOptions!>! options) -> void\nMicrosoft.AspNetCore.SignalR.Protocol.JsonHubProtocol.Name.get -> string!\nMicrosoft.AspNetCore.SignalR.Protocol.JsonHubProtocol.TransferFormat.get -> Microsoft.AspNetCore.Connections.TransferFormat\nMicrosoft.AspNetCore.SignalR.Protocol.JsonHubProtocol.TryParseMessage(ref System.Buffers.ReadOnlySequence<byte> input, Microsoft.AspNetCore.SignalR.IInvocationBinder! binder, out Microsoft.AspNetCore.SignalR.Protocol.HubMessage? message) -> bool\nMicrosoft.AspNetCore.SignalR.Protocol.JsonHubProtocol.Version.get -> int\nMicrosoft.AspNetCore.SignalR.Protocol.JsonHubProtocol.WriteMessage(Microsoft.AspNetCore.SignalR.Protocol.HubMessage! message, System.Buffers.IBufferWriter<byte>! output) -> void\nMicrosoft.Extensions.DependencyInjection.JsonProtocolDependencyInjectionExtensions\nstatic Microsoft.Extensions.DependencyInjection.JsonProtocolDependencyInjectionExtensions.AddJsonProtocol<TBuilder>(this TBuilder builder) -> TBuilder\nstatic Microsoft.Extensions.DependencyInjection.JsonProtocolDependencyInjectionExtensions.AddJsonProtocol<TBuilder>(this TBuilder builder, System.Action<Microsoft.AspNetCore.SignalR.JsonHubProtocolOptions!>! configure) -> TBuilder\n```\n\n----------------------------------------\n\nTITLE: Abstract Formatter Classes in ASP.NET Core\nDESCRIPTION: Abstract class definitions for input and output formatters handling request and response body formatting.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Mvc.Formatters.InputFormatter.ReadRequestBodyAsync(Microsoft.AspNetCore.Mvc.Formatters.InputFormatterContext! context) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.Formatters.InputFormatterResult!>!\nabstract Microsoft.AspNetCore.Mvc.Formatters.OutputFormatter.WriteResponseBodyAsync(Microsoft.AspNetCore.Mvc.Formatters.OutputFormatterWriteContext! context) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Default Model Metadata Overrides in C#\nDESCRIPTION: Override implementations for model metadata functionality, including property accessors and metadata retrieval methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_34\n\nLANGUAGE: csharp\nCODE:\n```\noverride Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.DefaultModelMetadata.AdditionalValues.get -> System.Collections.Generic.IReadOnlyDictionary<object!, object!>!\noverride Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.DefaultModelMetadata.BinderModelName.get -> string?\noverride Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.DefaultModelMetadata.BinderType.get -> System.Type?\noverride Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.DefaultModelMetadata.GetMetadataForProperties(System.Type! modelType) -> System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata!>!\noverride Microsoft.AspNetCore.Mvc.ModelBinding.Metadata.DefaultModelMetadata.GetMetadataForType(System.Type! modelType) -> Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata!\n```\n\n----------------------------------------\n\nTITLE: Implementing ManifestEmbeddedFileProvider Class in C#\nDESCRIPTION: This snippet defines the ManifestEmbeddedFileProvider class, which provides access to manifest-embedded files. It includes constructors, methods for getting directory contents and file information, and a property for accessing the assembly.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/FileProviders/Embedded/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.FileProviders.ManifestEmbeddedFileProvider\nMicrosoft.Extensions.FileProviders.ManifestEmbeddedFileProvider.Assembly.get -> System.Reflection.Assembly!\nMicrosoft.Extensions.FileProviders.ManifestEmbeddedFileProvider.GetDirectoryContents(string! subpath) -> Microsoft.Extensions.FileProviders.IDirectoryContents!\nMicrosoft.Extensions.FileProviders.ManifestEmbeddedFileProvider.GetFileInfo(string! subpath) -> Microsoft.Extensions.FileProviders.IFileInfo!\nMicrosoft.Extensions.FileProviders.ManifestEmbeddedFileProvider.ManifestEmbeddedFileProvider(System.Reflection.Assembly! assembly) -> void\nMicrosoft.Extensions.FileProviders.ManifestEmbeddedFileProvider.ManifestEmbeddedFileProvider(System.Reflection.Assembly! assembly, string! root) -> void\nMicrosoft.Extensions.FileProviders.ManifestEmbeddedFileProvider.ManifestEmbeddedFileProvider(System.Reflection.Assembly! assembly, string! root, string! manifestName, System.DateTimeOffset lastModified) -> void\nMicrosoft.Extensions.FileProviders.ManifestEmbeddedFileProvider.ManifestEmbeddedFileProvider(System.Reflection.Assembly! assembly, string! root, System.DateTimeOffset lastModified) -> void\nMicrosoft.Extensions.FileProviders.ManifestEmbeddedFileProvider.Watch(string! filter) -> Microsoft.Extensions.Primitives.IChangeToken!\n```\n\n----------------------------------------\n\nTITLE: Overriding ToString Methods for SignalR Message Classes\nDESCRIPTION: Override implementations of ToString() for various SignalR message classes to provide human-readable string representations of message objects. Useful for debugging and logging.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\noverride Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.ToString() -> string!\noverride Microsoft.AspNetCore.SignalR.Protocol.InvocationMessage.ToString() -> string!\noverride Microsoft.AspNetCore.SignalR.Protocol.StreamInvocationMessage.ToString() -> string!\noverride Microsoft.AspNetCore.SignalR.Protocol.StreamItemMessage.ToString() -> string!\n```\n\n----------------------------------------\n\nTITLE: Implementing AnalysisMiddleware for ASP.NET Core in C#\nDESCRIPTION: This snippet defines the AnalysisMiddleware class, which wraps existing middleware components to provide diagnostic information. It includes a constructor for initializing the middleware and an Invoke method for processing HTTP requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/MiddlewareAnalysis/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.MiddlewareAnalysis.AnalysisMiddleware\nMicrosoft.AspNetCore.MiddlewareAnalysis.AnalysisMiddleware.AnalysisMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, System.Diagnostics.DiagnosticSource! diagnosticSource, string! middlewareName) -> void\nMicrosoft.AspNetCore.MiddlewareAnalysis.AnalysisMiddleware.Invoke(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining IConnectionBuilder Interface in C#\nDESCRIPTION: This snippet defines the IConnectionBuilder interface with methods for building and using middleware in connection pipelines.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Connections.IConnectionBuilder\nMicrosoft.AspNetCore.Connections.IConnectionBuilder.ApplicationServices.get -> System.IServiceProvider!\nMicrosoft.AspNetCore.Connections.IConnectionBuilder.Build() -> Microsoft.AspNetCore.Connections.ConnectionDelegate!\nMicrosoft.AspNetCore.Connections.IConnectionBuilder.Use(System.Func<Microsoft.AspNetCore.Connections.ConnectionDelegate!, Microsoft.AspNetCore.Connections.ConnectionDelegate!>! middleware) -> Microsoft.AspNetCore.Connections.IConnectionBuilder!\n```\n\n----------------------------------------\n\nTITLE: Extension Methods for Configuring Output Caching in ASP.NET Core Applications\nDESCRIPTION: This snippet shows the extension methods for configuring output caching in ASP.NET Core applications. It includes methods for adding output caching to the service collection, applying output cache middleware, and configuring output caching on endpoints using convention builders.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/OutputCaching/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.DependencyInjection.OutputCacheConventionBuilderExtensions\nMicrosoft.Extensions.DependencyInjection.OutputCacheServiceCollectionExtensions\nstatic Microsoft.AspNetCore.Builder.OutputCacheApplicationBuilderExtensions.UseOutputCache(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\nstatic Microsoft.Extensions.DependencyInjection.OutputCacheConventionBuilderExtensions.CacheOutput<TBuilder>(this TBuilder builder) -> TBuilder\nstatic Microsoft.Extensions.DependencyInjection.OutputCacheConventionBuilderExtensions.CacheOutput<TBuilder>(this TBuilder builder, Microsoft.AspNetCore.OutputCaching.IOutputCachePolicy! policy) -> TBuilder\nstatic Microsoft.Extensions.DependencyInjection.OutputCacheConventionBuilderExtensions.CacheOutput<TBuilder>(this TBuilder builder, string! policyName) -> TBuilder\nstatic Microsoft.Extensions.DependencyInjection.OutputCacheConventionBuilderExtensions.CacheOutput<TBuilder>(this TBuilder builder, System.Action<Microsoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder!>! policy) -> TBuilder\nstatic Microsoft.Extensions.DependencyInjection.OutputCacheConventionBuilderExtensions.CacheOutput<TBuilder>(this TBuilder builder, System.Action<Microsoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder!>! policy, bool excludeDefaultPolicy) -> TBuilder\nstatic Microsoft.Extensions.DependencyInjection.OutputCacheServiceCollectionExtensions.AddOutputCache(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Microsoft.Extensions.DependencyInjection.OutputCacheServiceCollectionExtensions.AddOutputCache(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.OutputCaching.OutputCacheOptions!>! configureOptions) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected JSON Content Type in C#\nDESCRIPTION: This method checks for unexpected JSON content types, throws a BadHttpRequestException if necessary, and logs the event. It uses a predefined logging action for consistent message formatting.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitSource_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedJsonContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract AuthorizationHandler Methods in C#\nDESCRIPTION: Abstract method definitions for the AuthorizationHandler class that must be implemented by derived classes. These methods handle resource-specific and general authorization requirements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Authorization.AuthorizationHandler<TRequirement, TResource>.HandleRequirementAsync(Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext! context, TRequirement requirement, TResource resource) -> System.Threading.Tasks.Task!\n```\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Authorization.AuthorizationHandler<TRequirement>.HandleRequirementAsync(Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext! context, TRequirement requirement) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Writing JSON Response in ASP.NET Core in C#\nDESCRIPTION: This method writes a JSON response to the HTTP response. It handles type-specific serialization and falls back to generic object serialization if needed.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsSameInterceptorsFromDifferentFiles.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Request Handling Error Logger and Exception Manager for ASP.NET Core\nDESCRIPTION: A helper class that conditionally logs or throws exceptions based on configuration options. It handles various common request processing errors like IO exceptions, JSON parsing failures, parameter binding issues, and content type validation, providing consistent error messages and logging patterns.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/HandlesEndpointsWithAndWithoutDiagnostics.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\n    file sealed class LogOrThrowExceptionHelper\n    {\n        private readonly ILogger? _rdgLogger;\n        private readonly bool _shouldThrow;\n\n        public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n        {\n            var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n            _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n            _shouldThrow = options?.ThrowOnBadRequest ?? false;\n        }\n\n        public void RequestBodyIOException(IOException exception)\n        {\n            if (_rdgLogger != null)\n            {\n                _requestBodyIOException(_rdgLogger, exception);\n            }\n        }\n\n        private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n            LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n        public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n        {\n            if (_shouldThrow)\n            {\n                var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n                throw new BadHttpRequestException(message, exception);\n            }\n\n            if (_rdgLogger != null)\n            {\n                _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n            }\n        }\n\n        private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n            LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, \"InvalidJsonRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as JSON.\");\n\n        public void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n        {\n            if (_shouldThrow)\n            {\n                var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n                throw new BadHttpRequestException(message);\n            }\n\n            if (_rdgLogger != null)\n            {\n                _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n            }\n        }\n\n        private static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n            LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n\n        public void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)\n        {\n            if (_shouldThrow)\n            {\n                var message = string.Format(CultureInfo.InvariantCulture, \"Required parameter \\\"{0} {1}\\\" was not provided from {2}.\", parameterTypeName, parameterName, source);\n                throw new BadHttpRequestException(message);\n            }\n\n            if (_rdgLogger != null)\n            {\n                _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);\n            }\n        }\n\n        private static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n            LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n\n        public void ImplicitBodyNotProvided(string parameterName)\n        {\n            if (_shouldThrow)\n            {\n                var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n                throw new BadHttpRequestException(message);\n            }\n\n            if (_rdgLogger != null)\n            {\n                _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n            }\n        }\n\n        private static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n            LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n\n        public void UnexpectedJsonContentType(string? contentType)\n        {\n            if (_shouldThrow)\n            {\n                var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n                throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n            }\n\n            if (_rdgLogger != null)\n            {\n                _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n            }\n        }\n\n        private static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =\n            LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, \"UnexpectedContentType\"), \"Expected a supported JSON media type but got \\\"{ContentType}\\\".\");\n\n        public void UnexpectedNonFormContentType(string? contentType)\n        {\n            if (_shouldThrow)\n            {\n                var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n                throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n            }\n\n            if (_rdgLogger != null)\n            {\n                _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n            }\n        }\n\n        private static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n            LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n\n        public void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n        {\n            if (_shouldThrow)\n            {\n                var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n                throw new BadHttpRequestException(message, exception);\n            }\n\n            if (_rdgLogger != null)\n            {\n                _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n            }\n        }\n\n        private static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n            LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n    }\n```\n\n----------------------------------------\n\nTITLE: Unfiltered Request Handler Implementation for ASP.NET Core Endpoints\nDESCRIPTION: Implements the standard request handler without filtering. It processes HTTP requests by extracting and validating parameters, constructing the parameter object, and executing the endpoint handler if validation succeeds.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nTask RequestHandler(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParameterListRecordStruct, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)\n                    var HttpContext_local = httpContext;\n    // Endpoint Parameter: Value (Type = int, IsOptional = False, IsParsable = True, IsArray = False, Source = RouteOrQuery)\n    var Value_raw = Value_RouteOrQueryResolver(httpContext);\n    if (Value_raw is StringValues { Count: 0 })\n    {\n        wasParamCheckFailure = true;\n        logOrThrowExceptionHelper.RequiredParameterNotProvided(\"int\", \"Value\", \"route or query string\");\n    }\n    var Value_temp = (string?)Value_raw;\n    if (!GeneratedRouteBuilderExtensionsCore.TryParseExplicit<int>(Value_temp!, CultureInfo.InvariantCulture, out var Value_parsed_temp))\n    {\n        if (!string.IsNullOrEmpty(Value_temp))\n        {\n            logOrThrowExceptionHelper.ParameterBindingFailed(\"int\", \"Value\", Value_temp);\n            wasParamCheckFailure = true;\n        }\n    }\n    int Value_local = Value_parsed_temp!;\n\n    var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListRecordStruct { HttpContext = HttpContext_local, Value = Value_local };\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n        return Task.CompletedTask;\n    }\n    handler(args_local);\n    return Task.CompletedTask;\n}\n```\n\n----------------------------------------\n\nTITLE: StartupBase Virtual Methods for Service Configuration in ASP.NET Core\nDESCRIPTION: Virtual methods from the StartupBase class that provide customization points for configuring services and creating service providers in an ASP.NET Core application. These methods are called during application startup.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Hosting.StartupBase.ConfigureServices(Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> void\nvirtual Microsoft.AspNetCore.Hosting.StartupBase.CreateServiceProvider(Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> System.IServiceProvider!\nvirtual Microsoft.AspNetCore.Hosting.StartupBase<TBuilder>.ConfigureContainer(TBuilder builder) -> void\n```\n\n----------------------------------------\n\nTITLE: Running Specific JavaScript Test File in ASP.NET Core\nDESCRIPTION: Command to run tests in a specific file or directory. The FileName parameter can be a substring of the path.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/JSUnitTests.md#2025-04-08_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n> npm test -- FileName\n```\n\n----------------------------------------\n\nTITLE: Building Filter Delegate for ASP.NET Core Endpoints in C#\nDESCRIPTION: This method constructs a filter delegate for ASP.NET Core endpoints. It applies route handler filters in reverse order to the initial filtered invocation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsSameInterceptorsFromDifferentFiles.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Blazor WASM Benchmark with Crank\nDESCRIPTION: Command to execute Blazor WASM benchmarks using Crank with default configuration. Uses predefined benchmark profiles from the aspnetcore repository.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/benchmarkapps/Wasm.Performance/README.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncrank --config https://github.com/dotnet/aspnetcore/blob/main/src/Components/benchmarkapps/Wasm.Performance/benchmarks.compose.json?raw=true --config https://github.com/aspnet/Benchmarks/blob/main/scenarios/aspnet.profiles.yml?raw=true --scenario blazorwasmbenchmark --profile aspnet-perf-lin\n```\n\n----------------------------------------\n\nTITLE: JSON Content Type Validation in C#\nDESCRIPTION: Validates that the content type is a supported JSON media type. Returns 415 Unsupported Media Type status if validation fails.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_QueryNotPresent.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedJsonContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft.AspNetCore.Owin Package\nDESCRIPTION: Command to install the Microsoft.AspNetCore.Owin NuGet package using the dotnet CLI.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Owin/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.AspNetCore.Owin\n```\n\n----------------------------------------\n\nTITLE: Updating Submodules to Match Parent Repo\nDESCRIPTION: Command to update all submodules to match the version expected by the parent repository.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Submodules.md#2025-04-08_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit submodule update\n```\n\n----------------------------------------\n\nTITLE: Importing Specific HTTP Server API Types in C#\nDESCRIPTION: This code snippet specifies the exact Windows HTTP Server API types to be imported for use in ASP.NET Core. It includes structures for HTTP requests, authentication, SSL information, and socket addressing. The selective import approach helps reduce the final DLL size.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/IIS/IIS/src/NativeMethods.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// https://github.com/microsoft/cswin32\n// Listing specific types reduces the size of the final dll.\n// Uncomment the next line to import all definitions during development.\n// Windows.Win32.Networking.HttpServer\nHTTP_AUTH_STATUS\nHTTP_COOKED_URL\nHTTP_DATA_CHUNK\nHTTP_REQUEST_AUTH_INFO\nHTTP_REQUEST_AUTH_TYPE\nHTTP_REQUEST_FLAG_*\nHTTP_REQUEST_PROPERTY\nHTTP_REQUEST_PROPERTY_SNI\nHTTP_REQUEST_PROPERTY_SNI_HOST_MAX_LENGTH\nHTTP_REQUEST_V1\nHTTP_REQUEST_V2\nHTTP_SSL_PROTOCOL_INFO\nSOCKADDR_IN\nSOCKADDR_IN6\n```\n\n----------------------------------------\n\nTITLE: Form Generation Extensions in ASP.NET Core\nDESCRIPTION: Extension methods for creating HTML forms with various routing and configuration options. Supports antiforgery tokens, custom HTML attributes, and different HTTP methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperFormExtensions.BeginForm(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper htmlHelper, Microsoft.AspNetCore.Mvc.Rendering.FormMethod method, bool? antiforgery, object htmlAttributes) -> Microsoft.AspNetCore.Mvc.Rendering.MvcForm\n```\n\n----------------------------------------\n\nTITLE: Implementing SecurityTokenReceivedContext for WS-Federation Authentication in C#\nDESCRIPTION: This class represents the context when a security token is received during WS-Federation authentication. It includes properties for the protocol message and a constructor for initializing the context.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/WsFederation/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.WsFederation.SecurityTokenReceivedContext\nMicrosoft.AspNetCore.Authentication.WsFederation.SecurityTokenReceivedContext.ProtocolMessage.get -> Microsoft.IdentityModel.Protocols.WsFederation.WsFederationMessage!\nMicrosoft.AspNetCore.Authentication.WsFederation.SecurityTokenReceivedContext.ProtocolMessage.set -> void\nMicrosoft.AspNetCore.Authentication.WsFederation.SecurityTokenReceivedContext.SecurityTokenReceivedContext(Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Authentication.AuthenticationScheme! scheme, Microsoft.AspNetCore.Authentication.WsFederation.WsFederationOptions! options, Microsoft.AspNetCore.Authentication.AuthenticationProperties! properties) -> void\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: A preprocessor directive that enables nullable reference type checks, helping catch potential null reference exceptions at compile time. This is a C# 8.0+ feature that improves type safety in the codebase.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/netstandard2.0/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: HTTP Request Trailer Extensions in ASP.NET Core\nDESCRIPTION: Extension methods for handling HTTP trailers in requests, providing functionality to check for trailer support, access declared trailers, and retrieve trailer values.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.RequestTrailerExtensions.CheckTrailersAvailable(this Microsoft.AspNetCore.Http.HttpRequest! request) -> bool\nstatic Microsoft.AspNetCore.Http.RequestTrailerExtensions.GetDeclaredTrailers(this Microsoft.AspNetCore.Http.HttpRequest! request) -> Microsoft.Extensions.Primitives.StringValues\nstatic Microsoft.AspNetCore.Http.RequestTrailerExtensions.GetTrailer(this Microsoft.AspNetCore.Http.HttpRequest! request, string! trailerName) -> Microsoft.Extensions.Primitives.StringValues\nstatic Microsoft.AspNetCore.Http.RequestTrailerExtensions.SupportsTrailers(this Microsoft.AspNetCore.Http.HttpRequest! request) -> bool\n```\n\n----------------------------------------\n\nTITLE: Defining QuickGrid Column Base Class in C#\nDESCRIPTION: This snippet defines the abstract base class for columns in the QuickGrid component. It includes properties for alignment, styling, sorting, and content rendering.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/QuickGrid/Microsoft.AspNetCore.Components.QuickGrid/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.Align.get -> Microsoft.AspNetCore.Components.QuickGrid.Align\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.Align.set -> void\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.Class.get -> string?\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.Class.set -> void\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.ColumnBase() -> void\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.ColumnOptions.get -> Microsoft.AspNetCore.Components.RenderFragment?\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.ColumnOptions.set -> void\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.Grid.get -> Microsoft.AspNetCore.Components.QuickGrid.QuickGrid<TGridItem>!\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.HeaderContent.get -> Microsoft.AspNetCore.Components.RenderFragment!\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.HeaderContent.set -> void\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.HeaderTemplate.get -> Microsoft.AspNetCore.Components.RenderFragment<Microsoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>!>?\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.HeaderTemplate.set -> void\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.InitialSortDirection.get -> Microsoft.AspNetCore.Components.QuickGrid.SortDirection\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.InitialSortDirection.set -> void\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.IsDefaultSortColumn.get -> bool\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.IsDefaultSortColumn.set -> void\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.PlaceholderTemplate.get -> Microsoft.AspNetCore.Components.RenderFragment<Microsoft.AspNetCore.Components.Web.Virtualization.PlaceholderContext>?\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.PlaceholderTemplate.set -> void\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.Sortable.get -> bool?\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.Sortable.set -> void\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.Title.get -> string?\nMicrosoft.AspNetCore.Components.QuickGrid.ColumnBase<TGridItem>.Title.set -> void\n```\n\n----------------------------------------\n\nTITLE: RedirectToPageResult Class Definition - C#\nDESCRIPTION: Class for handling page redirections in ASP.NET Core MVC with support for page name, handler, route values, and URL fragments.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.RedirectToPageResult.RedirectToPageResult(string? pageName, string? pageHandler, object? routeValues, bool permanent, bool preserveMethod, string? fragment) -> void\n```\n\n----------------------------------------\n\nTITLE: Cloning the ASP.NET Core Repository with Submodules in Bash\nDESCRIPTION: Command to clone the ASP.NET Core repository from a personal fork, including all submodules using the --recursive flag.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/BuildFromSource.md#2025-04-08_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --recursive https://github.com/YOUR_USERNAME/aspnetcore\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata in ASP.NET Core\nDESCRIPTION: Implementation of IParameterBindingMetadata for storing parameter binding information. This class captures details like parameter name, type, and binding capabilities needed for request parameter resolution.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Post_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Server Delegation Interface in C#\nDESCRIPTION: Interface for creating delegation rules in HTTP.sys that allow forwarding requests to specific URL prefixes and queue names.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/HttpSys/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Server.HttpSys.IServerDelegationFeature\nMicrosoft.AspNetCore.Server.HttpSys.IServerDelegationFeature.CreateDelegationRule(string! queueName, string! urlPrefix) -> Microsoft.AspNetCore.Server.HttpSys.DelegationRule!\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Extension Method for IEndpointRouteBuilder in C#\nDESCRIPTION: Extends IEndpointRouteBuilder with a MapGet method to handle HTTP GET requests. It includes metadata population, request delegate creation, and applies endpoint filters if defined.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_MultipleSpecialTypeParam_StringReturn.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        // Metadata population logic\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        // Request delegate creation logic\n    };\n    var castHandler = Cast(handler, global::System.String (global::Microsoft.AspNetCore.Http.HttpRequest arg0, global::Microsoft.AspNetCore.Http.HttpResponse arg1) => throw null!);\n    return MapCore(\n        endpoints,\n        pattern,\n        handler,\n        GetVerb,\n        populateMetadata,\n        createRequestDelegate,\n        castHandler.Method);\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Form Request Body Handler\nDESCRIPTION: Handles invalid form request body by either throwing BadHttpRequestException or logging debug message with parameter details and exception.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ModelMetadataProvider Methods in ASP.NET Core MVC\nDESCRIPTION: Virtual methods in the ModelMetadataProvider class for retrieving metadata for constructors, parameters, and properties. These methods are crucial for model binding operations in ASP.NET Core MVC.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadataProvider.GetMetadataForConstructor(System.Reflection.ConstructorInfo! constructor, System.Type! modelType) -> Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadataProvider.GetMetadataForParameter(System.Reflection.ParameterInfo! parameter, System.Type! modelType) -> Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata!\nvirtual Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadataProvider.GetMetadataForProperty(System.Reflection.PropertyInfo! propertyInfo, System.Type! modelType) -> Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata!\n```\n\n----------------------------------------\n\nTITLE: Defining WebHostService Class for ASP.NET Core Windows Service\nDESCRIPTION: This class extends the functionality of IWebHost to run as a Windows Service. It includes constructor and lifecycle methods for service management.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/WindowsServices/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Hosting.WindowsServices.WebHostService\nMicrosoft.AspNetCore.Hosting.WindowsServices.WebHostService.WebHostService(Microsoft.AspNetCore.Hosting.IWebHost! host) -> void\noverride sealed Microsoft.AspNetCore.Hosting.WindowsServices.WebHostService.OnStart(string![]! args) -> void\noverride sealed Microsoft.AspNetCore.Hosting.WindowsServices.WebHostService.OnStop() -> void\nvirtual Microsoft.AspNetCore.Hosting.WindowsServices.WebHostService.OnStarted() -> void\nvirtual Microsoft.AspNetCore.Hosting.WindowsServices.WebHostService.OnStarting(string![]! args) -> void\nvirtual Microsoft.AspNetCore.Hosting.WindowsServices.WebHostService.OnStopped() -> void\nvirtual Microsoft.AspNetCore.Hosting.WindowsServices.WebHostService.OnStopping() -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing Core Route Mapping in ASP.NET Core\nDESCRIPTION: Core mapping functionality for route handlers in ASP.NET Core, providing a bridge between route builder extensions and route handler services.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ReturnsVoid_Has_No_Metadata.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ValidationProblem Result Method in C#\nDESCRIPTION: This method creates a ValidationProblem result with customizable error details, status code, and additional metadata.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.Results.ValidationProblem(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string!, string![]!>>! errors, string? detail = null, string? instance = null, int? statusCode = null, string? title = null, string? type = null, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string!, object?>>? extensions = null) -> Microsoft.AspNetCore.Http.IResult!\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Implementation in ASP.NET Core\nDESCRIPTION: Generated class that provides metadata about parameters being bound in request delegates, including information about parsing capabilities, binding methods, and optionality.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Content Result Methods in C#\nDESCRIPTION: These methods create content results with various options for content type, encoding, and status code.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.TypedResults.Content(string? content, Microsoft.Net.Http.Headers.MediaTypeHeaderValue! contentType) -> Microsoft.AspNetCore.Http.HttpResults.ContentHttpResult!\nstatic Microsoft.AspNetCore.Http.TypedResults.Content(string? content, string? contentType = null, System.Text.Encoding? contentEncoding = null, int? statusCode = null) -> Microsoft.AspNetCore.Http.HttpResults.ContentHttpResult!\nstatic Microsoft.AspNetCore.Http.TypedResults.Content(string? content, string? contentType, System.Text.Encoding? contentEncoding) -> Microsoft.AspNetCore.Http.HttpResults.ContentHttpResult!\n```\n\n----------------------------------------\n\nTITLE: BindingAddress Class for Server Binding in ASP.NET Core\nDESCRIPTION: The BindingAddress class handles server binding information in ASP.NET Core. It supports different binding types including HTTP, named pipes, and Unix pipes, and encapsulates host, port, scheme, and path information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.BindingAddress\nMicrosoft.AspNetCore.Http.BindingAddress.BindingAddress() -> void\nMicrosoft.AspNetCore.Http.BindingAddress.Host.get -> string!\nMicrosoft.AspNetCore.Http.BindingAddress.IsNamedPipe.get -> bool\nMicrosoft.AspNetCore.Http.BindingAddress.IsUnixPipe.get -> bool\nMicrosoft.AspNetCore.Http.BindingAddress.NamedPipeName.get -> string!\nMicrosoft.AspNetCore.Http.BindingAddress.PathBase.get -> string!\nMicrosoft.AspNetCore.Http.BindingAddress.Port.get -> int\nMicrosoft.AspNetCore.Http.BindingAddress.Scheme.get -> string!\nMicrosoft.AspNetCore.Http.BindingAddress.UnixPipePath.get -> string!\n```\n\n----------------------------------------\n\nTITLE: EditContextProperties Class API for ASP.NET Core Blazor Forms\nDESCRIPTION: The EditContextProperties class provides a dictionary-like storage for attaching custom properties to an EditContext. It enables storing and retrieving arbitrary data associated with the form's edit context.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/Forms/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Components.Forms.EditContextProperties\nMicrosoft.AspNetCore.Components.Forms.EditContextProperties.EditContextProperties() -> void\nMicrosoft.AspNetCore.Components.Forms.EditContextProperties.Remove(object! key) -> bool\nMicrosoft.AspNetCore.Components.Forms.EditContextProperties.this[object! key].get -> object!\nMicrosoft.AspNetCore.Components.Forms.EditContextProperties.this[object! key].set -> void\nMicrosoft.AspNetCore.Components.Forms.EditContextProperties.TryGetValue(object! key, out object? value) -> bool\n```\n\n----------------------------------------\n\nTITLE: Defining Required Parameter Logger in ASP.NET Core\nDESCRIPTION: Defines a structured logger for missing required parameters using LoggerMessage.Define. Creates an efficient logging delegate to capture parameter type, name, and expected source with minimal allocations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n    LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n```\n\n----------------------------------------\n\nTITLE: Running Tests for ASP.NET Core Data Protection Project\nDESCRIPTION: Instructions for running tests for the DataProtection project. It references the main BuildFromSource.md file for detailed steps on running tests from the command line.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/DataProtection/README.md#2025-04-08_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n### Test\n\nTo run the tests for this project, [run the tests on the command line](../../docs/BuildFromSource.md#running-tests-on-command-line) in this directory.\n```\n\n----------------------------------------\n\nTITLE: Defining PageModel Base Class Methods - C#\nDESCRIPTION: Core method definitions for the PageModel class including model binding, HTTP context access, and routing functionality. These methods provide the foundation for Razor Pages handler methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class PageModel\n{\n    public HttpContext HttpContext { get; }\n    public IModelMetadataProvider MetadataProvider { get; set; }\n    public ModelStateDictionary ModelState { get; }\n    public PageContext PageContext { get; set; }\n    public HttpRequest Request { get; }\n    public HttpResponse Response { get; }\n    public RouteData RouteData { get; }\n    public ITempDataDictionary TempData { get; set; }\n    public IUrlHelper Url { get; set; }\n    public ClaimsPrincipal User { get; }\n    public ViewDataDictionary ViewData { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Compiler directive that enables nullable reference type checking to help prevent null reference exceptions. This enforces more strict null checking at compile time.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.TagHelpers/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Core Theory Test Implementation Pattern\nDESCRIPTION: Demonstrates the recommended pattern for organizing Theory tests to avoid timeout issues by splitting test cases across multiple test methods. Includes conditional execution and skip logic for specific test environments.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/ProjectTemplates/README.md#2025-04-08_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n[ConditionalTheory]\n[SkipOnHelix(\"https://github.com/dotnet/aspnetcore/issues/28090\", Queues = HelixConstants.Windows10Arm64 + HelixConstants.DebianArm64)]\n[InlineData(\"IndividualB2C\", null)]\n[InlineData(\"IndividualB2C\", new[] { ArgConstants.UseProgramMain })]\n[InlineData(\"IndividualB2C\", new[] { ArgConstants.CalledApiUrlGraphMicrosoftCom, ArgConstants.CalledApiScopesUserReadWrite })]\n[InlineData(\"IndividualB2C\", new[] { ArgConstants.UseProgramMain, ArgConstants.CalledApiUrlGraphMicrosoftCom, ArgConstants.CalledApiScopesUserReadWrite })]\npublic Task MvcTemplate_IdentityWeb_IndividualB2C_BuildsAndPublishes(string auth, string[] args) => MvcTemplateBuildsAndPublishes(auth: auth, args: args);\n\n[ConditionalTheory]\n[SkipOnHelix(\"https://github.com/dotnet/aspnetcore/issues/28090\", Queues = HelixConstants.Windows10Arm64 + HelixConstants.DebianArm64)]\n[InlineData(\"SingleOrg\", null)]\n[InlineData(\"SingleOrg\", new[] { ArgConstants.UseProgramMain })]\n[InlineData(\"SingleOrg\", new[] { ArgConstants.CalledApiUrlGraphMicrosoftCom, ArgConstants.CalledApiScopesUserReadWrite })]\n[InlineData(\"SingleOrg\", new[] { ArgConstants.UseProgramMain, ArgConstants.CalledApiUrlGraphMicrosoftCom, ArgConstants.CalledApiScopesUserReadWrite })]\n[InlineData(\"SingleOrg\", new[] { ArgConstants.CallsGraph })]\n[InlineData(\"SingleOrg\", new[] { ArgConstants.UseProgramMain, ArgConstants.CallsGraph })]\npublic Task MvcTemplate_IdentityWeb_SingleOrg_BuildsAndPublishes(string auth, string[] args) => MvcTemplateBuildsAndPublishes(auth: auth, args: args);\n```\n\n----------------------------------------\n\nTITLE: Building ASP.NET Core MVC Project\nDESCRIPTION: Command line instructions for building the ASP.NET Core MVC project from source. Requires executing the build script appropriate for the operating system.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/README.md#2025-04-08_snippet_0\n\nLANGUAGE: batch\nCODE:\n```\nbuild.cmd\n```\n\nLANGUAGE: shell\nCODE:\n```\nbuild.sh\n```\n\n----------------------------------------\n\nTITLE: Migrations Endpoint Middleware Implementation in ASP.NET Core (C#)\nDESCRIPTION: Middleware implementation that provides an HTTP endpoint for applying Entity Framework Core migrations. Includes the constructor for dependency injection and the Invoke method that processes migration requests.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics.EntityFrameworkCore/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Diagnostics.EntityFrameworkCore.MigrationsEndPointMiddleware.MigrationsEndPointMiddleware(Microsoft.AspNetCore.Http.RequestDelegate! next, Microsoft.Extensions.Logging.ILogger<Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore.MigrationsEndPointMiddleware!>! logger, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Builder.MigrationsEndPointOptions!>! options) -> void\nvirtual Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore.MigrationsEndPointMiddleware.Invoke(Microsoft.AspNetCore.Http.HttpContext! context) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Decoding Completion Message with Non-Void Result in MessagePack\nDESCRIPTION: Shows the decoding of a Completion message with a non-void result in the SignalR MessagePack protocol. It includes message type, headers, invocation ID, result kind, and the result value.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_10\n\nLANGUAGE: MessagePack\nCODE:\n```\n0x95 0x03 0x80 0xa3 0x78 0x79 0x7a 0x03 0x2a\n```\n\n----------------------------------------\n\nTITLE: File Path References for TFM Updates in ASP.NET Core\nDESCRIPTION: References to key project files that need updating when ingesting a new SDK with updated TFM. These files control the default .NET Core target framework settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/UpdatingMajorVersionAndTFM.md#2025-04-08_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n/eng/tools/RepoTasks/RepoTasks.csproj\n/eng/tools/RepoTasks/RepoTasks.tasks\n```\n\n----------------------------------------\n\nTITLE: DefaultAuthorizationEvaluator Class Definition in C#\nDESCRIPTION: Definition of the DefaultAuthorizationEvaluator class that evaluates the state of AuthorizationHandlerContext to determine if authorization was successful.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.DefaultAuthorizationEvaluator\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.DefaultAuthorizationEvaluator.DefaultAuthorizationEvaluator() -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.DefaultAuthorizationEvaluator.Evaluate(Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext! context) -> Microsoft.AspNetCore.Authorization.AuthorizationResult!\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Extension Method for IEndpointRouteBuilder in C#\nDESCRIPTION: Implements the MapGet extension method for IEndpointRouteBuilder to handle GET requests. It includes metadata population, request delegate creation, and parameter binding logic.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/SupportsSameInterceptorsFromDifferentFiles.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        // Metadata population logic\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        // Request delegate creation logic\n    };\n    var castHandler = Cast(handler, global::System.String (global::System.String arg0) => throw null!);\n    return MapCore(\n        endpoints,\n        pattern,\n        handler,\n        GetVerb,\n        populateMetadata,\n        createRequestDelegate,\n        castHandler.Method);\n}\n```\n\n----------------------------------------\n\nTITLE: DefaultHttpContext Class in ASP.NET Core\nDESCRIPTION: The default implementation of HttpContext in ASP.NET Core. It provides access to request, response, and server features through a feature collection, and contains services like form processing options and scope factories.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.DefaultHttpContext\nMicrosoft.AspNetCore.Http.DefaultHttpContext.DefaultHttpContext() -> void\nMicrosoft.AspNetCore.Http.DefaultHttpContext.DefaultHttpContext(Microsoft.AspNetCore.Http.Features.IFeatureCollection! features) -> void\nMicrosoft.AspNetCore.Http.DefaultHttpContext.FormOptions.get -> Microsoft.AspNetCore.Http.Features.FormOptions!\nMicrosoft.AspNetCore.Http.DefaultHttpContext.FormOptions.set -> void\nMicrosoft.AspNetCore.Http.DefaultHttpContext.HttpContext.get -> Microsoft.AspNetCore.Http.HttpContext!\nMicrosoft.AspNetCore.Http.DefaultHttpContext.Initialize(Microsoft.AspNetCore.Http.Features.IFeatureCollection! features) -> void\nMicrosoft.AspNetCore.Http.DefaultHttpContext.ServiceScopeFactory.get -> Microsoft.Extensions.DependencyInjection.IServiceScopeFactory!\nMicrosoft.AspNetCore.Http.DefaultHttpContext.ServiceScopeFactory.set -> void\nMicrosoft.AspNetCore.Http.DefaultHttpContext.Uninitialize() -> void\n```\n\n----------------------------------------\n\nTITLE: HttpRequestFeature in ASP.NET Core\nDESCRIPTION: Feature containing the core HTTP request data in ASP.NET Core. It provides access to request properties like method, path, headers, body, protocol, and query string information needed for request processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.Body.get -> System.IO.Stream!\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.Body.set -> void\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.Headers.get -> Microsoft.AspNetCore.Http.IHeaderDictionary!\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.Headers.set -> void\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.HttpRequestFeature() -> void\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.Method.get -> string!\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.Method.set -> void\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.Path.get -> string!\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.Path.set -> void\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.PathBase.get -> string!\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.PathBase.set -> void\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.Protocol.get -> string!\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.Protocol.set -> void\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.QueryString.get -> string!\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.QueryString.set -> void\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.RawTarget.get -> string!\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.RawTarget.set -> void\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.Scheme.get -> string!\nMicrosoft.AspNetCore.Http.Features.HttpRequestFeature.Scheme.set -> void\n```\n\n----------------------------------------\n\nTITLE: IQueuePolicy Interface for Concurrency Limiter\nDESCRIPTION: Interface that defines how requests are queued and processed. Implementations control whether requests are accepted, queued, or rejected based on the current server load.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ConcurrencyLimiter/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.ConcurrencyLimiter.IQueuePolicy.TryEnterAsync() -> System.Threading.Tasks.ValueTask<bool>\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.ConcurrencyLimiter.IQueuePolicy.OnExit() -> void\n```\n\n----------------------------------------\n\nTITLE: Runtime Type Compatibility Check for JSON Serialization\nDESCRIPTION: Determines if a JsonTypeInfo instance should be used with a given runtime type. This helps select the most appropriate serialization approach based on type relationships.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Post_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)\n    => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();\n```\n\n----------------------------------------\n\nTITLE: Defining ApiParameterDescription Class in C#\nDESCRIPTION: Class definition for describing API parameters including binding information, validation requirements, and routing details.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ApiExplorer.ApiParameterDescription.ApiParameterDescription() -> void\nMicrosoft.AspNetCore.Mvc.ApiExplorer.ApiParameterDescription.BindingInfo.get -> Microsoft.AspNetCore.Mvc.ModelBinding.BindingInfo?\nMicrosoft.AspNetCore.Mvc.ApiExplorer.ApiParameterDescription.BindingInfo.set -> void\nMicrosoft.AspNetCore.Mvc.ApiExplorer.ApiParameterDescription.IsRequired.get -> bool\nMicrosoft.AspNetCore.Mvc.ApiExplorer.ApiParameterDescription.IsRequired.set -> void\n```\n\n----------------------------------------\n\nTITLE: JSON Content Type Validation in ASP.NET Core\nDESCRIPTION: Validates JSON content type headers, throwing BadHttpRequestException with 415 status code if invalid.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam.generated.txt#2025-04-08_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedJsonContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced OutputCachePolicyBuilder Methods for Tagging and Conditional Caching in ASP.NET Core\nDESCRIPTION: This snippet shows the OutputCachePolicyBuilder methods for tagging cache entries, varying output by custom values, and conditional caching with predicate functions. These methods allow for more complex caching scenarios including tag-based cache invalidation and context-dependent caching decisions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/OutputCaching/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder.Tag(params string![]! tags) -> Microsoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder!\nMicrosoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder.VaryByValue(string! key, string! value) -> Microsoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder!\nMicrosoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder.VaryByValue(System.Func<Microsoft.AspNetCore.Http.HttpContext!, System.Collections.Generic.KeyValuePair<string!, string!>>! varyBy) -> Microsoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder!\nMicrosoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder.VaryByValue(System.Func<Microsoft.AspNetCore.Http.HttpContext!, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask<System.Collections.Generic.KeyValuePair<string!, string!>>>! varyBy) -> Microsoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder!\nMicrosoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder.With(System.Func<Microsoft.AspNetCore.OutputCaching.OutputCacheContext!, bool>! predicate) -> Microsoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder!\nMicrosoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder.With(System.Func<Microsoft.AspNetCore.OutputCaching.OutputCacheContext!, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask<bool>>! predicate) -> Microsoft.AspNetCore.OutputCaching.OutputCachePolicyBuilder!\n```\n\n----------------------------------------\n\nTITLE: FormFeature for Form Processing in ASP.NET Core\nDESCRIPTION: Feature for handling form data in HTTP requests. It provides methods to read form data from request bodies, supports both synchronous and asynchronous operations, and handles form content validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Features.FormFeature\nMicrosoft.AspNetCore.Http.Features.FormFeature.Form.get -> Microsoft.AspNetCore.Http.IFormCollection?\nMicrosoft.AspNetCore.Http.Features.FormFeature.Form.set -> void\nMicrosoft.AspNetCore.Http.Features.FormFeature.FormFeature(Microsoft.AspNetCore.Http.HttpRequest! request) -> void\nMicrosoft.AspNetCore.Http.Features.FormFeature.FormFeature(Microsoft.AspNetCore.Http.HttpRequest! request, Microsoft.AspNetCore.Http.Features.FormOptions! options) -> void\nMicrosoft.AspNetCore.Http.Features.FormFeature.FormFeature(Microsoft.AspNetCore.Http.IFormCollection! form) -> void\nMicrosoft.AspNetCore.Http.Features.FormFeature.HasFormContentType.get -> bool\nMicrosoft.AspNetCore.Http.Features.FormFeature.ReadForm() -> Microsoft.AspNetCore.Http.IFormCollection!\nMicrosoft.AspNetCore.Http.Features.FormFeature.ReadFormAsync() -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Http.IFormCollection!>!\nMicrosoft.AspNetCore.Http.Features.FormFeature.ReadFormAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Http.IFormCollection!>!\n```\n\n----------------------------------------\n\nTITLE: Displaying Cost Labels in Markdown\nDESCRIPTION: This code snippet shows an embedded image in Markdown format, which displays the cost labels used for rough estimations of issue complexity during the release planning process.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/ReleasePlanning.md#2025-04-08_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n![image](https://user-images.githubusercontent.com/34246760/139494632-2a5145f6-eec9-40d6-919f-3ece8b9c986a.png)\n```\n\n----------------------------------------\n\nTITLE: Invalid Form Request Body Handler in C#\nDESCRIPTION: Handles cases where form data in the request body cannot be properly parsed. Includes exception propagation and logging.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_StringArrayParam_Optional.generated.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n\nprivate static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n    LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Non-Form Content Type in C#\nDESCRIPTION: This method handles cases where an unexpected non-form content type is received. It throws a BadHttpRequestException with a 415 status code or logs the issue.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Twitter Request Tokens in C#\nDESCRIPTION: Defines the RequestToken class for managing Twitter request tokens, including properties for token, token secret, and callback confirmation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Twitter/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.Twitter.RequestToken\nMicrosoft.AspNetCore.Authentication.Twitter.RequestToken.CallbackConfirmed.get -> bool\nMicrosoft.AspNetCore.Authentication.Twitter.RequestToken.CallbackConfirmed.set -> void\nMicrosoft.AspNetCore.Authentication.Twitter.RequestToken.Properties.get -> Microsoft.AspNetCore.Authentication.AuthenticationProperties!\nMicrosoft.AspNetCore.Authentication.Twitter.RequestToken.Properties.set -> void\nMicrosoft.AspNetCore.Authentication.Twitter.RequestToken.RequestToken() -> void\nMicrosoft.AspNetCore.Authentication.Twitter.RequestToken.Token.get -> string!\nMicrosoft.AspNetCore.Authentication.Twitter.RequestToken.Token.set -> void\nMicrosoft.AspNetCore.Authentication.Twitter.RequestToken.TokenSecret.get -> string!\nMicrosoft.AspNetCore.Authentication.Twitter.RequestToken.TokenSecret.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining RootNamespaceAttribute Class in C#\nDESCRIPTION: Creates an attribute class for specifying root namespaces.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Localization/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Localization.RootNamespaceAttribute.RootNamespace.get -> string!\nMicrosoft.Extensions.Localization.RootNamespaceAttribute.RootNamespaceAttribute(string! rootNamespace) -> void\n```\n\n----------------------------------------\n\nTITLE: OAuth Extension Methods\nDESCRIPTION: Extension methods for configuring OAuth authentication in the application's service collection\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OAuth/src/PublicAPI.Shipped.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.OAuthExtensions.AddOAuth(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, string! authenticationScheme, string! displayName, System.Action<Microsoft.AspNetCore.Authentication.OAuth.OAuthOptions!>! configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\nstatic Microsoft.Extensions.DependencyInjection.OAuthExtensions.AddOAuth(this Microsoft.AspNetCore.Authentication.AuthenticationBuilder! builder, string! authenticationScheme, System.Action<Microsoft.AspNetCore.Authentication.OAuth.OAuthOptions!>! configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Class in C# for ASP.NET Core\nDESCRIPTION: This class represents metadata for parameter binding in ASP.NET Core. It includes properties for the parameter name, type information, and binding capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitServiceParam_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BuildFilterDelegate Method for Endpoint Filtering in C#\nDESCRIPTION: Creates a BuildFilterDelegate method that applies a series of endpoint filters to the request processing pipeline. It iterates through filter factories in reverse order to build the filter chain.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_MultipleSpecialTypeParam_StringReturn.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: View Rendering Methods in PageModel\nDESCRIPTION: Methods for rendering pages and partial views with optional model data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.Page() -> Microsoft.AspNetCore.Mvc.RazorPages.PageResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.Partial(string! viewName) -> Microsoft.AspNetCore.Mvc.PartialViewResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageModel.Partial(string! viewName, object? model) -> Microsoft.AspNetCore.Mvc.PartialViewResult!\n```\n\n----------------------------------------\n\nTITLE: ApplicationBuilder Class Methods and Properties in ASP.NET Core\nDESCRIPTION: The ApplicationBuilder class that implements the middleware pipeline in ASP.NET Core. It provides methods for configuring HTTP request processing, building the request delegate, and managing server features and application properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Builder.ApplicationBuilder\nMicrosoft.AspNetCore.Builder.ApplicationBuilder.ApplicationBuilder(System.IServiceProvider! serviceProvider) -> void\nMicrosoft.AspNetCore.Builder.ApplicationBuilder.ApplicationBuilder(System.IServiceProvider! serviceProvider, object! server) -> void\nMicrosoft.AspNetCore.Builder.ApplicationBuilder.ApplicationServices.get -> System.IServiceProvider!\nMicrosoft.AspNetCore.Builder.ApplicationBuilder.ApplicationServices.set -> void\nMicrosoft.AspNetCore.Builder.ApplicationBuilder.Build() -> Microsoft.AspNetCore.Http.RequestDelegate!\nMicrosoft.AspNetCore.Builder.ApplicationBuilder.New() -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\nMicrosoft.AspNetCore.Builder.ApplicationBuilder.Properties.get -> System.Collections.Generic.IDictionary<string!, object?>!\nMicrosoft.AspNetCore.Builder.ApplicationBuilder.ServerFeatures.get -> Microsoft.AspNetCore.Http.Features.IFeatureCollection!\nMicrosoft.AspNetCore.Builder.ApplicationBuilder.Use(System.Func<Microsoft.AspNetCore.Http.RequestDelegate!, Microsoft.AspNetCore.Http.RequestDelegate!>! middleware) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Implementing MessageReceivedContext Class in C#\nDESCRIPTION: Defines the MessageReceivedContext class which represents the context for the message received event in Bearer Token authentication. It includes properties for the HTTP context, authentication scheme, options, and the received token.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/BearerToken/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.BearerToken.MessageReceivedContext\nMicrosoft.AspNetCore.Authentication.BearerToken.MessageReceivedContext.MessageReceivedContext(Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Authentication.AuthenticationScheme! scheme, Microsoft.AspNetCore.Authentication.BearerToken.BearerTokenOptions! options) -> void\nMicrosoft.AspNetCore.Authentication.BearerToken.MessageReceivedContext.Token.get -> string?\nMicrosoft.AspNetCore.Authentication.BearerToken.MessageReceivedContext.Token.set -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring Razor Pages at Content Root in ASP.NET Core\nDESCRIPTION: Extension method for IMvcBuilder that configures Razor Pages to be at the content root of the application. This impacts where Razor Pages files are located in the application structure.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.MvcRazorPagesMvcBuilderExtensions.WithRazorPagesAtContentRoot(this Microsoft.Extensions.DependencyInjection.IMvcBuilder! builder) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\n```\n\n----------------------------------------\n\nTITLE: Problem Details JSON Converter Implementation\nDESCRIPTION: Custom JSON converter implementation for handling ProblemDetails and ValidationProblemDetails serialization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.NewtonsoftJson/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic override bool CanConvert(Type objectType)\n\npublic override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)\n\npublic override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)\n```\n\n----------------------------------------\n\nTITLE: StreamAsChannelAsync Extension Methods for SignalR HubConnection\nDESCRIPTION: Collection of overloaded extension methods for streaming data from a SignalR hub as a ChannelReader. Supports varying numbers of arguments (0-10) and returns a typed ChannelReader.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.StreamAsChannelCoreAsync<TResult>(this Microsoft.AspNetCore.SignalR.Client.HubConnection! hubConnection, string! methodName, object?[]! args, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<System.Threading.Channels.ChannelReader<TResult>!>!\n```\n\n----------------------------------------\n\nTITLE: HTTPS Redirection Middleware Implementation in C#\nDESCRIPTION: Implementation of the HTTPS redirection middleware that automatically redirects HTTP requests to HTTPS. Includes configuration options for port and status code.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpsPolicy/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class HttpsRedirectionMiddleware\n{\n    public HttpsRedirectionMiddleware(RequestDelegate next, IOptions<HttpsRedirectionOptions> options, IConfiguration config, ILoggerFactory loggerFactory);\n    public HttpsRedirectionMiddleware(RequestDelegate next, IOptions<HttpsRedirectionOptions> options, IConfiguration config, ILoggerFactory loggerFactory, IServerAddressesFeature serverAddressesFeature);\n    public Task Invoke(HttpContext context);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocation Attribute in C#\nDESCRIPTION: Defines a sealed attribute class for method interception with version and data parameters. Used for code generation tracking.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Routes and Building Filter Delegates in C#\nDESCRIPTION: This snippet contains methods for mapping routes and building filter delegates. It includes the Cast<T> method for delegate casting and the BuildFilterDelegate method for constructing endpoint filter delegates.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: ASCII Art Warning Box\nDESCRIPTION: Decorative ASCII art box containing a warning symbol or pattern to visually emphasize the importance of not modifying the directory contents.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/eng/common/README.md#2025-04-08_snippet_0\n\nLANGUAGE: ascii-art\nCODE:\n```\n                uuuuuuuuuuuuuuuuuuuu\n              u\" uuuuuuuuuuuuuuuuuu \"u\n            u\" u$$$$$$$$$$$$$$$$$$$$u \"u\n          u\" u$$$$$$$$$$$$$$$$$$$$$$$$u \"u\n        u\" u$$$$$$$$$$$$$$$$$$$$$$$$$$$$u \"u\n      u\" u$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$u \"u\n    u\" u$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$u \"u\n    $ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $\n    $ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $\n    $ $$$\" ... \"$...  ...$\" ... \"$$$  ... \"$$$ $\n    $ $$$u `\"$$$$$$$  $$$  $$$$$  $$  $$$  $$$ $\n    $ $$$$$$uu \"$$$$  $$$  $$$$$  $$  \"\"\" u$$$ $\n    $ $$$\"\"$$$  $$$$  $$$u \"$$$\" u$$  $$$$$$$$ $\n    $ $$$$....,$$$$$..$$$$$....,$$$$..$$$$$$$$ $\n    $ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $\n    \"u \"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\" u\"\n      \"u \"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\" u\"\n        \"u \"$$$$$$$$$$$$$$$$$$$$$$$$$$$$\" u\"\n          \"u \"$$$$$$$$$$$$$$$$$$$$$$$$\" u\"\n            \"u \"$$$$$$$$$$$$$$$$$$$$\" u\"\n              \"u \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" u\"\n                \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Extension Methods for MVC Builder Data Annotations\nDESCRIPTION: Extension methods for adding data annotation and localization support to MVC builder configuration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.DataAnnotations/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.MvcDataAnnotationsMvcBuilderExtensions.AddDataAnnotationsLocalization(this Microsoft.Extensions.DependencyInjection.IMvcBuilder! builder) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\n\nstatic Microsoft.Extensions.DependencyInjection.MvcDataAnnotationsMvcBuilderExtensions.AddDataAnnotationsLocalization(this Microsoft.Extensions.DependencyInjection.IMvcBuilder! builder, System.Action<Microsoft.AspNetCore.Mvc.DataAnnotations.MvcDataAnnotationsLocalizationOptions!>? setupAction) -> Microsoft.Extensions.DependencyInjection.IMvcBuilder!\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft.Authentication.WebAssembly.Msal Package via .NET CLI\nDESCRIPTION: This command installs the Microsoft.Authentication.WebAssembly.Msal NuGet package to your project using the .NET CLI. This package is required to implement MSAL authentication in Blazor WebAssembly applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Components/WebAssembly/Authentication.Msal/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.Authentication.WebAssembly.Msal\n```\n\n----------------------------------------\n\nTITLE: Configuring MVC Services with Authorization and Custom Formatter\nDESCRIPTION: Configures MVC Core services with authorization support and adds a custom media type mapping for JSON format.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Tools/Microsoft.dotnet-openapi/test/TestContent/Startup.cs.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nservices\n    .AddMvcCore()\n    .AddAuthorization()\n    .AddFormatterMappings(m => m.SetMediaTypeMappingForFormat(\"js\", new MediaTypeHeaderValue(\"application/json\")));\n```\n\n----------------------------------------\n\nTITLE: Middleware Interface Definition\nDESCRIPTION: Core interface for implementing middleware components in ASP.NET Core HTTP request pipeline\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.IMiddleware.InvokeAsync(Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Http.RequestDelegate! next) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTPS Redirection Options in ASP.NET Core\nDESCRIPTION: This snippet defines a class for HTTPS redirection options in ASP.NET Core. It includes properties for the HTTPS port and status code for redirection, with default values set.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/SqlServer/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Microsoft.AspNetCore.HttpsPolicy;\n\n/// <summary>\n/// Options for the HTTPS Redirection Middleware.\n/// </summary>\npublic class HttpsRedirectionOptions\n{\n    /// <summary>\n    /// The HTTPS port to use for redirect URIs. A null value will use the ambient\n    /// HTTPS port configured on the server, if any.\n    /// </summary>\n    public int? HttpsPort { get; set; }\n\n    /// <summary>\n    /// The status code used for the redirect response. The default is 307.\n    /// </summary>\n    public int RedirectStatusCode { get; set; } = StatusCodes.Status307TemporaryRedirect;\n\n    /// <summary>\n    /// Indicates if the middleware should ignore paths on loopback hosts.\n    /// </summary>\n    /// <remarks>\n    /// When this option is set to 'true', requests using a loopback host (localhost)\n    /// are not redirected to HTTPS.\n    /// Default value: false.\n    /// </remarks>\n    public bool ExcludeLoopbackHosts { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Antiforgery Token Constructor\nDESCRIPTION: Constructor for creating an antiforgery token set with request token, cookie token, form field name, and header name parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Antiforgery/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Antiforgery.AntiforgeryTokenSet.AntiforgeryTokenSet(string? requestToken, string? cookieToken, string! formFieldName, string? headerName) -> void\n```\n\n----------------------------------------\n\nTITLE: HTTP Response Generation Handler\nDESCRIPTION: Executes different types of HTTP responses based on the return type - handles IResult, string, and JSON responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitSource_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing StackExchangeRedis Cache Package via .NET CLI\nDESCRIPTION: Command to add the Microsoft.Extensions.Caching.StackExchangeRedis package to a .NET project using the dotnet CLI.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/PACKAGE.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Microsoft.Extensions.Caching.StackExchangeRedis\n```\n\n----------------------------------------\n\nTITLE: HttpConnectionFeature in ASP.NET Core\nDESCRIPTION: Feature providing connection information for HTTP requests in ASP.NET Core. It handles connection properties like connection ID, remote and local IP addresses, and port numbers for client-server communication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Features.HttpConnectionFeature\nMicrosoft.AspNetCore.Http.Features.HttpConnectionFeature.ConnectionId.get -> string!\nMicrosoft.AspNetCore.Http.Features.HttpConnectionFeature.ConnectionId.set -> void\nMicrosoft.AspNetCore.Http.Features.HttpConnectionFeature.HttpConnectionFeature() -> void\nMicrosoft.AspNetCore.Http.Features.HttpConnectionFeature.LocalIpAddress.get -> System.Net.IPAddress?\nMicrosoft.AspNetCore.Http.Features.HttpConnectionFeature.LocalIpAddress.set -> void\nMicrosoft.AspNetCore.Http.Features.HttpConnectionFeature.LocalPort.get -> int\nMicrosoft.AspNetCore.Http.Features.HttpConnectionFeature.LocalPort.set -> void\nMicrosoft.AspNetCore.Http.Features.HttpConnectionFeature.RemoteIpAddress.get -> System.Net.IPAddress?\nMicrosoft.AspNetCore.Http.Features.HttpConnectionFeature.RemoteIpAddress.set -> void\nMicrosoft.AspNetCore.Http.Features.HttpConnectionFeature.RemotePort.get -> int\nMicrosoft.AspNetCore.Http.Features.HttpConnectionFeature.RemotePort.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining Content Type Constants in ASP.NET Core\nDESCRIPTION: This generated code defines constants for common content types used in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Page Route Transformer Convention in ASP.NET Core\nDESCRIPTION: Virtual method that determines whether a route transformer should be applied to a page route model. This allows for conditional application of route transformations based on the page route model properties.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.ApplicationModels.PageRouteTransformerConvention.ShouldApply(Microsoft.AspNetCore.Mvc.ApplicationModels.PageRouteModel! action) -> bool\n```\n\n----------------------------------------\n\nTITLE: Sending File Asynchronously in ASP.NET Core\nDESCRIPTION: This static method provides a fallback mechanism for sending files asynchronously when the primary method is not available.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.SendFileFallback.SendFileAsync(System.IO.Stream! destination, string! filePath, long offset, long? count, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: HeaderDictionary Extension Methods for ASP.NET Core\nDESCRIPTION: Extension methods for manipulating HTTP headers in ASP.NET Core. Provides functionality for appending, getting, and setting comma-separated values in headers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.HeaderDictionaryExtensions.Append(this Microsoft.AspNetCore.Http.IHeaderDictionary! headers, string! key, Microsoft.Extensions.Primitives.StringValues value) -> void\nstatic Microsoft.AspNetCore.Http.HeaderDictionaryExtensions.AppendCommaSeparatedValues(this Microsoft.AspNetCore.Http.IHeaderDictionary! headers, string! key, params string![]! values) -> void\nstatic Microsoft.AspNetCore.Http.HeaderDictionaryExtensions.GetCommaSeparatedValues(this Microsoft.AspNetCore.Http.IHeaderDictionary! headers, string! key) -> string![]!\nstatic Microsoft.AspNetCore.Http.HeaderDictionaryExtensions.SetCommaSeparatedValues(this Microsoft.AspNetCore.Http.IHeaderDictionary! headers, string! key, params string![]! values) -> void\n```\n\n----------------------------------------\n\nTITLE: Model Validation Classes\nDESCRIPTION: Defines core classes for model validation including ModelValidationResult, ValidationEntry, and ValidationStateEntry. These classes handle validation state management and results in ASP.NET Core MVC.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class ModelValidationResult\n{\n    public string MemberName { get; }\n    public string Message { get; }\n    public ModelValidationResult(string? memberName, string? message);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ResourceNamesCache Class in C#\nDESCRIPTION: Defines a class for caching resource names with a GetOrAdd method.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Localization/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Localization.ResourceNamesCache.GetOrAdd(string! name, System.Func<string!, System.Collections.Generic.IList<string!>?>! valueFactory) -> System.Collections.Generic.IList<string!>?\nMicrosoft.Extensions.Localization.ResourceNamesCache.ResourceNamesCache() -> void\n```\n\n----------------------------------------\n\nTITLE: Defining JwtBearerEvents Methods for Authentication Lifecycle in C#\nDESCRIPTION: These virtual methods define the events that can be handled during the JWT Bearer authentication process, including authentication failures, challenges, forbidden responses, message reception, and token validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/JwtBearer/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerEvents.AuthenticationFailed(Microsoft.AspNetCore.Authentication.JwtBearer.AuthenticationFailedContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerEvents.Challenge(Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerChallengeContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerEvents.Forbidden(Microsoft.AspNetCore.Authentication.JwtBearer.ForbiddenContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerEvents.MessageReceived(Microsoft.AspNetCore.Authentication.JwtBearer.MessageReceivedContext! context) -> System.Threading.Tasks.Task!\nvirtual Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerEvents.TokenValidated(Microsoft.AspNetCore.Authentication.JwtBearer.TokenValidatedContext! context) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Adding OpenAPI Operation Transformer in ASP.NET Core\nDESCRIPTION: Extension method allowing registration of a custom OpenAPI operation transformer. The transformer takes an OpenApiOperation, a context object, and a cancellation token, and returns a Task.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.OpenApiEndpointConventionBuilderExtensions.AddOpenApiOperationTransformer<TBuilder>(this TBuilder builder, System.Func<Microsoft.OpenApi.Models.OpenApiOperation!, Microsoft.AspNetCore.OpenApi.OpenApiOperationTransformerContext!, System.Threading.CancellationToken, System.Threading.Tasks.Task!>! transformer) -> TBuilder\n```\n\n----------------------------------------\n\nTITLE: Empty Form and Query Collections in ASP.NET Core\nDESCRIPTION: These static readonly properties provide empty instances of FormCollection and QueryCollection for use in HTTP-related operations.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Microsoft.AspNetCore.Http.FormCollection.Empty -> Microsoft.AspNetCore.Http.FormCollection!\nstatic readonly Microsoft.AspNetCore.Http.QueryCollection.Empty -> Microsoft.AspNetCore.Http.QueryCollection!\n```\n\n----------------------------------------\n\nTITLE: Running ResultsOfTGenerator Tool for Results<T> Union Types in ASP.NET Core\nDESCRIPTION: Command to run the ResultsOfTGenerator tool in the src\\Http\\Http.Results\\tools\\ResultsOfTGenerator directory. This tool generates the Results<TResult1, TResult2, TResultN> union types used in Minimal APIs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/README.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet run\n```\n\n----------------------------------------\n\nTITLE: JSON Response Writing Helper\nDESCRIPTION: Handles writing different types of responses including IResult, string, and JSON objects with proper type handling and polymorphism support.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_JsonBodyOrService_HandlesBothJsonAndService.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: User Claims Management Interface\nDESCRIPTION: Interface for managing user claims including adding, removing, replacing, and retrieving claims for users.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.IUserClaimStore<TUser>.AddClaimsAsync(TUser! user, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim!>! claims, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Identity.IUserClaimStore<TUser>.GetClaimsAsync(TUser! user, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IList<System.Security.Claims.Claim!>!>!\n```\n\n----------------------------------------\n\nTITLE: WebApplicationFactory Generic Class Implementation\nDESCRIPTION: Core factory class for creating and configuring test instances of web applications with customizable client options and host building\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Testing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.Testing.WebApplicationFactory<TEntryPoint>.CreateClient() -> System.Net.Http.HttpClient!\nMicrosoft.AspNetCore.Mvc.Testing.WebApplicationFactory<TEntryPoint>.CreateDefaultClient(System.Uri! baseAddress, params System.Net.Http.DelegatingHandler![]! handlers) -> System.Net.Http.HttpClient!\nvirtual Microsoft.AspNetCore.Mvc.Testing.WebApplicationFactory<TEntryPoint>.CreateHost(Microsoft.Extensions.Hosting.IHostBuilder! builder) -> Microsoft.Extensions.Hosting.IHost!\n```\n\n----------------------------------------\n\nTITLE: Running SignalR Tests with Iteration\nDESCRIPTION: Command for running tests in iteration mode to skip optional build steps for faster development cycles.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/JSFunctionalTests.md#2025-04-08_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run test:inner\n```\n\n----------------------------------------\n\nTITLE: JSON Response Handler Implementation\nDESCRIPTION: Handles writing different types of responses including IResult, string, and JSON objects to the HTTP response.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running BaselineGenerator Auto-Update Command\nDESCRIPTION: Command to automatically update baseline files by finding latest patch versions of packages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/eng/tools/BaselineGenerator/README.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet run --update\n```\n\n----------------------------------------\n\nTITLE: View Component Rendering Methods in PageBase Class\nDESCRIPTION: Virtual methods for rendering view components within Razor Pages. These methods allow invoking view components by name or type with optional arguments.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.ViewComponent(string! componentName) -> Microsoft.AspNetCore.Mvc.ViewComponentResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.ViewComponent(string! componentName, object? arguments) -> Microsoft.AspNetCore.Mvc.ViewComponentResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.ViewComponent(System.Type! componentType) -> Microsoft.AspNetCore.Mvc.ViewComponentResult!\nvirtual Microsoft.AspNetCore.Mvc.RazorPages.PageBase.ViewComponent(System.Type! componentType, object? arguments) -> Microsoft.AspNetCore.Mvc.ViewComponentResult!\n```\n\n----------------------------------------\n\nTITLE: Building JavaScript Library for Testing in ASP.NET Core\nDESCRIPTION: Command to build the JavaScript libraries before running tests. This step is necessary after making changes to the codebase.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/JSUnitTests.md#2025-04-08_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n> npm run build\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants Definition in ASP.NET Core\nDESCRIPTION: Defines constants for common content types used in HTTP communication including JSON, plaintext, and form data formats.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleComplexTypeParam_StringReturn.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SqlServerCacheOptions Class in C#\nDESCRIPTION: Declares the SqlServerCacheOptions class with properties for configuring the SQL Server cache. It includes settings for connection string, schema name, table name, expiration intervals, and system clock.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/SqlServer/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCacheOptions\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCacheOptions.ConnectionString.get -> string?\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCacheOptions.ConnectionString.set -> void\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCacheOptions.DefaultSlidingExpiration.get -> System.TimeSpan\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCacheOptions.DefaultSlidingExpiration.set -> void\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCacheOptions.ExpiredItemsDeletionInterval.get -> System.TimeSpan?\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCacheOptions.ExpiredItemsDeletionInterval.set -> void\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCacheOptions.SchemaName.get -> string?\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCacheOptions.SchemaName.set -> void\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCacheOptions.SqlServerCacheOptions() -> void\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCacheOptions.SystemClock.get -> Microsoft.Extensions.Internal.ISystemClock!\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCacheOptions.SystemClock.set -> void\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCacheOptions.TableName.get -> string?\nMicrosoft.Extensions.Caching.SqlServer.SqlServerCacheOptions.TableName.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining MessageReceivedContext Class for JWT Bearer Authentication in C#\nDESCRIPTION: This class represents the context for when a JWT token is received during authentication. It includes properties for the token and a constructor that initializes the context with HTTP context, authentication scheme, and options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/JwtBearer/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.JwtBearer.MessageReceivedContext.MessageReceivedContext(Microsoft.AspNetCore.Http.HttpContext! context, Microsoft.AspNetCore.Authentication.AuthenticationScheme! scheme, Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerOptions! options) -> void\nMicrosoft.AspNetCore.Authentication.JwtBearer.MessageReceivedContext.Token.get -> string?\nMicrosoft.AspNetCore.Authentication.JwtBearer.MessageReceivedContext.Token.set -> void\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected JSON Content Type in ASP.NET Core\nDESCRIPTION: Handles cases where a JSON content type was expected but a different or no content type was provided. When throwing, returns a 415 Unsupported Media Type status code. Either throws an exception or logs the error.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndGet_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedJsonContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Content Type\nDESCRIPTION: Validates form media type in HTTP requests and throws BadHttpRequestException if invalid. Includes logging functionality when enabled.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleComplexTypeParam_StringReturn.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Visual Studio Workflow for ASP.NET Core Projects\nDESCRIPTION: Commands to restore dependencies, build a specific project (Http), and launch Visual Studio for that project.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/BuildFromSource.md#2025-04-08_snippet_4\n\nLANGUAGE: powershell\nCODE:\n```\n./restore.cmd\n\ncd src/Http\n./build.cmd\n./startvs.cmd\n```\n\n----------------------------------------\n\nTITLE: Route Handler Mapping Implementation in C#\nDESCRIPTION: Internal implementation for mapping route handlers with support for metadata population and request delegate creation. Includes helper methods for delegate casting and filter building.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_SingleEnumParam_StringReturn.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Cast Method for Delegate Type Conversion\nDESCRIPTION: A utility method for safely casting Delegate objects to specific delegate types using generic type parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_StringArrayParam.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Failure Handler\nDESCRIPTION: Handles general parameter binding failures with source value information. Implements both exception throwing and logging capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_TakesCustomMetadataEmitter_Has_Metadata.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =\n    LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, \"ParameterBindingFailed\"), \"Failed to bind parameter \\\"{ParameterType} {ParameterName}\\\" from \\\"{SourceValue}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: FormOptions Configuration in ASP.NET Core\nDESCRIPTION: Configuration options for form data processing in ASP.NET Core. It contains settings that control form data parsing, including memory limits, buffer sizes, and validation constraints for multipart forms and key-value pairs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Features.FormOptions\nMicrosoft.AspNetCore.Http.Features.FormOptions.BufferBody.get -> bool\nMicrosoft.AspNetCore.Http.Features.FormOptions.BufferBody.set -> void\nMicrosoft.AspNetCore.Http.Features.FormOptions.BufferBodyLengthLimit.get -> long\nMicrosoft.AspNetCore.Http.Features.FormOptions.BufferBodyLengthLimit.set -> void\nMicrosoft.AspNetCore.Http.Features.FormOptions.FormOptions() -> void\nMicrosoft.AspNetCore.Http.Features.FormOptions.KeyLengthLimit.get -> int\nMicrosoft.AspNetCore.Http.Features.FormOptions.KeyLengthLimit.set -> void\nMicrosoft.AspNetCore.Http.Features.FormOptions.MemoryBufferThreshold.get -> int\nMicrosoft.AspNetCore.Http.Features.FormOptions.MemoryBufferThreshold.set -> void\nMicrosoft.AspNetCore.Http.Features.FormOptions.MultipartBodyLengthLimit.get -> long\nMicrosoft.AspNetCore.Http.Features.FormOptions.MultipartBodyLengthLimit.set -> void\nMicrosoft.AspNetCore.Http.Features.FormOptions.MultipartBoundaryLengthLimit.get -> int\nMicrosoft.AspNetCore.Http.Features.FormOptions.MultipartBoundaryLengthLimit.set -> void\nMicrosoft.AspNetCore.Http.Features.FormOptions.MultipartHeadersCountLimit.get -> int\nMicrosoft.AspNetCore.Http.Features.FormOptions.MultipartHeadersCountLimit.set -> void\nMicrosoft.AspNetCore.Http.Features.FormOptions.MultipartHeadersLengthLimit.get -> int\nMicrosoft.AspNetCore.Http.Features.FormOptions.MultipartHeadersLengthLimit.set -> void\nMicrosoft.AspNetCore.Http.Features.FormOptions.ValueCountLimit.get -> int\nMicrosoft.AspNetCore.Http.Features.FormOptions.ValueCountLimit.set -> void\nMicrosoft.AspNetCore.Http.Features.FormOptions.ValueLengthLimit.get -> int\nMicrosoft.AspNetCore.Http.Features.FormOptions.ValueLengthLimit.set -> void\n```\n\n----------------------------------------\n\nTITLE: Decoding Ack Message in MessagePack\nDESCRIPTION: Shows the structure and decoding of an Ack message in the SignalR MessagePack protocol. It includes message type and sequence ID.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_15\n\nLANGUAGE: MessagePack\nCODE:\n```\n0x92 0x08 0xcc 0x24\n```\n\n----------------------------------------\n\nTITLE: Configuring Middleware Pipeline for ASP.NET Core Application in C#\nDESCRIPTION: This code snippet demonstrates how to configure the middleware pipeline for an ASP.NET Core application. It sets up middleware for routing, authorization, and endpoints.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\napp.UseRouting();\n\napp.UseAuthorization();\n\napp.UseEndpoints(endpoints =>\n{\n    endpoints.MapControllers();\n    endpoints.MapControllerRoute(\n        name: \"default\",\n        pattern: \"{controller=Home}/{action=Index}/{id?}\");\n    endpoints.MapRazorPages();\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Authorization Policies in C#\nDESCRIPTION: These methods on the AuthorizationBuilder class allow for adding and configuring various types of authorization policies, including default policies, fallback policies, and named policies. They provide flexibility in defining authorization rules for an application.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authorization.AuthorizationBuilder.AddDefaultPolicy(string! name, Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy) -> Microsoft.AspNetCore.Authorization.AuthorizationBuilder!\nvirtual Microsoft.AspNetCore.Authorization.AuthorizationBuilder.AddFallbackPolicy(string! name, Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy) -> Microsoft.AspNetCore.Authorization.AuthorizationBuilder!\nvirtual Microsoft.AspNetCore.Authorization.AuthorizationBuilder.AddPolicy(string! name, Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy) -> Microsoft.AspNetCore.Authorization.AuthorizationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Running SQL Cache Tool Help Command\nDESCRIPTION: Demonstrates how to access the help documentation for the dotnet-sql-cache tool using the command line interface. This command provides information about the tool's usage and available options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Tools/dotnet-sql-cache/README.md#2025-04-08_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet sql-cache --help\n```\n\n----------------------------------------\n\nTITLE: Extending Authorization Services in C#\nDESCRIPTION: This snippet shows extension methods for the IAuthorizationService interface, providing various overloads for authorizing users against policies or requirements.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Authorization.AuthorizationServiceExtensions.AuthorizeAsync(this Microsoft.AspNetCore.Authorization.IAuthorizationService! service, System.Security.Claims.ClaimsPrincipal! user, Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authorization.AuthorizationResult!>!\nstatic Microsoft.AspNetCore.Authorization.AuthorizationServiceExtensions.AuthorizeAsync(this Microsoft.AspNetCore.Authorization.IAuthorizationService! service, System.Security.Claims.ClaimsPrincipal! user, object? resource, Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authorization.AuthorizationResult!>!\nstatic Microsoft.AspNetCore.Authorization.AuthorizationServiceExtensions.AuthorizeAsync(this Microsoft.AspNetCore.Authorization.IAuthorizationService! service, System.Security.Claims.ClaimsPrincipal! user, object? resource, Microsoft.AspNetCore.Authorization.IAuthorizationRequirement! requirement) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authorization.AuthorizationResult!>!\nstatic Microsoft.AspNetCore.Authorization.AuthorizationServiceExtensions.AuthorizeAsync(this Microsoft.AspNetCore.Authorization.IAuthorizationService! service, System.Security.Claims.ClaimsPrincipal! user, string! policyName) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authorization.AuthorizationResult!>!\n```\n\n----------------------------------------\n\nTITLE: IDeveloperPageExceptionFilter Interface Definition\nDESCRIPTION: Interface for implementing custom exception filters in developer error pages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Diagnostics.IDeveloperPageExceptionFilter.HandleExceptionAsync(Microsoft.AspNetCore.Diagnostics.ErrorContext! errorContext, System.Func<Microsoft.AspNetCore.Diagnostics.ErrorContext!, System.Threading.Tasks.Task!>! next) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Defining AzureAppServicesHostingStartup Class in C#\nDESCRIPTION: Declares the AzureAppServicesHostingStartup class with a constructor and Configure method. This class is used to set up Azure App Services integration for ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Azure/AzureAppServices.HostingStartup/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\nMicrosoft.AspNetCore.AzureAppServices.HostingStartup.AzureAppServicesHostingStartup\nMicrosoft.AspNetCore.AzureAppServices.HostingStartup.AzureAppServicesHostingStartup.AzureAppServicesHostingStartup() -> void\nMicrosoft.AspNetCore.AzureAppServices.HostingStartup.AzureAppServicesHostingStartup.Configure(Microsoft.AspNetCore.Hosting.IWebHostBuilder! builder) -> void\n```\n\n----------------------------------------\n\nTITLE: Saving Submodule Update in Parent Repository\nDESCRIPTION: Series of commands to update a submodule (Kestrel in this example) and commit the change to the parent repository.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/Submodules.md#2025-04-08_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngit submodule update --remote modules/KestrelHttpServer/\ngit add modules/KestrelhttpServer/\ngit commit -m \"Update Kestrel to latest version\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Request Body Buffering in ASP.NET Core\nDESCRIPTION: These extension methods enable buffering of the request body with various options for buffer threshold and limit.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Http.HttpRequestRewindExtensions.EnableBuffering(this Microsoft.AspNetCore.Http.HttpRequest! request) -> void\nstatic Microsoft.AspNetCore.Http.HttpRequestRewindExtensions.EnableBuffering(this Microsoft.AspNetCore.Http.HttpRequest! request, int bufferThreshold) -> void\nstatic Microsoft.AspNetCore.Http.HttpRequestRewindExtensions.EnableBuffering(this Microsoft.AspNetCore.Http.HttpRequest! request, int bufferThreshold, long bufferLimit) -> void\nstatic Microsoft.AspNetCore.Http.HttpRequestRewindExtensions.EnableBuffering(this Microsoft.AspNetCore.Http.HttpRequest! request, long bufferLimit) -> void\n```\n\n----------------------------------------\n\nTITLE: Health Check Options Configuration Class\nDESCRIPTION: Configuration options class for customizing health check behavior including caching, response writing, and status code mapping.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HealthChecks/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class HealthCheckOptions\n{\n    public bool AllowCachingResponses { get; set; }\n    public Func<HealthCheckRegistration, bool>? Predicate { get; set; }\n    public Func<HttpContext, HealthReport, Task> ResponseWriter { get; set; }\n    public IDictionary<HealthStatus, int> ResultStatusCodes { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending HandshakeRequest in JSON for SignalR Protocol\nDESCRIPTION: Example of a HandshakeRequest message sent by the client to agree on the message format. It specifies the protocol name and version to be used for the connection.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"protocol\": \"messagepack\",\n    \"version\": 1\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Message for Required Parameter Not Provided in C#\nDESCRIPTION: This snippet defines a LoggerMessage for logging when a required parameter is not provided. It uses LogLevel.Debug and creates an EventId for the message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n    LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n```\n\n----------------------------------------\n\nTITLE: Connection Handler and Multiplexed Connection Abstractions in C#\nDESCRIPTION: Defines abstract methods for connection handling and multiplexed connections support, allowing for connection acceptance and establishing new connections with feature collections.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Connections.Abstractions/src/PublicAPI/net10.0/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nabstract Microsoft.AspNetCore.Connections.ConnectionHandler.OnConnectedAsync(Microsoft.AspNetCore.Connections.ConnectionContext! connection) -> System.Threading.Tasks.Task!\nabstract Microsoft.AspNetCore.Connections.MultiplexedConnectionContext.AcceptAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Connections.ConnectionContext?>\nabstract Microsoft.AspNetCore.Connections.MultiplexedConnectionContext.ConnectAsync(Microsoft.AspNetCore.Http.Features.IFeatureCollection? features = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Connections.ConnectionContext!>\n```\n\n----------------------------------------\n\nTITLE: Creating Request Delegate for ASP.NET Core Endpoint\nDESCRIPTION: This snippet generates a request delegate for an ASP.NET Core endpoint, handling parameter resolution, JSON deserialization, and response writing. It includes logic for endpoint filtering and error handling.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/VerifyAsParametersBaseline.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nRequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n{\n    Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n    Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n    Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n    Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n    var handler = Cast(del, global::System.String (global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithImplicitFromBody arg0) => throw null!);\n    EndpointFilterDelegate? filteredInvocation = null;\n    var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n    var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n    var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n    var jsonSerializerOptions = jsonOptions.SerializerOptions;\n    jsonSerializerOptions.MakeReadOnly();\n    var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n    var serviceProviderIsService = serviceProvider?.GetService<IServiceProviderIsService>();\n    var Todo_JsonBodyOrServiceResolver = ResolveJsonBodyOrService<global::Microsoft.AspNetCore.Http.Generators.Tests.TodoStruct>(logOrThrowExceptionHelper, \"TodoStruct\", \"Todo\", jsonSerializerOptions, serviceProviderIsService);\n\n    if (options.EndpointBuilder.FilterFactories.Count > 0)\n    {\n        filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n        {\n            if (ic.HttpContext.Response.StatusCode == 400)\n            {\n                return ValueTask.FromResult<object?>(Results.Empty);\n            }\n            return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithImplicitFromBody>(0)!));\n        },\n        options.EndpointBuilder,\n        handler.Method);\n    }\n\n    async Task RequestHandler(HttpContext httpContext)\n    {\n        var wasParamCheckFailure = false;\n        var HttpContext_local = httpContext;\n        var Todo_resolveJsonBodyOrServiceResult = await Todo_JsonBodyOrServiceResolver(httpContext, false);\n        if (!Todo_resolveJsonBodyOrServiceResult.Item1)\n        {\n            return;\n        }\n        var Todo_local = Todo_resolveJsonBodyOrServiceResult.Item2!;\n\n        var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithImplicitFromBody(HttpContext_local, Todo_local);\n\n        if (wasParamCheckFailure)\n        {\n            httpContext.Response.StatusCode = 400;\n            return;\n        }\n        var result = handler(args_local);\n        if (result is string)\n        {\n            httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n        }\n        else\n        {\n            httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n        }\n        await httpContext.Response.WriteAsync(result);\n    }\n\n    async Task RequestHandlerFiltered(HttpContext httpContext)\n    {\n        var wasParamCheckFailure = false;\n        var HttpContext_local = httpContext;\n        var Todo_resolveJsonBodyOrServiceResult = await Todo_JsonBodyOrServiceResolver(httpContext, false);\n        if (!Todo_resolveJsonBodyOrServiceResult.Item1)\n        {\n            return;\n        }\n        var Todo_local = Todo_resolveJsonBodyOrServiceResult.Item2!;\n\n        var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithImplicitFromBody(HttpContext_local, Todo_local);\n\n        if (wasParamCheckFailure)\n        {\n            httpContext.Response.StatusCode = 400;\n        }\n        var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithImplicitFromBody>(httpContext, args_local));\n        if (result is not null)\n        {\n            await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n        }\n    }\n\n    RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\n    var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\n    return new RequestDelegateResult(targetDelegate, metadata);\n};\n```\n\n----------------------------------------\n\nTITLE: LinkGenerator Endpoint Name Extensions for Path and URI Generation in ASP.NET Core\nDESCRIPTION: Extension methods for Microsoft.AspNetCore.Routing.LinkGenerator that generate paths and URIs using endpoint names. These methods provide various overloads to accommodate different parameter combinations and contexts.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.LinkGeneratorEndpointNameAddressExtensions.GetPathByName(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, string! endpointName, object? values, Microsoft.AspNetCore.Http.PathString pathBase = default(Microsoft.AspNetCore.Http.PathString), Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.LinkGeneratorEndpointNameAddressExtensions.GetUriByName(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, Microsoft.AspNetCore.Http.HttpContext! httpContext, string! endpointName, Microsoft.AspNetCore.Routing.RouteValueDictionary? values = null, string? scheme = null, Microsoft.AspNetCore.Http.HostString? host = null, Microsoft.AspNetCore.Http.PathString? pathBase = null, Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.LinkGeneratorEndpointNameAddressExtensions.GetUriByName(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, Microsoft.AspNetCore.Http.HttpContext! httpContext, string! endpointName, object? values, string? scheme = null, Microsoft.AspNetCore.Http.HostString? host = null, Microsoft.AspNetCore.Http.PathString? pathBase = null, Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.LinkGeneratorEndpointNameAddressExtensions.GetUriByName(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, string! endpointName, Microsoft.AspNetCore.Routing.RouteValueDictionary! values, string! scheme, Microsoft.AspNetCore.Http.HostString host, Microsoft.AspNetCore.Http.PathString pathBase = default(Microsoft.AspNetCore.Http.PathString), Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.LinkGeneratorEndpointNameAddressExtensions.GetUriByName(this Microsoft.AspNetCore.Routing.LinkGenerator! generator, string! endpointName, object? values, string! scheme, Microsoft.AspNetCore.Http.HostString host, Microsoft.AspNetCore.Http.PathString pathBase = default(Microsoft.AspNetCore.Http.PathString), Microsoft.AspNetCore.Http.FragmentString fragment = default(Microsoft.AspNetCore.Http.FragmentString), Microsoft.AspNetCore.Routing.LinkOptions? options = null) -> string?\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata Implementation for ASP.NET Core\nDESCRIPTION: Implements IParameterBindingMetadata interface to store parameter binding information. It tracks parameter name, binding capabilities (TryParse, BindAsync), and whether parameters are optional for request processing.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\n%GENERATEDCODEATTRIBUTE%\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Problem Details Service Interface\nDESCRIPTION: Interface for services that handle writing problem details responses in HTTP endpoints\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.IProblemDetailsService.WriteAsync(Microsoft.AspNetCore.Http.ProblemDetailsContext! context) -> System.Threading.Tasks.ValueTask\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Implicit Body in ASP.NET Core (C#)\nDESCRIPTION: This method handles cases where an implicit body is expected but not provided. It can throw an exception or log the error based on configuration. It takes the parameter name as input.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Post_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic void ImplicitBodyNotProvided(string parameterName)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Implicit body inferred for parameter \\\"{0}\\\" but no body was provided. Did you mean to use a Service instead?\", parameterName);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _implicitBodyNotProvided(_rdgLogger, parameterName, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Parameter Binding Metadata in ASP.NET Core\nDESCRIPTION: Defines a class for storing parameter binding metadata. It includes information about the parameter name, type, and binding capabilities.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class ParameterBindingMetadata: IParameterBindingMetadata\n{\n    internal ParameterBindingMetadata(\n        string name,\n        ParameterInfo parameterInfo,\n        bool hasTryParse = false,\n        bool hasBindAsync = false,\n        bool isOptional = false)\n    {\n        Name = name;\n        ParameterInfo = parameterInfo;\n        HasTryParse = hasTryParse;\n        HasBindAsync = hasBindAsync;\n        IsOptional = isOptional;\n    }\n\n    public string Name { get; }\n\n    public bool HasTryParse { get; }\n\n    public bool HasBindAsync { get; }\n\n    public ParameterInfo ParameterInfo { get; }\n\n    public bool IsOptional { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SqlServerCachingServicesExtensions Class in C#\nDESCRIPTION: Declares the SqlServerCachingServicesExtensions class with an extension method for adding distributed SQL Server caching to the dependency injection container in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/SqlServer/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.DependencyInjection.SqlServerCachingServicesExtensions\nstatic Microsoft.Extensions.DependencyInjection.SqlServerCachingServicesExtensions.AddDistributedSqlServerCache(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.Extensions.Caching.SqlServer.SqlServerCacheOptions!>! setupAction) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Adding Page Conventions in ASP.NET Core Razor Pages\nDESCRIPTION: Extension methods for PageConventionCollection that allow adding various conventions to Razor Pages. These include parameter model conventions, route customization, and authorization rules for pages and folders.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.PageConventionCollectionExtensions.Add(this Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection! conventions, Microsoft.AspNetCore.Mvc.ApplicationModels.IParameterModelBaseConvention! convention) -> Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection!\nstatic Microsoft.Extensions.DependencyInjection.PageConventionCollectionExtensions.AddAreaPageRoute(this Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection! conventions, string! areaName, string! pageName, string! route) -> Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection!\nstatic Microsoft.Extensions.DependencyInjection.PageConventionCollectionExtensions.AddPageRoute(this Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection! conventions, string! pageName, string! route) -> Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection!\n```\n\n----------------------------------------\n\nTITLE: Form Handling Classes in ASP.NET Core\nDESCRIPTION: Implements form data handling functionality including file uploads and form collection management.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic class FormFile {\n    public string ContentDisposition { get; set; }\n    public string ContentType { get; set; }\n    public string FileName { get; }\n    public IHeaderDictionary Headers { get; set; }\n    public long Length { get; }\n    public string Name { get; }\n    \n    public void CopyTo(Stream target);\n    public Task CopyToAsync(Stream target, CancellationToken cancellationToken = default);\n    public Stream OpenReadStream();\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Messages to Clients using SendAsync in ASP.NET Core SignalR\nDESCRIPTION: These methods provide various overloads for sending messages to clients using the SendAsync method. They allow sending up to 10 arguments with different combinations, and include an optional CancellationToken.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/server/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.SignalR.ClientProxyExtensions.SendAsync(this Microsoft.AspNetCore.SignalR.IClientProxy! clientProxy, string! method, object? arg1, object? arg2, object? arg3, object? arg4, object? arg5, object? arg6, object? arg7, object? arg8, object? arg9, object? arg10, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Configuring Filters for Razor Pages in ASP.NET Core\nDESCRIPTION: Extension methods for PageConventionCollection that add filters to Razor Pages. These methods allow developers to add filter metadata or factory functions to create filters for page application models.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.RazorPages/src/PublicAPI.Shipped.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.PageConventionCollectionExtensions.ConfigureFilter(this Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection! conventions, Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata! filter) -> Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection!\nstatic Microsoft.Extensions.DependencyInjection.PageConventionCollectionExtensions.ConfigureFilter(this Microsoft.AspNetCore.Mvc.ApplicationModels.PageConventionCollection! conventions, System.Func<Microsoft.AspNetCore.Mvc.ApplicationModels.PageApplicationModel!, Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata!>! factory) -> Microsoft.AspNetCore.Mvc.ApplicationModels.IPageApplicationModelConvention!\n```\n\n----------------------------------------\n\nTITLE: Concurrency Limiter Configuration Options\nDESCRIPTION: Configuration options for the ConcurrencyLimiter middleware. Defines behavior for request rejection and other middleware settings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ConcurrencyLimiter/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.ConcurrencyLimiter.ConcurrencyLimiterOptions.ConcurrencyLimiterOptions() -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.ConcurrencyLimiter.ConcurrencyLimiterOptions.OnRejected.get -> Microsoft.AspNetCore.Http.RequestDelegate!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.ConcurrencyLimiter.ConcurrencyLimiterOptions.OnRejected.set -> void\n```\n\n----------------------------------------\n\nTITLE: Configuring Queue Policy in ASP.NET Core Concurrency Limiter\nDESCRIPTION: Extension methods to register FIFO queue and LIFO stack policies for the concurrency limiter. These methods allow configuration of maximum concurrent requests and queue limits.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ConcurrencyLimiter/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.QueuePolicyServiceCollectionExtensions.AddQueuePolicy(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.ConcurrencyLimiter.QueuePolicyOptions!>! configure) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.Extensions.DependencyInjection.QueuePolicyServiceCollectionExtensions.AddStackPolicy(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Microsoft.AspNetCore.ConcurrencyLimiter.QueuePolicyOptions!>! configure) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Configuring Static File Options in ASP.NET Core\nDESCRIPTION: This snippet defines a class for static file options in ASP.NET Core. It includes properties for content type provider, default content type, ServeUnknownFileTypes, and OnPrepareResponse.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Caching/SqlServer/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Microsoft.AspNetCore.Builder;\n\n/// <summary>\n/// Options for serving static files\n/// </summary>\npublic class StaticFileOptions : SharedOptionsBase\n{\n    /// <summary>\n    /// Constructs a new instance of <see cref=\"StaticFileOptions\"/>.\n    /// </summary>\n    public StaticFileOptions() : base()\n    { }\n\n    /// <summary>\n    /// Constructs a new instance of <see cref=\"StaticFileOptions\"/> using the specified <see cref=\"SharedOptions\"/>.\n    /// </summary>\n    /// <param name=\"sharedOptions\">The <see cref=\"SharedOptions\"/> to use.</param>\n    public StaticFileOptions(SharedOptions sharedOptions) : base(sharedOptions)\n    { }\n\n    /// <summary>\n    /// Used to map files to content-types.\n    /// </summary>\n    public IContentTypeProvider? ContentTypeProvider { get; set; }\n\n    /// <summary>\n    /// The default content type for a request if the ContentTypeProvider cannot determine one.\n    /// None is provided by default, so the client must determine the format themselves.\n    /// http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7\n    /// </summary>\n    public string? DefaultContentType { get; set; }\n\n    /// <summary>\n    /// If the file is not a recognized content-type should it be served?\n    /// Default: false.\n    /// </summary>\n    public bool ServeUnknownFileTypes { get; set; }\n\n    /// <summary>\n    /// Called after the status code and headers have been set, but before the body has been written.\n    /// This can be used to add or change the response headers.\n    /// </summary>\n    public Action<StaticFileResponseContext>? OnPrepareResponse { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Browser SignalR Connection Setup\nDESCRIPTION: Example of establishing a SignalR connection in a browser environment, including connection building, event handling, and sending messages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/ts/signalr/README.md#2025-04-08_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nlet connection = new signalR.HubConnectionBuilder()\n    .withUrl(\"/chat\")\n    .build();\n\nconnection.on(\"send\", data => {\n    console.log(data);\n});\n\nconnection.start()\n    .then(() => connection.invoke(\"send\", \"Hello\"));\n```\n\n----------------------------------------\n\nTITLE: Configuring JSON Serialization Options for ASP.NET Core\nDESCRIPTION: This code snippet defines extension methods for configuring JSON serialization options in ASP.NET Core. It includes methods for adding custom converters, setting naming policies, and configuring options for both System.Text.Json and Newtonsoft.Json serializers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Server.Abstractions/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Running NPM Build Command\nDESCRIPTION: Command to build node components from the repository root, assuming prerequisites are installed.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/docs/UpdatingMinifiedJsFiles.md#2025-04-08_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Authentication Builder Schema Configuration Methods\nDESCRIPTION: Methods for configuring authentication schemes including policy schemes, remote schemes, and general authentication schemes with various options and handlers.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authentication.AuthenticationBuilder.AddPolicyScheme(string! authenticationScheme, string? displayName, System.Action<Microsoft.AspNetCore.Authentication.PolicySchemeOptions!>! configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n\nvirtual Microsoft.AspNetCore.Authentication.AuthenticationBuilder.AddRemoteScheme<TOptions, THandler>(string! authenticationScheme, string? displayName, System.Action<TOptions!>? configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n\nvirtual Microsoft.AspNetCore.Authentication.AuthenticationBuilder.AddScheme<TOptions, THandler>(string! authenticationScheme, string? displayName, System.Action<TOptions!>? configureOptions) -> Microsoft.AspNetCore.Authentication.AuthenticationBuilder!\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Non-Form Content Type in C#\nDESCRIPTION: This method handles unexpected non-form content types, throws a BadHttpRequestException if required, and logs the event. It uses a predefined logging action for consistent message formatting.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitSource_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: HTTP Response Feature Methods in ASP.NET Core\nDESCRIPTION: These virtual methods provide functionality for checking if a response has started and registering callbacks for response events.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http/src/PublicAPI.Shipped.txt#2025-04-08_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Http.Features.HttpResponseFeature.HasStarted.get -> bool\nvirtual Microsoft.AspNetCore.Http.Features.HttpResponseFeature.OnCompleted(System.Func<object!, System.Threading.Tasks.Task!>! callback, object! state) -> void\nvirtual Microsoft.AspNetCore.Http.Features.HttpResponseFeature.OnStarting(System.Func<object!, System.Threading.Tasks.Task!>! callback, object! state) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining TLS Handshake Callback Classes in C#\nDESCRIPTION: This snippet defines classes for TLS handshake callbacks in Kestrel, including context and options for customizing the TLS handshake process.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext\nMicrosoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.AllowDelayedClientCertificateNegotation.get -> bool\nMicrosoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.AllowDelayedClientCertificateNegotation.set -> void\nMicrosoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.CancellationToken.get -> System.Threading.CancellationToken\nMicrosoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.ClientHelloInfo.get -> System.Net.Security.SslClientHelloInfo\nMicrosoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.Connection.get -> Microsoft.AspNetCore.Connections.ConnectionContext!\nMicrosoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.SslStream.get -> System.Net.Security.SslStream!\nMicrosoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.State.get -> object?\nMicrosoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.TlsHandshakeCallbackContext() -> void\nMicrosoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions\nMicrosoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions.HandshakeTimeout.get -> System.TimeSpan\nMicrosoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions.HandshakeTimeout.set -> void\nMicrosoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions.OnConnection.get -> System.Func<Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext!, System.Threading.Tasks.ValueTask<System.Net.Security.SslServerAuthenticationOptions!>>!\nMicrosoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions.OnConnection.set -> void\nMicrosoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions.OnConnectionState.get -> object?\nMicrosoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions.OnConnectionState.set -> void\nMicrosoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions.TlsHandshakeCallbackOptions() -> void\n```\n\n----------------------------------------\n\nTITLE: Implicit Body Missing Handler\nDESCRIPTION: Handles scenarios where an implicit body parameter is expected but not provided in the request. Includes suggestions for alternative approaches.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_TakesCustomMetadataEmitter_Has_Metadata.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, \"ImplicitBodyNotProvided\"), \"Implicit body inferred for parameter \\\"{ParameterName}\\\" but no body was provided. Did you mean to use a Service instead?\");\n```\n\n----------------------------------------\n\nTITLE: Converting Delegates with Generic Cast Method in C#\nDESCRIPTION: A utility method that casts a Delegate to a specified generic type T where T is constrained to be a Delegate. This helps with type-safe delegate conversion.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static T Cast<T>(Delegate d, T _) where T : Delegate\n{\n    return (T)d;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Context in C# for ASP.NET Core\nDESCRIPTION: This directive enables nullable reference types for the entire project or file. It instructs the compiler to treat reference types as non-nullable by default, enhancing null-safety in the codebase.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Negotiate/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: OpenAPI Todo Schema Definition\nDESCRIPTION: Defines a Todo item schema with required properties for id, title, completion status and creation timestamp. Includes property descriptions and format specifications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/OpenApi/test/Microsoft.AspNetCore.OpenApi.Tests/Integration/snapshots/OpenApi3_1/OpenApiDocumentIntegrationTests.VerifyOpenApiDocument_documentName=responses.verified.txt#2025-04-08_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"Todo\": {\n    \"required\": [\n      \"id\",\n      \"title\",\n      \"completed\",\n      \"createdAt\"\n    ],\n    \"type\": \"object\",\n    \"properties\": {\n      \"id\": {\n        \"type\": \"integer\",\n        \"description\": \"The unique identifier of the to-do item.\",\n        \"format\": \"int32\"\n      },\n      \"title\": {\n        \"type\": \"string\",\n        \"description\": \"The title of the to-do item.\"\n      },\n      \"completed\": {\n        \"type\": \"boolean\",\n        \"description\": \"Indicates whether the to-do item is completed.\"\n      },\n      \"createdAt\": {\n        \"type\": \"string\",\n        \"description\": \"The date and time when the to-do item was created.\",\n        \"format\": \"date-time\"\n      }\n    },\n    \"description\": \"Represents a to-do item.\"\n  }\n```\n\n----------------------------------------\n\nTITLE: Running Tests for JWT Bearer Authentication Project Using PowerShell\nDESCRIPTION: Command to run the tests for the Microsoft.AspNetCore.Authentication.JwtBearer project from the parent security directory using PowerShell with the test flag.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/JwtBearer/src/README.md#2025-04-08_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd -t\n```\n\n----------------------------------------\n\nTITLE: Exception Handling and Logging in ASP.NET Core Request Processing\nDESCRIPTION: This helper class manages logging and throwing exceptions for various scenarios in request processing, such as invalid JSON, parameter binding failures, and content type mismatches.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_NullableStringArrayParam.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    // ... [Additional methods for handling various error scenarios]\n\n    private static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n        LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n\n    public void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n        LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Virtual Methods in ResourceManagerStringLocalizerFactory in C#\nDESCRIPTION: Defines virtual methods for creating and managing resource localizers in the ResourceManagerStringLocalizerFactory class.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Localization/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.Extensions.Localization.ResourceManagerStringLocalizerFactory.CreateResourceManagerStringLocalizer(System.Reflection.Assembly! assembly, string! baseName) -> Microsoft.Extensions.Localization.ResourceManagerStringLocalizer!\nvirtual Microsoft.Extensions.Localization.ResourceManagerStringLocalizerFactory.GetResourceLocationAttribute(System.Reflection.Assembly! assembly) -> Microsoft.Extensions.Localization.ResourceLocationAttribute?\nvirtual Microsoft.Extensions.Localization.ResourceManagerStringLocalizerFactory.GetResourcePrefix(string! baseResourceName, string! baseNamespace) -> string!\nvirtual Microsoft.Extensions.Localization.ResourceManagerStringLocalizerFactory.GetResourcePrefix(string! location, string! baseName, string! resourceLocation) -> string!\nvirtual Microsoft.Extensions.Localization.ResourceManagerStringLocalizerFactory.GetResourcePrefix(System.Reflection.TypeInfo! typeInfo) -> string!\nvirtual Microsoft.Extensions.Localization.ResourceManagerStringLocalizerFactory.GetResourcePrefix(System.Reflection.TypeInfo! typeInfo, string? baseNamespace, string? resourcesRelativePath) -> string!\nvirtual Microsoft.Extensions.Localization.ResourceManagerStringLocalizerFactory.GetRootNamespaceAttribute(System.Reflection.Assembly! assembly) -> Microsoft.Extensions.Localization.RootNamespaceAttribute?\n```\n\n----------------------------------------\n\nTITLE: Combining Authorization Policies in C#\nDESCRIPTION: This snippet shows methods for combining multiple authorization policies. It includes both synchronous and asynchronous versions, allowing for flexible policy creation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Authorization.AuthorizationPolicy.Combine(params Microsoft.AspNetCore.Authorization.AuthorizationPolicy![]! policies) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicy!\nstatic Microsoft.AspNetCore.Authorization.AuthorizationPolicy.Combine(System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.AuthorizationPolicy!>! policies) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicy!\nstatic Microsoft.AspNetCore.Authorization.AuthorizationPolicy.CombineAsync(Microsoft.AspNetCore.Authorization.IAuthorizationPolicyProvider! policyProvider, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.IAuthorizeData!>! authorizeData) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authorization.AuthorizationPolicy?>!\nstatic Microsoft.AspNetCore.Authorization.AuthorizationPolicy.CombineAsync(Microsoft.AspNetCore.Authorization.IAuthorizationPolicyProvider! policyProvider, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.IAuthorizeData!>! authorizeData, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.AuthorizationPolicy!>! policies) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authorization.AuthorizationPolicy?>!\n```\n\n----------------------------------------\n\nTITLE: Writing JSON Response in ASP.NET Core\nDESCRIPTION: Writes a JSON response to the HTTP response. It handles type information and polymorphism, ensuring proper serialization of the response object.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MapPost Route Handler in ASP.NET Core\nDESCRIPTION: Generated extension method implementing POST route handling with JSON body parsing, parameter binding, and response serialization. Includes metadata population and request delegate creation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nfile static class GeneratedRouteBuilderExtensionsCore\n{\n    private static readonly JsonOptions FallbackJsonOptions = new();\n    private static readonly string[] PostVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Post };\n\n    %INTERCEPTSLOCATIONATTRIBUTE%\n    internal static RouteHandlerBuilder MapPost0(\n        this IEndpointRouteBuilder endpoints,\n        [StringSyntax(\"Route\")] string pattern,\n        Delegate handler)\n    {\n        MetadataPopulator populateMetadata = (methodInfo, options) =>\n        {\n            Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n            Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n            options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n            var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n            var serviceProviderIsService = serviceProvider.GetRequiredService<IServiceProviderIsService>();\n            var jsonBodyOrServiceTypeTuples = new (bool, Type)[] {\n                #nullable disable\n                (false, typeof(global::System.String[])),\n                #nullable enable\n            };\n            foreach (var (isOptional, type) in jsonBodyOrServiceTypeTuples)\n            {\n                if (!serviceProviderIsService.IsService(type))\n                {\n                    options.EndpointBuilder.Metadata.Add(new AcceptsMetadata(type: type, isOptional: isOptional, contentTypes: GeneratedMetadataConstants.JsonContentType));\n                    break;\n                }\n            }\n            var parameters = methodInfo.GetParameters();\n            options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n            options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(global::System.Int32), contentTypes: GeneratedMetadataConstants.JsonContentType));\n            return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n        };\n        /* Remaining implementation truncated for brevity */\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Endpoint Filter Chain Builder in C#\nDESCRIPTION: Constructs a chain of endpoint filters by applying filter factories in reverse order. Used for request pipeline customization.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_IntArrayParam_Optional.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Executing HTTP Response in ASP.NET Core\nDESCRIPTION: Handles execution of different response types including IResult, string and JSON objects. Contains special handling for JSON serialization with trimming support.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Polymorphism Detection for JSON Serialization in ASP.NET Core\nDESCRIPTION: Helper method that determines if a JsonTypeInfo has known polymorphism by checking if the type is sealed, a value type, or has explicit polymorphism options configured.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)\n    => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;\n```\n\n----------------------------------------\n\nTITLE: Implementing MapPost Request Handler in ASP.NET Core\nDESCRIPTION: Generated extension method for mapping POST requests in ASP.NET Core. Includes metadata population, request delegate creation, and parameter binding logic with support for JSON body parsing and service resolution.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_TakesCustomMetadataEmitter_Has_Metadata.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nfile static class GeneratedRouteBuilderExtensionsCore\n{\n    private static readonly JsonOptions FallbackJsonOptions = new();\n    private static readonly string[] PostVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Post };\n\n    %INTERCEPTSLOCATIONATTRIBUTE%\n    internal static RouteHandlerBuilder MapPost0(\n        this IEndpointRouteBuilder endpoints,\n        [StringSyntax(\"Route\")] string pattern,\n        Delegate handler)\n    {\n        MetadataPopulator populateMetadata = (methodInfo, options) =>\n        {\n            // Metadata population logic\n        };\n        RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n        {\n            // Request delegate creation logic\n        };\n        var castHandler = Cast(handler, void (global::Microsoft.AspNetCore.Http.Generators.Tests.CustomMetadataEmitter arg0) => throw null!);\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining RemoteAuthenticationOptions class in C# for ASP.NET Core\nDESCRIPTION: This snippet defines the RemoteAuthenticationOptions class, which inherits from AuthenticationSchemeOptions. It includes properties for configuring remote authentication such as SignInScheme, SaveTokens, and Events.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/JwtBearer/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class RemoteAuthenticationOptions : AuthenticationSchemeOptions\n{\n    /// <summary>\n    /// Gets or sets the scheme to use for sign in.\n    /// </summary>\n    public string? SignInScheme { get; set; }\n\n    /// <summary>\n    /// Gets or sets the authentication scheme corresponding to the middleware\n    /// responsible of persisting user's identity after a successful authentication.\n    /// This value typically corresponds to a cookie middleware registered in the Startup class.\n    /// When omitted, <see cref=\"IdentityConstants.ApplicationScheme\"/> is used as a fallback value.\n    /// </summary>\n    public string? SignOutScheme { get; set; }\n\n    /// <summary>\n    /// Gets or sets a boolean indicating whether the handler should save tokens.\n    /// </summary>\n    public bool SaveTokens { get; set; }\n\n    /// <summary>\n    /// Gets or sets the optional events that can be used to handle remote authentication operations.\n    /// </summary>\n    public new RemoteAuthenticationEvents Events\n    {\n        get => (RemoteAuthenticationEvents)base.Events!;\n        set => base.Events = value;\n    }\n\n    /// <summary>\n    /// Gets or sets the type used to configure the options.\n    /// </summary>\n    public Type? OptionsType { get; set; }\n\n    /// <summary>\n    /// Initializes a new <see cref=\"RemoteAuthenticationOptions\"/>.\n    /// </summary>\n    public RemoteAuthenticationOptions()\n    {\n        Events = new RemoteAuthenticationEvents();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Decoding Non-Blocking Invocation Message in MessagePack\nDESCRIPTION: Shows the structure and decoding of a non-blocking Invocation message in the SignalR MessagePack protocol. This example has a nil invocation ID, indicating a non-blocking call.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_4\n\nLANGUAGE: MessagePack\nCODE:\n```\n0x96 0x01 0x80 0xc0 0xa6 0x6d 0x65 0x74 0x68 0x6f 0x64 0x91 0x2a 0x90\n```\n\n----------------------------------------\n\nTITLE: Invalid Form Request Body Handler\nDESCRIPTION: Handles cases where form data parameter binding fails. Provides both exception throwing and logging functionality for form processing errors.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_TakesCustomMetadataEmitter_Has_Metadata.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n    LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Mapping Core Route Handlers in ASP.NET Core\nDESCRIPTION: Provides the core implementation for mapping route handlers to endpoints. It takes route parameters, HTTP methods, delegates, and metadata to create route handler builders.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating JsonWriter in NewtonsoftJsonOutputFormatter in ASP.NET Core MVC\nDESCRIPTION: This virtual method creates a Newtonsoft.Json.JsonWriter instance based on the provided TextWriter. It's used for customizing the JSON writing process when formatting HTTP responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.NewtonsoftJson/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.Formatters.NewtonsoftJsonOutputFormatter.CreateJsonWriter(System.IO.TextWriter! writer) -> Newtonsoft.Json.JsonWriter!\n```\n\n----------------------------------------\n\nTITLE: Defining CORS Attribute Interfaces in C#\nDESCRIPTION: Defines interfaces for disabling and enabling CORS attributes, including a property for policy name.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Cors.Infrastructure.IDisableCorsAttribute\nMicrosoft.AspNetCore.Cors.Infrastructure.IEnableCorsAttribute\nMicrosoft.AspNetCore.Cors.Infrastructure.IEnableCorsAttribute.PolicyName.get -> string?\nMicrosoft.AspNetCore.Cors.Infrastructure.IEnableCorsAttribute.PolicyName.set -> void\n```\n\n----------------------------------------\n\nTITLE: Building .NET Components for JSInterop\nDESCRIPTION: Commands to build and test the .NET components of Microsoft.JSInterop package using the dotnet CLI.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/JSInterop/README.md#2025-04-08_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ndotnet build\ndotnet test\n```\n\n----------------------------------------\n\nTITLE: Content Type Constants Definition in C#\nDESCRIPTION: Static class defining common content type constants used for HTTP request and response handling. Includes JSON, plaintext, and form data content types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_NoParam_StringReturn.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedMetadataConstants\n{\n    public static readonly string[] JsonContentType = new [] { \"application/json\" };\n    public static readonly string[] PlaintextContentType = new [] { \"text/plain\" };\n    public static readonly string[] FormFileContentType = new[] { \"multipart/form-data\" };\n    public static readonly string[] FormContentType = new[] { \"multipart/form-data\", \"application/x-www-form-urlencoded\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Decoding Invocation Message in MessagePack\nDESCRIPTION: Demonstrates the structure and decoding process of an Invocation message in the SignalR MessagePack protocol. It includes headers, invocation ID, target method, arguments, and stream IDs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md#2025-04-08_snippet_3\n\nLANGUAGE: MessagePack\nCODE:\n```\n0x96 0x01 0x80 0xa3 0x78 0x79 0x7a 0xa6 0x6d 0x65 0x74 0x68 0x6f 0x64 0x91 0x2a 0x90\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: A preprocessor directive that enables nullable reference type checks for the entire source file or project. This helps catch potential null reference exceptions at compile time.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpsPolicy/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Executing Return Values in ASP.NET Core Response Pipeline\nDESCRIPTION: Handles different types of return values from request handlers. Processes IResult instances, strings, and other objects by executing or serializing them appropriately to the HTTP response.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_NullableStringArrayParam_EmptyQueryValues.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Message for Unexpected Non-Form Content Type in C#\nDESCRIPTION: Creates a logger message for unexpected non-form content types using LoggerMessage.Define. This is used to log debug messages when an unsupported form media type is received.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =\n    LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, \"UnexpectedNonFormContentType\"), \"Expected a supported form media type but got \\\"{ContentType}\\\".\");\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocation Attribute in C#\nDESCRIPTION: Defines a sealed attribute class used for method interception, allowing multiple attributes per method with version and data parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/RequestDelegateValidateGeneratedFormCode.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfile sealed class InterceptsLocationAttribute : Attribute\n{\n    public InterceptsLocationAttribute(int version, string data)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Required Parameter Logger in ASP.NET Core (C#)\nDESCRIPTION: Defines a structured logging action for missing required parameters. Creates a reusable logging delegate with appropriate log level, event ID, and message template for consistent logging of missing required parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Get_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nprivate static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =\n    LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, \"RequiredParameterNotProvided\"), \"Required parameter \\\"{ParameterType} {ParameterName}\\\" was not provided from {Source}.\");\n```\n\n----------------------------------------\n\nTITLE: Implementing MapCore Method for ASP.NET Core Route Building\nDESCRIPTION: Defines a MapCore method that serves as a core implementation for mapping routes in ASP.NET Core. It calls RouteHandlerServices.Map with the provided parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_StringArrayParam.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapCore(\n    this IEndpointRouteBuilder routes,\n    string pattern,\n    Delegate handler,\n    IEnumerable<string>? httpMethods,\n    MetadataPopulator populateMetadata,\n    RequestDelegateFactoryFunc createRequestDelegate,\n    MethodInfo methodInfo)\n{\n    return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Structured Log Message for Invalid Form Parameters\nDESCRIPTION: Creates a structured log message definition using LoggerMessage.Define to log debug information when failing to read form parameters from request body. Uses event ID 8 with name 'InvalidFormRequestBody' and includes parameter type and name placeholders.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_StringArrayParam.generated.txt#2025-04-08_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nLoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Web Host Builder Configuration\nDESCRIPTION: Creates and configures a web host builder with content root, startup class, Kestrel server, and IIS integration.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Tools/Microsoft.dotnet-openapi/test/TestContent/Startup.cs.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static IWebHostBuilder CreateWebHostBuilder(string[] args) =>\n    new WebHostBuilder()\n        .UseContentRoot(Directory.GetCurrentDirectory())\n        .UseStartup<Startup>()\n        .UseKestrel()\n        .UseIISIntegration();\n```\n\n----------------------------------------\n\nTITLE: Request Body Parsing in ASP.NET Core\nDESCRIPTION: Handles parsing and validation of JSON request bodies with comprehensive error handling and logging. Supports optional parameters and content type validation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndPut_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static async ValueTask<(bool, T?)> TryResolveBodyAsync<T>(HttpContext httpContext, LogOrThrowExceptionHelper logOrThrowExceptionHelper, bool allowEmpty, string parameterTypeName, string parameterName, JsonTypeInfo<T> jsonTypeInfo, bool isInferred = false)\n{\n    var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();\n    T? bodyValue = default;\n    var bodyValueSet = false;\n\n    if (feature?.CanHaveBody == true)\n    {\n        if (!httpContext.Request.HasJsonContentType())\n        {\n            logOrThrowExceptionHelper.UnexpectedJsonContentType(httpContext.Request.ContentType);\n            httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;\n            return (false, default);\n        }\n        try\n        {\n            bodyValue = await httpContext.Request.ReadFromJsonAsync(jsonTypeInfo);\n            bodyValueSet = bodyValue != null;\n        }\n        catch (BadHttpRequestException badHttpRequestException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(badHttpRequestException);\n            httpContext.Response.StatusCode = badHttpRequestException.StatusCode;\n            return (false, default);\n        }\n        catch (IOException ioException)\n        {\n            logOrThrowExceptionHelper.RequestBodyIOException(ioException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n        catch (System.Text.Json.JsonException jsonException)\n        {\n            logOrThrowExceptionHelper.InvalidJsonRequestBody(parameterTypeName, parameterName, jsonException);\n            httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n            return (false, default);\n        }\n    }\n\n    if (!allowEmpty && !bodyValueSet)\n    {\n        if (!isInferred)\n        {\n            logOrThrowExceptionHelper.RequiredParameterNotProvided(parameterTypeName, parameterName, \"body\");\n        }\n        else\n        {\n            logOrThrowExceptionHelper.ImplicitBodyNotProvided(parameterName);\n        }\n        httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;\n        return (false, bodyValue);\n    }\n\n    return (true, bodyValue);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LocalizationOptions Class in C#\nDESCRIPTION: Defines a class for localization options with a ResourcesPath property.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Localization/Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.Extensions.Localization.LocalizationOptions.LocalizationOptions() -> void\nMicrosoft.Extensions.Localization.LocalizationOptions.ResourcesPath.get -> string!\nMicrosoft.Extensions.Localization.LocalizationOptions.ResourcesPath.set -> void\n```\n\n----------------------------------------\n\nTITLE: IRouter Interface Definition in C#\nDESCRIPTION: Defines the core routing interface for ASP.NET Core with methods for route matching and virtual path generation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Routing.IRouter {\n    Microsoft.AspNetCore.Routing.VirtualPathData? GetVirtualPath(\n        Microsoft.AspNetCore.Routing.VirtualPathContext! context\n    )\n    System.Threading.Tasks.Task! RouteAsync(\n        Microsoft.AspNetCore.Routing.RouteContext! context\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Route Precedence Computation in ASP.NET Core\nDESCRIPTION: These static methods compute the precedence of routes for inbound and outbound routing in ASP.NET Core. They help determine the order in which routes should be evaluated.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.Template.RoutePrecedence.ComputeInbound(Microsoft.AspNetCore.Routing.Template.RouteTemplate! template) -> decimal\n\nstatic Microsoft.AspNetCore.Routing.Template.RoutePrecedence.ComputeOutbound(Microsoft.AspNetCore.Routing.Template.RouteTemplate! template) -> decimal\n```\n\n----------------------------------------\n\nTITLE: Short-Circuit Endpoint Mapping in ASP.NET Core\nDESCRIPTION: This extension method allows for mapping short-circuit endpoints in ASP.NET Core. It creates endpoints that immediately return a specified status code for given route prefixes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Routing.RouteShortCircuitEndpointRouteBuilderExtensions.MapShortCircuit(this Microsoft.AspNetCore.Routing.IEndpointRouteBuilder! builder, int statusCode, params string![]! routePrefixes) -> Microsoft.AspNetCore.Builder.IEndpointConventionBuilder!\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Enables nullable reference type checking at the file level using the #nullable enable directive. This enforces more strict null-checking and helps prevent null reference exceptions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Building Filter Delegate for Endpoint in ASP.NET Core\nDESCRIPTION: Constructs a filter delegate for an endpoint by applying route handler filters in reverse order. It uses the endpoint builder and method info to create the filter context.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)\n{\n    var routeHandlerFilters =  builder.FilterFactories;\n    var context0 = new EndpointFilterFactoryContext\n    {\n        MethodInfo = mi,\n        ApplicationServices = builder.ApplicationServices,\n    };\n    var initialFilteredInvocation = filteredInvocation;\n    for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)\n    {\n        var filterFactory = routeHandlerFilters[i];\n        filteredInvocation = filterFactory(context0, filteredInvocation);\n    }\n    return filteredInvocation;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RouteEndpoint Class in C#\nDESCRIPTION: This snippet defines the RouteEndpoint class with properties for Order and RoutePattern, and a constructor for creating route endpoints.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Routing.RouteEndpoint\nMicrosoft.AspNetCore.Routing.RouteEndpoint.Order.get -> int\nMicrosoft.AspNetCore.Routing.RouteEndpoint.RouteEndpoint(Microsoft.AspNetCore.Http.RequestDelegate! requestDelegate, Microsoft.AspNetCore.Routing.Patterns.RoutePattern! routePattern, int order, Microsoft.AspNetCore.Http.EndpointMetadataCollection? metadata, string? displayName) -> void\nMicrosoft.AspNetCore.Routing.RouteEndpoint.RoutePattern.get -> Microsoft.AspNetCore.Routing.Patterns.RoutePattern!\n```\n\n----------------------------------------\n\nTITLE: Executing Async Returns and Writing JSON Responses in C#\nDESCRIPTION: This snippet includes methods for executing async returns and writing JSON responses. It handles different types of return objects, including IResult, string, and JSON serializable objects.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n\n[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\",\n    Justification = \"The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.\")]\n[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"See above.\")]\nprivate static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)\n{\n    var runtimeType = value?.GetType();\n\n    if (jsonTypeInfo.ShouldUseWith(runtimeType))\n    {\n        return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);\n    }\n\n    return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Hub Method Handlers in SignalR Client C#\nDESCRIPTION: Provides a method to remove all handlers for a specific hub method name, allowing for dynamic management of hub method callbacks.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.SignalR.Client.HubConnection.Remove(string! methodName) -> void\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C# for ASP.NET Core\nDESCRIPTION: This directive enables nullable reference types, a C# feature that helps detect potential null reference exceptions at compile time rather than runtime. When enabled, reference types are non-nullable by default, and nullable reference types must be explicitly marked with '?'.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/StaticAssets/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Configuring DbContext Health Checks in ASP.NET Core\nDESCRIPTION: Example showing how to register a DbContext with Entity Framework Core and add a health check for that DbContext using AddDbContextCheck extension method in the application startup.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HealthChecks.EntityFrameworkCore/src/PACKAGE.md#2025-04-08_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Services.AddDbContext<SampleDbContext>(options =>\n    options.UseSqlServer(builder.Configuration.GetConnectionString(\"DefaultConnection\")));\n\nbuilder.Services.AddHealthChecks()\n    .AddDbContextCheck<SampleDbContext>();\n```\n\n----------------------------------------\n\nTITLE: Implementing HTTP Request Handler with Request and Response Parameters in ASP.NET Core\nDESCRIPTION: This handler processes HTTP requests with both request and response parameters. It includes validation logic, content type negotiation for string vs. JSON responses, and efficient task completion handling for successful and error cases.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nTask RequestHandler(HttpContext httpContext)\n{\n    var wasParamCheckFailure = false;\n    var req_local = httpContext.Request;\n    var res_local = httpContext.Response;\n\n    if (wasParamCheckFailure)\n    {\n        httpContext.Response.StatusCode = 400;\n        return Task.CompletedTask;\n    }\n    var result = handler(req_local, res_local);\n    if (result is string)\n    {\n        httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n    }\n    else\n    {\n        httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n    }\n    return httpContext.Response.WriteAsync(result);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in ASP.NET Core\nDESCRIPTION: Processes errors that occur when reading form data from the request body. It either throws a BadHttpRequestException with the underlying exception or logs a debug message including parameter type and name that could not be read.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Input Helper Extensions in ASP.NET Core\nDESCRIPTION: Extension methods for generating HTML input elements including checkboxes, hidden fields, and password inputs. Supports strongly-typed model binding and custom HTML attributes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperInputExtensions.CheckBoxFor<TModel>(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper<TModel> htmlHelper, System.Linq.Expressions.Expression<System.Func<TModel, bool>> expression) -> Microsoft.AspNetCore.Html.IHtmlContent\n```\n\n----------------------------------------\n\nTITLE: Handling Parameter Binding Failures in ASP.NET Core\nDESCRIPTION: A method that handles cases where parameter binding fails. It either throws a BadHttpRequestException or logs the error depending on configuration. The method formats an error message containing the parameter type, name, and source value that failed to bind.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndGet_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to bind parameter \\\"{0} {1}\\\" from \\\"{2}\\\".\", parameterTypeName, parameterName, sourceValue);\n        throw new BadHttpRequestException(message);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MapPost Extension Method in C#\nDESCRIPTION: Implements a MapPost extension method for IEndpointRouteBuilder to handle HTTP POST requests. It includes metadata population, request delegate creation, and parameter binding for JSON body or query string inputs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedRouteBuilderExtensionsCore\n{\n    private static readonly JsonOptions FallbackJsonOptions = new();\n    private static readonly string[] PostVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Post };\n\n    %INTERCEPTSLOCATIONATTRIBUTE%\n    internal static RouteHandlerBuilder MapPost0(\n        this IEndpointRouteBuilder endpoints,\n        [StringSyntax(\"Route\")] string pattern,\n        Delegate handler)\n    {\n        MetadataPopulator populateMetadata = (methodInfo, options) =>\n        {\n            // ... (metadata population logic)\n        };\n        RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n        {\n            // ... (request delegate creation logic)\n        };\n\n        async Task RequestHandler(HttpContext httpContext)\n        {\n            // ... (request handling logic)\n        }\n\n        async Task RequestHandlerFiltered(HttpContext httpContext)\n        {\n            // ... (filtered request handling logic)\n        }\n\n        // ... (remaining implementation)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DeveloperExceptionPageOptions Class in C#\nDESCRIPTION: This snippet defines the DeveloperExceptionPageOptions class, which provides configuration options for the developer exception page middleware in ASP.NET Core.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics/src/PublicAPI.Shipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Builder.DeveloperExceptionPageOptions\nMicrosoft.AspNetCore.Builder.DeveloperExceptionPageOptions.DeveloperExceptionPageOptions() -> void\nMicrosoft.AspNetCore.Builder.DeveloperExceptionPageOptions.FileProvider.get -> Microsoft.Extensions.FileProviders.IFileProvider?\nMicrosoft.AspNetCore.Builder.DeveloperExceptionPageOptions.FileProvider.set -> void\nMicrosoft.AspNetCore.Builder.DeveloperExceptionPageOptions.SourceCodeLineCount.get -> int\nMicrosoft.AspNetCore.Builder.DeveloperExceptionPageOptions.SourceCodeLineCount.set -> void\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Form Content Type in ASP.NET Core\nDESCRIPTION: Implements a method to handle cases where a form media type was expected but a different content type was received. The method either throws a BadHttpRequestException with a status code of 415 or logs a debug message.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitHeader_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive that enables nullable reference type checking at the file level. This helps catch potential null reference exceptions at compile time rather than runtime.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/SignalR.Common/src/PublicAPI/net10.0/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet0 Extension Method for RouteBuilder in C#\nDESCRIPTION: Extends IEndpointRouteBuilder with a MapGet0 method to handle GET requests. It includes parameter parsing, metadata population, and request delegation for nullable integer array query parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile static class GeneratedRouteBuilderExtensionsCore\n{\n    private static readonly JsonOptions FallbackJsonOptions = new();\n    private static readonly string[] GetVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Get };\n\n    %INTERCEPTSLOCATIONATTRIBUTE%\n    internal static RouteHandlerBuilder MapGet0(\n        this IEndpointRouteBuilder endpoints,\n        [StringSyntax(\"Route\")] string pattern,\n        Delegate handler)\n    {\n        MetadataPopulator populateMetadata = (methodInfo, options) =>\n        {\n            Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n            Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n            options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n            var parameters = methodInfo.GetParameters();\n            options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"p\", parameters[0], hasTryParse: true, hasBindAsync: false, isOptional: true));\n            options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(global::System.Int32?[]), contentTypes: GeneratedMetadataConstants.JsonContentType));\n            return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n        };\n        RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n        {\n            Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n            Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n            Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n            Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n            var handler = Cast(del, global::System.Int32?[] (global::System.Int32?[]? arg0= default) => throw null!);\n            EndpointFilterDelegate? filteredInvocation = null;\n            var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n            var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);\n            var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n            var jsonSerializerOptions = jsonOptions.SerializerOptions;\n            jsonSerializerOptions.MakeReadOnly();\n            var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n            var responseJsonTypeInfo =  (JsonTypeInfo<global::System.Int32?[]?>)jsonSerializerOptions.GetTypeInfo(typeof(global::System.Int32?[]));\n\n            if (options.EndpointBuilder.FilterFactories.Count > 0)\n            {\n                filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n                {\n                    if (ic.HttpContext.Response.StatusCode == 400)\n                    {\n                        return ValueTask.FromResult<object?>(Results.Empty);\n                    }\n                    return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::System.Int32?[]?>(0)!));\n                },\n                options.EndpointBuilder,\n                handler.Method);\n            }\n\n            Task RequestHandler(HttpContext httpContext)\n            {\n                var wasParamCheckFailure = false;\n                // Endpoint Parameter: p (Type = int?[]?, IsOptional = True, IsParsable = True, IsArray = True, Source = Query)\n                var p_raw = httpContext.Request.Query[\"p\"];\n                var p_temp = p_raw.ToArray();\n                global::System.Int32?[]? p_local = new global::System.Int32?[p_temp.Length];\n                for (var i = 0; i < p_temp.Length; i++)\n                {\n                    var element = p_temp[i];\n                    if (!GeneratedRouteBuilderExtensionsCore.TryParseExplicit<int>(element!, CultureInfo.InvariantCulture, out var parsed_element))\n                    {\n                        if (!string.IsNullOrEmpty(element))\n                        {\n                            wasParamCheckFailure = true;\n                            logOrThrowExceptionHelper.RequiredParameterNotProvided(\"int?[]?\", \"p\", \"query string\");\n                        }\n                    }\n                    p_local[i] = string.IsNullOrEmpty(element) ? null! : parsed_element!;\n                }\n\n                if (wasParamCheckFailure)\n                {\n                    httpContext.Response.StatusCode = 400;\n                    return Task.CompletedTask;\n                }\n                var result = handler(p_local);\n                return GeneratedRouteBuilderExtensionsCore.WriteJsonResponseAsync(httpContext.Response, result, responseJsonTypeInfo);\n            }\n\n            async Task RequestHandlerFiltered(HttpContext httpContext)\n            {\n                var wasParamCheckFailure = false;\n                // Endpoint Parameter: p (Type = int?[]?, IsOptional = True, IsParsable = True, IsArray = True, Source = Query)\n                var p_raw = httpContext.Request.Query[\"p\"];\n                var p_temp = p_raw.ToArray();\n                global::System.Int32?[]? p_local = new global::System.Int32?[p_temp.Length];\n                for (var i = 0; i < p_temp.Length; i++)\n                {\n                    var element = p_temp[i];\n                    if (!GeneratedRouteBuilderExtensionsCore.TryParseExplicit<int>(element!, CultureInfo.InvariantCulture, out var parsed_element))\n                    {\n                        if (!string.IsNullOrEmpty(element))\n                        {\n                            wasParamCheckFailure = true;\n                            logOrThrowExceptionHelper.RequiredParameterNotProvided(\"int?[]?\", \"p\", \"query string\");\n                        }\n                    }\n                    p_local[i] = string.IsNullOrEmpty(element) ? null! : parsed_element!;\n                }\n\n                if (wasParamCheckFailure)\n                {\n                    httpContext.Response.StatusCode = 400;\n                }\n                var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::System.Int32?[]?>(httpContext, p_local));\n                if (result is not null)\n                {\n                    await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n                }\n            }\n\n            RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\n            var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\n            return new RequestDelegateResult(targetDelegate, metadata);\n        };\n        var castHandler = Cast(handler, global::System.Int32?[] (global::System.Int32?[]? arg0= default) => throw null!);\n        return MapCore(\n            endpoints,\n            pattern,\n            handler,\n            GetVerb,\n            populateMetadata,\n            createRequestDelegate,\n            castHandler.Method);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ViewLocalizer Class Methods in C#\nDESCRIPTION: This snippet shows the virtual methods of the ViewLocalizer class, which is used for localizing views. It includes indexer methods for getting localized HTML strings.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Localization/src/PublicAPI.Shipped.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.Mvc.Localization.ViewLocalizer.this[string! key, params object![]! arguments].get -> Microsoft.AspNetCore.Mvc.Localization.LocalizedHtmlString!\nvirtual Microsoft.AspNetCore.Mvc.Localization.ViewLocalizer.this[string! key].get -> Microsoft.AspNetCore.Mvc.Localization.LocalizedHtmlString!\n```\n\n----------------------------------------\n\nTITLE: RouteHandlerBuilder Implementation\nDESCRIPTION: Implementation of the RouteHandlerBuilder class that provides methods for building and configuring route handlers with conventions and final actions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Builder.RouteHandlerBuilder.RouteHandlerBuilder(System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Builder.IEndpointConventionBuilder!>! endpointConventionBuilders) -> void\nMicrosoft.AspNetCore.Builder.RouteHandlerBuilder.Add(System.Action<Microsoft.AspNetCore.Builder.EndpointBuilder!>! convention) -> void\nMicrosoft.AspNetCore.Builder.RouteHandlerBuilder.Finally(System.Action<Microsoft.AspNetCore.Builder.EndpointBuilder!>! finalConvention) -> void\n```\n\n----------------------------------------\n\nTITLE: Route Data Class Implementation in C#\nDESCRIPTION: Implements RouteData class for managing routing state and values in ASP.NET Core routing pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing.Abstractions/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Routing.RouteData {\n    Microsoft.AspNetCore.Routing.RouteValueDictionary! DataTokens.get\n    Microsoft.AspNetCore.Routing.RouteData.RouteDataSnapshot PushState(\n        Microsoft.AspNetCore.Routing.IRouter? router,\n        Microsoft.AspNetCore.Routing.RouteValueDictionary? values,\n        Microsoft.AspNetCore.Routing.RouteValueDictionary? dataTokens\n    )\n    RouteData()\n    RouteData(Microsoft.AspNetCore.Routing.RouteData! other)\n    RouteData(Microsoft.AspNetCore.Routing.RouteValueDictionary! values)\n}\n```\n\n----------------------------------------\n\nTITLE: Running All ASP.NET Core Benchmarks\nDESCRIPTION: Command to run all available benchmarks using the wildcard '*' as the benchmark name. The target framework moniker (tfm) must be specified.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/perf/Microbenchmarks/readme.md#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ndotnet run -c Release --framework <tfm> *\n```\n\n----------------------------------------\n\nTITLE: Health Check Endpoint Routing Extensions\nDESCRIPTION: Extension methods for IEndpointRouteBuilder to map health check endpoints with pattern matching and custom options.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HealthChecks/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic static class HealthCheckEndpointRouteBuilderExtensions\n{\n    public static IEndpointConventionBuilder MapHealthChecks(this IEndpointRouteBuilder endpoints, string pattern);\n    public static IEndpointConventionBuilder MapHealthChecks(this IEndpointRouteBuilder endpoints, string pattern, HealthCheckOptions options);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet2 Method for HTTP GET Endpoint Registration in ASP.NET Core\nDESCRIPTION: This method registers a GET endpoint with request and response parameters. It configures metadata for parameter binding, defines response types, and creates appropriate request delegates for handling HTTP requests with proper content type negotiation.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet2(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"req\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"res\", parameters[1], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n```\n\n----------------------------------------\n\nTITLE: Error Handling and Logging Helper for ASP.NET Core Request Delegation\nDESCRIPTION: Helper class that provides methods for logging or throwing exceptions during request processing. It handles IO exceptions and invalid JSON request bodies with appropriate error messages.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nfile sealed class LogOrThrowExceptionHelper\n{\n    private readonly ILogger? _rdgLogger;\n    private readonly bool _shouldThrow;\n\n    public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)\n    {\n        var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();\n        _rdgLogger = loggerFactory?.CreateLogger(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator\");\n        _shouldThrow = options?.ThrowOnBadRequest ?? false;\n    }\n\n    public void RequestBodyIOException(IOException exception)\n    {\n        if (_rdgLogger != null)\n        {\n            _requestBodyIOException(_rdgLogger, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, Exception?> _requestBodyIOException =\n        LoggerMessage.Define(LogLevel.Debug, new EventId(1, \"RequestBodyIOException\"), \"Reading the request body failed with an IOException.\");\n\n    public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)\n    {\n        if (_shouldThrow)\n        {\n            var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as JSON.\", parameterTypeName, parameterName);\n            throw new BadHttpRequestException(message, exception);\n        }\n\n        if (_rdgLogger != null)\n        {\n            _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n        }\n    }\n\n    private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =\n```\n\n----------------------------------------\n\nTITLE: Defining ModelExplorer Class Methods in C#\nDESCRIPTION: This snippet shows method signatures for the ModelExplorer class, which is used for exploring and accessing model metadata and values in ASP.NET Core MVC.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ModelExplorer.GetExplorerForExpression(Microsoft.AspNetCore.Mvc.ModelBinding.ModelMetadata metadata, object model) -> Microsoft.AspNetCore.Mvc.ViewFeatures.ModelExplorer\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Mvc.ViewFeatures.ModelExplorer.GetExplorerForProperty(string name) -> Microsoft.AspNetCore.Mvc.ViewFeatures.ModelExplorer\n```\n\n----------------------------------------\n\nTITLE: Invoking Hub Methods Asynchronously in SignalR Client C#\nDESCRIPTION: Provides core functionality for invoking hub methods asynchronously with support for cancellation. It handles method invocation with dynamic return types and parameters.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Client.Core/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nvirtual Microsoft.AspNetCore.SignalR.Client.HubConnection.InvokeCoreAsync(string! methodName, System.Type! returnType, object?[]! args, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<object?>!\n```\n\n----------------------------------------\n\nTITLE: Defining PubSubChannel Class in C# for ASP.NET Core\nDESCRIPTION: This code snippet defines the PubSubChannel class with a Name property and a ToString() method. It represents a channel for publish-subscribe messaging in ASP.NET Core applications.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Core/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Microsoft.AspNetCore.SignalR.Internal;\n\ninternal sealed class PubSubChannel\n{\n    public string Name { get; }\n\n    public PubSubChannel(string name)\n    {\n        Name = name;\n    }\n\n    public override string ToString() => $\"Channel: {Name}\";\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Value HTML Helper Extension Methods in C#\nDESCRIPTION: These extension methods provide functionality to retrieve values from model expressions in ASP.NET Core MVC views. They include methods for getting values from simple expressions, strongly-typed expressions, and model-level expressions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperValueExtensions.Value(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper htmlHelper, string expression) -> string\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperValueExtensions.ValueFor<TModel, TResult>(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper<TModel> htmlHelper, System.Linq.Expressions.Expression<System.Func<TModel, TResult>> expression) -> string\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperValueExtensions.ValueForModel(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper htmlHelper) -> string\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperValueExtensions.ValueForModel(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper htmlHelper, string format) -> string\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet Handler with HttpRequest Parameter\nDESCRIPTION: Internal extension method for mapping GET requests to a delegate handler that accepts an HttpRequest parameter. It generates metadata for the endpoint and constructs a RequestDelegate that processes the request and formats the response appropriately.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n%INTERCEPTSLOCATIONATTRIBUTE%\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n        options.EndpointBuilder.Metadata.Add(new ParameterBindingMetadata(\"req\", parameters[0], hasTryParse: false, hasBindAsync: false, isOptional: false));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        Debug.Assert(options.EndpointBuilder.ApplicationServices != null, \"ApplicationServices not found.\");\n        Debug.Assert(options.EndpointBuilder.FilterFactories != null, \"FilterFactories not found.\");\n        var handler = Cast(del, global::System.String (global::Microsoft.AspNetCore.Http.HttpRequest arg0) => throw null!);\n        EndpointFilterDelegate? filteredInvocation = null;\n        var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;\n        var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;\n        var jsonSerializerOptions = jsonOptions.SerializerOptions;\n        jsonSerializerOptions.MakeReadOnly();\n        var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));\n\n        if (options.EndpointBuilder.FilterFactories.Count > 0)\n        {\n            filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>\n            {\n                if (ic.HttpContext.Response.StatusCode == 400)\n                {\n                    return ValueTask.FromResult<object?>(Results.Empty);\n                }\n                return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.HttpRequest>(0)!));\n            },\n            options.EndpointBuilder,\n            handler.Method);\n        }\n\n        Task RequestHandler(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            var req_local = httpContext.Request;\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n                return Task.CompletedTask;\n            }\n            var result = handler(req_local);\n            if (result is string)\n            {\n                httpContext.Response.ContentType ??= \"text/plain; charset=utf-8\";\n            }\n            else\n            {\n                httpContext.Response.ContentType ??= \"application/json; charset=utf-8\";\n            }\n            return httpContext.Response.WriteAsync(result);\n        }\n\n        async Task RequestHandlerFiltered(HttpContext httpContext)\n        {\n            var wasParamCheckFailure = false;\n            var req_local = httpContext.Request;\n\n            if (wasParamCheckFailure)\n            {\n                httpContext.Response.StatusCode = 400;\n            }\n            var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.HttpRequest>(httpContext, req_local));\n            if (result is not null)\n            {\n                await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);\n            }\n        }\n\n        RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;\n        var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;\n        return new RequestDelegateResult(targetDelegate, metadata);\n    };\n    var castHandler = Cast(handler, global::System.String (global::Microsoft.AspNetCore.Http.HttpRequest arg0) => throw null!);\n    return MapCore(\n        endpoints,\n        pattern,\n        handler,\n        GetVerb,\n        populateMetadata,\n        createRequestDelegate,\n        castHandler.Method);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a custom attribute for intercepting method calls with version and data parameters. This attribute is used for code generation purposes.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndGet_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: EditorFor Extensions in ASP.NET Core\nDESCRIPTION: Extension methods for generating editor HTML elements for model properties. Includes overloads for template customization and additional view data.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.ViewFeatures/src/PublicAPI.Shipped.txt#2025-04-08_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Mvc.Rendering.HtmlHelperEditorExtensions.EditorFor<TModel, TResult>(this Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper<TModel> htmlHelper, System.Linq.Expressions.Expression<System.Func<TModel, TResult>> expression) -> Microsoft.AspNetCore.Html.IHtmlContent\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Form Request Body in C#\nDESCRIPTION: This method processes invalid form request bodies, throws a BadHttpRequestException if necessary, and logs the event. It includes parameter type and name information in the error message and log entry.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitSource_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Failed to read parameter \\\"{0} {1}\\\" from the request body as form.\", parameterTypeName, parameterName);\n        throw new BadHttpRequestException(message, exception);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);\n    }\n}\n\nprivate static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =\n    LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, \"InvalidFormRequestBody\"), \"Failed to read parameter \\\"{ParameterType} {ParameterName}\\\" from the request body as form.\");\n```\n\n----------------------------------------\n\nTITLE: Two-Factor Authentication Model\nDESCRIPTION: Implements the two-factor authentication login model with properties for verification code and remember machine option.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Identity/UI/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Identity.UI.V4.Pages.Account.Internal.LoginWith2faModel.InputModel\nMicrosoft.AspNetCore.Identity.UI.V4.Pages.Account.Internal.LoginWith2faModel.InputModel.TwoFactorCode.get -> string!\nMicrosoft.AspNetCore.Identity.UI.V4.Pages.Account.Internal.LoginWith2faModel.InputModel.TwoFactorCode.set -> void\nMicrosoft.AspNetCore.Identity.UI.V4.Pages.Account.Internal.LoginWith2faModel.InputModel.RememberMachine.get -> bool\nMicrosoft.AspNetCore.Identity.UI.V4.Pages.Account.Internal.LoginWith2faModel.InputModel.RememberMachine.set -> void\n```\n\n----------------------------------------\n\nTITLE: Authorizing User Against Requirements Collection\nDESCRIPTION: Asynchronously authorizes a user against a collection of IAuthorizationRequirement with an optional resource. Returns an AuthorizationResult indicating whether all requirements were satisfied.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\nvirtual Microsoft.AspNetCore.Authorization.DefaultAuthorizationService.AuthorizeAsync(System.Security.Claims.ClaimsPrincipal! user, object? resource, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authorization.IAuthorizationRequirement!>! requirements) -> System.Threading.Tasks.Task<Microsoft.AspNetCore.Authorization.AuthorizationResult!>!\n```\n\n----------------------------------------\n\nTITLE: Explicit Parsing for IParsable<T> Types\nDESCRIPTION: A helper method that wraps IParsable<T>.TryParse for supporting parameter conversion. Enables consistent parameter binding for types that implement the IParsable interface.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static bool TryParseExplicit<T>(string? s, IFormatProvider? provider, [MaybeNullWhen(returnValue: false)] out T result) where T: IParsable<T>\n    => T.TryParse(s, provider, out result);\n```\n\n----------------------------------------\n\nTITLE: Defining InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a custom attribute 'InterceptsLocationAttribute' used for method interception in the System.Runtime.CompilerServices namespace.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocationAttribute in C#\nDESCRIPTION: Defines a sealed attribute class used for method interception with versioning support. This attribute can be applied multiple times to methods.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndPut_WithArrayQueryString_AndBody_ShouldUseBody.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Razor View with Runtime Compilation\nDESCRIPTION: Sample Razor view that demonstrates the basic structure of a view file that can be modified at runtime when the runtime compilation package is enabled. Changes to this view will be reflected without application restart.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Razor.RuntimeCompilation/src/PACKAGE.md#2025-04-08_snippet_2\n\nLANGUAGE: HTML\nCODE:\n```\n<!-- Example Razor view: Views/Home/Index.cshtml -->\n@{\n    ViewData[\"Title\"] = \"Home Page\";\n}\n\n<h2>@ViewData[\"Title\"]</h2>\n\n<p>Welcome to the ASP.NET Core MVC application!</p>\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Form Content Type in ASP.NET Core (C#)\nDESCRIPTION: Handles cases where an unsupported form media type is received. Either throws a BadHttpRequestException with HTTP status 415 (Unsupported Media Type) or logs the issue with details about the unexpected content type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Get_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Non-Form Content Type in C#\nDESCRIPTION: Method to handle unexpected non-form content types. It either throws a BadHttpRequestException or logs a debug message depending on the _shouldThrow flag.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_IntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using RedirectToRouteHttpResult in ASP.NET Core\nDESCRIPTION: API signatures for the RedirectToRouteHttpResult class, which returns a redirect response to a route determined by the specified route values and name, with options for fragments and redirect types.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Results/src/PublicAPI.Shipped.txt#2025-04-08_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.HttpResults.RedirectToRouteHttpResult\nMicrosoft.AspNetCore.Http.HttpResults.RedirectToRouteHttpResult.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext! httpContext) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.HttpResults.RedirectToRouteHttpResult.Fragment.get -> string?\nMicrosoft.AspNetCore.Http.HttpResults.RedirectToRouteHttpResult.Permanent.get -> bool\nMicrosoft.AspNetCore.Http.HttpResults.RedirectToRouteHttpResult.PreserveMethod.get -> bool\nMicrosoft.AspNetCore.Http.HttpResults.RedirectToRouteHttpResult.RouteName.get -> string?\nMicrosoft.AspNetCore.Http.HttpResults.RedirectToRouteHttpResult.RouteValues.get -> Microsoft.AspNetCore.Routing.RouteValueDictionary!\n```\n\n----------------------------------------\n\nTITLE: HttpLoggingBuilderExtensions in ASP.NET Core\nDESCRIPTION: Extension methods for IApplicationBuilder that enable HTTP logging and W3C logging middleware in the ASP.NET Core request pipeline.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpLogging/src/PublicAPI.Shipped.txt#2025-04-08_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic Microsoft.AspNetCore.Builder.HttpLoggingBuilderExtensions.UseHttpLogging(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\nstatic Microsoft.AspNetCore.Builder.HttpLoggingBuilderExtensions.UseW3CLogging(this Microsoft.AspNetCore.Builder.IApplicationBuilder! app) -> Microsoft.AspNetCore.Builder.IApplicationBuilder!\n```\n\n----------------------------------------\n\nTITLE: AuthorizationPolicyBuilder Class Definition in C#\nDESCRIPTION: Definition of the AuthorizationPolicyBuilder class that provides a fluent API for building authorization policies with various requirements like claims, roles, and custom assertions.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/PublicAPI/net462/PublicAPI.Shipped.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.AddAuthenticationSchemes(params string![]! schemes) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.AddRequirements(params Microsoft.AspNetCore.Authorization.IAuthorizationRequirement![]! requirements) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.AuthenticationSchemes.get -> System.Collections.Generic.IList<string!>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.AuthenticationSchemes.set -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.AuthorizationPolicyBuilder(Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy) -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.AuthorizationPolicyBuilder(params string![]! authenticationSchemes) -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.Build() -> Microsoft.AspNetCore.Authorization.AuthorizationPolicy!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.Combine(Microsoft.AspNetCore.Authorization.AuthorizationPolicy! policy) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireAssertion(System.Func<Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext!, bool>! handler) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireAssertion(System.Func<Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext!, System.Threading.Tasks.Task<bool>!>! handler) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireAuthenticatedUser() -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireClaim(string! claimType) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireClaim(string! claimType, params string![]! allowedValues) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireClaim(string! claimType, System.Collections.Generic.IEnumerable<string!>! allowedValues) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.Requirements.get -> System.Collections.Generic.IList<Microsoft.AspNetCore.Authorization.IAuthorizationRequirement!>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.Requirements.set -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireRole(params string![]! roles) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireRole(System.Collections.Generic.IEnumerable<string!>! roles) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authorization.AuthorizationPolicyBuilder.RequireUserName(string! userName) -> Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining HttpConnectionDispatcherOptions Class in C#\nDESCRIPTION: Defines the HttpConnectionDispatcherOptions class with various properties for configuring connection dispatching.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/common/Http.Connections/src/PublicAPI.Shipped.txt#2025-04-08_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions\nMicrosoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.AllowStatefulReconnects.get -> bool\nMicrosoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.AllowStatefulReconnects.set -> void\nMicrosoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.ApplicationMaxBufferSize.get -> long\nMicrosoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.ApplicationMaxBufferSize.set -> void\n// ... (other properties)\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Non-Form Content Type in ASP.NET Core\nDESCRIPTION: Handles cases where a form content type was expected but a different or no content type was provided. When throwing, returns a 415 Unsupported Media Type status code. Either throws an exception or logs the error.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_PostAndGet_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedNonFormContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported form media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedNonFormContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Kestrel Project with PowerShell\nDESCRIPTION: Command to build the Kestrel project from source using PowerShell. This should be run inside the project directory.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/README.md#2025-04-08_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n> ./build.cmd\n```\n\n----------------------------------------\n\nTITLE: Implementing InterceptsLocationAttribute in System.Runtime.CompilerServices\nDESCRIPTION: A compiler attribute used for intercepting method calls at specific locations. This attribute is marked as auto-generated and is used internally by the ASP.NET Core framework for HTTP request interception.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapMethods_Get_WithArrayQueryString_AndBody_ShouldUseQueryString.generated.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    %GENERATEDCODEATTRIBUTE%\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    file sealed class InterceptsLocationAttribute : Attribute\n    {\n        public InterceptsLocationAttribute(int version, string data)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Handler Return Values in ASP.NET Core\nDESCRIPTION: Processes the return values from request handlers, supporting IResult objects, string responses, and JSON serialization. This enables flexible response types in minimal APIs.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ImplicitQuery_ComplexTypeArrayParam.generated.txt#2025-04-08_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MapGet0 Extension Method in C#\nDESCRIPTION: Implements a route builder extension method for handling synchronous GET requests. Includes metadata population, request delegate creation, and response handling for both plain text and JSON responses.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_NoParam_StringReturn.generated.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet0(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, type: typeof(string), contentTypes: GeneratedMetadataConstants.PlaintextContentType));\n        return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };\n    };\n    // ... [truncated for brevity]\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing IParsable<T> Explicitly in ASP.NET Core\nDESCRIPTION: Attempts to parse a string value to a type T that implements IParsable<T>.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitQuery_NullableIntArrayParam_Optional_QueryNotPresent.generated.txt#2025-04-08_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nprivate static bool TryParseExplicit<T>(string? s, IFormatProvider? provider, [MaybeNullWhen(returnValue: false)] out T result) where T: IParsable<T>\n    => T.TryParse(s, provider, out result);\n```\n\n----------------------------------------\n\nTITLE: Health Check Builder Extension Methods\nDESCRIPTION: Extension methods for IApplicationBuilder to configure health check middleware with various options including custom paths and ports.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HealthChecks/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static class HealthCheckApplicationBuilderExtensions\n{\n    public static IApplicationBuilder UseHealthChecks(this IApplicationBuilder app, PathString path);\n    public static IApplicationBuilder UseHealthChecks(this IApplicationBuilder app, PathString path, int port);\n    public static IApplicationBuilder UseHealthChecks(this IApplicationBuilder app, PathString path, HealthCheckOptions options);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected JSON Content Type in ASP.NET Core\nDESCRIPTION: Processes cases where a JSON content type was expected but a different content type was received. It either throws a BadHttpRequestException with a 415 status code or logs a debug message with the unexpected content type.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapPost_WithArrayQueryString_ShouldFail.generated.txt#2025-04-08_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic void UnexpectedJsonContentType(string? contentType)\n{\n    if (_shouldThrow)\n    {\n        var message = string.Format(CultureInfo.InvariantCulture, \"Expected a supported JSON media type but got \\\"{0}\\\".\", contentType);\n        throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);\n    }\n\n    if (_rdgLogger != null)\n    {\n        _unexpectedJsonContentType(_rdgLogger, contentType ?? \"(none)\", null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling LDAP Configuration\nDESCRIPTION: Methods for configuring LDAP integration with Negotiate authentication.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Negotiate/src/PublicAPI.Shipped.txt#2025-04-08_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Authentication.Negotiate.NegotiateOptions.EnableLdap(string! domain) -> void\n\nMicrosoft.AspNetCore.Authentication.Negotiate.NegotiateOptions.EnableLdap(System.Action<Microsoft.AspNetCore.Authentication.Negotiate.LdapSettings!>! configureSettings) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing Alternate MapGet Handler Extension Method\nDESCRIPTION: Partial implementation of another MapGet extension method variant. This method appears to be for a different parameter binding scenario but is not fully shown in the snippet.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/MapAction_ExplicitSource_SimpleReturn_Snapshot.generated.txt#2025-04-08_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static RouteHandlerBuilder MapGet1(\n    this IEndpointRouteBuilder endpoints,\n    [StringSyntax(\"Route\")] string pattern,\n    Delegate handler)\n{\n    MetadataPopulator populateMetadata = (methodInfo, options) =>\n    {\n        Debug.Assert(options != null, \"RequestDelegateFactoryOptions not found.\");\n        Debug.Assert(options.EndpointBuilder != null, \"EndpointBuilder not found.\");\n        options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60\", \"42.42.42.42\"));\n        var parameters = methodInfo.GetParameters();\n\n\n```\n\n----------------------------------------\n\nTITLE: HttpConnection Methods in ASP.NET Core (C#)\nDESCRIPTION: Defines the StartAsync methods for the HttpConnection class that initialize connections with specified transfer formats and cancellation tokens.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/clients/csharp/Http.Connections.Client/src/PublicAPI.Shipped.txt#2025-04-08_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnection.StartAsync(Microsoft.AspNetCore.Connections.TransferFormat transferFormat, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nMicrosoft.AspNetCore.Http.Connections.Client.HttpConnection.StartAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: Directive that enables nullable reference type checking at the file or project level. This helps catch potential null reference exceptions at compile time by making nullability explicit in the type system.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Servers/Kestrel/Core/src/PublicAPI.Unshipped.txt#2025-04-08_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Executing and Serializing API Endpoint Return Values in ASP.NET Core\nDESCRIPTION: Handles the execution of return values from request delegates based on their type. It processes IResult objects, strings, and serializes other objects to JSON using the provided type information.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Extensions/test/RequestDelegateGenerator/Baselines/Multiple_MapAction_WithParams_StringReturn.generated.txt#2025-04-08_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)\n{\n    if (obj is IResult r)\n    {\n        return r.ExecuteAsync(httpContext);\n    }\n    else if (obj is string s)\n    {\n        return httpContext.Response.WriteAsync(s);\n    }\n    else\n    {\n        return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building dotnet/aspnetcore in PowerShell\nDESCRIPTION: Commands to restore dependencies, activate local runtime, and build specific projects within the dotnet/aspnetcore repository.\nSOURCE: https://github.com/dotnet/aspnetcore/blob/main/src/Shared/runtime/ReadMe.SharedCode.md#2025-04-08_snippet_3\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS D:\\github\\aspnetcore> .\\restore.cmd\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS D:\\github\\aspnetcore> . .\\activate.ps1\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\n(aspnetcore) PS D:\\github\\aspnetcore\\src\\Shared\\test\\Shared.Tests> dotnet build\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\n(aspnetcore) PS D:\\github\\aspnetcore\\src\\servers\\Kestrel\\core\\src> dotnet build\n```"
  }
]