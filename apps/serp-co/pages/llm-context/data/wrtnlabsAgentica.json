[
  {
    "owner": "wrtnlabs",
    "repo": "agentica",
    "content": "TITLE: Agent Initialization with OpenAI and OpenAPI\nDESCRIPTION: This code snippet demonstrates the initialization of an Agentica agent.  It configures the agent with an OpenAI model (`gpt-4o-mini`) and defines controllers that leverage `HttpLlm.application` and `typia.llm.application` to integrate API functions defined by an OpenAPI document. The OpenAPI document is fetched from a remote URL, and `OpenApi.convert` transforms it into a suitable format for LLM function calling. It also incorporates other controllers based on `ShoppingCounselor`, `ShoppingPolicy`, and `ShoppingSearchRag` types. Finally, the agent is used to converse with the user.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/articles/i-made-mcp-alternative-solution-for-openai-and-all-other-llms.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport { HttpLlm, OpenApi } from \"@samchon/openapi\";\nimport typia from \"typia\";\n\nconst agent = new Agentica({\n  service: {\n    api: new OpenAI({ apiKey: \"*****\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    HttpLlm.application({\n      model: \"chatgpt\",\n      document: OpenApi.convert(\n        await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n        ).then(r => r.json())\n      )\n    }),\n    typia.llm.application<ShoppingCounselor, \"chatgpt\">(),\n    typia.llm.application<ShoppingPolicy, \"chatgpt\">(),\n    typia.llm.application<ShoppingSearchRag, \"chatgpt\">(),\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Agentica: Configuring HTTP Controller with Swagger/OpenAPI in Typescript\nDESCRIPTION: This code snippet demonstrates how to configure an HTTP controller within Agentica using a Swagger/OpenAPI document. It defines the agent with an HTTP controller, specifying the protocol, name, application (built from a Swagger/OpenAPI document), and connection details including host and authorization headers. The `assertHttpLlmApplication` function is used to create the application from the OpenAPI spec.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/controller/swagger.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Agentica,\n  IAgenticaController,\n  assertHttpLlmApplication\n} from \"@agentica/core\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      protocol: \"http\",\n      name: \"shopping\",\n      application: assertHttpLlmApplication({\n        model: \"chatgpt\",\n        document: await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n        ).then((r) => r.json()),\n      }),\n      connection: {\n        host: \"https://shopping-be.wrtn.ai\",\n        headers: {\n          Authorization: \"Bearer ********\",\n        },\n      },\n    } satisfies IAgenticaController.IHttp<\"chatgpt\">,\n  ],\n});\nawait agent.conversate(\"What you can do?\");\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica and Conversing\nDESCRIPTION: This snippet demonstrates how to initialize an Agentica instance with a specified model, vendor (OpenAI), controllers, and histories. It then calls the `conversate` function to start a conversation and archives the resulting prompts.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/history.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Agentica,\n  AgenticaHistory,\n  IAgenticaHistoryJson,\n} from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nexport const main = async (id: string): Promise<void> => {\n  const agent = new Agentica({\n    model: \"chatgpt\",\n    vendor: {\n      api: new OpenAI({ apiKey: \"*****\" }),\n      model: \"gpt-4o-mini\",\n    },\n    controllers: [...],\n    histories: (await getHistories(id)) satisfies IAgenticaHistoryJson[],\n  });\n  const prompts: AgenticaHistory[] = await agent.conversate(\n    \"I wanna buy MacBook Pro\",\n  );\n  await archiveHistories(id, prompts.map((p) => p.toJSON()));\n};\n```\n\n----------------------------------------\n\nTITLE: Create Swagger Agent with Agentica (TypeScript)\nDESCRIPTION: This TypeScript code defines an asynchronous function `SwaggerAgent` that creates and configures an Agentica agent to interact with a Swagger API.  It fetches the Swagger document from a remote URL, converts it using `assertHttpLlmApplication`, and sets up the API connection with the specified host and authorization headers.  It requires `dotenv` for managing environment variables and `OpenAI` for interacting with the OpenAI API.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/coding/swagger.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport dotenv from \"dotenv\";\nimport OpenAI from \"openai\";\n\ndotenv.config();\n\nconst openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n\nexport const SwaggerAgent = async () =>\n  new Agentica({\n    model: \"chatgpt\",\n    vendor: {\n      api: openai,\n      model: \"gpt-4o-mini\",\n    },\n    controllers: [\n      {\n        name: \"Shopping Mall\", // Name of the connector (can be any descriptive name)\n        protocol: \"http\", // Indicates an HTTP-based connector\n        application: assertHttpLlmApplication({\n          // Convert the Swagger JSON document to an OpenAPI model for Agentica.\n          document: await fetch(\n            \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n          ).then((r) => r.json()),\n          model: \"chatgpt\",\n        }),\n        connection: {\n          // This is the actual API host where the API requests will be sent.\n          host: \"https://shopping-be.wrtn.ai\",\n          headers: {\n            Authorization: \"Bearer *****\",\n          },\n        },\n      },\n    ],\n  });\n```\n\n----------------------------------------\n\nTITLE: Validation Feedback Implementation in TypeScript\nDESCRIPTION: This TypeScript code demonstrates the validation feedback strategy used in Agentica to improve LLM function calling.  The `correctFunctionCall` function takes a `FunctionCall`, a list of available `ILlmFunction` objects, and a `retry` function as input. It validates the arguments of the `FunctionCall` using `typia.validate<T>()` against the expected schema defined in `ILlmFunction`. If validation fails, it calls the `retry` function with detailed type errors to prompt the LLM to correct the arguments in the next turn. This iterative process enhances the accuracy of function calls.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/concepts/function-calling.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { FunctionCall } from \"pseudo\";\nimport { ILlmFunction, IValidation } from \"typia\";\n\nexport const correctFunctionCall = (p: {\n  call: FunctionCall;\n  functions: Array<ILlmFunction<\"chatgpt\">>;\n  retry: (reason: string, errors?: IValidation.IError[]) => Promise<unknown>;\n}): Promise<unknown> => {\n  // FIND FUNCTION\n  const func: ILlmFunction<\"chatgpt\"> | undefined =\n    p.functions.find((f) => f.name === p.call.name);\n  if (func === undefined) {\n    // never happened in my experience\n    return p.retry(\n      \"Unable to find the matched function name. Try it again.\",\n    );\n  }\n\n  // VALIDATE\n  const result: IValidation<unknown> = func.validate(p.call.arguments);\n  if (result.success === false) {\n    // 1st trial: 30% (gpt-4o-mini in shopping mall chatbot)\n    // 2nd trial with validation feedback: 99%\n    // 3nd trial with validation feedback again: never have failed\n    return p.retry(\n      \"Type errors are detected. Correct it through validation errors\",\n      {\n        errors: result.errors,\n      },\n    );\n  }\n  return result.data;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with Configurations (TypeScript)\nDESCRIPTION: This snippet demonstrates how to initialize an Agentica instance with various configuration options, including the model, vendor, controllers, and a detailed configuration object (IAgenticaConfig). The configuration object includes settings for the executor, system prompt, locale, timezone, and retry attempts. It showcases the use of AgenticaPgVectorSelector for function selection.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/config.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, IAgenticaProps, IAgenticaConfig } from \"@agentica/core\";\nimport { AgenticaPgVectorSelector } from \"@agentica/pg-vector-selector\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o\",\n  },\n  controllers: [...],\n  config: {\n    executor: {\n      initialize: null,\n      select: AgenticaPgVectorSelector.boot<\"chatgpt\">\n        (\"https://your-connector-hive-server.com\",\n      ),\n    },\n    systemPrompt: {\n      common: () => [\n        \"You are a counselor of the shopping mall.\",\n        \"\",\n        \"Be kind and polite to the customer.\",\n      ].join(\"\\n\"),\n    },\n    locale: \"ko-KR\",\n    timezone: \"Asia/Seoul\",\n    retry: 3,\n  },\n});\nawait agent.conversate(\"Hello, I want to refund my shoes.\");\n```\n\n----------------------------------------\n\nTITLE: Agentica Initialization with OpenAI and TypeScript Class\nDESCRIPTION: This snippet demonstrates initializing Agentica with an OpenAI vendor and configuring a controller using a TypeScript class and Swagger/OpenAPI document. It showcases how to integrate functions from different protocols into an AI agent.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/standalone/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\nimport { MobileFileSystem } from \"./services/MobileFileSystem\";\n\nconst agent = new Agentica({\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    // functions from TypeScript class\n    {\n      protocol: \"http\",\n      application: typia.llm.application<MobileFileSystem, \"chatgpt\">(),\n      execute: new MobileFileSystem(),\n    },\n    // functions from Swagger/OpenAPI\n    {\n      protocol: \"http\",\n      application: assertHttpLlmApplication({\n        model: \"chatgpt\",\n        document: await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n        ).then(r => r.json()),\n      }),\n      connection: {\n        host: \"https://shopping-be.wrtn.ai\",\n        headers: { Authorization: \"Bearer ********\" },\n      },\n    },\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Creating Agentica RAG Agent with OpenAI and Vector Store\nDESCRIPTION: This TypeScript code defines a RAG agent using Agentica, OpenAI's GPT model, and a vector store selector. It initializes the OpenAI API, configures the AgenticaOpenAIVectorStoreSelector to connect to the vector store, and sets up the Agentica agent with a chatgpt model and the vector store controller. It also sets up typia for type safety.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/coding/vector-store.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport { AgenticaOpenAIVectorStoreSelector } from \"@agentica/openai-vector-store\";\nimport dotenv from \"dotenv\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\ndotenv.config();\n\nconst openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n\nconst selector = new AgenticaOpenAIVectorStoreSelector({\n  provider: {\n    api: openai,\n    assistant: { name: \"agentica\", model: \"gpt-4o-mini\" },\n    vectorStore: { name: \"vectorStore\" },\n  },\n});\n\nexport const RagAgent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: openai,\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      protocol: \"class\",\n      name: \"vectorStore\",\n      application: typia.llm.application<\n        AgenticaOpenAIVectorStoreSelector,\n        \"chatgpt\"\n      >(),\n      execute: selector,\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Documenting TypeScript Functions for LLM\nDESCRIPTION: This code demonstrates how to document TypeScript functions for use in LLM function calling within Agentica.  It emphasizes the importance of detailed description comments for each function, explaining its purpose and any relationships with other functions, such as prerequisite or postrequisite conditions. The snippet showcases the use of description comments to explain the functionality of the `index` and `at` methods within the `ShoppingSaleService` class.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/controller/typescript.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tags } from \"typia\";\n\nimport { IPage } from \"@samchon/shopping-api/lib/structures/common/IPage\";\nimport { IShoppingActorEntity } from \"@samchon/shopping-api/lib/structures/shoppings/actors/IShoppingActorEntity\";\nimport { IShoppingSale } from \"@samchon/shopping-api/lib/structures/shoppings/sales/IShoppingSale\";\n\nexport class ShoppingSaleService {\n  /**\n   * List up every summarized sales.\n   *\n   * List up every {@link IShoppingSale.ISummary summarized sales}.\n   *\n   * As you can see, returned sales are summarized, not detailed. It does not\n   * contain the SKU (Stock Keeping Unit) information represented by the\n   * {@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\n   * If you want to get such detailed information of a sale, use\n   * `GET /shoppings/customers/sales/{id}` operation for each sale.\n   *\n   * > If you're an A.I. chatbot, and the user wants to buy or compose\n   * > {@link IShoppingCartCommodity shopping cart} from a sale, please\n   * > call the `GET /shoppings/customers/sales/{id}` operation at least once\n   * > to the target sale to get detailed SKU information about the sale.\n   * > It needs to be run at least once for the next steps.\n   *\n   * @returns Paginated sales with summarized information\n   */\n  @TypedRoute.Patch()\n  public index(props: {\n    /**\n     * Request info of pagination, searching and sorting\n     */\n    input: IShoppingSale.IRequest,\n  }): Promise<IPage<IShoppingSale.ISummary>>;\n\n  /**\n   * Get a sale with detailed information.\n   *\n   * Get a {@link IShoppingSale sale} with detailed information including\n   * the SKU (Stock Keeping Unit) information represented by the\n   * {@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\n   *\n   * > If you're an A.I. chatbot, and the user wants to buy or compose a\n   * > {@link IShoppingCartCommodity shopping cart} from a sale, please call\n   * > this operation at least once to the target sale to get detailed SKU\n   * > information about the sale.\n   * >\n   * > It needs to be run at least once for the next steps. In other words,\n   * > if you A.I. agent has called this operation to a specific sale, you\n   * > don't need to call this operation again for the same sale.\n   * >\n   * > Additionally, please do not summarize the SKU information. Just show\n   * > the every options and stocks in the sale with detailed information.\n   *\n   * @returns Detailed sale information\n   */\n  @TypedRoute.Get(\":id\")\n  public at(props: {\n    /**\n     * Target sale's {@link IShoppingSale.id}\n     */\n    id: string & tags.Format<\"uuid\">,\n  }): Promise<IShoppingSale>;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with OpenAI and TypeScript Class\nDESCRIPTION: This TypeScript code demonstrates how to initialize Agentica with an OpenAI model and a function defined as a TypeScript class (MobileFileSystem). It configures the agent to use the gpt-4o-mini model and specifies the http protocol for communication with the class. The code also includes fetching a Swagger/OpenAPI document for another controller.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/README.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\nimport { MobileFileSystem } from \"./services/MobileFileSystem\";\n\nconst agent = new Agentica({\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    // functions from TypeScript class\n    {\n      protocol: \"http\",\n      application: typia.llm.application<MobileFileSystem, \"chatgpt\">(),\n      execute: new MobileFileSystem(),\n    },\n    // functions from Swagger/OpenAPI\n    {\n      protocol: \"http\",\n      application: assertHttpLlmApplication({\n        model: \"chatgpt\",\n        document: await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n        ).then(r => r.json()),\n      }),\n      connection: {\n        host: \"https://shopping-be.wrtn.ai\",\n        headers: { Authorization: \"Bearer ********\" },\n      },\n    },\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica Agent with Controllers\nDESCRIPTION: This snippet initializes an Agentica agent with multiple controllers, including HTTP and class-based controllers. The HTTP controller integrates with an external shopping API using a Swagger definition. The class-based controllers leverage typia.llm.application for type-safe language model interaction. The agent is configured with an OpenAI model.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaExampleActualSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport typia from \"typia\";\n\nconst main = async (): Promise<void> => {\n  const agent = new Agentica({\n    model: \"chatgpt\",\n    vendor: {\n      api: new OpenAI({ apiKey: \"*****\" }),\n      model: \"gpt-4o-mini\",\n    },\n    controllers: [\n      {\n        protocol: \"http\",\n        name: \"shopping\",\n        application: assertHttpLlmApplication({\n          model: \"chatgpt\",\n          document: await fetch(\n            \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n          ).then(r => r.json()),\n        }),\n        connection: {\n          host: \"https://shopping-be.wrtn.ai\",\n          headers: {\n            Authorization: \"Bearer *****\",\n          },\n        },\n      },\n      {\n        protocol: \"class\",\n        name: \"counselor\",\n        application: \n          typia.llm.application<ShoppingCounselor, \"chatgpt\">(),\n        execute: new ShoppingCounselor(),\n      },\n      {\n        protocol: \"class\",\n        name: \"policy\",\n        application: \n          typia.llm.application<ShoppingPolicy, \"chatgpt\">(),\n        execute: new ShoppingPolicy(),\n      },\n      {\n        protocol: \"class\",\n        name: \"rag\",\n        application: \n          typia.llm.application<ShoppingSearchRag, \"chatgpt\">(),\n        execute: new ShoppingSearchRag(),\n      },\n    ],\n  });\n  await agent.conversate(\"I wanna buy MacBook Pro\");\n};\nmain().catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: Restoring Agentica Conversation History\nDESCRIPTION: This code snippet demonstrates how to restore the conversation state of an Agentica instance using prompt histories. It fetches the histories, creates a new Agentica instance with the `histories` property assignment, and then calls the `conversate()` function to continue the conversation.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/index.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, IAgenticaHistoryJson } from \"@agentica/core\";\n\nconst histories: IAgenticaHistoryJson[] = await getHistories();\nconst agent: Agentica<\"chatgpt\"> = new Agentica({\n  ...,\n  histories,\n});\nawait agent.conversate(\"Summarize what we have done please.\");\n```\n\n----------------------------------------\n\nTITLE: Creating a File System Agent with Agentica\nDESCRIPTION: This TypeScript code creates a File System Agent using Agentica, leveraging OpenAI's GPT model. It defines a class `FsClass` that wraps Node.js `fs` functions like `readdirSync`, `readFileSync`, and `writeFileSync`.  The agent exposes these functions for interaction via conversational prompts.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/coding/file-system.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport dotenv from \"dotenv\";\nimport fs from \"fs\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\ndotenv.config();\n\nconst openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n\nclass FsClass {\n  /**\n   * Indicates the current folder path.\n   *\n   * The directory name of the current module. This is the same as the\n   * `path.dirname()` of the `__filename`.\n   * @since v0.1.27\n   *\n   * @returns dirname\n   */\n  async __dirname(): Promise<string> {\n    return __dirname;\n  }\n\n  /**\n   * Reads the contents of the directory.\n   *\n   * See the POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more details.\n   *\n   * The optional `options` argument can be a string specifying an encoding, or an\n   * object with an `encoding` property specifying the character encoding to use for\n   * the filenames returned. If the `encoding` is set to `'buffer'`,\n   * the filenames returned will be passed as `Buffer` objects.\n   *\n   * If `options.withFileTypes` is set to `true`, the result will contain `fs.Dirent` objects.\n   * @since v0.1.21\n   */\n  async readdirSync(input: {\n    path: string;\n    options?:\n      | {\n          encoding: \"utf-8\";\n          withFileTypes?: false | undefined;\n          recursive?: boolean | undefined;\n        }\n      | \"utf-8\"\n      | null;\n  }): Promise<string[]> {\n    return fs.readdirSync(input.path, input.options);\n  }\n\n  /**\n   * Returns the contents of the `path`.\n   *\n   * For detailed information, see the documentation of the asynchronous version of\n   * this API: {@link readFile}.\n   *\n   * If the `encoding` option is specified then this function returns a\n   * string. Otherwise it returns a buffer.\n   *\n   * Similar to {@link readFile}, when the path is a directory, the behavior of\n   * `fs.readFileSync()` is platform-specific.\n   *\n   * @example\n   * import { readFileSync } from 'fs';\n   *\n   * // macOS, Linux, and Windows\n   * readFileSync('<directory>');\n   * // => [Error: EISDIR: illegal operation on a directory, read <directory>]\n   *\n   * //  FreeBSD\n   * readFileSync('<directory>'); // => <data>\n   *\n   * @since v0.1.8\n   * @param path filename\n   */\n  async readFileSync(input: { path: string }): Promise<string> {\n    return fs.readFileSync(input.path, { encoding: \"utf-8\" }) as string;\n  }\n\n  /**\n   * Writes data to the specified file.\n   *\n   * The `mode` option only affects the newly created file. See {@link open} for more details.\n   *\n   * For detailed information, see the documentation of the asynchronous version of\n   * this API: {@link writeFile}.\n   * @since v0.1.29\n   * @param file filename or file descriptor\n   */\n  async writeFileSync(input: { file: string; data: string }): Promise<void> {\n    return fs.writeFileSync(input.file, input.data);\n  }\n}\n\nexport const FileSystemAgent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: openai,\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"File Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<FsClass, \"chatgpt\">(),\n      execute: new FsClass(),\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Agentica: HTTP Authorization Header Configuration in Typescript\nDESCRIPTION: This code snippet illustrates how to configure authorization headers for an HTTP connection in Agentica. The `connection.headers` property within the controller configuration is used to specify the authorization details, enabling access to the HTTP server. This snippet focuses on lines 25-30 to show the authorization configuration.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/controller/swagger.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Agentica,\n  IAgenticaController,\n  assertHttpLlmApplication\n} from \"@agentica/core\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      protocol: \"http\",\n      name: \"shopping\",\n      application: assertHttpLlmApplication({\n        model: \"chatgpt\",\n        document: await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n        ).then((r) => r.json()),\n      }),\n      connection: {\n        host: \"https://shopping-be.wrtn.ai\",\n        headers: {\n          Authorization: \"Bearer ********\",\n        },\n      },\n    } satisfies IAgenticaController.IHttp<\"chatgpt\">,\n  ],\n});\nawait agent.conversate(\"What you can do?\");\n```\n\n----------------------------------------\n\nTITLE: OpenAPI Specification Flowchart\nDESCRIPTION: This Mermaid flowchart illustrates the conversion process from various OpenAPI specifications (Swagger v2.0, OpenAPI v3.0, v3.1) to LLM Function Calling schemas. It shows how `@samchon/openapi` converts Swagger/OpenAPI documents to a normalized OpenAPI v3.1 emended specification, which is then transformed into specific LLM function calling schemas for OpenAI (ChatGPT), Anthropic (Claude), Google (Gemini), and Meta (Llama).\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/concepts/function-calling.mdx#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart\n  subgraph \"OpenAPI Specification\"\n    v20(\"Swagger v2.0\") --upgrades--> emended[[\"OpenAPI v3.1 (emended)\"]]\n    v30(\"OpenAPI v3.0\") --upgrades--> emended\n    v31(\"OpenAPI v3.1\") --emends--> emended\n  end\n  subgraph \"OpenAPI Generator\"\n    emended --normalizes--> migration[[\"Migration Schema\"]]\n    migration --\"Artificial Intelligence\"--> lfc{{\"LLM Function Calling\"}}\n    lfc --\"OpenAI\"--> chatgpt(\"ChatGPT\")\n    lfc --\"Anthropic\"--> claude(\"Claude\")\n    lfc --\"Google\"--> gemini(\"Gemini\")\n    lfc --\"Meta\"--> llama(\"Llama\")\n  end\n```\n\n----------------------------------------\n\nTITLE: Defining Calculator Functions in TypeScript\nDESCRIPTION: This code defines a `Calculator` namespace with `add` and `sub` functions, including interfaces for their respective parameters. It demonstrates the required format for Agentica functions, including a single object parameter and detailed JSDoc comments. The functions can be executed within a React Native environment.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/react-native/calendar.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * A basic calculator that performs addition and subtraction operations.\n */\nnamespace Calculator {\n  /**\n   * Parameters for addition operation\n   */\n  interface AddProps {\n    /**\n     * First number to add\n     */\n    a: number;\n    /**\n     * Second number to add\n     */\n    b: number;\n  }\n\n  /**\n   * Parameters for subtraction operation\n   */\n  interface SubProps {\n    /**\n     * Number to subtract from\n     */\n    a: number;\n    /**\n     * Number to subtract\n     */\n    b: number;\n  }\n\n  /**\n   * Adds two numbers together.\n   * @returns The sum of two numbers\n   */\n  export function add(props: AddProps): number {\n    return props.a + props.b;\n  }\n\n  /**\n   * Subtracts the second number from the first number.\n   * @returns The result of subtracting the second number from the first number\n   */\n  export function sub(props: SubProps): number {\n    return props.a - props.b;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Agent Configuration with NestJS\nDESCRIPTION: This TypeScript code snippet demonstrates the configuration of an Agentica agent within a NestJS controller. It sets up an agent that uses tool calling to a localhost endpoint, fetching the API definition from a Swagger file.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/index.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// server/src/controllers/chat/ChatController.ts\n@Controller(\"chat\")\nexport class MyChatController {\n  @WebSocketRoute()\n  public async start(\n    @WebSocketRoute.Acceptor()\n    acceptor: WebSocketAcceptor<\n      undefined,\n      IAgenticaRpcService<\"chatgpt\">,\n      IAgenticaRpcListener\n    >\n  ): Promise<void> {\n    const agent: Agentica<\"chatgpt\"> = new Agentica({\n      model: \"chatgpt\",\n      vendor: {\n        api: new OpenAI({ apiKey: MyGlobal.env.OPENAI_API_KEY }),\n        model: \"gpt-4o-mini\",\n      },\n      controllers: [\n        {\n          protocol: \"http\",\n          name: \"bbs\",\n          application: assertHttpLlmApplication({\n            model: \"chatgpt\",\n            document: await fetch(\n              `http://localhost:${MyConfiguration.API_PORT()}/editor/swagger.json`\n            ).then((r) => r.json()),\n          }),\n          connection: {\n            host: `http://localhost:${MyConfiguration.API_PORT()}`,\n            headers: {\n              Authorization: \"Bearer *****\",\n            },\n          },\n        },\n      ],\n    });\n    const service: AgenticaRpcService<\"chatgpt\"> = new AgenticaRpcService({\n      agent,\n      listener: acceptor.getDriver(),\n    });\n    await acceptor.accept(service);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configure Environment Variables\nDESCRIPTION: This example shows the required environment variables to be set in a `.env` file.  It includes the OpenAI API key and the SerpApi API key.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-shopping.mdx#_snippet_2\n\nLANGUAGE: env\nCODE:\n```\nOPENAI_API_KEY=your_openai_api_key\nSERP_API_KEY=serp_api_key\n```\n\n----------------------------------------\n\nTITLE: Client WebSocket Connection and Conversation (TypeScript)\nDESCRIPTION: This TypeScript code establishes a WebSocket connection to a server using `tgrid` and initiates a conversation using the `AgenticaRpcService`. It defines a WebSocketConnector with handlers for 'text' and 'describe' events, logs the received role and text or description and connects to the server. Then, gets a driver for the `AgenticaRpcService` to start the conversation.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/index.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IAgenticaRpcListener, IAgenticaRpcService } from \"@agentica/rpc\";\nimport { Driver, WebSocketConnector } from \"tgrid\";\n\nconst connector: WebSocketConnector<\n  null,\n  IAgenticaRpcListener<\"chatgpt\">,\n  IAgenticaRpcService<\"chatgpt\">\n> = new WebSocketConnector(null, {\n  text: async (evt) => {\n    console.log(evt.role, evt.text);\n  },\n  describe: async (evt) => {\n    console.log(\"describer\", evt.text);\n  },\n});\nawait connector.connect(\"ws://localhost:3001\");\n\nconst driver: Driver<IAgenticaRpcService<\"chatgpt\">> = \n  connector.getDriver();\nawait driver.conversate(\"Hello, what you can do?\");\n```\n\n----------------------------------------\n\nTITLE: Google API Credentials\nDESCRIPTION: This shows the required Google API credentials that need to be configured in the `.env` file to properly use the Gmail connector. The variables include the OpenAI API key, Gmail Client ID, Gmail Client Secret, and Gmail Refresh Token.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/gmail.mdx#_snippet_2\n\nLANGUAGE: env\nCODE:\n```\nOPENAI_API_KEY=your-openai-api-key\nGMAIL_CLIENT_ID=your-gmail-client-id\nGMAIL_CLIENT_SECRET=your-gmail-client-secret\nGMAIL_REFRESH_TOKEN=your-gmail-refresh-token\n```\n\n----------------------------------------\n\nTITLE: Agentica Class Definition\nDESCRIPTION: Defines the `Agentica` class with a generic type `Model` constrained to `ILlmSchema.Model`. This class serves as a facade for interacting with an AI chatbot, managing conversations, events, history, and token usage. It utilizes TypeScript generics for specifying the LLM model.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport class Agentica<Model extends ILlmSchema.Model> {\n  /**\n   * Initializer constructor.\n   *\n   * @param props Properties to construct the agent\n   */\n  public constructor(private readonly props: IAgenticaProps<Model>);\n\n  /**\n   * Conversate with the A.I. chatbot.\n   *\n   * User talks to the A.I. chatbot with the content.\n   *\n   * When the user's conversation implies the A.I. chatbot to execute a\n   * function calling, the returned chat prompts will contain the\n   * function calling information like {@link AgenticaHistory.Execute}.\n   *\n   * @param content The content to talk\n   * @returns List of newly created chat prompts\n   */\n  public async conversate(content: string): Promise<AgenticaHistory<Model>[]>;\n\n  /**\n   * Add an event listener.\n   *\n   * Add an event listener to be called whenever the event is emitted.\n   *\n   * @param type Type of event\n   * @param listener Callback function to be called whenever the event is emitted\n   */\n  public on<Type extends AgenticaEvent.Type>(\n    type: Type,\n    listener: (\n      event: AgenticaEvent.Mapper<Model>[Type],\n    ) => void | Promise<void>,\n  ): this;\n\n  /**\n   * Erase an event listener.\n   *\n   * Erase an event listener to stop calling the callback function.\n   *\n   * @param type Type of event\n   * @param listener Callback function to erase\n   */\n  public off<Type extends AgenticaEvent.Type>(\n    type: Type,\n    listener: (\n      event: AgenticaEvent.Mapper<Model>[Type],\n    ) => void | Promise<void>,\n  ): this;\n\n  /**\n   * Get the chatbot's prompt histories.\n   *\n   * Get list of chat prompts that the chatbot has been conversated.\n   *\n   * @returns List of chat prompts\n   */\n  public getHistories(): AgenticaHistory<Model>[];\n\n  /**\n   * Get token usage of the A.I. chatbot.\n   *\n   * Entire token usage of the A.I. chatbot during the conversating\n   * with the user by {@link conversate} method callings.\n   *\n   * @returns Cost of the A.I. chatbot\n   */\n  public getTokenUsage(): AgenticaTokenUsage;\n}\n```\n\n----------------------------------------\n\nTITLE: Authenticating and Initializing Agentica with Shopping API\nDESCRIPTION: This snippet demonstrates authenticating against the @samchon/shopping-api backend before constructing the Agentica instance. It uses the ShoppingApi.functional methods to authenticate a customer and activate their account. After authentication, the Agentica instance is initialized with the authenticated connection object.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/enterprise/shopping.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport ShoppingApi from \"@samchon/shopping-api\";\nimport OpenAI from \"openai\";\n\n// Authentication to the shopping backend server\nconst connection: ShoppingApi.IConnection = {\n  host: \"https://shopping-be.wrtn.ai\",\n};\nawait ShoppingApi.functional.shoppings.customers.authenticate.create(\n  connection,\n  {\n    channel_code: \"samchon\",\n    external_user: null,\n    href: window.location.href,\n    referrer: window.document.referrer,\n  },\n);\nawait ShoppingApi.functional.shoppings.customers.authenticate.activate(\n  connection,\n  {\n    mobile: \"010-1234-5678\",\n    name: \"John Doe\",\n  },\n);\n\n// Bearer ********\n// Nestia SDK injected the Authorization header\nconsole.log(connection.headers?.Authorization);\n\n// Agentica with authenticated connection\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    model: \"gpt-4o-mini\",\n    api: new OpenAI({ apiKey: \"********\" }),\n  },\n  controllers: [\n    {\n      protocol: \"http\",\n      name: \"shopping\",\n      application: assertHttpLlmApplication({\n        model: \"chatgpt\",\n        document: await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n        ).then((res) => res.json()),\n      }),\n      connection,\n    }\n  ],\n});\nawait agent.convert(\"I wanna buy a Macbook.\");\n```\n\n----------------------------------------\n\nTITLE: JSON Expected Result for Shopping Scenario\nDESCRIPTION: This JSON represents the expected sequence of API calls that an agent should make in response to the user prompt. It outlines operations for listing sales, retrieving sale details, creating cart commodities, creating orders (with or without a shopping cart), and publishing orders. The description for each operation provides contextual information on its purpose and usage.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/README.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": [\n            {\n              \"type\": \"standalone\",\n              \"operation\": {\n                \"name\": \"shoppings_customers_carts_commodities_create\",\n                \"description\": \"Create a new commodity.\\n\\nCreate a new {@link IShoppingCartCommodity commodity} into a specific\\nshopping cart.\\n\\nIf {@link IShoppingCartCommodity.ICreate.accumulate} has `true` value\\nand there's some same commodity that composed with same\\n{@link IShoppingSaleUnitStock.IInvert stocks and quantities},\\nthen new commodity would not be created but the volume would be accumulated.\\n\\nBy the way, if the target {@link IShoppingSale sale} has been suspended or\\n{@link IShoppingSaleUnitStockInventory out of stock}, then 410 gone error\\nwould be thrown. Therefore, it would better to check the target sale and\\n{@link IShoppingSaleUnitStock stock}'s status before.\"\n              }\n            },\n            {\n              \"type\": \"standalone\",\n              \"operation\": {\n                \"name\": \"shoppings_customers_orders_create\",\n                \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n              }\n            }\n          ]\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Typia: LLM Application Example (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use `typia.llm.application<Class, Model>()` to generate an LLM function calling schema from a TypeScript class. The compiler analyzes the source code of the class and automatically creates the necessary schemas.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/concepts/compiler-driven-development.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nJYWwDg9gTgLgBAbzgSQDIBsQEExncAYwEMZgIA7OAXzgDMoIQ4AiAAQGciQCALCgeghgApuSJhgzANwAoUJFhwYATwlEANIiVEA5u2p0GTZirXSZMghXbxxYAFwoM2XPmKkKAHma8SOsDDMAHxwALxKqsBEAHTomNF2biRk5J4ycHAAQgBG7FiwhOjCAMrCUABuhMLq6Sy+MP6BMkEAFACUslbk7BBFsRA6LXYdFsDkMGW0RATCWbn5pARFpRVViLX8AFSbtXCbcADiwrZxcEQFS8Ls0bs7GXtwqMA2cACuYHDC5WXKZxdF+nOvGA3wAJnAxkoeLNMplinAACKZG73O4ZfasKDHV5QbqPZ7wCC0T7fKC-c6LAG3fi1Mag4QAD3ajmQOTy-2EAG0ALqyOAbba3OAAYSxJFmRDg5GEAHc-pThCj0UKAOpQYATQFS2XywoS8jgoE8EFXCHwMYwCBQ2ZIpV7IWsMDnLhwMAMMD6AAK7rKpFNRLgBDFEzor3IBA85AdWJgOLxADlZehfkHhOLDRzqbVU+KWm6hOxHAhdnAtmjUShyLRoCBkhQ4AGYNDdZclFacxMS3safcIeQwK8YCy2Qs9dFkKK0xM+dQ2sP5hy+QLy-sAKpgUHis6UClj25C9ebzXbltFOAyjU8bVyroTcZ2ldwR3Opj5j1wb1CX3Af3E95H2ZaDDCMUgdJ0oBdMYB3gRMbwoO94EtN4N3FLMMn-XM30LdZezLLt9gAFXOHRjlPYQAHJ9AQVh8HIABrFARw5aJgFBKg7XRHt7lYxwbHVcgdDgAAybQ9GiAAxGsSG8V5XlY4Il1wwVeweWDA3g0REKtDCJg47sSygwd53ZBVx0PcUZyoOc4HKCBWMU0tlPROAAFEIPYfUyIfIU3KIDzAR3DlDEYa1EWRfcK2fCDX3dL0fQKX9PncwDgMjNCkr84Q81iosSzwlTCOI0jd0uSjEBosYGNZBdTNY9j8K4jIeLgPixkEkSYF0a5JKgWsYBkuTQQU2orMcWz7JkKgLHy-ZR1bTSNWUFE7n2AADaqTL1VaIQCz5xkWuAsTdK4FoEk8SrPSEmxhOE4BaTJXjiY5IUyCBznBYplBsYQQDaZaaQtSZplmDa5rPRk71BfRQeYidg1mYsMny5zvVAc5fgAaWEJb0ua1qzo6rqJKk-rmFk+Sggc5GHknOtKFIEBZkbZsLsVdKO2EUEAH0SF4mB+Pa0TupJ7wAIAWgZ4Rhv5JGnIeVA-PgHTOaUUAmeJa6vPS5Xud5lr+ba4SheJ3rpOYcXJeGqaxEZ9gnRmRiar1HDHMfZAqxJlIGw1lmgqQjmHy4xkFHNcYgYduGpwRvK5ecgiNTPZmJWY-D8LgAAlYRjo88Zkm+VWYETn3k9MhqS1IQvhD5gWHNl8tnOFDTxjgbIIFBHGCrTxuw+b1v2+90LWfPdUYBgSgrubWsoDo0EIBlShq1NmA9M2RqW7b5Rq7a2vXbTgieFeEBsjEYB0AhWsSLgVd0+QFe94Po+T7PtHL+v5Bz2NXhAyISgjqxHPEK+1Lp3AqKBiRdFoMAHQOIVZ+TgKtcgj10CrU0BqOAjMf76CbCQKUVomyH2PkQU+59dCzAniXPcBU174MfkQ9A9guxwAAD5SiQYwlhLR8aC06mJHqfUZLqmCEbHh1xu4IQALKcyiARVQwhvAv2EFsYIIwMhTRlrvCs7tF59S9knMibZkIAW8hWAA8uQZMoVIFPXBG+b8poLynGyLMHWgdajB2gIhWRKBzIhnCJ6XcRB0CeEjuKSmk0gA\n```\n\n----------------------------------------\n\nTITLE: Initializing LLM Application Definition\nDESCRIPTION: This code snippet initializes the LLM application with a specified model ('chatgpt'), options (reference, strict, separate), and an array of functions. It imports necessary modules from the 'typia' library for validation and format checking.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/LlmApplicationJavaScriptSnippet.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__validateReport from \"typia/lib/internal/_validateReport.js\";\nimport * as __typia_transform__isFormatUri from \"typia/lib/internal/_isFormatUri.js\";\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport typia from \"typia\";\nconst app = {\n  model: \"chatgpt\",\n  options: {\n    reference: false,\n    strict: false,\n    separate: null,\n  },\n  functions: [\n```\n\n----------------------------------------\n\nTITLE: Generated Gemini Parameters Schema\nDESCRIPTION: This JavaScript code shows the JSON schema generated for Gemini parameters, including properties like 'id', 'age', and 'email' with their descriptions and types. Notice how the format constraints are included in the description since Gemini does not directly support the `format` constraint.  This schema is used for LLM function calling.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/vendor.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\n({\n  description: \"\",\n  type: \"object\",\n  properties: {\n    id: {\n      title: \"Primary Key\",\n      description:\n        \"Primary Key.\\n\\nPrimary Key generated by System.\\n\\n\\n@format uuid\",\n      type: \"string\",\n    },\n    age: {\n      title: \"Age of the user\",\n      description:\n        \"Age of the user.\\n\\nAge of the user in years.\\n\\n\\n@minimum 0\\n@maximum 100\",\n      type: \"integer\",\n    },\n    email: {\n      title: \"Email address of the user\",\n      description:\n        \"Email address of the user.\\n\\nEmail address written when membership joining.\\n\\n\\n@format email\",\n      type: \"string\",\n    },\n  },\n  required: [\"id\", \"age\", \"email\"],\n  additionalProperties: false,\n  $defs: {},\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Github Agent with Agentica\nDESCRIPTION: This TypeScript code initializes a Github Agent using Agentica. It imports necessary modules, configures OpenAI and Github services, and sets up the agent with the Github Connector controller.  It uses dotenv to load environment variables for API keys and access tokens.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/coding/github.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport { GithubService } from \"@wrtnlabs/connector-github\";\nimport dotenv from \"dotenv\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\ndotenv.config();\n\nconst openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n\nexport const GithubAgent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: openai,\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"Github Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<GithubService, \"chatgpt\">(),\n      execute: new GithubService({\n        secret: process.env.GITHUB_ACCESS_TOKEN!,\n      }),\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Generated Agent Code\nDESCRIPTION: This TypeScript code configures an Agentica agent to use the Google Scholar Connector. It imports necessary libraries, initializes the agent with OpenAI and Google Scholar services, and sets up the controller to execute Google Scholar queries.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-scholar.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\nimport dotenv from \"dotenv\";\nimport { OpenAI } from \"openai\";\n\nimport { GoogleScholarService } from \"@wrtnlabs/connector-google-scholar\";\n\ndotenv.config();\n\nconst agent: Agentica<\"chatgpt\"> = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: process.env.OPENAI_API_KEY! }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"Google Scholar Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<GoogleScholarService, \"chatgpt\">(),\n      execute: new GoogleScholarService({\n        serpApiKey: process.env.SERP_API_KEY!,\n      }),\n    },\n  ],\n});\n\nconst main = async () => {\n  console.log(await agent.conversate(\"What can you do?\"));\n};\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Defining LLM parameters for ChatGPT using typia\nDESCRIPTION: This TypeScript code snippet defines parameters for the ChatGPT model using the `typia` library. It specifies the types and constraints (tags) for user data fields such as `id` (UUID format), `age` (uint32 with maximum value 100), and `email` (email format). This demonstrates how to define schemas for LLM function calling.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/vendor.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\ntypia.llm.parameters<{ /**\n   * Primary Key.\n   * \n   * Primary Key generated by System.\n   */ id: string & tags.Format<\"uuid\">; /**\n   * Age of the user.\n   * \n   * Age of the user in years.\n   */ age: number & tags.Type<\"uint32\"> & tags.Maximum<100>; /**\n   * Email address of the user.\n   * \n   * Email address written when membership joining.\n   */ email: string & tags.Format<\"email\">; }, \"chatgpt\">();\n```\n\n----------------------------------------\n\nTITLE: Generating Frontend Components from Swagger/OpenAPI\nDESCRIPTION: This snippet explains how to generate frontend components from a Swagger/OpenAPI document using `HttpLlm.application()` to convert the document to LLM function calling schemas and then feeding it to `AutoViewAgent`. It demonstrates finding a specific API function and generating the corresponding frontend component.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/related/autoview.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AutoViewAgent } from \"@autoview/agent\";\nimport { OpenApi } from \"@samchon/openapi\";\nimport fs from \"fs\";\nimport OpenAI from \"openai\";\nimport typia, { tags } from \"typia\";\n\nconst app: IHttpLlmApplication<\"chatgpt\"> = HttpLlm.application({\n  model: \"chatgpt\",\n  document,\n  options: {\n    reference: true,\n  },\n});\nconst func: IHttpLlmFunction<\"chatgpt\"> | undefined = app.functions.find(\n  (func) =>\n    func.path === \"/shoppings/customers/sales/{id}\" && \n    func.method === \"get\",\n);\nif (func === undefined) throw new Error(\"Function not found\");\nelse if (func.output === undefined) throw new Error(\"No return type\");\n\nconst agent: AutoViewAgent = new AutoViewAgent({\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"o3-mini\",\n  },\n  inputSchema: {\n    $defs: func.parameters.$defs,\n    schema: func.output!,\n  },\n  transformFunctionName: \"transformSale\",\n});\nconst result: IAutoViewResult = await agent.generate();\n\nawait fs.promises.writeFile(\n  \"./src/transformers/transformSale.ts\",\n  result.typescript,\n  \"utf8\",\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with Controllers\nDESCRIPTION: This code snippet demonstrates how to initialize an Agentica instance with both HTTP server and TypeScript class controllers. It shows how to define the controllers, configure the connection to the HTTP server, and provide the class instance for the TypeScript class controller. It also shows how to configure the executor selector as a vector selector of the plugin.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/index.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport { AgenticaPgVectorSelector } from \"@agentica/pg-vector-selector\";\nimport typia from \"typia\";\n\nconst main = async (): Promise<void> => {\n  const agent = new Agentica({\n    model: \"chatgpt\",\n    vendor: {\n      api: new OpenAI({ apiKey: \"*****\" }),\n      model: \"gpt-4o-mini\",\n    },\n    controllers: [\n      {\n        protocol: \"http\",\n        name: \"shopping\",\n        application: assertHttpLlmApplication({\n          model: \"chatgpt\",\n          document: await fetch(\n            \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n          ).then((r) => r.json()),\n        }),\n        connection: {\n          host: \"https://shopping-be.wrtn.ai\",\n          headers: {\n            Authorization: \"Bearer *****\",\n          },\n        },\n      },\n      {\n        protocol: \"class\",\n        name: \"counselor\",\n        application: \n          typia.llm.application<ShoppingCounselor, \"chatgpt\">(),\n        execute: new ShoppingCounselor(),\n      },\n      {\n        protocol: \"class\",\n        name: \"policy\",\n        application: \n          typia.llm.application<ShoppingPolicy, \"chatgpt\">(),\n        execute: new ShoppingPolicy(),\n      },\n      {\n        protocol: \"class\",\n        name: \"rag\",\n        application: \n          typia.llm.application<ShoppingSearchRag, \"chatgpt\">(),\n        execute: new ShoppingSearchRag(),\n      },\n    ],\n    config: {\n      executor: {\n        select: AgenticaPgVectorSelector.boot<\"chatgpt\">\n          ('https://your-connector-hive-server.com')\n        ,\n      },\n    },\n  });\n  await agent.conversate(\"I wanna buy MacBook Pro\");\n};\nmain().catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: Agentica Initialization with Controllers\nDESCRIPTION: This code snippet demonstrates the initialization of an Agentica instance with multiple controllers, including HTTP and class-based protocols. It utilizes typia for LLM application definition and OpenAI for API interaction, showcasing a comprehensive agent configuration.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/index.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport { AgenticaPgVectorSelector } from \"@agentica/pg-vector-selector\";\nimport typia from \"typia\";\n\nconst main = async (): Promise<void> => {\n  const agent = new Agentica({\n    model: \"chatgpt\",\n    vendor: {\n      api: new OpenAI({ apiKey: \"*****\" }),\n      model: \"gpt-4o-mini\",\n    },\n    controllers: [\n      {\n        protocol: \"http\",\n        name: \"shopping\",\n        application: assertHttpLlmApplication({\n          model: \"chatgpt\",\n          document: await fetch(\n            \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n          ).then((r) => r.json()),\n        }),\n        connection: {\n          host: \"https://shopping-be.wrtn.ai\",\n          headers: {\n            Authorization: \"Bearer *****\",\n          },\n        },\n      },\n      {\n        protocol: \"class\",\n        name: \"counselor\",\n        application: \n          typia.llm.application<ShoppingCounselor, \"chatgpt\">(),\n        execute: new ShoppingCounselor(),\n      },\n      {\n        protocol: \"class\",\n        name: \"policy\",\n        application: \n          typia.llm.application<ShoppingPolicy, \"chatgpt\">(),\n        execute: new ShoppingPolicy(),\n      },\n      {\n        protocol: \"class\",\n        name: \"rag\",\n        application: \n          typia.llm.application<ShoppingSearchRag, \"chatgpt\">(),\n        execute: new ShoppingSearchRag(),\n      },\n    ],\n    config: {\n      executor: {\n        select: AgenticaPgVectorSelector.boot<\"chatgpt\">\n          ('https://your-connector-hive-server.com')\n        ,\n      },\n    },\n  });\n  await agent.conversate(\"I wanna buy MacBook Pro\");\n};\nmain().catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: Create Google Shopping Agent with Agentica\nDESCRIPTION: This TypeScript code creates a Google Shopping Agent using Agentica. It imports necessary modules, configures OpenAI, and sets up the agent with the Google Shopping connector.  It requires the `@agentica/core`, `@wrtnlabs/connector-google-shopping`, `dotenv`, `openai`, and `typia` packages, as well as setting the OPENAI_API_KEY and SERP_API_KEY environment variables.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-shopping.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport { GoogleShoppingService } from \"@wrtnlabs/connector-google-shopping\";\nimport dotenv from \"dotenv\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\ndotenv.config();\n\nconst openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n\nexport const GoogleShoppingAgent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: openai,\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"Google Shopping Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<GoogleShoppingService, \"chatgpt\">(),\n      execute: new GoogleShoppingService({\n        apiKey: process.env.SERP_API_KEY!,\n      }),\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: NodeJS WebSocket Server Setup (TypeScript)\nDESCRIPTION: This TypeScript code sets up a WebSocket server using `tgrid` and integrates it with `AgenticaRpcService`. It creates a WebSocketServer, opens it on port 3001, and defines an acceptor function. Inside the acceptor, it instantiates an Agentica agent and AgenticaRpcService, then accepts the service.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/index.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport {\n  AgenticaRpcService,\n  IAgenticaRpcListener,\n  IAgenticaRpcService,\n} from \"@agentica/rpc\";\nimport { WebSocketServer } from \"tgrid\";\n\nconst server: WebSocketServer<\n  null,\n  IAgenticaRpcService<\"chatgpt\">,\n  IAgenticaRpcListener<\"chatgpt\">\n> = new WebSocketServer();\nawait server.open(3_001, async (acceptor) => {\n  const agent: Agentica<\"chatgpt\"> = new Agentica({ ... });\n  const service: AgenticaRpcService<\"chatgpt\"> = \n    new AgenticaRpcService({\n      agent,\n      listener: acceptor.getDriver(),\n    });\n  await acceptor.accept(service);\n});\n```\n\n----------------------------------------\n\nTITLE: Listening for Request Event in Agentica\nDESCRIPTION: This code snippet demonstrates how to listen for the 'request' event in an Agentica agent. The 'request' event is triggered when Agentica makes a request to the OpenAI API. The code allows modifying the request body before it is sent. It requires the `@agentica/core` and `openai` packages.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/event.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, AgenticaEvent } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [...],\n});\nagent.on(\"request\", async (event) => {\n  event.body = await emendRequestBody(event.body)\n});\nawait agent.conversate(\"I wanna buy Surface Pro\");\n```\n\n----------------------------------------\n\nTITLE: Shopping Sale Controller Definition in Typescript\nDESCRIPTION: Defines an abstract ShoppingSaleController using NestJS and the @nestia/core library. It includes methods for listing summarized sales (index) and retrieving a sale with detailed information (at). The controller utilizes an AuthGuard and TypedRoute decorators for authentication and route handling respectively. It returns paginated sales data and detailed sale information.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/enterprise/shopping.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport core from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport { RouteIcon } from \"@wrtnio/decorators\";\nimport { tags } from \"typia\";\n \nimport { IPage } from \"@samchon/shopping-api/lib/structures/common/IPage\";\nimport { IShoppingActorEntity } from \"@samchon/shopping-api/lib/structures/shoppings/actors/IShoppingActorEntity\";\nimport { IShoppingSale } from \"@samchon/shopping-api/lib/structures/shoppings/sales/IShoppingSale\";\n \nimport { ShoppingSaleProvider } from \"../../../../providers/shoppings/sales/ShoppingSaleProvider\";\nimport { IShoppingControllerProps } from \"../IShoppingControllerProps\";\n \nexport function ShoppingSaleController<Actor extends IShoppingActorEntity>(\n  props: IShoppingControllerProps,\n) {\n  @Controller(`shoppings/${props.path}/sales`)\n  abstract class ShoppingSaleController {\n    /**\n     * List up every summarized sales.\n     *\n     * List up every {@link IShoppingSale.ISummary summarized sales}.\n     *\n     * As you can see, returned sales are summarized, not detailed. It does not\n     * contain the SKU (Stock Keeping Unit) information represented by the\n     * {@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\n     * If you want to get such detailed information of a sale, use\n     * `GET /shoppings/customers/sales/{id}` operation for each sale.\n     *\n     * > If you're an A.I. chatbot, and the user wants to buy or compose\n     * > {@link IShoppingCartCommodity shopping cart} from a sale, please\n     * > call the `GET /shoppings/customers/sales/{id}` operation at least once\n     * > to the target sale to get detailed SKU information about the sale.\n     * > It needs to be run at least once for the next steps.\n     *\n     * @param input Request info of pagination, searching and sorting\n     * @returns Paginated sales with summarized information\n     * @tag Sale\n     *\n     * @author Samchon\n     */\n    @RouteIcon(\n      \"https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icons/store.svg\",\n    )\n    @core.TypedRoute.Patch()\n    public async index(\n      @props.AuthGuard() actor: Actor,\n      @core.TypedBody() input: IShoppingSale.IRequest,\n    ): Promise<IPage<IShoppingSale.ISummary>> {\n      return ShoppingSaleProvider.index({\n        actor,\n        input,\n      });\n    }\n \n    /**\n     * Get a sale with detailed information.\n     *\n     * Get a {@link IShoppingSale sale} with detailed information including\n     * the SKU (Stock Keeping Unit) information represented by the\n     * {@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\n     *\n     * > If you're an A.I. chatbot, and the user wants to buy or compose a\n     * > {@link IShoppingCartCommodity shopping cart} from a sale, please call\n     * > this operation at least once to the target sale to get detailed SKU\n     * > information about the sale.\n     * >\n     * > It needs to be run at least once for the next steps. In other words,\n     * > if you A.I. agent has called this operation to a specific sale, you\n     * > don't need to call this operation again for the same sale.\n     * >\n     * > Additionally, please do not summarize the SKU information. Just show\n     * > the every options and stocks in the sale with detailed information.\n     *\n     * @param id Target sale's {@link IShoppingSale.id}\n     * @returns Detailed sale information\n     * @tag Sale\n     *\n     * @author Samchon\n     */\n    @core.TypedRoute.Get(\":id\")\n    public async at(\n      @props.AuthGuard() actor: Actor,\n      @core.TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\n    ): Promise<IShoppingSale> {\n      return ShoppingSaleProvider.at({\n        actor,\n        id,\n      });\n    }\n  }\n  return ShoppingSaleController;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Slack Agent with Agentica (TypeScript)\nDESCRIPTION: This TypeScript code defines an Agentica agent that uses OpenAI's GPT model and the SlackService connector to interact with Slack. It initializes the agent, configures the OpenAI API key, and sets up the Slack connector for sending messages and managing channels.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/slack.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\nimport dotenv from \"dotenv\";\nimport { OpenAI } from \"openai\";\n\nimport { SlackService } from \"@wrtnlabs/connector-slack\";\n\ndotenv.config();\n\nexport const agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY!,\n    }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"Slack Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<SlackService, \"chatgpt\">(),\n      execute: new SlackService(),\n    },\n  ],\n});\n\nconst main = async () => {\n  console.log(await agent.conversate(\"What can you do?\"));\n};\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for Github Agent\nDESCRIPTION: This configuration sets the environment variables required for the Github Agent.  It includes the OpenAI API key and the Github access token, ensuring secure access to the respective services. These variables are loaded by the dotenv library.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/coding/github.mdx#_snippet_2\n\nLANGUAGE: env\nCODE:\n```\nOPENAI_API_KEY=your-openai-api-key\nGITHUB_ACCESS_TOKEN=your-github-access-token\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with Typia in TypeScript\nDESCRIPTION: This snippet demonstrates how to initialize an Agentica agent with controllers, including a Swagger definition fetched from a remote URL and Typia LLM applications. It uses the `@agentica/core` library for agent creation and `typia` for LLM function calling capabilities. The code then starts a conversation with the agent.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/articles/typia-accomplished-agentic-ai-with-typescript-compiler-enhanced-function-calling.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\n\nconst agent = new Agentica({\n  controllers: [\n    await fetch(\n      \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n    ).then(r => r.json()),\n    typia.llm.application<ShoppingCounselor>(),\n    typia.llm.application<ShoppingPolicy>(),\n    typia.llm.application<ShoppingSearchRag>(),\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Generating Gemini Schema with typia\nDESCRIPTION: This TypeScript code uses the 'typia' library to generate a JSON schema specifically for Google Gemini. It defines a union type 'Shape' and interfaces 'Circle' and 'Rectangle', and then utilizes 'typia.llm.schema' to generate the Gemini-compatible schema. Gemini doesn't support union types directly.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/vendor.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\ntype Shape = Circle | Rectangle;\ninterface Circle {\n  type: \"circle\";\n  radius: number;\n}\ninterface Rectangle {\n  type: \"rectangle\";\n  width: number;\n  height: number;\n}\ntypia.llm.schema<Shape, \"gemini\">();\n```\n\n----------------------------------------\n\nTITLE: Agentica Vector Selector Basic Usage\nDESCRIPTION: This snippet demonstrates basic usage of the AgenticaVectorSelector. It initializes the vector selector and integrates it into an Agentica agent configuration, replacing the existing selector. The code shows how to define the agent's model, vendor, controllers, and how to configure the executor to use the vector selector.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/vector-selector.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport { AgenticaVectorSelector } from \"@agentica/vector-selector\";\nimport typia from \"typia\";\n\n// Initialize the vector selector\nconst selectorExecute = AgenticaVectorSelector.boot<\"chatgpt\">({\n  // Configuration options\n});\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    model: \"gpt-4o-mini\",\n    api: new OpenAI({\n      apiKey: process.env.CHATGPT_API_KEY,\n    }),\n  },\n  controllers: [\n    await fetch(\n      \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n    ).then(r => r.json()),\n    typia.llm.application<ShoppingCounselor>(),\n    typia.llm.application<ShoppingPolicy>(),\n    typia.llm.application<ShoppingSearchRag>(),\n  ],\n  config: {\n    executor: {\n      select: selectorExecute, // Replace the existing selector\n    }\n  }\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Listening for Call Event in Agentica\nDESCRIPTION: This code snippet demonstrates how to listen for the 'call' event in an Agentica agent. The 'call' event is triggered before a function is executed, allowing modification of arguments. The code checks if the operation's function has separated human-fillable arguments and merges them with the LLM-provided arguments. It depends on `@agentica/core`, `@samchon/openapi` and `openai`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/event.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, AgenticaEvent } from \"@agentica/core\";\nimport { ChatGptTypeChecker, HttpLlm, IChatGptSchema } from \"@samchon/openapi\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      type: \"http\",\n      application: HttpLlm.application({\n        model: \"chatgpt\",\n        document: await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\"\n        ),\n        options: {\n          separate: (schema: IChatGptSchema) =>\n            ChatGptTypeChecker.isString(schema) && schema.contentMediaType !== undefined,\n        },\n      }),\n    },\n  ],\n});\nagent.on(\"call\", async (event) => {\n  if (event.operation.function.separated?.human)\n    event.arguments = HttpLlm.mergeParameters({\n      function: event.operation.function,\n      llm: event.arguments,\n      human: await fillArguments(event.operation.function.separated.human)\n    });\n});\nawait agent.conversate(\"I wanna buy Surface Pro\");\n```\n\n----------------------------------------\n\nTITLE: NPM Installation of Agentica Core\nDESCRIPTION: This command installs the @agentica/core library along with its dependencies, @samchon/openapi and typia, using npm.  The subsequent command, npx typia setup, configures typia for TypeScript transformation.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/index.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @agentica/core @samchon/openapi typia\nnpx typia setup\n```\n\n----------------------------------------\n\nTITLE: Environment Variables for Reddit Agent\nDESCRIPTION: These environment variables are required for the Reddit agent to function correctly. They include the OpenAI API key, Reddit refresh token, Reddit client secret, and Reddit client ID. These variables are loaded using dotenv.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/reddit.mdx#_snippet_2\n\nLANGUAGE: env\nCODE:\n```\nOPENAI_API_KEY=your_openai_api_key\nREDDIT_SECRET=your_reddit_refresh_token\nREDDIT_CLIENT_SECRET=your_reddit_client_secret\nREDDIT_CLIENT_ID=your_reddit_client_id\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with Web Crawler Service\nDESCRIPTION: This TypeScript code initializes an Agentica agent with the WebCrawlerService. It imports necessary modules, configures the OpenAI API, and sets up the Web Crawler Connector with API keys from environment variables.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/crawler.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\nimport dotenv from \"dotenv\";\nimport OpenAI from \"openai\";\n\nimport { WebCrawlerService } from \"@wrtnlabs/connector-web-crawler\";\n\ndotenv.config();\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: process.env.OPENAI_API_KEY! }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"Web Crawler Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<WebCrawlerService, \"chatgpt\">(),\n      execute: new WebCrawlerService({\n        zenRowsApiKey: process.env.ZENROWS_API_KEY!,\n      }),\n    },\n  ],\n});\n\nconst main = async () => {\n  console.log(await agent.conversate(\"What can you do?\"));\n};\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Creating a new article with Swagger documentation in PHP\nDESCRIPTION: This code snippet defines a `BbsArticleController` class with a `create` method. The method is documented using Swagger (OpenAPI) annotations to describe the endpoint for creating a new article. The Swagger annotations define the request body (title, content, files) and the expected responses (success and failure). It takes a `Request` object as input, presumably containing the data for the new article.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/PhpLaravelSnippet.mdx#_snippet_0\n\nLANGUAGE: PHP\nCODE:\n```\n<?php\nclass BbsArticleController {\n  /**\n   * @OA\\Post(\n   *   path=\"/boards\",\n   *   tags={\"BBS\"},\n   *   summary=\"Create a new article\",\n   *   description=\"Create a new article with its first snapshot\",\n   *   @OA\\RequestBody(\n   *     description=\"Article information to create\",\n   *     required=true,\n   *     @OA\\MediaType(\n   *       mediaType=\"application/json\",\n   *       @OA\\Schema(\n   *         @OA\\Property(\n   *           property=\"title\",\n   *           type=\"string\",\n   *           description=\"Title of article\",\n   *         ),\n   *         @OA\\Property(\n   *           property=\"content\",\n   *           type=\"string\",\n   *           description=\"Content body of article\"\n   *         ),\n   *         @QA\\Property(\n   *           property=\"files\",\n   *           type=\"array\",\n   *           @QA\\Items(\n   *             @QA\\Schema(\n   *               @QA\\Property(\n   *                 property=\"name\",\n   *                 type=\"string\",\n   *                 maxLength=255,\n   *                 description=\"File name, except the extension\"\n   *               ),\n   *               @QA\\Property(\n   *                 property=\"extension\",\n   *                 type=\"string\",\n   *                 nullable=true,\n   *                 maxLength=8,\n   *                 description=\"File extension. If no extension, then set null\"\n   *               ),\n   *               @QA\\Property(\n   *                 property=\"url\",\n   *                 type=\"string\",\n   *                 format=\"url\",\n   *                 description=\"URL address that the file is located in\"\n   *               )\n   *             )\n   *           )\n   *         )\n   *       )\n   *     )\n   *   ),\n   *   @OA\\Response(response=\"200\", description=\"Success\"),\n   *   @OA\\Response(response=\"400\", description=\"Fail\")\n   * )\n   */\n  public function create(Request $request);\n}\n?>\n```\n\n----------------------------------------\n\nTITLE: Orchestration Sequence Diagram\nDESCRIPTION: This Mermaid sequence diagram illustrates the interactions between the User, Agent, Selector, Caller, and Describer components in the Agentica system. It shows the flow of conversation, function selection, calling, and result description.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/concepts/function-calling.mdx#_snippet_2\n\nLANGUAGE: Mermaid\nCODE:\n```\nsequenceDiagram\nactor User\nactor Agent\nparticipant Selector\nparticipant Caller\nparticipant Describer\nactivate User\nUser-->>Agent: Conversate:<br/>user says\nactivate Agent\nAgent->>Selector: Deliver conversation text\nactivate Selector\ndeactivate User\nNote over Selector: Select or remove candidate functions\nalt No candidate\n  Selector->>Agent: Talk like plain ChatGPT\n  deactivate Selector\n  Agent->>User: Conversate:<br/>agent says\n  activate User\n  deactivate User\nend\ndeactivate Agent\nloop Candidate functions exist\n  activate Agent\n  Agent->>Caller: Deliver conversation text\n  activate Caller\n  alt Contexts are enough\n    Note over Caller: Call fulfilled functions\n    Caller->>Describer: Function call histories\n    deactivate Caller\n    activate Describer\n    Describer->>Agent: Describe function calls\n    deactivate Describer\n    Agent->>User: Conversate:<br/>agent describes\n    activate User\n    deactivate User\n  else Contexts are not enough\n    break\n      Caller->>Agent: Request more information\n    end\n    Agent->>User: Conversate:<br/>agent requests\n    activate User\n    deactivate User\n  end\n  deactivate Agent\nend\n```\n\n----------------------------------------\n\nTITLE: JSON Structure for Order Processing\nDESCRIPTION: This JSON structure outlines the sequence of operations performed to process a user order. It includes fetching summarized sales, retrieving detailed product information, adding the most expensive stock to the shopping cart, creating an order, and publishing the order with payment and address information.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/2.success.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": [\n            {\n              \"type\": \"standalone\",\n              \"operation\": {\n                \"name\": \"shoppings_customers_carts_commodities_create\",\n                \"description\": \"Create a new commodity.\\n\\nCreate a new {@link IShoppingCartCommodity commodity} into a specific\\nshopping cart.\\n\\nIf {@link IShoppingCartCommodity.ICreate.accumulate} has `true` value\\nand there's some same commodity that composed with same\\n{@link IShoppingSaleUnitStock.IInvert stocks and quantities},\\nthen new commodity would not be created but the volume would be accumulated.\\n\\nBy the way, if the target {@link IShoppingSale sale} has been suspended or\\n{@link IShoppingSaleUnitStockInventory out of stock}, then 410 gone error\\nwould be thrown. Therefore, it would better to check the target sale and\\n{@link IShoppingSaleUnitStock stock}'s status before.\"\n              }\n            },\n            {\n              \"type\": \"standalone\",\n              \"operation\": {\n                \"name\": \"shoppings_customers_orders_create\",\n                \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n              }\n            }\n          ]\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Typia LLM Application Error Message in Bash\nDESCRIPTION: This snippet shows the error message generated by the Typescript compiler when using Typia's `llm.application` with an interface that violates LLM function calling rules. The error highlights issues with the `create` function's return type (union with undefined) and the `erase` function's parameter type (not an object).\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/controller/typescript.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsrc/examples/llm.application.violation.ts:4:41 - error TS(typia.llm.application): unsupported type detected    \n\n- BbsArticleController.create: unknown\n  - LLM application's function (\"create\")'s return type must not be union type with undefined.    \n\n- BbsArticleController.erase: unknown\n  - LLM application's function (\"erase\")'s parameter must be an object type.\n\n4 const app: ILlmApplication<\"chatgpt\"> = typia.llm.application<\n                                          ~~~~~~~~~~~~~~~~~~~~~~\n5   BbsArticleController,\n  ~~~~~~~~~~~~~~~~~~~~~~~\n6   \"chatgpt\"\n  ~~~~~~~~~~~\n7 >();\n  ~~~\n```\n\n----------------------------------------\n\nTITLE: Starting Agentica Github Agent Setup\nDESCRIPTION: This command initiates the Agentica setup wizard to create a Github Agent. The wizard guides the user through the installation process, package manager selection, controller selection, and API key entry.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/coding/github.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica start github-agent\n```\n\n----------------------------------------\n\nTITLE: Environment Variable Configuration\nDESCRIPTION: This example shows how to define environment variables within a `.env` file, including OpenAI API key and potentially other API keys, for secure and configurable application settings.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/index.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nOPENAI_API_KEY=YOUR_OPENAI_API_KEY\n\n# your api keys. for example, google, github, aws and so on.\nGOOGLE_API_KEY=YOUR_GOOGLE_API_KEY\n```\n\n----------------------------------------\n\nTITLE: WebSocket Client Setup (TypeScript)\nDESCRIPTION: Sets up a WebSocket client using tgrid and @agentica/rpc to connect to an Agentica server. It defines an IAgenticaRpcListener to handle events from the server and demonstrates calling server functions remotely.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/client.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IAgenticaRpcListener, IAgenticaRpcService } from \"@agentica/rpc\";\nimport { Driver, WebSocketConnector } from \"tgrid\";\n\n// Create WebSocketConnector with type specifications\nconst connector: WebSocketConnector<\n  null,\n  IAgenticaRpcListener,\n  IAgenticaRpcService<\"chatgpt\">\n> = new WebSocketConnector(null, {\n  // and configuring IAgenticaRpcListener instance\n  // server will call these functions remotely \n  // (Remote Procedure Call)\n  text: async (evt) => {\n    console.log(evt.role, evt.text);\n  },\n  select: async (evt) => {\n    console.log(\"selector\", evt.selection);\n  },\n  execute: async (evt) => {\n    console.log(\"execute\", evt.operation, evt.arguments, evt.value);\n  },\n  describe: async (evt) => {\n    console.log(\"describer\", evt.text);\n  },\n});\n\n// Connect to the server\nawait connector.connect(\"ws://localhost:3001\");\n\n// Call the server's functions remotely (Remote Procedure Call)\nconst driver: Driver<IAgenticaRpcService<\"chatgpt\">> = connector.getDriver();\nawait driver.conversate(\"Hello, what you can do?\");\n\n// Disconnect after your job\nawait connector.close();\n```\n\n----------------------------------------\n\nTITLE: Google Search Agent with OpenAI (TypeScript)\nDESCRIPTION: This TypeScript code defines an Agentica agent configured to use OpenAI's GPT model for performing Google searches. It imports necessary modules like Agentica core, typia for type safety, dotenv for environment variables, and the OpenAI client. It also uses the GoogleSearchService connector to interact with the Google Search API.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-search.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\nimport dotenv from \"dotenv\";\nimport { OpenAI } from \"openai\";\n\nimport { GoogleSearchService } from \"@wrtnlabs/connector-google-search\";\n\ndotenv.config();\n\nexport const agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY!,\n    }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"GoogleSearch Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<GoogleSearchService, \"chatgpt\">(),\n      execute: new GoogleSearchService(),\n    },\n  ],\n});\n\nconst main = async () => {\n  console.log(await agent.conversate(\"What can you do?\"));\n};\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Defining 'index' Function for Article Retrieval\nDESCRIPTION: This defines the 'index' function for retrieving all articles.  It specifies the input parameters (empty object), output schema (array of article objects), and a description. The output schema defines the structure of an article, including fields like 'id' (UUID), 'created_at' (date-time), 'title', 'body', and 'thumbnail' (URI). It also includes a validation function, although it always returns true in this snippet.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/LlmApplicationJavaScriptSnippet.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n    {\n      name: \"index\",\n      parameters: {\n        type: \"object\",\n        properties: {},\n        additionalProperties: false,\n        required: [],\n        $defs: {},\n      },\n      output: {\n        description: \"List of every articles\",\n        type: \"array\",\n        items: {\n          description:\n            \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n          type: \"object\",\n          properties: {\n            id: {\n              title: \"Primary Key\",\n              description: \"Primary Key.\\n\\n\\n@format uuid\",\n              type: \"string\",\n            },\n            created_at: {\n              title: \"Creation time of the article\",\n              description:\n                \"Creation time of the article.\\n\\n\\n@format date-time\",\n              type: \"string\",\n            },\n            updated_at: {\n              title: \"Last updated time of the article\",\n              description:\n                \"Last updated time of the article.\\n\\n\\n@format date-time\",\n              type: \"string\",\n            },\n            title: {\n              title: \"Title of the article\",\n              description:\n                \"Title of the article.\\n\\nRepresentative title of the article.\",\n              type: \"string\",\n            },\n            body: {\n              title: \"Content body\",\n              description:\n                \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n              type: \"string\",\n            },\n            thumbnail: {\n              title: \"Thumbnail image URI\",\n              description:\n                \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n              anyOf: [\n                {\n                  type: \"null\",\n                },\n                {\n                  type: \"string\",\n                  description: \"@format uri\\n@contentMediaType image/*\",\n                },\n              ],\n            },\n          },\n          required: [\n            \"id\",\n            \"created_at\",\n            \"updated_at\",\n            \"title\",\n            \"body\",\n            \"thumbnail\",\n          ],\n        },\n      },\n      description:\n        \"Get all articles.\\n\\nList up every articles archived in the BBS DB.\",\n      validate: (() => {\n        const __is = (input) => true;\n        let errors;\n        let _report;\n        return (input) => {\n          if (false === __is(input)) {\n            errors = [];\n            _report = __typia_transform__validateReport._validateReport(errors);\n            ((input, _path, _exceptionable = true) => true)(\n              input,\n              \"$input\",\n              true,\n            );\n            const success = 0 === errors.length;\n            return success\n              ? {\n                  success,\n                  data: input,\n                }\n              : {\n                  success,\n                  errors,\n                  data: input,\n                };\n          }\n          return {\n            success: true,\n            data: input,\n          };\n        };\n      })(),\n    },\n```\n\n----------------------------------------\n\nTITLE: Declaring Calculator Controller in Agentica\nDESCRIPTION: This code declares the `CalculatorController` to apply it to Agentica, conforming to the `IAgenticaController` interface.  It specifies the controller's protocol, name, execution logic, and application type for use with the 'chatgpt' model.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/react-native/battery.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nexport const CalculatorController: IAgenticaController<'chatgpt'> = {\n  protocol: 'class',\n  name: 'calculator',\n  execute: async props =>\n    (Calculator as any)[props.function.name](props.arguments),\n  application: typia.llm.application<typeof Calculator, 'chatgpt'>(),\n};\n```\n\n----------------------------------------\n\nTITLE: Install Core Library with pnpm\nDESCRIPTION: Installs the core Agentica library along with its dependencies, @samchon/openapi and typia, using pnpm. Includes a typia setup command.  This setup is necessary for converting Swagger/OpenAPI documents and composing LLM function calling schemas.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/manual.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm install @agentica/core @samchon/openapi typia\npnpm typia setup\n```\n\n----------------------------------------\n\nTITLE: Agentica CLI Google Search Agent Setup (Bash)\nDESCRIPTION: This command initiates the Agentica setup wizard to create a Google Search Agent. It handles package installation, project type selection, controller setup (GOOGLE SEARCH), and API key entry. After the wizard completes, Agentica generates the code, creates a `.env` file, and installs all the necessary dependencies.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-search.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica start google-search-agent\n```\n\n----------------------------------------\n\nTITLE: Notion API Key Configuration (.env)\nDESCRIPTION: This code snippet shows the required environment variables for configuring the Notion API. It includes the OpenAI API key and the Notion secret key, which are essential for the agent to authenticate and interact with the Notion workspace.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/notion.mdx#_snippet_2\n\nLANGUAGE: env\nCODE:\n```\nOPENAI_API_KEY=your-openai-api-key\nNOTION_SECRET_KEY=your-notion-secret-key\n```\n\n----------------------------------------\n\nTITLE: Arguments Hooking (Server - TypeScript)\nDESCRIPTION: Configures the WebSocket server using tgrid and @agentica/rpc to handle requests from the client. It defines the AgenticaRpcService and integrates with LlamaTypeChecker for advanced function parameter handling.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/client.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport {\n  AgenticaRpcService,\n  IAgenticaRpcListener,\n  IAgenticaRpcService,\n} from \"@agentica/rpc\";\nimport { LlamaTypeChecker } from \"@samchon/openapi\";\nimport OpenAI from \"openai\";\nimport { WebSocketServer } from \"tgrid\";\nimport typia from \"typia\";\n\nconst server: WebSocketServer<\n  null,\n  IAgenticaRpcService<\"llama\">,\n  IAgenticaRpcListener\n> = new WebSocketServer();\nawait server.open(3_001, async (acceptor) => {\n  const agent: Agentica<\"llama\"> = new Agentica({\n    model: \"llama\",\n    vendor: {\n      api: new OpenAI({\n        apiKey: \"********\",\n        baseURL: \"http://localhost:3000/llama\",\n      }),\n      model: \"llama-3.3-70b\",\n    },\n    controllers: [\n      {\n        name: \"bbs\",\n        protocol: \"class\",\n        application: typia.llm.application<BbsArticleService, \"llama\">({\n          separate: (schema) =>\n            LlamaTypeChecker.isString(schema) &&\n            schema.format === \"uri\" &&\n            schema.contentMediaType !== undefined,\n        }),\n        execute: new BbsArticleService(),\n      },\n    ],\n  });\n  const service: AgenticaRpcService<\"llama\"> = new AgenticaRpcService({\n    agent,\n    listener: acceptor.getDriver(),\n  });\n  await acceptor.accept(service);\n});\n```\n\n----------------------------------------\n\nTITLE: Define BbsArticle DTO with Validation in TypeScript\nDESCRIPTION: This code defines the `BbsArticle` data transfer object (DTO) with properties like `id`, `files`, `title`, `body`, and `created_at`. It uses decorators from `class-validator` to enforce validation rules such as data types, string lengths, and formats. The `@nestjs/swagger` decorators are used to define the API schema for documentation purposes. The `files` property showcases a potentially duplicated schema definition pattern.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/ClassValidatorSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ApiProperty } from \"@nestjs/swagger\";\nimport {\n  ArrayNotEmpty,\n  Format,\n  IsArray,\n  IsObject,\n  IsOptional,\n  IsString,\n  Match,\n  MaxLength,\n  Type,\n  ValidateNested,\n} from \"class-validator\";\n \nexport class BbsArticle {\n  @ApiProperty({\n    format: \"uuid\",\n  })\n  @IsString()\n  id!: string;\n \n  // DUPLICATED SCHEMA DEFINITION\n  // - duplicated function call + property type\n  // - have to specify `isArray` and `nullable` props by yourself\n  @ApiProperty({\n    type: () => AttachmentFile,\n    nullable: true,\n    isArray: true,\n    description: \"List of attached files.\",\n  })\n  @Type(() => AttachmentFile)\n  @IsArray()\n  @IsOptional()\n  @IsObject({ each: true })\n  @ValidateNested({ each: true })\n  files!: AttachmentFile[] | null;\n \n  @ApiProperty({\n    type: \"string\",\n    nullable: true,\n    minLength: 5,\n    maxLength: 100,\n    description: \"Title of the article.\",\n  })\n  @IsOptional()\n  @IsString()\n  title!: string | null;\n \n  @ApiProperty({\n    description: \"Main content body of the article.\",\n  })\n  @IsString()\n  body!: string;\n \n  @ApiProperty({\n    format: \"date-time\",\n    description: \"Creation time of article\",\n  })\n  @IsString()\n  created_at!: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Orchestration Executor (TypeScript)\nDESCRIPTION: This snippet demonstrates configuring the orchestration executor within the Agentica configuration. It highlights how to customize the executor's behavior, such as skipping the initialization process or using a different function selection strategy like AgenticaPgVectorSelector.  This allows for modifying how internal agents are orchestrated and affects overall agent behavior.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/config.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, IAgenticaProps, IAgenticaConfig } from \"@agentica/core\";\nimport { AgenticaPgVectorSelector } from \"@agentica/pg-vector-selector\";\nimport OpenAI from \"openai\";\n \nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o\",\n  },\n  controllers: [...],\n  config: {\n    executor: {\n      initialize: null,\n      select: AgenticaPgVectorSelector.boot<\"chatgpt\">\n        (\"https://your-connector-hive-server.com\",\n      ),\n    },\n  },\n});\nawait agent.conversate(\"Hello, I want to refund my shoes.\");\n```\n\n----------------------------------------\n\nTITLE: Agentica: Streaming Text Event in TypeScript\nDESCRIPTION: This snippet demonstrates how to stream 'text' events from Agentica using TypeScript. It sets up an Agentica instance and attaches an event listener to the 'text' event, processing the incoming text stream and writing it to the standard output.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/event.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, AgenticaEvent } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [...],\n});\nagent.on(\"text\", async (event) => {\n  console.log(\"Text from\", event.role);\n  for await (const text of event.stream)\n    process.stdout.write(text);\n  process.stdout.write(\"\\n\");\n});\nawait agent.conversate(\"I wanna buy Surface Pro\");\n```\n\n----------------------------------------\n\nTITLE: Agentica CLI Setup\nDESCRIPTION: This command starts the Agentica setup wizard to create a Google Scholar Agent. The wizard guides the user through installing dependencies, selecting the Google Scholar controller, and entering the OpenAI API key.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-scholar.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica start google-scholar-agent\n```\n\n----------------------------------------\n\nTITLE: Define AttachmentFile DTO with Validation in TypeScript\nDESCRIPTION: This code defines the `AttachmentFile` data transfer object (DTO) with properties like `name`, `extension`, and `url`. It utilizes decorators from `class-validator` to apply validation rules such as data types, string lengths, regular expression patterns, and URL format. The `@nestjs/swagger` decorators are used to define the API schema for documentation. This enforces data integrity and provides a clear API contract.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/ClassValidatorSnippet.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport class AttachmentFile {\n  @ApiProperty({\n    type: \"string\",\n    maxLength: 255,\n    pattern: \"^[a-zA-Z0-9-_]+$\",\n    description: \"File name.\",\n  })\n  @Matches(/^[a-z0-9]+$/)\n  @MaxLength(255)\n  @IsString()\n  name!: string | null;\n \n  @ApiProperty({\n    type: \"string\",\n    nullable: true,\n    maxLength: 255,\n    pattern: \"^[a-zA-Z0-9-_]+$\",\n    description: \"File extension.\",\n  })\n  @Matches(/^[a-z0-9]+$/)\n  @MaxLength(8)\n  @IsOptional()\n  @IsString()\n  extension!: string | null;\n \n  @ApiProperty({\n    format: \"url\",\n    description: \"URL of the file.\",\n  })\n  @Format(\"uri\")\n  @IsString()\n  url!: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Executing AgenticaSelectBenchmark (Advanced)\nDESCRIPTION: This snippet shows a more advanced configuration of AgenticaSelectBenchmark. It includes setting up an Agentica instance with a specific model, vendor, and controllers (using HttpLlm and OpenAI). It defines scenarios with specific text inputs and expected operation types, then executes the benchmark and generates a markdown report.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/benchmark.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { \n  AgenticaSelectBenchmark,\n  IAgenticaSelectBenchmarkScenario\n} from \"@agentica/benchmark\";\nimport { Agentica, IAgenticaOperation } from \"@agentica/core\";\nimport { HttpLlm, IHttpConnection, OpenApi } from \"@samchon/openapi\";\nimport fs from \"fs\";\nimport OpenAI from \"openai\";\nimport path from \"path\";\n\nconst mkdir = async (str: string) => {\n  try {\n    await fs.promises.mkdir(str, {\n      recursive: true,\n    });\n  } catch {}\n};\n\nconst rmdir = async (str: string) => {\n  try {\n    await fs.promises.rm(str, {\n      recursive: true,\n    });\n  } catch {}\n};\n\nconst main = async (): Promise<void> => {\n  // CREATE AI AGENT\n  const agent: Agentica<\"chatgpt\"> = new Agentica({\n    model: \"chatgpt\",\n    vendor: {\n      api: new OpenAI({ apiKey: \"********\" }),\n      model: \"gpt-4o-mini\",\n    },\n    controllers: [\n      {\n        protocol: \"http\",\n        name: \"shopping\",\n        application: HttpLlm.application({\n          model: \"chatgpt\",\n          document: await fetch(\n            \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n          ).then((res) => res.json()),\n        }),\n        connection: {\n          host: \"https://shopping-be.wrtn.ai\",\n          headers: {\n            Authorization: \"Bearer *****\",\n          },\n        },\n      },\n    ],\n  });\n\n  // DO BENCHMARK\n  const find = (method: OpenApi.Method, path: string): IAgenticaOperation => {\n    const found = agent\n      .getOperations()\n      .find(\n        (op) =>\n          op.protocol === \"http\" &&\n          op.function.method === method &&\n          op.function.path === path,\n      );\n    if (!found) throw new Error(`Operation not found: ${method} ${path}`);\n    return found;\n  };\n  const benchmark: AgenticaSelectBenchmark<\"chatgpt\"> = \n    new AgenticaSelectBenchmark({\n      agent,\n      config: {\n        repeat: 4,\n        simultaneous: 100,\n      },\n      scenarios: [\n        {\n          name: \"order\",\n          text: [\n            \"I wanna see every sales in the shopping mall\",\n            \"\",\n            \"And then show me the detailed information about the Macbook.\",\n            \"\",\n            \"After that, select the most expensive stock\",\n            \"from the Macbook, and put it into my shopping cart.\",\n            \"And take the shopping cart to the order.\",\n            \"\",\n            \"At last, I'll publish it by cash payment, and my address is\",\n            \"\",\n            \"  - country: South Korea\",\n            \"  - city/province: Seoul\",\n            \"  - department: Wrtn Apartment\",\n            \"  - Possession: 101-1411\",\n          ].join(\"\\n\"),\n          expected: {\n            type: \"array\",\n            items: [\n              {\n                type: \"standalone\",\n                operation: find(\"patch\", \"/shoppings/customers/sales\"),\n              },\n              {\n                type: \"standalone\",\n                operation: find(\"get\", \"/shoppings/customers/sales/{id}\"),\n              },\n              {\n                type: \"anyOf\",\n                anyOf: [\n                  {\n                    type: \"standalone\",\n                    operation: find(\"post\", \"/shoppings/customers/orders\"),\n                  },\n                  {\n                    type: \"standalone\",\n                    operation: find(\"post\", \"/shoppings/customers/orders/direct\"),\n                  },\n                ],\n              },\n              {\n                type: \"standalone\",\n                operation: find(\n                  \"post\",\n                  \"/shoppings/customers/orders/{orderId}/publish\",\n                ),\n              },\n            ],\n          },\n        },\n      ] satisfies IAgenticaSelectBenchmarkScenario<\"chatgpt\">[],\n    });\n  await benchmark.execute();\n\n  // REPORT\n  const docs: Record<string, string> = benchmark.report();\n  const root: string = `docs/benchmarks/call`;\n\n  await rmdir(root);\n  for (const [key, value] of Object.entries(docs)) {\n    await mkdir(path.join(root, key.split(\"/\").slice(0, -1).join(\"/\")));\n    await fs.promises.writeFile(path.join(root, key), value, \"utf8\");\n  }\n};\nmain().catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: Agentica Initialization and Usage with OpenAI and TypeScript Class\nDESCRIPTION: This snippet demonstrates how to initialize an Agentica instance with an OpenAI vendor and a TypeScript class as a controller. It showcases the configuration of the Agentica object, including specifying the API key, model, and controllers, which define the functions available to the AI agent. It also shows an example of using typia to create an LLM application.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/chat/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\nimport { MobileFileSystem } from \"./services/MobileFileSystem\";\n\nconst agent = new Agentica({\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    // functions from TypeScript class\n    {\n      protocol: \"http\",\n      application: typia.llm.application<MobileFileSystem, \"chatgpt\">(),\n      execute: new MobileFileSystem(),\n    },\n    // functions from Swagger/OpenAPI\n    {\n      protocol: \"http\",\n      application: assertHttpLlmApplication({\n        model: \"chatgpt\",\n        document: await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n        ).then(r => r.json()),\n      }),\n      connection: {\n        host: \"https://shopping-be.wrtn.ai\",\n        headers: { Authorization: \"Bearer ********\" },\n      },\n    },\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Agentica Project Setup via CLI (Bash)\nDESCRIPTION: This snippet shows the command to start the Agentica setup wizard using the command line interface. The wizard guides the user through setting up a new Agentica project, including selecting a package manager, project type, and embedded controllers.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ npx agentica start <directory>\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with TypeScript Class and OpenAPI\nDESCRIPTION: This code snippet demonstrates how to initialize an Agentica instance with a TypeScript class (MobileFileSystem) and an OpenAPI/Swagger document. It sets up the agent with OpenAI as the vendor and configures controllers to execute functions from both the TypeScript class and the API defined by the Swagger document.  It showcases integrating with an external shopping API.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/rpc/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\nimport { MobileFileSystem } from \"./services/MobileFileSystem\";\n\nconst agent = new Agentica({\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    // functions from TypeScript class\n    {\n      protocol: \"http\",\n      application: typia.llm.application<MobileFileSystem, \"chatgpt\">(),\n      execute: new MobileFileSystem(),\n    },\n    // functions from Swagger/OpenAPI\n    {\n      protocol: \"http\",\n      application: assertHttpLlmApplication({\n        model: \"chatgpt\",\n        document: await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n        ).then(r => r.json()),\n      }),\n      connection: {\n        host: \"https://shopping-be.wrtn.ai\",\n        headers: { Authorization: \"Bearer ********\" },\n      },\n    },\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Customizing System Prompts (TypeScript)\nDESCRIPTION: This snippet shows how to customize system prompts for internal agents in Agentica. It focuses on configuring the `systemPrompt` property within the Agentica configuration. Specifically, it demonstrates how to set a common system prompt that applies to all internal agents, guiding them with specific instructions (e.g., polite and gentle tone for a counseling chatbot).\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/config.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, IAgenticaProps, IAgenticaConfig } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o\",\n  },\n  controllers: [...],\n  config: {\n    systemPrompt: {\n      common: () => [\n        \"You are a counselor of the shopping mall.\",\n        \"\",\n        \"Be kind and polite to the customer.\",\n      ].join(\"\\n\"),\n    },\n  },\n});\nawait agent.conversate(\"Hello, I want to refund my shoes.\");\n```\n\n----------------------------------------\n\nTITLE: Google Calendar Agent with Function Selection\nDESCRIPTION: This TypeScript code demonstrates how to restrict the available functions in the GoogleCalendarService using TypeScript's `Pick` utility. It exposes only a subset of functions for a more secure and maintainable integration.  It depends on `openai` and `GoogleCalendarService`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-calendar.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport const GoogleCalendarAgent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: openai,\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"Google Calendar Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<\n        Pick<\n          GoogleCalendarService,\n          | \"getCalendarList\"\n          | \"createCalendar\"\n          | \"eventList\"\n          | \"createEvent\"\n          | \"updateEvent\"\n          | \"deleteEvent\"\n        >,\n        \"chatgpt\"\n      >(),\n      execute: new GoogleCalendarService({\n        clientId: process.env.GOOGLE_CALENDAR_CLIENT_ID!,\n        clientSecret: process.env.GOOGLE_CALENDAR_CLIENT_SECRET!,\n        secret: process.env.GOOGLE_CALENDAR_REFRESH_TOKEN!,\n      }),\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Yarn Installation of Agentica Core\nDESCRIPTION: This command installs the @agentica/core library along with its dependencies, @samchon/openapi and typia, using yarn. The subsequent command, yarn typia setup, configures typia for TypeScript transformation.  Note that Yarn Berry is not supported.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/index.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# YARN BERRY IS NOT SUPPORTED\nyarn add @agentica/core @samchon/openapi typia\nyarn typia setup\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with OpenAI\nDESCRIPTION: This snippet initializes an Agentica agent with the 'chatgpt' model, sets up the OpenAI vendor with a specific model and API key, and defines a controller for handling HTTP requests using the BbsArticleService. It uses typia.llm.application to generate the application based on the BbsArticleService and model.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaExampleVendorChatGptSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst agent: Agentica<\"chatgpt\"> = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    model: \"gpt-4o-mini\",\n    api: new OpenAI({\n      apiKey: \"********\",\n    }),\n  } satisfies IAgenticaVendor,\n  controllers: [\n    {\n      protocol: \"http\",\n      name: \"class\",\n      application: typia.llm.application<BbsArticleService, \"chatgpt\">(),\n      execute: new BbsArticleService(),\n    } satisfies IAgenticaController<\"chatgpt\">,\n  ]\n} satisfies IAgenticaProps<\"chatgpt\">);\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with TypeScript Class Controller\nDESCRIPTION: This snippet demonstrates how to initialize Agentica with a TypeScript class controller. It imports necessary modules, creates an Agentica instance, and configures a controller with the 'class' protocol, specifying the application schema, and providing an instance of the BbsArticleService class for execution. It also shows how to start a conversation with the configured agent.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/controller/typescript.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, IAgenticaController } from \"@agentica/core\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      protocol: \"class\",\n      name: \"bbs\",\n      application: typia.llm.application<BbsArticleService, \"chatgpt\">(),\n      execute: new BbsArticleService(),\n    } satisfies IAgenticaController.IClass<\"chatgpt\">,\n  ],\n});\nawait agent.conversate(\"What you can do?\");\n```\n\n----------------------------------------\n\nTITLE: Expected API Call Sequence\nDESCRIPTION: This JSON defines the expected sequence of API calls to fulfill the user's request. It lists operations for displaying sales, retrieving product details, creating orders, and publishing orders, including descriptions and parameters of each operation. The operations are designed to simulate a real-world e-commerce interaction with an A.I. agent.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/select/order/1.success.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_create\",\n            \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n          }\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Agentica with OpenAI GPT Vendor\nDESCRIPTION: This snippet demonstrates how to configure Agentica to use OpenAI's GPT models. It defines the IAgenticaVendor with the OpenAI API key and specifies the GPT model to be used.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/index.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { \n  Agentica,\n  IAgenticaController,\n  IAgenticaProps,\n  IAgenticaVendor\n} from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nimport { BbsArticleService } from \"./services/BbsArticleService\";\n\nconst agent: Agentica<\"chatgpt\"> = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    model: \"gpt-4o-mini\",\n    api: new OpenAI({\n      apiKey: \"********\",\n    }),\n  } satisfies IAgenticaVendor,\n  controllers: [\n    {\n      protocol: \"http\",\n      name: \"class\",\n      application: typia.llm.application<BbsArticleService, \"chatgpt\">(),\n      execute: new BbsArticleService(),\n    } satisfies IAgenticaController<\"chatgpt\">,\n  ]\n} satisfies IAgenticaProps<\"chatgpt\">);\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Agentica Initialization with TypeScript\nDESCRIPTION: This snippet demonstrates how to initialize an Agentica instance with configurations for OpenAI and function controllers. It imports necessary modules, sets up the vendor API, and defines controllers from a TypeScript class and a Swagger/OpenAPI document.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\nimport { MobileFileSystem } from \"./services/MobileFileSystem\";\n\nconst agent = new Agentica({\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    // functions from TypeScript class\n    {\n      protocol: \"http\",\n      application: typia.llm.application<MobileFileSystem, \"chatgpt\">(),\n      execute: new MobileFileSystem(),\n    },\n    // functions from Swagger/OpenAPI\n    {\n      protocol: \"http\",\n      application: assertHttpLlmApplication({\n        model: \"chatgpt\",\n        document: await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n        ).then(r => r.json()),\n      }),\n      connection: {\n        host: \"https://shopping-be.wrtn.ai\",\n        headers: { Authorization: \"Bearer ********\" },\n      },\n    },\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Defining Gemini Parameters with typia\nDESCRIPTION: This TypeScript code defines parameters for Google Gemini using 'typia' and its tagging system. It specifies properties like 'id' (UUID format), 'age' (uint32, max 100), and 'email' (email format) with their respective constraints. The 'typia.llm.parameters' function generates the Gemini-compatible parameter schema.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/vendor.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\ntypia.llm.parameters<{ /**\n   * Primary Key.\n   *\n   * Primary Key generated by System.\n   */\n  id: string & tags.Format<\"uuid\">;  /**\n   * Age of the user.\n   *\n   * Age of the user in years.\n   */\n  age: number & tags.Type<\"uint32\"> & tags.Maximum<100>;  /**\n   * Email address of the user.\n   *\n   * Email address written when membership joining.\n   */\n  email: string & tags.Format<\"email\">; }, \"gemini\">();\n```\n\n----------------------------------------\n\nTITLE: Generated Code: Arxiv Search Agent with Agentica\nDESCRIPTION: This TypeScript code sets up an Arxiv Search Agent using Agentica core, typia, dotenv, and OpenAI. It configures the agent to use the ArxivSearchService connector for searching research papers, leveraging OpenAI's GPT model for intelligent searches, and ensures type safety using typia.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/arxiv.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\nimport dotenv from \"dotenv\";\nimport { OpenAI } from \"openai\";\n\nimport { ArxivSearchService } from \"@wrtnlabs/connector-arxiv-search\";\n\ndotenv.config();\n\nexport const agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY!,\n    }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"ArxivSearch Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<ArxivSearchService, \"chatgpt\">(),\n      execute: new ArxivSearchService(),\n    },\n  ],\n});\n\nconst main = async () => {\n  console.log(await agent.conversate(\"What can you do?\"));\n};\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Defining IShoppingSaleUnitStock Interface (TypeScript)\nDESCRIPTION: This code defines the `IShoppingSaleUnitStock` interface, representing the final stock information for a product for sale. It's a subsidiary entity of `IShoppingSaleUnit`, constructed by selecting options and their candidate values.  It's essentially the SKU. It includes a product name and options (e.g. MacBook CPU, RAM, SSD options).\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/DocumentationStrategyDtoDescriptionSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Final component information on units for sale.\n *\n * `IShoppingSaleUnitStock` is a subsidiary entity of {@link IShoppingSaleUnit}\n * that represents a product catalog for sale, and is a kind of final stock that is\n * constructed by selecting all {@link IShoppingSaleUnitSelectableOption options}\n * (variable \"select\" type) and their\n * {@link IShoppingSaleUnitOptionCandidate candidate} values in the belonging unit.\n * It is the \"good\" itself that customers actually purchase.\n *\n * - Product Name) MacBook\n *   - Options\n *     - CPU: { i3, i5, i7, i9 }\n *     - RAM: { 8GB, 16GB, 32GB, 64GB, 96GB }\n *     - SSD: { 256GB, 512GB, 1TB }\n *   - Number of final stocks: 4 * 5 * 3 = 60\n *\n * For reference, the total number of `IShoppingSaleUnitStock` records in an\n * attribution unit can be obtained using Cartesian Product. In other words, the\n * value obtained by multiplying all the candidate values that each\n * (variable \"select\" type) option can have by the number of cases is the total\n * number of final stocks in the unit.\n *\n * Of course, without a single variable \"select\" type option, the final stocks\n * count in the unit is only 1.\n *\n * @author Samchon\n */\nexport interface IShoppingSaleUnitStock { ... }\n```\n\n----------------------------------------\n\nTITLE: Creating FastAPI POST Endpoint\nDESCRIPTION: This code snippet defines a FastAPI POST endpoint at '/items/'. The function 'create_item' is decorated with @app.post(\"/items/\") and takes an 'item' of type 'Item' (the Pydantic model) as input. It then returns the received 'item' which FastAPI automatically serializes to JSON.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/PythonFastApiSnippet.mdx#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@app.post(\"/items/\")\nasync def create_item(item: Item):\n  return item\n```\n\n----------------------------------------\n\nTITLE: Google Calendar Agent Setup with Agentica\nDESCRIPTION: This TypeScript code sets up a Google Calendar Agent using Agentica, OpenAI, and the GoogleCalendarService connector. It configures the agent with the OpenAI API, defines the Google Calendar controller, and includes a basic interaction example.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-calendar.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\nimport dotenv from \"dotenv\";\nimport { OpenAI } from \"openai\";\n\nimport { GoogleCalendarService } from \"@wrtnlabs/connector-google-calendar\";\n\ndotenv.config();\n\nexport const agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY!,\n    }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"GoogleCalendar Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<GoogleCalendarService, \"chatgpt\">(),\n      execute: new GoogleCalendarService(),\n    },\n  ],\n});\n\nconst main = async () => {\n  console.log(await agent.conversate(\"What can you do?\"));\n};\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: NestJS Server Dependencies Installation (npm)\nDESCRIPTION: This bash script installs the necessary dependencies for a NestJS WebSocket server using npm. It installs `@nestjs/common`, `@nestjs/core`, `@nestjs/platform-express`, `@agentica/core`, `@samchon/openapi`, `@agentica/rpc`, and `tgrid`. It also installs `nestia` as a dev dependency and runs `nestia setup`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/index.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @nestjs/common @nestjs/core @nestjs/platform-express\nnpm install @agentica/core @samchon/openapi\nnpm install @agentica/rpc tgrid\n\nnpm install -D nestia\nnpx nestia setup\n```\n\n----------------------------------------\n\nTITLE: Listening for Select Event in Agentica\nDESCRIPTION: This code snippet demonstrates how to listen for the 'select' event in an Agentica agent. The 'select' event is triggered when a candidate function is selected during the conversation. The code logs the selected operation's name and the reason for its selection to the console. It requires the `@agentica/core` and `openai` packages.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/event.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, AgenticaEvent } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [...],\n});\nagent.on(\"select\", async (event) => {\n  console.log(\n    \"select\",\n    event.selection.operation.name,\n    event.selection.reason,\n  );\n});\nawait agent.conversate(\"I wanna buy Surface Pro\");\n```\n\n----------------------------------------\n\nTITLE: Initializing and Conversing with MicroAgentica in TypeScript\nDESCRIPTION: This snippet demonstrates how to initialize a MicroAgentica instance with OpenAI integration, define controllers, provide history, engage in a conversation, and then archive the resulting prompts. The apiKey needs to be provided.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/micro.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  IMicroAgenticaHistoryJson,\n  MicroAgentica,\n  MicroAgenticaHistory,\n} from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nexport const main = async (id: string): Promise<void> => {\n  const agent = new MicroAgentica({\n    model: \"chatgpt\",\n    vendor: {\n      api: new OpenAI({ apiKey: \"*****\" }),\n      model: \"gpt-4o-mini\",\n    },\n    controllers: [...],\n    histories: (await getHistories(id)) satisfies IMicroAgenticaHistoryJson[],\n  });\n  const prompts: MicroAgenticaHistory[] = await agent.conversate(\n    \"I wanna buy MacBook Pro\",\n  );\n  await archiveHistories(id, prompts.map((p) => p.toJSON()));\n};\n```\n\n----------------------------------------\n\nTITLE: Agentica: Basic Event Handling in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up event listeners for various Agentica events such as 'text', 'initialize', 'select', 'execute', and 'describe'. It initializes an Agentica instance with OpenAI and defines asynchronous event handlers to process and log event data to the console. The `conversate` method triggers the event flow.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/event.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [...],\n});\n\nagent.on(\"text\", async (event) => {\n  console.log(\"Text from\", event.role);\n  for await (const text of event.stream)\n    process.stdout.write(text);\n  process.stdout.write(\"\\n\");\n});\n\nagent.on(\"initialize\", async () => {\n  console.log(\"Function calling started\");\n});\nagent.on(\"select\", async (event) => {\n  console.log(\n    \"Candidate function selected\", \n    event.selection.operation.name, \n    event.selection.reason,\n  );\n});\nagent.on(\"execute\", async (event) => {\n  console.log(\n    \"Function executed\", \n    event.operation.name, \n    event.arguments, \n    event.value,\n  );\n});\nagent.on(\"describe\", async (event) => {\n  console.log(\"Describe Function Calling\");\n  for (const execute of event.executes)\n    console.log(`  - ${execute.operation.name}`);\n  for await (const text of event.stream)\n    process.stdout.write(text);\n  process.stdout.write(\"\\n\");\n}); \n\nawait agent.conversate(\"I wanna buy Surface Pro\");\n```\n\n----------------------------------------\n\nTITLE: AgenticaOperation Type Definition (TypeScript)\nDESCRIPTION: Defines the AgenticaOperation type as a discriminated union of IHttp and IClass interfaces, representing HTTP API and TypeScript class operations, respectively. The `protocol` property acts as the discriminator. It specifies the contract for operations selectable by the Agentica AI chatbot for LLM function calling.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaOperationSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Operation information in the Nestia Agent.\n *\n * `AgenticaOperation` is a type represents an operation that would\n * be selected by the A.I. chatbot of {@link Agentica} class to\n * perform the LLM (Large Language Model) function calling.\n *\n * Also, it is an union type that is discriminated by the {@link protocol}\n * property. If the protocol value is `http`, it means that the HTTP API\n * operation would be called by the A.I. chatbot. Otherwise, if the protocol\n * value is `class`, it means that the operation has come from a\n * TypeScript class.\n *\n * @author Samchon\n */\nexport type AgenticaOperation<Model extends ILlmSchema.Model> =\n  | AgenticaOperation.IHttp<Model>\n  | AgenticaOperation.IClass<Model>;\nexport namespace AgenticaOperation {\n  /**\n   * HTTP API operation.\n   */\n  export type IHttp<Model extends ILlmSchema.Model> = IBase<\n    \"http\",\n    IAgenticaController.IHttp<Model>,\n    IHttpLlmFunction<Model>\n  >;\n\n  /**\n   * TypeScript class operation.\n   */\n  export type IClass<Model extends ILlmSchema.Model> = IBase<\n    \"class\",\n    IAgenticaController.IClass<Model>,\n    ILlmFunction<Model>\n  >;\n\n  interface IBase<Protocol, Application, Function> {\n    /**\n     * Protocol discriminator.\n     */\n    protocol: Protocol;\n\n    /**\n     * Belonged controller of the target function.\n     */\n    controller: Application;\n\n    /**\n     * Target function to call.\n     */\n    function: Function;\n\n    /**\n     * Identifier name.\n     */\n    name: string;\n\n    toJSON(): IAgenticaOperationJson;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Chat Connection (Client)\nDESCRIPTION: This TypeScript code snippet initializes a connection to a chat server using the Agentica RPC SDK. It imports necessary modules, establishes a connection with a specified host, and defines event handlers for text messages, selections, executions, and descriptions received from the server. Finally, it sends a sample conversation message and closes the connection.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/nestjs.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IAgenticaRpcListener } from \"@agentica/rpc\";\nimport api, { IConnection } from \"@ORGANIZATION/PROJECT-api\";\n\nconst { connector, driver } = await api.functional.chat.start(\n  {\n    host: \"http://localhost:30001\",\n  } satisfies IConnection,\n  {\n    text: async (evt) => {\n      console.log(evt.role, evt.text);\n    },\n    select: async (evt) => {\n      console.log(\"selector\", evt.selection);\n    },\n    execute: async (evt) => {\n      console.log(\"execute\", evt.operation, evt.arguments, evt.value);\n    },\n    describe: async (evt) => {\n      console.log(\"describer\", evt.text);\n    },\n  } satisfies IAgenticaRpcListener,\n);\n\nawait driver.conversate(\"Hello, what can you do?\");\n\nawait connector.close();\n```\n\n----------------------------------------\n\nTITLE: Client WebSocket Connection with TGrid\nDESCRIPTION: This snippet demonstrates how to establish a WebSocket connection from a client application using TGrid's `WebSocketConnector`. It defines a connector with authorization headers and specifies listeners for incoming messages from the server. It then obtains a `Driver` instance to call remote procedures.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/index.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IAgenticaRpcListener, IAgenticaRpcService } from \"@agentica/rpc\";\nimport { Driver, WebSocketConnector } from \"tgrid\";\n\ninterface IAuthorizationHeader {\n  Authorization: string;\n}\n\nconst connector: WebSocketConnector<\n  IAuthorizationHeader,\n  IAgenticaRpcListener<\"chatgpt\">,\n  IAgenticaRpcService<\"chatgpt\">\n> = new WebSocketConnector(\n  {\n    Authorization: \"Bearer ********\",\n  }, \n  {\n    text: async (evt) => {\n      console.log(evt.role, evt.text);\n    },\n    describe: async (evt) => {\n      console.log(\"describer\", evt.text);\n    },\n  },\n);\nawait connector.connect(\"ws://localhost:3001\");\n\nconst driver: Driver<IAgenticaRpcService<\"chatgpt\">> = \n  connector.getDriver();\nawait driver.conversate(\"Hello, what you can do?\");\n```\n\n----------------------------------------\n\nTITLE: Agentica CLI Start Command\nDESCRIPTION: This command initiates the Agentica Setup Wizard, which guides users through installing packages, choosing project type, selecting the Youtube Search controller, and entering the OpenAI API key.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/youtube-search.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica start youtube-search-agent\n```\n\n----------------------------------------\n\nTITLE: NestJS WebSocket Controller (TypeScript)\nDESCRIPTION: This TypeScript code defines a NestJS controller for handling WebSocket connections using `@nestia/core` and `tgrid`.  It uses the `@WebSocketRoute` decorator to define a handler function. The handler function instantiates an Agentica agent and AgenticaRpcService, and then accepts the service.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/index.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AgenticaRpcService, IAgenticaRpcListener } from \"@agentica/rpc\";\nimport { WebSocketRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport { WebSocketAcceptor } from \"tgrid\";\n\n@Controller(\"chat\")\nexport class ChatController {\n  @WebSocketRoute()\n  public async start(\n    // @WebSocketRoute.Param(\"id\") id: string,\n    @WebSocketRoute.Acceptor()\n    acceptor: WebSocketAcceptor<\n      null, // header\n      AgenticaRpcService<\"chatgpt\">,\n      IAgenticaRpcListener<\"chatgpt\">\n    >,\n  ): Promise<void> {\n    const agent: Agentica<\"chatgpt\"> = new Agentica({ ... });\n    const service: AgenticaRpcService<\"chatgpt\"> = \n      new AgenticaRpcService({\n        agent,\n        listener: acceptor.getDriver(),\n      });\n    await acceptor.accept(service);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Reddit Agent Code (TypeScript)\nDESCRIPTION: This TypeScript code sets up a Reddit agent using Agentica, OpenAI, and the Reddit connector. It initializes the agent with the OpenAI API key, configures the Reddit service with credentials from environment variables, and defines a main function to interact with the agent.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/reddit.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\nimport dotenv from \"dotenv\";\nimport { OpenAI } from \"openai\";\n\nimport { RedditService } from \"@wrtnlabs/connector-reddit\";\n\ndotenv.config();\n\nconst agent: Agentica<\"chatgpt\"> = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: process.env.OPENAI_API_KEY! }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"Reddit Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<RedditService, \"chatgpt\">(),\n      execute: new RedditService({\n        secret: process.env.REDDIT_SECRET!,\n        clientSecret: process.env.REDDIT_CLIENT_SECRET!,\n        clientId: process.env.REDDIT_CLIENT_ID!,\n      }),\n    },\n  ],\n});\n\nconst main = async () => {\n  console.log(await agent.conversate(\"What can you do?\"));\n};\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Applying Calculator Controller to MicroAgentica\nDESCRIPTION: This code shows how to integrate the `CalculatorController` into the `MicroAgentica` setup within the `App.tsx` file.  It includes configuring the OpenAI API key, model, and listing the `CalculatorController` in the controllers array.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/react-native/battery.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nnew MicroAgentica({\n  model: 'chatgpt',\n  vendor: {\n    /**\n     * @warning\n     * This template is a proof-of-concept template created to demonstrate whether Agentica can call native features.\n     * To use this in a production environment, architectural modifications are required to properly secure the OpenAI Key.\n     */\n    api: new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY,\n      dangerouslyAllowBrowser: true,\n    }),\n    model: 'gpt-4o',\n  },\n  controllers: [CalculatorController], // Insert CalculatorController. \n});\n```\n\n----------------------------------------\n\nTITLE: Generating SDK with Nestia CLI (pnpm)\nDESCRIPTION: Generates a Software Development Kit (SDK) for frontend applications using the `nestia sdk` command. This SDK allows client applications to interact with the backend server in a type-safe and convenient manner. Requires `@nestia/sdk` to be installed and a `nestia.config.ts` file to be configured.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/nestjs.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npnpm nestia sdk\n```\n\n----------------------------------------\n\nTITLE: Selecting Specific Google Docs Functions\nDESCRIPTION: This TypeScript code demonstrates how to restrict the available functions in the Google Docs Agent using TypeScript's `Pick` utility.  It exposes only the `write`, `clear`, `readDocs`, and `update` functions from the `GoogleDocsService`, enhancing security and maintainability.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-docs.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport const GoogleDocsAgent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: openai,\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"Google Docs Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<\n        Pick<GoogleDocsService, \"write\" | \"clear\" | \"readDocs\" | \"update\">,\n        \"chatgpt\"\n      >(),\n      execute: new GoogleDocsService({\n        clientId: process.env.GOOGLE_DOCS_CLIENT_ID!,\n        clientSecret: process.env.GOOGLE_DOCS_CLIENT_SECRET!,\n        secret: process.env.GOOGLE_DOCS_REFRESH_TOKEN!,\n      }),\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: LLM Application Definition in TypeScript\nDESCRIPTION: This code snippet defines an LLM application using `typia.llm.application`. It specifies the `BbsArticleService` as the service to be used with the \"chatgpt\" model. The ILlmApplication interface from \"@samchon/openapi\" provides type safety for the application.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/LlmApplicationExampleSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ILlmApplication } from \"@samchon/openapi\";\nimport typia from \"typia\";\n\nimport { BbsArticleService } from \"./BbsArticleService\";\n\nconst app: ILlmApplication<\"chatgpt\"> = typia.llm.application<\n  BbsArticleService,\n  \"chatgpt\"\n>();\nconsole.log(app);\n```\n\n----------------------------------------\n\nTITLE: Expected API Calls for Macbook Order\nDESCRIPTION: This JSON payload represents the expected sequence of API calls that an AI agent should perform to fulfill a user's request to view sales, retrieve Macbook details, add to cart, and publish the order. It describes operations to list summarized sales, fetch detailed sale information, create an order, and publish the order.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/select/order/4.success.md#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_create\",\n            \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n          }\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Agentica Operation Selection Interface Definition TypeScript\nDESCRIPTION: This TypeScript interface defines the structure for representing an operation selected by the Agentica A.I. chatbot for LLM function calling. It includes the `operation` (the selected AgenticaOperation), `reason` (the reason for selection), and a `toJSON` method for converting the object to a JSON representation. This type facilitates structured communication between the agent and the LLM.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaOperationSelectionSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Nestia agent operation selection.\n *\n * `AgenticaOperationSelection` is a type represents an operation\n * which has been selected by the A.I. chatbot of {@link Agentica}\n * class for the LLM (Large Language Model) function calling with\n * detailed {@link reason} of the selection (or cancellation).\n *\n * @author Samchon\n */\nexport interface AgenticaOperationSelection<Model extends ILlmSchema.Model> {\n  /**\n   * Target operation.\n   *\n   * Operation that has been selected to prepare LLM function calling,\n   * or canceled due to no more required.\n   */\n  operation: AgenticaOperation<Model>;\n\n  /**\n   * The reason of the function selection or cancellation.\n   */\n  reason: string;\n\n  toJSON(): IAgenticaOperationSelectionJson;\n}\n```\n\n----------------------------------------\n\nTITLE: Agentica Initialization with OpenAI and TypeScript Class\nDESCRIPTION: This code snippet demonstrates how to initialize Agentica with an OpenAI model and integrate a TypeScript class as a controller. It sets up the vendor API, model, and defines a controller using typia for a MobileFileSystem class.  The controller specifies the protocol as 'http', the application as a typia-generated LLM application for the 'chatgpt' model, and the execute property as an instance of the MobileFileSystem class.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/create-agentica/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\nimport { MobileFileSystem } from \"./services/MobileFileSystem\";\n\nconst agent = new Agentica({\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    // functions from TypeScript class\n    {\n      protocol: \"http\",\n      application: typia.llm.application<MobileFileSystem, \"chatgpt\">(),\n      execute: new MobileFileSystem(),\n    },\n    // functions from Swagger/OpenAPI\n    {\n      protocol: \"http\",\n      application: assertHttpLlmApplication({\n        model: \"chatgpt\",\n        document: await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n        ).then(r => r.json()),\n      }),\n      connection: {\n        host: \"https://shopping-be.wrtn.ai\",\n        headers: { Authorization: \"Bearer ********\" },\n      },\n    },\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Environment Variable Configuration (.env)\nDESCRIPTION: This block represents the environment variables required for the Google Search Agent to function correctly. It specifies the OpenAI API key and the SerpApi API key, which are essential for authenticating with the respective services.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-search.mdx#_snippet_2\n\nLANGUAGE: env\nCODE:\n```\nOPENAI_API_KEY=your-openai-api-key\nSERPAPI_API_KEY=your-serp-api-api-key\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with MCP Controller (TypeScript)\nDESCRIPTION: This snippet demonstrates how to initialize Agentica with an MCP controller. It creates an MCP client, connects to a server using Stdio transport, and sets up an Agentica instance with the connected client as a controller. The snippet requires the `@wrtnlabs/agentica`, `@modelcontextprotocol/sdk` and `openai` packages. It also assumes that the `GITHUB_PERSONAL_ACCESS_TOKEN` environment variable is set.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/controller/mcp.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertMcpController } from \"@wrtnlabs/agentica\";\nimport { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\n\nconst client = new Client({\n  name: \"calculator\",\n  version: \"1.0.0\",\n});\n\nawait client.connect(new StdioClientTransport({\n  command: \"npx\",\n  args: [\"-y\", \"@modelcontextprotocol/server-github\"],\n  env: {\n    GITHUB_PERSONAL_ACCESS_TOKEN: process.env.GITHUB_PERSONAL_ACCESS_TOKEN,\n    // Add other environment variables as needed\n  }\n}));\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"*****\"})\n    model: \"gpt-4o-mini\"\n  },\n  controllers: [\n    await assertMcpController({\n      name: \"calculator\",\n      model: \"chatgpt\",\n      client,\n    }),\n  ],\n});\nawait agent.conversate(\"What can you do?\");\n```\n\n----------------------------------------\n\nTITLE: Starting Agentica Project (React Native)\nDESCRIPTION: This command initializes a new Agentica project specifically configured for React Native.  It leverages the Agentica CLI to streamline project creation, prompting the user for project name, package manager, project type (React Native), and OpenAI API key.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/react-native/calendar.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica@latest start\n```\n\n----------------------------------------\n\nTITLE: Swagger to LLM Function Calling Conversion\nDESCRIPTION: This TypeScript snippet demonstrates how to convert a Swagger document to an LLM function calling schema using the `@samchon/openapi` library. It fetches a Swagger document from a URL, converts it to the OpenAPI format, and then creates an `IHttpLlmApplication` object configured for the ChatGPT model. The application object is then logged to the console.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/articles/new-backend-development-paradigm-in-the-new-ai-era.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  HttpLlm,\n  IHttpLlmApplication,\n  OpenApi,\n  OpenApiV3,\n  OpenApiV3_1,\n  SwaggerV2,\n} from \"@samchon/openapi\";\n\nconst main = async (): Promise<void> => {\n  const input:\n    | SwaggerV2.IDocument\n    | OpenApiV3.IDocument\n    | OpenApiV3_1.IDocument = await fetch(\n    \"https://raw.githubusercontent.com/samchon/shopping-backend/refs/heads/master/packages/api/swagger.json\"\n  ).then((r) => r.json());\n  const document: OpenApi.IDocument = OpenApi.convert(input);\n  const application: IHttpLlmApplication<\"chatgpt\"> = HttpLlm.application({\n    model: \"chatgpt\",\n    document,\n    options: {\n      reference: true,\n    },\n  });\n  console.log(application);\n};\nmain().catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: Expected Order Operations (JSON)\nDESCRIPTION: This JSON outlines the expected sequence of API operations for processing a user request to view sales, get details about a specific product (Macbook), add the most expensive stock to the shopping cart, create an order, and finally publish the order.  It defines the type of operation (standalone or anyOf) and the name/description of each shopping API call.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/4.success.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_create\",\n            \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n          }\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Notion Agent Code (TypeScript)\nDESCRIPTION: This TypeScript code demonstrates the basic structure of a Notion agent created with Agentica. It imports necessary modules, initializes the Agentica instance with OpenAI and Notion service configurations, and provides a simple example of interacting with the agent.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/notion.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\nimport dotenv from \"dotenv\";\nimport { OpenAI } from \"openai\";\n\nimport { NotionService } from \"@wrtnlabs/connector-notion\";\n\ndotenv.config();\n\nexport const agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY!,\n    }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"Notion Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<NotionService, \"chatgpt\">(),\n      execute: new NotionService(),\n    },\n  ],\n});\n\nconst main = async () => {\n  console.log(await agent.conversate(\"What can you do?\"));\n};\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Transport Authentication with Stdio (TypeScript)\nDESCRIPTION: This snippet shows how to pass environment variables to the child process when using the Stdio transport. This is useful for authentication, such as providing a GitHub personal access token.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/controller/mcp.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nawait client.connect(new StdioClientTransport({\n  command: \"npx\",\n  args: [\"-y\", \"@modelcontextprotocol/server-github\"],\n  env: {\n    GITHUB_PERSONAL_ACCESS_TOKEN: process.env.GITHUB_PERSONAL_ACCESS_TOKEN,\n    // Add other environment variables as needed\n  }\n}));\n```\n\n----------------------------------------\n\nTITLE: Setting OpenAI API Key in Environment Variables\nDESCRIPTION: This snippet shows how to define the OpenAI API key within a `.env` file. This is required for authenticating with the OpenAI API when running the RAG agent.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/coding/vector-store.mdx#_snippet_2\n\nLANGUAGE: env\nCODE:\n```\nOPENAI_API_KEY=your-openai-api-key\n```\n\n----------------------------------------\n\nTITLE: Starting Agentica with CLI\nDESCRIPTION: This snippet shows how to start a new Agentica project using the command line interface. It involves running the `npx agentica start <directory>` command, which will then prompt the user to select a package manager, project type, and embedded controllers.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/index.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npx agentica start <directory>\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with HTTP controller (Conceptual)\nDESCRIPTION: This code initializes an Agentica instance with an HTTP controller configured to interact with a shopping backend. It fetches the Swagger document from a remote source to define the API schema and sets up authentication headers for the connection.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/enterprise/shopping.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    model: \"gpt-4o-mini\",\n    api: new OpenAI({ apiKey: \"********\" }),\n  },\n  controllers: [\n    {\n      protocol: \"http\",\n      name: \"shopping\",\n      application: assertHttpLlmApplication({\n        model: \"chatgpt\",\n        document: await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n        ).then((res) => res.json()),\n      }),\n      connection: {\n        host: \"https://shopping-be.wrtn.ai\",\n        headers: {\n          Authorization: \"Bearer ********\",\n        },\n      },\n    }\n  ],\n});\nawait agent.convert(\"I wanna buy a Macbook.\");\n```\n\n----------------------------------------\n\nTITLE: IBbsArticle Interface Definition in TypeScript\nDESCRIPTION: Defines the `IBbsArticle` interface, extending `IBbsArticle.ICreate`, and including properties like `id`, `created_at`, and `updated_at` with format constraints.  This interface represents the complete structure of an article within the BBS system. The tags.Format type from the typia library is used to define string formats for validation.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/IBbsArticleSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tags } from \"typia\";\n\n/**\n * Article entity.\n *\n * `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\n */\nexport interface IBbsArticle extends IBbsArticle.ICreate {\n  /**\n   * Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n \n  /**\n   * Creation time of the article.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n \n  /**\n   * Last updated time of the article.\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n}\nexport namespace IBbsArticle {\n  /**\n   * Information of the article to create.\n   */\n  export interface ICreate {\n    /**\n     * Title of the article.\n     *\n     * Representative title of the article.\n     */\n    title: string;\n \n    /**\n     * Content body.\n     *\n     * Content body of the article writtn in the markdown format.\n     */\n    body: string;\n \n    /**\n     * Thumbnail image URI.\n     *\n     * Thumbnail image URI which can represent the article.\n     *\n     * If configured as `null`, it means that no thumbnail image in the article.\n     */\n    thumbnail:\n      | null\n      | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">);\n  }\n \n  /**\n   * Information of the article to update.\n   *\n   * Only the filled properties will be updated.\n   */\n  export type IUpdate = Partial<ICreate>;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Google Docs Agent with Agentica\nDESCRIPTION: This TypeScript code sets up a Google Docs Agent using Agentica, OpenAI, and the Google Docs Connector. It configures the agent with a specified model, OpenAI API key, and a Google Docs service instance for interacting with Google Docs.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-docs.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\nimport dotenv from \"dotenv\";\nimport { OpenAI } from \"openai\";\n\nimport { GoogleDocsService } from \"@wrtnlabs/connector-google-docs\";\n\ndotenv.config();\n\nexport const agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY!,\n    }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"Google Docs Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<GoogleDocsService, \"chatgpt\">(),\n      execute: new GoogleDocsService(),\n    },\n  ],\n});\n\nconst main = async () => {\n  console.log(await agent.conversate(\"What can you do?\"));\n};\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Setting up Agentica WebSocket Server with tgrid (TypeScript)\nDESCRIPTION: This TypeScript code demonstrates how to set up a WebSocket server using tgrid and Agentica's RPC services. It creates a WebSocketServer instance, accepts client connections, initializes an Agentica instance, and wraps it in an AgenticaRpcService. The server listens on port 3001.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/nodejs.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport {\n  AgenticaRpcService,\n  IAgenticaRpcListener,\n  IAgenticaRpcService\n} from \"@agentica/rpc\";\nimport { Driver, WebSocketServer } from \"tgrid\";\n\nconst server: WebSocketServer<\n  null,\n  IAgenticaRpcService<\"chatgpt\">,\n  IAgenticaRpcListener\n> = new WebSocketServer();\nawait server.open(3_001, async (acceptor) => {\n  const agent: Agentica<\"chatgpt\"> = new Agentica({ ... });\n  const listener: Driver<IAgenticaRpcListener> = acceptor.getDriver();\n  const service: AgenticaRpcService<\"chatgpt\"> = \n    new AgenticaRpcService({\n      agent,\n      listener,\n    });\n  await acceptor.accept(service);\n});\n```\n\n----------------------------------------\n\nTITLE: Configure Vector Selector with SQLite\nDESCRIPTION: This code configures the Agentica Vector Selector to use an SQLite database as the vector store. It initializes an SQLite database using `better-sqlite3`, configures the vector selector with the `configureSqliteStrategy` function, and passes the database instance and Cohere API key.  It integrates the selector into an Agentica agent and includes code to warm up the selector.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/vector-selector.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BootAgenticaVectorSelector } from \"@agentica/vector-selector\";\nimport { configureSqliteStrategy } from \"@agentica/vector-selector/strategy\";\nimport Database from \"better-sqlite3\";\n\n// Initialize SQLite database\nconst db = new Database(\"vector-store.sqlite\");\n\nconst selectorExecute = BootAgenticaVectorSelector({\n  strategy: configureSqliteStrategy<\"chatgpt\">({\n    db: db,\n    cohereApiKey: process.env.COHERE_API_KEY,\n  }),\n});\n\nconst agent = new Agentica({\n  // ... other configurations\n  config: {\n    executor: {\n      select: selectorExecute,\n    }\n  }\n});\n\n// Optional: Warm up the vector selector\nconst ctxForWarming = agent.getContext({\n  prompt: {\n    role: \"user\",\n    text: \"warming\",\n    type: \"text\",\n    toJSON: () => ({\n      role: \"user\",\n      text: \"warming\",\n      type: \"text\",\n    }),\n  },\n  usage: AgenticaTokenUsage.zero(),\n});\nawait selectorExecute(ctxForWarming);\n```\n\n----------------------------------------\n\nTITLE: Starting Agentica with pnpm\nDESCRIPTION: This command starts the Agentica development environment using pnpm as the package manager. It specifies the directory where the Agentica project should be initialized and uses the `--manager` flag to indicate the package manager.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/cli.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica start <directory> --manager pnpm\n```\n\n----------------------------------------\n\nTITLE: Generating SDK with Nestia CLI (npm)\nDESCRIPTION: Generates a Software Development Kit (SDK) for frontend applications using the `nestia sdk` command. This SDK allows client applications to interact with the backend server in a type-safe and convenient manner. Requires `@nestia/sdk` to be installed and a `nestia.config.ts` file to be configured.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/nestjs.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpx nestia sdk\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping NestJS with WebSocket Adaptor\nDESCRIPTION: Upgrades a NestJS application to support the WebSocket protocol using the `WebSocketAdaptor` from `@nestia/core`. This allows the application to handle both HTTP and WebSocket connections. Requires `@nestjs/common`, `@nestjs/core`, `@nestjs/platform-express`, `@nestia/core` and a defined NestJS Module (e.g., `MyModule`).\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/nestjs.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WebSocketAdaptor } from \"@nestia/core\";\nimport { INestApplication } from \"@nestjs/common\";\nimport { NestFactory } from \"@nestjs/core\";\n\nimport { MyModule } from \"./MyModule\";\n\nconst app: INestApplication = await NestFactory.create(MyModule);\nawait WebSocketAdaptor.upgrade(app);\nawait app.listen(3_001, \"0.0.0.0\");\n```\n\n----------------------------------------\n\nTITLE: Defining IBbsArticle Interface in TypeScript\nDESCRIPTION: This TypeScript code defines the IBbsArticle interface, representing an article in a Bulletin Board System (BBS). It includes properties such as id, created_at, updated_at, title, body, and thumbnail. The code uses the 'typia' library for type validation and formatting, including UUID and date-time formats, as well as content media type for the thumbnail.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/DocumentationStrategyNamespaceSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tags } from \"typia\";\n \n/**\n * Article entity.\n *\n * `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\n */\nexport interface IBbsArticle extends IBbsArticle.ICreate {\n  /**\n   * Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n \n  /**\n   * Creation time of the article.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n \n  /**\n   * Last updated time of the article.\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n}\nexport namespace IBbsArticle {\n  /**\n   * Information of the article to create.\n   */\n  export interface ICreate {\n    /**\n     * Title of the article.\n     *\n     * Representative title of the article.\n     */\n    title: string;\n \n    /**\n     * Content body.\n     *\n     * Content body of the article writtn in the markdown format.\n     */\n    body: string;\n \n    /**\n     * Thumbnail image URI.\n     *\n     * Thumbnail image URI which can represent the article.\n     *\n     * If configured as `null`, it means that no thumbnail image in the article.\n     */\n    thumbnail:\n      | null\n      | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">);\n  }\n \n  /**\n   * Information of the article to update.\n   *\n   * Only the filled properties will be updated.\n   */\n  export type IUpdate = Partial<ICreate>;\n}\n```\n\n----------------------------------------\n\nTITLE: Youtube Search Agent Setup with Agentica\nDESCRIPTION: This TypeScript code demonstrates setting up a Youtube Search Agent using Agentica, OpenAI, and the YoutubeSearchService connector. It initializes the agent with necessary configurations and API keys, enabling it to interact with the Youtube Search API and OpenAI's GPT model.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/youtube-search.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\nimport dotenv from \"dotenv\";\nimport { OpenAI } from \"openai\";\n\nimport { YoutubeSearchService } from \"@wrtnlabs/connector-youtube-search\";\n\ndotenv.config();\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: process.env.OPENAI_API_KEY! }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"Youtube Search Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<YoutubeSearchService, \"chatgpt\">(),\n      execute: new YoutubeSearchService({\n        serpApiKey: process.env.SERP_API_KEY!,\n        googleApiKey: process.env.GOOGLE_API_KEY!,\n        searchApiKey: process.env.SEARCH_API_KEY!,\n      }),\n    },\n  ],\n});\n\nconst main = async () => {\n  console.log(await agent.conversate(\"What can you do?\"));\n};\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Install Node.js Dependencies\nDESCRIPTION: This command installs the necessary Node.js type definitions using npm.  This is a prerequisite for using the `fs` module with TypeScript.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/coding/file-system.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @types/node\n```\n\n----------------------------------------\n\nTITLE: Implement Custom Vector Selector Strategy\nDESCRIPTION: This code demonstrates how to implement a custom vector selector strategy by implementing the `IAgenticaVectorSelectorStrategy` interface. It defines a `CustomVectorSelector` class with the required `searchTool` and `embedContext` methods. The `searchTool` method should implement the custom logic for searching tools, and the `embedContext` method should implement the logic for embedding the context into the vector space.  The code then configures the vector selector to use this custom strategy and integrates into an Agentica agent.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/vector-selector.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IAgenticaVectorSelectorStrategy } from \"@agentica/vector-selector\";\nimport type { AgenticaContext } from \"@agentica/core\";\n\nclass CustomVectorSelector implements IAgenticaVectorSelectorStrategy<\"chatgpt\"> {\n  async searchTool(\n    ctx: AgenticaContext<\"chatgpt\">,\n    query: string\n  ): Promise<{\n    name: string;\n    description: string | undefined;\n  }[]> {\n    // Implement your custom tool search logic here\n    // This should return a list of tools that match the query\n    return [];\n  }\n\n  async embedContext(props: {\n    ctx: AgenticaContext<\"chatgpt\">;\n    setEmbedded: () => void;\n  }): Promise<void> {\n    // Implement your custom context embedding logic here\n    // This is called when the context needs to be embedded into vector space\n  }\n}\n\n// Use your custom strategy\nconst selectorExecute = BootAgenticaVectorSelector({\n  strategy: new CustomVectorSelector(),\n});\n\nconst agent = new Agentica({\n  // ... other configurations\n  config: {\n    executor: {\n      select: selectorExecute,\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Agentica Initialization with TypeScript and OpenAI\nDESCRIPTION: This snippet demonstrates how to initialize an Agentica instance using TypeScript, integrating with OpenAI's API. It includes configuration for the OpenAI model, along with defining controllers that expose functions from TypeScript classes and Swagger/OpenAPI documents. The snippet also showcases how to initiate a conversation with the agent.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/benchmark/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\nimport { MobileFileSystem } from \"./services/MobileFileSystem\";\n\nconst agent = new Agentica({\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    // functions from TypeScript class\n    {\n      protocol: \"http\",\n      application: typia.llm.application<MobileFileSystem, \"chatgpt\">(),\n      execute: new MobileFileSystem(),\n    },\n    // functions from Swagger/OpenAPI\n    {\n      protocol: \"http\",\n      application: assertHttpLlmApplication({\n        model: \"chatgpt\",\n        document: await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n        ).then(r => r.json()),\n      }),\n      connection: {\n        host: \"https://shopping-be.wrtn.ai\",\n        headers: { Authorization: \"Bearer ********\" },\n      },\n    },\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Listening for Execute Event in Agentica\nDESCRIPTION: This code snippet demonstrates how to listen for the 'execute' event in an Agentica agent. The 'execute' event is triggered after a function is executed and returns a value. The code logs the operation name, arguments, and return value to the console. It requires the `@agentica/core` and `openai` packages.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/event.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, AgenticaEvent } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [...],\n});\nagent.on(\"execute\", async (event) => {\n  console.log(\n    \"execute\",\n    event.operation.name,\n    event.arguments,\n    event.value,\n  );\n});\nawait agent.conversate(\"I wanna buy Surface Pro\");\n```\n\n----------------------------------------\n\nTITLE: Expected Shopping Operations\nDESCRIPTION: This JSON object represents the expected sequence of operations based on the user's prompt. It outlines the API calls needed to list sales, retrieve detailed product information, create an order, and publish the order.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/2.success.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_create\",\n            \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n          }\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with Claude and OpenAI (TypeScript)\nDESCRIPTION: This snippet demonstrates how to initialize an Agentica instance using Claude 3.1, OpenAI, and OpenRouter. It configures the model, vendor API key, base URL, and controller for HTTP requests using the BbsArticleService. The agent is then used to start a conversation.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaExampleVendorMistralSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { \n  Agentica,\n  IAgenticaController,\n  IAgenticaProps,\n  IAgenticaVendor\n} from \"@agentica/core\";\nimport OpenAI from \"openai\";\n \nimport { BbsArticleService } from \"./services/BbsArticleService\";\n \nconst agent: Agentica<\"3.1\"> = new Agentica({\n  model: \"3.1\",\n  vendor: {\n    model: \"mistralai/mistral-small-3.1-24b-instruct\",\n    api: new OpenAI({\n      apiKey: \"********\",\n      baseURL: \"https://openrouter.ai/api/v1\",\n    }),\n  } satisfies IAgenticaVendor,\n  controllers: [\n    {\n      protocol: \"http\",\n      name: \"class\",\n      application: typia.llm.application<BbsArticleService, \"3.1\">(),\n      execute: new BbsArticleService(),\n    } satisfies IAgenticaController<\"3.1\">,\n  ]\n} satisfies IAgenticaProps<\"3.1\">);\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Configure Vector Selector with PostgreSQL\nDESCRIPTION: This code configures the Agentica Vector Selector to use a PostgreSQL vector store via the connector-hive server. It first checks if the connector-hive server is running. If the server is available, it configures the vector selector with the `configurePostgresStrategy` function and passes the connector-hive host. Finally, it integrates the vector selector into the Agentica agent's configuration.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/vector-selector.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BootAgenticaVectorSelector } from \"@agentica/vector-selector\";\nimport { configurePostgresStrategy } from \"@agentica/vector-selector/strategy\";\n\n// Check if connector-hive is running\nif (!(await fetch(`${connectorHiveUrl}/health`).catch(() => ({ ok: false }))).ok) {\n  throw new Error(\"Connector Hive is not running\");\n}\n\nconst selectorExecute = BootAgenticaVectorSelector({\n  strategy: configurePostgresStrategy<\"chatgpt\">({\n    host: connectorHiveUrl,\n  }),\n});\n\nconst agent = new Agentica({\n  // ... other configurations\n  config: {\n    executor: {\n      select: selectorExecute,\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Agentica Initialization with Deepseek\nDESCRIPTION: This snippet initializes an Agentica instance with the Deepseek language model, configures the OpenAI API as the vendor, and sets up a controller for the BbsArticleService. It showcases the configuration of the agent with a specific model, API key, and service endpoint.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaExampleVendorDeepSeekSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst agent: Agentica<\"llama\"> = new Agentica({\n  model: \"llama\",\n  vendor: {\n    model: \"deepseek/deepseek-chat-v3-0324\",\n    api: new OpenAI({\n      apiKey: \"********\",\n      baseURL: \"https://openrouter.ai/api/v1\",\n    }),\n  } satisfies IAgenticaVendor,\n  controllers: [\n    {\n      protocol: \"http\",\n      name: \"class\",\n      application: typia.llm.application<BbsArticleService, \"3.1\">(),\n      execute: new BbsArticleService(),\n    } satisfies IAgenticaController<\"3.1\">,\n  ]\n} satisfies IAgenticaProps<\"3.1\">);\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Initializing Typia (CLI)\nDESCRIPTION: These commands initialize Typia using its CLI and install any necessary dependencies.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/react-native.mdx#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nnpx typia setup\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Super AI Chatbot Development with Agentica\nDESCRIPTION: This TypeScript snippet shows how to develop a Super AI Chatbot using the `@agentica/core` library, leveraging a Swagger document for API definitions.  It fetches a Swagger document, converts it using `@samchon/openapi`, and configures an `Agentica` instance with an OpenAI API key and the converted application. It also sets up event listeners for 'select' and 'execute' events.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/articles/new-backend-development-paradigm-in-the-new-ai-era.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { HttpLlm, IHttpLlmApplication, OpenApi } from \"@samchon/openapi\";\nimport { Agentica } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst main = async (): Promise<void> => {\n  const application: IHttpLlmApplication<\"chatgpt\"> = HttpLlm.application({\n    model: \"chatgpt\",\n    document: OpenApi.convert(\n      await fetch(\"https://shopping-be.wrtn.ai/editor/swagger.json\").then((r) =>\n        r.json()\n      )\n    ),\n  });\n  const agent: Agentica<\"chatgpt\"> = new Agentica({\n    model: \"chatgpt\",\n    vendor: {\n      api: new OpenAI({\n        apiKey: \"YOUR_OPENAI_API_KEY\",\n      }),\n      model: \"gpt-4o-mini\",\n    },\n    controllers: [\n      {\n        protocol: \"http\",\n        name: \"shopping\",\n        application,\n        connection: {\n          host: \"https://shopping-be.wrtn.ai\",\n        },\n      },\n    ],\n    config: {\n      locale: \"en-US\",\n    },\n  });\n  agent.on(\"select\", async (select) => {});\n  agent.on(\"execute\", async (execute) => {});\n  await agent.conversate(\"What you can do?\");\n};\nmain().catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: Install Core Library with Yarn\nDESCRIPTION: Installs the core Agentica library along with its dependencies, @samchon/openapi and typia, using Yarn. Includes a typia setup command. This setup is necessary for converting Swagger/OpenAPI documents and composing LLM function calling schemas. Note: Yarn Berry is not supported.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/manual.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# YARN BERRY IS NOT SUPPORTED\nyarn add @agentica/core @samchon/openapi typia\nyarn typia setup\n```\n\n----------------------------------------\n\nTITLE: Google API Credentials Configuration\nDESCRIPTION: This snippet shows the environment variables needed to configure the Google API credentials for the Google Calendar Agent. It includes the OpenAI API key, Google Calendar client ID, client secret, and refresh token.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-calendar.mdx#_snippet_2\n\nLANGUAGE: env\nCODE:\n```\nOPENAI_API_KEY=your-openai-api-key\nGOOGLE_CALENDAR_CLIENT_ID=your-google-calendar-client-id\nGOOGLE_CALENDAR_CLIENT_SECRET=your-google-calendar-client-secret\nGOOGLE_CALENDAR_REFRESH_TOKEN=your-google-calendar-refresh-token\n```\n\n----------------------------------------\n\nTITLE: Initializing AgenticaSelectBenchmark (Basic)\nDESCRIPTION: This snippet demonstrates the basic initialization and execution of the AgenticaSelectBenchmark. It imports necessary modules, creates an Agentica instance, and configures the benchmark with repeat and simultaneous execution settings. The code then executes the benchmark and generates a report.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/benchmark.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { \n  AgenticaSelectBenchmark,\n  IAgenticaSelectBenchmarkScenario\n} from \"@agentica/benchmark\";\nimport { Agentica } from \"@agentica/core\";\n\nconst agent = new Agentica({ ... });\nconst benchmark = new AgenticaSelectBenchmark({\n  agent,\n  config: {\n    repeat: 4,\n    simultaneous: 100,\n  },\n  scenarios: [...] satisfies IAgenticaSelectBenchmarkScenario[],\n});\nawait benchmark.execute();\n\nconst docs: Record<string, string> = benchmark.report();\nawait archiveReport(docs);\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Calculator Controller in React Native\nDESCRIPTION: This code demonstrates how to implement a simple calculator with addition and subtraction functions within Agentica using the `IAgenticaController` interface.  It shows how to define function parameters using interfaces, document them with JSDoc for AI understanding, and create the controller to expose the functions to Agentica.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/react-native/battery.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n/**\n * A basic calculator that performs addition and subtraction operations.\n */\nnamespace Calculator {\n  /**\n   * Parameters for addition operation\n   */\n  interface AddProps {\n    /**\n     * First number to add\n     */\n    a: number;\n    /**\n     * Second number to add\n     */\n    b: number;\n  }\n\n  /**\n   * Parameters for subtraction operation\n   */\n  interface SubProps {\n    /**\n     * Number to subtract from\n     */\n    a: number;\n    /**\n     * Number to subtract\n     */\n    b: number;\n  }\n\n  /**\n   * Adds two numbers together.\n   * @returns The sum of two numbers\n   */\n  export function add(props: AddProps): number {\n    return props.a + props.b;\n  }\n\n  /**\n   * Subtracts the second number from the first number.\n   * @returns The result of subtracting the second number from the first number\n   */\n  export function sub(props: SubProps): number {\n    return props.a - props.b;\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Agentica: Joining Text Event in TypeScript\nDESCRIPTION: This snippet demonstrates how to join all text pieces of a stream into a single string using the `join()` method of the Agentica event. It initializes an Agentica instance and attaches an event listener to the 'text' event, concatenating all streamed text and logging the complete text content.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/event.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, AgenticaEvent } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [...],\n});\nagent.on(\"text\", async (event) => {\n  const text: string = await event.join();\n  console.log(\"Text from\", event.role, text);\n});\nawait agent.conversate(\"I wanna buy Surface Pro\");\n```\n\n----------------------------------------\n\nTITLE: Environment Variables Setup\nDESCRIPTION: These environment variables are required for the Google Scholar Agent to function.  OPENAI_API_KEY is used to authenticate with OpenAI, and SERP_API_KEY is used to authenticate with the SerpApi for Google Scholar searches.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-scholar.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nOPENAI_API_KEY=your-openai-api-key\nSERP_API_KEY=your-serp-api-key\n```\n\n----------------------------------------\n\nTITLE: Install Google Shopping Connector\nDESCRIPTION: This command installs the required Google Shopping connector package using npm. It is a prerequisite for using the Google Shopping agent.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-shopping.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @wrtnlabs/connector-google-shopping\n```\n\n----------------------------------------\n\nTITLE: Generated Javascript Schema for ChatGPT parameters\nDESCRIPTION: This JavaScript code snippet shows the JSON schema that is generated from the TypeScript code using typia.  It includes descriptions, types, and constraints for each parameter, such as the id (string with uuid format), age (integer with maximum value of 100), and email (string with email format).\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/vendor.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\n({\n  description: \"\",\n  type: \"object\",\n  properties: {\n    id: {\n      title: \"Primary Key\",\n      description:\n        \"Primary Key.\\n\\nPrimary Key generated by System.\\n\\n\\n@format uuid\",\n      type: \"string\",\n    },\n    age: {\n      title: \"Age of the user\",\n      description:\n        \"Age of the user.\\n\\nAge of the user in years.\\n\\n\\n@minimum 0\\n@maximum 100\",\n      type: \"integer\",\n    },\n    email: {\n      title: \"Email address of the user\",\n      description:\n        \"Email address of the user.\\n\\nEmail address written when membership joining.\\n\\n\\n@format email\",\n      type: \"string\",\n    },\n  },\n  required: [\"id\", \"age\", \"email\"],\n  additionalProperties: false,\n  $defs: {},\n});\n```\n\n----------------------------------------\n\nTITLE: Gmail Agent Initialization\nDESCRIPTION: This TypeScript code initializes a Gmail Agent using the Agentica framework. It configures the agent with the OpenAI model, API key, and the GmailService connector to enable interaction with Gmail.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/gmail.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\nimport dotenv from \"dotenv\";\nimport { OpenAI } from \"openai\";\n\nimport { GmailService } from \"@wrtnlabs/connector-gmail\";\n\ndotenv.config();\n\nexport const agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY!,\n    }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"Gmail Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<GmailService, \"chatgpt\">(),\n      execute: new GmailService(),\n    },\n  ],\n});\n\nconst main = async () => {\n  console.log(await agent.conversate(\"What can you do?\"));\n};\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Limit Google Shopping Agent Functions\nDESCRIPTION: This TypeScript code demonstrates how to limit the functions available to the Google Shopping Agent using TypeScript's `Pick` utility type. This code makes only `aliExpress` and `iherb` available.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-shopping.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport const GoogleShoppingAgent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: openai,\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"Google Shopping Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<\n        Pick<GoogleShoppingService, \"aliExpress\" | \"iherb\">,\n        \"chatgpt\"\n      >(),\n      execute: new GoogleShoppingService({\n        apiKey: process.env.SERP_API_KEY!,\n      }),\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Chat API Endpoint (Server)\nDESCRIPTION: This TypeScript code snippet defines a chat API endpoint using Nestia and the Agentica RPC SDK. It exports an asynchronous function `start` that accepts a connection object and a provider (IAgenticaRpcListener) and returns a connector and a driver.  The function establishes a WebSocket connection to the specified host and path, and returns objects allowing communication with the agent.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/nestjs.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @packageDocumentation\n * @module api.functional.chat\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\n */\n//================================================================\nimport type { IAgenticaRpcListener } from \"@agentica/rpc/lib/IAgenticaRpcListener\";\nimport type { IAgenticaRpcService } from \"@agentica/rpc/lib/IAgenticaRpcService\";\nimport type { IConnection } from \"@nestia/fetcher\";\nimport { WebSocketConnector } from \"tgrid\";\nimport type { Driver } from \"tgrid\";\n\n/**\n * @controller MyChatController.start\n * @path /chat\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\n */\nexport async function start(\n  connection: IConnection<start.Header>,\n  provider: start.Provider,\n): Promise<start.Output> {\n  const connector: WebSocketConnector<\n    start.Header,\n    start.Provider,\n    start.Listener\n  > = new WebSocketConnector(connection.headers ?? ({} as any), provider);\n  await connector.connect(\n    `${connection.host.endsWith(\"/\") ? connection.host.substring(0, connection.host.length - 1) : connection.host}${start.path()}`,\n  );\n  const driver: Driver<start.Listener> = connector.getDriver();\n  return {\n    connector,\n    driver,\n  };\n}\nexport namespace start {\n  export type Output = {\n    connector: WebSocketConnector<Header, Provider, Listener>;\n    driver: Driver<Listener>;\n  };\n  export type Header = undefined;\n  export type Provider = IAgenticaRpcListener;\n  export type Listener = IAgenticaRpcService<\"chatgpt\">;\n\n  export const path = () => \"/chat\";\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Agentica Dependencies (pnpm)\nDESCRIPTION: Installs necessary packages including @agentica/rpc, tgrid, @agentica/core, and @samchon/openapi using pnpm. These packages are required for building WebSocket client applications with Agentica.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/client.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm install @agentica/core @agentica/rpc tgrid\npnpm install @agentica/core @samchon/openapi\n```\n\n----------------------------------------\n\nTITLE: Generating Frontend Code from TypeScript Type\nDESCRIPTION: This snippet demonstrates how to generate frontend code from a TypeScript type using `typia.llm.parameters<Schema, Model, Config>()` and `AutoViewAgent`. It showcases the creation of an `AutoViewAgent` instance, code generation using `agent.generate()`, and saving the generated code to a file.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/related/autoview.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AutoViewAgent } from \"@autoview/agent\";\nimport fs from \"fs\";\nimport OpenAI from \"openai\";\nimport typia, { tags } from \"typia\";\n\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  name: string;\n  age: number & tags.Minimum<0> & tags.Maximum<100>;\n  thumbnail: string & tags.Format<\"uri\"> & tags.ContentMediaType;\n}\n\nconst agent: AutoViewAgent = new AutoViewAgent({\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"o3-mini\",\n  },\n  inputSchema: {\n    parameters: typia.llm.parameters<\n      IMember,\n      \"chatgpt\",\n      { reference: true }\n    >(),\n  },\n});\nconst result: IAutoViewResult = await agent.generate();\n\nawait fs.promises.writeFile(\n  \"./src/transformers/transformMember.ts\",\n  result.transformTsCode,\n  \"utf8\",\n);\n```\n\n----------------------------------------\n\nTITLE: Expected Shopping Operations JSON\nDESCRIPTION: This JSON outlines the expected sequence of operations for the shopping scenario, including listing sales, retrieving detailed information about a specific product (Macbook), creating a shopping order, and publishing the order. Each operation is described with its name and a detailed explanation of its purpose, dependencies and how it should be used by an A.I. chatbot.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/select/order/2.success.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_create\",\n            \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n          }\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Agentica: Streaming Describe Event in TypeScript\nDESCRIPTION: This snippet illustrates how to stream 'describe' events from Agentica. It sets up an Agentica instance and an event listener for the 'describe' event. It processes the stream of text data and function execution information related to function calling results.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/event.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, AgenticaEvent } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [...],\n});\nagent.on(\"describe\", async (event) => {\n  console.log(\"Describe Function Calling\");\n  for (const execute of event.executes)\n    console.log(`  - ${execute.operation.name}`);\n  for await (const text of event.stream)\n    process.stdout.write(text);\n  process.stdout.write(\"\\n\");\n});\nawait agent.conversate(\"I wanna buy Surface Pro\");\n```\n\n----------------------------------------\n\nTITLE: AI Code Validation Principles\nDESCRIPTION: This snippet outlines the principles used by `@autoview` to validate AI-generated frontend code. It involves finding a function, compiler feedback, validation feedback, and exception feedback to guide the AI in writing correct frontend code.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/related/autoview.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { FunctionCall } from \"pseudo\";\nimport { IValidation } from \"typia\";\n\nexport const correctCompile = <T>(ctx: {\n  call: FunctionCall;\n  compile: (src: string) => Promise<IValidation<(v: T) => IAutoViewComponentProps>>;\n  random: () => T;\n  repeat: number;\n  retry: (reason: string, errors?: IValidation.IError[]) => Promise<unknown>;\n}): Promise<(v: T) => IAutoViewComponentProps>> => {\n  // FIND FUNCTION\n  if (ctx.call.name !== \"render\")\n    return ctx.retry(\"Unable to find function. Try it again\");\n\n  //----\n  // COMPILER FEEDBACK\n  //----\n  const result: IValidation<(v: T) => IAutoViewComponentProps>> =\n    await ctx.compile(call.arguments.source);\n  if (result.success === false)\n    return ctx.retry(\"Correct compilation errors\", result.errors);\n\n  //----\n  // VALIDATION FEEDBACK\n  //----\n  for (let i: number = 0; i < ctx.repeat; ++i) {\n    const value: T = ctx.random(); // random value generation\n    try {\n      const props: IAutoViewComponentProps = result.data(value);\n      const validation: IValidation<IAutoViewComponentProps> =\n        func.validate(props); //validate AI generated function\n      if (validation.success === false)\n        return ctx.retry(\n          \"Type errors are detected. Correct it through validation errors\",\n          {\n            errors: validation.errors,\n          },\n        );\n    } catch (error) {\n      //----\n      // EXCEPTION FEEDBACK\n      //----\n      return ctx.retry(\n        \"Runtime error occurred. Correct by the error message\",\n        {\n          errors: [\n            {\n              path: \"$input\",\n              name: error.name,\n              reason: error.message,\n              stack: error.stack,\n            }\n          ]\n        }\n      )\n    }\n  }\n  return result.data;\n}\n```\n\n----------------------------------------\n\nTITLE: Server WebSocket Server with TGrid\nDESCRIPTION: This snippet illustrates how to set up a WebSocket server using TGrid's `WebSocketServer`. The server authenticates incoming connections based on the provided authorization header. Upon successful authentication, it creates an `AgenticaRpcService` instance and accepts the connection, making the service available for remote procedure calls.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/index.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport {\n  AgenticaRpcService,\n  IAgenticaRpcListener,\n  IAgenticaRpcService\n} from \"@agentica/rpc\";\nimport { Driver, WebSocketServer } from \"tgrid\";\n\nimport { authorizeToken } from \"./internal/authorizeToken\";\n\nconst server: WebSocketServer<\n  IAuthorizationHeader,\n  IAgenticaRpcService<\"chatgpt\">,\n  IAgenticaRpcListener\n> = new WebSocketServer();\nawait server.open(3_001, async (acceptor) => {\n  try {\n    await authorizeToken(acceptor.header);\n  } catch (error) {\n    await acceptor.reject(1008, (error as Error).message);\n    return;\n  }\n  const agent: Agentica<\"chatgpt\"> = new Agentica({ ... });\n  const listener: Driver<IAgenticaRpcListener> = acceptor.getDriver();\n  const service: AgenticaRpcService<\"chatgpt\"> = \n    new AgenticaRpcService({\n      agent,\n      listener,\n    });\n  await acceptor.accept(service);\n});\n\ninterface IAuthorizationHeader {\n  Authorization: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining 'create' Function for Article Creation\nDESCRIPTION: This defines the 'create' function for creating a new article. It specifies input parameters (an object containing the article data), the output schema (the created article object), and a description.  The input schema includes 'title', 'body', and 'thumbnail' (URI or null). It also includes a validation function generated by typia, ensuring data conforms to the schema.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/LlmApplicationJavaScriptSnippet.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n    {\n      name: \"create\",\n      parameters: {\n        description: \" Properties of create function\",\n        type: \"object\",\n        properties: {\n          input: {\n            description:\n              \"Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the current {@link IBbsArticle.ICreate} type:\\n\\n> Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the parent {@link IBbsArticle} type:\\n\\n> Article entity.\\n> \\n> `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n            type: \"object\",\n            properties: {\n              title: {\n                title: \"Title of the article\",\n                description:\n                  \"Title of the article.\\n\\nRepresentative title of the article.\",\n                type: \"string\",\n              },\n              body: {\n                title: \"Content body\",\n                description:\n                  \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n                type: \"string\",\n              },\n              thumbnail: {\n                title: \"Thumbnail image URI\",\n                description:\n                  \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n                anyOf: [\n                  {\n                    type: \"null\",\n                  },\n                  {\n                    type: \"string\",\n                    description: \"@format uri\\n@contentMediaType image/*\",\n                  },\n                ],\n              },\n            },\n            required: [\"title\", \"body\", \"thumbnail\"],\n          },\n        },\n        required: [\"input\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      output: {\n        description:\n          \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Primary Key\",\n            description: \"Primary Key.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n          created_at: {\n            title: \"Creation time of the article\",\n            description: \"Creation time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n          updated_at: {\n            title: \"Last updated time of the article\",\n            description:\n              \"Last updated time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n          title: {\n            title: \"Title of the article\",\n            description:\n              \"Title of the article.\\n\\nRepresentative title of the article.\",\n            type: \"string\",\n          },\n          body: {\n            title: \"Content body\",\n            description:\n              \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n            type: \"string\",\n          },\n          thumbnail: {\n            title: \"Thumbnail image URI\",\n            description:\n              \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n            anyOf: [\n              {\n                type: \"null\",\n              },\n              {\n                type: \"string\",\n                description: \"@format uri\\n@contentMediaType image/*\",\n              },\n            ],\n          },\n        },\n        required: [\n          \"id\",\n          \"created_at\",\n          \"updated_at\",\n          \"title\",\n          \"body\",\n          \"thumbnail\",\n        ],\n      },\n      description:\n        \"Create a new article.\\n\\nWrites a new article and archives it into the DB.\",\n      validate: (() => {\n        const _io0 = (input) =>\n          \"object\" === typeof input.input &&\n          null !== input.input &&\n          _io1(input.input);\n        const _io1 = (input) =>\n          \"string\" === typeof input.title &&\n          \"string\" === typeof input.body &&\n          (null === input.thumbnail ||\n            (\"string\" === typeof input.thumbnail &&\n              __typia_transform__isFormatUri._isFormatUri(input.thumbnail)));\n        const _vo0 = (input, _path, _exceptionable = true) =>\n          [\n            (((\"object\" === typeof input.input && null !== input.input) ||\n              _report(_exceptionable, {\n                path: _path + \".input\",\n                expected: \"IBbsArticle.ICreate\",\n                value: input.input,\n              })) &&\n              _vo1(input.input, _path + \".input\", true && _exceptionable)) ||\n              _report(_exceptionable, {\n                path: _path + \".input\",\n                expected: \"IBbsArticle.ICreate\",\n                value: input.input,\n              }),\n          ].every((flag) => flag);\n        const _vo1 = (input, _path, _exceptionable = true) =>\n          [\n            \"string\" === typeof input.title ||\n              _report(_exceptionable, {\n                path: _path + \".title\",\n                expected: \"string\",\n                value: input.title,\n              }),\n            \"string\" === typeof input.body ||\n              _report(_exceptionable, {\n                path: _path + \".body\",\n                expected: \"string\",\n                value: input.body,\n              }),\n            null === input.thumbnail ||\n              (\"string\" === typeof input.thumbnail &&\n                (__typia_transform__isFormatUri._isFormatUri(input.thumbnail) ||\n                  _report(_exceptionable, {\n                    path: _path + \".thumbnail\",\n                    expected: 'string & Format<\"uri\">',\n                    value: input.thumbnail,\n                  }))) ||\n              _report(_exceptionable, {\n                path: _path + \".thumbnail\",\n                expected:\n                  '((string & Format<\"uri\"> & ContentMediaType<\"image/*\">) | null)',\n                value: input.thumbnail,\n              }),\n          ].every((flag) => flag);\n        const __is = (input) =>\n          \"object\" === typeof input && null !== input && _io0(input);\n        let errors;\n        let _report;\n        return (input) => {\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with Llama Model (TypeScript)\nDESCRIPTION: This snippet initializes an Agentica instance named 'agent' with the 'llama' model. It configures the vendor to use OpenAI via OpenRouter with a specified API key and base URL. It also sets up a controller using the BbsArticleService, enabling HTTP protocol and class-based execution.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaExampleVendorLlamaSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst agent: Agentica<\"llama\"> = new Agentica({\n  model: \"llama\",\n  vendor: {\n    model: \"meta-llama/llama3.3-70b\",\n    api: new OpenAI({\n      apiKey: \"********\",\n      baseURL: \"https://openrouter.ai/api/v1\",\n    }),\n  } satisfies IAgenticaVendor,\n  controllers: [\n    {\n      protocol: \"http\",\n      name: \"class\",\n      application: typia.llm.application<BbsArticleService, \"llama\">(),\n      execute: new BbsArticleService(),\n    } satisfies IAgenticaController<\"llama\">,\n  ]\n} satisfies IAgenticaProps<\"llama\">);\n```\n\n----------------------------------------\n\nTITLE: Running NestJS Server Project\nDESCRIPTION: These commands navigate to the NestJS server project directory, install dependencies, and then build and start the application. The 'build' command compiles the TypeScript code, and 'start' launches the server.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/index.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# move to nestjs project folder\ncd server\n\n# install dependencies\nnpm install\n\n# build & run\nnpm run build && npm run start\n```\n\n----------------------------------------\n\nTITLE: Installing Agentica OpenAI Vector Store Package\nDESCRIPTION: This command installs the @agentica/openai-vector-store package, which is necessary for connecting Agentica to a vector store for document retrieval.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/coding/vector-store.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @agentica/openai-vector-store\n```\n\n----------------------------------------\n\nTITLE: Generating Frontend Code from non-object TypeScript\nDESCRIPTION: This snippet shows how to generate frontend code from a non-object TypeScript type, such as an array (`Array<IMember>`), using `typia.llm.schema<Schema, Model, Config>()`. It highlights the importance of pre-defining and assigning a `$defs` variable of type `Record<string, IChatGptSchema>` when using this function.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/related/autoview.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AutoViewAgent } from \"@autoview/agent\";\nimport fs from \"fs\";\nimport OpenAI from \"openai\";\nimport typia, { tags } from \"typia\";\n\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  name: string;\n  age: number & tags.Minimum<0> & tags.Maximum<100>;\n  thumbnail: string & tags.Format<\"uri\"> & tags.ContentMediaType;\n}\n\n// LLM SCHEMA GENERATION\nconst $defs: Record<string, IChatGptSchema> = {};\nconst schema: IChatGptSchema = typia.llm.schema<\n  Array<IMember>,\n  \"chatgpt\",\n  { reference: true }\n>({ $defs });\n\n// CODE GENERATION\nconst agent: AutoViewAgent = new AutoViewAgent({\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"o3-mini\",\n  },\n  inputSchema: {\n    $defs,\n    schema,\n  },\n  transformFunctionName: \"transformMember\",\n});\nconst result: IAutoViewResult = await agent.execute();\n\nawait fs.promises.writeFile(\n  \"./src/transformers/transformMember.ts\",\n  result.transformTsCode,\n  \"utf8\",\n);\n```\n\n----------------------------------------\n\nTITLE: BbsArticleService Class Definition TypeScript\nDESCRIPTION: Defines the `BbsArticleService` class with methods for CRUD operations on `IBbsArticle` objects. It initializes an empty array to store articles and uses `uuid` for generating unique IDs.  The class includes methods like `index`, `create`, `update`, and `erase` for managing the articles.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/BbsArticleServiceSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tags } from \"typia\";\nimport { v4 } from \"uuid\";\n\nimport { IBbsArticle } from \"./IBbsArticle\";\n\nexport class BbsArticleService {\n  private readonly articles: IBbsArticle[] = [];\n\n  /**\n   * Get all articles.\n   *\n   * List up every articles archived in the BBS DB.\n   *\n   * @returns List of every articles\n   */\n  public index(): IBbsArticle[] {\n    return this.articles;\n  }\n\n  /**\n   * Create a new article.\n   *\n   * Writes a new article and archives it into the DB.\n   *\n   * @param props Properties of create function\n   * @returns Newly created article\n   */\n  public create(props: {\n    /**\n     * Information of the article to create\n     */\n    input: IBbsArticle.ICreate;\n  }): IBbsArticle {\n    const article: IBbsArticle = {\n      id: v4(),\n      title: props.input.title,\n      body: props.input.body,\n      thumbnail: props.input.thumbnail,\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n    };\n    this.articles.push(article);\n    return article;\n  }\n\n  /**\n   * Update an article.\n   *\n   * Updates an article with new content.\n   *\n   * @param props Properties of update function\n   * @param input New content to update\n   */\n  public update(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * New content to update.\n     */\n    input: IBbsArticle.IUpdate;\n  }): void {\n    const article: IBbsArticle | undefined = this.articles.find(\n      (a) => a.id === props.id,\n    );\n    if (article === undefined)\n      throw new Error(\"Unable to find the matched article.\");\n    if (props.input.title !== undefined) article.title = props.input.title;\n    if (props.input.body !== undefined) article.body = props.input.body;\n    if (props.input.thumbnail !== undefined)\n      article.thumbnail = props.input.thumbnail;\n    article.updated_at = new Date().toISOString();\n  }\n\n  /**\n   * Erase an article.\n   *\n   * Erases an article from the DB.\n   *\n   * @param props Properties of erase function\n   */\n  public erase(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n  }): void {\n    const index: number = this.articles.findIndex((a) => a.id === props.id);\n    if (index === -1) throw new Error(\"Unable to find the matched article.\");\n    this.articles.splice(index, 1);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Exception Feedback with typia.random<T>() in TypeScript\nDESCRIPTION: Even with successful compilation, runtime exceptions can occur. `@autoview` uses `typia.random<T>()` to generate random values and tests whether the AI-generated TypeScript function throws an error. Exception information is then used to guide the AI agent for correction.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/related/autoview.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n`@autoview`\n```\n\n----------------------------------------\n\nTITLE: Starting a Conversation with Agentica (TypeScript)\nDESCRIPTION: This snippet initiates a conversation with the previously initialized Agentica instance using the 'conversate' method. It sends the input 'I wanna buy MacBook Pro' to the agent for processing.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaExampleVendorLlamaSnippet.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: NodeJS Server Dependencies Installation (pnpm)\nDESCRIPTION: This bash script installs the necessary dependencies for a NodeJS WebSocket server using pnpm. It installs `@agentica/core`, `@samchon/openapi`, `typia`, `@agentica/rpc`, and `tgrid`.  It then runs the `typia setup` command.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/index.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npnpm install @agentica/core @samchon/openapi typia\npnpm install @agentica/rpc tgrid\npnpm typia setup\n```\n\n----------------------------------------\n\nTITLE: Generating SDK with Nestia CLI (Yarn)\nDESCRIPTION: Generates a Software Development Kit (SDK) for frontend applications using the `nestia sdk` command. This SDK allows client applications to interact with the backend server in a type-safe and convenient manner. Requires `@nestia/sdk` to be installed and a `nestia.config.ts` file to be configured. Note: Yarn Berry is not supported.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/nestjs.mdx#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# YARN BERRY IS NOT SUPPORTED\nyarn nestia sdk\n```\n\n----------------------------------------\n\nTITLE: Google Image Agent Initialization (TypeScript)\nDESCRIPTION: This TypeScript code snippet demonstrates how to initialize an Agentica agent with the GoogleImageService connector and OpenAI's GPT model. It utilizes typia for type safety and dotenv for managing environment variables.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-image.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\nimport dotenv from \"dotenv\";\nimport { OpenAI } from \"openai\";\n\nimport { GoogleImageService } from \"@wrtnlabs/connector-google-image\";\n\ndotenv.config();\n\nexport const agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY!,\n    }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"GoogleImage Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<GoogleImageService, \"chatgpt\">(),\n      execute: new GoogleImageService(),\n    },\n  ],\n});\n\nconst main = async () => {\n  console.log(await agent.conversate(\"What can you do?\"));\n};\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: MicroAgentica Class Definition\nDESCRIPTION: Defines the `MicroAgentica` class, which serves as a micro AI chatbot agent capable of performing LLM function calling and managing conversation histories. This class is suitable for scenarios with a limited number of functions. It utilizes a generic type `Model` that extends `ILlmSchema.Model`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/MicroAgenticaSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport class MicroAgentica<Model extends ILlmSchema.Model> {\n  /**\n   * Initializer Constructor.\n   *\n   * @param props Properties to construct the micro agent\n   */\n  public constructor(private readonly props: IMicroAgenticaProps<Model>);\n  /**\n   * @internal\n   */\n  public clone(): MicroAgentica<Model> {\n    return new MicroAgentica<Model>({\n      ...this.props,\n      histories: this.props.histories?.slice(),\n    });\n  }\n\n  /* -----------------------------------------------------------\n    ACCESSORS\n  ----------------------------------------------------------- */\n  /**\n   * Conversate with the micro agent.\n   *\n   * User talks to the AI chatbot with the given content.\n   *\n   * When the user's conversation implies the AI chatbot to execute a\n   * function calling, the returned chat prompts will contain the\n   * function callinng information like {@link AgenticaExecuteHistory}\n   *\n   * @param content The content to talk\n   * @returns List of newly created histories\n   */\n  public async conversate(content: string): Promise<MicroAgenticaHistory<Model>[]>;\n  \n  /**\n   * Add an event listener.\n   *\n   * Add an event listener to be called whenever the event is emitted.\n   *\n   * @param type Type of event\n   * @param listener Callback function to be called whenever the event is emitted\n   */\n  public on<Type extends MicroAgenticaEvent.Type>(\n    type: Type,\n    listener: (\n      event: MicroAgenticaEvent.Mapper<Model>[Type],\n    ) => void | Promise<void>,\n  ): this;\n\n  /**\n   * Erase an event listener.\n   *\n   * Erase an event listener to stop calling the callback function.\n   *\n   * @param type Type of event\n   * @param listener Callback function to erase\n   */\n  public off<Type extends MicroAgenticaEvent.Type>(\n    type: Type,\n    listener: (\n      event: MicroAgenticaEvent.Mapper<Model>[Type],\n    ) => void | Promise<void>,\n  ): this;\n\n  /**\n   * Get the chatbot's histories.\n   *\n   * Get list of chat histories that the chatbot has been conversated.\n   *\n   * @returns List of chat histories\n   */\n  public getHistories(): MicroAgenticaHistory<Model>[];\n\n  /**\n   * Get token usage of the AI chatbot.\n   *\n   * Entire token usage of the AI chatbot during the conversating\n   * with the user by {@link conversate} method callings.\n   *\n   * @returns Cost of the AI chatbot\n   */\n  public getTokenUsage(): AgenticaTokenUsage;\n}\n```\n\n----------------------------------------\n\nTITLE: Agentica Project Setup using CLI\nDESCRIPTION: This code snippet shows how to start an Agentica project using the command-line interface. It guides users through selecting a package manager, project type, and embedded controllers.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/standalone/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ npx agentica start <directory>\n\n----------------------------------------\n Agentica Setup Wizard\n----------------------------------------\n? Package Manager (use arrow keys)\n  > npm\n    pnpm\n    yarn (berry is not supported)\n? Project Type\n    NodeJS Agent Server\n  > NestJS Agent Server\n    React Client Application\n    Standalone Application\n? Embedded Controllers (multi-selectable)\n    (none)\n    Google Calendar\n    Google News\n  > Github\n    Reddit\n    Slack\n    ...\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with Gemini\nDESCRIPTION: This snippet initializes the Agentica agent with the Gemini model. It configures the vendor to use the OpenRouter API, providing the API key and base URL. It also sets up a controller to handle HTTP requests using the BbsArticleService.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaExampleVendorGeminiSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst agent: Agentica<\"gemini\"> = new Agentica({\n  model: \"gemini\",\n  vendor: {\n    model: \"google/gemini-pro-1.5\",\n    api: new OpenAI({\n      apiKey: \"********\",\n      baseURL: \"https://openrouter.ai/api/v1\",\n    }),\n  } satisfies IAgenticaVendor,\n  controllers: [\n    {\n      protocol: \"http\",\n      name: \"class\",\n      application: typia.llm.application<BbsArticleService, \"gemini\">(),\n      execute: new BbsArticleService(),\n    } satisfies IAgenticaController<\"gemini\">,\n  ]\n} satisfies IAgenticaProps<\"gemini\">);\n```\n\n----------------------------------------\n\nTITLE: Order Publish Request Body Example (JSON)\nDESCRIPTION: This JSON snippet represents the structure of the request body used to publish an order. It includes fields for orderId, address (mobile, name, country, province, city, department, possession, zip_code, special_note), and vendor. The example shows the format and expected data types for each field, particularly highlighting the `mobile` field which caused the error.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/4.success.md#_snippet_7\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"orderId\": \"your-order-id\",\n  \"body\": {\n    \"address\": {\n      \"mobile\": \"your-mobile-number\",\n      \"name\": \"Customer\",\n      \"country\": \"South Korea\",\n      \"province\": \"Seoul\",\n      \"city\": \"Seoul\",\n      \"department\": \"Wrtn Apartment\",\n      \"possession\": \"101-1411\",\n      \"zip_code\": \"your-zip-code\",\n      \"special_note\": null\n    },\n    \"vendor\": null\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Summarized Sales with Pagination\nDESCRIPTION: This JSON snippet demonstrates how to list summarized sales with sorting, pagination (page number and limit), using the `shoppings_customers_sales_index` API endpoint. It defines the request body, specifying the sorting criteria (by sale price), page number, and number of items per page.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/4.success.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"sort\": [\n      \"-sale.price_range.highest.real\"\n    ],\n    \"page\": 1,\n    \"limit\": 10\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an API Controller with WebSocket Route\nDESCRIPTION: Defines a NestJS controller method to handle WebSocket connections using `@WebSocketRoute` from `@nestia/core`. It sets up an `AgenticaRpcService` to manage communication with an `Agentica` instance and interact with the client through WebSocket. Requires `@agentica/rpc`, `@nestia/core`, `@nestjs/common`, and `tgrid`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/nestjs.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  AgenticaRpcService,\n  IAgenticaRpcListener,\n  IAgenticaRpcListener\n} from \"@agentica/rpc\";\nimport { WebSocketRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport { Driver, WebSocketAcceptor } from \"tgrid\";\n\n@Controller(\"chat\")\nexport class ChatController {\n  @WebSocketRoute()\n  public async start(\n    // @WebSocketRoute.Param(\"id\") id: string,\n    @WebSocketRoute.Acceptor()\n    acceptor: WebSocketAcceptor<\n      null, // header\n      AgenticaRpcService<\"chatgpt\">,\n      IAgenticaRpcListener\n    >,\n  ): Promise<void> {\n    const agent: Agentica<\"chatgpt\"> = new Agentica({ ... });\n    const listener: Driver<IAgenticaRpcListener> = acceptor.getDriver();\n    const service: AgenticaRpcService<\"chatgpt\"> = \n      new AgenticaRpcService({\n        agent,\n        listener,\n      });\n    await acceptor.accept(service);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Create Shopping Order Request Body (JSON)\nDESCRIPTION: This JSON snippet represents the request body for creating a new shopping order. It includes an empty `goods` array, indicating that no specific goods are selected, and a `name` field set to `null`, suggesting that the order name may be generated automatically. The `goods` field should be populated with the list of commodities from the shopping cart to be included in the order.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/3.failure.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"goods\": [],\n    \"name\": null\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Agentica History Type Definitions in Typescript\nDESCRIPTION: This code defines a discriminated union type `AgenticaHistory` that represents different types of history entries in the Agentica system: Text, Select, Cancel, Execute, and Describe.  Each type is further defined using interfaces within a namespace `AgenticaHistory`.  The interfaces extend a common `Base` interface and define specific properties for each history type, including the `toJSON` method to serialize the history entry to a JSON format.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaHistorySnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport type AgenticaHistory =\n  | AgenticaHistory.Text\n  | AgenticaHistory.Select\n  | AgenticaHistory.Cancel\n  | AgenticaHistory.Execute\n  | AgenticaHistory.Describe;\nexport namespace AgenticaHistory {\n  export interface Select extends Base<\"select\"> {\n    id: string;\n    selections: AgenticaOperationSelection[];\n    toJSON(): IAgenticaHistoryJson.ISelect;\n  }\n  export interface Cancel extends Base<\"cancel\"> {\n    id: string;\n    selections: IAgenticaOperationSelection[];\n    toJSON(): IAgenticaHistoryJson.ICancel;\n  }\n  export interface Execute extends Base<\"execute\"> {\n    id: string;\n    operation: AgenticaOperation;\n    arguments: Record<string, any>;\n    value: any;\n    toJSON(): IAgenticaHistoryJson.IExecute;\n  }\n  export interface Describe extends Base<\"describe\"> {\n    executes: Execute[];\n    text: string;\n    toJSON(): IAgenticaHistoryJson.IDescribe;\n  }\n  export interface Text extends Base<\"text\"> {\n    role: \"assistant\" | \"user\";\n    text: string;\n    toJSON(): IAgenticaHistoryJson.IText;\n  }\n  interface Base<Type extends string> {\n    type: Type;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Index Method Definition in TypeScript\nDESCRIPTION: The `index` method retrieves a paginated list of summarized shopping sales. It is decorated with `@TypedRoute.Patch()` indicating it handles PATCH requests.  It takes an authenticated actor and a request body (`IShoppingSale.IRequest`) as input and returns a Promise resolving to `IPage<IShoppingSale.ISummary>`, representing the paginated sales data. It depends on `IShoppingSale.IRequest` and `IPage<IShoppingSale.ISummary>` types.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/ShoppingSaleControllerSnippet.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n    @TypedRoute.Patch()\n    public index(\n      @props.AuthGuard() actor: Actor,\n      @TypedBody() input: IShoppingSale.IRequest,\n    ): Promise<IPage<IShoppingSale.ISummary>>;\n```\n\n----------------------------------------\n\nTITLE: Install WebSocket Server (NestJS) with pnpm\nDESCRIPTION: Installs the required packages for setting up a WebSocket server within the NestJS framework using pnpm. Includes @agentica/core, @samchon/openapi, NestJS core packages, @agentica/rpc, tgrid, and nestia. Also involves setting up nestia with `pnpm nestia setup`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/manual.mdx#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npnpm install @agentica/core @samchon/openapi\npnpm install @nestjs/common @nestjs/core @nestjs/platform-express\npnpm install @agentica/rpc tgrid\n\npnpm install -D nestia\npnpm nestia setup\n```\n\n----------------------------------------\n\nTITLE: Installing Agentica dependencies using yarn\nDESCRIPTION: This command installs the necessary dependencies for developing a NodeJS WebSocket server for an AI chatbot using Agentica. It installs @agentica/core, @samchon/openapi, typia, @agentica/rpc, and tgrid using yarn. It also sets up typia. Note that YARN BERRY IS NOT SUPPORTED.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/nodejs.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# YARN BERRY IS NOT SUPPORTED\nyarn add @agentica/core @samchon/openapi typia\nyarn add @agentica/rpc tgrid\nyarn typia setup\n```\n\n----------------------------------------\n\nTITLE: Publish Shopping Order Request (JSON)\nDESCRIPTION: This JSON payload represents a request to publish an existing shopping order. It includes the customer's address details such as mobile number, name, country, province, city, department, possession, and zip code. It also includes a vendor (payment) object, which can be null if no vendor information is required.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/2.success.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"address\": {\n      \"mobile\": \"01012345678\",\n      \"name\": \"Robot\",\n      \"country\": \"South Korea\",\n      \"province\": \"Seoul\",\n      \"city\": \"Seoul\",\n      \"department\": \"Wrtn Apartment\",\n      \"possession\": \"101-1411\",\n      \"zip_code\": \"\",\n      \"special_note\": null\n    },\n    \"vendor\": null\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for Slack Agent (Env)\nDESCRIPTION: This configuration sets up the environment variables required for the Slack agent, including the OpenAI API key and the Slack secret key. These variables are loaded using the `dotenv` library to securely manage credentials.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/slack.mdx#_snippet_2\n\nLANGUAGE: env\nCODE:\n```\nOPENAI_API_KEY=your-openai-api-key\nSLACK_SECRET_KEY=your-slack-secret-key\n```\n\n----------------------------------------\n\nTITLE: Creating an item in FastAPI with automatic Swagger documentation\nDESCRIPTION: This code snippet demonstrates how to create an item in FastAPI. It uses type hints and descriptions to automatically generate Swagger documentation.  The BaseModel from pydantic is used to define the data structure of the Item. The `@app.post` decorator defines an endpoint that takes an `Item` as input and returns the same `Item`. No extra documentation is required, as FastAPI infers everything from the type hints. It requires the `fastapi` and `pydantic` packages.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/articles/new-backend-development-paradigm-in-the-new-ai-era.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass Item(BaseModel):\n  id: int\n  name: str\n  description: str = Field(None, description=\"The description of the item\")\n  price: float = Field(..., description=\"The price of the item\")\n  tags: List[str] = Field(default_factory=list, description=\"A list of tags associated with the item\")\n\n@app.post(\"/items/\")\nasync def create_item(item: Item):\n  return item\n\n```\n\n----------------------------------------\n\nTITLE: Launching Agentica Setup Wizard for Slack Agent (Bash)\nDESCRIPTION: This command launches the Agentica Setup Wizard and configures the project for a Slack agent. It guides the user through installing required packages, choosing the package manager, selecting the Slack controller, and entering the OpenAI API key.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/slack.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica start slack-agent\n```\n\n----------------------------------------\n\nTITLE: Agentica Setup Wizard using Command Line\nDESCRIPTION: This bash command initiates the Agentica setup wizard, allowing users to create new projects with tailored configurations. The wizard prompts the user to select a package manager, project type, and embedded controllers.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/benchmark/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ npx agentica start <directory>\n```\n\n----------------------------------------\n\nTITLE: Install WebSocket Server (NestJS) with Yarn\nDESCRIPTION: Installs the required packages for setting up a WebSocket server within the NestJS framework using Yarn. Includes @agentica/core, @samchon/openapi, NestJS core packages, @agentica/rpc, tgrid, and nestia. Also involves setting up nestia with `yarn nestia setup`. Note: Yarn Berry is not supported.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/manual.mdx#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# YARN BERRY IS NOT SUPPORTED\nyarn add @agentica/core @samchon/openapi\nyarn add @nestjs/common @nestjs/core @nestjs/platform-express\nyarn add @agentica/rpc tgrid\n\nyarn add -D nestia\nyarn nestia setup\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with HTTP LLM Applications (TypeScript)\nDESCRIPTION: This snippet initializes an Agentica instance with multiple LLM applications. It fetches a Swagger definition from a remote URL, converts it into an HTTP LLM application using `assertHttpLlmApplication`, and adds it to the Agentica instance's controllers array. It also adds other LLM applications created via `typia.llm.application` for ShoppingCounselor, ShoppingPolicy, and ShoppingSearchRag. Finally, it starts a conversation with the agent by calling `agent.conversate`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaExamplePseudoSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport typia from \"typia\";\n\nconst agent = new Agentica({\n  controllers: [\n    assertHttpLlmApplication(\n      await fetch(\n        \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n      ).then(r => r.json())\n    ),\n    typia.llm.application<ShoppingCounselor>(),\n    typia.llm.application<ShoppingPolicy>(),\n    typia.llm.application<ShoppingSearchRag>(),\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Connector-Hive Environment Variables\nDESCRIPTION: These environment variables configure the connector-hive server. They specify the port, database URL, Cohere API key, and an optional API key for request authentication.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/vector-selector.mdx#_snippet_5\n\nLANGUAGE: env\nCODE:\n```\nPROJECT_API_PORT=37001\nDATABASE_URL=postgresql://your_user:your_password@host.docker.internal:5432/your_database\nCOHERE_API_KEY=your_cohere_api_key\nAPI_KEY=your_optional_api_key  # Optional: If set, all requests except GET /health must include this key\n```\n\n----------------------------------------\n\nTITLE: Starting a Conversation with Agentica\nDESCRIPTION: This snippet initiates a conversation with the initialized Agentica agent using the `conversate` method. The message passed is \"I wanna buy MacBook Pro\", which serves as the initial prompt for the agent.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaExampleVendorChatGptSnippet.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Expected API Call Sequence JSON\nDESCRIPTION: This JSON object represents the expected sequence of API calls that would be made in response to the user's prompt. It outlines the different operations involved, such as listing sales, retrieving detailed product information, creating an order, and publishing the order. The JSON includes descriptions of each API operation, including important notes for AI chatbots.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/select/order/README.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_create\",\n            \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n          }\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Article Creation Input\nDESCRIPTION: This snippet validates the input for creating a new Bbs article. It checks the types and formats (UUID, URI) of the input properties using typia's validation functions. It returns a success boolean and the validated data or a list of errors if validation fails.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/LlmApplicationJavaScriptSnippet.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst _io0 = (input) =>\n          \"string\" === typeof input.title &&\n          \"string\" === typeof input.body &&\n          (null === input.thumbnail ||\n            (\"string\" === typeof input.thumbnail &&\n              __typia_transform__isFormatUri._isFormatUri(input.thumbnail)));\n        const _vo0 = (input, _path, _exceptionable = true) =>\n          [\n            \"string\" === typeof input.title ||\n              _report(_exceptionable, {\n                path: _path + \".title\",\n                expected: \"string\",\n                value: input.title,\n              }),\n            \"string\" === typeof input.body ||\n              _report(_exceptionable, {\n                path: _path + \".body\",\n                expected: \"string\",\n                value: input.body,\n              }),\n            null === input.thumbnail ||\n              (\"string\" === typeof input.thumbnail &&\n                (__typia_transform__isFormatUri._isFormatUri(input.thumbnail) ||\n                  _report(_exceptionable, {\n                    path: _path + \".thumbnail\",\n                    expected: 'string & Format<\"uri\">',\n                    value: input.thumbnail,\n                  }))) ||\n              _report(_exceptionable, {\n                path: _path + \".thumbnail\",\n                expected:\n                  '(string & Format<\"uri\"> & ContentMediaType<\"image/*\">) | null',\n                value: input.thumbnail,\n              }),\n          ].every((flag) => flag);\n        const __is = (input) =>\n          \"object\" === typeof input && null !== input && _io0(input);\n        let errors;\n        let _report;\n        return (input) => {\n          if (false === __is(input)) {\n            errors = [];\n            _report = __typia_transform__validateReport._validateReport(errors);\n            ((input, _path, _exceptionable = true) =>\n              (((\"object\" === typeof input && null !== input) ||\n                _report(true, {\n                  path: _path + \"\",\n                  expected: \"__type\",\n                  value: input,\n                })) &&\n                _vo0(input, _path + \"\", true)) ||\n              _report(true, {\n                path: _path + \"\",\n                expected: \"__type\",\n                value: input,\n              }))(input, \"$input\", true);\n            const success = 0 === errors.length;\n            return success\n              ? {\n                  success,\n                  data: input,\n                }\n              : {\n                  success,\n                  errors,\n                  data: input,\n                };\n          }\n          return {\n            success: true,\n            data: input,\n          };\n        };\n```\n\n----------------------------------------\n\nTITLE: Connecting with SSE Transport (TypeScript)\nDESCRIPTION: This snippet shows how to connect an MCP client using Server-Sent Events (SSE) transport. It uses the `SseClientTransport` and requires a valid SSE endpoint URL. This is useful for web-based applications where Stdio transport is not suitable.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/controller/mcp.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SseClientTransport } from \"@modelcontextprotocol/sdk/client/sse.js\";\n\nawait client.connect(new SseClientTransport({\n  url: \"your-sse-endpoint\"\n}));\n```\n\n----------------------------------------\n\nTITLE: ShoppingCustomerSaleController Definition\nDESCRIPTION: Defines a TypeScript controller for handling shopping customer sales.  It includes a `at` method that retrieves detailed sale information based on a provided ID. The method uses decorators from `@nestjs/common` and `@nestia/core` for routing and parameter validation.  It returns a Promise resolving to an `IShoppingSale` object.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/articles/i-made-mcp-alternative-solution-for-openai-and-all-other-llms.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n@Controller(\"shoppings/customers/sales\")\nexport class ShoppingCustomerSaleController {\n  /**\n   * Get a sale with detailed information.\n   *\n   * Get a {@link IShoppingSale sale} with detailed information including\n   * the SKU (Stock Keeping Unit) information represented by the\n   * {@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock}\n   * types.\n   *\n   * > If you're an A.I. chatbot, and the user wants to buy or compose a\n   * > {@link IShoppingCartCommodity shopping cart} from a sale, please\n   * > call this operation at least once to the target sale to get\n   * > detailed SKU information about the sale.\n   * >\n   * > It needs to be run at least once for the next steps. In other\n   * > words, if you A.I. agent has called this operation to a specific\n   * > sale, you don't need to call this operation again for the same\n   * > sale.\n   * >\n   * > Additionally, please do not summarize the SKU information.\n   * > Just show the every options and stocks in the sale with detailed\n   * > information.\n   *\n   * @param id Target sale's {@link IShoppingSale.id}\n   * @returns Detailed sale information\n   * @tag Sale\n   */\n  @TypedRoute.Get(\":id\")\n  public async at(\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSale>;\n}\n```\n\n----------------------------------------\n\nTITLE: NestJS Server Dependencies Installation (yarn)\nDESCRIPTION: This bash script installs the necessary dependencies for a NestJS WebSocket server using yarn. It installs `@nestjs/common`, `@nestjs/core`, `@nestjs/platform-express`, `@agentica/core`, `@samchon/openapi`, `@agentica/rpc`, and `tgrid`. It also installs `nestia` as a dev dependency and runs `nestia setup`. Notes that YARN BERRY IS NOT SUPPORTED.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/index.mdx#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# YARN BERRY IS NOT SUPPORTED\nyarn add @nestjs/common @nestjs/core @nestjs/platform-express\nyarn add @agentica/core @samchon/openapi\nyarn add @agentica/rpc tgrid\n\nyarn add -D nestia\nyarn nestia setup\n```\n\n----------------------------------------\n\nTITLE: Expected API Call Sequence\nDESCRIPTION: This JSON object outlines the expected sequence of API calls to fulfill the user's shopping scenario. It details the operations, types (standalone, anyOf), and descriptions for each call.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/select/order/2.success.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_create\",\n            \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n          }\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Agentica CLI Setup\nDESCRIPTION: This command initializes the Agentica setup wizard for a Google Calendar agent. It installs necessary packages, selects the Google Calendar controller, and configures the OpenAI API key.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-calendar.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica start google-calendar-agent\n```\n\n----------------------------------------\n\nTITLE: Starting a Conversation with Agentica\nDESCRIPTION: This snippet starts a conversation with the initialized Agentica agent.  It passes the input string \"I wanna buy MacBook Pro\" to the `conversate` method, triggering a response from the agent based on its configured model and controllers.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaExampleVendorGeminiSnippet.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: NestJS Server Dependencies Installation (pnpm)\nDESCRIPTION: This bash script installs the necessary dependencies for a NestJS WebSocket server using pnpm. It installs `@nestjs/common`, `@nestjs/core`, `@nestjs/platform-express`, `@agentica/core`, `@samchon/openapi`, `@agentica/rpc`, and `tgrid`. It also installs `nestia` as a dev dependency and runs `nestia setup`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/index.mdx#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npnpm install @nestjs/common @nestjs/core @nestjs/platform-express\npnpm install @agentica/core @samchon/openapi\npnpm install @agentica/rpc tgrid\n\npnpm install -D nestia\npnpm nestia setup\n```\n\n----------------------------------------\n\nTITLE: Shopping Scenario: Order Process API Calls (JSON)\nDESCRIPTION: This JSON payload represents the expected sequence of API calls for a shopping scenario. It includes listing sales, retrieving detailed product information, creating an order, and publishing the order. The \"operation\" fields describe the functionality of each API endpoint.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/select/order/3.success.md#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_create\",\n            \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n          }\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Create New Order Application\nDESCRIPTION: This snippet shows the JSON structure for creating a new order application. It includes a body object containing a goods array, which represents the commodities included in the order. The goods array appears to be an empty array in this example, but would contain commodity details in a real request. Creates a new IShoppingOrder order application from a IShoppingCartCommodity shopping cart.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/2.success.md#_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"body\": {\n    \"goods\": []\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: ShoppingSaleController Definition in TypeScript\nDESCRIPTION: This code defines a generic `ShoppingSaleController` function that accepts `IShoppingControllerProps` and returns a NestJS controller class. The controller is decorated with `@Controller` and configured to handle routes under `shoppings/${props.path}/sales`. It uses `TypedRoute` decorators from `@nestia/core` to define the HTTP methods and routes for each handler.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/ShoppingSaleControllerSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TypedBody, TypedRoute, TypedParam } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport { tags } from \"typia\";\n \nimport { IPage } from \"@samchon/shopping-api/lib/structures/common/IPage\";\nimport { IShoppingActorEntity } from \"@samchon/shopping-api/lib/structures/shoppings/actors/IShoppingActorEntity\";\nimport { IShoppingSale } from \"@samchon/shopping-api/lib/structures/shoppings/sales/IShoppingSale\";\n \nimport { IShoppingControllerProps } from \"../IShoppingControllerProps\";\n\nexport function ShoppingSaleController<Actor extends IShoppingActorEntity>(\n  props: IShoppingControllerProps,\n) {\n  @Controller(`shoppings/${props.path}/sales`)\n  abstract class ShoppingSaleController {\n```\n\n----------------------------------------\n\nTITLE: Initializing MicroAgentica with ChatGPT\nDESCRIPTION: This snippet demonstrates how to initialize a MicroAgentica instance with a ChatGPT model. It sets up the model, vendor (using OpenAI API), controllers, and conversation histories. The code also includes event handlers for 'text' and 'describe' events, and a conversation example with archiving.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/micro.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MicroAgentica, MicroAgenticaHistory } from \"@agentica/core\";\nimport OpenAI from \"@agentica/openai\";\nimport { v4 } from \"uuid\";\n\nexport const main = async (id: string): Promise<void> => {\n  // CONSTRUCTION\n  const agent: MicroAgentica<\"chatgpt\"> = new MicroAgentica({\n    model: \"chatgpt\",\n    vendor: {\n      api: new OpenAI({ apiKey: \"********\" }),\n      model: \"gpt-4o-mini\",\n    },\n    controllers: [\n      {\n        protocol: \"class\",\n        name: \"bbs\",\n        application: typia.llm.application<BbsArticleService, \"chatgpt\">(),\n        execute: new MicroAgenticaHistory(),\n      }\n    ],\n    histories: await getPrompts(id),\n  });\n\n  // EVENT HANDLING\n  agent.on(\"text\", async (event) => {\n    for await (const piece of event.stream)\n      console.log(piece);\n  });\n  agent.on(\"describe\", async (event) => {\n    console.log(\n      \"describe\", \n      event.executes.map((x) => x.operation.function.name),\n      await event.join(), // full text joining instead of streaming\n    );\n  });\n\n  // CONVERSATION & ARCHIVING\n  const prompts: MicroAgenticaHistory[] = await agent.conversate(\n    \"I wanna buy Mackbook Pro.\"\n  );\n  await archiveHistories(id, prompts);\n};\n```\n\n----------------------------------------\n\nTITLE: JSON Schema with Format in Description\nDESCRIPTION: This JSON snippet demonstrates how the `format` constraint is included within the `description` property of a schema when using Gemini, since Gemini does not directly support the `format` constraint.  This allows LLMs to utilize this information, even though it's not part of the standard schema.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/vendor.mdx#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"string\",\n  \"description\": \"Primary Key.\\n\\n@format uuid\"\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with Claude Model\nDESCRIPTION: This snippet initializes the Agentica instance with the Claude model. It configures the model vendor, including API keys and the base URL, and defines a controller using the BbsArticleService for handling specific application logic. It also sets the protocol to 'http'.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaExampleVendorClaudeSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst agent: Agentica<\"claude\"> = new Agentica({\n  model: \"claude\",\n  vendor: {\n    model: \"anthropic/claude-3.5-sonnet\",\n    api: new OpenAI({\n      apiKey: \"********\",\n      baseURL: \"https://openrouter.ai/api/v1\",\n    }),\n  } satisfies IAgenticaVendor,\n  controllers: [\n    {\n      protocol: \"http\",\n      name: \"class\",\n      application: typia.llm.application<BbsArticleService, \"claude\">(),\n      execute: new BbsArticleService(),\n    } satisfies IAgenticaController<\"claude\">,\n  ]\n} satisfies IAgenticaProps<\"claude\">);\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Configuring nestia.config.ts for SDK Generation\nDESCRIPTION: Configures the `nestia.config.ts` file for generating an SDK using `@nestia/sdk`. This file specifies the input NestJS application instance and the output directory for the generated SDK.  Requires `@nestia/sdk`, `@nestjs/core` and a defined NestJS Module (e.g., `YourModule`).\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/nestjs.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\n\nimport { YourModule } from \"./src/YourModule\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: async () => {\n    const app = await NestFactory.create(YourModule);\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\n    // app.setGlobalPrefix(\"api\");\n    // app.enableVersioning({\n    //     type: VersioningType.URI,\n    //     prefix: \"v\",\n    // })\n    return app;\n  },\n  output: \"src/api\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: Configure Locale and Timezone in Agentica\nDESCRIPTION: This code snippet demonstrates how to configure the `locale` and `timezone` properties within the Agentica configuration. The `locale` property is set to \"ko-KR\", indicating the Korean language and South Korea region. The `timezone` property is set to \"Asia/Seoul\", specifying the timezone of Seoul, South Korea. This configuration allows the AI agent to consider the user's language and location when generating responses and calling functions.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/config.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o\",\n  },\n  controllers: [...],\n  config: {\n    locale: \"ko-KR\",\n    timezone: \"Asia/Seoul\",\n  },\n});\nawait agent.conversate(\"Hello, I want to refund my shoes.\");\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Yarn\nDESCRIPTION: Installs the necessary yarn packages for setting up a NestJS WebSocket server with Agentica. It includes dependencies for NestJS core functionality, Agentica's core library and OpenAPI support, WebSocket RPC, and development tools like nestia. Note: Yarn Berry is not supported.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/nestjs.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# YARN BERRY IS NOT SUPPORTED\nyarn add @nestjs/common @nestjs/core @nestjs/platform-express\nyarn add @agentica/core @samchon/openapi\nyarn add @agentica/rpc tgrid\n\nyarn add -D nestia\nyarn nestia setup\n```\n\n----------------------------------------\n\nTITLE: At Method Definition in TypeScript\nDESCRIPTION: The `at` method retrieves a detailed shopping sale by its ID. It is decorated with `@TypedRoute.Get(\":id\")` indicating it handles GET requests to the `/sales/:id` endpoint.  It takes an authenticated actor and a sale ID (string in UUID format) as input, and returns a Promise resolving to `IShoppingSale`, representing the detailed sale information. It uses `@TypedParam` to bind the `id` path parameter.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/ShoppingSaleControllerSnippet.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n    @TypedRoute.Get(\":id\")\n    public at(\n      @props.AuthGuard() actor: Actor,\n      @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\n    ): Promise<IShoppingSale>;\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with OpenAI and TypeScript Class\nDESCRIPTION: This TypeScript snippet demonstrates how to initialize an Agentica instance with an OpenAI model and a TypeScript class defining functions. It imports necessary modules from `@agentica/core`, `openai`, and `typia`. The `Agentica` constructor takes configuration options including the AI vendor (OpenAI) and a list of controllers, where one controller is defined as a TypeScript class.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\nimport { MobileFileSystem } from \"./services/MobileFileSystem\";\n\nconst agent = new Agentica({\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    // functions from TypeScript class\n    {\n      protocol: \"http\",\n      application: typia.llm.application<MobileFileSystem, \"chatgpt\">(),\n      execute: new MobileFileSystem(),\n    },\n    // functions from Swagger/OpenAPI\n    {\n      protocol: \"http\",\n      application: assertHttpLlmApplication({\n        model: \"chatgpt\",\n        document: await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n        ).then(r => r.json()),\n      }),\n      connection: {\n        host: \"https://shopping-be.wrtn.ai\",\n        headers: { Authorization: \"Bearer ********\" },\n      },\n    },\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Handling Events in MicroAgentica\nDESCRIPTION: This snippet demonstrates how to handle events emitted by a MicroAgentica instance. It sets up event listeners for 'text', 'execute', and 'describe' events. The 'text' event prints the received text, the 'execute' event logs information about function execution, and the 'describe' event prints the described functions.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/micro.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MicroAgentica } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new MicroAgentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [...],\n});\n\nagent.on(\"text\", async (event) => {\n  console.log(\"Text from\", event.role);\n  for await (const text of event.stream)\n    process.stdout.write(text);\n  process.stdout.write(\"\\n\");\n});\nagent.on(\"execute\", async (event) => {\n  console.log(\n    \"Function executed\", \n    event.operation.name, \n    event.arguments, \n    event.value,\n  );\n});\nagent.on(\"describe\", async (event) => {\n  console.log(\"Describe Function Calling\");\n  for (const execute of event.executes)\n    console.log(`  - ${execute.operation.name}`);\n  for await (const text of event.stream)\n    process.stdout.write(text);\n  process.stdout.write(\"\\n\");\n}); \n\nawait agent.conversate(\"I wanna buy Surface Pro\");\n```\n\n----------------------------------------\n\nTITLE: Agentica Example Snippet\nDESCRIPTION: Agentica offers a powerful agentic AI library, specializing in LLM Function Calling. The snippet example includes core functionality for listing Swagger/OpenAPI/MCP documents or TypeScript class types to the @agentica.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/index.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Tabs } from \"nextra/components\";\n\nimport RemoteSource from \"../../components/RemoteSource\";\nimport AgenticaExamplePseudoSnippet from \"../snippets/AgenticaExamplePseudoSnippet.mdx\";\nimport AgenticaExampleActualSnippet from \"../snippets/AgenticaExampleActualSnippet.mdx\";\nimport { YoutubeRenderer } from \"../../components/YoutubeRenderer\";\n```\n\n----------------------------------------\n\nTITLE: Agentica with Meta Llama Vendor\nDESCRIPTION: This snippet shows how to configure Agentica to use Meta's Llama models. It requires setting the baseURL for the OpenAI API to the Llama API endpoint and specifying the Llama model.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/index.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { \n  Agentica,\n  IAgenticaController,\n  IAgenticaProps,\n  IAgenticaVendor\n} from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nimport { BbsArticleService } from \"./services/BbsArticleService\";\n\nconst agent: Agentica<\"llama\"> = new Agentica({\n  model: \"llama\",\n  vendor: {\n    model: \"llama3.3-70b\",\n    api: new OpenAI({\n      apiKey: \"********\",\n      baseURL: \"https://api.llama-api.com\",\n    }),\n  } satisfies IAgenticaVendor,\n  controllers: [\n    {\n      protocol: \"http\",\n      name: \"class\",\n      application: typia.llm.application<BbsArticleService, \"llama\">(),\n      execute: new BbsArticleService(),\n    } satisfies IAgenticaController<\"llama\">,\n  ]\n} satisfies IAgenticaProps<\"llama\">);\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Setting Retry Count for Validation Feedback (TypeScript)\nDESCRIPTION: This snippet illustrates how to configure the retry count for validation feedback during function calling in Agentica. It demonstrates setting the `retry` property within the Agentica configuration to control how many times the agent retries function calling when it encounters invalid typed arguments. The snippet highlights the importance of setting a reasonable retry count for improved success rates.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/config.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o\",\n  },\n  controllers: [...],\n  config: {\n    retry: 3,\n  },\n});\nawait agent.conversate(\"Hello, I want to refund my shoes.\");\n```\n\n----------------------------------------\n\nTITLE: TypeScript Compilation Error Output\nDESCRIPTION: Shows the error message generated when the `BbsArticleController` violates the constraints of `typia.llm.application`. The error highlights the issues with the return type of `create` and the parameter type of `erase`. It specifies that the function's return type must not be a union type with undefined, and the function's parameter must be an object type.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/concepts/compiler-driven-development.mdx#_snippet_5\n\nLANGUAGE: Bash\nCODE:\n```\nsrc/examples/llm.application.violation.ts:4:41 - error TS(typia.llm.application): unsupported type detected    \n\n- BbsArticleController.create: unknown\n  - LLM application's function (\"create\")'s return type must not be union type with undefined.    \n\n- BbsArticleController.erase: unknown\n  - LLM application's function (\"erase\")'s parameter must be an object type.\n\n4 const app: ILlmApplication<\"chatgpt\"> = typia.llm.application<\n                                          ~~~~~~~~~~~~~~~~~~~~~~\n5   BbsArticleController,\n  ~~~~~~~~~~~~~~~~~~~~~~~\n6   \"chatgpt\"\n  ~~~~~~~~~~~\n7 >();\n  ~~~\n\n\nFound 1 error in src/examples/llm.application.violation.ts:4\n```\n\n----------------------------------------\n\nTITLE: Initializing and Conversing with MicroAgentica in TypeScript (Typia Import)\nDESCRIPTION: This snippet demonstrates how to initialize a MicroAgentica instance, define controllers, provide history, engage in a conversation, and then archive the resulting prompts. It includes an import of typia, although it isn't directly used in the showcased functionality.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/micro.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  IMicroAgenticaHistoryJson,\n  MicroAgentica,\n  MicroAgenticaHistory,\n} from \"@agentica/core\";\nimport typia from \"typia\";\n\nexport const main = async (id: string): Promise<void> => {\n  const agent = new MicroAgentica({\n    model: \"chatgpt\",\n    vendor: {\n      api: new OpenAI({ apiKey: \"*****\" }),\n      model: \"gpt-4o-mini\",\n    },\n    controllers: [...],\n    histories: (await getHistories(id)) satisfies IMicroAgenticaHistoryJson[],\n  });\n  const prompts: MicroAgenticaHistory[] = await agent.conversate(\n    \"I wanna buy MacBook Pro\",\n  );\n  await archiveHistories(id, prompts.map((p) => p.toJSON()));\n}\n```\n\n----------------------------------------\n\nTITLE: Install WebSocket Server (NestJS) with npm\nDESCRIPTION: Installs the required packages for setting up a WebSocket server within the NestJS framework using npm. Includes @agentica/core, @samchon/openapi, NestJS core packages, @agentica/rpc, tgrid, and nestia.  Also involves setting up nestia with `npx nestia setup`\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/manual.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @agentica/core @samchon/openapi\nnpm install @nestjs/common @nestjs/core @nestjs/platform-express\nnpm install @agentica/rpc tgrid\n\nnpm install -D nestia\nnpx nestia setup\n```\n\n----------------------------------------\n\nTITLE: Install Core Library with npm\nDESCRIPTION: Installs the core Agentica library along with its dependencies, @samchon/openapi and typia, using npm. Includes a typia setup command. This setup is necessary for converting Swagger/OpenAPI documents and composing LLM function calling schemas.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/manual.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @agentica/core @samchon/openapi typia\nnpx typia setup\n```\n\n----------------------------------------\n\nTITLE: Create Shopping Order Request (JSON)\nDESCRIPTION: This JSON payload represents a request to create a new shopping order. It includes an array of goods, each with a commodity ID and volume, and a name for the order. An example of how the commodity_id maps to an item in the shopping cart.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/2.success.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"goods\": [\n      {\n        \"commodity_id\": \"2e217919-45f4-45f3-9712-d535b7efa7b3\",\n        \"volume\": 1\n      }\n    ],\n    \"name\": \"Macbook Order\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Publish Shopping Order Request Body\nDESCRIPTION: This JSON snippet represents the request body for publishing a shopping order. It includes customer address information such as mobile number, name, country, province, city, department, possession, zip code and a special note. The vendor information is set to null, indicating it might not be required in all cases.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/4.success.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"address\": {\n      \"mobile\": \"01012345678\",\n      \"name\": \"Robot\",\n      \"country\": \"South Korea\",\n      \"province\": \"Seoul\",\n      \"city\": \"Seoul\",\n      \"department\": \"Wrtn Apartment\",\n      \"possession\": \"101-1411\",\n      \"zip_code\": \"zip_code\",\n      \"special_note\": null\n    },\n    \"vendor\": null\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Define Text Event Interface\nDESCRIPTION: Defines the `Text` interface within the `AgenticaEvent` namespace, representing a text event. It includes properties for the role (user or assistant), a readable stream of strings, and a method to join the stream into a complete string.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaEventSnippet.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace AgenticaEvent {\n  export interface Text extends Base<\"text\"> {\n    role: \"user\" | \"assistant\"\n    stream: ReadableStream<string>;\n    join(): Promise<string>;\n  }\n\n```\n\n----------------------------------------\n\nTITLE: PNPM Installation of Agentica Core\nDESCRIPTION: This command installs the @agentica/core library along with its dependencies, @samchon/openapi and typia, using pnpm. The subsequent command, pnpm typia setup, configures typia for TypeScript transformation.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/index.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm install @agentica/core @samchon/openapi typia\npnpm typia setup\n```\n\n----------------------------------------\n\nTITLE: Create Shopping Cart Commodity Request Body (JSON)\nDESCRIPTION: This JSON snippet represents the expected request body for creating a new commodity in a shopping cart. The `sale_id`, `unit_id`, and `stock_id` must be valid UUIDs. The quantity and volume parameters specify the amount of the commodity to be added to the cart. The 'choices' field is provided as an empty array.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/3.failure.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"sale_id\": \"uuid_of_macbook_sale\",\n    \"stocks\": [\n      {\n        \"unit_id\": \"uuid_of_most_expensive_macbook_unit\",\n        \"stock_id\": \"uuid_of_most_expensive_macbook_stock\",\n        \"choices\": [],\n        \"quantity\": 1\n      }\n    ],\n    \"volume\": 1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Agentica Dependencies (npm)\nDESCRIPTION: Installs necessary packages including @agentica/rpc, tgrid, @agentica/core, and @samchon/openapi using npm. These packages are required for building WebSocket client applications with Agentica.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/client.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @agentica/rpc tgrid\nnpm install @agentica/core @samchon/openapi\n```\n\n----------------------------------------\n\nTITLE: Install WebSocket Server (NodeJS) with pnpm\nDESCRIPTION: Installs the necessary packages for setting up a WebSocket server in a NodeJS environment using pnpm. This includes @agentica/core, @samchon/openapi, typia, @agentica/rpc, and tgrid. A typia setup command is also included.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/manual.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npnpm install @agentica/core @samchon/openapi typia\npnpm install @agentica/rpc tgrid\npnpm typia setup\n```\n\n----------------------------------------\n\nTITLE: Execute Discountable Info\nDESCRIPTION: This JSON payload is used to execute the 'shoppings_customers_orders_discountable' function. It requires a valid order ID to compute discountable features for the order.  A 'good_ids' field is included in the body, but is set to null in this example.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/4.success.md#_snippet_5\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"id\": \"some-valid-order-id\",\n  \"body\": {\n    \"good_ids\": null\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MicroAgentica with ChatGPT Vendor\nDESCRIPTION: This snippet shows how to create a MicroAgentica instance specifically configured to use the ChatGPT vendor, including setting the model, API key, and controllers for handling different protocols (in this case, HTTP). The code also demonstrates starting a conversation.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/micro.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { \n  IAgenticaController,\n  IAgenticaVendor,\n  IMicroAgenticaProps,\n  MicroAgentica\n} from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nimport { BbsArticleService } from \"./services/BbsArticleService\";\n\nconst agent: MicroAgentica<\"chatgpt\"> = new MicroAgentica({\n  model: \"chatgpt\",\n  vendor: {\n    model: \"gpt-4o-mini\",\n    api: new OpenAI({\n      apiKey: \"********\",\n    }),\n  } satisfies IAgenticaVendor,\n  controllers: [\n    {\n      protocol: \"http\",\n      name: \"class\",\n      application: typia.llm.application<BbsArticleService, \"chatgpt\">(),\n      execute: new BbsArticleService(),\n    } satisfies IAgenticaController<\"chatgpt\">,\n  ]\n} satisfies IMicroAgenticaProps<\"chatgpt\">);\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Valid Shopping Cart Commodity Request Body (JSON)\nDESCRIPTION: This JSON snippet provides an example of a valid request body for creating a commodity. All ID fields (`sale_id`, `unit_id`, `stock_id`) are replaced with placeholder UUIDs to indicate the expected data format. This example shows the correct structure to resolve the 400 Bad Request errors.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/3.failure.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"sale_id\": \"valid-uuid-here\",\n  \"stocks\": [\n    {\n      \"unit_id\": \"valid-uuid-here\",\n      \"stock_id\": \"valid-uuid-here\",\n      \"choices\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"volume\": 1\n}\n```\n\n----------------------------------------\n\nTITLE: Backend API Example (Python Django)\nDESCRIPTION: Illustrates a backend API endpoint implementation using Python and the Django framework. This showcases a traditional backend setup where the Swagger/OpenAPI document generation is not emphasized.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/concepts/compiler-driven-development.mdx#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport PythonDjangoSnippet from \"../../snippets/PythonDjangoSnippet.mdx\";\n```\n\n----------------------------------------\n\nTITLE: SampleControllerTest with Spring Extension\nDESCRIPTION: This Kotlin code demonstrates a test class `SampleControllerTest` using Spring Boot and REST Docs for API documentation. It sets up a MockMvc instance to perform HTTP requests and verify responses, generating documentation snippets based on the test results. It uses annotations from Spring and REST Docs to configure the test and generate documentation.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/articles/i-made-mcp-alternative-solution-for-openai-and-all-other-llms.md#_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\n@ExtendWith(RestDocumentationExtension::class, SpringExtension::class)\n@SpringBootTest\nclass SampleControllerTest {\n  private lateinit var mockMvc: MockMvc\n\n  @BeforeEach\n  internal fun setUp(context: WebApplicationContext, restDocumentation: RestDocumentationContextProvider) {\n    mockMvc = MockMvcBuilders.webAppContextSetup(context)\n      .apply<DefaultMockMvcBuilder>(MockMvcRestDocumentation.documentationConfiguration(restDocumentation))\n      .build()\n  }\n\n  @Test\n  fun getSampleByIdTest() {\n    val sampleId = \"aaa\"\n    mockMvc.perform(\n      get(\"/api/v1/samples/{sampleId}\", sampleId)\n    )\n      .andExpect(status().isOk)\n      .andExpect(jsonPath(\"sampleId\", `is`(sampleId)))\n      .andExpect(jsonPath(\"name\", `is`(\"sample-$sampleId\")))\n      .andDo(\n        MockMvcRestDocumentationWrapper.document(\n          identifier = \"sample\",\n          resourceDetails = ResourceSnippetParametersBuilder()\n            .tag(\"Sample\")\n            .description(\"Get a sample by id\")\n            .pathParameters(\n              parameterWithName(\"sampleId\")\n                .description(\"the sample id\"),\n            )\n            .responseFields(\n              fieldWithPath(\"sampleId\")\n                .type(JsonFieldType.STRING)\n                .description(\"The sample identifier.\"),\n              fieldWithPath(\"name\")\n                .type(JsonFieldType.STRING)\n                .description(\"The name of sample.\"),\n            ),\n        ),\n      )\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Agentica Setup Wizard\nDESCRIPTION: This command executes the Agentica setup wizard using npx. The wizard guides users through creating a new project by prompting them to select a package manager, project type, and embedded controllers.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/rpc/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ npx agentica start <directory>\n```\n\n----------------------------------------\n\nTITLE: Creating a Shopping Order Request Body JSON\nDESCRIPTION: This JSON snippet shows the structure of a request body to create a shopping order.  It specifies the 'commodity_id' and 'volume' for goods to be included in the order, along with a 'name' for the order. The 'commodity_id' should be a valid UUID.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/4.success.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"goods\": [\n      {\n        \"commodity_id\": \"uuid-of-the-most-expensive-macbook-stock\",\n        \"volume\": 1\n      }\n    ],\n    \"name\": \"Macbook Order\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Define Execute Event Interface\nDESCRIPTION: Defines the `Execute` interface within the `AgenticaEvent` namespace, representing an execution event. It includes properties for the id, operation, arguments, and the resulting value.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaEventSnippet.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n  export interface Execute<Model extends ILlmSchema.Model> \n    extends Base<\"execute\"> {\n    id: string;\n    operation: AgenticaOperation<Model>;\n    arguments: Record<string, any>;\n    value: any;\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Running Tests with pnpm\nDESCRIPTION: This snippet describes how to execute tests for each package using the pnpm package manager. The `pnpm test` command is used to verify the functionality of individual packages within the project. It may require the `CHATGPT_API_KEY` environment variable for certain tests.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm test\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with npm\nDESCRIPTION: Installs the necessary npm packages for setting up a NestJS WebSocket server with Agentica. It includes dependencies for NestJS core functionality, Agentica's core library and OpenAPI support, WebSocket RPC, and development tools like nestia.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/nestjs.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @nestjs/common @nestjs/core @nestjs/platform-express\nnpm install @agentica/core @samchon/openapi\nnpm install @agentica/rpc tgrid\n\nnpm install -D nestia\nnpx nestia setup\n```\n\n----------------------------------------\n\nTITLE: Expected JSON structure for the described scenario\nDESCRIPTION: This JSON outlines the expected operations for fulfilling a user's shopping request. It involves fetching sales summaries, retrieving detailed product information (Macbook), creating an order from the selected cart items, and publishing the order.  It uses a type array to specify a sequence of operations.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/select/order/4.success.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_create\",\n            \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n          }\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Install WebSocket Client Application with npm\nDESCRIPTION: Installs the necessary packages for a client application using npm, specifically @agentica/rpc and tgrid.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/manual.mdx#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @agentica/rpc tgrid\n```\n\n----------------------------------------\n\nTITLE: Validating LLM Function Call with Typia in TypeScript\nDESCRIPTION: This TypeScript function `correctFunctionCall` validates an LLM function call using `typia`. It takes a `FunctionCall`, a list of `ILlmFunction` objects, and a `retry` function as parameters. If validation fails, it calls the `retry` function with detailed error information to prompt the LLM to correct the arguments.  The function returns a Promise resolving to the validated data or the result of the retry call.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/articles/i-made-mcp-alternative-solution-for-openai-and-all-other-llms.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { FunctionCall } from \"pseudo\";\nimport { ILlmFunction, IValidation } from \"typia\";\n\nexport const correctFunctionCall = (p: {\n  call: FunctionCall;\n  functions: Array<ILlmFunction<\"chatgpt\">>;\n  retry: (reason: string, errors?: IValidation.IError[]) => Promise<unknown>;\n}): Promise<unknown> => {\n  // FIND FUNCTION\n  const func: ILlmFunction<\"chatgpt\"> | undefined =\n    p.functions.find((f) => f.name === p.call.name);\n  if (func === undefined) {\n    // never happened in my experience\n    return p.retry(\n      \"Unable to find the matched function name. Try it again.\",\n    );\n  }\n\n  // VALIDATE\n  const result: IValidation<unknown> = func.validate(p.call.arguments);\n  if (result.success === false) {\n    // 1st trial: 30% (gpt-4o-mini in shopping mall chatbot)\n    // 2nd trial with validation feedback: 99%\n    // 3nd trial with validation feedback again: never have failed\n    return p.retry(\n      \"Type errors are detected. Correct it through validation errors\",\n      {\n        errors: result.errors,\n      },\n    );\n  }\n  return result.data;\n}\n```\n\n----------------------------------------\n\nTITLE: shim.ts Content (TypeScript)\nDESCRIPTION: This TypeScript file, `shim.ts`, provides essential polyfills to ensure compatibility and proper functionality of Agentica in the React Native environment. It addresses issues with global objects and asynchronous iterators, and it leverages `expo/fetch` to provide the `fetch` API.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/react-native.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// shim.ts\nimport 'react-native-polyfill-globals/auto';\nimport '@azure/core-asynciterator-polyfill';\nimport { fetch } from 'expo/fetch';\n\n(() => {\n  globalThis.fetch = fetch as any;\n})();\n```\n\n----------------------------------------\n\nTITLE: Agentica CLI Wizard Example\nDESCRIPTION: This is an example of the interactive CLI wizard that appears when running `npx agentica start my-project-directory`.  It shows how to select the package manager, project type, and embedded controllers.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/cli.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ npx agentica start my-project-directory\n\n----------------------------------------\n Agentica Setup Wizard\n----------------------------------------\n? Package Manager (use arrow keys)\n  > npm\n    pnpm\n    yarn (berry is not supported)\n? Project Type\n    NodeJS Agent Server\n  > NestJS Agent Server\n    React Client Application\n    Standalone Application\n    React-Native Application\n? Embedded Controllers (multi-selectable)\n    (none)\n    Google Calendar\n    Google News\n  > Github\n    Reddit\n    Slack\n    ...\n```\n\n----------------------------------------\n\nTITLE: Expected API Call Sequence (Hypothetical)\nDESCRIPTION: This JSON describes the expected sequence of API calls to fulfill the user's request to view sales, get Macbook details, select the most expensive stock, add it to the cart, create an order, and publish it. It lists the `type` (standalone or anyOf) and the `operation` name and description for each API call. This is the ideal flow the system was supposed to follow.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/3.failure.md#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_create\",\n            \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n          }\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Linting Code with pnpm\nDESCRIPTION: This snippet shows how to check code quality using the pnpm package manager. The `pnpm lint` command likely runs linters and code formatters to ensure that the codebase adheres to predefined style guidelines.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npnpm lint\n```\n\n----------------------------------------\n\nTITLE: Expected API Interaction - JSON\nDESCRIPTION: This JSON defines the expected API calls and their arguments based on the user's prompt.  It specifies the sequence of operations the AI agent should perform, including listing sales, retrieving details of a specific product, creating a shopping cart commodity, and publishing an order. The structure outlines the expected data flow and dependencies between operations.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/select/order/1.success.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_create\",\n            \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n          }\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Agentica Crawler Agent Setup\nDESCRIPTION: This command launches the Agentica Setup Wizard, which guides the user through setting up a crawler agent. It handles package installation, project configuration, and selection of the WEB_CRAWLER controller.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/crawler.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica start crawler-agent\n```\n\n----------------------------------------\n\nTITLE: Agentica Project Setup using CLI\nDESCRIPTION: This code snippet shows how to initialize an Agentica project using the command-line interface. It demonstrates the command to start the setup wizard and the interactive options available for selecting the package manager, project type, and embedded controllers.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/cli/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ npx agentica start <directory>\n\n----------------------------------------\n Agentica Setup Wizard\n----------------------------------------\n? Package Manager (use arrow keys)\n  > npm\n    pnpm\n    yarn (berry is not supported)\n? Project Type\n    NodeJS Agent Server\n  > NestJS Agent Server\n    React Client Application\n    Standalone Application\n? Embedded Controllers (multi-selectable)\n    (none)\n    Google Calendar\n    Google News\n  > Github\n    Reddit\n    Slack\n    ...\n```\n\n----------------------------------------\n\nTITLE: Installing Typia Libraries (NPM)\nDESCRIPTION: This command installs the required libraries for Typia, including `typia` and `@ryoppippi/unplugin-typia`. Typia enables compile-time type checking in React Native applications.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/react-native.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnpm install typia @ryoppippi/unplugin-typia\n```\n\n----------------------------------------\n\nTITLE: Expected Order Operations JSON\nDESCRIPTION: This JSON defines the expected sequence of API operations for fulfilling the user's request. It includes fetching summarized sales, retrieving detailed sale information for a Macbook, creating an order application (either with or without a shopping cart), and publishing the order with payment and delivery details.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/1.failure.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_create\",\n            \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n          }\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Agentica Project Setup using CLI\nDESCRIPTION: This code snippet shows how to initiate an Agentica project using the command-line interface. It executes the 'npx agentica start <directory>' command to launch the setup wizard. The wizard prompts the user to select a package manager, project type, and embedded controllers.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/create-agentica/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ npx agentica start <directory>\n```\n\n----------------------------------------\n\nTITLE: Agentica Setup Wizard Command\nDESCRIPTION: This bash command initiates the Agentica setup wizard, allowing users to create new projects based on their specific requirements, such as project type (NodeJS Agent Server, NestJS Agent Server, React Client Application, or Standalone Application) and embedded controllers (e.g., Github, Reddit, Slack).\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ npx agentica start <directory>\n```\n\n----------------------------------------\n\nTITLE: Declaring the Calculator Controller in TypeScript\nDESCRIPTION: This code declares the `CalculatorController` that connects the `Calculator` functions to Agentica. It defines the protocol, name, and execution logic using `IAgenticaController`. The `execute` function dynamically calls the appropriate calculator function based on the `props.function.name` and passes the arguments.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/react-native/calendar.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport const CalculatorController: IAgenticaController<'chatgpt'> = {\n  protocol: 'class',\n  name: 'calculator',\n  execute: async props =>\n    (Calculator as any)[props.function.name](props.arguments),\n  application: typia.llm.application<typeof Calculator, 'chatgpt'>(),\n};\n```\n\n----------------------------------------\n\nTITLE: Execute shoppings_customers_sales_index request\nDESCRIPTION: Defines the request body for the 'shoppings_customers_sales_index' API endpoint. It includes parameters for sorting the results by sale price, specifying the page number, and limiting the number of results per page.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/4.success.md#_snippet_5\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"body\": {\n    \"sort\": [\n      \"-sale.price_range.highest.real\"\n    ],\n    \"page\": 1,\n    \"limit\": 10\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Agentica Select Benchmark Scenario Interface Definition\nDESCRIPTION: Defines the `IAgenticaSelectBenchmarkScenario` interface, representing a function selection benchmark scenario. It includes properties for the scenario name, user prompt text, and expected operations.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/benchmark.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Scenario of function selection.\n *\n * `IAgenticaSelectBenchmarkScenario` is a data structure which\n * represents a function selection benchmark scenario. It contains two\n * properties; {@linkk text} and {@link operations}.\n *\n * The {@link text} means the conversation text from the user, and\n * the other {@link operations} are the expected operations that\n * should be selected by the `selector` agent through the {@link text}\n * conversation.\n *\n * @author Samchon\n */\nexport interface IAgenticaSelectBenchmarkScenario<\n  Model extends ILlmSchema.Model,\n> {\n  /**\n   * Name of the scenario.\n   *\n   * It must be unique within the benchmark scenarios.\n   */\n  name: string;\n\n  /**\n   * The prompt text from user.\n   */\n  text: string;\n\n  /**\n   * Expected function selection sequence.\n   *\n   * Sequence of operations (API operation or class function) that\n   * should be selected by the `selector` agent from the user's\n   * {@link text} conversation for the LLM (Large Language Model)\n   * function selection.\n   */\n  expected: IAgenticaBenchmarkExpected<Model>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IShoppingSaleUnit Interface (TypeScript)\nDESCRIPTION: This code defines the `IShoppingSaleUnit` interface, representing product composition information handled in the sale. It's an entity embodying the \"individual product\" information in the `IShoppingSale`. It can represent bundled products and doesn't refer to the final stock until options are selected.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/DocumentationStrategyDtoDescriptionSnippet.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Product composition information handled in the sale.\n *\n * `IShoppingSaleUnit` is an entity that embodies the \"individual product\"\n * information handled in the {@link IShoppingSale sale}.\n *\n * For reference, the reason why `IShoppingSaleUnit` is separated from\n * {@link IShoppingSaleSnapshot} by an algebraic relationship of 1: N is because\n * there are some cases where multiple products are sold in one listing. This is\n * the case with so-called \"bundled products\".\n *\n * - Bundle from regular product (Mackbook Set)\n *   - Main Body\n *   - Keyboard\n *   - Mouse\n *   - Apple Care (Free A/S Voucher)\n *\n * And again, `IShoppingSaleUnit` does not in itself refer to the\n * {@link IShoppingSaleUnitStock final stock} that the\n * {@link IShoppingCustomer customer} will {@link IShoppingOrder purchase}.\n * The final stock can be found only after selecting all given\n * {@link IShoppingSaleUnitOption options} and their\n * {@link IShoppingSaleUnitOptionCandidate candidate values}.\n *\n * For example, even if you buy a Macbook, the final stocks are determined only\n * after selecting all the options (CPU / RAM / SSD), etc.\n *\n * @author Samchon\n */\nexport interface IShoppingSaleUnit { ... }\n```\n\n----------------------------------------\n\nTITLE: Introduce `typia`, superfast runtime validator\nDESCRIPTION: Article content describing `typia` as a transformer library with features like super-fast runtime validators, JSON schema, LLM function calling, Protocol Buffer encoding/decoding, and random data generation. It emphasizes its superior speed compared to `class-validator` and encourages users to visit the `typia` website.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/chat/src/examples/bbs/script.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n`typia` is a transformer library supporting below features:\n\n- Super-fast runtime validators\n- Enhanced JSON schema and serde functions\n- LLM function calling schema and structured output\n- Protocol Buffer encoder and decoder\n- Random data generator\n\nFor reference, `typia`'s runtime validator 20,000x faster than `class-validator` by utilizing the AoT (Ahead of Time) compilation strategy. Let's visit typia website https://typia.io, and enjoy its super-fast performance.\n```\n\n----------------------------------------\n\nTITLE: Install Standalone Application with npm\nDESCRIPTION: Installs packages required for a standalone frontend application using npm. Includes @agentica/core, @samchon/openapi, typia, and @ryoppippi/unplugin-typia. Also involves setting up typia with `npx typia setup`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/manual.mdx#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @agentica/core @samchon/openapi typia\nnpx typia setup\n\nnpm install -D @ryoppippi/unplugin-typia\n```\n\n----------------------------------------\n\nTITLE: Retrieve Sale by ID in JSON\nDESCRIPTION: This JSON snippet represents the input for retrieving a specific sale by its ID. The `id` field contains the unique identifier of the sale to be fetched. Used in the `shoppings_customers_sales_at` operation.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/2.success.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"c5e3679b-d71e-42a2-b051-a42b235e4a0d\"\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Bare React Native Project (CLI)\nDESCRIPTION: This command initializes a new bare React Native project using the React Native CLI. It requires Node.js and a working React Native development environment.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/react-native.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx @react-native-community/cli@15.0.0 init\n```\n\n----------------------------------------\n\nTITLE: Get Detailed Sale Information - JSON Request Body\nDESCRIPTION: This snippet shows the JSON request body for getting detailed sale information for a specific sale ID. The 'id' parameter is the unique identifier of the sale, expected to be in UUID format. Providing an invalid UUID will result in an error.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/4.success.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"some-sale-id\"\n}\n```\n\n----------------------------------------\n\nTITLE: NodeJS Server Dependencies Installation (yarn)\nDESCRIPTION: This bash script installs the necessary dependencies for a NodeJS WebSocket server using yarn. It installs `@agentica/core`, `@samchon/openapi`, `typia`, `@agentica/rpc`, and `tgrid`.  It then runs the `typia setup` command.  Notes that YARN BERRY IS NOT SUPPORTED.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/index.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# YARN BERRY IS NOT SUPPORTED\nyarn add @agentica/core @samchon/openapi typia\nyarn add @agentica/rpc tgrid\nyarn typia setup\n```\n\n----------------------------------------\n\nTITLE: NodeJS Server Dependencies Installation (npm)\nDESCRIPTION: This bash script installs the necessary dependencies for a NodeJS WebSocket server using npm. It installs `@agentica/core`, `@samchon/openapi`, `typia`, `@agentica/rpc`, and `tgrid`.  It then runs the `typia setup` command.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/index.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @agentica/core @samchon/openapi typia\nnpm install @agentica/rpc tgrid\nnpx typia setup\n```\n\n----------------------------------------\n\nTITLE: Arguments Hooking (Client - TypeScript)\nDESCRIPTION: Demonstrates arguments hooking in the client application using @samchon/openapi and @agentica/rpc. It shows how to modify function arguments before they are sent to the server using the 'call' function in IAgenticaRpcListener.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/client.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IAgenticaRpcListener, IAgenticaRpcService } from \"@agentica/rpc\";\nimport { ILlamaSchema, ILlmFunction } from \"@samchon/openapi\";\nimport { Driver, WebSocketConnector } from \"tgrid\";\n\nconst fillArguments = async (\n  param: ILlamaSchema.IParameters\n): Promise<Record<string, any>> => {\n  ...\n};\n\nconst connector: WebSocketConnector<\n  null,\n  IAgenticaRpcListener,\n  IAgenticaRpcService<\"llama\">\n> = new WebSocketConnector(null, {\n  text: async (evt) => {\n    console.log(evt.role, evt.text);\n  },\n  describe: async (evt) => {\n    console.log(\"describer\", evt.text);\n  },\n  call: async (event) => {\n    const func: ILlmFunction<\"llama\"> | undefined = controllers\n      .find((c) => c.name === event.operation.controller)\n      ?.application.functions.find(\n        (f) => f.name === event.operation.function,\n      );\n    if (!func?.separated?.human) return null;\n    return fillArguments(func.separated.human);\n  },\n});\nawait connector.connect(\"ws://localhost:3001\");\n\nconst driver: Driver<IAgenticaRpcService<\"llama\">> = connector.getDriver();\nconst controllers = await driver.getControllers();\nawait driver.conversate(\"I wanna create an article with file uploading.\");\n\nawait connector.close();\n```\n\n----------------------------------------\n\nTITLE: Expected API Calls for Shopping Scenario\nDESCRIPTION: This JSON outlines the sequence of API calls expected to fulfill the user's shopping request. It includes calls to list sales, retrieve detailed sale information, create a cart commodity, create an order, and publish the order. The structure defines the type of API call (standalone or anyOf) and provides descriptions for each operation.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/3.failure.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": [\n            {\n              \"type\": \"standalone\",\n              \"operation\": {\n                \"name\": \"shoppings_customers_carts_commodities_create\",\n                \"description\": \"Create a new commodity.\\n\\nCreate a new {@link IShoppingCartCommodity commodity} into a specific\\nshopping cart.\\n\\nIf {@link IShoppingCartCommodity.ICreate.accumulate} has `true` value\\nand there's some same commodity that composed with same\\n{@link IShoppingSaleUnitStock.IInvert stocks and quantities},\\nthen new commodity would not be created but the volume would be accumulated.\\n\\nBy the way, if the target {@link IShoppingSale sale} has been suspended or\\n{@link IShoppingSaleUnitStockInventory out of stock}, then 410 gone error\\nwould be thrown. Therefore, it would better to check the target sale and\\n{@link IShoppingSaleUnitStock stock}'s status before.\"\n              }\n            },\n            {\n              \"type\": \"standalone\",\n              \"operation\": {\n                \"name\": \"shoppings_customers_orders_create\",\n                \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n              }\n            }\n          ]\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Expo Modules Plugin (NPM)\nDESCRIPTION: This command installs the `@callstack/repack-plugin-expo-modules` plugin, enabling the use of Expo modules within a Repack environment.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/react-native.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @callstack/repack-plugin-expo-modules\n```\n\n----------------------------------------\n\nTITLE: Validating Article Update Input\nDESCRIPTION: This snippet validates the input for updating an existing Bbs article. It includes checks for the article's ID (UUID format) and the optional input properties (title, body, thumbnail - URI format). The function utilizes typia's validation capabilities, reporting errors if the input data doesn't conform to the expected structure.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/LlmApplicationJavaScriptSnippet.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst _io0 = (input) =>\n          \"string\" === typeof input.id &&\n          __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n          \"object\" === typeof input.input &&\n          null !== input.input &&\n          false === Array.isArray(input.input) &&\n          _io1(input.input);\n        const _io1 = (input) =>\n          (undefined === input.title || \"string\" === typeof input.title) &&\n          (undefined === input.body || \"string\" === typeof input.body) &&\n          (null === input.thumbnail ||\n            undefined === input.thumbnail ||\n            (\"string\" === typeof input.thumbnail &&\n              __typia_transform__isFormatUri._isFormatUri(input.thumbnail)));\n        const _vo0 = (input, _path, _exceptionable = true) =>\n          [\n            (\"string\" === typeof input.id &&\n              (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n                _report(_exceptionable, {\n                  path: _path + \".id\",\n                  expected: 'string & Format<\"uuid\">',\n                  value: input.id,\n                }))) ||\n              _report(_exceptionable, {\n                path: _path + \".id\",\n                expected: '(string & Format<\"uuid\">)',\n                value: input.id,\n              }),\n            (((\"object\" === typeof input.input &&\n              null !== input.input &&\n              false === Array.isArray(input.input)) ||\n              _report(_exceptionable, {\n                path: _path + \".input\",\n                expected: \"Partial<IBbsArticle.ICreate>\",\n                value: input.input,\n              })) &&\n              _vo1(input.input, _path + \".input\", true && _exceptionable)) ||\n              _report(_exceptionable, {\n                path: _path + \".input\",\n                expected: \"Partial<IBbsArticle.ICreate>\",\n                value: input.input,\n              }),\n          ].every((flag) => flag);\n        const _vo1 = (input, _path, _exceptionable = true) =>\n          [\n            undefined === input.title ||\n              \"string\" === typeof input.title ||\n              _report(_exceptionable, {\n                path: _path + \".title\",\n                expected: \"(string | undefined)\",\n                value: input.title,\n              }),\n            undefined === input.body ||\n              \"string\" === typeof input.body ||\n              _report(_exceptionable, {\n                path: _path + \".body\",\n                expected: \"(string | undefined)\",\n                value: input.body,\n              }),\n            null === input.thumbnail ||\n              undefined === input.thumbnail ||\n              (\"string\" === typeof input.thumbnail &&\n                (__typia_transform__isFormatUri._isFormatUri(input.thumbnail) ||\n                  _report(_exceptionable, {\n                    path: _path + \".thumbnail\",\n                    expected: 'string & Format<\"uri\">',\n                    value: input.thumbnail,\n                  }))) ||\n              _report(_exceptionable, {\n                path: _path + \".thumbnail\",\n                expected:\n                  '((string & Format<\"uri\"> & ContentMediaType<\"image/*\">) | null | undefined)',\n                value: input.thumbnail,\n              }),\n          ].every((flag) => flag);\n        const __is = (input) =>\n          \"object\" === typeof input && null !== input && _io0(input);\n        let errors;\n        let _report;\n        return (input) => {\n          if (false === __is(input)) {\n            errors = [];\n            _report = __typia_transform__validateReport._validateReport(errors);\n            ((input, _path, _exceptionable = true) =>\n              (((\"object\" === typeof input && null !== input) ||\n                _report(true, {\n                  path: _path + \"\",\n                  expected: \"__type\",\n                  value: input,\n                })) &&\n                _vo0(input, _path + \"\", true)) ||\n              _report(true, {\n                path: _path + \"\",\n                expected: \"__type\",\n                value: input,\n              }))(input, \"$input\", true);\n            const success = 0 === errors.length;\n            return success\n              ? {\n                  success,\n                  data: input,\n                }\n              : {\n                  success,\n                  errors,\n                  data: input,\n                };\n          }\n          return {\n            success: true,\n            data: input,\n          };\n        };\n```\n\n----------------------------------------\n\nTITLE: Fetching Sale by ID with JSON\nDESCRIPTION: This JSON payload specifies the ID of the sale to be retrieved. The `id` field corresponds to the sale identifier. This API call retrieves detailed information about a specific sale, including SKU details.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/3.failure.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"macbook_sale_id\"\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MicroAgentica with Llama Vendor\nDESCRIPTION: This snippet shows how to configure a MicroAgentica instance to use the Llama model as its vendor. It includes setting the model name, base URL for the Llama API, and defining controllers for HTTP protocol.  It also includes a conversation example.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/micro.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { \n  IAgenticaController,\n  IAgenticaVendor,\n  IMicroAgenticaProps,\n  MicroAgentica\n} from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nimport { BbsArticleService } from \"./services/BbsArticleService\";\n\nconst agent: MicroAgentica<\"llama\"> = new MicroAgentica({\n  model: \"llama\",\n  vendor: {\n    model: \"llama3.3-70b\",\n    api: new OpenAI({\n      apiKey: \"********\",\n      baseURL: \"https://api.llama-api.com\",\n    }),\n  } satisfies IAgenticaVendor,\n  controllers: [\n    {\n      protocol: \"http\",\n      name: \"class\",\n      application: typia.llm.application<BbsArticleService, \"llama\">(),\n      execute: new BbsArticleService(),\n    } satisfies IAgenticaController<\"llama\">,\n  ]\n} satisfies IMicroAgenticaProps<\"llama\">);\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Client Application Dependencies Installation (npm)\nDESCRIPTION: This bash script installs the necessary dependencies for a client application using npm. It installs `@agentica/rpc`, `tgrid`, `@agentica/core`, and `@samchon/openapi`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/index.mdx#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @agentica/rpc tgrid\nnpm install @agentica/core @samchon/openapi\n```\n\n----------------------------------------\n\nTITLE: Validation Feedback using typia.random<T>() in TypeScript\nDESCRIPTION: `@autoview` employs `typia.random<T>()` to generate random values based on a given schema and tests the AI-generated TypeScript rendering function against these values.  If the output is invalid, the AI agent receives detailed tracking information to correct the function, ensuring data validation.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/related/autoview.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n`@autoview`\n```\n\n----------------------------------------\n\nTITLE: Expected JSON Response for Order Scenario\nDESCRIPTION: This JSON object defines the expected sequence of API calls for processing a user's order. It includes listing sales, retrieving detailed product information, creating an order (with or without a shopping cart), and publishing the order with payment and address details.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/README.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_create\",\n            \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n          }\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Repack (CLI)\nDESCRIPTION: This command initializes Repack in the React Native project. Repack is a bundler based on Webpack/Rspack and is used because the default Metro bundler is incompatible with Typia.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/react-native.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx @callstack/repack-init\n```\n\n----------------------------------------\n\nTITLE: Starting Agentica Project via CLI\nDESCRIPTION: This bash command demonstrates how to start an Agentica project using the command-line interface. It initializes the project setup wizard which allows the user to select the package manager, project type, and embedded controllers.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\n$ npx agentica start <directory>\n```\n\n----------------------------------------\n\nTITLE: Console Output Example\nDESCRIPTION: This bash snippet demonstrates the console output generated by the documentation. It shows the description of the IBbsArticle.ICreate type and its parent type, IBbsArticle. This output illustrates how the documentation tool copies the parent's namespace documentation to its children to provide comprehensive information.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/DocumentationStrategyNamespaceSnippet.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nInformation of the article to create.\n \n------------------------------\n \nDescription of the current {@link IBbsArticle.ICreate} type:\n \nInformation of the article to create.\n \n> Description of the parent {@link IBbsArticle} type: Article entity.\n>\n> `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\n```\n\n----------------------------------------\n\nTITLE: Compiler Feedback with tsc in TypeScript\nDESCRIPTION: `@autoview` utilizes the `tsc` command to compile AI-generated TypeScript code. If compilation fails, detailed error messages are provided to the AI agent, enabling it to correct the code. This process helps ensure syntactically correct code generation.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/related/autoview.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n`@autoview`\n```\n\n----------------------------------------\n\nTITLE: Install Agentica Vector Selector\nDESCRIPTION: This command installs the @agentica/vector-selector package using npm. This package provides the vector selector functionality for Agentica.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/vector-selector.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @agentica/vector-selector\n```\n\n----------------------------------------\n\nTITLE: Expected API Call Sequence for Ordering Macbook\nDESCRIPTION: This JSON outlines the expected sequence of API calls that should be triggered by the user's prompt. It covers listing sales, retrieving details about the Macbook, adding the most expensive stock to the shopping cart, creating an order, and publishing the order with a cash payment.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/4.success.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": [\n            {\n              \"type\": \"standalone\",\n              \"operation\": {\n                \"name\": \"shoppings_customers_carts_commodities_create\",\n                \"description\": \"Create a new commodity.\\n\\nCreate a new {@link IShoppingCartCommodity commodity} into a specific\\nshopping cart.\\n\\nIf {@link IShoppingCartCommodity.ICreate.accumulate} has `true` value\\nand there's some same commodity that composed with same\\n{@link IShoppingSaleUnitStock.IInvert stocks and quantities},\\nthen new commodity would not be created but the volume would be accumulated.\\n\\nBy the way, if the target {@link IShoppingSale sale} has been suspended or\\n{@link IShoppingSaleUnitStockInventory out of stock}, then 410 gone error\\nwould be thrown. Therefore, it would better to check the target sale and\\n{@link IShoppingSaleUnitStock stock}'s status before.\"\n              }\n            },\n            {\n              \"type\": \"standalone\",\n              \"operation\": {\n                \"name\": \"shoppings_customers_orders_create\",\n                \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n              }\n            }\n          ]\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Agentica Vector Selector Basic Setup\nDESCRIPTION: This code snippet illustrates the minimal configuration required to initialize the AgenticaVectorSelector.  It uses the `boot` method to create an instance with default settings for the \"chatgpt\" model. This setup is suitable for basic use cases where no customization is needed.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/vector-selector.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst selectorExecute = AgenticaVectorSelector.boot<\"chatgpt\">({\n  // Basic configuration options\n});\n```\n\n----------------------------------------\n\nTITLE: Adding UnpluginTypia Plugin (JavaScript)\nDESCRIPTION: This code snippet adds the `UnpluginTypia` plugin to the `rspack.config.mjs` file. This plugin integrates Typia into the Rspack build process.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/react-native.mdx#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n// rspack.config.mjs\nimport ...\nimport UnpluginTypia from '@ryoppippi/unplugin-typia/webpack';\n\nexport default {\n  ...\n  plugins: [..., UnpluginTypia()], // Add UnpluginTypia Plugin\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica Project (CLI)\nDESCRIPTION: This command initializes a new Agentica project using the Agentica CLI. It creates a project folder named \"agentica-test\" and prompts the user to answer a series of questions for project configuration.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/index.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica start agentica-test\n```\n\n----------------------------------------\n\nTITLE: Displaying Remote TypeScript Structures in Tabs\nDESCRIPTION: This snippet uses Nextra's Tabs component to display three TypeScript interface definitions fetched from a remote GitHub repository. Each tab contains a RemoteSource component that fetches and renders the content of a specific TypeScript file, showcasing the structure definitions for shopping coupons, cart commodities, and sale units.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/DocumentationStrategyPropertyDescriptionSnippet.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n<Tabs items={[\n  <code>IShoppingCouponRestriction</code>,\n  <code>IShoppingCartCommodityStock</code>,\n  <code>IShoppingSaleUnitStock</code>,\n]}>\n  <Tabs.Tab>\n    <RemoteSource \n      url=\"https://raw.githubusercontent.com/samchon/shopping-backend/refs/heads/master/src/api/structures/shoppings/coupons/IShoppingCouponRestriction.ts\"\n      filename=\"@samchon/shopping-backend/IShoppingCouponRestriction\"\n      showLineNumbers />\n  </Tabs.Tab>\n  <Tabs.Tab>\n    <RemoteSource \n      url=\"https://raw.githubusercontent.com/samchon/shopping-backend/refs/heads/master/src/api/structures/shoppings/orders/IShoppingCartCommodityStock.ts\"\n      filename=\"@samchon/shopping-backend/IShoppingCartCommodityStock\"\n      showLineNumbers />\n  </Tabs.Tab>\n  <Tabs.Tab>\n    <RemoteSource \n      url=\"https://raw.githubusercontent.com/samchon/shopping-backend/refs/heads/master/src/api/structures/shoppings/sales/IShoppingSaleUnitStock.ts\"\n      filename=\"@samchon/shopping-backend/IShoppingSaleUnitStock\"\n      showLineNumbers />\n  </Tabs.Tab>\n</Tabs>\n```\n\n----------------------------------------\n\nTITLE: Handling Execute Prompts with Agentica\nDESCRIPTION: This snippet shows how to initialize Agentica and iterate through prompts to identify and log execution-based conversation entries. It accesses and logs operation names, arguments, and return values.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/history.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, AgenticaHistory } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"*****\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [...],\n});\nconst prompts: AgenticaHistory[] = await agent.conversate(\n  \"I wanna buy MacBook Pro\",\n);\nfor (const p of prompts)\n  if (p.type === \"execute\")\n    console.log(\n      \"execute\",\n      p.operation.name,\n      p.arguments,\n      p.value,\n    );\n```\n\n----------------------------------------\n\nTITLE: Import AgenticaPage Component (TypeScript/JSX)\nDESCRIPTION: This code snippet imports the AgenticaPage component from the specified path. This component likely contains the layout and content for the landing page of the Agentica application. The component is used to render the landing page's content.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/index.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport AgenticaPage from \"../app/_pages/Landing.tsx\";\n```\n\n----------------------------------------\n\nTITLE: Create Shopping Cart Commodity - JSON Request Body\nDESCRIPTION: This snippet shows the JSON request body for creating a commodity in the shopping cart. It includes the sale ID, the stocks to be added (with unit ID, stock ID, choices, and quantity), the volume, and a flag indicating whether to accumulate quantities.  The sale_id is a UUID that identifies the sale to which the commodities belong.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/4.success.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"sale_id\": \"abcde12345-fc65-4b4d-b94e-e1234567890\",\n    \"stocks\": [\n      {\n        \"unit_id\": \"c8a9afcd-5e3d-4816-bb38-7e149cbf7c9c\",\n        \"stock_id\": \"d60dc9d8-f76a-4bc9-bd06-ff5f4bd6de90\",\n        \"choices\": [],\n        \"quantity\": 1\n      }\n    ],\n    \"volume\": 1,\n    \"accumulate\": false\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Typia LLM Application Violation Example\nDESCRIPTION: Illustrates an example of using `typia.llm.application` with a class (`BbsArticleController`) that violates the required constraints, resulting in a compilation error. The example defines an interface `BbsArticleController` with `create` and `erase` methods. The attempt to create an `ILlmApplication` using `typia.llm.application` triggers TypeScript errors due to the return type of `create` being a union with undefined, and the parameter type of `erase` not being a single object.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/concepts/compiler-driven-development.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ILlmApplication } from \"@samchon/openapi\";\nimport typia, { tags } from \"typia\";\n\nconst app: ILlmApplication<\"chatgpt\"> = typia.llm.application<\n  BbsArticleController,\n  \"chatgpt\"\n>();\n\nconsole.log(app);\n\ninterface BbsArticleController {\n  /**\n   * Create a new article.\n   *\n   * Writes a new article and archives it into the DB.\n   *\n   * @param props Properties of create function\n   * @returns Newly created article\n   */\n  create(props: {\n    /**\n     * Information of the article to create\n     */\n    input: IBbsArticle.ICreate;\n  }): Promise<IBbsArticle | undefined>;\n\n  erase(id: string & tags.Format<\"uuid\">): Promise<void>;\n}\n```\n\n----------------------------------------\n\nTITLE: OpenAPI Versions Flowchart\nDESCRIPTION: This Mermaid flowchart illustrates the evolution of OpenAPI specifications and their conversion to LLM function calling schemas for various AI models. It shows how different versions of Swagger/OpenAPI are normalized into a Migration Schema and then transformed into LLM Function Calling schemas.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/articles/new-backend-development-paradigm-in-the-new-ai-era.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart\n  subgraph \"OpenAPI Specification\"\n    v20(\"Swagger v2.0\") --upgrades--> emended[[\"OpenAPI v3.1 (emended)\"]]\n    v30(\"OpenAPI v3.0\") --upgrades--> emended\n    v31(\"OpenAPI v3.1\") --emends--> emended\n  end\n  subgraph \"OpenAPI Generator\"\n    emended --normalizes--> migration[[\"Migration Schema\"]]\n    migration --\"Artificial Intelligence\"--> lfc{{\"LLM Function Calling\"}}\n    lfc --\"OpenAI\"--> chatgpt(\"ChatGPT\")\n    lfc --\"Anthropic\"--> claude(\"Claude\")\n    lfc --\"Google\"--> gemini(\"Gemini\")\n    lfc --\"Meta\"--> llama(\"Llama\")\n  end\n```\n\n----------------------------------------\n\nTITLE: Listing Summarized Sales with Pagination in JSON\nDESCRIPTION: This JSON snippet defines the request body for listing summarized sales. It specifies sorting by creation date in descending order, the page number (1), and the number of items per page (10). This is used in the `shoppings_customers_sales_index` operation.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/2.success.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"sort\": [\n      \"-sale.created_at\"\n    ],\n    \"page\": 1,\n    \"limit\": 10\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Agentica Dependencies (yarn)\nDESCRIPTION: Installs necessary packages including @agentica/rpc, tgrid, @agentica/core, and @samchon/openapi using yarn. These packages are required for building WebSocket client applications with Agentica.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/client.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @agentica/core @agentica/rpc tgrid\nyarn add @agentica/core @samchon/openapi\n```\n\n----------------------------------------\n\nTITLE: List Summarized Sales JSON Request\nDESCRIPTION: This code snippet demonstrates the structure of the JSON request body used to list summarized sales. It includes sorting parameters (by creation date in descending order), the page number, and the number of sales to return per page. This request retrieves a list of sales, excluding detailed SKU information.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/2.success.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"sort\": [\n      \"-sale.created_at\"\n    ],\n    \"page\": 1,\n    \"limit\": 10\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Rspack Configuration (JavaScript)\nDESCRIPTION: This code snippet updates the `rspack.config.mjs` file to include the `ExpoModulesPlugin`. This plugin integrates Expo modules with Repack.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/react-native.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// rspack.config.mjs\nimport ...\nimport { ExpoModulesPlugin } from '@callstack/repack-plugin-expo-modules';\n\nexport default {\n  ...\n  plugins: [\n    ...\n    new ExpoModulesPlugin(),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Execute Order Publishing\nDESCRIPTION: This JSON payload is used to execute the 'shoppings_customers_orders_publish_create' function. It includes the order ID and customer details like mobile number, address, and zip code.  The 'vendor' field is set to null in this example.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/4.success.md#_snippet_6\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"orderId\": \"your-order-id\",\n  \"body\": {\n    \"address\": {\n      \"mobile\": \"your-mobile-number\",\n      \"name\": \"Customer\",\n      \"country\": \"South Korea\",\n      \"province\": \"Seoul\",\n      \"city\": \"Seoul\",\n      \"department\": \"Wrtn Apartment\",\n      \"possession\": \"101-1411\",\n      \"zip_code\": \"your-zip-code\",\n      \"special_note\": null\n    },\n    \"vendor\": null\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Install WebSocket Server (NodeJS) with npm\nDESCRIPTION: Installs the necessary packages for setting up a WebSocket server in a NodeJS environment using npm. This includes @agentica/core, @samchon/openapi, typia, @agentica/rpc, and tgrid. A typia setup command is also included.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/manual.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @agentica/core @samchon/openapi typia\nnpm install @agentica/rpc tgrid\nnpx typia setup\n```\n\n----------------------------------------\n\nTITLE: Extending Schema for Album Listing (DRF Spectacular)\nDESCRIPTION: This code extends the automatically generated schema for the 'list' method of an AlbumViewset using drf-spectacular. It adds parameters for filtering by artist and release date, including examples for the release date parameter. It also overrides the default description and provides authentication information.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/PythonDjangoSnippet.mdx#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@extend_schema(\n    # extra parameters added to the schema\n    parameters=[\n      OpenApiParameter(name='artist', description='Filter by artist', required=False, pe=str),\n      OpenApiParameter(\n        name='release',\n        type=OpenApiTypes.DATE,\n        location=OpenApiParameter.QUERY,\n        description='Filter by release date',\n        examples=[\n          OpenApiExample(\n            'Example 1',\n            summary='short optional summary',\n            description='longer description',\n            value='1993-08-23'\n          ),\n          ...\n        ],\n      ),\n    ],\n    # override default docstring extraction\n    description='More descriptive text',\n    # provide Authentication class that deviates from the views default\n    auth=None,\n    # change the auto-generated operation name\n    operation_id=None,\n    # or even completely override what AutoSchema would generate. Provide raw Open API spec  Dict.\n    operation=None,\n    # attach request/response examples to the operation.\n    examples=[\n      OpenApiExample(\n        'Example 1',\n        description='longer description',\n        value=...\n      ),\n      ...\n    ],\n  )\n  def list(self, request):\n    # your non-standard behavior\n    return super().list(request)\n```\n\n----------------------------------------\n\nTITLE: Backend API Example (PHP Laravel)\nDESCRIPTION: Illustrates a backend API endpoint implementation using PHP and the Laravel framework.  This showcases a traditional backend setup where the Swagger/OpenAPI document generation is not emphasized.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/concepts/compiler-driven-development.mdx#_snippet_2\n\nLANGUAGE: php\nCODE:\n```\nimport PhpLaravelSnippet from \"../../snippets/PhpLaravelSnippet.mdx\";\n```\n\n----------------------------------------\n\nTITLE: List Summarized Sales Parameters JSON\nDESCRIPTION: This JSON snippet defines the request body for listing summarized sales. It includes parameters for sorting the results, pagination, and limiting the number of items per page.  Sorting is applied to the 'sale.created_at' field in descending order, displaying the most recent sales first.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/2.success.md#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"body\": {\n    \"sort\": [\n      \"-sale.created_at\"\n    ],\n    \"page\": 1,\n    \"limit\": 10\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to initialize the Agentica framework. It sets up an agent with OpenAI integration, specifying the API key and model.  It also includes controller configurations to specify how to use functions from TypeScript class and Swagger/OpenAPI. It showcases function calling capabilities with `agent.conversate`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/vector-selector/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\nimport { MobileFileSystem } from \"./services/MobileFileSystem\";\n\nconst agent = new Agentica({\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    // functions from TypeScript class\n    {\n      protocol: \"http\",\n      application: typia.llm.application<MobileFileSystem, \"chatgpt\">(),\n      execute: new MobileFileSystem(),\n    },\n    // functions from Swagger/OpenAPI\n    {\n      protocol: \"http\",\n      application: assertHttpLlmApplication({\n        model: \"chatgpt\",\n        document: await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n        ).then(r => r.json()),\n      }),\n      connection: {\n        host: \"https://shopping-be.wrtn.ai\",\n        headers: { Authorization: \"Bearer ********\" },\n      },\n    },\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Expected API calls\nDESCRIPTION: This JSON object outlines the expected sequence of API calls based on the user's prompt. It includes calls to list sales, retrieve detailed information, add to cart, create an order, and publish the order. The `description` field provides context on the purpose of each API endpoint.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/1.failure.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": [\n            {\n              \"type\": \"standalone\",\n              \"operation\": {\n                \"name\": \"shoppings_customers_carts_commodities_create\",\n                \"description\": \"Create a new commodity.\\n\\nCreate a new {@link IShoppingCartCommodity commodity} into a specific\\nshopping cart.\\n\\nIf {@link IShoppingCartCommodity.ICreate.accumulate} has `true` value\\nand there's some same commodity that composed with same\\n{@link IShoppingSaleUnitStock.IInvert stocks and quantities},\\nthen new commodity would not be created but the volume would be accumulated.\\n\\nBy the way, if the target {@link IShoppingSale sale} has been suspended or\\n{@link IShoppingSaleUnitStockInventory out of stock}, then 410 gone error\\nwould be thrown. Therefore, it would better to check the target sale and\\n{@link IShoppingSaleUnitStock stock}'s status before.\"\n              }\n            },\n            {\n              \"type\": \"standalone\",\n              \"operation\": {\n                \"name\": \"shoppings_customers_orders_create\",\n                \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n              }\n            }\n          ]\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Create Shopping Cart Commodity\nDESCRIPTION: This snippet demonstrates the JSON structure for creating a shopping cart commodity.  It includes the sale ID, stock details (unit ID, stock ID, quantity), volume, and accumulate flag.  The sale_id, unit_id, and stock_id should be valid UUIDs. It creates a new IShoppingCartCommodity commodity into a specific shopping cart. If accumulate is true and there's some same commodity that composed with same stocks and quantities, then new commodity would not be created but the volume would be accumulated.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/2.success.md#_snippet_3\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"body\": {\n    \"sale_id\": \"macbook_sale_uuid\",\n    \"stocks\": [\n      {\n        \"unit_id\": \"macbook_unit_uuid\",\n        \"stock_id\": \"most_expensive_macbook_stock_uuid\",\n        \"choices\": [],\n        \"quantity\": 1\n      }\n    ],\n    \"volume\": 1,\n    \"accumulate\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Schema for Specific Methods with Actions (DRF Spectacular)\nDESCRIPTION: This code demonstrates how to extend the OpenAPI schema for a specific method ('set_password') of a Django REST Framework viewset using drf-spectacular. It uses multiple @extend_schema decorators to specify different request and response serializers for different HTTP methods (POST and GET) associated with the action.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/PythonDjangoSnippet.mdx#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@extend_schema(\n    request=AlbumLikeSerializer,\n    responses={204: None},\n    methods=[\"POST\"]\n  )\n  @extend_schema(description='Override a specific method', methods=[\"GET\"])\n  @action(detail=True, methods=['post', 'get'])\n  def set_password(self, request, pk=None):\n    # your action behavior\n    ...\n```\n\n----------------------------------------\n\nTITLE: Starting Agentica with npm\nDESCRIPTION: This command starts the Agentica development environment using npm as the package manager. It specifies the directory where the Agentica project should be initialized.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/cli.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica start <directory>\n```\n\n----------------------------------------\n\nTITLE: Defining IShoppingSale Interface (TypeScript)\nDESCRIPTION: This code defines the `IShoppingSale` interface, representing seller sales products. It's an entity embodying \"product sales\" information registered by the `ISoppingSeller`. The main sale information is recorded in the sub `IShoppingSaleSnapshot`, allowing for historical data preservation and A/B testing.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/DocumentationStrategyDtoDescriptionSnippet.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Seller sales products.\n *\n * `IShoppingSale` is an entity that embodies \"product sales\" (sales)\n * information registered by the {@link ISoppingSeller seller}. And the main\n * information of the sale is recorded in the sub {@link IShoppingSaleSnapshot},\n * not in the main `IShoppingSale`. When a seller changes a previously registered\n * item, the existing `IShoppingSale` record is not changed, but a new\n * {@link IShoppingSaleSnapshot snapshot} record be created.\n *\n * This is to preserve the {@link IShoppingCustomer customer}'s\n * {@link IShoppingOrder purchase history} flawlessly after the customer\n * purchases a specific item, even if the seller changes the components or\n * price of the item. It is also intended to support sellers in so-called A/B\n * testing, which involves changing components or prices and measuring the\n * performance in each case.\n *\n * @author Samchon\n */\nexport interface IShoppingSale { ... }\n```\n\n----------------------------------------\n\nTITLE: Running React Client Project\nDESCRIPTION: These commands navigate to the React client project directory, install dependencies, and then build and start the application. The 'build' command prepares the application for deployment, and 'start' serves the built application.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/index.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# move to react project folder\ncd client\n\n# install dependencies\nnpm install\n\n# build & run\nnpm run build && npm run start\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with TypeScript\nDESCRIPTION: This snippet demonstrates how to initialize Agentica with OpenAI, define a controller using a TypeScript class (MobileFileSystem), and define another controller using a Swagger/OpenAPI document. It showcases integrating different function sources and calling the agent.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\nimport { MobileFileSystem } from \"./services/MobileFileSystem\";\n\nconst agent = new Agentica({\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    // functions from TypeScript class\n    {\n      protocol: \"http\",\n      application: typia.llm.application<MobileFileSystem, \"chatgpt\">(),\n      execute: new MobileFileSystem(),\n    },\n    // functions from Swagger/OpenAPI\n    {\n      protocol: \"http\",\n      application: assertHttpLlmApplication({\n        model: \"chatgpt\",\n        document: await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n        ).then(r => r.json()),\n      }),\n      connection: {\n        host: \"https://shopping-be.wrtn.ai\",\n        headers: { Authorization: \"Bearer ********\" },\n      },\n    },\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: AgenticaSelectBenchmark Class Definition\nDESCRIPTION: This snippet defines the `AgenticaSelectBenchmark` class, which is used for benchmarking LLM function calling selection. It provides methods for executing the benchmark, reporting the results, and configuration options for defining the benchmark's behavior. The class is designed to test whether the selector agent can select candidate functions as expected.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/benchmark.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * LLM function calling selection benchmark.\n *\n * `AgenticaSelectBenchmark` is a class for the benchmark of the\n * LLM (Large Model Language) function calling's selection part.\n * It utilizes the `selector` agent and tests whether the expected\n * {@link IAgenticaOperation operations} are properly selected from\n * the given {@link IAgenticaSelectBenchmarkScenario scenarios}.\n *\n * Note that, this `AgenticaSelectBenchmark` class measures only the\n * selection benchmark, testing whether the `selector` agent can select\n * candidate functions to call as expected. Therefore, it does not test\n * about the actual function calling which is done by the `executor` agent.\n * If you want that feature, use {@link AgenticaCallBenchmark} class instead.\n * \n * @author Samchon\n */\nexport class AgenticaSelectBenchmark<Model extends ILlmSchema.Model> {\n  /**\n   * Initializer Constructor.\n   *\n   * @param props Properties of the selection benchmark\n   */\n  public constructor(props: AgenticaSelectBenchmark.IProps<Model>);\n\n  /**\n   * Execute the benchmark.\n   *\n   * Execute the benchmark of the LLM function selection, and returns\n   * the result of the benchmark.\n   *\n   * If you wanna see progress of the benchmark, you can pass a callback\n   * function as the argument of the `listener`. The callback function\n   * would be called whenever a benchmark event is occurred.\n   *\n   * Also, you can publish a markdown format report by calling\n   * the {@link report} function after the benchmark execution.\n   *\n   * @param listener Callback function listening the benchmark events\n   * @returns Results of the function selection benchmark\n   */\n  public execute(\n    listener?: (event: IAgenticaSelectBenchmarkEvent<Model>) => void,\n  ): Promise<IAgenticaSelectBenchmarkResult<Model>>;\n\n  /**\n   * Report the benchmark result as markdown files.\n   *\n   * Report the benchmark result {@link execute}d by\n   * `AgenticaSelectBenchmark` as markdown files, and returns a\n   * dictionary object of the markdown reporting files. The key of\n   * the dictionary would be file name, and the value would be the\n   * markdown content.\n   *\n   * For reference, the markdown files are composed like below:\n   *\n   * - `./README.md`\n   * - `./scenario-1/README.md`\n   * - `./scenario-1/1.success.md`\n   * - `./scenario-1/2.failure.md`\n   * - `./scenario-1/3.error.md`\n   *\n   * @returns Dictionary of markdown files.\n   */\n  public report(): Record<string, string>;\n}\nexport namespace AgenticaSelectBenchmark {\n  /**\n   * Properties of the {@link AgenticaSelectBenchmark} constructor.\n   */\n  export interface IProps<Model extends ILlmSchema.Model> {\n    /**\n     * AI agent instance.\n     */\n    agent: Agentica<Model>;\n\n    /**\n     * List of scenarios what you expect.\n     */\n    scenarios: IAgenticaSelectBenchmarkScenario<Model>[];\n\n    /**\n     * Configuration for the benchmark.\n     */\n    config?: Partial<IConfig>;\n  }\n\n  /**\n   * Configuration for the benchmark.\n   *\n   * `AgenticaSelectBenchmark.IConfig` is a data structure which\n   * represents a configuration for the benchmark, especially the\n   * capacity information of the benchmark execution.\n   */\n  export interface IConfig {\n    /**\n     * Repeat count.\n     *\n     * The number of repeating count for the benchmark execution\n     * for each scenario.\n     *\n     * @default 10\n     */\n    repeat: number & tags.Type<\"uint32\"> & tags.Minimum<1>;\n\n    /**\n     * Simultaneous count.\n     *\n     * The number of simultaneous count for the parallel benchmark\n     * execution.\n     *\n     * If you configure this property greater than `1`, the benchmark\n     * for each scenario would be executed in parallel in the given\n     * count.\n     *\n     * @default 10\n     */\n    simultaneous: number & tags.Type<\"uint32\"> & tags.Minimum<1>;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Get Sale with Detailed Info Parameters JSON\nDESCRIPTION: This JSON snippet shows an example for retrieving a specific sale with detailed information using its ID. The \"id\" field is intended to represent the unique identifier of a sales record.  It highlights an incorrect value 'all', which should be replaced by a valid UUID.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/2.success.md#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"id\": \"all\"\n}\n```\n\n----------------------------------------\n\nTITLE: Client Application Dependencies Installation (yarn)\nDESCRIPTION: This bash script installs the necessary dependencies for a client application using yarn. It installs `@agentica/core`, `@agentica/rpc`, `tgrid`, and `@samchon/openapi`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/index.mdx#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @agentica/core @agentica/rpc tgrid\nyarn add @agentica/core @samchon/openapi\n```\n\n----------------------------------------\n\nTITLE: Define AgenticaEvent Types\nDESCRIPTION: Defines the discriminated union `AgenticaEvent`, encompassing various event types such as `Initialize`, `Select`, `Call`, `Execute`, and `Describe`. Each event type is further defined within the `AgenticaEvent` namespace.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaEventSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport type AgenticaEvent =\n  | AgenticaEvent.Initialize\n  | AgenticaEvent.Select\n  | AgenticaEvent.Call\n  | AgenticaEvent.Execute\n  | AgenticaEvent.Describe;\n```\n\n----------------------------------------\n\nTITLE: Define Base Event Interface\nDESCRIPTION: Defines the `Base` interface within the `AgenticaEvent` namespace, serving as a base interface for all event types. It includes a `type` property of type `string`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaEventSnippet.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n  interface Base<Type extends string> {\n    type: Type;\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Publish Shopping Order - JSON Request Body\nDESCRIPTION: This JSON snippet represents the request body for publishing a shopping order. It includes the customer's address details and an optional vendor object.  The address contains mandatory fields such as mobile number, receiver name, country, province, city, department, possession, zip code, and an optional special note.  A successful request will publish the order, while a malformed or incomplete request will return an error.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/2.success.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"address\": {\n      \"mobile\": \"01012345678\",\n      \"name\": \"Receiver Name\",\n      \"country\": \"South Korea\",\n      \"province\": \"Seoul\",\n      \"city\": \"Seoul\",\n      \"department\": \"Wrtn Apartment\",\n      \"possession\": \"101-1411\",\n      \"zip_code\": \"zip_code_placeholder\",\n      \"special_note\": null\n    },\n    \"vendor\": null\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating index.js (JavaScript)\nDESCRIPTION: This code snippet updates the `index.js` file to import the `shim.ts` file, applying the necessary polyfills to the React Native application.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/react-native.mdx#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\n// index.js\nimport './shim'; // Add shim\nimport ...\n\nAppRegistry.registerComponent(appName, () => App);\n```\n\n----------------------------------------\n\nTITLE: Testing a GET Request and Generating REST Docs in Kotlin\nDESCRIPTION: This snippet demonstrates testing a GET request to retrieve a sample by ID using MockMvc. It performs the request, validates the HTTP status and JSON response, and generates REST Docs documentation using MockMvcRestDocumentationWrapper.document. The documentation includes request and response details.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/KotlinSpringSnippet.mdx#_snippet_1\n\nLANGUAGE: Kotlin\nCODE:\n```\n  @Test\n  fun getSampleByIdTest() {\n    val sampleId = \"aaa\"\n    mockMvc.perform(\n      get(\"/api/v1/samples/{sampleId}\", sampleId)\n    )\n      .andExpect(status().isOk)\n      .andExpect(jsonPath(\"sampleId\", `is`(sampleId)))\n      .andExpect(jsonPath(\"name\", `is`(\"sample-$sampleId\")))\n      .andDo(\n        MockMvcRestDocumentationWrapper.document(\n          identifier = \"sample\",\n          resourceDetails = ResourceSnippetParametersBuilder()\n            .tag(\"Sample\")\n            .description(\"Get a sample by id\")\n            .pathParameters(\n              parameterWithName(\"sampleId\")\n                .description(\"the sample id\"),\n            )\n            .responseFields(\n              fieldWithPath(\"sampleId\")\n                .type(JsonFieldType.STRING)\n                .description(\"The sample identifier.\"),\n              fieldWithPath(\"name\")\n                .type(JsonFieldType.STRING)\n                .description(\"The name of sample.\"),\n            ),\n        ),\n      )\n  }\n```\n\n----------------------------------------\n\nTITLE: Expected Shopping Operations (JSON)\nDESCRIPTION: This JSON outlines the expected sequence of operations for a shopping scenario. It includes listing sales, getting detailed sale information, creating an order (either with or without a shopping cart), and publishing the order with payment and address details. It describes the expected interaction with a shopping system including API endpoints.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/select/order/README.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": [\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_index\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\"\n      }\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_sales_at\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\"\n      }\n    },\n    {\n      \"type\": \"anyOf\",\n      \"anyOf\": [\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_create\",\n            \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\"\n          }\n        },\n        {\n          \"type\": \"standalone\",\n          \"operation\": {\n            \"name\": \"shoppings_customers_orders_direct\",\n            \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\"\n          }\n        }\n      ]\n    },\n    {\n      \"type\": \"standalone\",\n      \"operation\": {\n        \"name\": \"shoppings_customers_orders_publish_create\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Define Request Event Interface\nDESCRIPTION: Defines the `Request` interface within the `AgenticaEvent` namespace, representing an API request event. It includes the source, body, and optional request options.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaEventSnippet.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n  export interface Request extends Base<\"request\"> {\n    source: AgenticaEventSource;\n    body: OpenAI.ChatCompletionCreateParamsStreaming;\n    options?: OpenAI.RequestOptions | undefined;\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Agentica Initialization with OpenAI and TypeScript Class\nDESCRIPTION: This code snippet demonstrates how to initialize Agentica with an OpenAI model and integrate a TypeScript class as a function provider. It showcases the configuration required to connect to a language model and expose functionalities from a TypeScript class through an HTTP protocol.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/cli/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\nimport { MobileFileSystem } from \"./services/MobileFileSystem\";\n\nconst agent = new Agentica({\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    // functions from TypeScript class\n    {\n      protocol: \"http\",\n      application: typia.llm.application<MobileFileSystem, \"chatgpt\">(),\n      execute: new MobileFileSystem(),\n    },\n    // functions from Swagger/OpenAPI\n    {\n      protocol: \"http\",\n      application: assertHttpLlmApplication({\n        model: \"chatgpt\",\n        document: await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n        ).then(r => r.json()),\n      }),\n      connection: {\n        host: \"https://shopping-be.wrtn.ai\",\n        headers: { Authorization: \"Bearer ********\" },\n      },\n    },\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Create Commodity JSON Request\nDESCRIPTION: This JSON snippet represents the structure of a request to create a new commodity in the shopping cart. It includes details such as the `sale_id`, `unit_id`, `stock_id`, and `quantity`.  The server expects UUID formatted strings for sale_id, unit_id, and stock_id.  Ensure that sale_id, unit_id and stock_id are valid UUIDs.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/4.success.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"sale_id\": \"macbook_sale_id\",\n    \"stocks\": [\n      {\n        \"unit_id\": \"macbook_unit_id\",\n        \"stock_id\": \"macbook_stock_id\",\n        \"choices\": [],\n        \"quantity\": 1\n      }\n    ],\n    \"volume\": 1,\n    \"accumulate\": false\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: List Summarized Sales\nDESCRIPTION: This snippet shows the JSON structure for listing summarized sales. It includes parameters for sorting (by sale creation date in descending order), page number, and the number of items per page. It is used to retrieve a list of summarized IShoppingSale.ISummary summarized sales.  It doesn't contain the SKU (Stock Keeping Unit) information represented by the IShoppingSaleUnitOption and IShoppingSaleUnitStock types.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/2.success.md#_snippet_5\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"body\": {\n    \"sort\": [\n      \"-sale.created_at\"\n    ],\n    \"page\": 1,\n    \"limit\": 10\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing MCP SDK (Bash)\nDESCRIPTION: This command installs the Model Context Protocol SDK package using npm. It's a prerequisite for using MCP with Agentica, as it provides the necessary client and transport implementations.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/controller/mcp.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @modelcontextprotocol/sdk\n```\n\n----------------------------------------\n\nTITLE: Define Initialize Event Interface\nDESCRIPTION: Defines the `Initialize` interface within the `AgenticaEvent` namespace, representing an initialization event. It extends the `Base` interface with the type set to \"initialize\".\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaEventSnippet.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n  export interface Initialize extends Base<\"initialize\"> {}\n\n```\n\n----------------------------------------\n\nTITLE: Setting up Agentica project using command line\nDESCRIPTION: This bash snippet demonstrates how to set up an Agentica project using the `npx agentica start` command. The command initiates a setup wizard that guides the user through selecting a package manager, project type, and embedded controllers.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ npx agentica start <directory>\n\n----------------------------------------\n Agentica Setup Wizard\n----------------------------------------\n? Package Manager (use arrow keys)\n  > npm\n    pnpm\n    yarn (berry is not supported)\n? Project Type\n    NodeJS Agent Server\n  > NestJS Agent Server\n    React Client Application\n    Standalone Application\n? Embedded Controllers (multi-selectable)\n    (none)\n    Google Calendar\n    Google News\n  > Github\n    Reddit\n    Slack\n    ...\n```\n\n----------------------------------------\n\nTITLE: Agentica: Initialize Event Handling in TypeScript\nDESCRIPTION: This snippet showcases how to handle the 'initialize' event in Agentica, which is triggered when function calling begins.  It sets up an Agentica instance and logs a message to the console when the initialization event occurs.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/event.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, AgenticaEvent } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [...],\n});\nagent.on(\"initialize\", async () => {\n  console.log(\"Function calling begins\");\n});\nawait agent.conversate(\"I wanna buy Surface Pro\");\n```\n\n----------------------------------------\n\nTITLE: Navigating to Project Directory\nDESCRIPTION: This command changes the current directory to the newly created Agentica project folder, allowing subsequent commands to be executed within the project context.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/index.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd agentica-test\n```\n\n----------------------------------------\n\nTITLE: Render AgenticaPage Component (JSX)\nDESCRIPTION: This JSX snippet renders the AgenticaPage component. It's a simple component invocation that places the landing page content within the application's UI. The AgenticaPage component is expected to handle the display logic and data rendering for the landing page.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/index.mdx#_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\n<AgenticaPage></AgenticaPage>\n```\n\n----------------------------------------\n\nTITLE: Querying Sales Index with JSON Payload\nDESCRIPTION: This JSON payload is used to query the sales index.  It allows sorting the results by sale price, specifying a page number, and setting a limit on the number of results returned.  It sets the sorting order to descending by real price, sets page to 1 and limit to 100.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/3.failure.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"sort\": [\n      \"-sale.price_range.highest.real\"\n    ],\n    \"page\": 1,\n    \"limit\": 100\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Install WebSocket Server (NodeJS) with Yarn\nDESCRIPTION: Installs the necessary packages for setting up a WebSocket server in a NodeJS environment using Yarn. This includes @agentica/core, @samchon/openapi, typia, @agentica/rpc, and tgrid. A typia setup command is also included. Note: Yarn Berry is not supported.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/manual.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# YARN BERRY IS NOT SUPPORTED\nyarn add @agentica/core @samchon/openapi typia\nyarn add @agentica/rpc tgrid\nyarn typia setup\n```\n\n----------------------------------------\n\nTITLE: Define Response Event Interface\nDESCRIPTION: Defines the `Response` interface within the `AgenticaEvent` namespace, representing an API response event. It includes the source, body, stream, and optional request options, as well as a method to join the stream into a complete response.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaEventSnippet.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n  export interface Response extends Base<\"response\"> {\n    source: AgenticaEventSource;\n    body: OpenAI.ChatCompletionCreateResponse;\n    options?: OpenAI.RequestOptions | undefined;\n    stream: ReadableStream<OpenAI.ChatCompletionChunk>;\n    options?: OpenAI.RequestOptions | undefined;\n    join(): Promise<OpenAI.ChatCompletion>;\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Define LLM Application with Invalid Typescript Interface\nDESCRIPTION: This snippet demonstrates an attempt to define an LLM application using Typia with a Typescript interface (`BbsArticleController`) that violates LLM function calling rules. The `create` function returns a union type with `undefined`, and the `erase` function takes a non-object type parameter, leading to compilation errors.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/controller/typescript.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ILlmApplication } from \"@samchon/openapi\";\nimport typia, { tags } from \"typia\";\n\nconst app: ILlmApplication<\"chatgpt\"> = typia.llm.application<\n  BbsArticleController,\n  \"chatgpt\"\n>();\nconsole.log(app);\n\ninterface BbsArticleController {\n  /**\n   * Create a new article.\n   *\n   * Writes a new article and archives it into the DB.\n   *\n   * @param props Properties of create function\n   * @returns Newly created article, or undefined if failed\n   */\n  create(props: {\n    /**\n     * Information of the article to create\n     */\n    input: IBbsArticle.ICreate;\n  }): Promise<IBbsArticle | undefined>;\n\n  /**\n   * Erase an article.\n   * \n   * @warning Cannot convert to LLM function schema\n   *          Its because the parameter is not an object type\n   */\n  erase(id: string & tags.Format<\"uuid\">): Promise<void>;\n}\n```\n\n----------------------------------------\n\nTITLE: Execute shoppings_customers_sales_at request\nDESCRIPTION: Defines the request body for the 'shoppings_customers_sales_at' API endpoint, which retrieves a specific sale by its ID. The 'id' parameter specifies the unique identifier of the sale to be retrieved.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/4.success.md#_snippet_6\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"id\": \"7212bc44-31f8-4571-b3e9-5362040aee50\"\n}\n```\n\n----------------------------------------\n\nTITLE: Agentica Vector Selector Advanced Setup\nDESCRIPTION: This snippet demonstrates how to configure advanced options for the AgenticaVectorSelector, including experimental features like customizing the function selection prompt. The `experimental` property allows users to specify parameters like `select_prompt` to tailor the selector's behavior.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/vector-selector.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst selectorExecute = AgenticaVectorSelector.boot<\"chatgpt\">({\n  // Advanced configuration options\n  experimental: {\n    select_prompt: \"Custom prompt for function selection\",\n    // Additional experimental features\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Agentica App Configuration Object - JavaScript\nDESCRIPTION: This snippet defines the structure of an Agentica application's configuration object. It initializes the 'success' flag to true and sets the 'data' field to an input value. The configuration object is then logged to the console using console.log().\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/LlmApplicationJavaScriptSnippet.mdx#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst app = {\n  stores: [\n    {\n      input: (\n        ({\n          success: true,\n            data: input,\n          };\n        })()\n      ),\n    },\n  ],\n};\nconsole.log(app);\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica React Native Project\nDESCRIPTION: This command initializes a new Agentica project with the latest version. It guides the user through project configuration, including project name, package manager selection (npm, yarn, or pnpm), project type (React Native), and OpenAI API key setup.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/react-native/battery.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica@latest start\n```\n\n----------------------------------------\n\nTITLE: Creating Battery Controller in React Native with Agentica\nDESCRIPTION: This code snippet demonstrates how to create an Agentica controller for accessing battery information using the `expo-battery` package.  It defines a controller named `BatteryController` that implements the `IAgenticaController` interface. It exports battery-related information retrieval functionality.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/react-native/battery.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport {IAgenticaController} from '@agentica/core';\nimport * as Battery from 'expo-battery';\nimport typia from 'typia';\n\nexport const BatteryController: IAgenticaController<'chatgpt'> = {\n  protocol: 'class',\n  name: 'battery',\n  execute: async props =>\n    (Battery as any)[props.function.name](props.arguments),\n  application: typia.llm.application<\n    Pick<\n      typeof Battery,\n      'getBatteryLevelAsync' | 'getBatteryStateAsync' | 'getPowerStateAsync'\n    >,\n    'chatgpt'\n  >(),\n};\n```\n\n----------------------------------------\n\nTITLE: Agentica CLI: Start Arxiv Search Agent\nDESCRIPTION: This command launches the Agentica Setup Wizard, guiding the user through installing required packages, choosing the package manager and project type, selecting the ARXIV SEARCH controller, and entering the OpenAI API key.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/arxiv.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica start arxiv-search-agent\n```\n\n----------------------------------------\n\nTITLE: Agentica Initialization with TypeScript and OpenAI\nDESCRIPTION: This code snippet demonstrates how to initialize an Agentica agent with OpenAI, using a TypeScript class (MobileFileSystem) and a Swagger/OpenAPI document for function definitions. It utilizes typia for type-safe LLM application definition and includes an example of interacting with the agent.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/benchmark/vector-selector-benchmark/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, assertHttpLlmApplication } from \"@agentica/core\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n\nimport { MobileFileSystem } from \"./services/MobileFileSystem\";\n\nconst agent = new Agentica({\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    // functions from TypeScript class\n    {\n      protocol: \"http\",\n      application: typia.llm.application<MobileFileSystem, \"chatgpt\">(),\n      execute: new MobileFileSystem(),\n    },\n    // functions from Swagger/OpenAPI\n    {\n      protocol: \"http\",\n      application: assertHttpLlmApplication({\n        model: \"chatgpt\",\n        document: await fetch(\n          \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n        ).then(r => r.json()),\n      }),\n      connection: {\n        host: \"https://shopping-be.wrtn.ai\",\n        headers: { Authorization: \"Bearer ********\" },\n      },\n    },\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: List Summarized Sales (shoppings_customers_sales_index) JSON\nDESCRIPTION: This JSON payload defines the request body for listing summarized sales. It specifies sorting by 'sale.created_at' in descending order, limits the page size to 10, and requests the first page. The 'body' parameter contains sorting, pagination, and limit settings.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/1.failure.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"sort\": [\n      \"-sale.created_at\"\n    ],\n    \"page\": 1,\n    \"limit\": 10\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Agentica Benchmark Expected Type Definition\nDESCRIPTION: Defines the `IAgenticaBenchmarkExpected` type, which specifies the expected operation or set of operations for a benchmark.  It is a union type consisting of `IAllOf`, `IAnyOf`, `IArray`, and `IStandalone`, allowing for flexible specification of expected outcomes.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/benchmark.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Expected operation determinant.\n *\n * `IAgenticaBenchmarkExpected` is a type for determining what\n * operation is expected in the benchmarking.\n *\n * And `IAgenticaBenchmarkExpected` is an union type of 4 types,\n * especially designed for the detailed determination of the expected\n * operations.\n *\n * @author Samchon\n */\nexport type IAgenticaBenchmarkExpected<Model extends ILlmSchema.Model> =\n  | IAgenticaBenchmarkExpected.IAllOf<Model>\n  | IAgenticaBenchmarkExpected.IAnyOf<Model>\n  | IAgenticaBenchmarkExpected.IArray<Model>\n  | IAgenticaBenchmarkExpected.IStandalone<Model>;\nexport namespace IAgenticaBenchmarkExpected {\n  /**\n   * All of them must meet the condition, but sequence is not important.\n   */\n  export interface IAllOf<Model extends ILlmSchema.Model> {\n    type: \"allOf\";\n    allOf: Array<\n      Exclude<\n        IAgenticaBenchmarkExpected<Model>,\n        IAgenticaBenchmarkExpected.IAllOf<Model>\n      >\n    >;\n  }\n\n  /**\n   * At least one of them must meet the condition.\n   */\n  export interface IAnyOf<Model extends ILlmSchema.Model> {\n    type: \"anyOf\";\n    anyOf: Array<\n      Exclude<\n        IAgenticaBenchmarkExpected<Model>,\n        IAgenticaBenchmarkExpected.IAnyOf<Model>\n      >\n    >;\n  }\n\n  /**\n   * All of them must meet the condition, and sequence is important.\n   */\n  export interface IArray<Model extends ILlmSchema.Model> {\n    type: \"array\";\n    items: Array<\n      Exclude<\n        IAgenticaBenchmarkExpected<Model>,\n        IAgenticaBenchmarkExpected.IArray<Model>\n      >\n    >;\n  }\n\n  /**\n   * Standalone operation.\n   */\n  export interface IStandalone<Model extends ILlmSchema.Model> {\n    type: \"standalone\";\n    operation: IAgenticaOperation<Model>;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating the Controller in App.tsx with MicroAgentica\nDESCRIPTION: This snippet demonstrates how to integrate the `CalculatorController` into the `MicroAgentica` setup within `App.tsx`. It initializes `MicroAgentica` with the OpenAI model and specifies the `CalculatorController` in the `controllers` array.  It also includes a warning about securing the OpenAI API key in a production environment.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/react-native/calendar.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nnew MicroAgentica({\n  model: 'chatgpt',\n  vendor: {\n    /**\n     * @warning\n     * This template is a proof-of-concept template created to demonstrate whether Agentica can call native features.\n     * To use this in a production environment, architectural modifications are required to properly secure the OpenAI Key.\n     */\n    api: new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY,\n      dangerouslyAllowBrowser: true,\n    }),\n    model: 'gpt-4o',\n  },\n  controllers: [CalculatorController], // Insert CalculatorController. \n});\n```\n\n----------------------------------------\n\nTITLE: Setup PostgreSQL with Vector Extension\nDESCRIPTION: This command sets up a PostgreSQL database with the pgvector extension using Docker. It defines environment variables for the database user, password, and database name, and maps the port 5432 for external access.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/vector-selector.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -d \\\n  --name postgres-vector \\\n  -e POSTGRES_USER=your_user \\\n  -e POSTGRES_PASSWORD=your_password \\\n  -e POSTGRES_DB=your_database \\\n  -p 5432:5432 \\\n  pgvector/pgvector\n```\n\n----------------------------------------\n\nTITLE: Installing Agentica and Polyfills (NPM)\nDESCRIPTION: This command installs Agentica core libraries and required polyfill libraries for React Native.  These polyfills address compatibility issues within the React Native environment, particularly concerning features expected by Agentica and related libraries.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/react-native.mdx#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @agentica/core openai\nnpm i react-native-polyfill-globals@latest react-native-url-polyfill react-native-get-random-values react-native-fetch-api base-64 web-streams-polyfill@3.3.3 @azure/core-asynciterator-polyfill\n```\n\n----------------------------------------\n\nTITLE: Create New Order Application (JSON)\nDESCRIPTION: This JSON snippet illustrates the format for creating a new order application.  It includes a `body` object containing the `goods` to be ordered (identified by `commodity_id` and `volume`) and a `name` for the order.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/1.failure.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"goods\": [\n      {\n        \"commodity_id\": \"uuid-for-macbook-high-end\",\n        \"volume\": 1\n      }\n    ],\n    \"name\": \"Macbook Order\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: IAgenticaSelectBenchmarkEvent Definition\nDESCRIPTION: This snippet defines the `IAgenticaSelectBenchmarkEvent` interface, representing events that occur during the LLM function selection benchmark. These events represent different phases of the benchmark testing for a scenario, categorized as success, failure, or error, providing insight into the benchmark's progress and results.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/benchmark.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Event of LLM function selection benchmark.\n *\n * `IAgenticaSelectBenchmarkEvent` is an union type of the events occurred\n * during the LLM function selection benchmark, representing one phase of\n * the benchmark testing about a scenario.\n *\n * In other words, when {@link AgenticaSelectBenchmark} executes the\n * benchmark, it will run the benchmark will test a scenario repeately with\n * the given configuration {@link AgenticaSelectBenchmark.IConfig.repeat}.\n * And in the repeated benchmark about a scenario,\n * `IAgenticaSelectBenchmarkEvent` is one of the repeated testing.\n *\n * For reference, `IAgenticaSelectBenchmarkEvent` is categorized into three\n * types: `success`, `failure`, and `error`. The `success` means the\n * benchmark testing is fully meet the expected scenario, and `failure`\n * means that the `selector` had not selected the expected operations. The\n * last type, `error`, means that an error had been occurred during the\n * benchmark testing.\n *\n * @author Samchon\n */\n```\n\n----------------------------------------\n\nTITLE: Install better-sqlite3\nDESCRIPTION: This command installs the better-sqlite3 package using npm. This package provides a fast and simple SQLite3 wrapper for Node.js.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/vector-selector.mdx#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nnpm install better-sqlite3\n```\n\n----------------------------------------\n\nTITLE: Gmail Agent with Function Selection\nDESCRIPTION: This code shows how to restrict the available functions of the Gmail Agent by using TypeScript's `Pick` utility. This enhances security and maintainability by only exposing specific functions like `createDraft`, `findEmails`, `deleteMailList`, `sendEmail`, and `hardDelete`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/gmail.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport const GmailAgent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: openai,\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      name: \"Gmail Connector\",\n      protocol: \"class\",\n      application: typia.llm.application<\n        Pick<\n          GmailService,\n          | \"createDraft\"\n          | \"findEmails\"\n          | \"deleteMailList\"\n          | \"sendEmail\"\n          | \"hardDelete\"\n        >,\n        \"chatgpt\"\n      >(),\n      execute: new GmailService({\n        clientId: process.env.GMAIL_CLIENT_ID!,\n        clientSecret: process.env.GMAIL_CLIENT_SECRET!,\n        secret: process.env.GMAIL_REFRESH_TOKEN!,\n      }),\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server with pnpm\nDESCRIPTION: This snippet illustrates how to start the development server using the pnpm package manager. The `pnpm dev` command likely initiates a local server that checks for compilation and type-checking errors, facilitating a smooth development process.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with pnpm\nDESCRIPTION: Installs the necessary pnpm packages for setting up a NestJS WebSocket server with Agentica. It includes dependencies for NestJS core functionality, Agentica's core library and OpenAPI support, WebSocket RPC, and development tools like nestia.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/nestjs.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm install @nestjs/common @nestjs/core @nestjs/platform-express\npnpm install @agentica/core @samchon/openapi\npnpm install @agentica/rpc tgrid\n\npnpm install -D nestia\npnpm nestia setup\n```\n\n----------------------------------------\n\nTITLE: Defining Pydantic Item Model\nDESCRIPTION: This code snippet defines a Pydantic data model named 'Item' inheriting from BaseModel. It specifies data fields with type hints and descriptions using the Field class. The tags field uses default_factory=list to initialize an empty list if no value is provided.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/PythonFastApiSnippet.mdx#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Item(BaseModel):\n  id: int\n  name: str\n  description: str = Field(None, description=\"The description of the item\")\n  price: float = Field(..., description=\"The price of the item\")\n  tags: List[str] = Field(\n    default_factory=list,\n    description=\"A list of tags associated with the item\"\n  )\n```\n\n----------------------------------------\n\nTITLE: ShoppingCustomerOrderController in TypeScript\nDESCRIPTION: This snippet represents the ShoppingCustomerOrderController, likely part of a shopping backend application. It handles customer order-related functionalities. Without actual code, the specifics are unknown but based on name one can infer its function within a larger e-commerce system.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/ShoppingCustomerOrderPublishControllerSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: List Summarized Sales - JSON Request Body\nDESCRIPTION: This snippet shows the JSON request body for listing summarized sales. It includes sorting criteria, page number, and the maximum number of items per page. The 'sort' parameter specifies the sorting order based on the 'real' value of the highest price within the sale's price range, in descending order.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/4.success.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"sort\": [\n      \"-sale.price_range.highest.real\"\n    ],\n    \"page\": 1,\n    \"limit\": 10\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Backend API Example (Kotlin Spring)\nDESCRIPTION: Illustrates a backend API endpoint implementation using Kotlin and the Spring framework. This showcases a traditional backend setup where the Swagger/OpenAPI document generation is not emphasized.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/concepts/compiler-driven-development.mdx#_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nimport AgenticaExamplePseudoSnippet from \"../../snippets/AgenticaExamplePseudoSnippet.mdx\";\nimport AgenticaExampleActualSnippet from \"../../snippets/AgenticaExampleActualSnippet.mdx\";\nimport KotlinSpringSnippet from \"../../snippets/KotlinSpringSnippet.mdx\";\n```\n\n----------------------------------------\n\nTITLE: BBS Articles Controller Definition\nDESCRIPTION: Defines the BbsArticlesController class with methods for handling article-related operations. It utilizes NestJS's Controller decorator to define the base route and Nestia's TypedRoute decorators for specific endpoint definitions. The controller depends on IBbsArticle and IPage interfaces for request and response types.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/BbsArticleControllerSnippet.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TypedBody, TypedRoute, TypedParam } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport { tags } from \"typia\";\n\nimport { IBbsArticle } from \"../../api/structures/bbs/IBbsArticle\";\nimport { IPage } from \"../../api/structures/common/IPage\";\nimport { BbsArticleProvider } from \"../../providers/bbs/BbsArticleProvider\";\n\n@Controller(\"bbs/articles/:section\")\nexport class BbsArticlesController {\n  /**\n   * List up entire articles, but paginated and summarized.\n   *\n   * This method is for listing up summarized articles with pagination.\n   *\n   * If you want, you can search and sort articles with specific conditions.\n   *\n   * @param section Target section\n   * @param input Pagination request info with searching and sorting options\n   * @returns Paginated articles with summarization\n   */\n  @TypedRoute.Patch()\n  public index(\n    @TypedBody() input: IBbsArticle.IRequest,\n  ): Promise<IPage<IBbsArticle.ISummary>>;\n\n  /**\n   * Get an article with detailed info.\n   *\n   * Open an article with detailed info, increasing reading count.\n   *\n   * @param section Target section\n   * @param id Target articles id\n   * @returns Detailed article info\n   */\n  @TypedRoute.Get(\":id\")\n  public at(\n    @TypedParam(\"id\") id: string,\n  ): Promise<IBbsArticle>;\n\n  /**\n   * Create a new article.\n   *\n   * Create a new article and returns its detailed record info.\n   *\n   * @param section Target section\n   * @param input New article info\n   * @returns Newly created article info\n   */\n  @TypedRoute.Post()\n  public create(\n    @TypedBody() input: IBbsArticle.ICreate,\n  ): Promise<IBbsArticle>;\n\n  /**\n   * Update article.\n   *\n   * When updating, this BBS system does not overwrite the content, but accumulate it.\n   * Therefore, whenever an article being updated, length of {@link IBbsArticle.snapshots}\n   * would be increased and accumulated.\n   *\n   * @param id Target articles id\n   * @param input Content to update\n   * @returns Newly created content info\n   */\n  @TypedRoute.Put(\":id\")\n  public update(\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\n    @TypedBody() input: IBbsArticle.IUpdate,\n  ): Promise<IBbsArticle.ISnapshot>;\n\n  /**\n   * Erase an article.\n   *\n   * Erase an article with specific password.\n   *\n   * @param id Target articles id\n   * @param input Password to erase\n   */\n  @TypedRoute.Delete(\":id\")\n  public erase(\n    @TypedParam(\"id\") id: string,\n    @TypedBody() input: IBbsArticle.IErase,\n  ): Promise<void>;\n}\n```\n\n----------------------------------------\n\nTITLE: Agentica: Joining Describe Event in TypeScript\nDESCRIPTION: This example demonstrates how to join the text content of a 'describe' event in Agentica. It initializes an Agentica instance, adds an event listener to the 'describe' event, and concatenates all streamed text data into a single string for processing.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/event.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, AgenticaEvent } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [...],\n});\nagent.on(\"describe\", async (event) => {\n  console.log(\"Describe Function Calling\");\n  for (const execute of event.executes)\n    console.log(`  - ${execute.operation.name}`);\n\n  const text: string = await event.join();\n  console.log(text);\n});\nawait agent.conversate(\"I wanna buy Surface Pro\");\n```\n\n----------------------------------------\n\nTITLE: Updating tsconfig.json (JSON)\nDESCRIPTION: This code snippet updates the `tsconfig.json` file to extend the default React Native TypeScript configuration and include any required `compilerOptions`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/react-native.mdx#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"extends\": \"@react-native/typescript-config/tsconfig.json\",\n  \"compilerOptions\": {}\n}\n```\n\n----------------------------------------\n\nTITLE: Execute Sales Details Retrieval (JSON)\nDESCRIPTION: This JSON snippet demonstrates the structure for executing a request to retrieve detailed information about a specific sale. The `id` field contains the unique identifier of the sale to be retrieved.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/1.failure.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"e12c7653-0edf-4595-98ec-03f9b9e9a7e3\"\n}\n```\n\n----------------------------------------\n\nTITLE: Agentica Project Setup using CLI\nDESCRIPTION: This bash command demonstrates how to start the Agentica setup wizard to create a new project. The wizard guides the user through selecting a package manager, project type (NodeJS, NestJS, React, or standalone), and embedded controllers.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/benchmark/vector-selector-benchmark/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ npx agentica start <directory>\n```\n\n----------------------------------------\n\nTITLE: Handling Describe Prompts with Agentica\nDESCRIPTION: This snippet shows how to initialize Agentica and iterate through prompts to identify and log description-based conversation entries. It shows operation names and descriptions.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/history.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, AgenticaHistory } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"*****\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [...],\n});\nconst prompts: AgenticaHistory[] = await agent.conversate(\n  \"I wanna buy MacBook Pro\",\n);\nfor (const p of prompts)\n  if (p.type === \"describe\")\n    console.log(\n      \"describe\",\n      p.executes.map((e) => e.operation.name),\n      p.text,\n    );\n```\n\n----------------------------------------\n\nTITLE: Agentica Calendar Controller (React Native)\nDESCRIPTION: This TypeScript code defines a controller for managing calendar operations within an Agentica-powered React Native application. It implements the IAgenticaController interface, allowing integration with a ChatGPT agent.  It utilizes the `expo-calendar` library to interact with device calendars and provides a set of wrapped functions for common calendar tasks.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/react-native/calendar.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {IAgenticaController} from '@agentica/core';\nimport typia, {Primitive} from 'typia';\nimport * as Calendar from 'expo-calendar';\n\n/**\n * Controller for handling calendar operations.\n * Implements the IAgenticaController interface for ChatGPT integration.\n */\nexport const CalendarController: IAgenticaController<'chatgpt'> = {\n  protocol: 'class',\n  name: 'calendar',\n  execute: async props => {\n    return (WRAPPED_CALENDAR as any)[props.function.name](props.arguments);\n  },\n  application: typia.llm.application<typeof WRAPPED_CALENDAR, 'chatgpt'>(),\n};\n\n/**\n * Namespace containing all wrapped calendar operations.\n * Provides type-safe interfaces for interacting with the Expo Calendar API.\n */\nexport namespace WRAPPED_CALENDAR {\n  /**\n   * Checks if the Calendar API is available on the current device.\n   * Note: This only checks if the API is available, not if the app has permissions to use it.\n   * @returns A promise that resolves to true if the Calendar API is available, false otherwise.\n   */\n  export async function wrappedIsAvailableAsync(): Promise<boolean> {\n    return Calendar.isAvailableAsync();\n  }\n\n  /**\n   * Retrieves a list of calendars from the device.\n   * On iOS, can optionally filter by entity type (events or reminders).\n   * @param props Optional parameters for filtering calendars.\n   * @returns A promise that resolves to an array of calendar objects.\n   */\n  export async function wrappedGetCalendarsAsync(\n    props: WrappedGetCalendarsAsyncProps,\n  ): Promise<Calendar.Calendar[]> {\n    return Calendar.getCalendarsAsync(props.entityType);\n  }\n\n  /**\n   * Creates a new calendar on the device.\n   * @param props The properties for the new calendar.\n   * @returns A promise that resolves to the ID of the newly created calendar.\n   */\n  export async function wrappedCreateCalendarAsync(\n    props: WrappedCreateCalendarAsyncProps,\n  ): Promise<string> {\n    return Calendar.createCalendarAsync(props.details);\n  }\n\n  /**\n   * Updates an existing calendar's properties.\n   * @param props The ID of the calendar to update and the new properties.\n   * @returns A promise that resolves to the ID of the updated calendar.\n   */\n  export async function wrappedUpdateCalendarAsync(\n    props: WrappedUpdateCalendarAsyncProps,\n  ): Promise<string> {\n    return Calendar.updateCalendarAsync(props.id, props.details);\n  }\n\n  /**\n   * Deletes a calendar and all its associated events/reminders.\n   * Warning: This action cannot be undone.\n   * @param props The ID of the calendar to delete.\n   * @returns A promise that resolves when the calendar is deleted.\n   */\n  export async function wrappedDeleteCalendarAsync(\n    props: WrappedDeleteCalendarAsyncProps,\n  ): Promise<void> {\n    return Calendar.deleteCalendarAsync(props.id);\n  }\n\n  /**\n   * Retrieves events from specified calendars within a given time range.\n   * Note: The behavior differs between iOS and Android:\n   * - iOS returns all events that overlap with the time range\n   * - Android returns only events that start and end within the time range\n   * @param props The calendar IDs and time range to search.\n   * @returns A promise that resolves to an array of event objects.\n   */\n  export async function wrappedGetEventsAsync(\n    props: WrappedGetEventsAsyncProps,\n  ): Promise<Calendar.Event[]> {\n    return Calendar.getEventsAsync(\n      props.calendarIds,\n      new Date(props.startDate),\n      new Date(props.endDate),\n    );\n  }\n\n  /**\n   * Retrieves a specific event by its ID.\n   * For recurring events, can optionally specify a particular instance.\n   * @param props The event ID and optional recurring event parameters.\n   * @returns A promise that resolves to the event object.\n   */\n  export async function wrappedGetEventAsync(\n    props: WrappedGetEventAsyncProps,\n  ): Promise<Calendar.Event> {\n    return Calendar.getEventAsync(props.id, {\n      ...props.recurringEventOptions,\n      instanceStartDate: props.recurringEventOptions?.instanceStartDate\n        ? new Date(props.recurringEventOptions.instanceStartDate)\n        : undefined,\n    });\n  }\n\n  /**\n   * Creates a new event in the specified calendar.\n   * @param props The calendar ID and event data.\n   * @returns A promise that resolves to the ID of the newly created event.\n   */\n  export async function wrappedCreateEventAsync(\n    props: WrappedCreateEventAsyncProps,\n  ): Promise<string> {\n    return Calendar.createEventAsync(props.calendarId, {\n      ...props.eventData,\n      startDate: new Date(props.eventData.startDate ?? ''),\n      endDate: new Date(props.eventData.endDate ?? ''),\n      lastModifiedDate: props.eventData.lastModifiedDate\n        ? new Date(props.eventData.lastModifiedDate)\n        : undefined,\n      originalStartDate: props.eventData.originalStartDate\n        ? new Date(props.eventData.originalStartDate)\n        : undefined,\n    });\n  }\n\n  /**\n   * Updates an existing event's properties.\n   * @param props The event ID, new properties, and optional recurring event parameters.\n   * @returns A promise that resolves to the ID of the updated event.\n   */\n  export async function wrappedUpdateEventAsync(\n    props: WrappedUpdateEventAsyncProps,\n  ): Promise<string> {\n    return Calendar.updateEventAsync(\n      props.id,\n      {\n        ...props.details,\n        startDate: props.details.startDate\n          ? new Date(props.details.startDate)\n          : undefined,\n        endDate: props.details.endDate\n          ? new Date(props.details.endDate)\n          : undefined,\n        lastModifiedDate: props.details.lastModifiedDate\n          ? new Date(props.details.lastModifiedDate)\n          : undefined,\n        originalStartDate: props.details.originalStartDate\n          ? new Date(props.details.originalStartDate)\n          : undefined,\n      },\n      {\n        ...props.recurringEventOptions,\n        instanceStartDate: props.recurringEventOptions?.instanceStartDate\n          ? new Date(props.recurringEventOptions.instanceStartDate)\n          : undefined,\n      },\n    );\n  }\n\n  /**\n   * Deletes an event from the calendar.\n   * @param props The event ID and optional recurring event parameters.\n   * @returns A promise that resolves when the event is deleted.\n   */\n  export async function wrappedDeleteEventAsync(\n    props: WrappedDeleteEventAsyncProps,\n  ): Promise<void> {\n    return Calendar.deleteEventAsync(props.id, props.recurringEventOptions);\n  }\n\n  /**\n   * Retrieves all attendees for a specific event.\n   * @param props The event ID and optional recurring event parameters.\n   * @returns A promise that resolves to an array of attendee objects.\n   */\n  export async function wrappedGetAttendeesForEventAsync(\n    props: WrappedGetAttendeesForEventAsyncProps,\n  ): Promise<Calendar.Attendee[]> {\n    return Calendar.getAttendeesForEventAsync(\n      props.id,\n      props.recurringEventOptions,\n    );\n  }\n\n  /**\n   * Checks the current permissions for accessing calendars.\n   * @returns A promise that resolves to the current permission status.\n   */\n  export async function wrappedGetCalendarPermissionsAsync(): Promise<Calendar.PermissionResponse> {\n    return Calendar.getCalendarPermissionsAsync();\n  }\n\n  /**\n   * Requests permission to access calendars.\n   * @returns A promise that resolves to the permission status after the user responds.\n   */\n  export async function wrappedRequestCalendarPermissionsAsync(): Promise<Calendar.PermissionResponse> {\n    return Calendar.requestCalendarPermissionsAsync();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Apple MacBook Pro Sale Details\nDESCRIPTION: This section details comprehensive information about a specific sale of an Apple MacBook Pro, providing insights into various components of the sale, including basic details, content information, seller and customer details, categories, and available units.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/4.success.md#_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\nMacBook Pro\n\n**The Ultimate Tool for Professionals**\n\nMacBook Pro is designed to elevate your creativity and productivity to new heights. Combining exceptional performance, elegant design, and the unparalleled experience only Apple can deliver, this is the device that empowers you to tackle any challenge with confidence.\n\n- **Remarkable Performance**\n\n  Powered by the next-generation chip, it handles demanding tasks and complex projects effortlessly, delivering unmatched speed and efficiency.\n\n- **Outstanding Display**\n\n  The Retina display offers rich colors and sharp contrast, creating an immersive visual experience. With ProMotion technology, enjoy smooth scrolling and fluid animations like never before.\n\n- **All-Day Battery Life**\n\n  Stay focused and in the flow wherever you go with a battery that lasts all day. This is a laptop that works as hard as you do.\n\n- **Sleek Yet Powerful Design**\n\n  A precision aluminum body that’s lightweight yet durable, paired with a minimalist design that stands out on your desk and on the go.\n\n- **Smart Connectivity**\n\n  Versatile ports for high-speed data transfer and seamless compatibility ensure you're ready for any work environment.\n\nWith MacBook Pro, your potential knows no bounds. **It’s time to rediscover what you’re capable of.**\n```\n\n----------------------------------------\n\nTITLE: Importing Nextra Tabs and RemoteSource component\nDESCRIPTION: This code snippet imports the Tabs component from the nextra/components library and the RemoteSource component from a local file. These components are essential for structuring and displaying the remote TypeScript code within the page.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/DocumentationStrategyPropertyDescriptionSnippet.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Tabs } from \"nextra/components\";\n\nimport { RemoteSource } from \"../../components/RemoteSource\";\n```\n\n----------------------------------------\n\nTITLE: Error on MigrateRouteFetcher.propagate\nDESCRIPTION: This section describes a 500 Internal Server Error encountered while publishing an order, specifically an error within the MigrateRouteFetcher.propagate() method. The error message indicates a mismatch in the number of parameters, which could be due to missing parameters, data type mismatches, or server-side issues.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/4.success.md#_snippet_9\n\n\n\n----------------------------------------\n\nTITLE: Extending Schema for Album Creation (DRF Spectacular)\nDESCRIPTION: This code extends the automatically generated schema for the 'create' method of an AlbumViewset using drf-spectacular. It specifies the request serializer as AlbumCreationSerializer and the response serializer as AlbumSerializer for a 201 status code.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/PythonDjangoSnippet.mdx#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@extend_schema(\n    request=AlbumCreationSerializer,\n    responses={201: AlbumSerializer},\n  )\n  def create(self, request):\n    # your non-standard behavior\n    return super().create(request)\n```\n\n----------------------------------------\n\nTITLE: shoppings_customers_sales_index request body\nDESCRIPTION: This JSON represents the request body used when calling the `shoppings_customers_sales_index` API endpoint. It specifies the sorting criteria (by sale price in descending order), the page number (1), and the limit of items per page (10).  This is intended to retrieve the most expensive sales first.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/3.failure.md#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"body\": {\n    \"sort\": [\n      \"-sale.price_range.highest.real\"\n    ],\n    \"page\": 1,\n    \"limit\": 10\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Select Prompts with Agentica\nDESCRIPTION: This snippet shows how to initialize Agentica and iterate through prompts to identify and log selection-based conversation entries. It iterates through the selections to show operation names and reasons.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/history.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, AgenticaHistory } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"*****\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [...],\n});\n\nconst prompts: AgenticaHistory[] = await agent.conversate(\n  \"I wanna buy MacBook Pro\",\n);\nfor (const p of prompts)\n  if (p.type === \"select\")\n    for (const selection of p.selections) \n      console.log(\n        \"select\",\n        selection.operation.name,\n        selection.reason,\n      );\n```\n\n----------------------------------------\n\nTITLE: Setting up MockMvc with Spring REST Docs in Kotlin\nDESCRIPTION: This snippet demonstrates the setup of MockMvc for testing Spring MVC controllers. It integrates Spring REST Docs to generate API documentation from the test execution. It initializes MockMvc within the setUp function, configuring it with the WebApplicationContext and RestDocumentationContextProvider.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/KotlinSpringSnippet.mdx#_snippet_0\n\nLANGUAGE: Kotlin\nCODE:\n```\n@ExtendWith(RestDocumentationExtension::class, SpringExtension::class)\n@SpringBootTest\nclass SampleControllerTest {\n  private lateinit var mockMvc: MockMvc\n\n  @BeforeEach\n  internal fun setUp(context: WebApplicationContext, restDocumentation: RestDocumentationContextProvider) {\n    mockMvc = MockMvcBuilders\n      .webAppContextSetup(context)\n      .apply<DefaultMockMvcBuilder>(\n        MockMvcRestDocumentation.documentationConfiguration(\n          restDocumentation\n        )\n      ).build()\n  }\n```\n\n----------------------------------------\n\nTITLE: Rendering Agentica Chat Application with React and TypeScript\nDESCRIPTION: This code snippet demonstrates how to render the AgenticaChatApplication component within a React application.  It imports the necessary modules from `@agentica/core` and `@agentica/chat`, creates an Agentica instance (agent), and then renders the AgenticaChatApplication component with the agent prop.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/chat/src/README.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport { AgenticaChatApplication } from \"@agentica/chat\";\nimport typia from \"typia\";\n\nconst agent = new Agentica({ ... });\nReactDOM.render(\n  <AgenticaChatApplication agent={agent} />,\n  document.body,\n);\n```\n\n----------------------------------------\n\nTITLE: Listening for Response Event in Agentica\nDESCRIPTION: This code snippet demonstrates how to listen for the 'response' event in an Agentica agent. The 'response' event is triggered when Agentica receives a response from the OpenAI API. The code logs the completion data to the console. It requires the `@agentica/core` and `openai` packages.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/event.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, AgenticaEvent } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [...],\n});\nagent.on(\"response\", async (event) => {\n  console.log(\n    \"completion\",\n    (await event.join()) satisfies OpenAI.ChatCompletion,\n  );\n});\nawait agent.conversate(\"I wanna buy Surface Pro\");\n```\n\n----------------------------------------\n\nTITLE: Handling Text Prompts with Agentica\nDESCRIPTION: This snippet shows how to initialize Agentica and iterate through prompts to identify and log text-based conversation entries. It demonstrates how to access the role and text content of `AgenticaHistory.Text` prompts.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/history.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, AgenticaHistory } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"*****\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [...],\n});\n\nconst prompts: AgenticaHistory[] = await agent.conversate(\n  \"I wanna buy MacBook Pro\",\n);\nfor (const p of prompts)\n  if (p.type === \"text\") console.log(p.role, p.text);\n```\n\n----------------------------------------\n\nTITLE: Google API Credentials Configuration\nDESCRIPTION: These environment variables are required to configure the Google API credentials for the Google Docs Agent. They include the OpenAI API key, Google Docs Client ID, Client Secret, and Refresh Token, which are necessary for authenticating and authorizing the agent to access Google Docs.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-docs.mdx#_snippet_2\n\nLANGUAGE: env\nCODE:\n```\nOPENAI_API_KEY=your-openai-api-key\nGOOGLE_DOCS_CLIENT_ID=your-google-docs-client-id\nGOOGLE_DOCS_CLIENT_SECRET=your-google-docs-client-secret\nGOOGLE_DOCS_REFRESH_TOKEN=your-google-docs-refresh-token\n```\n\n----------------------------------------\n\nTITLE: List Cart Commodities (shoppings_customers_carts_commodities_index) JSON\nDESCRIPTION: This JSON payload is used to request a list of commodities in a shopping cart. It includes search criteria (currently empty), sorting by 'sale.created_at' in descending order, pagination settings (page 1, limit 100), and an empty body. This allows retrieval of paginated shopping cart items.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/1.failure.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"search\": {},\n  \"sort\": [\n    \"-sale.created_at\"\n  ],\n  \"page\": 1,\n  \"limit\": 100,\n  \"body\": {}\n}\n```\n\n----------------------------------------\n\nTITLE: Execute shoppings_customers_sales_index body\nDESCRIPTION: This JSON provides the request body used when executing the `shoppings_customers_sales_index` API. It specifies the sorting criteria (by sales creation date in descending order) and pagination parameters (page number and limit per page).\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/1.failure.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"sort\": [\n      \"-sale.created_at\"\n    ],\n    \"page\": 1,\n    \"limit\": 10\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Agentica Project with CLI\nDESCRIPTION: This bash command uses the Agentica CLI to start a new project in a specified directory. It initiates an interactive setup wizard to configure the project's package manager, type, and embedded controllers.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/vector-selector/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ npx agentica start <directory>\n```\n\n----------------------------------------\n\nTITLE: Agentica: Disabling Initializer in TypeScript\nDESCRIPTION: This snippet demonstrates how to disable the initializer feature in Agentica by configuring `IAgenticaExecutor.initialize` to `null`. This prevents the `AgenticaEvent.Initialize` event from being triggered.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/event.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica, IAgenticaConfig, IAgenticaExecutor } from \"@agentica/core\";\nimport OpenAI from \"openai\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [...],\n  config: {\n    executor: {\n      initialize: null,\n    } satisfies IAgenticaExecutor,\n  } satisfies IAgenticaConfig,\n});\nawait agent.conversate(\"I wanna buy Surface Pro\");\n```\n\n----------------------------------------\n\nTITLE: Frontend Rendering with @autoview/ui\nDESCRIPTION: This snippet demonstrates how to render the automatically generated code using the `@autoview/ui` package. It shows how to import `renderComponent()` from `@autoview/ui` and use it as a React component.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/related/autoview.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n//----\n// GENERATED CODE\n//----\n// src/transformSale.ts\nimport { IAutoViewComponentProps } from \"@autoview/interface\";\n\nexport function transformSale(sale: IShoppingSale): IAutoViewComponentProps;\n\n//----\n// RENDERING CODE\n//----\n// src/SaleView.tsx\nimport { IAutoViewComponentProps } from \"@autoview/interface\";\nimport { renderComponent } from \"@autoview/ui\";\n\nimport { transformSale } from \"./transformSale\";\n\nexport const SaleView = (props: {\n  sale: IShoppingSale\n}) => {\n  const comp: IAutoViewComponentProps = transformSale(sale);\n  return <div>\n    {renderComponent(comp)}\n  </div>;\n};\nexport default SaleView;\n\n//----\n// MAIN APPLICATION\n//----\n// src/main.tsx\nimport ReactDOM from \"react-dom\";\n\nimport SaleView from \"./SaleView\";\n\nconst sale: IShoppingSale = { ... };\nReactDOM.render(<SaleView sale={sale} />, document.body);\n```\n\n----------------------------------------\n\nTITLE: Validating Article Erase Input\nDESCRIPTION: This snippet validates the input for deleting an existing Bbs article. The main validation is that the article ID is present and in the correct UUID format, checked via typia's `isFormatUuid` function.  If the ID is valid the function returns a success boolean and the input data; otherwise, it will return a list of errors.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/LlmApplicationJavaScriptSnippet.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst _io0 = (input) =>\n          \"string\" === typeof input.id &&\n          __typia_transform__isFormatUuid._isFormatUuid(input.id);\n        const _vo0 = (input, _path, _exceptionable = true) =>\n          [\n            (\"string\" === typeof input.id &&\n              (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n                _report(_exceptionable, {\n                  path: _path + \".id\",\n                  expected: 'string & Format<\"uuid\">',\n                  value: input.id,\n                }))) ||\n              _report(_exceptionable, {\n                path: _path + \".id\",\n                expected: '(string & Format<\"uuid\">)',\n                value: input.id,\n              }),\n          ].every((flag) => flag);\n        const __is = (input) =>\n          \"object\" === typeof input && null !== input && _io0(input);\n        let errors;\n        let _report;\n        return (input) => {\n          if (false === __is(input)) {\n            errors = [];\n            _report = __typia_transform__validateReport._validateReport(errors);\n            ((input, _path, _exceptionable = true) =>\n              (((\"object\" === typeof input && null !== input) ||\n                _report(true, {\n                  path: _path + \"\",\n                  expected: \"__type\",\n                  value: input,\n                })) &&\n                _vo0(input, _path + \"\", true)) ||\n              _report(true, {\n                path: _path + \"\",\n                expected: \"__type\",\n                value: input,\n              }))(input, \"$input\", true);\n            const success = 0 === errors.length;\n            return success\n              ? {\n                  success,\n                  data: input,\n                }\n              : {\n                  success,\n                  errors,\n                  data: input,\n                };\n          }\n          return {\n            success: true,\n            data: input,\n          };\n        };\n```\n\n----------------------------------------\n\nTITLE: Get Sale Details by ID (shoppings_customers_sales_at) JSON\nDESCRIPTION: This JSON payload is used to retrieve the detailed information of a specific sale using its ID. The 'id' parameter specifies the unique identifier of the sale to be retrieved. This call is crucial for AI chatbots needing stock information.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/1.failure.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"3c92c14f-2c0f-4c0a-bf77-6f8bb300fb25\"\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Agentica dependencies using npm\nDESCRIPTION: This command installs the necessary dependencies for developing a NodeJS WebSocket server for an AI chatbot using Agentica. It installs @agentica/core, @samchon/openapi, typia, @agentica/rpc, and tgrid using npm. It also sets up typia.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/nodejs.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @agentica/core @samchon/openapi typia\nnpm install @agentica/rpc tgrid\nnpx typia setup\n```\n\n----------------------------------------\n\nTITLE: Example JSON Schema with format specification\nDESCRIPTION: This JSON snippet demonstrates a simple schema example showing a \"string\" type with a \"description\" field that includes a \"@format uuid\" annotation. This is used to convey formatting information to LLMs, especially when the underlying schema does not directly support the 'format' keyword, as in OpenAI's schema model. The LLM must interpret the \"@format uuid\" description to validate the data correctly.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/core/vendor.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"string\",\n  \"description\": \"Primary Key.\\n\\n@format uuid\"\n}\n```\n\n----------------------------------------\n\nTITLE: Frontend Chat Application with React and Agentica\nDESCRIPTION: This TypeScript snippet demonstrates how to create a frontend chat application using React, `@agentica/core`, and `@wrtnlabs/chat`.  It fetches a Swagger document, converts it to the OpenAPI format using `@samchon/openapi`, and then initializes an `Agentica` instance within a React component. The agent is then passed to the `WrtnChatApplication` component for rendering.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/articles/new-backend-development-paradigm-in-the-new-ai-era.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport { WrtnChatApplication } from \"@wrtnlabs/chat\";\nimport {\n  HttpLlm,\n  IHttpConnection,\n  IHttpLlmApplication,\n  OpenApi,\n} from \"@samchon/openapi\";\nimport OpenAI from \"openai\";\nimport { useEffect, useState } from \"react\";\n\nexport const ShoppingChatApplication = (\n  props: ShoppingChatApplication.IProps\n) => {\n  const [application, setApplication] =\n    useState<IHttpLlmApplication<\"chatgpt\"> | null>(null);\n  useEffect(() => {\n    (async () => {\n      setApplication(\n        HttpLlm.application({\n          model: \"chatgpt\",\n          document: OpenApi.convert(\n            await fetch(\"https://shopping-be.wrtn.ai/editor/swagger.json\").then(\n              (r) => r.json()\n            )\n          ),\n        })\n      );\n    })().catch(console.error);\n  }, []);\n  if (application === null)\n    return (\n      <div>\n        <h2>Loading Swagger document</h2>\n        <hr />\n        <p>Wait for a moment please.</p>\n        <p>Loading Swagger document...</p>\n      </div>\n    );\n\n  const agent: Agentica<\"chatgpt\"> = new Agentica({\n    model: \"chatgpt\",\n    vendor: {\n      api: props.api,\n      model: \"gpt-4o-mini\",\n    },\n    controllers: [\n      {\n        protocol: \"http\",\n        name: \"main\",\n        application,\n        connection: props.connection,\n      },\n    ],\n    config: {\n      locale: props.locale,\n    },\n  });\n  return <WrtnChatApplication agent={agent} />;\n};\nexport namespace ShoppingChatApplication {\n  export interface IProps {\n    api: OpenAI;\n    connection: IHttpConnection;\n    name: string;\n    mobile: string;\n    locale?: string;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Environment Variables Setup (.env)\nDESCRIPTION: This snippet shows the required environment variables for the Google Image Agent to function correctly. It includes the OpenAI API key and the SerpApi API key, which are used for authentication and service access.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-image.mdx#_snippet_2\n\nLANGUAGE: env\nCODE:\n```\nOPENAI_API_KEY=your-openai-api-key\nSERP_API_KEY=your-serp-api-key\n```\n\n----------------------------------------\n\nTITLE: Environment Variable: OpenAI API Key\nDESCRIPTION: This environment variable stores the OpenAI API key required for the Arxiv Search Agent to interact with the OpenAI GPT model. The API key should be stored securely in a `.env` file and accessed using `process.env.OPENAI_API_KEY`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/arxiv.mdx#_snippet_2\n\nLANGUAGE: env\nCODE:\n```\nOPENAI_API_KEY=your-openai-api-key\n```\n\n----------------------------------------\n\nTITLE: Typia Example (TSX)\nDESCRIPTION: This code snippet provides an example of using Typia in a React Native component. It uses `typia.random` to generate a random string and display it in a Text component.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/react-native.mdx#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\n// App.tsx\nimport React from 'react';\nimport { Text, View } from 'react-native';\nimport typia from 'typia';\n\nfunction App(): React.JSX.Element {\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>{typia.random<'Hello World'>()}</Text>\n    </View>\n  );\n}\n\nexport default App;\n```\n\n----------------------------------------\n\nTITLE: Starting Agentica with Reddit Agent\nDESCRIPTION: This command launches the Agentica Setup Wizard to create a Reddit agent project. It guides the user through installing packages, choosing package manager, selecting the Reddit controller, and entering the OpenAI API key.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/reddit.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica start reddit-agent\n```\n\n----------------------------------------\n\nTITLE: Generating Swagger documentation in Django with DRF-Spectacular\nDESCRIPTION: This code snippet demonstrates how to generate Swagger documentation in Django using the DRF-Spectacular library. It shows how to use the `@extend_schema` decorator to add documentation to viewsets and actions. It requires the `drf_spectacular` and `djangorestframework` packages. The input is an HTTP request, and the output is an HTTP response with data serialized by the specified serializer.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/articles/new-backend-development-paradigm-in-the-new-ai-era.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom drf_spectacular.utils import extend_schema, OpenApiParameter, OpenApiExample\nfrom drf_spectacular.types import OpenApiTypes\n\nclass AlbumViewset(viewset.ModelViewset):\n  serializer_class = AlbumSerializer\n\n  @extend_schema(\n      request=AlbumCreationSerializer,\n      responses={201: AlbumSerializer},\n  )\n  def create(self, request):\n      # your non-standard behavior\n      return super().create(request)\n\n  @extend_schema(\n      # extra parameters added to the schema\n      parameters=[\n          OpenApiParameter(name='artist', description='Filter by artist', required=False, pe=str),\n          OpenApiParameter(\n              name='release',\n              type=OpenApiTypes.DATE,\n              location=OpenApiParameter.QUERY,\n              description='Filter by release date',\n              examples=[\n                  OpenApiExample(\n                      'Example 1',\n                      summary='short optional summary',\n                      description='longer description',\n                      value='1993-08-23'\n                  ),\n                  ...\n              ],\n          ),\n      ],\n      # override default docstring extraction\n      description='More descriptive text',\n      # provide Authentication class that deviates from the views default\n      auth=None,\n      # change the auto-generated operation name\n      operation_id=None,\n      # or even completely override what AutoSchema would generate. Provide raw Open API spec  Dict.\n      operation=None,\n      # attach request/response examples to the operation.\n      examples=[\n          OpenApiExample(\n              'Example 1',\n              description='longer description',\n              value=...\n          ),\n          ...\n      ],\n  )\n  def list(self, request):\n      # your non-standard behavior\n      return super().list(request)\n\n  @extend_schema(\n    request=AlbumLikeSerializer,\n    responses={204: None},\n    methods=[\"POST\"]\n  )\n  @extend_schema(description='Override a specific method', methods=[\"GET\"])\n  @action(detail=True, methods=['post', 'get'])\n  def set_password(self, request, pk=None):\n    # your action behavior\n    ...\n\n```\n\n----------------------------------------\n\nTITLE: Create Shopping Cart Commodity JSON Request\nDESCRIPTION: This code snippet demonstrates the structure of the JSON request body required to create a new commodity in a shopping cart. It includes the sale ID, stock details (unit ID, stock ID, choices, and quantity), and the volume of the commodity. This request is used to add a specific item from a sale to the shopping cart.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/2.success.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"sale_id\": \"ed70c7f4-0e3b-4e58-acd3-0648e946588a\",\n    \"stocks\": [\n      {\n        \"unit_id\": \"5621003e-b0c6-4d3e-b7c5-8e0a0f82dfcc\",\n        \"stock_id\": \"a73a6f79-0b2a-4c9b-b5ab-6b72c8e256b0\",\n        \"choices\": [],\n        \"quantity\": 1\n      }\n    ],\n    \"volume\": 1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Agentica CLI Setup\nDESCRIPTION: This command launches the Agentica Setup Wizard to guide the user through setting up a Gmail Agent. It installs necessary packages, chooses a package manager, selects the GMAIL controller, and prompts for the OpenAI API key.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/gmail.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica start gmail-agent\n```\n\n----------------------------------------\n\nTITLE: Set OpenAI API Key Environment Variable\nDESCRIPTION: This line shows how to set the OpenAI API key in the `.env` file, which is necessary for the agent to authenticate with the OpenAI service.  Replace `your-openai-api-key` with your actual OpenAI API key.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/coding/swagger.mdx#_snippet_2\n\nLANGUAGE: env\nCODE:\n```\nOPENAI_API_KEY=your-openai-api-key\n```\n\n----------------------------------------\n\nTITLE: Interacting with Slack Bot via Mentions (Plaintext)\nDESCRIPTION: This plaintext example shows how to interact with the integrated Slack bot by mentioning it in a channel. The bot processes the message and responds accordingly using its Slack connector functions.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/slack.mdx#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n@your_bot_name Send a welcome message to the #general channel.\n```\n\n----------------------------------------\n\nTITLE: Starting Agentica CLI for Notion Agent (Bash)\nDESCRIPTION: This command initiates the Agentica setup wizard for creating a Notion agent. It automates the process of installing necessary packages, selecting the Notion controller, and configuring API keys.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/notion.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica start notion-agent\n```\n\n----------------------------------------\n\nTITLE: Start Agentica Google Image Agent Setup (CLI)\nDESCRIPTION: This command initiates the Agentica Setup Wizard to create a Google Image Agent.  It guides the user through package installation, project type selection, controller selection, and API key input.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-image.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica start google-image-agent\n```\n\n----------------------------------------\n\nTITLE: Installing Agentica dependencies using pnpm\nDESCRIPTION: This command installs the necessary dependencies for developing a NodeJS WebSocket server for an AI chatbot using Agentica. It installs @agentica/core, @samchon/openapi, typia, @agentica/rpc, and tgrid using pnpm. It also sets up typia.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/nodejs.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm install @agentica/core @samchon/openapi typia\npnpm install @agentica/rpc tgrid\npnpm typia setup\n```\n\n----------------------------------------\n\nTITLE: Agentica Google Docs Agent Setup\nDESCRIPTION: This command initiates the Agentica setup wizard for creating a Google Docs Agent. The wizard guides the user through package installation, project type selection, controller selection, and API key entry.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/google-docs.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica start google-docs-agent\n```\n\n----------------------------------------\n\nTITLE: Create Shopping Order Request Body (JSON)\nDESCRIPTION: This JSON payload represents the request body for creating a new shopping order. It includes an array of goods with their respective commodity IDs and volumes. The 'name' field can be used to provide a name for the order.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/core/examples/benchmarks/call/order/1.failure.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"goods\": [\n      {\n        \"commodity_id\": \"macbook-high-end-id\",\n        \"volume\": 1\n      }\n    ],\n    \"name\": null\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Agentica with yarn (Unsupported)\nDESCRIPTION: This command attempts to start the Agentica development environment using yarn as the package manager. However, yarn berry is not supported by Agentica. The `--manager` flag is used to specify the package manager.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/cli.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpx agentica start <directory> --manager yarn\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables\nDESCRIPTION: This code shows the environment variables required for the Agentica web crawler agent. It specifies the OPENAI_API_KEY and ZENROWS_API_KEY which must be set in the .env file.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/crawler.mdx#_snippet_2\n\nLANGUAGE: env\nCODE:\n```\nOPENAI_API_KEY=your-openai-api-key\nZENROWS_API_KEY=your-zenrows-api-key\n```\n\n----------------------------------------\n\nTITLE: Define Call Event Interface\nDESCRIPTION: Defines the `Call` interface within the `AgenticaEvent` namespace, representing a call event. It includes properties for the id, operation, and arguments.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaEventSnippet.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n  export interface Call<Model extends ILlmSchema.Model> \n    extends Base<\"call\"> {\n    id: string;\n    operation: AgenticaOperation<Model>;\n    arguments: Record<string, any>;\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Creating API Documentation with Swagger Annotations (PHP)\nDESCRIPTION: This snippet illustrates how to define API documentation within a PHP Laravel controller using Swagger annotations. It showcases the use of `@OA` tags to describe the API endpoint, request body, and response formats.  The example defines a `POST` endpoint `/boards` with request body parameters for title, content and files.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/articles/new-backend-development-paradigm-in-the-new-ai-era.md#_snippet_5\n\nLANGUAGE: PHP\nCODE:\n```\n<?php\nclass BbsArticleController {\n  /**\n   * @OA\\Post(\n   *   path=\"/boards\",\n   *   tags={\"BBS\"},\n   *   summary=\"Create a new article\",\n   *   description=\"Create a new article with its first snapshot\",\n   *   @OA\\RequestBody(\n   *     description=\"Article information to create\",\n   *     required=true,\n   *     @OA\\MediaType(\n   *       mediaType=\"application/json\",\n   *       @OA\\Schema(\n   *         @OA\\Property(\n   *           property=\"title\",\n   *           type=\"string\",\n   *           description=\"Title of article\",\n   *         ),\n   *         @OA\\Property(\n   *           property=\"content\",\n   *           type=\"string\",\n   *           description=\"Content body of article\"\n   *         ),\n   *         @QA\\Property(\n   *           property=\"files\",\n   *           type=\"array\",\n   *           @QA\\Items(\n   *             @QA\\Schema(\n   *               @QA\\Property(\n   *                 property=\"name\",\n   *                 type=\"string\",\n   *                 maxLength=255,\n   *                 description=\"File name, except the extension\"\n   *               ),\n   *               @QA\\Property(\n   *                 property=\"extension\",\n   *                 type=\"string\",\n   *                 nullable=true,\n   *                 maxLength=8,\n   *                 description=\"File extension. If no extension, then set null\"\n   *               ),\n   *               @QA\\Property(\n   *                 property=\"url\",\n   *                 type=\"string\",\n   *                 format=\"url\",\n   *                 description=\"URL address that the file is located in\"\n   *               )\n   *             )\n   *           )\n   *         )\n   *       )\n   *     )\n   *   ),\n   *   @OA\\Response(response=\"200\", description=\"Success\"),\n   *   @OA\\Response(response=\"400\", description=\"Fail\")\n   * )\n   */\n  public function store(Request $request);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Interface for BbsArticleService TypeScript\nDESCRIPTION: Defines a TypeScript interface `IBbsArticleService` with methods for managing articles. Includes JSDoc-style comments to describe each function's purpose, parameters, and return values. This interface can be used with `@agentica/benchmark` for contract-driven development before implementation.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/concepts/compiler-driven-development.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface IBbsArticleService {\n  /**\n   * Get all articles.\n   *\n   * List up every articles archived in the BBS DB.\n   *\n   * @returns List of every articles\n   */\n  index(): IBbsArticle[];\n\n  /**\n   * Create a new article.\n   *\n   * Writes a new article and archives it into the DB.\n   *\n   * @param props Properties of create function\n   * @returns Newly created article\n   */\n  create(props: {\n    /**\n     * Information of the article to create\n     */\n    input: IBbsArticle.ICreate;\n  }): IBbsArticle;\n\n  /**\n   * Update an article.\n   *\n   * Updates an article with new content.\n   *\n   * @param props Properties of update function\n   * @param input New content to update\n   */\n  update(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * New content to update.\n     */\n    input: IBbsArticle.IUpdate;\n  }): void;\n\n  /**\n   * Erase an article.\n   *\n   * Erases an article from the DB.\n   *\n   * @param props Properties of erase function\n   */\n  erase(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n  }): void;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Expo (CLI)\nDESCRIPTION: This command initializes Expo in the React Native project. Expo provides a toolchain that simplifies and speeds up React Native development. It's used here for polyfills and utilizing native modules.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/react-native.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-expo-app@latest\n```\n\n----------------------------------------\n\nTITLE: Retrieving Detailed Sale Information\nDESCRIPTION: This JSON snippet shows how to retrieve detailed information for a specific sale using the `shoppings_customers_sales_at` API endpoint. It specifies the 'id' parameter in the request body, which is used to identify the target sale.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/4.success.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"sales-list-id\"\n}\n```\n\n----------------------------------------\n\nTITLE: Install OpenAPI package\nDESCRIPTION: This command installs the `@samchon/openapi` package, which is required for working with OpenAPI/Swagger documents in the project.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/coding/swagger.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @samchon/openapi\n```\n\n----------------------------------------\n\nTITLE: Running the App (NPM)\nDESCRIPTION: These commands are used to start the React Native application for different platforms. It includes commands to install pod dependencies for iOS and run the app on both iOS and Android.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/setup/react-native.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start\n\n# For iOS\nnpx pod-install\nnpm run ios\n\n# For Android\nnpm run android\n```\n\n----------------------------------------\n\nTITLE: Environment Variables for Youtube Search Agent\nDESCRIPTION: These environment variables are required for the Youtube Search Agent to function correctly. They include the OpenAI API key, Serp API key, Google API key, and Search API key, all of which are necessary for accessing external APIs and services.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/tutorial/productivity/youtube-search.mdx#_snippet_2\n\nLANGUAGE: env\nCODE:\n```\nOPENAI_API_KEY=your-openai-api-key\nSERP_API_KEY=your-serp-api-key\nGOOGLE_API_KEY=your-google-api-key\nSEARCH_API_KEY=your-search-api-key\n```\n\n----------------------------------------\n\nTITLE: Agentica Project Setup using CLI\nDESCRIPTION: This snippet shows the command-line interface (CLI) command to start the Agentica setup wizard. It also depicts the interactive prompts that guide the user through configuring a new Agentica project. This includes selecting the package manager, project type, and embedded controllers.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/chat/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ npx agentica start <directory>\n\n----------------------------------------\n Agentica Setup Wizard\n----------------------------------------\n? Package Manager (use arrow keys)\n  > npm\n    pnpm\n    yarn (berry is not supported)\n? Project Type\n    NodeJS Agent Server\n  > NestJS Agent Server\n    React Client Application\n    Standalone Application\n? Embedded Controllers (multi-selectable)\n    (none)\n    Google Calendar\n    Google News\n  > Github\n    Reddit\n    Slack\n    ...\n```\n\n----------------------------------------\n\nTITLE: Testing REST API with Spring RestDocs (Kotlin)\nDESCRIPTION: This snippet demonstrates how to test a REST API endpoint using Spring RestDocs and Kotlin. It sets up a mock MVC environment, performs a GET request, validates the response status and JSON structure, and generates API documentation using `MockMvcRestDocumentationWrapper.document`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/articles/new-backend-development-paradigm-in-the-new-ai-era.md#_snippet_4\n\nLANGUAGE: Kotlin\nCODE:\n```\n@ExtendWith(RestDocumentationExtension::class, SpringExtension::class)\n@SpringBootTest\nclass SampleControllerTest {\n  private lateinit var mockMvc: MockMvc\n\n  @BeforeEach\n  internal fun setUp(context: WebApplicationContext, restDocumentation: RestDocumentationContextProvider) {\n    mockMvc = MockMvcBuilders.webAppContextSetup(context)\n      .apply<DefaultMockMvcBuilder>(MockMvcRestDocumentation.documentationConfiguration(restDocumentation))\n      .build()\n  }\n\n  @Test\n  fun getSampleByIdTest() {\n    val sampleId = \"aaa\"\n    mockMvc.perform(\n      get(\"/api/v1/samples/{sampleId}\", sampleId)\n    )\n      .andExpect(status().isOk)\n      .andExpect(jsonPath(\"sampleId\", `is`(sampleId)))\n      .andExpect(jsonPath(\"name\", `is`(\"sample-$sampleId\")))\n      .andDo(\n        MockMvcRestDocumentationWrapper.document(\n          identifier = \"sample\",\n          resourceDetails = ResourceSnippetParametersBuilder()\n            .tag(\"Sample\")\n            .description(\"Get a sample by id\")\n            .pathParameters(\n              parameterWithName(\"sampleId\")\n                .description(\"the sample id\"),\n            )\n            .responseFields(\n              fieldWithPath(\"sampleId\")\n                .type(JsonFieldType.STRING)\n                .description(\"The sample identifier.\"),\n              fieldWithPath(\"name\")\n                .type(JsonFieldType.STRING)\n                .description(\"The name of sample.\"),\n            ),\n        ),\n      )\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Execute Shoppings Customers Sales At - JSON Configuration\nDESCRIPTION: This JSON configuration provides the input parameters for the `shoppings_customers_sales_at` function. It specifies the 'id' parameter with a value of 'sales_list'. This function aims to retrieve sale details based on the provided ID.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/3.failure.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"sales_list\"\n}\n```\n\n----------------------------------------\n\nTITLE: Create Order JSON Request\nDESCRIPTION: This JSON snippet represents the structure of a request to create a new order. It includes details such as the `goods` and `name`. In this case, goods is an empty array and name is the name of the order. This request will create an order application without any specific goods selected.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/test/examples/benchmarks/call/order/4.success.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"body\": {\n    \"goods\": [],\n    \"name\": \"MacBook Order\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Client Application Dependencies Installation (pnpm)\nDESCRIPTION: This bash script installs the necessary dependencies for a client application using pnpm. It installs `@agentica/core`, `@agentica/rpc`, `tgrid`, and `@samchon/openapi`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/websocket/index.mdx#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\npnpm install @agentica/core @agentica/rpc tgrid\npnpm install @agentica/core @samchon/openapi\n```\n\n----------------------------------------\n\nTITLE: Releasing with pnpm\nDESCRIPTION: This snippet describes the release process using the pnpm package manager. The `pnpm release` command automatically increments the version number, creates a git tag, and pushes the tag to the remote repository. This triggers a GitHub Actions workflow to publish the package to the npm registry.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npnpm release\n```\n\n----------------------------------------\n\nTITLE: Introduce nestia, collection NestJS helper libraries\nDESCRIPTION: Article content about `nestia`, a set of helper libraries for NestJS. It lists key modules like `@nestia/core`, `@nestia/sdk`, `@nestia/editor`, and `@nestia/chat`, highlighting features like decorators, SDK/Swagger generation, Swagger-UI with TypeScript IDE, and AI chatbot capabilities. It mentions speed improvements using `typia` and AI chatbot creation directly from Swagger documents.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/packages/chat/src/examples/bbs/script.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n`nestia` is a set of helper libraries for NestJS.\n\n- `@nestia/core`: Super-fast decorators\n- `@nestia/sdk`: SDK/Swagger generators with native TypeScript types\n- `@nestia/editor`: Swawgger-UI with Online TypeScript IDE and SDK\n- `@nestia/chat`: Super AI chatbot by Swagger document\n\nFor reference, runtime validator is 20,000x faster than `class-validator` by utilizing the `typia` library, and make composite server performance 30x faster.\n\nAlso, you can make AI chatbot just by Swagger document, so that every backend servers can be the AI chatbot. Let's enjoy the new paradigm of the AI era.\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with pnpm\nDESCRIPTION: This snippet demonstrates how to install project dependencies using the pnpm package manager. It assumes that pnpm and nodejs are already installed. Running `pnpm install` installs the dependencies listed in the project's package.json file.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Preparing the environment with pnpm\nDESCRIPTION: This snippet shows how to execute the `pnpm prepare` command, which likely runs setup or build steps necessary for the project. This is particularly useful if `pnpm prepare` hasn't been executed previously, ensuring that the environment is ready for development or testing.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm prepare\n```\n\n----------------------------------------\n\nTITLE: Define Select Event Interface\nDESCRIPTION: Defines the `Select` interface within the `AgenticaEvent` namespace, representing a selection event. It includes a `selection` property of type `AgenticaOperationSelection<Model>`.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaEventSnippet.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n  export interface Select<Model extends ILlmSchema.Model> \n    extends Base<\"select\"> {\n    selection: AgenticaOperationSelection<Model>;\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Agentica Select Benchmark Event Types Definition\nDESCRIPTION: Defines the event types (Success, Failure, Error) for the Agentica select benchmark. Each event type extends a base event interface and includes specific properties related to the benchmark execution, such as token usage, selected operations, assistant prompts, and error information.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/benchmark.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IAgenticaSelectBenchmarkEvent<Model extends ILlmSchema.Model> =\n  | IAgenticaSelectBenchmarkEvent.ISuccess<Model>\n  | IAgenticaSelectBenchmarkEvent.IFailure<Model>\n  | IAgenticaSelectBenchmarkEvent.IError<Model>;\nexport namespace IAgenticaSelectBenchmarkEvent {\n  /**\n   * Success event type.\n   *\n   * The `success` event type represents that the benchmark testing is\n   * fully meet the expected scenario.\n   */\n  export interface ISuccess<Model extends ILlmSchema.Model>\n    extends IEventBase<\"success\", Model> {\n    /**\n     * Usage of the token during the benchmark.\n     */\n    usage: IAgenticaTokenUsage;\n\n    /**\n     * Selected operations in the benchmark.\n     */\n    selected: IAgenticaOperationSelection<Model>[];\n\n    /**\n     * Prompt messages from the assistant.\n     */\n    assistantPrompts: IAgenticaPrompt.IText<\"assistant\">[];\n  }\n\n  /**\n   * Failure event type.\n   *\n   * The `failure` event type represents that the `selector` had not\n   * selected the expected scenario in the benchmark testing.\n   */\n  export interface IFailure<Model extends ILlmSchema.Model>\n    extends IEventBase<\"failure\", Model> {\n    /**\n     * Usage of the token during the benchmark.\n     */\n    usage: IAgenticaTokenUsage;\n\n    /**\n     * Selected operations in the benchmark.\n     */\n    selected: IAgenticaOperationSelection<Model>[];\n\n    /**\n     * Prompt messages from the assistant.\n     */\n    assistantPrompts: IAgenticaPrompt.IText<\"assistant\">[];\n  }\n\n  /**\n   * Error event type.\n   * \n   * The `error` event type repsents that an error had been occurred\n   * during the benchmark testing.\n   */\n  export interface IError<Model extends ILlmSchema.Model>\n    extends IEventBase<\"error\", Model> {\n    /**\n     * Error occurred during the benchmark.\n     */\n    error: unknown;\n  }\n\n  interface IEventBase<Type extends string, Model extends ILlmSchema.Model> {\n    /**\n     * Discriminant type.\n     */\n    type: Type;\n\n    /**\n     * Expected scenario.\n     */\n    scenario: IAgenticaSelectBenchmarkScenario<Model>;\n\n    /**\n     * When the benchmark testing started.\n     */\n    started_at: Date;\n\n    /**\n     * When the benchmark testing completed.\n     */\n    completed_at: Date;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Run Connector-Hive Server\nDESCRIPTION: This command pulls the latest connector-hive image from ghcr.io and runs it in a Docker container. It sets the container name to \"connector-hive\", uses the environment variables defined in the .env file, and maps port 37001 for external access.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/docs/plugins/vector-selector.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndocker pull ghcr.io/wrtnlabs/connector-hive:latest && \\\ndocker run -d \\\n  --name connector-hive \\\n  --env-file .env \\\n  -p 37001:37001 \\\n  ghcr.io/wrtnlabs/connector-hive:latest\n```\n\n----------------------------------------\n\nTITLE: Define Describe Event Interface\nDESCRIPTION: Defines the `Describe` interface within the `AgenticaEvent` namespace, representing a description event. It includes properties for the executed history, a readable stream, and a method to join the stream.\nSOURCE: https://github.com/wrtnlabs/agentica/blob/main/website/content/snippets/AgenticaEventSnippet.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n  export interface Describe<Model extends ILlmSchema.Model> \n    extends Base<\"describe\"> {\n    executes: AgenticaHistory.Execute<Model>[];\n    stream: ReadableStream<string>;\n    join(): Promise<string>;\n  }\n\n```"
  }
]