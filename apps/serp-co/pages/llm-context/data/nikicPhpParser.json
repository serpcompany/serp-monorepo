[
  {
    "owner": "nikic",
    "repo": "php-parser",
    "content": "TITLE: Parsing PHP Code into an AST with PHP-Parser\nDESCRIPTION: This snippet demonstrates how to parse PHP code into an Abstract Syntax Tree (AST) and dump it in a human-readable format. It uses the ParserFactory to create a parser for the newest supported PHP version, attempts to parse the code, and handles any parsing errors.\nSOURCE: https://github.com/nikic/php-parser/blob/master/README.md#2025-04-18_snippet_0\n\nLANGUAGE: php\nCODE:\n```\n<?php\nuse PhpParser\\Error;\nuse PhpParser\\NodeDumper;\nuse PhpParser\\ParserFactory;\n\n$code = <<<'CODE'\n<?php\n\nfunction test($foo)\n{\n    var_dump($foo);\n}\nCODE;\n\n$parser = (new ParserFactory())->createForNewestSupportedVersion();\ntry {\n    $ast = $parser->parse($code);\n} catch (Error $error) {\n    echo \"Parse error: {$error->getMessage()}\\n\";\n    return;\n}\n\n$dumper = new NodeDumper;\necho $dumper->dump($ast) . \"\\n\";\n```\n\n----------------------------------------\n\nTITLE: Building PHP AST using Fluent Builder Interface\nDESCRIPTION: Demonstrates how to use BuilderFactory to create a complex PHP class definition with namespace, use statements, traits, methods and properties using a fluent interface. The example shows various builder methods for constructing different parts of a PHP class.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/AST_builders.markdown#2025-04-18_snippet_0\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\BuilderFactory;\nuse PhpParser\\PrettyPrinter;\nuse PhpParser\\Node;\n\n$factory = new BuilderFactory;\n$node = $factory->namespace('Name\\Space')\n    ->addStmt($factory->use('Some\\Other\\Thingy')->as('SomeClass'))\n    ->addStmt($factory->useFunction('strlen'))\n    ->addStmt($factory->useConst('PHP_VERSION'))\n    ->addStmt($factory->class('SomeOtherClass')\n        ->extend('SomeClass')\n        ->implement('A\\Few', '\\Interfaces')\n        ->makeAbstract() // ->makeFinal()\n\n        ->addStmt($factory->useTrait('FirstTrait'))\n\n        ->addStmt($factory->useTrait('SecondTrait', 'ThirdTrait')\n            ->and('AnotherTrait')\n            ->with($factory->traitUseAdaptation('foo')->as('bar'))\n            ->with($factory->traitUseAdaptation('AnotherTrait', 'baz')->as('test'))\n            ->with($factory->traitUseAdaptation('AnotherTrait', 'func')->insteadof('SecondTrait')))\n\n        ->addStmt($factory->method('someMethod')\n            ->makePublic()\n            ->makeAbstract() // ->makeFinal()\n            ->setReturnType('bool') // ->makeReturnByRef()\n            ->addParam($factory->param('someParam')->setType('SomeClass'))\n            ->setDocComment('/**\n                              * This method does something.\n                              *\n                              * @param SomeClass And takes a parameter\n                              */')\n        )\n\n        ->addStmt($factory->method('anotherMethod')\n            ->makeProtected() // ->makePublic() [default], ->makePrivate()\n            ->addParam($factory->param('someParam')->setDefault('test'))\n            // it is possible to add manually created nodes\n            ->addStmt(new Node\\Expr\\Print_(new Node\\Expr\\Variable('someParam')))\n        )\n\n        // properties will be correctly reordered above the methods\n        ->addStmt($factory->property('someProperty')->makeProtected())\n        ->addStmt($factory->property('anotherProperty')->makePrivate()->setDefault(array(1, 2, 3)))\n    )\n\n    ->getNode()\n;\n\n$stmts = array($node);\n$prettyPrinter = new PrettyPrinter\\Standard();\necho $prettyPrinter->prettyPrintFile($stmts);\n```\n\n----------------------------------------\n\nTITLE: Traversing and Modifying an AST with PHP-Parser\nDESCRIPTION: This snippet shows how to traverse and modify an AST using the NodeTraverser and a custom NodeVisitor. It creates a visitor that empties the body of all function nodes, effectively removing all function implementations while preserving their signatures.\nSOURCE: https://github.com/nikic/php-parser/blob/master/README.md#2025-04-18_snippet_1\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\Node;\nuse PhpParser\\Node\\Stmt\\Function_;\nuse PhpParser\\NodeTraverser;\nuse PhpParser\\NodeVisitorAbstract;\n\n$traverser = new NodeTraverser();\n$traverser->addVisitor(new class extends NodeVisitorAbstract {\n    public function enterNode(Node $node) {\n        if ($node instanceof Function_) {\n            // Clean out the function body\n            $node->stmts = [];\n        }\n    }\n});\n\n$ast = $traverser->traverse($ast);\necho $dumper->dump($ast) . \"\\n\";\n```\n\n----------------------------------------\n\nTITLE: Modifying and Pretty Printing PHP Code\nDESCRIPTION: A complete example demonstrating parsing PHP code, modifying the AST by changing a string value, and pretty printing the modified code back to PHP syntax.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/2_Usage_of_basic_components.markdown#2025-04-18_snippet_4\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\Error;\nuse PhpParser\\ParserFactory;\nuse PhpParser\\PrettyPrinter;\n\n$code = \"<?php echo 'Hi ', hi\\\\getTarget();\";\n\n$parser = (new ParserFactory())->createForHostVersion();\n$prettyPrinter = new PrettyPrinter\\Standard();\n\ntry {\n    // parse\n    $stmts = $parser->parse($code);\n\n    // change\n    $stmts[0]         // the echo statement\n          ->exprs     // sub expressions\n          [0]         // the first of them (the string node)\n          ->value     // it's value, i.e. 'Hi '\n          = 'Hello '; // change to 'Hello '\n\n    // pretty print\n    $code = $prettyPrinter->prettyPrint($stmts);\n\n    echo $code;\n} catch (Error $e) {\n    echo 'Parse Error: ', $e->getMessage(), \"\\n\";\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing PHP Code with Error Handling\nDESCRIPTION: A complete example of parsing PHP code using the parser instance, handling potential syntax errors with a try-catch block. The parsed result is an array of statement nodes.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/2_Usage_of_basic_components.markdown#2025-04-18_snippet_2\n\nLANGUAGE: php\nCODE:\n```\n<?php\nuse PhpParser\\Error;\nuse PhpParser\\ParserFactory;\n\n$code = <<<'CODE'\n<?php\nfunction printLine($msg) {\n    echo $msg, \"\\n\";\n}\nprintLine('Hello World!!!');\nCODE;\n\n$parser = (new ParserFactory())->createForHostVersion();\n\ntry {\n    $stmts = $parser->parse($code);\n    // $stmts is an array of statement nodes\n} catch (Error $e) {\n    echo 'Parse Error: ', $e->getMessage(), \"\\n\";\n}\n```\n\n----------------------------------------\n\nTITLE: Converting an AST Back to PHP Code with Pretty Printer\nDESCRIPTION: This snippet demonstrates how to convert a modified AST back to PHP code using the PrettyPrinter. It takes the AST (which had its function bodies emptied in the previous step) and outputs formatted PHP code that can be used in a real PHP application.\nSOURCE: https://github.com/nikic/php-parser/blob/master/README.md#2025-04-18_snippet_2\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\PrettyPrinter;\n\n$prettyPrinter = new PrettyPrinter\\Standard;\necho $prettyPrinter->prettyPrintFile($ast);\n```\n\n----------------------------------------\n\nTITLE: Basic Pretty Printing with PHP-Parser\nDESCRIPTION: Demonstrates the basic usage of the pretty printer to convert parsed PHP syntax trees back to code. This shows how to parse code, modify the syntax tree, and then print it back as PHP code.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Pretty_printing.markdown#2025-04-18_snippet_0\n\nLANGUAGE: php\nCODE:\n```\n$stmts = $parser->parse($code);\n\n// MODIFY $stmts here\n\n$prettyPrinter = new PhpParser\\PrettyPrinter\\Standard;\n$newCode = $prettyPrinter->prettyPrintFile($stmts);\n```\n\n----------------------------------------\n\nTITLE: Removing Nodes from the AST in PHP\nDESCRIPTION: Demonstrates how to remove nodes from the AST by returning NodeVisitor::REMOVE_NODE. This example removes all return statements from the code.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Walking_the_AST.markdown#2025-04-18_snippet_6\n\nLANGUAGE: php\nCODE:\n```\npublic function leaveNode(Node $node) {\n    if ($node instanceof Node\\Stmt\\Return_) {\n        // Remove all return statements\n        return NodeVisitor::REMOVE_NODE;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Recovery in PHP Parser\nDESCRIPTION: Shows how to use the ErrorHandler\\Collecting class to gather all parsing errors while continuing to parse the remaining code, instead of throwing exceptions immediately.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Error_handling.markdown#2025-04-18_snippet_1\n\nLANGUAGE: php\nCODE:\n```\n$parser = (new PhpParser\\ParserFactory())->createForHostVersion();\n$errorHandler = new PhpParser\\ErrorHandler\\Collecting;\n\n$stmts = $parser->parse($code, $errorHandler);\n\nif ($errorHandler->hasErrors()) {\n    foreach ($errorHandler->getErrors() as $error) {\n        // $error is an ordinary PhpParser\\Error\n    }\n}\n\nif (null !== $stmts) {\n    // $stmts is a best-effort partial AST\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Namespace Converter Implementation\nDESCRIPTION: Full implementation of a namespace converter that transforms namespaced code to pseudo namespaces and handles class/function/const declarations\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/2_Usage_of_basic_components.markdown#2025-04-18_snippet_10\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\Node;\nuse PhpParser\\Node\\Stmt;\nuse PhpParser\\NodeVisitor;\n\nclass NodeVisitor_NamespaceConverter extends \\PhpParser\\NodeVisitorAbstract\n{\n    public function leaveNode(Node $node) {\n        if ($node instanceof Node\\Name) {\n            return new Node\\Name(str_replace('\\\\', '_', $node->toString()));\n        } elseif ($node instanceof Stmt\\Class_\n                  || $node instanceof Stmt\\Interface_\n                  || $node instanceof Stmt\\Function_) {\n            $node->name = str_replace('\\\\', '_', $node->namespacedName->toString();\n        } elseif ($node instanceof Stmt\\Const_) {\n            foreach ($node->consts as $const) {\n                $const->name = str_replace('\\\\', '_', $const->namespacedName->toString());\n            }\n        } elseif ($node instanceof Stmt\\Namespace_) {\n            // returning an array merges is into the parent array\n            return $node->stmts;\n        } elseif ($node instanceof Stmt\\Use_) {\n            // remove use nodes altogether\n            return NodeVisitor::REMOVE_NODE;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Integer Literals to String Literals using NodeVisitor in PHP\nDESCRIPTION: Demonstrates using a NodeTraverser with a custom NodeVisitor to convert all integer literals in an AST to string literals. This example shows the basic pattern of traversing an AST and modifying nodes during traversal.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Walking_the_AST.markdown#2025-04-18_snippet_0\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\{Node, NodeTraverser, NodeVisitorAbstract};\n\n$traverser = new NodeTraverser;\n$traverser->addVisitor(new class extends NodeVisitorAbstract {\n    public function leaveNode(Node $node) {\n        if ($node instanceof Node\\Scalar\\Int_) {\n            return new Node\\Scalar\\String_((string) $node->value);\n        }\n    }\n});\n\n$stmts = ...;\n$modifiedStmts = $traverser->traverse($stmts);\n```\n\n----------------------------------------\n\nTITLE: Replacing Nodes in the AST using leaveNode() in PHP\nDESCRIPTION: Example of replacing AST nodes by returning a new node from leaveNode(). This converts all boolean AND expressions into their negated form.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Walking_the_AST.markdown#2025-04-18_snippet_4\n\nLANGUAGE: php\nCODE:\n```\npublic function leaveNode(Node $node) {\n    if ($node instanceof Node\\Expr\\BinaryOp\\BooleanAnd) {\n        // Convert all $a && $b expressions into !($a && $b)\n        return new Node\\Expr\\BooleanNot($node);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using NodeFinder for Various Node Finding Tasks in PHP\nDESCRIPTION: This code snippet demonstrates different ways to use the NodeFinder class to find specific nodes in an AST. It shows how to find all class nodes, classes that extend another class, the first class in the AST, and a class with a specific name.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Walking_the_AST.markdown#2025-04-18_snippet_14\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\{Node, NodeFinder};\n\n$nodeFinder = new NodeFinder;\n\n// Find all class nodes.\n$classes = $nodeFinder->findInstanceOf($stmts, Node\\Stmt\\Class_::class);\n\n// Find all classes that extend another class\n$extendingClasses = $nodeFinder->find($stmts, function(Node $node) {\n    return $node instanceof Node\\Stmt\\Class_\n        && $node->extends !== null;\n});\n\n// Find first class occurring in the AST. Returns null if no class exists.\n$class = $nodeFinder->findFirstInstanceOf($stmts, Node\\Stmt\\Class_::class);\n\n// Find first class that has name $name\n$class = $nodeFinder->findFirst($stmts, function(Node $node) use ($name) {\n    return $node instanceof Node\\Stmt\\Class_\n        && $node->resolvedName->toString() === $name;\n});\n```\n\n----------------------------------------\n\nTITLE: Removing Function Call Statements in PHP\nDESCRIPTION: Example of removing specific function calls that appear as expression statements. This code removes all var_dump() calls that occur as standalone statements.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Walking_the_AST.markdown#2025-04-18_snippet_7\n\nLANGUAGE: php\nCODE:\n```\npublic function leaveNode(Node $node) {\n    if ($node instanceof Node\\Stmt\\Expression\n        && $node->expr instanceof Node\\Expr\\FuncCall\n        && $node->expr->name instanceof Node\\Name\n        && $node->expr->name->toString() === 'var_dump'\n    ) {\n        return NodeVisitor::REMOVE_NODE;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting Parent Nodes in PHP AST using ParentConnectingVisitor\nDESCRIPTION: This snippet demonstrates how to use the ParentConnectingVisitor to add parent node references to an Abstract Syntax Tree (AST) in PHP. It creates a parser, parses code, and traverses the AST to connect parent nodes.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/FAQ.markdown#2025-04-18_snippet_0\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\NodeTraverser;\nuse PhpParser\\NodeVisitor\\ParentConnectingVisitor;\nuse PhpParser\\ParserFactory;\n\n$code = '...';\n\n$traverser = new NodeTraverser(new ParentConnectingVisitor);\n\n$parser = (new ParserFactory())->createForHostVersion();\n$ast    = $parser->parse($code);\n$ast    = $traverser->traverse($ast);\n```\n\n----------------------------------------\n\nTITLE: Formatting-Preserving Pretty Printing in PHP-Parser\nDESCRIPTION: Shows how to use the formatting-preserving pretty printing mode which attempts to maintain the original code formatting for unchanged parts of the syntax tree. This is useful for automated refactoring where only specific portions of code need to change.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Pretty_printing.markdown#2025-04-18_snippet_1\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\{NodeTraverser, NodeVisitor, ParserFactory, PrettyPrinter};\n\n$parser = (new ParserFactory())->createForHostVersion();\n$oldStmts = $parser->parse($code);\n$oldTokens = $parser->getTokens();\n\n// Run CloningVisitor before making changes to the AST.\n$traverser = new NodeTraverser(new NodeVisitor\\CloningVisitor());\n$newStmts = $traverser->traverse($oldStmts);\n\n// MODIFY $newStmts HERE\n\n$printer = new PrettyPrinter\\Standard();\n$newCode = $printer->printFormatPreserving($newStmts, $oldStmts, $oldTokens);\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping PHP Parser with Composer Autoloader\nDESCRIPTION: Initial setup for the PHP Parser library by including the composer autoloader and optionally configuring XDebug settings to handle deeply nested node trees.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/2_Usage_of_basic_components.markdown#2025-04-18_snippet_0\n\nLANGUAGE: php\nCODE:\n```\nrequire 'path/to/vendor/autoload.php';\n```\n\nLANGUAGE: php\nCODE:\n```\nini_set('xdebug.max_nesting_level', 3000);\n```\n\n----------------------------------------\n\nTITLE: Node Visitor Implementation for Token Analysis in PHP\nDESCRIPTION: Shows a complete example of implementing a node visitor that uses token information, including parser setup and token handling. Demonstrates how to integrate token analysis into the AST traversal process.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Lexer.markdown#2025-04-18_snippet_2\n\nLANGUAGE: php\nCODE:\n```\nclass MyNodeVisitor extends PhpParser\\NodeVisitorAbstract {\n    private $tokens;\n    public function setTokens(array $tokens) {\n        $this->tokens = $tokens;\n    }\n\n    public function leaveNode(PhpParser\\Node $node) {\n        if ($node instanceof PhpParser\\Node\\Stmt\\Property) {\n            var_dump(isDeclaredUsingVar($this->tokens, $node));\n        }\n    }\n}\n\n$parser = (new PhpParser\\ParserFactory())->createForHostVersion($lexerOptions);\n\n$visitor = new MyNodeVisitor();\n$traverser = new PhpParser\\NodeTraverser($visitor);\n\ntry {\n    $stmts = $parser->parse($code);\n    $visitor->setTokens($parser->getTokens());\n    $stmts = $traverser->traverse($stmts);\n} catch (PhpParser\\Error $e) {\n    echo 'Parse Error: ', $e->getMessage();\n}\n```\n\n----------------------------------------\n\nTITLE: Encoding PHP AST to JSON using php-parser\nDESCRIPTION: This snippet demonstrates how to parse PHP code into an Abstract Syntax Tree (AST) and encode it to JSON format using json_encode(). It creates a parser for the host PHP version, parses a simple PHP function definition, and outputs the resulting AST as pretty-printed JSON.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/JSON_representation.markdown#2025-04-18_snippet_0\n\nLANGUAGE: php\nCODE:\n```\n<?php\n\nuse PhpParser\\ParserFactory;\n\n$code = <<<'CODE'\n<?php\n\n/** @param string $msg */\nfunction printLine($msg) {\n    echo $msg, \"\\n\";\n}\nCODE;\n\n$parser = (new ParserFactory())->createForHostVersion();\n\ntry {\n    $stmts = $parser->parse($code);\n\n    echo json_encode($stmts, JSON_PRETTY_PRINT), \"\\n\";\n} catch (PhpParser\\Error $e) {\n    echo 'Parse Error: ', $e->getMessage();\n}\n```\n\n----------------------------------------\n\nTITLE: Basic PHP Parser Usage with Node Visitor\nDESCRIPTION: Demonstrates basic usage of PHP Parser with a node visitor, including parsing code, traversing AST, and pretty printing\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/2_Usage_of_basic_components.markdown#2025-04-18_snippet_6\n\nLANGUAGE: php\nCODE:\n```\n$prettyPrinter = new PrettyPrinter\\Standard;\n\n// add your visitor\n$traverser->addVisitor(new MyNodeVisitor);\n\ntry {\n    $code = file_get_contents($fileName);\n\n    // parse\n    $stmts = $parser->parse($code);\n\n    // traverse\n    $stmts = $traverser->traverse($stmts);\n\n    // pretty print\n    $code = $prettyPrinter->prettyPrintFile($stmts);\n\n    echo $code;\n} catch (PhpParser\\Error $e) {\n    echo 'Parse Error: ', $e->getMessage();\n}\n```\n\n----------------------------------------\n\nTITLE: Decoding JSON back to PHP AST using JsonDecoder\nDESCRIPTION: This snippet shows how to convert a JSON representation back into a PHP Abstract Syntax Tree (AST) using the JsonDecoder class provided by php-parser. This allows for reconstructing the AST after it has been serialized to JSON format.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/JSON_representation.markdown#2025-04-18_snippet_2\n\nLANGUAGE: php\nCODE:\n```\n<?php\n\n$jsonDecoder = new PhpParser\\JsonDecoder();\n$ast = $jsonDecoder->decode($json);\n```\n\n----------------------------------------\n\nTITLE: Handling Column Information in PHP Parser Errors\nDESCRIPTION: Demonstrates how to check for and display column information from parsing errors. Shows both detailed and simplified approaches to error message formatting with column information.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Error_handling.markdown#2025-04-18_snippet_0\n\nLANGUAGE: php\nCODE:\n```\nif ($e->hasColumnInfo()) {\n    echo $e->getRawMessage() . ' from ' . $e->getStartLine() . ':' . $e->getStartColumn($code)\n        . ' to ' . $e->getEndLine() . ':' . $e->getEndColumn($code);\n    // or:\n    echo $e->getMessageWithColumnInfo($code);\n} else {\n    echo $e->getMessage();\n}\n```\n\n----------------------------------------\n\nTITLE: NodeVisitor Interface Definition in PHP\nDESCRIPTION: The interface definition for NodeVisitor showing the four required methods: beforeTraverse(), enterNode(), leaveNode(), and afterTraverse(). These methods are called at different points during AST traversal.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Walking_the_AST.markdown#2025-04-18_snippet_2\n\nLANGUAGE: php\nCODE:\n```\ninterface NodeVisitor {\n    public function beforeTraverse(array $nodes);\n    public function enterNode(Node $node);\n    public function leaveNode(Node $node);\n    public function afterTraverse(array $nodes);\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying AST Nodes by Changing Properties in PHP\nDESCRIPTION: Example of modifying the AST by directly changing node properties. This approach increments all integer literal values in the AST.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Walking_the_AST.markdown#2025-04-18_snippet_3\n\nLANGUAGE: php\nCODE:\n```\npublic function leaveNode(Node $node) {\n    if ($node instanceof Node\\Scalar\\LNumber) {\n        // increment all integer literals\n        $node->value++;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using NameResolver in PHP\nDESCRIPTION: Sets up a NameResolver visitor and applies it to resolve names to their fully-qualified form using NodeTraverser.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Name_resolution.markdown#2025-04-18_snippet_0\n\nLANGUAGE: php\nCODE:\n```\n$nameResolver = new PhpParser\\NodeVisitor\\NameResolver;\n$nodeTraverser = new PhpParser\\NodeTraverser;\n$nodeTraverser->addVisitor($nameResolver);\n\n// Resolve names\n$stmts = $nodeTraverser->traverse($stmts);\n```\n\n----------------------------------------\n\nTITLE: Parser Usage Example with Format Preservation\nDESCRIPTION: Demonstrates the updated way to use the parser with format preservation, showing both old and new approaches for comparison.\nSOURCE: https://github.com/nikic/php-parser/blob/master/UPGRADE-5.0.md#2025-04-18_snippet_4\n\nLANGUAGE: php\nCODE:\n```\n$parser = (new ParserFactory())->createForNewestSupportedVersion();\n$oldStmts = $parser->parse($code);\n$oldTokens = $parser->getTokens();\n\n$traverser = new NodeTraverser(new NodeVisitor\\CloningVisitor());\n$newStmts = $traverser->traverse($oldStmts);\n```\n\n----------------------------------------\n\nTITLE: Setting Up Node Traversal\nDESCRIPTION: Basic setup for the NodeTraverser, which allows for traversing and visiting the node tree to perform analysis or transformations in a generic way.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/2_Usage_of_basic_components.markdown#2025-04-18_snippet_5\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\NodeTraverser;\nuse PhpParser\\ParserFactory;\nuse PhpParser\\PrettyPrinter;\n\n$parser        = (new ParserFactory())->createForHostVersion();\n$traverser     = new NodeTraverser;\n```\n\n----------------------------------------\n\nTITLE: Stopping Traversal Completely in PHP\nDESCRIPTION: Shows how to stop AST traversal completely after finding a specific node by returning NodeVisitor::STOP_TRAVERSAL. This example stops traversal after finding a class with a specific name.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Walking_the_AST.markdown#2025-04-18_snippet_11\n\nLANGUAGE: php\nCODE:\n```\nprivate $class = null;\npublic function enterNode(Node $node) {\n    if ($node instanceof Node\\Stmt\\Class_ &&\n        $node->namespacedName->toString() === 'Foo\\Bar\\Baz'\n    ) {\n        $this->class = $node;\n        return NodeVisitor::STOP_TRAVERSAL;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Traversers for Independent Visitors in PHP\nDESCRIPTION: Shows how to use separate traversers when visitors cannot be interleaved. This approach performs multiple independent traversals of the AST.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Walking_the_AST.markdown#2025-04-18_snippet_13\n\nLANGUAGE: php\nCODE:\n```\n$traverserA = new NodeTraverser;\n$traverserA->addVisitor($visitorA);\n$traverserB = new NodeTraverser;\n$traverserB->addVisitor($visitorB);\n$stmts = $traverserA->traverser($stmts);\n$stmts = $traverserB->traverser($stmts);\n```\n\n----------------------------------------\n\nTITLE: Skipping Child Node Traversal in PHP\nDESCRIPTION: Demonstrates how to skip traversal of child nodes by returning NodeVisitor::DONT_TRAVERSE_CHILDREN. This optimizes traversal when processing class declarations by avoiding unnecessary recursion.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Walking_the_AST.markdown#2025-04-18_snippet_10\n\nLANGUAGE: php\nCODE:\n```\nprivate $classes = [];\npublic function enterNode(Node $node) {\n    if ($node instanceof Node\\Stmt\\Class_) {\n        $this->classes[] = $node;\n        return NodeVisitor::DONT_TRAVERSE_CHILDREN;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Parsers with Updated ParserFactory in PHP\nDESCRIPTION: Demonstrates how to create parsers using the new methods in ParserFactory after the removal of the create() method. It shows equivalent operations for previous PREFER_PHP7 and ONLY_PHP5 options.\nSOURCE: https://github.com/nikic/php-parser/blob/master/UPGRADE-5.0.md#2025-04-18_snippet_0\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\ParserFactory;\nuse PhpParser\\PhpVersion;\n\n$factory = new ParserFactory();\n\n# Before\n$parser = $factory->create(ParserFactory::PREFER_PHP7);\n\n# After (this is roughly equivalent to PREFER_PHP7 behavior)\n$parser = $factory->createForNewestSupportedVersion();\n# Or\n$parser = $factory->createForHostVersion();\n\n# Before\n$parser = $factory->create(ParserFactory::ONLY_PHP5);\n# After (supported on a best-effort basis)\n$parser = $factory->createForVersion(PhpVersion::fromString(\"5.6\"));\n```\n\n----------------------------------------\n\nTITLE: Replacing Nodes with Null in PHP\nDESCRIPTION: Shows how to replace nodes with null using NodeVisitor::REPLACE_WITH_NULL. This example removes all else statements by replacing them with null.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Walking_the_AST.markdown#2025-04-18_snippet_8\n\nLANGUAGE: php\nCODE:\n```\npublic function leaveNode(Node $node) {\n    if ($node instanceof Node\\Stmt\\Else_) {\n        return NodeVisitor::REPLACE_WITH_NULL;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Token Class Interface Definition in PHP\nDESCRIPTION: Defines the core interface of the Token class used by the lexer, including token ID, text content, line number, and position attributes. Shows the main properties and methods available for token handling.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Lexer.markdown#2025-04-18_snippet_0\n\nLANGUAGE: php\nCODE:\n```\nclass Token {\n    /** @var int Token ID, either T_* or ord($char) for single-character tokens. */\n    public int $id;\n    /** @var string The textual content of the token. */\n    public string $text;\n    /** @var int The 1-based starting line of the token (or -1 if unknown). */\n    public int $line;\n    /** @var int The 0-based starting position of the token (or -1 if unknown). */\n    public int $pos;\n\n    /** @param int|string|(int|string)[] $kind Token ID or text (or array of them) */\n    public function is($kind): bool;\n}\n```\n\n----------------------------------------\n\nTITLE: Using ConstExprEvaluator in PHP-Parser\nDESCRIPTION: Shows basic usage of the ConstExprEvaluator class to evaluate constant expressions with error handling.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Constant_expression_evaluation.markdown#2025-04-18_snippet_1\n\nLANGUAGE: php\nCODE:\n```\n<?php\n\nuse PhpParser\\{ConstExprEvaluator, ConstExprEvaluationException};\n\n$evaluator = new ConstExprEvaluator();\ntry {\n    $value = $evaluator->evaluateSilently($someExpr);\n} catch (ConstExprEvaluationException $e) {\n    // Either the expression contains unsupported expression types,\n    // or an error occurred during evaluation\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring NameResolver Options in PHP\nDESCRIPTION: Demonstrates initialization of NameResolver with configuration options for preserving original names and controlling node replacement behavior.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Name_resolution.markdown#2025-04-18_snippet_1\n\nLANGUAGE: php\nCODE:\n```\n$nameResolver = new PhpParser\\NodeVisitor\\NameResolver(null, [\n    'preserveOriginalNames' => false,\n    'replaceNodes' => true,\n]);\n```\n\n----------------------------------------\n\nTITLE: Token Position Check Example in PHP\nDESCRIPTION: Demonstrates how to check if a property was declared using 'var' keyword by examining token positions. Shows practical usage of token position information in AST analysis.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Lexer.markdown#2025-04-18_snippet_1\n\nLANGUAGE: php\nCODE:\n```\n/** @param PhpParser\\Token[] $tokens */\nfunction isDeclaredUsingVar(array $tokens, PhpParser\\Node\\Stmt\\Property $prop) {\n    $i = $prop->getStartTokenPos();\n    return $tokens[$i]->id === T_VAR;\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing a Node with Multiple Nodes in PHP\nDESCRIPTION: Example of replacing a single node with multiple nodes by returning an array. This converts a return statement into an assignment and a return of the assigned variable.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Walking_the_AST.markdown#2025-04-18_snippet_9\n\nLANGUAGE: php\nCODE:\n```\npublic function leaveNode(Node $node) {\n    if ($node instanceof Node\\Stmt\\Return_ && $node->expr !== null) {\n        // Convert \"return foo();\" into \"$retval = foo(); return $retval;\"\n        $var = new Node\\Expr\\Variable('retval');\n        return [\n            new Node\\Stmt\\Expression(new Node\\Expr\\Assign($var, $node->expr)),\n            new Node\\Stmt\\Return_($var),\n        ];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dumping AST Nodes in Human-Readable Format\nDESCRIPTION: Using the NodeDumper to output the abstract syntax tree in a human-readable format. This is useful for understanding the structure of the parsed code.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/2_Usage_of_basic_components.markdown#2025-04-18_snippet_3\n\nLANGUAGE: php\nCODE:\n```\n<?php\nuse PhpParser\\NodeDumper;\n\n$nodeDumper = new NodeDumper;\necho $nodeDumper->dump($stmts), \"\\n\";\n```\n\n----------------------------------------\n\nTITLE: Token Class Interface in PHP Parser\nDESCRIPTION: Shows the interface of the new PhpParser\\Token class which provides compatibility with PHP 8.0's PhpToken class. Includes core properties and methods for token handling.\nSOURCE: https://github.com/nikic/php-parser/blob/master/UPGRADE-5.0.md#2025-04-18_snippet_3\n\nLANGUAGE: php\nCODE:\n```\nclass Token {\n    public int $id;\n    public string $text;\n    public int $line;\n    public int $pos;\n\n    public function is(int|string|array $kind): bool;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Visitors with a Single Traverser in PHP\nDESCRIPTION: Example of using multiple visitors with a single NodeTraverser. This approach traverses the AST only once, with the visitors being called in an interleaved pattern.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Walking_the_AST.markdown#2025-04-18_snippet_12\n\nLANGUAGE: php\nCODE:\n```\n$traverser = new NodeTraverser;\n$traverser->addVisitor($visitorA);\n$traverser->addVisitor($visitorB);\n$stmts = $traverser->traverse($stmts);\n```\n\n----------------------------------------\n\nTITLE: Namespace Conversion Base Implementation\nDESCRIPTION: Base code setup for converting namespaced code to pseudo namespaces, including parser initialization and file handling\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/2_Usage_of_basic_components.markdown#2025-04-18_snippet_9\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\ParserFactory;\nuse PhpParser\\PrettyPrinter;\nuse PhpParser\\NodeTraverser;\nuse PhpParser\\NodeVisitor\\NameResolver;\n\n$inDir  = '/some/path';\n$outDir = '/some/other/path';\n\n$parser        = (new ParserFactory())->createForNewestSupportedVersion();\n$traverser     = new NodeTraverser;\n$prettyPrinter = new PrettyPrinter\\Standard;\n\n$traverser->addVisitor(new NameResolver); // we will need resolved names\n$traverser->addVisitor(new NamespaceConverter); // our own node visitor\n\n// iterate over all .php files in the directory\n$files = new \\RecursiveIteratorIterator(new \\RecursiveDirectoryIterator($inDir));\n$files = new \\RegexIterator($files, '/\\.php$/');\n\nforeach ($files as $file) {\n    try {\n        // read the file that should be converted\n        $code = file_get_contents($file->getPathName());\n\n        // parse\n        $stmts = $parser->parse($code);\n\n        // traverse\n        $stmts = $traverser->traverse($stmts);\n\n        // pretty print\n        $code = $prettyPrinter->prettyPrintFile($stmts);\n\n        // write the converted file to the target directory\n        file_put_contents(\n            substr_replace($file->getPathname(), $outDir, 0, strlen($inDir)),\n            $code\n        );\n    } catch (PhpParser\\Error $e) {\n        echo 'Parse Error: ', $e->getMessage();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Node Visitor Implementation\nDESCRIPTION: Example of a basic node visitor that modifies string literals in the AST by changing their values to 'foo'\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/2_Usage_of_basic_components.markdown#2025-04-18_snippet_7\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\Node;\nuse PhpParser\\NodeVisitorAbstract;\n\nclass MyNodeVisitor extends NodeVisitorAbstract {\n    public function leaveNode(Node $node) {\n        if ($node instanceof Node\\Scalar\\String_) {\n            $node->value = 'foo';\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pretty Printer Method Implementation\nDESCRIPTION: Demonstrates the implementation of pretty printer methods for handling operator precedence. Shows examples for binary and unary operators with updated parameter handling.\nSOURCE: https://github.com/nikic/php-parser/blob/master/UPGRADE-5.0.md#2025-04-18_snippet_2\n\nLANGUAGE: php\nCODE:\n```\nprotected function p(\n    Node $node, int $precedence = self::MAX_PRECEDENCE, int $lhsPrecedence = self::MAX_PRECEDENCE,\n    bool $parentFormatPreserved = false\n): string;\n```\n\nLANGUAGE: php\nCODE:\n```\nprotected function pExpr_BinaryOp_Plus(\n    BinaryOp\\Plus $node, int $precedence, int $lhsPrecedence\n): string {\n    return $this->pInfixOp(\n        BinaryOp\\Plus::class, $node->left, ' + ', $node->right, $precedence, $lhsPrecedence);\n}\n\nprotected function pExpr_UnaryPlus(\n    Expr\\UnaryPlus $node, int $precedence, int $lhsPrecedence\n): string {\n    return $this->pPrefixOp(Expr\\UnaryPlus::class, '+', $node->expr, $precedence, $lhsPrecedence);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Visitors to NodeTraverser in PHP\nDESCRIPTION: Shows two equivalent ways to add multiple visitors to a NodeTraverser, either through the constructor or using the addVisitor() method.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Walking_the_AST.markdown#2025-04-18_snippet_1\n\nLANGUAGE: php\nCODE:\n```\n$traverser = new NodeTraverser($visitor1, $visitor2, $visitor3);\n\n// Equivalent to:\n$traverser = new NodeTraverser();\n$traverser->addVisitor($visitor1);\n$traverser->addVisitor($visitor2);\n$traverser->addVisitor($visitor3);\n```\n\n----------------------------------------\n\nTITLE: Error Recovery in PHP-Parser 3.0\nDESCRIPTION: Shows the new approach to error recovery in PHP-Parser 3.0 using the ErrorHandler\\Collecting class.\nSOURCE: https://github.com/nikic/php-parser/blob/master/UPGRADE-3.0.md#2025-04-18_snippet_1\n\nLANGUAGE: PHP\nCODE:\n```\n$lexer = ...;\n$parser = (new ParserFactory)->create(ParserFactor::ONLY_PHP7, $lexer);\n\n$errorHandler = new ErrorHandler\\Collecting;\n$stmts = $parser->parse($code, $errorHandler);\nif ($errorHandler->hasErrors()) {\n    handleErrors($errorHandler->getErrors());\n}\nprocessAst($stmts);\n```\n\n----------------------------------------\n\nTITLE: Generated PHP Output from AST Builder\nDESCRIPTION: Shows the resulting PHP code output after processing the AST built using the BuilderFactory. Demonstrates how the fluent builder syntax is transformed into properly formatted PHP code.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/AST_builders.markdown#2025-04-18_snippet_1\n\nLANGUAGE: php\nCODE:\n```\n<?php\n\nnamespace Name\\Space;\n\nuse Some\\Other\\Thingy as SomeClass;\nuse function strlen;\nuse const PHP_VERSION;\nabstract class SomeOtherClass extends SomeClass implements A\\Few, \\Interfaces\n{\n    use FirstTrait;\n    use SecondTrait, ThirdTrait, AnotherTrait {\n        foo as bar;\n        AnotherTrait::baz as test;\n        AnotherTrait::func insteadof SecondTrait;\n    }\n    protected $someProperty;\n    private $anotherProperty = [1, 2, 3];\n    /**\n     * This method does something.\n     *\n     * @param SomeClass And takes a parameter\n     */\n    abstract public function someMethod(SomeClass $someParam): bool;\n    protected function anotherMethod($someParam = 'test')\n    {\n        print $someParam;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Improper Node Replacement Leading to Infinite Recursion in PHP\nDESCRIPTION: An example showing how replacing nodes in enterNode() can lead to infinite recursion if not carefully implemented, as new nodes will also be traversed.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Walking_the_AST.markdown#2025-04-18_snippet_5\n\nLANGUAGE: php\nCODE:\n```\npublic function enterNode(Node $node) {\n    if ($node instanceof Node\\Expr\\BinaryOp\\BooleanAnd) {\n        // Convert all $a && $b expressions into !($a && $b)\n        return new Node\\Expr\\BooleanNot($node);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example JSON output of PHP AST for a simple function\nDESCRIPTION: This is an example of the JSON representation produced by encoding a PHP AST. It shows the detailed node structure for a simple function definition, including attributes like line numbers, comments, parameter information, and function body statements.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/JSON_representation.markdown#2025-04-18_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\n    {\n        \"nodeType\": \"Stmt_Function\",\n        \"attributes\": {\n            \"startLine\": 4,\n            \"comments\": [\n                {\n                    \"nodeType\": \"Comment_Doc\",\n                    \"text\": \"\\/** @param string $msg *\\/\",\n                    \"line\": 3,\n                    \"filePos\": 7,\n                    \"tokenPos\": 2,\n                    \"endLine\": 3,\n                    \"endFilePos\": 31,\n                    \"endTokenPos\": 2\n                }\n            ],\n            \"endLine\": 6\n        },\n        \"byRef\": false,\n        \"name\": {\n            \"nodeType\": \"Identifier\",\n            \"attributes\": {\n                \"startLine\": 4,\n                \"endLine\": 4\n            },\n            \"name\": \"printLine\"\n        },\n        \"params\": [\n            {\n                \"nodeType\": \"Param\",\n                \"attributes\": {\n                    \"startLine\": 4,\n                    \"endLine\": 4\n                },\n                \"type\": null,\n                \"byRef\": false,\n                \"variadic\": false,\n                \"var\": {\n                    \"nodeType\": \"Expr_Variable\",\n                    \"attributes\": {\n                        \"startLine\": 4,\n                        \"endLine\": 4\n                    },\n                    \"name\": \"msg\"\n                },\n                \"default\": null,\n                \"flags\": 0,\n                \"attrGroups\": []\n            }\n        ],\n        \"returnType\": null,\n        \"stmts\": [\n            {\n                \"nodeType\": \"Stmt_Echo\",\n                \"attributes\": {\n                    \"startLine\": 5,\n                    \"endLine\": 5\n                },\n                \"exprs\": [\n                    {\n                        \"nodeType\": \"Expr_Variable\",\n                        \"attributes\": {\n                            \"startLine\": 5,\n                            \"endLine\": 5\n                        },\n                        \"name\": \"msg\"\n                    },\n                    {\n                        \"nodeType\": \"Scalar_String\",\n                        \"attributes\": {\n                            \"startLine\": 5,\n                            \"endLine\": 5,\n                            \"kind\": 2,\n                            \"rawValue\": \"\\\"\\\\n\\\"\"\n                        },\n                        \"value\": \"\\n\"\n                    }\n                ]\n            }\n        ],\n        \"attrGroups\": [],\n        \"namespacedName\": null\n    }\n]\n```\n\n----------------------------------------\n\nTITLE: Initializing Parser and PrettyPrinter (New Syntax)\nDESCRIPTION: Shows the new, recommended way of initializing the Parser and PrettyPrinter classes using namespaces in PHP-Parser 1.0.\nSOURCE: https://github.com/nikic/php-parser/blob/master/UPGRADE-1.0.md#2025-04-18_snippet_1\n\nLANGUAGE: php\nCODE:\n```\n$parser = new \\PhpParser\\Parser(new PhpParser\\Lexer\\Emulative);\n$prettyPrinter = new \\PhpParser\\PrettyPrinter\\Standard;\n```\n\n----------------------------------------\n\nTITLE: AST Output Example for PHP Echo Statement\nDESCRIPTION: Shows an example of the Abstract Syntax Tree (AST) structure generated by the parser for a simple PHP echo statement with two string arguments. The output demonstrates the hierarchical representation of code as nodes with values and relationships.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/0_Introduction.markdown#2025-04-18_snippet_0\n\nLANGUAGE: php\nCODE:\n```\narray(\n    0: Stmt_Echo(\n        exprs: array(\n            0: Scalar_String(\n                value: Hi\n            )\n            1: Scalar_String(\n                value: World\n            )\n        )\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Error Handling with ConstExprEvaluator\nDESCRIPTION: Illustrates the difference between evaluateDirectly() and evaluateSilently() methods when handling division by zero errors.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Constant_expression_evaluation.markdown#2025-04-18_snippet_2\n\nLANGUAGE: php\nCODE:\n```\n<?php\n\nuse PhpParser\\{ConstExprEvaluator, ConstExprEvaluationException};\nuse PhpParser\\Node\\{Expr, Scalar};\n\n$evaluator = new ConstExprEvaluator();\n\n// 10 / 0\n$expr = new Expr\\BinaryOp\\Div(new Scalar\\Int_(10), new Scalar\\Int_(0));\n\nvar_dump($evaluator->evaluateDirectly($expr)); // float(INF)\n// Warning: Division by zero\n\ntry {\n    $evaluator->evaluateSilently($expr);\n} catch (ConstExprEvaluationException $e) {\n    var_dump($e->getPrevious()->getMessage()); // Division by zero\n}\n```\n\n----------------------------------------\n\nTITLE: NameContext Class API Definition in PHP\nDESCRIPTION: Defines the public API interface of the NameContext class used for name resolution operations, including methods for namespace handling and name resolution.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Name_resolution.markdown#2025-04-18_snippet_2\n\nLANGUAGE: php\nCODE:\n```\nclass NameContext {\n    public function __construct(ErrorHandler $errorHandler);\n    public function startNamespace(Name $namespace = null);\n    public function addAlias(Name $name, string $aliasName, int $type, array $errorAttrs = []);\n\n    public function getNamespace();\n    public function getResolvedName(Name $name, int $type);\n    public function getResolvedClassName(Name $name) : Name;\n    public function getPossibleNames(string $name, int $type) : array;\n    public function getShortName(string $name, int $type) : Name;\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Fallback Handler for ConstExprEvaluator\nDESCRIPTION: Shows how to implement a custom fallback handler for evaluating unsupported expression types.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Constant_expression_evaluation.markdown#2025-04-18_snippet_3\n\nLANGUAGE: php\nCODE:\n```\n<?php\n\nuse PhpParser\\{ConstExprEvaluator, ConstExprEvaluationException};\nuse PhpParser\\Node\\Expr;\n\n$evaluator = new ConstExprEvaluator(function(Expr $expr) {\n    if ($expr instanceof Expr\\ConstFetch) {\n        return fetchConstantSomehow($expr);\n    }\n    if ($expr instanceof Expr\\ClassConstFetch) {\n        return fetchClassConstantSomehow($expr);\n    }\n    // etc.\n    throw new ConstExprEvaluationException(\n        \"Expression of type {$expr->getType()} cannot be evaluated\");\n});\n\ntry {\n    $evaluator->evaluateSilently($someExpr);\n} catch (ConstExprEvaluationException $e) {\n    // Handle exception\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting Sibling Nodes in PHP AST using NodeConnectingVisitor\nDESCRIPTION: This snippet shows how to use the NodeConnectingVisitor to add references to previous and next sibling nodes in a PHP Abstract Syntax Tree (AST). It creates a parser, parses code, and traverses the AST to connect sibling nodes.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/FAQ.markdown#2025-04-18_snippet_1\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\NodeTraverser;\nuse PhpParser\\NodeVisitor\\NodeConnectingVisitor;\nuse PhpParser\\ParserFactory;\n\n$code = '...';\n\n$traverser = new NodeTraverser(new NodeConnectingVisitor);\n\n$parser = (new ParserFactory())->createForHostVersion();\n$ast    = $parser->parse($code);\n$ast    = $traverser->traverse($ast);\n```\n\n----------------------------------------\n\nTITLE: Recursive Constant Reference Example\nDESCRIPTION: Demonstrates a case of circular constant references that could cause infinite recursion if not handled properly.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Constant_expression_evaluation.markdown#2025-04-18_snippet_4\n\nLANGUAGE: php\nCODE:\n```\n<?php\nclass Test {\n    const A = self::B;\n    const B = self::A;\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Parser Fallback in Error Recovery Mode\nDESCRIPTION: Demonstrates how to implement multiple parser fallback in error recovery mode, maintaining the previous behavior of PHP-Parser 2.x.\nSOURCE: https://github.com/nikic/php-parser/blob/master/UPGRADE-3.0.md#2025-04-18_snippet_2\n\nLANGUAGE: PHP\nCODE:\n```\n$lexer = ...;\n$parser7 = new Parser\\Php7($lexer);\n$parser5 = new Parser\\Php5($lexer);\n\n$errors7 = new ErrorHandler\\Collecting();\n$stmts7 = $parser7->parse($code, $errors7);\nif ($errors7->hasErrors()) {\n    $errors5 = new ErrorHandler\\Collecting();\n    $stmts5 = $parser5->parse($code, $errors5);\n    if (!$errors5->hasErrors()) {\n        // If PHP 7 parse has errors but PHP 5 parse has no errors, use PHP 5 result\n        return [$stmts5, $errors5];\n    }\n}\n// If PHP 7 succeeds or both fail use PHP 7 result\nreturn [$stmts7, $errors7];\n```\n\n----------------------------------------\n\nTITLE: Accessing PHP Node Attributes\nDESCRIPTION: Code sample showing common node attribute access methods added to the Node class for better access to metadata.\nSOURCE: https://github.com/nikic/php-parser/blob/master/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: PHP\nCODE:\n```\n$node->getComments();\n$node->getStartLine();\n$node->getEndLine();\n$node->getStartTokenPos();\n$node->getEndTokenPos();\n$node->getStartFilePos();\n$node->getEndFilePos();\n```\n\n----------------------------------------\n\nTITLE: Creating PHP Parser Instances for Different PHP Versions\nDESCRIPTION: Creating parser instances targeting specific PHP versions using the ParserFactory. Allows parsing code for the host version, the newest supported version, or a specific PHP version.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/2_Usage_of_basic_components.markdown#2025-04-18_snippet_1\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\ParserFactory;\nuse PhpParser\\PhpVersion;\n\n// Parser for the version you are running on.\n$parser = (new ParserFactory())->createForHostVersion();\n\n// Parser for the newest PHP version supported by the PHP-Parser library.\n$parser = (new ParserFactory())->createForNewestSupportedVersion();\n\n// Parser for a specific PHP version.\n$parser = (new ParserFactory())->createForVersion(PhpVersion::fromString('8.1'));\n```\n\n----------------------------------------\n\nTITLE: Creating Scalar Number Node\nDESCRIPTION: Demonstrates the updated constructor for Scalar nodes which no longer has a default value, requiring explicit initialization.\nSOURCE: https://github.com/nikic/php-parser/blob/master/CHANGELOG.md#2025-04-18_snippet_11\n\nLANGUAGE: php\nCODE:\n```\nnew LNumber(0)\n```\n\n----------------------------------------\n\nTITLE: Creating Parser Instance in PHP-Parser 2.0\nDESCRIPTION: Demonstrates the new way of creating a parser instance using ParserFactory in PHP-Parser 2.0.\nSOURCE: https://github.com/nikic/php-parser/blob/master/UPGRADE-2.0.md#2025-04-18_snippet_1\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\ParserFactory;\n$parser = (new ParserFactory)->create(ParserFactory::PREFER_PHP7);\n```\n\n----------------------------------------\n\nTITLE: PHP Class Definition Without Parentheses\nDESCRIPTION: Example of dereferencing new expressions without parentheses in PHP 8.4.\nSOURCE: https://github.com/nikic/php-parser/blob/master/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: PHP\nCODE:\n```\nnew ClassName\n```\n\n----------------------------------------\n\nTITLE: Creating Parser Instance with Custom Lexer in PHP-Parser 2.0\nDESCRIPTION: Shows how to create a parser instance with a custom lexer using ParserFactory in PHP-Parser 2.0.\nSOURCE: https://github.com/nikic/php-parser/blob/master/UPGRADE-2.0.md#2025-04-18_snippet_2\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\ParserFactory;\n$lexer = new MyLexer;\n$parser = (new ParserFactory)->create(ParserFactory::PREFER_PHP7, $lexer);\n```\n\n----------------------------------------\n\nTITLE: Accessing PHP Parser Token Constants\nDESCRIPTION: Demonstrates the new location for token constants which were moved from Parser to a dedicated Tokens class.\nSOURCE: https://github.com/nikic/php-parser/blob/master/CHANGELOG.md#2025-04-18_snippet_9\n\nLANGUAGE: php\nCODE:\n```\nPhpParser\\Parser\\Tokens\n```\n\n----------------------------------------\n\nTITLE: Modifier Constants Migration in PHP Parser\nDESCRIPTION: Shows the migration of modifier constants from Class_ to the new PhpParser\\Modifiers class. These constants are used for flags in Class_, ClassMethod, Property and other nodes.\nSOURCE: https://github.com/nikic/php-parser/blob/master/UPGRADE-5.0.md#2025-04-18_snippet_1\n\nLANGUAGE: php\nCODE:\n```\nPhpParser\\Node\\Stmt\\Class_::MODIFIER_PUBLIC    -> PhpParser\\Modifiers::PUBLIC\nPhpParser\\Node\\Stmt\\Class_::MODIFIER_PROTECTED -> PhpParser\\Modifiers::PROTECTED\nPhpParser\\Node\\Stmt\\Class_::MODIFIER_PRIVATE   -> PhpParser\\Modifiers::PRIVATE\nPhpParser\\Node\\Stmt\\Class_::MODIFIER_STATIC    -> PhpParser\\Modifiers::STATIC\nPhpParser\\Node\\Stmt\\Class_::MODIFIER_ABSTRACT  -> PhpParser\\Modifiers::ABSTRACT\nPhpParser\\Node\\Stmt\\Class_::MODIFIER_FINAL     -> PhpParser\\Modifiers::FINAL\nPhpParser\\Node\\Stmt\\Class_::MODIFIER_READONLY  -> PhpParser\\Modifiers::READONLY\nPhpParser\\Node\\Stmt\\Class_::VISIBILITY_MODIFIER_MASK -> PhpParser\\Modifiers::VISIBILITY_MASK\n```\n\n----------------------------------------\n\nTITLE: Concatenating Names Using Name::concat()\nDESCRIPTION: Demonstrates the new Name::concat() method for concatenating two names, which is the preferred approach over deprecated methods.\nSOURCE: https://github.com/nikic/php-parser/blob/master/CHANGELOG.md#2025-04-18_snippet_6\n\nLANGUAGE: php\nCODE:\n```\nName::concat()\n```\n\n----------------------------------------\n\nTITLE: NodeVisitor Interface Methods\nDESCRIPTION: Declaration of the four required methods for implementing the NodeVisitor interface\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/2_Usage_of_basic_components.markdown#2025-04-18_snippet_8\n\nLANGUAGE: php\nCODE:\n```\npublic function beforeTraverse(array $nodes);\npublic function enterNode(\\PhpParser\\Node $node);\npublic function leaveNode(\\PhpParser\\Node $node);\npublic function afterTraverse(array $nodes);\n```\n\n----------------------------------------\n\nTITLE: Building PHP Parser with Debug Option\nDESCRIPTION: Command to rebuild the parsers with debug symbols enabled, which also creates a y.output file for detailed parsing information.\nSOURCE: https://github.com/nikic/php-parser/blob/master/grammar/README.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nphp grammar/rebuildParsers.php --debug\n```\n\n----------------------------------------\n\nTITLE: Basic Constant Expression Example in PHP\nDESCRIPTION: Demonstrates how constant expressions can be used in PHP class definitions for computing values at compile time.\nSOURCE: https://github.com/nikic/php-parser/blob/master/doc/component/Constant_expression_evaluation.markdown#2025-04-18_snippet_0\n\nLANGUAGE: php\nCODE:\n```\n<?php\nclass Test {\n    const SECONDS_IN_HOUR = 60 * 60;\n    const SECONDS_IN_DAY = 24 * self::SECONDS_IN_HOUR;\n}\n```\n\n----------------------------------------\n\nTITLE: Building PHP Parser with rebuildParsers.php\nDESCRIPTION: Command to rebuild the parsers using the rebuildParsers.php script. The command accepts optional environment variables and command-line arguments for customization.\nSOURCE: https://github.com/nikic/php-parser/blob/master/grammar/README.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nphp grammar/rebuildParsers.php\n```\n\n----------------------------------------\n\nTITLE: Creating Parser Instance Using ParserFactory\nDESCRIPTION: Shows the recommended way to create a parser instance using the new PhpParser\\ParserFactory class.\nSOURCE: https://github.com/nikic/php-parser/blob/master/CHANGELOG.md#2025-04-18_snippet_5\n\nLANGUAGE: php\nCODE:\n```\nPhpParser\\ParserFactory\n```\n\n----------------------------------------\n\nTITLE: Error Recovery in PHP-Parser 2.x\nDESCRIPTION: Demonstrates how error recovery was implemented in PHP-Parser 2.x using the 'throwOnError' option and 'getErrors()' method.\nSOURCE: https://github.com/nikic/php-parser/blob/master/UPGRADE-3.0.md#2025-04-18_snippet_0\n\nLANGUAGE: PHP\nCODE:\n```\n$lexer = ...;\n$parser = (new ParserFactory)->create(ParserFactor::ONLY_PHP7, $lexer, [\n    'throwOnError' => true,\n]);\n\n$stmts = $parser->parse($code);\n$errors = $parser->getErrors();\nif ($errors) {\n    handleErrors($errors);\n}\nprocessAst($stmts);\n```\n\n----------------------------------------\n\nTITLE: PHP Property Hook Example\nDESCRIPTION: Example of property hook desugaring where 'set => $value' expands to a full property assignment statement.\nSOURCE: https://github.com/nikic/php-parser/blob/master/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: PHP\nCODE:\n```\nset => $value\n// expands to:\nset { $this->propertyName = $value; }\n```\n\n----------------------------------------\n\nTITLE: Creating Parser Instance in PHP-Parser 1.x\nDESCRIPTION: Shows how to create a parser instance in the old version of PHP-Parser using direct instantiation.\nSOURCE: https://github.com/nikic/php-parser/blob/master/UPGRADE-2.0.md#2025-04-18_snippet_0\n\nLANGUAGE: php\nCODE:\n```\nuse PhpParser\\Parser, PhpParser\\Lexer;\n$parser = new Parser(new Lexer\\Emulative);\n```\n\n----------------------------------------\n\nTITLE: Custom PrettyPrinter Implementation (New Syntax)\nDESCRIPTION: Shows the updated way of implementing a custom PrettyPrinter method for the Trait statement in PHP-Parser 1.0. The explicit newline before pStmts() call is removed.\nSOURCE: https://github.com/nikic/php-parser/blob/master/UPGRADE-1.0.md#2025-04-18_snippet_3\n\nLANGUAGE: php\nCODE:\n```\npublic function pStmt_Trait(Stmt\\Trait_ $node) {\n    return 'trait ' . $node->name\n         . \"\\n\" . '{' . $this->pStmts($node->stmts) . \"\\n\" . '}';\n}\n```\n\n----------------------------------------\n\nTITLE: PHP Node Resolution Example\nDESCRIPTION: Example showing name resolution in the null-safe context with variable interpolation.\nSOURCE: https://github.com/nikic/php-parser/blob/master/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: PHP\nCODE:\n```\n\"$foo[-1]\" // Negative interpolated offset\n\"$foo[0]\"  // Integer offset\n```\n\n----------------------------------------\n\nTITLE: Custom PrettyPrinter Implementation (Old Syntax)\nDESCRIPTION: Demonstrates the old way of implementing a custom PrettyPrinter method for the Trait statement. This syntax includes an explicit newline before pStmts() call.\nSOURCE: https://github.com/nikic/php-parser/blob/master/UPGRADE-1.0.md#2025-04-18_snippet_2\n\nLANGUAGE: php\nCODE:\n```\npublic function pStmt_Trait(PHPParser_Node_Stmt_Trait $node) {\n    return 'trait ' . $node->name\n         . \"\\n\" . '{' . \"\\n\" . $this->pStmts($node->stmts) . \"\\n\" . '}';\n}\n```\n\n----------------------------------------\n\nTITLE: PHP Array Syntax Example\nDESCRIPTION: Deprecated alternative array syntax that was removed from PHP 8 parser but still supported in PHP 7 parser.\nSOURCE: https://github.com/nikic/php-parser/blob/master/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: PHP\nCODE:\n```\n$array{0}\n```\n\n----------------------------------------\n\nTITLE: Running Development Tools with Make in PHP Parser\nDESCRIPTION: Commands for running PHP-CS-Fixer and PHPStan using Make in the PHP Parser project. These tools help maintain code quality and detect potential issues.\nSOURCE: https://github.com/nikic/php-parser/blob/master/CONTRIBUTING.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmake php-cs-fixer\nmake phpstan\n```\n\n----------------------------------------\n\nTITLE: Building PHP Parser with Temporary Grammar Preservation\nDESCRIPTION: Command to rebuild the parsers while preserving the preprocessed grammar file for inspection or debugging purposes.\nSOURCE: https://github.com/nikic/php-parser/blob/master/grammar/README.md#2025-04-18_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nphp grammar/rebuildParsers.php --keep-tmp-grammar\n```\n\n----------------------------------------\n\nTITLE: Accessing PHP Parser Interface\nDESCRIPTION: Shows the interface that replaced the previous concrete class, now implemented by multiple parser versions.\nSOURCE: https://github.com/nikic/php-parser/blob/master/CHANGELOG.md#2025-04-18_snippet_8\n\nLANGUAGE: php\nCODE:\n```\nPhpParser\\Parser\n```\n\n----------------------------------------\n\nTITLE: Taking Subslice of Name with slice()\nDESCRIPTION: Shows how to use the new slice() method to take a subslice of a name, replacing deprecated methods like set(), append(), prepend(), and setFirst().\nSOURCE: https://github.com/nikic/php-parser/blob/master/CHANGELOG.md#2025-04-18_snippet_7\n\nLANGUAGE: php\nCODE:\n```\nName->slice()\n```\n\n----------------------------------------\n\nTITLE: Creating NodeTraverser with Node Cloning\nDESCRIPTION: Shows how to create a NodeTraverser with the old node cloning behavior by passing true to the constructor.\nSOURCE: https://github.com/nikic/php-parser/blob/master/CHANGELOG.md#2025-04-18_snippet_10\n\nLANGUAGE: php\nCODE:\n```\nnew NodeTraverser(true)\n```\n\n----------------------------------------\n\nTITLE: Initializing Parser and PrettyPrinter (Old Syntax)\nDESCRIPTION: Demonstrates the old way of initializing the Parser and PrettyPrinter classes using underscores. This syntax is still supported but discouraged in version 1.0.\nSOURCE: https://github.com/nikic/php-parser/blob/master/UPGRADE-1.0.md#2025-04-18_snippet_0\n\nLANGUAGE: php\nCODE:\n```\n$parser = new \\PHPParser_Parser(new \\PHPParser_Lexer_Emulative);\n$prettyPrinter = new \\PHPParser_PrettyPrinter_Default;\n```"
  }
]