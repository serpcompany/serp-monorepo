[
  {
    "owner": "pointfreeco",
    "repo": "swift-composable-architecture",
    "content": "TITLE: SwiftUI Bindings with $store Syntax - Swift\nDESCRIPTION: Shows how to create bindings directly from the store using the `$` syntax.  This is enabled by the `BindableAction` and `BindingReducer`. These bindings provide two-way communication between the view and the state, allowing the view to update the state and vice versa.  These bindings drastically simplify the view layer.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Bindings.md#_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\nTextField(\"Display name\", text: $store.displayName)\nToggle(\"Notifications\", text: $store.enableNotifications)\n// ...\n\n```\n\n----------------------------------------\n\nTITLE: Defining Feature Actions Swift\nDESCRIPTION: This code defines the actions that can occur in the Feature. These include tapping the decrement and increment buttons, tapping the number fact button, and receiving a response from the number fact API.  Each case represents a distinct user interaction or system event.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  @ObservableState\n  struct State: Equatable { /* ... */ }\n  enum Action {\n    case decrementButtonTapped\n    case incrementButtonTapped\n    case numberFactButtonTapped\n    case numberFactResponse(String)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional App Entry Point for Testing in Swift\nDESCRIPTION: Code snippet demonstrates how to conditionally omit the application's entry point when tests are running in an application target. This prevents interference from the app's runtime code during testing, resolving dependency-related test failures.  Uses `TestContext.current == nil` from the `XCTest Dynamic Overlay` library to detect test execution.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_31\n\nLANGUAGE: swift\nCODE:\n```\nimport SwiftUI\nimport ComposableArchitecture\n\n@main\nstruct MyApp: App {\n  var body: some Scene {\n    WindowGroup {\n      if TestContext.current == nil{\n        // Your real root view\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modeling Navigation with Enums in Swift\nDESCRIPTION: This code snippet shows the recommended approach of using a single enum to represent possible navigation destinations. This enforces that only one destination can be active at a time, preventing invalid states.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nenum State {\n  case addItem(AddFeature.State)\n  case detailItem(DetailFeature.State)\n  case editItem(EditFeature.State)\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: TestStore Send Action and Assert State Change\nDESCRIPTION: This snippet shows how to send an action to the `TestStore` and assert the resulting state change. The trailing closure allows defining the expected state after the action is processed by the reducer.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nawait store.send(.incrementButtonTapped) {\n  $0.count = 1\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up In-Memory Storage for UI Testing\nDESCRIPTION: This code demonstrates how to set up in-memory storage for UI testing using environment variables. It checks for the presence of the \"UITesting\" environment variable and, if found, overrides the `defaultAppStorage` and `defaultFileStorage` dependencies to use in-memory storage, preventing data persistence across UI test runs and ensuring test isolation. The UUID ensures each test gets a unique suite name.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_29\n\nLANGUAGE: swift\nCODE:\n```\n@main\nstruct EntryPoint: App {\n  let store = Store(initialState: AppFeature.State()) {\n    AppFeature()\n  } withDependencies: {\n    if ProcessInfo.processInfo.environment[\"UITesting\"] == \"true\" {\n      $0.defaultAppStorage = UserDefaults(\n        suiteName:\"\\(NSTemporaryDirectory())\\\\(UUID().uuidString)\"\n      )!\n      $0.defaultFileStorage = .inMemory\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UIKit Feature View Controller Swift\nDESCRIPTION: This code defines a UIKit view controller that displays the Feature's state and sends actions to the store. It initializes UI elements like labels and buttons, sets up constraints, and observes state changes to update the UI accordingly.  Actions are triggered by button taps, sending the corresponding action to the store.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nclass FeatureViewController: UIViewController {\n  let store: StoreOf<Feature>\n\n  init(store: StoreOf<Feature>) {\n    self.store = store\n    super.init(nibName: nil, bundle: nil)\n  }\n\n  required init?(coder: NSCoder) {\n    fatalError(\"init(coder:) has not been implemented\")\n  }\n\n  override func viewDidLoad() {\n    super.viewDidLoad()\n\n    let countLabel = UILabel()\n    let decrementButton = UIButton()\n    let incrementButton = UIButton()\n    let factLabel = UILabel()\n    \n    // Omitted: Add subviews and set up constraints...\n    \n    observe { [weak self] in\n      guard let self \n      else { return }\n      \n      countLabel.text = \"\\(self.store.text)\"\n      factLabel.text = self.store.numberFact\n    }\n  }\n\n  @objc private func incrementButtonTapped() {\n    self.store.send(.incrementButtonTapped)\n  }\n  @objc private func decrementButtonTapped() {\n    self.store.send(.decrementButtonTapped)\n  }\n  @objc private func factButtonTapped() {\n    self.store.send(.numberFactButtonTapped)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Effects with TestStore (Swift)\nDESCRIPTION: Explains how to test effects that feed data back into the store using `TestStore`. The example simulates tapping a button that triggers an effect to fetch a number fact. It shows how to use `store.receive` to assert that the expected data is received and updates the `numberFact` state.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\nawait store.send(.numberFactButtonTapped)\n\nawait store.receive(\\.numberFactResponse) {\n  $0.numberFact = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Using the @Reducer Macro\nDESCRIPTION: Demonstrates using the @Reducer macro to simplify reducer definition by automatically fulfilling protocol requirements.  It shows how to annotate a struct with @Reducer and omit the Reducer conformance.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_4\n\nLANGUAGE: Swift\nCODE:\n```\n+@Reducer\n-struct CounterFeature: Reducer {\n+struct CounterFeature {\n   @ObservableState\n   struct State {\n     var count = 0\n   }\n   enum Action {\n     case decrementButtonTapped\n     case incrementButtonTapped\n   }\n   var body: some ReducerOf<Self> {\n     Reduce { state, action in\n       switch action {\n       case .decrementButtonTapped:\n         state.count -= 1\n         return .none\n       case .incrementButtonTapped:\n         state.count += 1  \n         return .none\n       }\n     }\n   }\n }\n```\n\n----------------------------------------\n\nTITLE: Testing User Flows and Effects with TestStore in TCA (Swift)\nDESCRIPTION: This snippet illustrates how to use a `TestStore` to emulate user flows by sending actions and asserting how state changes. It also shows how to assert on effects feeding data back into the system by asserting on received actions. This capability is enabled by the data type representation of all actions in the feature.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/FAQ.md#_snippet_2\n\nLANGUAGE: Swift\nCODE:\n```\nstore.send(.refreshButtonTapped) {\n  $0.isLoading = true\n}\nstore.receive(\\ .userResponse) {\n  $0.currentUser = User(id: 42, name: \"Blob\")\n  $0.isLoading = false\n}\n```\n\n----------------------------------------\n\nTITLE: Scoping to Child Features for Optimal Performance\nDESCRIPTION: This snippet illustrates the recommended method of scoping directly to child features using stored properties for optimal performance. This avoids performance issues associated with computed properties in scopes.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Performance.md#_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\nChildView(\n  store: store.scope(state: \\.child, action: \\.child)\n)\n```\n\n----------------------------------------\n\nTITLE: CPU Intensive Work in Effect - Efficient\nDESCRIPTION: This snippet shows the recommended approach of performing CPU-intensive work within an `Effect`. This offloads the work to a cooperative thread pool, preventing the main thread from being blocked.  It also demonstrates the use of `Task.yield()` to cooperate within the thread pool. The result is then sent back to the reducer via an action.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Performance.md#_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\ncase .buttonTapped:\n  return .run { send in\n    var result = // ...\n    for (index, value) in someLargeCollection.enumerated() {\n      // Some intense computation with value\n\n      // Yield every once in awhile to cooperate in the thread pool.\n      if index.isMultiple(of: 1_000) {\n        await Task.yield()\n      }\n    }\n    await send(.computationResponse(result))\n  }\n\ncase let .computationResponse(result):\n  state.result = result\n```\n\n----------------------------------------\n\nTITLE: Initializing the Store\nDESCRIPTION: This snippet demonstrates how to construct a `Store` instance. It shows passing in the initial state and the `Feature` reducer to set up the application's entry point.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\nimport ComposableArchitecture\n\n@main\nstruct MyApp: App {\n  var body: some Scene {\n    WindowGroup {\n      FeatureView(\n        store: Store(initialState: Feature.State()) {\n          Feature()\n        }\n      )\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Feature with Reducer Macro\nDESCRIPTION: This snippet introduces the `@Reducer` macro from ComposableArchitecture, used to define the domain and behavior of a feature. This struct will encapsulate state, actions, and the logic to handle them.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nimport ComposableArchitecture\n\n@Reducer\nstruct Feature {\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting Dependency into Reducer Swift\nDESCRIPTION: This code shows how to inject a dependency (numberFact) into a reducer.  This allows for mocking the dependency during tests and using a live implementation in the application. The dependency is a closure that fetches a number fact based on an integer input.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  let numberFact: (Int) async throws -> String\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Reducer with Timer Effect in Swift\nDESCRIPTION: This code defines a Reducer named Feature with a timer that counts up to 5. The .startTimerButtonTapped action sets the count to 0 and starts an effect that sleeps for 1 second and then sends a .timerTick action. The .timerTick action increments the state's count.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  @ObservableState\n  struct State: Equatable {\n    var count = 0\n  }\n  enum Action {\n    case startTimerButtonTapped\n    case timerTick\n  }\n  var body: some Reducer<State, Action> {\n    Reduce { state, action in\n      switch action {\n      case .startTimerButtonTapped:\n        state.count = 0\n        return .run { send in\n          for _ in 1...5 {\n            try await Task.sleep(for: .seconds(1))\n            await send(.timerTick)\n          }\n        }\n\n      case .timerTick:\n        state.count += 1\n        return .none\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Finishing the Test with Mock Dependency (Swift)\nDESCRIPTION: Shows how to complete the test using the mock dependency. After sending the action, it asserts that the correct mock response is received and the state is updated as expected. This ensures the feature behaves correctly with the mocked dependency.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\nawait store.send(.numberFactButtonTapped)\n\nawait store.receive(\\.numberFactResponse) {\n  $0.numberFact = \"0 is a good number Brent\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom SharedKey\nDESCRIPTION: Shows how to define a custom `SharedKey` to implement a custom persistence strategy. This involves creating a type conforming to `SharedKey`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_6\n\nLANGUAGE: Swift\nCODE:\n```\npublic final class CustomSharedKey: SharedKey {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Exhaustive Test with Skipped Assertions Swift\nDESCRIPTION: This code snippet expands on the non-exhaustive testing example by showing how to reveal skipped assertions without causing test failures. By setting `store.exhaustivity = .off(showSkippedAssertions: true)`, the test store will display grey, informational boxes for any unasserted state changes or received actions. This allows developers to gain insight into the behavior of the system without enforcing strict assertions on every aspect of the feature.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_17\n\nLANGUAGE: swift\nCODE:\n```\nlet store = TestStore(initialState: AppFeature.State()) {\n  AppFeature()\n}\nstore.exhaustivity = .off(showSkippedAssertions: true)  // ‚¨ÖÔ∏è\n\nawait store.send(\\.\\login.submitButtonTapped)\nawait store.receive(\\.\\login.delegate.didLogin) {\n  $0.selectedTab = .activity\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Feature State\nDESCRIPTION: This snippet shows how to define the state for a feature using a struct.  The `@ObservableState` macro is applied to enable observation tools. The state includes an integer counter and an optional string for displaying a number fact.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  @ObservableState\n  struct State: Equatable {\n    var count = 0\n    var numberFact: String?\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified TestStore Construction (Swift)\nDESCRIPTION: Illustrates how to construct a `TestStore` without specifying any dependencies. You can still override any dependency needed for the purpose of the test by using `withDependencies`. This allows for focused and isolated tests.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_20\n\nLANGUAGE: swift\nCODE:\n```\nlet store = TestStore(initialState: Feature.State()) {\n  Feature()\n} withDependencies: {\n  $0.numberFact.fetch = { \"\\($0) is a good number Brent\" }\n}\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Testing Binding Actions - Swift\nDESCRIPTION: This example shows how to test binding actions using a `TestStore`.  Instead of sending specific actions, a `BindingAction` is sent that describes the key path being set and the value. This enables testing the integration between SwiftUI bindings and the reducer logic. The expected state mutation is asserted.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Bindings.md#_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\nlet store = TestStore(initialState: Settings.State()) {\n  Settings()\n}\n\nstore.send(\\.binding.displayName, \"Blob\") {\n  $0.displayName = \"Blob\"\n}\nstore.send(\\.binding.protectMyPosts, true) {\n  $0.protectMyPosts = true\n)\n\n```\n\n----------------------------------------\n\nTITLE: DependencyValues Extension (Swift)\nDESCRIPTION: This code defines an extension on `DependencyValues` to provide a computed property for a dependency, `FactClient`. If `FactClient` is not `Sendable`, a warning will be generated.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SwiftConcurrency.md#_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nextension DependencyValues {\n  var factClient: FactClient {\n    get { self[FactClient.self] }\n    set { self[FactClient.self] = newValue }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sharing State with @Shared Property Wrapper (Explicit)\nDESCRIPTION: Demonstrates how to share state between features using the `@Shared` property wrapper without persistence.  The parent feature holds a `@Shared` property for `count`, which is then passed as a reference to the child feature's state using the projected value `$count`. Any changes in the child feature will be reflected in the parent feature.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\n@Reducer\nstruct ParentFeature {\n  @ObservableState\n  struct State {\n    @Shared var count: Int\n    // Other properties\n  }\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Test Stores (ComposableArchitecture, Swift)\nDESCRIPTION: Demonstrates the preferred approach for creating TestStore instances within individual tests rather than as shared instance variables.  This allows for more precise control over the initial state and dependency overrides in each test.  It also ensures proper deinitialization and exhaustive assertions.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_33\n\nLANGUAGE: Diff\nCODE:\n```\n @MainActor\n struct FeatureTests {\n   // üëé Don't do this:\n-  let store = TestStore(initialState: Feature.State()) {\n-    Feature()\n-  }\n\n   @Test\n   func basics() async {\n     // üëç Do this:\n+    let store = TestStore(initialState: Feature.State()) {\n+      Feature()\n+    }\n     // ...\n   }\n }\n```\n\n----------------------------------------\n\nTITLE: Defining a Parent Feature Reducer with Stack Navigation in Swift\nDESCRIPTION: This snippet defines a parent feature reducer that uses StackState for managing a stack of child features. The Path reducer defines the possible states and actions for the child features in the stack. The parent reducer uses .forEach to handle actions for the child features.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  @ObservableState\n  struct State: Equatable {\n    var path = StackState<Path.State>()\n  }\n  enum Action {\n    case path(StackActionOf<Path>)\n  }\n\n  @Reducer  \n  struct Path {\n    enum State: Equatable { case counter(Counter.State) }\n    enum Action { case counter(Counter.Action) }\n    var body: some ReducerOf<Self> {\n      Scope(state: \\.counter, action: \\.counter) { Counter() }\n    }\n  }\n\n  var body: some ReducerOf<Self> {\n    Reduce { state, action in\n      // Logic and behavior for core feature.\n    }\n    .forEach(\\.path, action: \\.path) { Path() }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using case key paths instead of CasePath Swift\nDESCRIPTION: This code snippet demonstrates replacing the `/` prefix operator for deriving case paths with the simpler key path syntax in the Composable Architecture.  This requires the use of the `@Reducer` macro on the feature.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.4.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nReduce { state, action in \n  // ...\n}\n.ifLet(\\.\\child, action: /Action.child) {\n  ChildFeature()\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nReduce { state, action in \n  // ...\n}\n.ifLet(\\.\\child, action: \\.child) {\n  ChildFeature()\n}\n```\n\n----------------------------------------\n\nTITLE: Sendable FactClient Definition (Swift)\nDESCRIPTION: This code shows how to define a `Sendable` dependency, `FactClient`, by ensuring its properties and closure-based endpoints are annotated with `@Sendable`. This makes the entire `FactClient` sendable.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SwiftConcurrency.md#_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nstruct FactClient {\n  var fetch: @Sendable (Int) async throws -> String\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Feature Actions\nDESCRIPTION: This code defines an enum for the actions that can occur in the feature. These include user-initiated actions (button taps) and internal actions (API response).\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  @ObservableState\n  struct State: Equatable { /* ... */ }\n  enum Action {\n    case decrementButtonTapped\n    case incrementButtonTapped\n    case numberFactButtonTapped\n    case numberFactResponse(String)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Slider Action Frequency with onEditingChanged\nDESCRIPTION: This snippet shows how to use the `onEditingChanged` closure of a `Slider` to send an action only when the user finishes interacting with the slider, instead of sending actions for every minor change. This reduces action frequency and improves performance.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Performance.md#_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nSlider(value: self.$opacity, in: 0...1) {\n  self.store.send(.setOpacity(self.opacity))\n}\n```\n\n----------------------------------------\n\nTITLE: Reducer with BindingReducer - Swift\nDESCRIPTION: Simplifies the reducer's body by including a `BindingReducer`. This reducer automatically handles the `binding` action, updating the state based on the key path and value provided in the `BindingAction`. This significantly reduces boilerplate compared to manually handling each binding action.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Bindings.md#_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Settings {\n  @ObservableState\n  struct State { /* ... */ }\n  enum Action: BindableAction { /* ... */ }\n\n  var body: some Reducer<State, Action> {\n    BindingReducer()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Reducer with Immutable State Capture in Effect (Swift)\nDESCRIPTION: This code shows the correct way to access state within an `Effect` by capturing it as an immutable value using a capture list. This resolves the concurrency error and allows safe access to the state.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SwiftConcurrency.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nreturn .run { [state] send in\n  try await Task.sleep(for: .seconds(1))\n  await send(.delayed(state.count))  // ‚úÖ\n}\n```\n\n----------------------------------------\n\nTITLE: Settings State with ObservableState - Swift\nDESCRIPTION: Defines the state for a settings feature with multiple editable fields, utilizing the `@ObservableState` macro. This state is designed to be used with SwiftUI bindings. Each field represents a different setting that can be configured by the user.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Bindings.md#_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Settings {\n  @ObservableState\n  struct State {\n    var digest = Digest.daily\n    var displayName = \"\"\n    var enableNotifications = false\n    var isLoading = false\n    var protectMyPosts = false\n    var sendEmailNotifications = false\n    var sendMobileNotifications = false\n  }\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Store Scoping with Key Paths and Case Key Paths (New API)\nDESCRIPTION: This code snippet presents the new and preferred way of scoping a store using key paths for state and case key paths for actions. It demonstrates how to scope to a child state and action using the simplified syntax provided by the `Reducer()` macro.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.5.md#_snippet_2\n\nLANGUAGE: Swift\nCODE:\n```\n// ‚úÖ New API\nChildView(\n  store: store.scope(\n    state: \\.child,\n    action: \\.child\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Tree-Based Navigation Using Presents Macro in InventoryFeature\nDESCRIPTION: This code snippet defines a feature using the `@Reducer` macro, including a state struct annotated with `@ObservableState` and the `@Presents` macro, illustrating tree-based navigation to a detail screen.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/WhatIsNavigation.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct InventoryFeature {\n  @ObservableState\n  struct State {\n    @Presents var detailItem: DetailItemFeature.State?\n    // ...\n  }\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Dependency Client Swift\nDESCRIPTION: This snippet defines a struct to encapsulate the number fact functionality. This allows for easier dependency management and testing by providing a clear interface for the dependency.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\nstruct NumberFactClient {\n  var fetch: (Int) async throws -> String\n}\n```\n\n----------------------------------------\n\nTITLE: Sharing State with @Shared Property Wrapper (File Storage)\nDESCRIPTION: Illustrates persisting shared state using the `@Shared` property wrapper with `fileStorage`. This strategy serializes the value to JSON and saves it to the file system. Requires a URL for the file path and a default value. The value must conform to `Codable`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_5\n\nLANGUAGE: Swift\nCODE:\n```\n@Shared(.fileStorage(URL(/* ... */)) var users: [User] = []\n```\n\n----------------------------------------\n\nTITLE: Settings View with Bindable Store - Swift\nDESCRIPTION: Declares a `SettingsView` struct that conforms to the `View` protocol. It utilizes the `@Bindable` property wrapper to hold a `StoreOf<Settings>`, enabling SwiftUI bindings to interact with the Composable Architecture store.  This allows for two-way data flow between the view and the store.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Bindings.md#_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nstruct SettingsView: View {\n  @Bindable var store: StoreOf<Settings>\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Reducer Logic\nDESCRIPTION: This snippet implements the `body` property, defining the reducer's logic.  It uses a `Reduce` block with a switch statement to handle different actions, updating the state accordingly.  The `numberFactButtonTapped` action triggers an asynchronous API request using `URLSession` and `Effect.run`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  @ObservableState\n  struct State: Equatable { /* ... */ }\n  enum Action { /* ... */ }\n\n  var body: some Reducer<State, Action> {\n    Reduce { state, action in\n      switch action {\n      case .decrementButtonTapped:\n        state.count -= 1\n        return .none\n\n      case .incrementButtonTapped:\n        state.count += 1\n        return .none\n\n      case .numberFactButtonTapped:\n        return .run { [count = state.count] send in\n          let (data, _) = try await URLSession.shared.data(\n            from: URL(string: \"http://numbersapi.com/\\(count)/trivia\")!\n          )\n          await send(\n            .numberFactResponse(String(decoding: data, as: UTF8.self))\n          )\n        }\n\n      case let .numberFactResponse(fact):\n        state.numberFact = fact\n        return .none\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Dependency to Reducer (Swift)\nDESCRIPTION: Demonstrates how to add a dependency (numberFact) to the `Feature` reducer.  This allows for mocking the dependency during testing, ensuring predictable behavior. The dependency is a function that takes an integer and returns a string.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  let numberFact: (Int) async throws -> String\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Empty Reducer Definition using @Reducer Macro\nDESCRIPTION: Demonstrates the simplest possible reducer definition using the @Reducer macro.  The macro automatically provides default implementations for the State, Action, and body requirements of the Reducer protocol.  This allows for incremental implementation of reducer logic.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.8.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n}\n```\n\n----------------------------------------\n\nTITLE: Reducing High-Frequency Actions with Interval-Based Updates\nDESCRIPTION: This snippet demonstrates how to reduce the frequency of actions sent during a long-running effect by only sending progress updates at specific intervals. This avoids overwhelming the system with unnecessary updates.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Performance.md#_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\ncase .startButtonTapped:\n  return .run { send in\n    var count = 0\n    let max = await self.eventsClient.count()\n    let interval = max / 100\n\n    for await event in self.eventsClient.events() {\n      defer { count += 1 }\n      if count.isMultiple(of: interval) {\n        await send(.progress(Double(count) / Double(max)))\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Sharing State with @Shared Property Wrapper (Child)\nDESCRIPTION: Demonstrates how to share state between features using the `@Shared` property wrapper without persistence. The child feature uses `@Shared` to also reference the shared `count` integer.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\n@Reducer\nstruct ChildFeature {\n  @ObservableState\n  struct State {\n    @Shared var count: Int\n    // Other properties\n  }\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Destination with Parent Feature in Swift\nDESCRIPTION: This code demonstrates how to integrate the destination enum with the parent feature's state and actions using `@Presents` and `PresentationAction`. It uses the `ifLet` operator to connect the parent and child domains.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct InventoryFeature {\n  @ObservableState\n  struct State { \n    @Presents var destination: Destination.State?\n    // ...\n  }\n  enum Action {\n    case destination(PresentationAction<Destination.Action>)\n    // ...\n  }\n\n  // ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct InventoryFeature {\n  // ...\n\n  var body: some ReducerOf<Self> {\n    Reduce { state, action in \n      // ...\n    }\n    .ifLet(\\.\\$destination, action: \\.destination) \n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Store with @StateObject in SwiftUI - Swift\nDESCRIPTION: This code demonstrates how to initialize a Store using SwiftUI's `@StateObject` property wrapper, ensuring that the Store is only initialized once when the parent view is first computed. This avoids unnecessary Store initializations when the parent view is recomputed. The example includes a FeatureView struct with a StoreOf<Feature> and initialization using StateObject.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.19.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\nstruct FeatureView: View {\n  @StateObject var store: StoreOf<Feature>\n\n  init() {\n    _store = StateObject(\n      // This expression is only evaluated the first time the parent view is computed.\n      wrappedValue: Store(initialState: Feature.State()) {\n        Feature()\n      }\n    )\n  }\n\n  var body: some View { /* ... */ }\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Exhaustive Testing with TestStore\nDESCRIPTION: This snippet shows how to use non-exhaustive testing with `TestStore` to assert only on the parts of the features that are important for the test. By setting `store.exhaustivity = .off`, you can focus on high-level behavior without asserting on every state change.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_21\n\nLANGUAGE: swift\nCODE:\n```\n@Test\nfunc dismissal() {\n  let store = TestStore(\n    initialState: Feature.State(\n      counter: CounterFeature.State(count: 3)\n    )\n  ) {\n    CounterFeature()\n  }\n  store.exhaustivity = .off\n\n  await store.send(\\.counter.incrementButtonTapped)\n  await store.send(\\.counter.incrementButtonTapped)\n  await store.receive(\\.counter.dismiss) \n}\n```\n\n----------------------------------------\n\nTITLE: Mutating Shared State with Lock in Swift\nDESCRIPTION: This code shows how to mutate shared state in an isolated fashion to prevent race conditions using the `withLock` method. It atomically increments the `count` value.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_18\n\nLANGUAGE: swift\nCODE:\n```\nstate.$count.withLock { $0 += 1 }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stack-Based Navigation in UIKit with TCA\nDESCRIPTION: This snippet demonstrates how to implement stack-based navigation in a UIKit app using TCA and the `NavigationStackController`. It subclasses `NavigationStackController` to drive navigation from the `path` (StackState) of the app's feature. Requires the use of `@UIBindable` to bind the store to the view controller.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.13.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nclass AppController: NavigationStackController {\n  private var store: StoreOf<AppFeature>!\n\n  convenience init(store: StoreOf<AppFeature>) {\n    @UIBindable var store = store\n\n    self.init(path: $store.scope(state: \\.path, action: \\.path)) {\n      RootViewController(store: store)\n    } destination: { store in \n      switch store.case {\n      case .addItem(let store):\n        AddViewController(store: store)\n      case .detailItem(let store):\n        DetailViewController(store: store)\n      case .editItem(let store):\n        EditViewController(store: store)\n      }\n    }\n\n    self.store = store\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Action to TestStore in Swift\nDESCRIPTION: This sends the `.startTimerButtonTapped` action to the TestStore. This is done to trigger the timer effect defined in the Feature reducer, allowing the test to observe and assert on the resulting actions and state changes.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\nawait store.send(.startTimerButtonTapped)\n```\n\n----------------------------------------\n\nTITLE: Action Definition for State Mutation - Swift\nDESCRIPTION: Defines an action within the Settings reducer to handle changes to the `isHapticsEnabled` state. This action enables external components to trigger state updates, for instance, in response to a toggle interaction. The action receives a boolean value representing the new state of haptics.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Bindings.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Settings {\n  struct State: Equatable { /* ... */ }\n\n  enum Action {\n    case isHapticsEnabledChanged(Bool)\n    // ...\n  }\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying StackState using subscript(id:case:) in Swift\nDESCRIPTION: This snippet demonstrates modifying the state of a child feature using StackState's subscript(id:case:) method.  It provides a concise way to both access the correct element by ID and extract the specific case of the Path enum for direct manipulation of the contained state (counter's count in this instance).\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nawait store.send(\\.path[id: 0].counter.incrementButtonTapped) {\n  $0.path[id: 0, case: \\.counter]?.count = 4\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Shared State Mutation Directly in Reducer\nDESCRIPTION: This test demonstrates how to verify the mutation of shared state directly within the reducer. It uses `TestStore` to send the `incrementButtonTapped` action and asserts that the `count` property is updated to 1 within the provided closure. The `$0.$count.withLock { $0 = 1 }` inside the trailing closure asserts the final value of the shared count.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_21\n\nLANGUAGE: swift\nCODE:\n```\n@Test\nfunc increment() async {\n  let store = TestStore(initialState: Feature.State(count: Shared(0))) {\n    Feature()\n  }\n\n  await store.send(.incrementButtonTapped) {\n    $0.$count.withLock { $0 = 1 }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining features using @Shared for shared state in Swift\nDESCRIPTION: This snippet shows two features, Feature1 and Feature2, that both use the @Shared property wrapper to share a count value persisted in AppStorage. This allows both features to keep their count values synchronized. The count is initialized to 0.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_30\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature1 {\n  struct State {\n    @Shared(.appStorage(\"count\")) var count = 0\n  }\n  // ...\n}\n\n@Reducer\nstruct Feature2 {\n  struct State {\n    @Shared(.appStorage(\"count\")) var count = 0\n  }\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Timer Feature with Effects\nDESCRIPTION: Implements a counter feature with a timer that increments the count every second.  It utilizes effects to manage the asynchronous timer and demonstrates the use of cancellable effects.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_3\n\nLANGUAGE: Swift\nCODE:\n```\nstruct CounterFeature: Reducer {\n  @ObservableState\n  struct State {\n    var count = 0\n  }\n  enum Action {\n    case decrementButtonTapped\n    case incrementButtonTapped\n    case startTimerButtonTapped\n    case stopTimerButtonTapped\n    case timerTick\n  }\n  enum CancelID { case timer }\n\n  var body: some ReducerOf<Self> {\n    Reduce { state, action in\n      switch action {\n      case .decrementButtonTapped:\n        state.count -= 1\n        return .none\n\n      case .incrementButtonTapped:\n        state.count += 1\n        return .none\n\n      case .startTimerButtonTapped:\n        return .run { send in\n          while true {\n            try await Task.sleep(for: .seconds(1))\n            await send(.timerTick)\n          }\n        }\n        .cancellable(CancelID.timer)\n\n      case .stopTimerButtonTapped:\n        return .cancel(CancelID.timer)\n\n      case .timerTick:\n        state.count += 1\n        return .none\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sharing State with @Shared Property Wrapper (In-Memory)\nDESCRIPTION: Illustrates how to share state across the application using the `@Shared` property wrapper with in-memory persistence.  The `inMemory` persistence strategy keeps the data in memory, available to the whole application, but resets it on relaunch. A default value must be provided.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_3\n\nLANGUAGE: Swift\nCODE:\n```\n@Reducer\nstruct ChildFeature {\n  @ObservableState\n  struct State {\n    @Shared(.inMemory(\"count\")) var count = 0\n    // Other properties\n  }\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Test Failure on Incorrect Shared State Mutation\nDESCRIPTION: This test shows how `TestStore` detects incorrect mutations of shared state. The test intentionally sets the shared count to 2 instead of 1 after the `incrementButtonTapped` action. This mismatch causes the test to fail, highlighting the importance of accurate assertions on shared state changes. The trailing closure should reflect the correct resultant state after the reducer logic is executed.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_22\n\nLANGUAGE: swift\nCODE:\n```\n@Test\nfunc increment() async {\n  let store = TestStore(initialState: Feature.State(count: Shared(0))) {\n    Feature()\n  }\n\n  await store.send(.incrementButtonTapped) {\n    $0.$count.withLock { $0 = 2 }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using @ObservableState (iOS 17 and Above)\nDESCRIPTION: Demonstrates an even simpler view body update for iOS 17 and above, removing the need for WithViewStore or WithPerceptionTracking entirely. This approach allows direct access to state and actions within the view body.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n var body: some View {\n-  WithViewStore(store, observe: ViewState.init) { viewStore in\n     Form {\n-      Text(viewStore.count.description)\n-      Button(\"+\") { viewStore.send(.incrementButtonTapped) }\n+      Text(store.count.description)\n+      Button(\"+\") { store.send(.incrementButtonTapped) }\n     }\n-  }\n }\n```\n\n----------------------------------------\n\nTITLE: Sharing State with @Shared Property Wrapper (User Defaults)\nDESCRIPTION: Demonstrates how to persist shared state using the `@Shared` property wrapper with the `appStorage` persistence strategy. This approach automatically saves changes to User Defaults and loads them on application launch. A key and default value are required.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_4\n\nLANGUAGE: Swift\nCODE:\n```\n@Shared(.appStorage(\"count\")) var count = 0\n```\n\n----------------------------------------\n\nTITLE: Simplified Destination Reducer with @Reducer Macro\nDESCRIPTION: Demonstrates how the @Reducer macro can be applied to an enum to automatically generate the State, Action, and body requirements for a destination reducer.  Each case in the enum holds a reducer for the corresponding feature, significantly reducing boilerplate.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.8.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nenum Destination {\n  case add(FormFeature)\n  case detail(DetailFeature)\n  case edit(EditFeature)\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Shared State in Tests\nDESCRIPTION: This demonstrates how to set an initial value for `@Shared` state in a test. By declaring the shared state within the test scope, you can specify a default value that will be used for all features using it. This is useful for controlling the initial state of shared dependencies during testing.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_27\n\nLANGUAGE: swift\nCODE:\n```\n@Test\nfunc basics() {\n  @Shared(.appStorage(\"count\")) var count = 42\n\n  // Shared state will be 42 for all features using it.\n  let store = TestStore(‚Ä¶)\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Assertion of Shared State Mutation\nDESCRIPTION: Shows the correct way to assert against shared state mutations in the Composable Architecture's test store. The assertion must be performed in the `send` block for the initial action (`tap` in this case) that triggers the effect leading to the mutation. This works because the `TestStore` processes actions eagerly.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_50\n\nLANGUAGE: swift\nCODE:\n```\nawait store.send(.tap) {  // ‚úÖ\n  $0.$shared.withLock { $0 = true }\n}\n\n// ‚ùå Expected state to change, but no change occurred.\nawait store.receive(.response)  // ‚úÖ\n```\n\n----------------------------------------\n\nTITLE: Reducer with Minimal State Capture in Effect (Swift)\nDESCRIPTION: This code demonstrates capturing only the necessary parts of the state for the effect using a new variable name in the capture list. This is a more refined approach to immutably accessing state within an effect.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SwiftConcurrency.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nreturn .run { [count = state.count] send in\n  try await Task.sleep(for: .seconds(1))\n  await send(.delayed(count))  // ‚úÖ\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing @BindingState with ObservableState Swift\nDESCRIPTION: This snippet details the transition from using `@BindingState` to `@ObservableState` for bindings in TCA. All instances of `<doc:BindingState>` are removed and the feature's state is annotated with `@ObservableState`. The `BindableAction` conformance and `BindingReducer` are still needed. The store is held in a bindable manner using `@Bindable` or `@Perception.Bindable`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  struct State {\n    @BindingState var text = \"\"\n    @BindingState var isOn = false\n  }\n  enum Action: BindableAction {\n    case binding(BindingAction<State>)\n  }\n  var body: some ReducerOf<Self> { /* ... */ }\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nWithViewStore(store, observe: { $0 }) { viewStore in\n  Form {\n    TextField(\"Text\", text: viewStore.$text)\n    Toggle(isOn: viewStore.$isOn)\n  }\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nstruct ViewState: Equatable {\n  @BindingViewState var text: String\n  @BindingViewState var isOn: Bool\n  init(store: BindingViewStore<Feature.State>) {\n    self._text = store.$text\n    self._isOn = store.$isOn\n  }\n}\n\nvar body: some View {\n  WithViewStore(store, observe: ViewState.init) { viewStore in\n    Form {\n      TextField(\"Text\", text: viewStore.$text)\n      Toggle(isOn: viewStore.$isOn)\n    }\n  }\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n+@ObservableState\n struct State {\n-  @BindingState var text = \"\"\n-  @BindingState var isOn = false\n+  var text = \"\"\n+  var isOn = false\n }\n```\n\nLANGUAGE: swift\nCODE:\n```\n@Bindable var store: StoreOf<Feature>\n```\n\nLANGUAGE: swift\nCODE:\n```\n@Perception.Bindable var store: StoreOf<Feature>\n```\n\nLANGUAGE: swift\nCODE:\n```\nvar body: some View {\n  Form {\n    TextField(\"Text\", text: $store.text)\n    Toggle(isOn: $store.isOn)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing ForEachStore with ForEach\nDESCRIPTION: Shows how to replace ForEachStore with the standard SwiftUI ForEach view. This requires using Store/scope(state:action:)-90255 and providing an identifier for each element. If the state's id is not associated with a selection binding, the `id` parameter is not required.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nForEach(\n  store.scope(state: \\.rows, action: \\.rows),\n  id: \\.state.id\n) { childStore in\n  ChildView(store: childStore)\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n ForEach(\n-  store.scope(state: \\.rows, action: \\.rows),\n-  id: \\.state.id,\n+  store.scope(state: \\.rows, action: \\.rows)\n ) { childStore in\n   ChildView(store: childStore)\n }\n```\n\nLANGUAGE: swift\nCODE:\n```\nForEach(\n  Array(store.scope(state: \\.rows, action: \\.rows).enumerated()),\n  id: \\.element\n) { position, childStore in\n  ChildView(store: childStore)\n    .background {\n      position.isMultiple(of: 2) ? Color.white : Color.gray\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Dependency in Reduce Implementation (Swift)\nDESCRIPTION: Shows how to use the injected `numberFact` dependency within the `reduce` function. The example invokes the `numberFact` dependency with the current count and then sends an action to update the state with the received fact.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\ncase .numberFactButtonTapped:\n  return .run { [count = state.count] send in \n    let fact = try await self.numberFact(count)\n    await send(.numberFactResponse(fact))\n  }\n```\n\n----------------------------------------\n\nTITLE: Enabling InferSendableFromCaptures Feature in SPM\nDESCRIPTION: This snippet shows how to enable the `InferSendableFromCaptures` Swift feature in an SPM package. This feature automatically infers sendability for closures, which can resolve the concurrency issues related to enum cases as function references. The `swiftSettings` array is part of the package manifest.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.15.md#_snippet_2\n\nLANGUAGE: Swift\nCODE:\n```\nswiftSettings: [\n  .enableUpcomingFeature(\"InferSendableFromCaptures\"),\n]),\n```\n\n----------------------------------------\n\nTITLE: Action with BindableAction - Swift\nDESCRIPTION: Simplifies the action enum by using `BindableAction`.  Instead of defining a case for each state property, a single `binding` case is introduced that holds a `BindingAction` generic over the reducer's state. This approach drastically reduces boilerplate code.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Bindings.md#_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Settings {\n  @ObservableState\n  struct State { /* ... */ }\n\n  enum Action: BindableAction {\n    case binding(BindingAction<State>)\n  }\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Counter Feature Logic\nDESCRIPTION: Implements the logic for a simple counter feature by using a Reduce block inside the Reducer's body. The state is mutated based on the incoming action, and .none is returned to indicate no effects are needed.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_2\n\nLANGUAGE: Swift\nCODE:\n```\nstruct CounterFeature: Reducer {\n  // ...\n  var body: some ReducerOf<Self> {\n    Reduce { state, action in\n      switch action {\n      case .decrementButtonTapped:\n        state.count -= 1\n        return .none\n      case .incrementButtonTapped:\n        state.count += 1  \n        return .none\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Receiving Action from TestStore with Timeout in Swift\nDESCRIPTION: This demonstrates using `store.receive` to assert that a `.timerTick` action is received after sending the `.startTimerButtonTapped` action.  A timeout is specified to allow time for the timer effect to execute.  The closure asserts that the state's count is incremented to 1.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\nawait store.receive(\\.timerTick, timeout: .seconds(2)) {\n  $0.count = 1\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Destination Reducer in Swift\nDESCRIPTION: This code defines a nested enum within a reducer, representing different destination features. The `@Reducer` macro handles the composition and reducer implementation for each case.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct InventoryFeature {\n  // ...\n\n  @Reducer\n  enum Destination {\n    case addItem(AddFeature)\n    case detailItem(DetailFeature)\n    case editItem(EditFeature)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: NavigationStack Destination Closure (Simplified)\nDESCRIPTION: Demonstrates the simplified approach to constructing the destination closure for a NavigationStack when using the enhanced @Reducer macro. The `store.case` property allows for direct extraction of the store for each case, eliminating the need for separate destructuring and scoping.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.8.md#_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\nNavigationStack(path: $store.scope(state: \\.path, action: \\.path)) {\n  // Root view\n} destination: { store in\n  switch store.case {\n  case let .detail(store):\n    DetailView(store: store)\n  case let .meeting(store):\n    MeetingView(store: store)\n  case let .record(store):\n    RecordView(store: store)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Tree-Based Navigation State Definition (Swift)\nDESCRIPTION: Demonstrates how to define state for tree-based navigation using the Composable Architecture. The `editItem` property, annotated with `@Presents`, represents an optional state for an edit feature, illustrating the hierarchical relationship between the detail and edit screens. This enforces that the edit screen can only be navigated to from the detail screen.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/WhatIsNavigation.md#_snippet_6\n\nLANGUAGE: Swift\nCODE:\n```\n@ObservableState\nstruct State {\n  @Presents var editItem: EditItemFeature.State?\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Observing Changes with WithPerceptionTracking\nDESCRIPTION: This snippet shows how to observe changes to a perceptible model within a SwiftUI view using `WithPerceptionTracking`. The `WithPerceptionTracking` view ensures that the view re-renders when the `count` property of the `CounterModel` changes.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/ObservationBackport.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nstruct CounterView: View {\n  let model = CounterModel()\n\n  var body: some View {\n    WithPerceptionTracking {\n      Form {\n        Text(self.model.count.description)\n        Button(\"Decrement\") { self.model.count -= 1 }\n        Button(\"Increment\") { self.model.count += 1 }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing sheet(store:) with sheet(item:) SwiftUI\nDESCRIPTION: This snippet demonstrates how to replace the TCA's `sheet(store:)` view modifier with SwiftUI's native `sheet(item:)` modifier. It requires holding the store in a bindable manner, using the `@Bindable` property wrapper. The state key path is updated to use `\\.child` instead of `\\.$child`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\n.sheet(store: store.scope(state: \\.$child, action: \\.child)) { store in\n  ChildView(store: store)\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n@Bindable var store: StoreOf<Feature>\n```\n\nLANGUAGE: swift\nCODE:\n```\n@Perception.Bindable var store: StoreOf<Feature>\n```\n\nLANGUAGE: swift\nCODE:\n```\n.sheet(item: $store.scope(state: \\.child, action: \\.child)) { store in\n  ChildView(store: store)\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Against Payload of a Received Action\nDESCRIPTION: This snippet shows how to assert against the payload of a received action using the syntax introduced in version 1.6 of the library. It allows verifying the data associated with an action.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.9.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nstore.receive(\\.\\child.presented.success, \"Hello\")\n```\n\n----------------------------------------\n\nTITLE: AppState Codable implementation with @Shared in Swift\nDESCRIPTION: This snippet shows an example of `AppState` conforming to `Codable` while containing a `@Shared` property. It provides custom `encode(to:)` and `init(from:)` implementations to handle the shared state. It shows initializing the shared state manually.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_47\n\nLANGUAGE: swift\nCODE:\n```\nstruct AppState {\n  @Shared(.appStorage(\"launchCount\")) var launchCount = 0\n  var todos: [String] = []\n}\n\nextension AppState: Codable {\n  enum CodingKeys: String, CodingKey { case todos }\n\n  init(from decoder: any Decoder) throws {\n    let container = try decoder.container(keyedBy: CodingKeys.self)\n\n    // Use the property wrapper default via the memberwise initializer:\n    try self.init(\n      todos: container.decode([String].self, forKey: .todos)\n    )\n\n    // Or initialize the shared storage manually:\n    self._launchCount = Shared(wrappedValue: 0, .appStorage(\"launchCount\"))\n    self.todos = try container.decode([String].self, forKey: .todos)\n  }\n\n  func encode(to encoder: any Encoder) throws {\n    var container = encoder.container(keyedBy: CodingKeys.self)\n    try container.encode(self.todos, forKey: .todos)\n    // Skip encoding the launch count.\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Feature with Shared State in TCA\nDESCRIPTION: This code defines a simple counter feature using the `@Shared` property wrapper to manage shared integer state.  The feature includes a reducer that increments the shared count when the `incrementButtonTapped` action is sent.  It utilizes the `withLock` method to ensure thread safety when modifying the shared state.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_20\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer \nstruct Feature {\n  struct State: Equatable {\n    @Shared var count: Int\n  }\n  enum Action {\n    case incrementButtonTapped\n  }\n  var body: some ReducerOf<Self> {\n    Reduce { state, action in\n      switch action {\n      case .incrementButtonTapped:\n        state.$count.withLock { $0 += 1 }\n        return .none\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Counter Feature Actions\nDESCRIPTION: Defines the actions for a simple counter feature, including incrementing and decrementing the count.  These actions represent user interactions or effects that can modify the state.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\nstruct CounterFeature: Reducer {\n  // ...\n  enum Action {\n    case decrementButtonTapped\n    case incrementButtonTapped\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Reducer with Clock Dependency in Swift\nDESCRIPTION: This code adds a Clock dependency to the Feature reducer using the `@Dependency` property wrapper. This allows for injecting a controlled Clock implementation during testing, enabling faster and more predictable tests.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\nimport Clocks\n\n@Reducer\nstruct Feature {\n  struct State { /* ... */ }\n  enum Action { /* ... */ }\n  @Dependency(\\.continuousClock) var clock\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Reducer with Shared Property\nDESCRIPTION: Defines a reducer `Feature` with a shared boolean property `bool` managed by `@Shared`. The reducer handles `tap` and `response` actions, where `tap` triggers an effect that sends `response`, and `response` toggles the shared `bool` using `withLock` to ensure thread safety.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_48\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  struct State: Equatable {\n    @Shared(value: false) var bool\n  }\n  enum Action {\n    case tap\n    case response\n  }\n  var body: some ReducerOf<Self> {\n    Reduce { state, action in\n      switch action {\n      case .tap:\n        return .run { send in\n          await send(.response)\n        }\n      case .response:\n        state.$bool.withLock { $0.toggle() }\n        return .none\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Receiving Actions and Asserting Dismissal in TestStore\nDESCRIPTION: This snippet demonstrates how to use the `TestStore/receive` method to assert that a specific action (PresentationAction/dismiss) is received, indicating that the child feature has dismissed itself. It confirms that the `counter` state is set to `nil` after the dismissal.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_20\n\nLANGUAGE: swift\nCODE:\n```\nawait store.receive(\\.counter.dismiss) {\n  \\$0.counter = nil\n}\n```\n\n----------------------------------------\n\nTITLE: Sharing Logic with Methods - Efficient\nDESCRIPTION: This snippet demonstrates the recommended approach of sharing logic using a method within the `Reducer` struct. This avoids the overhead of sending additional actions and improves performance. The `sharedComputation` method takes `inout State` as input, allowing direct state mutations and returning an `Effect<Action>`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Performance.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  @ObservableState\n  struct State { /* ... */ }\n  enum Action { /* ... */ }\n\n  var body: some Reducer<State, Action> {\n    Reduce { state, action in\n      switch action {\n      case .buttonTapped:\n        state.count += 1\n        return self.sharedComputation(state: &state)\n\n      case .toggleChanged:\n        state.isEnabled.toggle()\n        return self.sharedComputation(state: &state)\n\n      case let .textFieldChanged(text):\n        state.description = text\n        return self.sharedComputation(state: &state)\n      }\n    }\n  }\n\n  func sharedComputation(state: inout State) -> Effect<Action> {\n    // Some shared work to compute something.\n    return .run { send in\n      // A shared effect to compute something\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing State Changes Swift\nDESCRIPTION: This snippet demonstrates how to test state changes using TestStore's `send` method. It simulates user interactions (increment/decrement button taps) and asserts that the state changes as expected. Each `await store.send` triggers an action, and the trailing closure checks the resulting state modification.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n// Test that tapping on the increment/decrement buttons changes the count\nawait store.send(.incrementButtonTapped) {\n  $0.count = 1\n}\nawait store.send(.decrementButtonTapped) {\n  $0.count = 0\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Persisted Shared State in Swift\nDESCRIPTION: This snippet shows how to initialize shared state with a persistence strategy (e.g., `appStorage`). The initializer takes a plain value and constructs the `Shared` value using the initializer that takes a `SharedKey` as the second argument, specifying the persistence strategy.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\npublic struct State {\n  @Shared public var count: Int\n  // other fields\n\n  public init(count: Int, /* other fields */) {\n    self._count = Shared(wrappedValue: count, .appStorage(\"count\"))\n    // other assignments\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Tree-Based Navigation Using Presents Macro in EditItemFeature\nDESCRIPTION: This code snippet demonstrates a further nested level of tree-based navigation using the `@Presents` macro to present an alert within the edit screen feature.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/WhatIsNavigation.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct EditItemFeature {\n  struct State {\n    @Presents var alert: AlertState<AlertAction>?\n    // ...\n  }\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Dismissing Using DismissEffect in TCA\nDESCRIPTION: This code demonstrates using `DismissEffect` from the Composable Architecture to dismiss a feature from within a reducer. The `dismiss` dependency is injected, and when invoked, it sends a PresentationAction/dismiss action to `nil` out the state, handling the dismissal logic entirely within the child feature.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  @ObservableState\n  struct State { /* ... */ }\n  enum Action { \n    case closeButtonTapped\n    // ...\n  }\n  @Dependency(\\.dismiss) var dismiss\n  var body: some Reducer<State, Action> {\n    Reduce { state, action in\n      switch action {\n      case .closeButtonTapped:\n        return .run { _ in await self.dismiss() }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Mock Dependency in Tests (Swift)\nDESCRIPTION: Demonstrates how to use a mock dependency for testing. This mock dependency returns a deterministic and predictable fact, allowing for isolated and reliable tests. The mock dependency is injected when creating the `TestStore`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\n@Test\nfunc basics() async {\n  let store = TestStore(initialState: Feature.State()) {\n    Feature(numberFact: { \"\\($0) is a good number Brent\" })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Scoping Navigation Views to Child Domains\nDESCRIPTION: This snippet shows how to scope to a child domain using navigation view modifiers like `sheet`. This is a recommended use case for scoping that does not introduce performance concerns.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Performance.md#_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\n.sheet(store: store.scope(state: \\.child, action: \\.child)) { store in\n  ChildView(store: store)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Collection of States for Stack-Based Navigation\nDESCRIPTION: This code snippet creates a collection of `Path` enum values, representing the features presented on the navigation stack.  It shows adding a detail and edit screen to the stack.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/WhatIsNavigation.md#_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nlet path: [Path] = [\n  .detail(DetailItemFeature.State(item: item)),\n  .edit(EditItemFeature.State(item: item)),\n  // ...\n]\n```\n\n----------------------------------------\n\nTITLE: Mapping Effect Output to Action\nDESCRIPTION: This snippet demonstrates mapping the output of an `Effect` (e.g., from a client fetch) to an action using the case of an enum as a function.  It shows a common pattern where the output of an asynchronous operation is wrapped in an action to be processed by the reducer. The issue of non-sendable function values being converted to sendable closures is addressed, particularly in strict concurrency mode.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.15.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\nreturn client.fetch()\n  .map(Action.response)\n```\n\n----------------------------------------\n\nTITLE: Parent Feature Reducer with Presents Macro\nDESCRIPTION: This example shows how to embed the CounterFeature into a parent feature using the `@Presents` macro, `PresentationAction` type, and `Reducer/ifLet` operator. This allows the parent feature to present and manage the state of the child counter feature.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_17\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  @ObservableState\n  struct State: Equatable {\n    @Presents var counter: CounterFeature.State?\n  }\n  enum Action {\n    case counter(PresentationAction<CounterFeature.Action>)\n  }\n  var body: some Reducer<State, Action> {\n    Reduce { state, action in\n      // Logic and behavior for core feature.\n    }\n    .ifLet(\\.\\$counter, action: \\.counter) {\n      CounterFeature()\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Exhaustive Test Store Usage in Swift\nDESCRIPTION: Illustrates how to configure a TestStore for non-exhaustive testing in the Composable Architecture (TCA). In non-exhaustive mode, the closure in `store.send` receives the state *after* the action is sent, allowing assertions on specific state changes without needing to replicate the entire reducer logic.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_19\n\nLANGUAGE: swift\nCODE:\n```\nlet store = TestStore(/* ... */)\nstore.exhaustivity = .off\n\nstore.send(.buttonTapped) {\n  $0  // Represents the state *after* the action was sent\n}\n```\n\n----------------------------------------\n\nTITLE: Effect Cancellation Migration\nDESCRIPTION: This code snippet illustrates how to migrate from a fire-and-forget effect that outlives the store to using an unstructured task. This ensures that analytics or persistence effects proceed without cancellation even when the store deallocates. The key change is wrapping the asynchronous operation in a `Task` block.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.18.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n return .run { _ in\n-  await analytics.track(/* ... */)\n+  Task {\n+    await analytics.track(/* ... */)\n+  }\n }\n```\n\n----------------------------------------\n\nTITLE: Defining Destination Reducer (@Reducer Macro)\nDESCRIPTION: This code defines a destination reducer using the `@Reducer` macro. This simplifies the definition by automatically generating the State and Action enums and Scopes. It significantly reduces the boilerplate code required for destination reducers.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nenum Destination {\n  case add(FormFeature)\n  case detail(DetailFeature)\n  case edit(EditFeature)\n}\n```\n\n----------------------------------------\n\nTITLE: Making @Shared properties fileprivate in Swift\nDESCRIPTION: This snippet demonstrates making @Shared properties `fileprivate` to restrict their mutation to within their file scope.  This further enforces the pattern of using shared state correctly and prevents accidental modification from outside the intended scope, enhancing code safety.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_33\n\nLANGUAGE: swift\nCODE:\n```\nstruct State {\n  @Shared(.appStorage(\"count\")) fileprivate var count = 0\n}\n```\n\n----------------------------------------\n\nTITLE: Observing State Changes in UIKit with TCA\nDESCRIPTION: This snippet demonstrates how to use the `observe` function to minimally observe changes to the `count` property of a feature's state in a UIKit view controller. The closure will only be invoked when the observed state changes, optimizing UI updates.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.13.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nlet store: StoreOf<Feature>\n\nfunc viewDidLoad() {\n  super.viewDidLoad()\n\n  // ...\n\n  observe { [weak self] in\n    countLabel.text = \"Count: \\(store.count)\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing @PresentationState with @Presents Swift\nDESCRIPTION: This snippet illustrates the replacement of the `@PresentationState` property wrapper with the new `@Presents` macro in Swift. The `@Presents` macro should be used when using `@ObservableState` macro due to limitations of Swift macros used with property wrappers. This resolves the compiler errors that occur when applying the `@ObservableState` macro with `@PresentationState`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n@ObservableState \nstruct State {\n  @PresentationState var child: Child.State?  // üõë\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n@ObservableState \nstruct State {\n  @Presents var child: Child.State?  // ‚úÖ\n}\n```\n\n----------------------------------------\n\nTITLE: Reducer with Mutable State Access in Effect (Swift)\nDESCRIPTION: This code demonstrates an attempt to access mutable state directly within an `Effect`'s closure, which results in a concurrency error. It highlights the problem of capturing `inout` parameters in concurrently executing code.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SwiftConcurrency.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  @ObservableState\n  struct State { /* ... */ }\n  enum Action { /* ... */ }\n\n  var body: some Reducer<State, Action> {\n    Reduce { state, action in\n      switch action {\n      case .buttonTapped:\n        return .run { send in\n          try await Task.sleep(for: .seconds(1))\n          await send(.delayed(state.count))\n          // üõë Mutable capture of 'inout' parameter 'state' is\n          //    not allowed in concurrently-executing code\n        }\n\n        // ...\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Compose Reducers with ifLet for Child Feature Integration (Swift)\nDESCRIPTION: This snippet shows how to compose the reducers of parent and child features using the `ifLet` reducer operator. When the `.addButtonTapped` action is triggered, the `addItem` state is populated, driving the navigation. The `ifLet` operator focuses on the presentation state (`\\.$addItem`) and uses a case path (`\\.addItem`) for enum actions.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct InventoryFeature {\n  @ObservableState\n  struct State: Equatable { /* ... */ }\n  enum Action { /* ... */ }\n  \n  var body: some ReducerOf<Self> {\n    Reduce { state, action in \n      switch action {\n      case .addButtonTapped:\n        // Populating this state performs the navigation\n        state.addItem = ItemFormFeature.State()\n        return .none\n\n      // ...\n      }\n    }\n    .ifLet(\\.$addItem, action: \\.addItem) {\n      ItemFormFeature()\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Scoping to Identified Arrays with Case Key Paths\nDESCRIPTION: This code snippet shows how to scope to a specific row in an `IdentifiedArray` using case key paths. This simplifies the action transformation required when dealing with collections of identifiable data.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.5.md#_snippet_5\n\nLANGUAGE: Swift\nCODE:\n```\nstore.scope(\n  state: \\.rows[id: id],\n  action: { .rows(.element(id: id, action: $0)) }\n)\n```\n\nLANGUAGE: Swift\nCODE:\n```\nstore.scope(\n  state: \\.rows[id: id],\n  action: \\.rows[id: id]\n)\n```\n\n----------------------------------------\n\nTITLE: Using custom persistence strategy with @SharedReader in Swift\nDESCRIPTION: This snippet shows how to define a shared reader property using a custom persistence strategy (.remoteConfig). This strategy loads (and subscribes to) a remote configuration file from a server, keeping it automatically in sync. This illustrates how to leverage `@SharedReader` with custom data loading mechanisms.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_35\n\nLANGUAGE: swift\nCODE:\n```\n@SharedReader(.remoteConfig) var remoteConfig\n```\n\n----------------------------------------\n\nTITLE: Reducer Feature with ObservableState Swift\nDESCRIPTION: This shows how to use the `@ObservableState` macro to make the feature's state observable. This enables simpler bindings when using the new observation tools.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer \nstruct Feature {\n  @ObservableState\n  struct State {\n    // ...\n  }\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Persisted Shared State with @autoclosure in Swift\nDESCRIPTION: This code snippet shows how to initialize persisted shared state using an `@autoclosure` to delay the evaluation of the initial value until it's actually needed (i.e., when no value exists in the external storage). This can improve performance and prevent unnecessary computations.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\npublic struct State {\n  @Shared public var count: Int\n  // other fields\n\n  public init(count: @autoclosure () -> Int, /* other fields */) {\n    self._count = Shared(wrappedValue: count(), .appStorage(\"count\"))\n    // other assignments\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Integrate Views with SwiftUI Binding and Store Scope (Swift)\nDESCRIPTION: This snippet demonstrates how to integrate the views of parent and child features using SwiftUI's `sheet(item:)` modifier. It passes a binding of a `Store` to the modifier, which is focused on the presentation state and actions using `.scope`. The `@Bindable` property wrapper is used to produce a binding to a store for use in the view.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nstruct InventoryView: View {\n  @Bindable var store: StoreOf<InventoryFeature>\n\n  var body: some View {\n    List {\n      // ...\n    }\n    .sheet(\n      item: $store.scope(state: \\.addItem, action: \\.addItem)\n    ) { store in\n      ItemFormView(store: store)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting State and Saving Data in TCA\nDESCRIPTION: This code demonstrates how to extract feature state after detecting a specific action (saveButtonTapped) and perform additional logic, such as closing the feature and saving data to the database. It uses a guard statement to safely unwrap the state and then performs asynchronous operations to save the edited item.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\ncase .destination(.presented(.editItem(.saveButtonTapped))):\n  guard case let .editItem(editItemState) = state.destination\n  else { return .none }\n\n  state.destination = nil\n  return .run { _ in\n    self.database.save(editItemState.item)\n  }\n```\n\n----------------------------------------\n\nTITLE: Presenting Features by Populating Destination State in Swift\nDESCRIPTION: This code snippet shows how to present a specific feature by setting the `destination` state to the corresponding enum case. This action can then be handled by SwiftUI's presentation modifiers.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\ncase addButtonTapped:\n  state.destination = .addItem(AddFeature.State())\n  return .none\n```\n\n----------------------------------------\n\nTITLE: Using @Dependency Property Wrapper (Swift)\nDESCRIPTION: Shows how to use the `@Dependency` property wrapper to inject the `numberFact` dependency into the `Feature` reducer. This eliminates the need to explicitly pass the dependency when constructing the reducer. The `numberFact` can then be accessed using the wrapper.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_18\n\nLANGUAGE: swift\nCODE:\n```\n @Reducer\n struct Feature {\n-  let numberFact: (Int) async throws -> String\n+  @Dependency(\\.numberFact) var numberFact\n   \n   ‚Ä¶\n\n-  try await self.numberFact(count)\n+  try await self.numberFact.fetch(count)\n }\n```\n\n----------------------------------------\n\nTITLE: Enabling InferSendableFromCaptures Feature in Xcode\nDESCRIPTION: This snippet demonstrates how to enable the `InferSendableFromCaptures` Swift feature in Xcode by adding a new \"Other Swift Flags\" flag to the project's build settings. This feature automatically infers sendability for closures, potentially resolving concurrency issues. The flag `-enable-upcoming-feature InferSendableFromCaptures` needs to be added.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.15.md#_snippet_3\n\nLANGUAGE: Swift\nCODE:\n```\n-enable-upcoming-feature InferSendableFromCaptures\n```\n\n----------------------------------------\n\nTITLE: Streamlined Test for Shared Logic\nDESCRIPTION: This snippet shows a streamlined test case when sharing logic through reducer methods. The test now reads as a direct sequence of user actions and their corresponding state changes, making it clearer and easier to understand.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Performance.md#_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nlet store = TestStore(initialState: Feature.State()) {\n  Feature()\n}\n\nstore.send(.buttonTapped) {\n  $0.count = 1\n  // Assert on shared logic\n}\nstore.send(.toggleChanged) {\n  $0.isEnabled = true\n  // Assert on shared logic\n}\nstore.send(.textFieldChanged(\"Hello\") {\n  $0.description = \"Hello\"\n  // Assert on shared logic\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing TestStore State for Assertions\nDESCRIPTION: This snippet shows how to access the current state of the `TestStore` using the `state` property and perform assertions on computed properties or other state values. The snippet also warns against trying to update the state with `store.state` inside the send closure.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nstore.send(.incrementButtonTapped) {\n  $0.count = 3\n}\nXCTAssertTrue(store.state.isPrime)\n```\n\n----------------------------------------\n\nTITLE: Mutating Shared State in an Effect in TCA\nDESCRIPTION: This code snippet demonstrates how shared state can be captured and mutated within an effect.  The `incrementButtonTapped` action now returns an effect that captures the shared `count` state and increments it asynchronously using `withLock`. This highlights the possibility of side effects directly modifying shared state outside of the reducer's immediate scope.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_23\n\nLANGUAGE: swift\nCODE:\n```\ncase .incrementButtonTapped:\n  return .run { [sharedCount = state.$count] _ in\n    await sharedCount.withLock { $0 += 1 }\n  }\n```\n\n----------------------------------------\n\nTITLE: Conditional Reducer with Inferred Destination Reducer\nDESCRIPTION: Shows how the trailing closure can be omitted from `ifLet` operator when using the new destination reducers simplifying the code.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.8.md#_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n Reduce { state, action in\n   // Core feature logic\n }\n+.ifLet(\\.\\$destination, action: \\.destination)\n```\n\n----------------------------------------\n\nTITLE: Using @Shared with fileStorage key in Swift\nDESCRIPTION: This snippet shows how to define a shared property, `users`, using the `.fileStorage` strategy to persist an array of users to disk. It uses a URL to identify the storage location. It represents a basic file storage setup.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_36\n\nLANGUAGE: swift\nCODE:\n```\nextension URL {\n  static let users = URL(/* ... */))\n}\n\n@Shared(.fileStorage(.users)) var users: [User] = []\n```\n\n----------------------------------------\n\nTITLE: Initializing Feature Reducer Swift\nDESCRIPTION: This code snippet initializes a new Feature struct annotated with the @Reducer macro from the Composable Architecture. This serves as the base for defining the state, actions, and logic of the feature.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nimport ComposableArchitecture\n\n@Reducer\nstruct Feature {\n}\n```\n\n----------------------------------------\n\nTITLE: Action Ping-Pong with Intermingled State Mutations & Async Operations (Swift)\nDESCRIPTION: Illustrates the action \"ping-pong\" scenario in TCA, where multiple actions are needed to perform asynchronous operations with state mutations in between. It shows the need for separate actions for each async operation and state change.  This pattern is necessary when mutations are interleaved with asynchronous calls, highlighting a trade-off for the benefits of TCA's action data description.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/FAQ.md#_snippet_4\n\nLANGUAGE: Swift\nCODE:\n```\ncase .refreshButtonTapped:\n  return .run { send in \n    await send(.userResponse(apiClient.fetchCurrentUser()))\n  }\ncase let .userResponse(response):\n  return .run { send in \n    await send(.moviesResponse(apiClient.fetchMovies(userID: response.id)))\n  }\ncase let .moviesResponse(response):\n  // Do something with response\n```\n\n----------------------------------------\n\nTITLE: Avoiding Infinite Loops with Shared State in Swift\nDESCRIPTION: This code snippet illustrates a potential infinite loop scenario when a feature both holds shared state and subscribes to changes in that state. Modifying the shared `count` within the `countUpdated` action triggers a new emission from the publisher, leading to a recursive cycle.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\ncase .onAppear:\n  return .publisher {\n    state.$count.publisher\n      .map(Action.countUpdated)\n  }\n\ncase .countUpdated(let count):\n  state.count = count + 1\n  return .none\n```\n\n----------------------------------------\n\nTITLE: Replacing IfLetStore with 'if let'\nDESCRIPTION: Illustrates how to replace the deprecated IfLetStore with standard 'if let' syntax in SwiftUI. This involves using Store/scope(state:action:)-90255 to derive a store for the non-optional state.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nif let childStore = store.scope(state: \\.child, action: \\.child) {\n  ChildView(store: childStore)\n} else {\n  Text(\"Nothing to show\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Persistence Strategy\nDESCRIPTION: Demonstrates how to define a static function on the `SharedKey` protocol to create a new persistence strategy, enabling its use with the `@Shared` property wrapper.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_7\n\nLANGUAGE: Swift\nCODE:\n```\nextension SharedReaderKey {\n  public static func custom<Value>(/*...*/) -> Self\n  where Self == CustomPersistence<Value> {\n    CustomPersistence(/* ... */)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Dependencies on a Reducer\nDESCRIPTION: This snippet showcases the `Reducer/dependency(_:)` API for overriding dependencies on a reducer, enhancing testability and modularity.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.9.md#_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\nMyFeature()\n  .dependency(mockAPIClient)\n```\n\n----------------------------------------\n\nTITLE: Adding TCA as a SwiftPM Dependency\nDESCRIPTION: This code snippet shows how to add the Composable Architecture as a dependency to a Swift Package Manager project. It specifies the GitHub URL of the TCA repository and the 'ComposableArchitecture' product for a specific target.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nlet package = Package(\n  dependencies: [\n    .package(\n      url: \"https://github.com/pointfreeco/swift-composable-architecture\",\n      from: \"1.0.0\"\n    ),\n  ],\n  targets: [\n    .target(\n      name: \"<target-name>\",\n      dependencies: [\n        .product(\n          name: \"ComposableArchitecture\",\n          package: \"swift-composable-architecture\"\n        )\n      ]\n    )\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Settings View with Bindable Store (Simplified) - Swift\nDESCRIPTION: Declares a `SettingsView` struct with the `@Bindable` property wrapper to hold a `StoreOf<Settings>`.  This is the same as the previous example, demonstrating that the view structure remains the same when using `BindingAction` and `BindingReducer`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Bindings.md#_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\nstruct SettingsView: View {\n  @Bindable var store: StoreOf<Settings>\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining BindingAction into Key Path of State\nDESCRIPTION: This snippet shows how `BindingAction` can dynamically chain into a key path of state when sending actions, simplifying data binding assertions.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.9.md#_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\n-store.send(.binding(.set(\\.\\firstName, \"Blob\")))\n+store.send(\\.\\binding.firstName, \"Blob\")\n```\n\n----------------------------------------\n\nTITLE: Asserting Delegate Action Payload (New)\nDESCRIPTION: This code snippet demonstrates the new way of asserting that an action features sends a delegate action with a specific boolean payload using the key path and the expected payload. This approach allows asserting only on specific parts of the action.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.6.md#_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\nawait store.receive(\\ .child.delegate.response, true)\n```\n\n----------------------------------------\n\nTITLE: Fixing Autocomplete Issues\nDESCRIPTION: This code presents two ways to fix autocompletion issues that can occur in the body of a reducer when using `@Reducer`. The first is by adding an explicit `Reducer` conformance, and the second is by adding explicit generics to instances of `Reduce`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_18\n\nLANGUAGE: swift\nCODE:\n```\n @Reducer\n-struct Feature {\n+struct Feature: Reducer {\n\n```\n\nLANGUAGE: swift\nCODE:\n```\n var body: some Reducer<State, Action> {\n-  Reduce { state, action in\n+  Reduce<State, Action> { state, action in\n\n```\n\n----------------------------------------\n\nTITLE: Sending Actions to Child Features in StackState using TestStore in Swift\nDESCRIPTION: This snippet demonstrates how to send an action to a specific child feature within a StackState using its ID.  It utilizes the \\.path[id: 0].counter.incrementButtonTapped key path to target the incrementButtonTapped action on the counter feature at ID 0 in the stack.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\nawait store.send(\\.path[id: 0].counter.incrementButtonTapped) {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Sharing State with Shared Property Wrapper in Swift\nDESCRIPTION: This snippet shows how to use the `@Shared` property wrapper to share state between different features in a Composable Architecture application. Changes made to the shared state will be instantly observed by all features holding onto it. The shared state `signUpData` is of type `SignUpData`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.10.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@ObservableState\nstruct State {\n  @Shared var signUpData: SignUpData\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Finishing a TestStore (ComposableArchitecture, Swift)\nDESCRIPTION: Illustrates how to explicitly call `TestStore/finish` at the end of a test when a test store does not deinitialize automatically.  This ensures that exhaustive coverage is retained, including checks for unreceived actions and in-flight effects.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_34\n\nLANGUAGE: Swift\nCODE:\n```\nawait store.finish()\n```\n\n----------------------------------------\n\nTITLE: Receiving Test Store Actions with Case Key Path Syntax\nDESCRIPTION: This snippet demonstrates the simplified syntax introduced in version 1.4 for receiving test store actions using case key paths. It shows how to assert on actions received in a test more succinctly.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.9.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n-store.receive(.child(.presented(.response(.success(\"Hello\")))))\n+store.receive(\\.\\child.response.success)\n```\n\n----------------------------------------\n\nTITLE: Basic Test Setup for Feature in Swift\nDESCRIPTION: This sets up a basic test using TestStore for the Feature reducer. It initializes a TestStore with an initial state and the Feature reducer, allowing for assertions on state changes and effect executions.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n@MainActor\nstruct TimerTests {\n  @Test\n  func basics() async {\n    let store = TestStore(initialState: Feature.State(count: 0)) {\n      Feature()\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing Deeply Nested State for Tree-Based Navigation\nDESCRIPTION: This code snippet shows how to construct a deeply nested state to deep-link into the application with the inventory view drilled down to an item, the edit sheet opened, and an alert presented. It demonstrates the tree-like structure of the state.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/WhatIsNavigation.md#_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nInventoryView(\n  store: Store(\n    initialState: InventoryFeature.State(\n      detailItem: DetailItemFeature.State(      // Drill-down to detail screen\n        editItem: EditItemFeature.State(        // Open edit modal\n          alert: AlertState {                   // Open alert\n            TextState(\"This item is invalid.\")\n          }\n        )\n      )\n    )\n  ) {\n    InventoryFeature()\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Destructuring Actions in TCA\nDESCRIPTION: This snippet demonstrates how to destructure actions within a parent feature to detect specific actions in a child feature (editItem.saveButtonTapped). It uses pattern matching on PresentationAction, then PresentationAction/presented(_:), then the relevant feature, and finally the target action. This enables integration of logic between child and parent features.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\ncase .destination(.presented(.editItem(.saveButtonTapped))):\n  // ...\n```\n\n----------------------------------------\n\nTITLE: Testing Effect Execution Swift\nDESCRIPTION: This snippet illustrates testing the execution of an effect and the data it feeds back into the store. It simulates tapping a button that triggers an effect, then asserts that the correct response is received and the state is updated accordingly.  `await store.receive` is used to check data received from an effect.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nawait store.send(.numberFactButtonTapped)\n\nawait store.receive(\\.\\numberFactResponse) {\n  $0.numberFact = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Stack-Based Navigation Path Definition (Swift)\nDESCRIPTION: Illustrates how to define a navigation path using a stack-based approach. The `path` array, containing different `Path` enum cases, represents a sequence of screens navigated in the application. This example shows a recursive navigation path where the user returns to the initial screen.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/WhatIsNavigation.md#_snippet_7\n\nLANGUAGE: Swift\nCODE:\n```\nlet path: [Path] = [\n  .movie(/* ... */),\n  .actors(/* ... */),\n  .actor(/* ... */),\n  .movies(/* ... */),\n  .movie(/* ... */),\n]\n```\n\n----------------------------------------\n\nTITLE: Non-Exhaustive Testing with TestStore in Swift\nDESCRIPTION: This snippet demonstrates non-exhaustive testing by turning off exhaustivity on the TestStore. This allows you to assert only on the parts of the features that you care about. In this example, it asserts that after tapping the increment button twice, a StackAction.popFrom action is eventually received.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\n@Test\nfunc dismissal() {\n  let store = TestStore(\n    initialState: Feature.State(\n      path: StackState([\n        CounterFeature.State(count: 3)\n      ])\n    )\n  ) {\n    CounterFeature()\n  }\n  store.exhaustivity = .off\n\n  await store.send(\\.path[id: 0].counter.incrementButtonTapped)\n  await store.send(\\.path[id: 0].counter.incrementButtonTapped)\n  await store.receive(\\.path.popFrom)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Counter Feature Reducer in Swift\nDESCRIPTION: This snippet defines a simple counter feature using the TCA's @Reducer macro. It includes state, actions, and reducer logic to increment and decrement the count. When the count reaches 5 or greater, it dismisses itself using the dismiss dependency.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct CounterFeature {\n  @ObservableState\n  struct State: Equatable {\n    var count = 0\n  }\n  enum Action {\n    case decrementButtonTapped\n    case incrementButtonTapped\n  }\n\n  @Dependency(\\.dismiss) var dismiss\n\n  var body: some Reducer<State, Action> {\n    Reduce { state, action in\n      switch action {\n      case .decrementButtonTapped:\n        state.count -= 1\n        return .none\n\n      case .incrementButtonTapped:\n        state.count += 1\n        return state.count >= 5\n          ? .run { _ in await self.dismiss() }\n          : .none\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Dependencies in Tests Swift\nDESCRIPTION: This code shows how to override dependencies in tests using the `withDependencies` closure of the `TestStore`. This allows for customizing the behavior of dependencies for specific test cases.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_19\n\nLANGUAGE: swift\nCODE:\n```\nlet store = TestStore(initialState: Feature.State()) {\n  Feature()\n} withDependencies: {\n  $0.numberFact.fetch = { \"\\($0) is a good number Brent\" }\n}\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Replacing NavigationStackStore with NavigationStack SwiftUI\nDESCRIPTION: This snippet illustrates the migration from `NavigationStackStore` to SwiftUI's `NavigationStack`. The state of the feature and the path reducer's state are marked with `@ObservableState`. The store is held in a bindable manner using `@Bindable` or `@Perception.Bindable`. The custom initializer on `NavigationStack` is then used.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  struct State {\n    var path: StackState<Path.State> = []\n  }\n  enum Action {\n    case path(StackAction<Path.State, Path.Action>)\n  }\n  var body: some ReducerOf<Self> { /* ... */ }\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nNavigationStackStore(store.scope(state: \\.path, action: \\.path)) {\n  RootView()\n} destination: {\n  switch $0 {\n  case .activity:\n    CaseLet(/Feature.State.activity, action: Feature.Action.activity) { store in\n      ActivityView(store: store)\n    }\n  case .settings:\n    CaseLet(/Feature.State.settings, action: Feature.Action.settings) { store in\n      SettingsView(store: store)\n    }\n  }\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  @ObservableState\n  struct State {\n    // ...\n  }\n  // ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Path {\n  @ObservableState\n  enum State {\n    // ...\n  }\n  // ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n@Bindable var store: StoreOf<Feature>\n```\n\nLANGUAGE: swift\nCODE:\n```\n@Perception.Bindable var store: StoreOf<Feature>\n```\n\nLANGUAGE: swift\nCODE:\n```\nNavigationStack(path: $store.scope(state: \\.path, action: \\.path)) {\n  RootView()\n} destination: { store in\n  switch store.state {\n  case .activity:\n    if let store = store.scope(state: \\.activity, action: \\.activity) {\n      ActivityView(store: store)\n    }\n  case .settings:\n    if let store = store.scope(state: \\.settings, action: \\.settings) {\n      SettingsView(store: store)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Closure for Mapping Effect Output\nDESCRIPTION: This snippet provides an alternative solution to the \"non-sendable function value\" error by explicitly opening the closure instead of using the enum case as a function reference. This makes the closure sendable, addressing concurrency issues in strict mode.  The `$0` represents the output value from the `fetch()` operation.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.15.md#_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\nreturn client.fetch()\n  .map { .response($0) }\n```\n\n----------------------------------------\n\nTITLE: Debugging State Changes with _printChanges() in TCA (Swift)\nDESCRIPTION: This snippet showcases the `_printChanges()` reducer operator, which provides insight into every action entering the system and prints a formatted message showing how state changed. This is a powerful debugging tool made possible by the data description of actions in TCA, allowing developers to easily track state mutations.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/FAQ.md#_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\nreceived action:\n  AppFeature.Action.syncUpsList(.addSyncUpButtonTapped)\n  AppFeature.State(\n    _path: [:],\n    _syncUpsList: SyncUpsList.State(\n-     _destination: nil,\n+     _destination: .add(\n+       SyncUpForm.State(\n+         ‚Ä¶\n+       )\n+     ),\n      _syncUps: #1 [‚Ä¶]\n    )\n  )\n```\n\n----------------------------------------\n\nTITLE: Exhaustive Test Store Usage in Swift\nDESCRIPTION: Demonstrates how to configure a TestStore for exhaustive testing in the Composable Architecture (TCA). In exhaustive mode, the closure in `store.send` receives the state *before* the action is sent, requiring mutations to reflect the state *after* the action.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_18\n\nLANGUAGE: swift\nCODE:\n```\nlet store = TestStore(/* ... */)\n// ‚ÑπÔ∏è \"on\" is the default so technically this is not needed\nstore.exhaustivity = .on\n\nstore.send(.buttonTapped) {\n  $0  // Represents the state *before* the action was sent\n}\n```\n\n----------------------------------------\n\nTITLE: Reducer forEach Operator with Path Reducer\nDESCRIPTION: This code demonstrates using the `forEach` operator with a path reducer. Similar to the `ifLet` operator, the trailing closure of the `forEach` operator can be omitted when used with a path reducer.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\nReduce { state, action in\n  // Core feature logic\n}\n.forEach(\\.path, action: \\.path)\n-{\n-  Path()\n-}\n```\n\n----------------------------------------\n\nTITLE: Initializing Non-Persisted Shared State (Self-Contained) in Swift\nDESCRIPTION: This snippet illustrates how to initialize shared state that is not persisted and whose source of truth resides within the feature being initialized. The initializer takes a plain value and constructs the `Shared` value within the initializer.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\npublic struct State {\n  @Shared public var count: Int\n  // other fields\n\n  public init(count: Int, /* other fields */) {\n    self._count = Shared(count)\n    // other assignments\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Working Test with Explicit UUID Provision in Swift\nDESCRIPTION: Demonstrates the working test using the modified `Model` and reducer. The test now provides the UUID explicitly, avoiding the issue of side effects during assertion closure invocations in non-exhaustive tests with skipped assertions.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_29\n\nLANGUAGE: swift\nCODE:\n```\nawait store.send(.addButtonTapped) {\n  $0.values = [\n    Model(id: UUID(0))\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Reducer Handling Individual Actions - Swift\nDESCRIPTION: Demonstrates the reducer logic for handling each individual action, updating the corresponding state field with the new value provided in the action.  This example shows the verbose and repetitive nature of handling multiple binding-related actions manually.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Bindings.md#_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Settings {\n  @ObservableState\n  struct State { /* ... */ }\n  enum Action { /* ... */ }\n\n  var body: some Reducer<State, Action> {\n    Reduce { state, action in\n      switch action {\n      case let digestChanged(digest):\n        state.digest = digest\n        return .none\n\n      case let displayNameChanged(displayName):\n        state.displayName = displayName\n        return .none\n\n      case let enableNotificationsChanged(isOn):\n        state.enableNotifications = isOn\n        return .none\n\n      case let protectMyPostsChanged(isOn):\n        state.protectMyPosts = isOn\n        return .none\n\n      case let sendEmailNotificationsChanged(isOn):\n        state.sendEmailNotifications = isOn\n        return .none\n\n      case let sendMobileNotificationsChanged(isOn):\n        state.sendMobileNotifications = isOn\n        return .none\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Define State and Actions with @Presents for Navigation (Swift)\nDESCRIPTION: This snippet demonstrates how to define the state and actions for tree-based navigation using the `@Presents` macro and `PresentationAction`. The `addItem` state, an optional of `ItemFormFeature.State`, represents whether the add item form is currently presented. An action case is defined using `PresentationAction` to manage the presentation of the child feature.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct InventoryFeature {\n  @ObservableState\n  struct State: Equatable {\n    @Presents var addItem: ItemFormFeature.State?\n    var items: IdentifiedArrayOf<Item> = []\n    // ...\n  }\n\n  enum Action {\n    case addItem(PresentationAction<ItemFormFeature.Action>)\n    // ...\n  }\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Timer Effect with Clock Sleep in Swift\nDESCRIPTION: This updates the timer effect to use the Clock dependency's `sleep(for:)` method instead of `Task.sleep`. This allows for controlling the passage of time in tests using a controlled Clock implementation.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\nreturn .run { send in\n  for _ in 1...5 {\n    try await self.clock.sleep(for: .seconds(1))\n    await send(.timerTick)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Annotating a struct with @Reducer macro Swift\nDESCRIPTION: This code snippet demonstrates how to annotate a struct conforming to Reducer with the `@Reducer` macro. This macro automates certain aspects of Reducer implementation and enables new capabilities like case key paths.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.4.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n+@Reducer\nstruct MyFeature: Reducer {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Swift-Sharing Dependency (Backward Compatible)\nDESCRIPTION: This code snippet demonstrates how to add an explicit dependency on the `swift-sharing` library in your Swift Package Manager manifest file. This pins the library to a version less than 1.0, ensuring backward compatibility with older Composable Architecture versions that included the `@Shared` property wrapper.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.17.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\n.package(url: \"https://github.com/pointfreeco/swift-sharing\", from: \"0.1.0\"),\n```\n\n----------------------------------------\n\nTITLE: Binding Store with @Bindable in Swift\nDESCRIPTION: This snippet shows how to hold onto the store in a bindable manner using the `@Bindable` property wrapper, necessary for SwiftUI integration and using the `scope` operator.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\nstruct InventoryView: View {\n  @Bindable var store: StoreOf<InventoryFeature>\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Providing Live Dependency in App Entry Point (Swift)\nDESCRIPTION: Illustrates how to provide a live version of the `numberFact` dependency to the `Feature` reducer in the application's entry point. This live dependency interacts with a real-world API server to fetch number facts.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\n@main\nstruct MyApp: App {\n  var body: some Scene {\n    WindowGroup {\n      FeatureView(\n        store: Store(initialState: Feature.State()) {\n          Feature(\n            numberFact: { number in\n              let (data, _) = try await URLSession.shared.data(\n                from: URL(string: \"http://numbersapi.com/\\(number)\")!\n              )\n              return String(decoding: data, as: UTF8.self)\n            }\n          )\n        }\n      )\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Subscripts for External Data in State Transformations\nDESCRIPTION: This code snippet illustrates how to use subscripts to incorporate external data into state transformations when scoping a store. This is useful when the child feature's state depends on data outside of the parent's state.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.5.md#_snippet_4\n\nLANGUAGE: Swift\nCODE:\n```\nChildView(\n  store: store.scope(\n    state: {\n      ChildFeature(\n        settings: viewStore.settings,\n        state: $0.child\n      )\n    },\n    action: { .child($0) }\n  )\n)\n```\n\nLANGUAGE: Swift\nCODE:\n```\nextension State {\n  subscript(settings settings: Settings) -> ChildFeature {\n    ChildFeature(\n      settings: settings,\n      state: self.child\n    )\n  }\n}\n```\n\nLANGUAGE: Swift\nCODE:\n```\nChildView(\n  store: store.scope(\n    state: \\[settings: viewStore.settings],\n    action: \\.child\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Modified Reducer with Explicit UUID Generation in Swift\nDESCRIPTION: Demonstrates how to modify the reducer to generate the UUID explicitly using `@Dependency(\\.uuid)` and pass it to the `Model`'s initializer. This centralizes the side effect and avoids unexpected behavior in non-exhaustive tests.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_28\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  // ...\n  @Dependency(\\.uuid) var uuid\n  var body: some Reducer<State, Action> {\n    Reduce { state, action in\n      switch action {\n      case .addButtonTapped:\n        state.values.append(Model(id: self.uuid()))\n        return .none\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Injected Dependency Swift\nDESCRIPTION: This snippet demonstrates how to use the injected `numberFact` dependency within the `reduce` function of the `Feature` reducer. It calls the dependency to fetch a fact based on the current state and then sends an action to update the state with the retrieved fact.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\ncase .numberFactButtonTapped:\n  return .run { [count = state.count] send in \n    let fact = try await self.numberFact(count)\n    await send(.numberFactResponse(fact))\n  }\n```\n\n----------------------------------------\n\nTITLE: Reducer State Change Test\nDESCRIPTION: This code demonstrates a basic approach to testing state changes in a Reducer by directly mutating the state and asserting the result. While functional, it's more verbose than using `TestStore`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  @ObservableState\n  struct State: Equatable {\n    var count = 0\n  }\n  enum Action {\n    case incrementButtonTapped\n    case decrementButtonTapped\n  }\n  var body: some Reduce<State, Action> {\n    Reduce { state, action in\n      switch action {\n      case .incrementButtonTapped:\n        state.count += 1\n        return .none\n      case .decrementButtonTapped:\n        state.count -= 1\n        return .none\n      }\n    }\n  }\n}\n\n@Test\nfunc basics() {\n  let feature = Feature()\n  var currentState = Feature.State(count: 0)\n  _ = feature.reduce(into: &currentState, action: .incrementButtonTapped)\n  #expect(currentState == State(count: 1))\n\n  _ = feature.reduce(into: &currentState, action: .decrementButtonTapped)\n  #expect(currentState == State(count: 0))\n}\n```\n\n----------------------------------------\n\nTITLE: Using NavigationStackController with UIKit in Swift\nDESCRIPTION: This code snippet demonstrates how to use `NavigationStackController` to integrate UIKit's `UINavigationController` with a `StackState` managed by the Composable Architecture. It initializes the controller with a store scope for the path, a root view controller, and a destination closure to create child view controllers based on the store's case.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_18\n\nLANGUAGE: Swift\nCODE:\n```\nclass AppController: NavigationStackController {\n  private var store: StoreOf<AppFeature>!\n\n  convenience init(store: StoreOf<AppFeature>) {\n    @UIBindable var store = store\n\n    self.init(path: $store.scope(state: \\.path, action: \\.path)) {\n      RootViewController(store: store)\n    } destination: { store in \n      switch store.case {\n      case .addItem(let store):\n        AddViewController(store: store)\n      case .detailItem(let store):\n        DetailViewController(store: store)\n      case .editItem(let store):\n        EditViewController(store: store)\n      }\n    }\n\n    self.store = store\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending SharedReaderKey for type-safe persistence in Swift\nDESCRIPTION: This code extends the `SharedReaderKey` protocol to add a static variable (`users`) describing the details of persistence for an `IdentifiedArrayOf<User>` using `fileStorage`. This provides type safety by associating the type directly with the persistence key, preventing accidental use of the wrong type.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_38\n\nLANGUAGE: swift\nCODE:\n```\nextension SharedReaderKey where Self == FileStorageKey<IdentifiedArrayOf<User>> {\n  static var users: Self {\n    fileStorage(.users)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Mutating Shared State with withLock - Swift\nDESCRIPTION: This snippet demonstrates the recommended way to mutate shared state from an effect using the `withLock` method on the projected value of `@Shared`. This ensures thread-safe mutation by locking the entire unit of work.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.11.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\ncase .delayedIncrementButtonTapped:\n  return .run { _ in\n    @Shared(.count) var count\n    $count.withLock { $0 += 1 }\n  }\n```\n\n----------------------------------------\n\nTITLE: Avoiding static linking issues in tests (ComposableArchitecture, Swift)\nDESCRIPTION: Describes the problem that arises when statically linking the ComposableArchitecture module to the tests target. This can cause conflicts with the statically linked implementation in the app itself, leading to test failures. The solution is to remove the static link from the test target.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_32\n\n\n\n----------------------------------------\n\nTITLE: View Actions with ViewAction Protocol Swift\nDESCRIPTION: This example outlines how to separate view actions from internal feature actions using the `ViewAction` protocol and the `@ViewAction` macro, enhancing encapsulation and preventing unintended actions from being sent from the view.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_17\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature\n  struct State { /* ... */ }\n  enum Action {\n    case loginResponse(Bool)\n    case view(View)\n\n    enum View {\n      case loginButtonTapped\n    }\n  }\n  // ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nstruct FeatureView: View {\n  let store: StoreOf<Feature>\n\n  var body: some View {\n    WithViewStore(\n      store, \n      observe: { $0 }, \n      send: Feature.Action.view  // üëà\n    ) { viewStore in\n      Button(\"Login\") {\n        viewStore.send(.loginButtonTapped)\n      }\n    }\n  }\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  // ...\n  enum Action: ViewAction {  // üëà\n    // ...\n  }\n  // ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n+@ViewAction(for: Feature.self)\nstruct FeatureView: View {\n  let store: StoreOf<Feature>\n\n  var body: some View {\n-    WithViewStore(\n-      store, \n-      observe: { $0 }, \n-      send: Feature.Action.view\n-    ) { viewStore in\n       Button(\"Login\") {\n-        viewStore.send(.loginButtonTapped)\n+        send(.loginButtonTapped)\n       }\n     }\n-  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying StackState using XCTModify in Swift\nDESCRIPTION: This snippet shows how to modify the state of a child feature within a StackState using the XCTModify helper function. It takes an inout piece of enum state and a case path to extract the payload for mutation. In this example, it increments the count of the counter feature at ID 0.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\nawait store.send(\\.path[id: 0].counter.incrementButtonTapped) {\n  XCTModify(&$0.path[id: 0], case: \\.counter) {\n    $0.count = 4\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Shared State for a Child Feature in Swift\nDESCRIPTION: This snippet defines the state for a child feature (`PhoneNumberFeature`) that uses `@Shared` to hold onto a specific part of shared state, in this case, the phone number (`String`).\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer \nstruct PhoneNumberFeature { \n  struct State {\n    @Shared var phoneNumber: String\n  }\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Supplying Mock Data to Previews - Swift\nDESCRIPTION: This snippet shows how to use the `constant` helper on `SharedReader` to simplify supplying mock data to Xcode previews, similar to SwiftUI's `Binding.constant`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.11.md#_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n#Preview {\n  FeatureView(\n    store: Store(\n      initialState: Feature.State(count: .constant(42))\n    ) {\n      Feature()\n    }\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Inefficient Test for Shared Action\nDESCRIPTION: This snippet shows an example of a test setup when using shared actions. It highlights the increased complexity, as you need to assert on both the initial action and the subsequent shared action, cluttering the test with internal implementation details.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Performance.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nlet store = TestStore(initialState: Feature.State()) {\n  Feature()\n}\n\nstore.send(.buttonTapped) {\n  $0.count = 1\n}\nstore.receive(\\.sharedComputation) {\n  // Assert on shared logic\n}\nstore.send(.toggleChanged) {\n  $0.isEnabled = true\n}\nstore.receive(\\.sharedComputation) {\n  // Assert on shared logic\n}\nstore.send(.textFieldChanged(\"Hello\")) {\n  $0.description = \"Hello\"\n}\nstore.receive(\\.sharedComputation) {\n  // Assert on shared logic\n}\n```\n\n----------------------------------------\n\nTITLE: forEach with Inferred Path Reducer\nDESCRIPTION: Shows how the trailing closure can be omitted from `forEach` operator when using the new path reducers, which further simplifies the code.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.8.md#_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n Reduce { state, action in\n   // Core feature logic\n }\n+.forEach(\\.path, action: \\.path)\n```\n\n----------------------------------------\n\nTITLE: Replacing SwitchStore and CaseLet\nDESCRIPTION: Demonstrates how to replace SwitchStore and CaseLet with a standard Swift switch statement and optional store scoping.  It uses 'if let' to safely unwrap the store after scoping.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nswitch store.state {\ncase .activity:\n  if let store = store.scope(state: \\.activity, action: \\.activity) {\n    ActivityView(store: store)\n  }\ncase .settings:\n  if let store = store.scope(state: \\.settings, action: \\.settings) {\n    SettingsView(store: store)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Scoping Store for Presentation in SwiftUI\nDESCRIPTION: This code snippet demonstrates how to use the `scope` operator to derive bindings from the store for different presentation styles like sheets, popovers, and navigation destinations. It ensures each presentation is tied to a specific case of the destination enum.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nvar body: some View {\n  List {\n    // ...\n  }\n  .sheet(\n    item: $store.scope(\n      state: \\.destination?.addItem,\n      action: \\.destination.addItem\n    )\n  ) { store in \n    AddFeatureView(store: store)\n  }\n  .popover(\n    item: $store.scope(\n      state: \\.destination?.editItem,\n      action: \\.destination.editItem\n    )\n  ) { store in \n    EditFeatureView(store: store)\n  }\n  .navigationDestination(\n    item: $store.scope(\n      state: \\.destination?.detailItem,\n      action: \\.destination.detailItem\n    )\n  ) { store in \n    DetailFeatureView(store: store)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Receives for Timer Ticks in Swift\nDESCRIPTION: This extends the previous example by asserting that five `.timerTick` actions are received, each incrementing the state's count. The timeout is needed because Task.sleep introduces real-world asynchrony, slowing down the test. This exhaustively tests the effect's execution.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nawait store.receive(\\.timerTick, timeout: .seconds(2)) {\n  $0.count = 1\n}\nawait store.receive(\\.timerTick, timeout: .seconds(2)) {\n  $0.count = 2\n}\nawait store.receive(\\.timerTick, timeout: .seconds(2)) {\n  $0.count = 3\n}\nawait store.receive(\\.timerTick, timeout: .seconds(2)) {\n  $0.count = 4\n}\nawait store.receive(\\.timerTick, timeout: .seconds(2)) {\n  $0.count = 5\n}\n```\n\n----------------------------------------\n\nTITLE: Action enum with @CasePathable Swift\nDESCRIPTION: This code shows how the `@CasePathable` macro is applied to the `Action` enum within a feature.  This allows the use of key path syntax for actions.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.4.md#_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n+@CasePathable\nenum Action {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using Perception.Bindable for Bindings\nDESCRIPTION: This code demonstrates how to use the `Perception.Bindable` property wrapper as a replacement for SwiftUI's `@Bindable` in projects targeting iOS versions older than iOS 17.  It allows deriving bindings from a store using the Composable Architecture.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/ObservationBackport.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nstruct MyView: View {\n  @Perception.Bindable var store: StoreOf<MyFeature>\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: CPU Intensive Work in Reducer - Inefficient\nDESCRIPTION: This snippet demonstrates performing CPU-intensive work directly within a reducer, which is an anti-pattern since reducers operate on the main thread. Avoid this approach to prevent blocking the main thread and impacting UI responsiveness.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Performance.md#_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\ncase .buttonTapped:\n  var result = // ...\n  for value in someLargeCollection {\n    // Some intense computation with value\n  }\n  state.result = result\n```\n\n----------------------------------------\n\nTITLE: Implementing Feature Reducer Body Swift\nDESCRIPTION: This code implements the reducer body, defining how the state changes in response to different actions. It uses a switch statement to handle each action case, updating the state and returning effects as needed.  The .run effect is used for the numberFactButtonTapped case to perform an asynchronous API request.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  @ObservableState\n  struct State: Equatable { /* ... */ }\n  enum Action { /* ... */ }\n\n  var body: some Reducer<State, Action> {\n    Reduce { state, action in\n      switch action {\n      case .decrementButtonTapped:\n        state.count -= 1\n        return .none\n\n      case .incrementButtonTapped:\n        state.count += 1\n        return .none\n\n      case .numberFactButtonTapped:\n        return .run { [count = state.count] send in\n          let (data, _) = try await URLSession.shared.data(\n            from: URL(string: \"http://numbersapi.com/\\(count)/trivia\")!\n          )\n          await send(\n            .numberFactResponse(String(decoding: data, as: UTF8.self))\n          )\n        }\n\n      case let .numberFactResponse(fact):\n        state.numberFact = fact\n        return .none\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using type-safe @Shared key in Swift\nDESCRIPTION: This snippet demonstrates using the type-safe key defined in the previous snippet with the `@Shared` property wrapper. By specifying `.users` directly, the compiler enforces the type associated with the key, preventing type mismatches.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_39\n\nLANGUAGE: swift\nCODE:\n```\n@Shared(.users) var users: IdentifiedArrayOf<User> = []\n```\n\n----------------------------------------\n\nTITLE: Using dot syntax for state access Swift\nDESCRIPTION: This example demonstrates how to use dot syntax to access a state's associated value when the state enum is annotated with `@CasePathable` and `@dynamicMemberLookup`. It shows how to scope a store's state to a specific case within an `IfLetStore`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.4.md#_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\nIfLetStore(\n   store.scope(\n-    state: /Feature.State.tray, action: Feature.Action.tray\n+    state: \\.tray, action: { .tray($0) }\n   )\n) { store in\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: StackState Pop in Reducer\nDESCRIPTION: This code snippet demonstrates how to dismiss a feature by directly manipulating the StackState, using the `popLast()` method within a reducer. This approach requires the reducer to have access to the stack state.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\ncase .closeButtonTapped:\n  state.popLast()\n  return .none\n```\n\n----------------------------------------\n\nTITLE: Referencing Dependencies with Alternative Syntax\nDESCRIPTION: This snippet demonstrates the alternative syntax introduced in swift-dependencies version 1.2 for referencing a dependency, which reduces boilerplate.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.9.md#_snippet_7\n\nLANGUAGE: diff\nCODE:\n```\n-@Dependency(\\.\\apiClient) var apiClient\n+@Dependency(APIClient.self) var apiClient\n```\n\n----------------------------------------\n\nTITLE: Enum-driven Navigation with Key Paths (New API)\nDESCRIPTION: This snippet presents the new approach, replacing the deprecated multi-parameter API with a single store scoped by keypaths to both state and action. The streamlined syntax improves readability and reduces code complexity.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.5.md#_snippet_7\n\nLANGUAGE: Swift\nCODE:\n```\n// ‚úÖ New API\n.sheet(\n  store: store.scope(\n    state: \\.$destination.editForm,\n    action: \\.destination.editForm\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Providing Live Dependency Swift\nDESCRIPTION: This code demonstrates how to provide a live version of the dependency (numberFact) to the Feature reducer within the application's entry point.  It uses URLSession to fetch a number fact from an external API.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\n@main\nstruct MyApp: App {\n  var body: some Scene {\n    WindowGroup {\n      FeatureView(\n        store: Store(initialState: Feature.State()) {\n          Feature(\n            numberFact: { number in\n              let (data, _) = try await URLSession.shared.data(\n                from: URL(string: \"http://numbersapi.com/\\(number)\")!\n              )\n              return String(decoding: data, as: UTF8.self)\n            }\n          )\n        }\n      )\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Reducer Logic for Handling State Changes - Swift\nDESCRIPTION: This code snippet demonstrates how the reducer handles the `isHapticsEnabledChanged` action. When the action is received, it updates the `isHapticsEnabled` property of the state with the provided boolean value. The reducer returns `.none` to indicate that no effects are triggered.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Bindings.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Settings {\n  struct State: Equatable { /* ... */ }\n  enum Action { /* ... */ }\n\n  var body: some Reducer<State, Action> {\n    Reduce { state, action in\n      switch action {\n      case let .isHapticsEnabledChanged(isEnabled):\n        state.isHapticsEnabled = isEnabled\n        return .none\n      // ...\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: NavigationStack with Path Reducer\nDESCRIPTION: This code shows how to use the `NavigationStack` initializer with a path reducer and the `Store.case` computed property to extract stores for each case in the path state.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\nNavigationStack(path: $store.scope(state: \\.path, action: \\.path)) {\n  // Root view\n} destination: { store in\n  switch store.case {\n  case let .add(store):\n    AddView(store: store)\n  case let .detail(store):\n    DetailView(store: store)\n  case let .edit(store):\n    EditView(store: store)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Subscripting Shared State Collection in Swift\nDESCRIPTION: This snippet shows how to subscript into a `Shared` collection (specifically, an `IdentifiedArray`) to derive shared state for a particular element in the array, returning a `Shared<Todo?>`. The result is then unwrapped to create a `Shared<Todo>`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_17\n\nLANGUAGE: swift\nCODE:\n```\n@Shared(.fileStorage(.todos)) var todos: IdentifiedArrayOf<Todo> = []\n\nguard let todo = Shared($todos[id: todoID])\nelse { return }\ntodo // Shared<Todo>\n```\n\n----------------------------------------\n\nTITLE: Handling Lazy View Closures with WithPerceptionTracking\nDESCRIPTION: This example illustrates how to correctly handle lazy view closures, such as those used in `ForEach`, when using `WithPerceptionTracking`. It demonstrates the need to wrap the content of the lazy closure in another `WithPerceptionTracking` view to ensure proper observation of changes.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/ObservationBackport.md#_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nWithPerceptionTracking {\n  ForEach(store.scope(state: \\.rows, action: \\.rows), id: \\.state.id) { store in\n    WithPerceptionTracking {\n      Text(store.title)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Automatic @CasePathable and @dynamicMemberLookup\nDESCRIPTION: Demonstrates that when the Reducer/State of your feature is an enum, the @Reducer macro automatically applies the @CasePathable macro, as well as @dynamicMemberLookup.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_6\n\nLANGUAGE: Swift\nCODE:\n```\n+@CasePathable\n+@dynamicMemberLookup\n enum State {\n   // ...\n }\n```\n\n----------------------------------------\n\nTITLE: Incorrect removeLast() in Non-Exhaustive Test in Swift\nDESCRIPTION: Demonstrates the incorrect usage of `removeLast()` in a non-exhaustive test store. This highlights why relative mutations can lead to failures or crashes because the state is already modified by the reducer before the assertion closure is executed.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_21\n\nLANGUAGE: swift\nCODE:\n```\nstore.exhaustivity = .off\nawait store.send(.removeButtonTapped) {\n  $0.values.removeLast()  // ‚ùå\n}\n```\n\n----------------------------------------\n\nTITLE: Counting Elements in NavigationPath in Swift\nDESCRIPTION: This code snippet shows how to count the number of elements in a `NavigationPath`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_16\n\nLANGUAGE: Swift\nCODE:\n```\npath.count\n```\n\n----------------------------------------\n\nTITLE: Using navigationDestination with NavigationPath in Swift\nDESCRIPTION: This code snippet shows how to use `navigationDestination` with a `NavigationPath` to determine which view should be pushed onto the stack based on the data type.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_14\n\nLANGUAGE: Swift\nCODE:\n```\nstruct RootView: View {\n  @State var path = NavigationPath()\n\n  var body: some View {\n    NavigationStack(path: self.$path) {\n      Form {\n        // ...\n      }\n      .navigationDestination(for: Int.self) { integer in \n        // ...\n      }\n      .navigationDestination(for: String.self) { string in \n        // ...\n      }\n      .navigationDestination(for: Bool.self) { bool in \n        // ...\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using withLock with MainActor - Swift\nDESCRIPTION: This snippet shows how to use `withLock` with `@MainActor`, requiring the use of `await` for its usage. This prevents deadlocks if shared state was read from and written to on different threads.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.11.md#_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n-sharedCount.withLock { $0 += 1 }\n+await sharedCount.withLock { $0 += 1 }\n```\n\n----------------------------------------\n\nTITLE: Automatic @CasePathable Application\nDESCRIPTION: Shows how the `@Reducer` macro automatically applies the `@CasePathable` macro to the `Action` enum. This enables the use of key path syntax for enum cases in the library's APIs.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_5\n\nLANGUAGE: Swift\nCODE:\n```\n+@CasePathable\n enum Action {\n   // ...\n }\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Asynchronous Operations in TCA (Swift)\nDESCRIPTION: This snippet demonstrates how to execute multiple asynchronous operations within a single effect in TCA when no state mutations are needed between them. It shows how to fetch data from multiple API endpoints and then send a single action with the combined result, avoiding unnecessary \"ping-ponging\" of actions.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/FAQ.md#_snippet_3\n\nLANGUAGE: Swift\nCODE:\n```\ncase .refreshButtonTapped:\n  return .run { send in \n    let userResponse = await apiClient.fetchCurrentUser()    \n    let moviesResponse = await apiClient.fetchMovies(userID: userResponse.id)\n    await send(.moviesResponse(moviesResponse))\n  }\n```\n\n----------------------------------------\n\nTITLE: Destination Reducer with Enum State and Action\nDESCRIPTION: Shows a destination reducer pattern with an enum for State and Action. Each case in the enum corresponds to a feature that can be navigated to.  The body defines scoping for each child reducer. This code is verbose and can be simplified with the new @Reducer macro feature.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.8.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Destination {\n  @ObservableState\n  enum State {\n    case add(FormFeature.State)\n    case detail(DetailFeature.State)\n    case edit(EditFeature.State)\n  }\n  enum Action {\n    case add(FormFeature.Action)\n    case detail(DetailFeature.Action)\n    case edit(EditFeature.Action)  \n  }\n  var body: some ReducerOf<Self> {\n    Scope(state: \\.add, action: \\.add) {\n      FormFeature()\n    }\n    Scope(state: \\.detail, action: \\.detail) {\n      DetailFeature()\n    }\n    Scope(state: \\.edit, action: \\.edit) {\n      EditFeature()\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Type-safe appStorage key example in Swift\nDESCRIPTION: This snippet shows how to create a type-safe `.appStorage` key for an integer value. It defines a static variable `count` constrained to `AppStorageKey<Int>`, associating the AppStorage key \"count\" with an integer type.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_42\n\nLANGUAGE: swift\nCODE:\n```\nextension SharedReaderKey where Self == AppStorageKey<Int>> {\n  static var count: Self {\n    appStorage(\"count\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: TestStore with ImmediateClock Dependency in Swift\nDESCRIPTION: This demonstrates how to provide an ImmediateClock dependency to the TestStore. This ensures that the timer effect executes without any actual delay, making the test run much faster.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\nlet store = TestStore(initialState: Feature.State(count: 0)) {\n  Feature()\n} withDependencies: {\n  $0.continuousClock = ImmediateClock()\n}\n```\n\n----------------------------------------\n\nTITLE: Synthesizing Protocol Conformances\nDESCRIPTION: This code shows how to extend the generated State type to synthesize protocol conformances like `Equatable`. This is required because the `State` type is automatically generated when using `@Reducer` on an enum.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nenum Destination {\n  // ...\n}\nextension Destination.State: Equatable {}\n```\n\n----------------------------------------\n\nTITLE: Collapsing PresentationAction's 'presented' Case\nDESCRIPTION: This snippet shows how the `presented` case of a `PresentationAction` can be collapsed for a more concise syntax when sending actions.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.9.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n-store.send(.destination(.presented(.tap)))\n+store.send(\\.\\destination.tap)\n```\n\n----------------------------------------\n\nTITLE: Weakened Assertion on Count in Non-Exhaustive Test in Swift\nDESCRIPTION: Shows how to weaken assertions in non-exhaustive tests by only asserting on the count of elements rather than the content of the elements.  This avoids the need for precise state mutation replication in the test.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_23\n\nLANGUAGE: swift\nCODE:\n```\nstore.exhaustivity = .off\nawait store.send(.removeButtonTapped) {\n  XCTAssertEqual($0.values.count, 0)\n}\n```\n\n----------------------------------------\n\nTITLE: UIKit Trait-Based Navigation\nDESCRIPTION: This code snippet demonstrates how to use the new `push` endpoint on `traitCollection` to navigate based on trait collections by pushing an element of `StackState`. It takes a `state` parameter, allowing for pushing a specific state, such as a detail view, onto the navigation stack.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.18.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\ntraitCollection.push(state: Path.State.detail(/* ... */))\n```\n\n----------------------------------------\n\nTITLE: Testing feature with shared state using TestStore in Swift\nDESCRIPTION: This snippet demonstrates testing a feature (Feature1) that uses shared state (@Shared). It sends an action (.feature1(.buttonTapped)) to the store and asserts that the count in feature1's state is incremented to 1.  It illustrates a basic assertion on a single feature's shared state.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_31\n\nLANGUAGE: swift\nCODE:\n```\nawait store.send(.feature1(.buttonTapped)) {\n  $0.feature1.count = 1\n}\n```\n\n----------------------------------------\n\nTITLE: Presenting a View from Ignored Case\nDESCRIPTION: This code shows how to present a view from an ignored case in a destination reducer. It uses `Store.withState` to access the state without observation because the value held in the ignored case does not have the `ObservableState` macro applied.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\n.sheet(item: $store.scope(state: \\.destination?.item, action: \\.destination.item)) { store in\n  ItemView(item: store.withState { $0 })\n}\n```\n\n----------------------------------------\n\nTITLE: Observing Shared State Changes with Publisher in Swift\nDESCRIPTION: This code snippet demonstrates how to observe changes to a shared state variable using the `publisher` property exposed by the `@Shared` property wrapper. It creates an effect that subscribes to changes in the `count` state and emits a `countUpdated` action.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\ncase .onAppear:\n  return .publisher {\n    state.$count.publisher\n      .map(Action.countUpdated)\n  }\n\ncase .countUpdated(let count):\n  // Do something with count\n  return .none\n```\n\n----------------------------------------\n\nTITLE: Providing Mock Dependency Swift\nDESCRIPTION: This code shows how to provide a mock implementation of the dependency (numberFact) in a test. This allows for controlling the behavior of the dependency and writing deterministic tests. It provides a hardcoded string that is based on the input number.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\n@Test\nfunc basics() async {\n  let store = TestStore(initialState: Feature.State()) {\n    Feature(numberFact: { \"\\($0) is a good number Brent\" })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Destination Reducer (Traditional)\nDESCRIPTION: This code defines a destination reducer with explicit State, Action enums, and Scopes for each case. This requires manual definition of state and action cases for each navigable feature, along with scoping in the reducer body.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Destination {\n  @ObservableState\n  enum State {\n    case add(FormFeature.State)\n    case detail(DetailFeature.State)\n    case edit(EditFeature.State)\n  }\n  enum Action {\n    case add(FormFeature.Action)\n    case detail(DetailFeature.Action)\n    case edit(EditFeature.Action)\n  }\n  var body: some ReducerOf<Self> {\n    Scope(state: \\.add, action: \\.add) {\n      FormFeature()\n    }\n    Scope(state: \\.detail, action: \\.detail) {\n      DetailFeature()\n    }\n    Scope(state: \\.edit, action: \\.edit) {\n      EditFeature()\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Failing Test with showSkippedAssertions in Swift\nDESCRIPTION: Demonstrates a test that fails when `showSkippedAssertions` is set to `true` in a non-exhaustive test store. This highlights the issue of side effects occurring twice due to the assertion closure being invoked multiple times.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_26\n\nLANGUAGE: swift\nCODE:\n```\n@Test\nfunc add() async {\n  let store = TestStore(initialState: Feature.State()) {\n    Feature()\n  } withDependencies: {\n    $0.uuid = .incrementing\n  }\n  store.exhaustivity = .off(showSkippedAssertions: true)\n\n  await store.send(.addButtonTapped) {\n    $0.values = [Model()]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Presenting Child Features in UIKit with TCA\nDESCRIPTION: This snippet shows how to present a child view controller when the `child` state of a feature becomes non-`nil` using the `present(item:)` API. It utilizes the `scope` function to derive a store for the child feature.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.13.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@UIBindable var store: StoreOf<Feature>\n\nfunc viewDidLoad() {\n  super.viewDidLoad()\n\n  present(item: $store.scope(state: \\.child, action: \\.child)) { store in\n    ChildViewController(store: store)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Race Condition Example with Shared State in Swift\nDESCRIPTION: This snippet illustrates a potential race condition that can still occur when mutating shared state even with the `withLock` method if the value is read outside the lock before being updated.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_19\n\nLANGUAGE: swift\nCODE:\n```\nlet currentCount = state.count\nstate.$count.withLock { $0 = currentCount + 1 }\n```\n\n----------------------------------------\n\nTITLE: Overriding Shared State Again in Tests (Workaround)\nDESCRIPTION: This code shows a workaround for potential issues with early access to `@Shared` state, especially in app targets. It sets the shared state again after the initial declaration to ensure that the desired value overrides any potentially conflicting value set by the app target. This approach avoids accidental initializations that can interfere with test setup.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_28\n\nLANGUAGE: swift\nCODE:\n```\n@Test\nfunc basics() {\n  @Shared(.appStorage(\"count\")) var count = 42\n  count = 42  // NB: Set again to override any value set by the app target.\n\n  // Shared state will be 42 for all features using it.\n  let store = TestStore(‚Ä¶)\n}\n```\n\n----------------------------------------\n\nTITLE: Persisting Simple Data Types to User Defaults in Swift\nDESCRIPTION: This snippet illustrates how to store simple data types in user defaults using the `.appStorage` persistence strategy within the `@Shared` property wrapper.  The value associated with the key \"isOn\" in user defaults will be synchronized with the `isOn` property. Any changes to `isOn` will be automatically persisted to user defaults and loaded upon app launch.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.10.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@ObservableState \nstruct State {\n  @Shared(.appStorage(\"isOn\")) var isOn = false\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Subscripting IdentifiedAction and StackAction\nDESCRIPTION: This snippet illustrates how `IdentifiedAction` and `StackAction` can be subscripted into for cleaner action sending syntax.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.9.md#_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\n-store.send(.path(.element(id: 0, action: .tap)))\n+store.send(\\.\\path[id: 0].tap)\n```\n\n----------------------------------------\n\nTITLE: Actions for Each State Field - Swift\nDESCRIPTION: Defines an enum of actions within the Settings reducer, with a case for each field in the state that can be modified. Each case takes a parameter of the corresponding field's type. These actions are used to update the state from the view.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Bindings.md#_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Settings {\n  @ObservableState\n  struct State { /* ... */ }\n\n  enum Action {\n    case digestChanged(Digest)\n    case displayNameChanged(String)\n    case enableNotificationsChanged(Bool)\n    case protectMyPostsChanged(Bool)\n    case sendEmailNotificationsChanged(Bool)\n    case sendMobileNotificationsChanged(Bool)\n  }\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Assertion of Shared State Mutation\nDESCRIPTION: Demonstrates an incorrect approach to asserting the shared state mutation. It attempts to assert the state change within the `response` action's `receive` block, which fails due to the `TestStore` eagerly processing the action before the assertion.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_49\n\nLANGUAGE: swift\nCODE:\n```\n// ‚ùå State was not expected to change, but a change occurred: ‚Ä¶\n//\n//     Feature.State(\n//   -   _shared: #1 false\n//   +   _shared: #1 true\n// \t   )\n//\n// (Expected: ‚àí, Actual: +)\nawait store.send(.tap)\n\n// ‚ùå Expected state to change, but no change occurred.\nawait store.receive(.response) {\n  $0.$shared.withLock { $0 = true }\n}\n```\n\n----------------------------------------\n\nTITLE: forEach with key path Swift\nDESCRIPTION: This snippet demonstrates how to use `forEach` with key path syntax for `IdentifiedAction`.  It requires the `@Reducer` macro to be applied to the feature.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.4.md#_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\nReduce { state, action in \n  // ...\n}\n.forEach(\\.\\rows, action: \\.rows) {\n  RowFeature()\n}\n```\n\n----------------------------------------\n\nTITLE: Using @SharedReader for read-only shared state in Swift\nDESCRIPTION: This snippet demonstrates using `@SharedReader` for defining a read-only piece of shared state. It shows how to declare a property using `@SharedReader` and highlights the compiler error that occurs when attempting to mutate a `@SharedReader` property.  This enforces read-only access to specific shared data.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_34\n\nLANGUAGE: swift\nCODE:\n```\n@SharedReader(.appStorage(\"isOn\")) var isOn = false\nisOn = true  // üõë\n```\n\n----------------------------------------\n\nTITLE: Potential Race Condition Example - Swift\nDESCRIPTION: This snippet illustrates a potential race condition that can still occur even with `withLock` if the value is read outside the lock. It highlights the importance of wrapping as many mutations as possible in a single `withLock` block.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.11.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nlet currentCount = count\n$count.withLock { $0 = currentCount + 1 }\n```\n\n----------------------------------------\n\nTITLE: Invalid Action After Dismiss\nDESCRIPTION: This code snippet highlights an anti-pattern in Composable Architecture: sending an action after invoking `dismiss()`. This is invalid because the feature's state is no longer present in the stack after dismissal, leading to runtime warnings and test failures.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nreturn .run { send in \n  await self.dismiss()\n  await send(.tick)  // ‚ö†Ô∏è\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Complex State Transformations with Computed Properties\nDESCRIPTION: This code snippet demonstrates how to handle state transformations that require additional logic by moving the logic into a computed property on the state. This allows for using key paths in the `scope` function.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.5.md#_snippet_3\n\nLANGUAGE: Swift\nCODE:\n```\nChildView(\n  store: store.scope(\n    state: { ChildFeature(state: $0.child) },\n    action: { .child($0) }\n  )\n)\n```\n\nLANGUAGE: Swift\nCODE:\n```\nextension State {\n  var childFeature: ChildFeature {\n    ChildFeature(state: self.child)\n  }\n}\n```\n\nLANGUAGE: Swift\nCODE:\n```\nChildView(\n  store: store.scope(\n    state: \\.childFeature,\n    action: \\.child\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Receiving StackAction/popFrom with TestStore in Swift\nDESCRIPTION: This snippet demonstrates how to use TestStore to assert that a StackAction.popFrom action is received, indicating that a child feature has been dismissed from the stack.  It checks that the child feature at ID 0 is set to nil in the path.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\nawait store.receive(\\.path.popFrom) {\n  $0.path[id: 0] = nil\n}\n```\n\n----------------------------------------\n\nTITLE: Reducer Logic with Binding Action Pattern Matching - Swift\nDESCRIPTION: This snippet shows how to intercept specific binding actions within the reducer for additional logic, such as validation or side effects. It uses pattern matching on the `action` to identify `binding` actions targeting specific key paths.  This allows for adding custom behavior on top of the automatic binding handling.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Bindings.md#_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\nvar body: some Reducer<State, Action> {\n  BindingReducer()\n\n  Reduce { state, action in\n    switch action\n    case .binding(\\.displayName):\n      // Validate display name\n  \n    case .binding(\\.enableNotifications):\n      // Return an effect to request authorization from UNUserNotificationCenter\n  \n    // ...\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sharing Logic Before Core Logic\nDESCRIPTION: This snippet illustrates the flexibility of using methods for shared logic, allowing you to execute the shared logic before the core logic if necessary.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Performance.md#_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\ncase .buttonTapped:\n  let sharedEffect = self.sharedComputation(state: &state)\n  state.count += 1\n  return sharedEffect\n```\n\n----------------------------------------\n\nTITLE: Exhaustive Integration Test Example Swift\nDESCRIPTION: This code snippet demonstrates an exhaustive integration test for a login flow in a tab-based application using the Composable Architecture. It shows how to emulate user actions, assert on state changes within the login feature, handle API responses, and verify the final state change of switching the selected tab to activity after a successful login. The test requires detailed knowledge of the login feature's internal workings and can become fragile if the feature's logic changes.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\nlet store = TestStore(initialState: AppFeature.State()) {\n  AppFeature()\n}\n\n// 1Ô∏è‚É£ Emulate user tapping on submit button.\nawait store.send(\\.\\login.submitButtonTapped) {\n  // 2Ô∏è‚É£ Assert how all state changes in the login feature\n  $0.login?.isLoading = true\n  // ...\n}\n\n// 3Ô∏è‚É£ Login feature performs API request to login, and\n//    sends response back into system.\nawait store.receive(\\.\\login.loginResponse.success) {\n// 4Ô∏è‚É£ Assert how all state changes in the login feature\n  $0.login?.isLoading = false\n  // ...\n}\n\n// 5Ô∏è‚É£ Login feature sends a delegate action to let parent\n//    feature know it has successfully logged in.\nawait store.receive(\\.\\login.delegate.didLogin) {\n// 6Ô∏è‚É£ Assert how all of app state changes due to that action.\n  $0.authenticatedTab = .loggedIn(\n    Profile.State(...)\n  )\n  // ...\n  // 7Ô∏è‚É£ *Finally* assert that the selected tab switches to activity.\n  $0.selectedTab = .activity\n}\n```\n\n----------------------------------------\n\nTITLE: Destructuring old style action Swift\nDESCRIPTION: This snippet shows the necessary change in destructuring the old-style action to include a `.element` layer when using `IdentifiedAction`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.4.md#_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\n-case let .row(id: id, action: .buttonTapped):\n+case let .rows(.element(id: id, action: .buttonTapped)):\n```\n\n----------------------------------------\n\nTITLE: Defining NumberFactClient (Swift)\nDESCRIPTION: Defines a `NumberFactClient` struct to encapsulate the number fact functionality. This client has a `fetch` property, which is a closure that takes an integer and asynchronously returns a string. It serves as an abstraction layer for the number fact API.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_16\n\nLANGUAGE: swift\nCODE:\n```\nstruct NumberFactClient {\n  var fetch: (Int) async throws -> String\n}\n```\n\n----------------------------------------\n\nTITLE: SwiftUI Toggle with Binding to Store - Swift\nDESCRIPTION: This snippet demonstrates how to create a SwiftUI Toggle that binds to the `isHapticsEnabled` state in the store. The `.sending` method transforms the binding mutation into the corresponding action (`.isHapticsEnabledChanged`) to be sent to the store.  This establishes the two-way binding between the view and the store.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Bindings.md#_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nvar body: some View {\n  Form {\n    Toggle(\n      \"Haptic feedback\",\n      isOn: $store.isHapticsEnabled.sending(\\.isHapticsEnabledChanged)\n    )\n\n    // ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Pinning Sharing to an older version using Swift Package Manager\nDESCRIPTION: This code snippet demonstrates how to explicitly add a dependency on the Sharing library to pin it to a version less than 2.0 using the Swift Package Manager. This is useful if you are not ready to migrate to Sharing 2.0 and want to maintain compatibility with older persistence strategies. It ensures that your project uses a specific version of the Sharing library.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.17.1.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\n.package(url: \"https://github.com/pointfreeco/swift-sharing\", from: \"0.1.0\"),\n```\n\n----------------------------------------\n\nTITLE: Reducer Example with removeLast() in Swift\nDESCRIPTION: Shows a simple reducer that removes the last element from an array. This is used to illustrate the differences between exhaustive and non-exhaustive testing and the limitations of relative mutations in non-exhaustive tests.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_20\n\nLANGUAGE: swift\nCODE:\n```\ncase .removeButtonTapped:\n  state.values.removeLast()\n  return .none\n```\n\n----------------------------------------\n\nTITLE: Defining SwiftUI Feature View Swift\nDESCRIPTION: This code defines a SwiftUI view that displays the Feature's state and sends actions to the store. It uses a Form to organize the UI elements, including Text for displaying the count and fact, and Buttons for triggering actions.  The view observes state changes through the `store` property.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nstruct FeatureView: View {\n  let store: StoreOf<Feature>\n\n  var body: some View {\n    Form {\n      Section {\n        Text(\"\\(store.count)\")\n        Button(\"Decrement\") { store.send(.decrementButtonTapped) }\n        Button(\"Increment\") { store.send(.incrementButtonTapped) }\n      }\n\n      Section {\n        Button(\"Number fact\") { store.send(.numberFactButtonTapped) }\n      }\n      \n      if let fact = store.numberFact {\n        Text(fact)\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Dismissing a Presented Feature in TCA\nDESCRIPTION: This snippet shows how to dismiss a presented feature by setting the state representing the presented feature to `nil`. This is a simple way to close or remove a feature that is currently being presented.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\ncase .closeButtonTapped:\n  state.destination = nil\n  return .none\n```\n\n----------------------------------------\n\nTITLE: Receiving action with key path syntax in TestStore Swift\nDESCRIPTION: This code snippet demonstrates the new, simplified way to assert on actions received in a TestStore using key path syntax.  It relies on the `@CasePathable` macro being applied to the action enum.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.4.md#_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nstore.receive(\\.\\child.presented.response.success)\n```\n\nLANGUAGE: swift\nCODE:\n```\nstore.receive(\\.\\child.response.success)\n```\n\n----------------------------------------\n\nTITLE: Store Scoping with Closures (Deprecated)\nDESCRIPTION: This code snippet illustrates the deprecated method of scoping a store using closures to transform state and actions. It showcases how to pass in a state transformation closure and an action transformation closure to the scope function.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.5.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\nstore.scope(\n  state: (State) -> ChildState,\n  action: (ChildAction) -> Action\n)\n```\n\n----------------------------------------\n\nTITLE: Counter Feature Reducer with Dismissal\nDESCRIPTION: This snippet showcases a simple counter feature with the ability to dismiss itself when the count reaches 5. It uses the `DismissEffect` dependency to trigger dismissal when the increment button is tapped and the count is greater than or equal to 5.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_16\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct CounterFeature {\n  @ObservableState\n  struct State: Equatable {\n    var count = 0\n  }\n  enum Action {\n    case decrementButtonTapped\n    case incrementButtonTapped\n  }\n\n  @Dependency(\\.dismiss) var dismiss\n\n  var body: some Reducer<State, Action> {\n    Reduce { state, action in\n      switch action {\n      case .decrementButtonTapped:\n        state.count -= 1\n        return .none\n\n      case .incrementButtonTapped:\n        state.count += 1\n        return state.count >= 5\n          ? .run { _ in await self.dismiss() }\n          : .none\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: TestStore Initialization for TCA Feature\nDESCRIPTION: This snippet demonstrates initializing a `TestStore` for the `Feature` reducer with an initial state where the counter is already set to 3. This setup is crucial for testing how the parent feature interacts with the child counter feature.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_18\n\nLANGUAGE: swift\nCODE:\n```\n@Test\nfunc dismissal() {\n  let store = TestStore(\n    initialState: Feature.State(\n      counter: CounterFeature.State(count: 3)\n    )\n  ) {\n    CounterFeature()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: DismissEffect Usage in Reducer\nDESCRIPTION: This code snippet demonstrates how to use `DismissEffect` from the Composable Architecture to dismiss a feature from within a reducer.  It showcases the usage of the dependency management system and the `Effect.run` to perform the asynchronous dismissal operation.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  @ObservableState\n  struct State { /* ... */ }\n  enum Action { \n    case closeButtonTapped\n    // ...\n  }\n  @Dependency(\\.dismiss) var dismiss\n  var body: some Reducer<State, Action> {\n    Reduce { state, action in\n      switch action {\n      case .closeButtonTapped:\n        return .run { _ in await self.dismiss() }\n      // ...\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Enum Reducers\nDESCRIPTION: This code shows how to nest enum reducers. The parent enum reducer must specify the child's `Body` associated value and `body` static property explicitly.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_17\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nenum Modal { /* ... */ }\n\n@Reducer\nenum Destination {\n  case modal(Modal.Body = Modal.body)\n}\n```\n\n----------------------------------------\n\nTITLE: Using @ObservableState (iOS 16 and Below)\nDESCRIPTION: Shows how to update an existing feature by marking the State with the @ObservableState macro, deleting the ViewState type, replacing WithViewStore with WithPerceptionTracking, and accessing/sending to the store directly. This approach is compatible with older iOS versions (iOS 16 and below).\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n @Reducer\n struct Feature {\n+  @ObservableState\n  struct State { /* ... */ }\n  enum Action { /* ... */ }\n  var body: some ReducerOf<Self> {\n    // ...\n  }\n}\n \nstruct FeatureView: View {\n  let store: StoreOf<Feature>\n \n-  struct ViewState: Equatable {\n-    // ...\n-    init(state: Feature.State) { /* ... */ }\n-  }\n \n  var body: some View {\n-    WithViewStore(store, observe: ViewState.init) { viewStore in\n+    WithPerceptionTracking {\n      Form {\n-        Text(viewStore.count.description)\n-        Button(\"+\") { viewStore.send(.incrementButtonTapped) }\n+        Text(store.count.description)\n+        Button(\"+\") { store.send(.incrementButtonTapped) }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Test Store Actions with Case Key Paths\nDESCRIPTION: This snippet demonstrates the new `TestStore/send` method introduced in version 1.9 for sending actions to test stores via case key paths. It simplifies integration-style tests with deeply-nested actions.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.9.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n-store.send(.path(.element(id: 0, action: .destination(.presented(.record(.startButtonTapped))))))\n+store.send(\\.\\path[id: 0].destination.record.startButtonTapped)\n store.receive(\\.\\path[id: 0].destination.record.timerTick)\n```\n\n----------------------------------------\n\nTITLE: UserDefaults Animation Limitation (Swift)\nDESCRIPTION: Demonstrates a limitation where changes made directly to UserDefaults using `UserDefaults.standard.set` within an animation block will not animate SwiftUI views that are using `@Shared(.appStorage(...))` with that UserDefaults key.  This is due to the thread hop required when using `NotificationCenter` to observe changes.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.16.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nwithAnimation {\n  // ‚ö†Ô∏è This will not animate any SwiftUI views using '@Shared(.appStorage(\"co.pointfree.count\"))'\n  UserDefaults.standard.set(0, forKey: \"co.pointfree.count\")\n}\n```\n\n----------------------------------------\n\nTITLE: Reducer ifLet Operator with Destination Reducer\nDESCRIPTION: This code demonstrates using the `ifLet` operator with a destination reducer created with the `@Reducer` macro. The trailing closure can be omitted, as it can be automatically inferred, further simplifying the reducer composition.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\n Reduce { state, action in\n   // Core feature logic\n }\n .ifLet(\\.destination, action: \\.destination)\n-{\n-  Destination()\n-}\n```\n\n----------------------------------------\n\nTITLE: Synthesizing Protocol Conformances (Swift < 6 Workaround)\nDESCRIPTION: This code presents a workaround for a Swift compiler bug (Swift < 6) when synthesizing protocol conformances on the `State` and `Action` types. It uses the `@Reducer` macro with ``ComposableArchitecture/_SynthesizedConformance`` arguments.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_16\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer(state: .equatable, .sendable, action: .sendable)\nenum Destination {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Receiving Action from TestStore without Timeout in Swift\nDESCRIPTION: This simplifies the `store.receive` assertions by removing the timeout argument. Since the ImmediateClock is used, the timer effect executes instantly, and the actions are received immediately, eliminating the need for a timeout.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\nawait store.receive(\\.timerTick) {\n  $0.count = 1\n}\nawait store.receive(\\.timerTick) {\n  $0.count = 2\n}\nawait store.receive(\\.timerTick) {\n  $0.count = 3\n}\nawait store.receive(\\.timerTick) {\n  $0.count = 4\n}\nawait store.receive(\\.timerTick) {\n  $0.count = 5\n}\n```\n\n----------------------------------------\n\nTITLE: Observing Store Changes in UIKit Swift\nDESCRIPTION: This demonstrates how to observe changes in the store within a UIKit view controller using the `observe` method, replacing the older Combine-based approach for subscribing to store updates.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_18\n\nLANGUAGE: swift\nCODE:\n```\nfunc viewDidLoad() {\n  super.viewDidLoad()\n\n  store.publisher.count\n    .sink { [weak self] in self?.countLabel.text = \"\\($0)\" }\n    .store(in: &cancellables)\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nfunc viewDidLoad() {\n  super.viewDidLoad()\n\n  observe { [weak self] in \n    guard let self \n    else { return }\n\n    self.countLabel.text = \"\\(self.store.count)\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Onboarding Game Logic in TCA (Swift)\nDESCRIPTION: This snippet demonstrates how to intercept actions in a TCA reducer to implement complex onboarding logic in a word game. It showcases how to inspect the user's action and the current onboarding step to determine the next step, leveraging the enum representation of actions in TCA. This example also illustrates how this logic can be 100% unit testable.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/FAQ.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\ncase .game(.submitButtonTapped):\n  switch state.step {\n  case\n    .step5_SubmitGame where state.game.selectedWordString == \"GAME\",\n    .step8_FindCubes where state.game.selectedWordString == \"CUBES\",\n    .step12_CubeIsShaking where state.game.selectedWordString == \"REMOVE\",\n    .step16_FindAnyWord where dictionary.contains(state.game.selectedWordString, .en):\n\n  state.step.next()\n```\n\n----------------------------------------\n\nTITLE: Modified Model Definition without UUID Dependency in Swift\nDESCRIPTION: Shows how to modify the `Model` struct to accept the UUID as an initializer parameter.  This avoids the issue of the `@Dependency` being accessed within the model's initializer, preventing side effects during the assertion closure invocations.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_27\n\nLANGUAGE: swift\nCODE:\n```\nstruct Model: Equatable {\n  let id: UUID\n  init(id: UUID) {\n    self.id = id\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving Shared State for Child Feature in Swift\nDESCRIPTION: This snippet demonstrates how a parent feature derives a small piece of shared state (the `phoneNumber`) from a larger `Shared<SignUpData>` and passes it to the child feature's state. This allows the child feature to hold onto only the necessary shared data.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_16\n\nLANGUAGE: swift\nCODE:\n```\ncase .nextButtonTapped:\n  state.path.append(\n    PhoneNumberFeature.State(phoneNumber: state.$signUpData.phoneNumber)\n  )\n```\n\n----------------------------------------\n\nTITLE: Defining Tree-Based Navigation Using Presents Macro in DetailItemFeature\nDESCRIPTION: This code snippet defines the nested detail screen, demonstrating tree-based navigation using the `@Presents` macro to present an edit screen as a sheet.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/WhatIsNavigation.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct DetailItemFeature {\n  @ObservableState\n  struct State {\n    @Presents var editItem: EditItemFeature.State?\n    // ...\n  }\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Perceptible Class\nDESCRIPTION: This code snippet demonstrates how to define a perceptible class using the `@Perceptible` macro from the Perception framework. It creates a simple `CounterModel` class with a `count` property that can be observed for changes.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/ObservationBackport.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Perceptible\nclass CounterModel {\n  var count = 0\n}\n```\n\n----------------------------------------\n\nTITLE: TabView Binding with Store Swift\nDESCRIPTION: This shows how to bind directly to a Store's state using `@Bindable` and the `sending` method. This simplifies the binding process when the state is observable.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\n@Bindable var store: StoreOf<Feature>\n\n```\n\nLANGUAGE: swift\nCODE:\n```\nTabView(selection: $store.tab.sending(\\.tabChanged)) {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Enum-Based State Changes in TCA\nDESCRIPTION: This snippet showcases how to assert on state changes when using enum state to model multiple destinations. To mutate a specific enum case, you must chain into the particular case to make the desired mutation.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_22\n\nLANGUAGE: swift\nCODE:\n```\nawait store.send(\\.destination.counter.incrementButtonTapped) {\n  \\$0.destination?.counter?.count = 4\n}\n```\n\n----------------------------------------\n\nTITLE: Using @Dependency Swift\nDESCRIPTION: This code demonstrates how to use the `@Dependency` property wrapper to access the registered dependency within the Feature reducer.  This eliminates the need to explicitly pass the dependency when constructing the reducer.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_17\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n-  let numberFact: (Int) async throws -> String\n+  @Dependency(\\.numberFact) var numberFact\n   \n   ‚Ä¶\n\n-  try await self.numberFact(count)\n+  try await self.numberFact.fetch(count)\n}\n```\n\n----------------------------------------\n\nTITLE: SwiftUI View Dismissal\nDESCRIPTION: This code snippet illustrates how to dismiss a view in SwiftUI using the `@Environment(\\.\\dismiss)` property wrapper. This allows a child view to dismiss itself from the navigation stack without explicit communication with the parent view.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nstruct ChildView: View {\n  @Environment(\\.dismiss) var dismiss\n  var body: some View {\n    Button(\"Close\") { self.dismiss() }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Dependency with DependencyKey (Swift)\nDESCRIPTION: Demonstrates how to register the `NumberFactClient` with the dependency management system using the `DependencyKey` protocol. It provides a `liveValue` which is used when the application is running in simulators or on devices. Also shows how to extend `DependencyValues` to provide easy access to the dependency.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_17\n\nLANGUAGE: swift\nCODE:\n```\nextension NumberFactClient: DependencyKey {\n  static let liveValue = Self(\n    fetch: { number in\n      let (data, _) = try await URLSession.shared\n        .data(from: URL(string: \"http://numbersapi.com/\\(number)\")!\n      )\n      return String(decoding: data, as: UTF8.self)\n    }\n  )\n}\n\nextension DependencyValues {\n  var numberFact: NumberFactClient {\n    get { self[NumberFactClient.self] }\n    set { self[NumberFactClient.self] = newValue }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Annotating Feature struct with @Reducer macro Swift\nDESCRIPTION: This snippet demonstrates how to annotate a Feature struct with the `@Reducer` macro, which automatically applies the `@CasePathable` macro to the feature's Action enum.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.4.md#_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Marking a View Property as @MainActor in Swift\nDESCRIPTION: This code snippet demonstrates how to resolve potential compilation errors in Xcode < 16 when accessing a `store` property within a SwiftUI view that uses strict concurrency settings.  It involves marking the view property (e.g., `title`) with the `@MainActor` attribute to ensure it runs on the main thread, aligning with the @MainActor-isolated `Store` type.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.14.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\n struct FeatureView: View {\n   let store: StoreOf<Feature>\n \n   var body: some View {\n     // ...\n   }\n \n+  @MainActor\n   var title: some View {\n     Text(store.name)\n   }\n }\n```\n\n----------------------------------------\n\nTITLE: Initializing TestStore Swift\nDESCRIPTION: This code snippet shows how to initialize a TestStore in Swift using the initial state and the Feature reducer.  It sets up the basic structure for testing a feature built with the Composable Architecture.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\n@Test\nfunc basics() async {\n  let store = TestStore(initialState: Feature.State()) {\n    Feature()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a SwiftUI View\nDESCRIPTION: This snippet defines a SwiftUI view for the feature. It holds a `StoreOf<Feature>` to observe state changes and send actions. The view includes buttons for incrementing, decrementing, and fetching a number fact, along with a text field to display the fact.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nstruct FeatureView: View {\n  let store: StoreOf<Feature>\n\n  var body: some View {\n    Form {\n      Section {\n        Text(\"\\(store.count)\")\n        Button(\"Decrement\") { store.send(.decrementButtonTapped) }\n        Button(\"Increment\") { store.send(.incrementButtonTapped) }\n      }\n\n      Section {\n        Button(\"Number fact\") { store.send(.numberFactButtonTapped) }\n      }\n      \n      if let fact = store.numberFact {\n        Text(fact)\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Reducer Logic with onChange(of:_:) - Swift\nDESCRIPTION: This snippet demonstrates how to use the `onChange(of:_:)` method to react to changes in specific fields of the state. This provides an alternative way to trigger additional logic or side effects when a binding is updated.  It can be used for validation or to perform other operations.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Bindings.md#_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\nvar body: some Reducer<State, Action> {\n  BindingReducer()\n    .onChange(of: \\.displayName) { oldValue, newValue in\n      // Validate display name\n    }\n    .onChange(of: \\.enableNotifications) { oldValue, newValue in\n      // Return an authorization request effect\n    }\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Shared State Mutation in an Effect (Correct)\nDESCRIPTION: This test shows the correct way to test shared state when it's mutated within an effect.  It uses `TestStore.assert` to explicitly assert on the final shared state after the action is sent and the effect has run. The `$0.$count.withLock { $0 = 1 }` verifies the expected state change caused by the effect.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_25\n\nLANGUAGE: swift\nCODE:\n```\n@Test\nfunc increment() async {\n  let store = TestStore(initialState: SimpleFeature.State(count: Shared(0))) {\n    SimpleFeature()\n  }\n  await store.send(.incrementButtonTapped)\n  store.assert {\n    $0.$count.withLock { $0 = 1 }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Feature State Swift\nDESCRIPTION: This code defines the state for the Feature reducer.  It includes a count, which is an integer, and a numberFact, which is an optional string. The `@ObservableState` macro is applied to enable observation tools.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  @ObservableState\n  struct State: Equatable {\n    var count = 0\n    var numberFact: String?\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enum with @CasePathable and @dynamicMemberLookup Swift\nDESCRIPTION: This code shows explicit usage of `@CasePathable` and `@dynamicMemberLookup` for delegate state and action enums, which allows case key path syntax to be used.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.4.md#_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\n@CasePathable\nenum DelegateAction {\n  case didFinish(success: Bool)\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n@CasePathable\n@dynamicMemberLookup\nenum DestinationState {\n  case tray(Tray.State)\n}\n```\n\n----------------------------------------\n\nTITLE: Testing State Changes with TestStore (Swift)\nDESCRIPTION: Illustrates how to use `TestStore` to assert state changes after sending actions. The example simulates tapping increment and decrement buttons and asserts that the `count` state is updated accordingly. It showcases the use of `store.send` to dispatch actions and verify expected state changes.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\n// Test that tapping on the increment/decrement buttons changes the count\nawait store.send(.incrementButtonTapped) {\n  $0.count = 1\n}\nawait store.send(.decrementButtonTapped) {\n  $0.count = 0\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Absolute Mutation in Non-Exhaustive Test in Swift\nDESCRIPTION: Illustrates the correct way to perform assertions in non-exhaustive tests using absolute mutations. Instead of relative mutations like `removeLast()`, the entire collection is replaced with its final expected value.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_22\n\nLANGUAGE: swift\nCODE:\n```\nstore.exhaustivity = .off\nawait store.send(.removeButtonTapped) {\n  $0.values = []\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Non-Persisted Shared State (Parent Feature) in Swift\nDESCRIPTION: This snippet shows how to initialize shared state that is not persisted (no argument passed to `@Shared`) and whose source of truth resides in the parent feature. The initializer takes a `Shared` value and assigns it to the underscored property.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\npublic struct State {\n  @Shared public var count: Int\n  // other fields\n\n  public init(count: Shared<Int>, /* other fields */) {\n    self._count = count\n    // other assignments\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Actions and Asserting State Changes in TestStore\nDESCRIPTION: This code showcases how to send actions to the `TestStore` to simulate user interactions and assert that the state changes as expected. It demonstrates sending the `incrementButtonTapped` action and verifies that the counter's count is updated correctly.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_19\n\nLANGUAGE: swift\nCODE:\n```\nawait store.send(\\.counter.incrementButtonTapped) {\n  \\$0.counter?.count = 4\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nawait store.send(\\.counter.incrementButtonTapped) {\n  \\$0.counter?.count = 5\n}\n```\n\n----------------------------------------\n\nTITLE: Updating alert and confirmationDialog SwiftUI\nDESCRIPTION: This example shows how to update `alert(store:)` with the new `alert(_:)` modifier in SwiftUI. The key change involves using a store binding scope operation similar to `sheet(item:)`. The `alert(store:)` is replaced with `alert($store.scope(state: \\.alert, action: \\.alert))`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n.alert(store: store.scope(state: \\.$alert, action: \\.alert))\n```\n\nLANGUAGE: swift\nCODE:\n```\n.alert($store.scope(state: \\.alert, action: \\.alert))\n```\n\n----------------------------------------\n\nTITLE: Custom Binding Logic with Store Extension Swift\nDESCRIPTION: This example demonstrates how to define custom `get`-`set` properties (or subscripts) on the store to encapsulate complex binding logic, improving testability and code organization.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\n// Before\n\n// In the view:\nForEach(Flag.allCases) { flag in\n  Toggle(\n    flag.description,\n    isOn: viewStore.binding(\n      get: { $0.featureFlags.contains(flag) }\n      send: { .flagToggled(flag, isOn: $0) }\n    )\n  )\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\n\n// In the file:\nextension StoreOf<Feature> {\n  subscript(hasFeatureFlag flag: Flag) -> Bool {\n    get { featureFlags.contains(flag) }\n    set {\n      send(.flagToggled(flag, isOn: newValue))\n    }\n  }\n}\n\n// In the view:\nForEach(Flag.allCases) { flag in\n  Toggle(\n    flag.description,\n    isOn: $store[hasFeatureFlag: flag]\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Shared State Mutation in an Effect (Incorrect)\nDESCRIPTION: This test illustrates an incomplete test for shared state mutated in an effect.  The trailing closure in `store.send` is omitted, meaning the test isn't asserting on the state changes caused by the effect.  This will lead to a test failure indicating that shared state was mutated without an assertion.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_24\n\nLANGUAGE: swift\nCODE:\n```\n@Test\nfunc increment() async {\n  let store = TestStore(initialState: SimpleFeature.State(count: Shared(0))) {\n    SimpleFeature()\n  }\n  await store.send(.incrementButtonTapped)\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Exhaustive Integration Test Example Swift\nDESCRIPTION: This code snippet demonstrates a non-exhaustive integration test for the same login flow, but focusing only on the final outcome: the selected tab switching to activity after the user taps the 'Submit' button. By setting `store.exhaustivity = .off`, the test bypasses the need to assert on intermediate state changes within the login feature, making it less verbose and more resilient to changes in the login feature's implementation details. This approach is suitable for testing high-level flows without getting bogged down in the specifics of individual features.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_16\n\nLANGUAGE: swift\nCODE:\n```\nlet store = TestStore(initialState: AppFeature.State()) {\n  AppFeature()\n}\nstore.exhaustivity = .off  // ‚¨ÖÔ∏è\n\nawait store.send(\\.\\login.submitButtonTapped)\nawait store.receive(\\.\\login.delegate.didLogin) {\n  $0.selectedTab = .activity\n}\n```\n\n----------------------------------------\n\nTITLE: Testing shared state with mutation in Swift\nDESCRIPTION: This snippet shows an alternative testing approach for shared state. Instead of directly asserting on the state within the trailing closure of `TestStore.send`, it captures a reference to the shared state and mutates that reference within the closure. This approach helps catch accidental removal of the `@Shared` property wrapper.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_32\n\nLANGUAGE: swift\nCODE:\n```\n@Test\nfunc increment() async {\n  @Shared(.appStorage(\"count\")) var count = 0\n  let store = TestStore(initialState: ParentFeature.State()) {\n    ParentFeature()\n  }\n\n  await store.send(.feature1(.buttonTapped)) {\n    // Mutate $0 to expected value.\n    count = 1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Store in App Swift\nDESCRIPTION: This code demonstrates how to initialize the store in the application's entry point. It creates a Store instance with the initial state and the Feature reducer.  The FeatureView is then initialized with this store, allowing it to display and interact with the feature's state.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\nimport ComposableArchitecture\n\n@main\nstruct MyApp: App {\n  var body: some Scene {\n    WindowGroup {\n      FeatureView(\n        store: Store(initialState: Feature.State()) {\n          Feature()\n        }\n      )\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Dependency Key Swift\nDESCRIPTION: This code shows how to register the `NumberFactClient` with the dependency management system by conforming it to the `DependencyKey` protocol.  It also defines the `liveValue` that will be used when running the application.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_16\n\nLANGUAGE: swift\nCODE:\n```\nextension NumberFactClient: DependencyKey {\n  static let liveValue = Self(\n    fetch: { number in\n      let (data, _) = try await URLSession.shared\n        .data(from: URL(string: \"http://numbersapi.com/\\(number)\")!\n      )\n      return String(decoding: data, as: UTF8.self)\n    }\n  )\n}\n\nextension DependencyValues {\n  var numberFact: NumberFactClient {\n    get { self[NumberFactClient.self] }\n    set { self[NumberFactClient.self] = newValue }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Reducer Feature with Tab Action Swift\nDESCRIPTION: This code defines a Feature reducer with a State that includes a `tab` property and an Action enum that includes a `tabChanged` action. This allows updating the tab state within the reducer.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer \nstruct Feature {\n  struct State {\n    var tab = 0\n  }\n  enum Action {\n    case tabChanged(Int)\n  }\n  var body: some ReducerOf<Self> {\n    Reduce { state, action in\n      switch action {\n      case let .tabChanged(tab):\n        state.tab = tab\n        return .none\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Computed View State Swift\nDESCRIPTION: This snippet illustrates the transition from using a dedicated `ViewState` struct to computing view-related state directly within the feature's state, reducing complexity and improving performance.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_16\n\nLANGUAGE: swift\nCODE:\n```\nstruct ViewState: Equatable {\n  let fullName: String\n  init(state: Feature.State) {\n    self.fullName = \"\\(state.firstName) \\(state.lastName)\"\n  }\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nstruct State {\n  // State fields\n  \n  var fullName: String {\n    \"\\(self.firstName) \\(self.lastName)\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Nested Action Sending with Case Key Paths\nDESCRIPTION: This snippet demonstrates the significant simplification achieved when sending complex, deeply nested actions using case key paths in version 1.9.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.9.md#_snippet_6\n\nLANGUAGE: diff\nCODE:\n```\n-store.send(\n-  .path(\n-    .element(\n-      id: 0,\n-      action: .destination(\n-        .presented(\n-          .sheet(\n-            .binding(\n-              .set(\\.\\password, \"blobisawesome\")\n-            )\n-          )\n-        )\n-      )\n-    )\n-  )\n-)\n+store.send(\\.\\path[id: 0].destination.sheet.binding.password, \"blobisawesome\")\n```\n\n----------------------------------------\n\nTITLE: Compiler error example with type-safe @Shared key in Swift\nDESCRIPTION: This snippet demonstrates the compiler error that occurs when attempting to use the wrong type with a type-safe `@Shared` key. This showcases how the type-safe key prevents assigning a value of type `[User]` to a property expected to be of type `IdentifiedArrayOf<User>`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_40\n\nLANGUAGE: swift\nCODE:\n```\n@Shared(.users) var users = [User]()\n```\n\n----------------------------------------\n\nTITLE: Defining a Counter Feature State\nDESCRIPTION: Defines the state for a simple counter feature using a struct with an integer count. The @ObservableState macro is applied to make the state observable by the view.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\nstruct CounterFeature: Reducer {\n  @ObservableState\n  struct State {\n    var count = 0\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: FeatureView wrapped in WithPerceptionTracking in Swift\nDESCRIPTION: This code shows a SwiftUI View wrapped in `WithPerceptionTracking`. Wrapping the view's body with `WithPerceptionTracking` ensures proper updates when the `sharedCount` changes, especially when deploying to iOS 16 or earlier.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_46\n\nLANGUAGE: swift\nCODE:\n```\nstruct FeatureView: View {\n  let store: StoreOf<Feature>\n\n  var body: some View {\n    WithPerceptionTracking {\n      Form {\n        Text(store.sharedCount.description)\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using App Storage with Shared State in TCA\nDESCRIPTION: This code snippet shows how to use the `.appStorage` persistence strategy with the `@Shared` property wrapper.  This persists the `count` state to `UserDefaults` using the key \"count\". During testing, TCA automatically uses a non-persisting UserDefaults to avoid test interference.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_26\n\nLANGUAGE: swift\nCODE:\n```\nstruct State: Equatable {\n  @Shared(.appStorage(\"count\")) var count: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Receiving Child Actions with TestStore in Swift\nDESCRIPTION: This snippet shows how to assert that a specific action is received from a child feature in the stack. It constructs a case key path for the child action using subscripting on the \\.path case with the element ID. Here, it expects to receive the .response action from the counter feature at ID 0.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\nawait store.receive(\\.path[id: 0].counter.response) {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Optional Child Stores Swift\nDESCRIPTION: This shows how to handle optional child stores using the `observe` method and `Store/scope`, replacing the previous Combine-based `ifLet` approach.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_19\n\nLANGUAGE: swift\nCODE:\n```\nstore\n  .scope(state: \\.child, action: \\.child)\n  .ifLet { childStore in\n    // Use child store, _e.g._ create a child view controller\n  } else: {\n    // Perform clean up work, _e.g._ dismiss child view controller\n  }\n  .store(in: &cancellables)\n```\n\nLANGUAGE: swift\nCODE:\n```\nobserve {\n  if let childStore = store.scope(state: \\.child, action: \\.child) {\n    // Use child store, _e.g._ create a child view controller\n  } else {\n    // Perform clean up work, _e.g._ dismiss child view controller\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Baking in the default value into a SharedReaderKey extension in Swift\nDESCRIPTION: This snippet demonstrates baking in the default value into the `SharedReaderKey` extension.  When the `.users` shared state is referenced, no explicit default value is required.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_43\n\nLANGUAGE: swift\nCODE:\n```\nextension SharedReaderKey where Self == FileStorageKey<IdentifiedArrayOf<User>>.Default {\n  static var users: Self {\n    Self[.fileStorage(.users), default: []]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Settings State Definition - Swift\nDESCRIPTION: Defines the state for a settings feature, including a boolean property to track haptic feedback enablement.  This state is part of a Reducer struct in the Composable Architecture. The state is also marked as Equatable.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Bindings.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Settings {\n  struct State: Equatable {\n    var isHapticsEnabled = true\n    // ...\n  }\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing TestStore with StackState in Swift\nDESCRIPTION: This snippet shows how to initialize a TestStore with an initial state that includes a StackState containing a CounterFeature.State.  This sets up the test environment with a counter already present in the navigation stack with count of 3.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n@Test\nfunc dismissal() {\n  let store = TestStore(\n    initialState: Feature.State(\n      path: StackState([\n        CounterFeature.State(count: 3)\n      ])\n    )\n  ) {\n    CounterFeature()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Last Element from NavigationPath in Swift\nDESCRIPTION: This code snippet demonstrates how to remove the last element from a `NavigationPath`.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_15\n\nLANGUAGE: Swift\nCODE:\n```\npath.removeLast()\n```\n\n----------------------------------------\n\nTITLE: Stack-Based Navigation - Invalid Path (Swift)\nDESCRIPTION: Shows an example of an invalid navigation path possible with stack-based navigation. This demonstrates a scenario where the edit screen is presented before the detail screen, which is considered nonsensical in the application's defined flow, highlighting a drawback of stack-based navigation.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/WhatIsNavigation.md#_snippet_8\n\nLANGUAGE: Swift\nCODE:\n```\nlet path: [Path] = [\n  .edit(/* ... */),\n  .detail(/* ... */)\n]\n```\n\n----------------------------------------\n\nTITLE: Path Reducer with @Reducer Macro\nDESCRIPTION: Demonstrates a simplified path reducer using the @Reducer macro on an enum. Each case holds a reducer for a screen that can be pushed onto a navigation stack.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.8.md#_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nenum Path {\n  case detail(DetailFeature)\n  case meeting(MeetingFeature)\n  case record(RecordFeature)\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified App Entry Point (Swift)\nDESCRIPTION: Demonstrates the simplified app entry point after using the dependency management system. The entry point no longer needs to construct dependencies, as they are automatically provided.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_19\n\nLANGUAGE: swift\nCODE:\n```\n@main\nstruct MyApp: App {\n  var body: some Scene {\n    WindowGroup {\n      FeatureView(\n        store: Store(initialState: Feature.State()) {\n          Feature()\n        }\n      )\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Delegate Action Payload (Old)\nDESCRIPTION: This code snippet demonstrates the old way of asserting that an action features sends a delegate action with a specific boolean payload. This approach asserts the entire action.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.6.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\nawait store.receive(.child(.delegate(.response(true))))\n```\n\n----------------------------------------\n\nTITLE: Referencing shared state without default value or type annotation in Swift\nDESCRIPTION: This code demonstrates how to declare a `@Shared` property without specifying a default value or type annotation when the default value and type are baked into the type-safe key.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_44\n\nLANGUAGE: swift\nCODE:\n```\n@Shared(.users) var users\n```\n\n----------------------------------------\n\nTITLE: Defining Stack-Based Navigation with an Enum\nDESCRIPTION: This code snippet defines an enum to represent the possible features that can be navigated to on a stack using stack-based navigation.  It demonstrates a detail and edit feature within the enum.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/WhatIsNavigation.md#_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nenum Path {\n  case detail(DetailItemFeature.State)\n  case edit(EditItemFeature.State)\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Shared State Reference to Child Feature\nDESCRIPTION: Shows how to pass a reference to the shared count from the parent to the child feature. The projected value `$count` is used to pass a reference rather than the actual value.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_2\n\nLANGUAGE: Swift\nCODE:\n```\ncase .presentButtonTapped:\n  state.child = ChildFeature.State(count: state.$count)\n  // ...\n```\n\n----------------------------------------\n\nTITLE: Appending Data to NavigationPath in Swift\nDESCRIPTION: This code snippet demonstrates how to append different types of data to a `NavigationPath`. `NavigationPath` allows appending any kind of `Hashable` data, but it is type-erased.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_13\n\nLANGUAGE: Swift\nCODE:\n```\nvar path = NavigationPath()\npath.append(1)\npath.append(\"Hello\")\npath.append(false)\n```\n\n----------------------------------------\n\nTITLE: Testing Response with Mock Swift\nDESCRIPTION: This snippet demonstrates how to test that the application receives the mocked response as injected in the previous step and that the state changes accordingly.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\nawait store.send(.numberFactButtonTapped)\n\nawait store.receive(\\.\\numberFactResponse) {\n  $0.numberFact = \"0 is a good number Brent\"\n}\n```\n\n----------------------------------------\n\nTITLE: Preview Workaround\nDESCRIPTION: This code presents a workaround for using `#Preview` with destination and path reducers. The workaround involves moving the view to a helper that can be compiled outside of the macro, and then using it inside the macro.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_19\n\nLANGUAGE: swift\nCODE:\n```\n#Preview {\n  preview\n}\nprivate var preview: some View {\n  FeatureView(\n    store: Store(\n      initialState: Feature.State(\n        destination: .edit(EditFeature.State())\n      )\n    ) {\n      Feature()\n    }\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Basic TestStore Initialization (Swift)\nDESCRIPTION: Demonstrates the basic initialization of a `TestStore` for testing features in the Composable Architecture. It initializes the store with an initial state and the `Feature` reducer.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n@Test\nfunc basics() async {\n  let store = TestStore(initialState: Feature.State()) {\n    Feature()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Recommended UserDefaults Key Naming (Swift)\nDESCRIPTION: Illustrates the recommended approach for naming UserDefaults keys when using `@Shared(.appStorage(...))`. It suggests using delimiters such as \"/\", \":\", or \"-\" instead of \".\" or \"@\" to leverage the more efficient Key-Value Observing (KVO) mechanism.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.16.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Shared(.appStorage(\"co:pointfree:count\")) var count = 0\n```\n\n----------------------------------------\n\nTITLE: DelegateAction enum with @CasePathable Swift\nDESCRIPTION: This code shows how to explicitly annotate DelegateAction enum with @CasePathable to enable case key path syntax.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.4.md#_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\n@CasePathable\nenum DelegateAction {\n  case didFinish(success: Bool)\n}\n```\n\n----------------------------------------\n\nTITLE: NavigationStack Destination Closure (Verbose)\nDESCRIPTION: Illustrates the verbose approach of constructing the destination closure for a NavigationStack.  It requires destructuring the Path.State enum, scoping the store, and conditionally unwrapping the scoped store before passing it to the child view.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.8.md#_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\nNavigationStack(path: $store.scope(state: \\.path, action: \\.path)) {\n  // Root view\n} destination: { store in\n  switch store.state {\n  case .detail:\n    if let store = store.scope(state: \\.detail, action: \\.detail) {\n      DetailView(store: store)\n    }\n  case .meeting:\n    if let store = store.scope(state: \\.meeting, action: \\.meeting) {\n      MeetingView(store: store)\n    }\n  case .record:\n    if let store = store.scope(state: \\.record, action: \\.record) {\n      RecordView(store: store)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Action enum using IdentifiedAction Swift\nDESCRIPTION: This snippet demonstrates the updated `Action` enum structure to hold `IdentifiedActionOf<Nested>` instead of individual ID and action components.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.4.md#_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\nenum Action {\n  // ...\n  case rows(IdentifiedActionOf<Nested>)\n}\n```\n\n----------------------------------------\n\nTITLE: Type-safe inMemory key example in Swift\nDESCRIPTION: This code snippet shows the creation of a type-safe `.inMemory` key for use with `@Shared`.  It constrains the key to InMemoryKey<IdentifiedArrayOf<User>> and assigns the value using inMemory(\"users\").\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_41\n\nLANGUAGE: swift\nCODE:\n```\nextension SharedReaderKey where Self == InMemoryKey<IdentifiedArrayOf<User>> {\n  static var users: Self {\n    inMemory(\"users\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a UIKit ViewController\nDESCRIPTION: This snippet shows how to implement the feature using a UIKit view controller. It demonstrates how to create UI elements, and connect actions from the UI elements to sending actions to the store. It also shows how to observe store changes in `viewDidLoad` and update the UI accordingly.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/GettingStarted.md#_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\nclass FeatureViewController: UIViewController {\n  let store: StoreOf<Feature>\n\n  init(store: StoreOf<Feature>) {\n    self.store = store\n    super.init(nibName: nil, bundle: nil)\n  }\n\n  required init?(coder: NSCoder) {\n    fatalError(\"init(coder:) has not been implemented\")\n  }\n\n  override func viewDidLoad() {\n    super.viewDidLoad()\n\n    let countLabel = UILabel()\n    let decrementButton = UIButton()\n    let incrementButton = UIButton()\n    let factLabel = UILabel()\n    \n    // Omitted: Add subviews and set up constraints...\n    \n    observe { [weak self] in\n      guard let self \n      else { return }\n      \n      countLabel.text = \"\\(self.store.text)\"\n      factLabel.text = self.store.numberFact\n    }\n  }\n\n  @objc private func incrementButtonTapped() {\n    self.store.send(.incrementButtonTapped)\n  }\n  @objc private func decrementButtonTapped() {\n    self.store.send(.decrementButtonTapped)\n  }\n  @objc private func factButtonTapped() {\n    self.store.send(.numberFactButtonTapped)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: State enum with @CasePathable and @dynamicMemberLookup Swift\nDESCRIPTION: This snippet shows how the `@CasePathable` and `@dynamicMemberLookup` macros are applied to the `State` enum when the feature uses the `@Reducer` macro and state is an enum. This allows accessing associated values via dot-syntax.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.4.md#_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n+@CasePathable\n+@dynamicMemberLookup\nenum State {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing TestStore\nDESCRIPTION: This snippet demonstrates how to initialize a `TestStore` with an initial state and a reducer. `TestStore` is used for testing features in the Composable Architecture.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nimport Testing\n\n@MainActor\nstruct CounterTests {\n  @Test\n  func basics() async {\n    let store = TestStore(initialState: Feature.State(count: 0)) {\n      Feature()\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Dismissing a View in SwiftUI\nDESCRIPTION: Demonstrates the usage of the `@Environment(\\.dismiss)` property wrapper in SwiftUI to allow a child view to dismiss itself. When the `dismiss()` function is invoked, SwiftUI finds the closest parent view with a presentation and dismisses it. This allows child views to control their own dismissal without explicit communication with a parent.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\nstruct ChildView: View {\n  @Environment(\\.dismiss) var dismiss\n  var body: some View {\n    Button(\"Close\") { self.dismiss() }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using @Shared with fileStorage key, type IdentifiedArrayOf<User>, in Swift\nDESCRIPTION: This snippet shows using @Shared with a `fileStorage` key but refactoring from a plain array of `User` objects, to an `IdentifiedArrayOf<User>`. Used to point out that type safety might be compromised if this is not applied everywhere.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_37\n\nLANGUAGE: swift\nCODE:\n```\n// Somewhere else in the application\n@Shared(.fileStorage(.users)) var users: IdentifiedArrayOf<User> = []\n```\n\n----------------------------------------\n\nTITLE: TabView Binding with ViewStore Swift\nDESCRIPTION: This snippet demonstrates how to derive a binding for a TabView's selection using ViewStore's `binding(get:send:)` method. It connects the `tab` state to the `tabChanged` action.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\nTabView(\n  selection: viewStore.binding(get: \\.tab, send: { .tabChanged($0) })\n) {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Persistence Strategy with @Shared\nDESCRIPTION: Demonstrates how to use a custom persistence strategy with the `@Shared` property wrapper. Requires a default value.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_8\n\nLANGUAGE: Swift\nCODE:\n```\n@Shared(.custom(/* ... */)) var myValue: Value\n```\n\n----------------------------------------\n\nTITLE: Model Definition with UUID Dependency in Swift\nDESCRIPTION: Defines a `Model` struct that uses the `@Dependency(\\.uuid)` to generate a UUID.  This pattern can cause issues with non-exhaustive tests that show skipped assertions due to the closure in `send` being invoked twice.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_24\n\nLANGUAGE: swift\nCODE:\n```\nstruct Model: Equatable {\n  let id: UUID\n  init() {\n    @Dependency(\\.uuid) var uuid\n    self.id = uuid()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: NavigationLink for Backwards Compatibility in Swift\nDESCRIPTION: This code snippet provides a backwards compatible implementation of `navigationDestination` using `NavigationLink` for deployment targets earlier than iOS 16, macOS 13, tvOS 16, and watchOS 9.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\n@available(iOS, introduced: 13, deprecated: 16)\n@available(macOS, introduced: 10.15, deprecated: 13)\n@available(tvOS, introduced: 13, deprecated: 16)\n@available(watchOS, introduced: 6, deprecated: 9)\nextension NavigationLink {\n  public init<D, C: View>(\n    item: Binding<D?>,\n    onNavigate: @escaping (_ isActive: Bool) -> Void,\n    @ViewBuilder destination: (D) -> C,\n    @ViewBuilder label: () -> Label\n  ) where Destination == C? {\n    self.init(\n      destination: item.wrappedValue.map(destination),\n      isActive: Binding(\n        get: { item.wrappedValue != nil },\n        set: { isActive, transaction in\n          onNavigate(isActive)\n          if !isActive {\n            item.transaction(transaction).wrappedValue = nil\n          }\n        }\n      ),\n      label: label\n    )\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Optional Shared Property - Swift\nDESCRIPTION: This snippet showcases how to migrate optional dynamic member lookup on `Shared` to using `Shared.init(_:)` to explicitly unwrap a shared optional value.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.11.md#_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n-if let sharedUnwrappedProperty = $shared.optionalProperty {\n+if let sharedUnwrappedProperty = Shared($shared.optionalProperty) {\n   // ...\n }\n```\n\n----------------------------------------\n\nTITLE: Store Scoping with Key Paths (Deprecated)\nDESCRIPTION: This code snippet demonstrates the old approach of scoping a store using a key path for state and a closure for action, which is now deprecated. It shows how to scope the store to a child state property and wrap the child action in a parent action.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.5.md#_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\n// ‚ö†Ô∏è Deprecated API\nChildView(\n  store: store.scope(\n    state: \\.child,\n    action: { .child($0) }\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Receiving action with IdentifiedAction in TestStore Swift\nDESCRIPTION: This code snippet demonstrates how to receive an action for a specific element when using IdentifiedAction in a TestStore.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.4.md#_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\nstore.receive(\\.\\rows[id: 0].response.success)\n```\n\nLANGUAGE: swift\nCODE:\n```\nstore.receive(\\.\\path[id: 0].response.success)\n```\n\n----------------------------------------\n\nTITLE: Multiple Sends Test with Explicit UUIDs in Swift\nDESCRIPTION: Shows an example of sending multiple actions in a test, explicitly providing the UUIDs for each `Model` created.  This further reinforces the importance of controlling side effects when using non-exhaustive tests with skipped assertions.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_30\n\nLANGUAGE: swift\nCODE:\n```\nawait store.send(.addButtonTapped) {\n  $0.values = [\n    Model(id: UUID(0))\n  ]\n}\nawait store.send(.addButtonTapped) {\n  $0.values = [\n    Model(id: UUID(0)),\n    Model(id: UUID(1))\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Receiving concrete action in TestStore Swift\nDESCRIPTION: This code snippet shows the old way of receiving an action by constructing the concrete action type in the test store.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.4.md#_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\nstore.receive(.child(.presented(.response(.success(\"Hello!\")))))\n```\n\n----------------------------------------\n\nTITLE: Stack-Based Navigation - Multiple Edits (Swift)\nDESCRIPTION: Illustrates another example of an invalid navigation path possible with stack-based navigation. It shows multiple edit screens pushed one after another, which is considered non-sensical and undesirable for a well-defined navigation flow in the application.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/WhatIsNavigation.md#_snippet_9\n\nLANGUAGE: Swift\nCODE:\n```\nlet path: [Path] = [\n  .edit(/* ... */),\n  .edit(/* ... */),\n  .edit(/* ... */),\n]\n```\n\n----------------------------------------\n\nTITLE: Feature Reducer with addButtonTapped Action in Swift\nDESCRIPTION: Shows a reducer for a `Feature` that appends a new `Model` to an array when the `addButtonTapped` action is sent.  This reducer is used to demonstrate the issue of side effects in non-exhaustive tests with skipped assertions.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_25\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  struct State: Equatable {\n    var values: [Model] = []\n  }\n  enum Action {\n    case addButtonTapped\n  }\n  var body: some Reducer<State, Action> {\n    Reduce { state, action in\n      switch action {\n      case .addButtonTapped:\n        state.values.append(Model())\n        return .none\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Dropping Reducer conformance Swift\nDESCRIPTION: This code snippet illustrates how to drop the explicit `Reducer` conformance when using the `@Reducer` macro.  However, it notes potential issues with Xcode autocomplete and type inference.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.4.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\n-struct MyFeature: Reducer {\n+struct MyFeature {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking Child Reducer Directly\nDESCRIPTION: Instead of sending actions to a child feature to invoke logic, it's more efficient to invoke the child reducer directly from the parent.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Performance.md#_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n// Handling action from parent feature:\ncase .buttonTapped:\n  // Send action to child to perform logic:\n  return .send(.child(.refresh))\n```\n\nLANGUAGE: swift\nCODE:\n```\ncase .buttonTapped:\n  return reduce(into: &state, action: .child(.refresh))\n```\n\n----------------------------------------\n\nTITLE: Avoiding Computed Properties in Scopes\nDESCRIPTION: This snippet demonstrates the problem of using computed properties within scopes. Accessing state from the scoped store transforms the root state to the child state, including the potentially heavy computation, multiple times, which can degrade performance.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Performance.md#_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\nextension ParentFeature.State {\n  var computedChild: ChildFeature.State {\n    ChildFeature.State(\n      // Heavy computation here...\n    )\n  }\n}\n\nChildView(\n  store: store.scope(state: \\.computedChild, action: \\.child)\n)\n```\n\n----------------------------------------\n\nTITLE: Mutating Shared State Directly (Deprecated) - Swift\nDESCRIPTION: This snippet shows the deprecated way of directly mutating shared state from an effect. It's no longer recommended due to potential race conditions and is replaced by the `withLock` method.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.11.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\ncase .delayedIncrementButtonTapped:\n  return .run { _ in\n    @Shared(.count) var count\n    count += 1  // ‚ö†Ô∏è Use '$shared.withLock' instead of mutating directly.\n  }\n```\n\n----------------------------------------\n\nTITLE: Empty Reducer with @Reducer Macro\nDESCRIPTION: Illustrates how the @Reducer macro can be used to define an empty reducer by automatically inserting empty Reducer/State struct, Reducer/Action enum, and Reducer/body-swift.property.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_7\n\nLANGUAGE: Swift\nCODE:\n```\n@Reducer\nstruct Feature {}\n```\n\n----------------------------------------\n\nTITLE: Simplified App Entry Swift\nDESCRIPTION: This snippet demonstrates the simplified application entry point after registering the dependency with the dependency management system.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/README.md#_snippet_18\n\nLANGUAGE: swift\nCODE:\n```\n@main\nstruct MyApp: App {\n  var body: some Scene {\n    WindowGroup {\n      FeatureView(\n        store: Store(initialState: Feature.State()) {\n          Feature()\n        }\n      )\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: forEach with case path Swift\nDESCRIPTION: This snippet shows the old way of using `forEach` with a case path using the `/` prefix operator.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.4.md#_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\nReduce { state, action in \n  // ...\n}\n.forEach(\\.\\rows, action: /Action.row(id:action:)) {\n  RowFeature()\n}\n```\n\n----------------------------------------\n\nTITLE: Feature Reducer and View (Pre-1.7)\nDESCRIPTION: Demonstrates the structure of a typical feature built with the Composable Architecture before version 1.7. It manually manages a ViewState struct and uses WithViewStore to minimize observed state. This structure needs to be updated to leverage the new observation tools.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.7.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  struct State { /* ... */ }\n  enum Action { /* ... */ }\n  var body: some ReducerOf<Self> {\n    // ...\n  }\n}\n\nstruct FeatureView: View {\n  let store: StoreOf<Feature>\n\n  struct ViewState: Equatable {\n    // ...\n    init(state: Feature.State) { /* ... */ }\n  }\n\n  var body: some View {\n    WithViewStore(store, observe: ViewState.init) { viewStore in\n      Form {\n        Text(viewStore.count.description)\n        Button(\"+\") { viewStore.send(.incrementButtonTapped) }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enum-driven Navigation with State and Action (Deprecated)\nDESCRIPTION: This snippet represents the old, deprecated approach to handling enum-driven navigation. Using separate parameters for store, state and action, this code shows the verbose way to bind navigation elements to specific cases within an enum.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.5.md#_snippet_6\n\nLANGUAGE: Swift\nCODE:\n```\n// ‚ö†Ô∏è Deprecated API\n.sheet(\n  store: store.scope(state: \\.$destination, action: { .destination($0) }),\n  state: \\.editForm,\n  action: { .editForm($0) }\n)\n```\n\n----------------------------------------\n\nTITLE: Destination Reducer with Ignored Case\nDESCRIPTION: This code demonstrates how to define a destination reducer with a case that is not powered by a reducer using the `@ReducerCaseIgnored` macro. This is useful for navigating to features that are not built with the Composable Architecture or are very simple.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Extensions/Reducer.md#_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nenum Destination {\n  case add(AddItemFeature)\n  case edit(EditItemFeature)\n  @ReducerCaseIgnored\n  case item(Item)\n}\n```\n\n----------------------------------------\n\nTITLE: FeatureView without WithPerceptionTracking showing runtime warning in Swift\nDESCRIPTION: This shows a simple SwiftUI view that accesses `store.sharedCount.description` but it's missing `WithPerceptionTracking`. This missing wrapper will produce a runtime warning when deployed to older versions of iOS.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/SharingState.md#_snippet_45\n\nLANGUAGE: swift\nCODE:\n```\nstruct FeatureView: View {\n  let store: StoreOf<Feature>\n\n  var body: some View {\n    Form {\n      Text(store.sharedCount.description)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Persisting Shared State to File System in Swift\nDESCRIPTION: This snippet demonstrates how to persist shared state to the file system using the `.fileStorage` persistence strategy within the `@Shared` property wrapper. Any changes to `signUpData` will be automatically persisted to disk and loaded upon app launch.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/MigrationGuides/MigratingTo1.10.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@ObservableState\nstruct State {\n  @Shared(.fileStorage(URL(/* ... */)) var signUpData = SignUpData()\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating over NavigationPath is not allowed in Swift\nDESCRIPTION: This code snippet shows that you cannot iterate directly over a NavigationPath.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/StackBasedNavigation.md#_snippet_17\n\nLANGUAGE: Swift\nCODE:\n```\nlet path: NavigationPath = ‚Ä¶\nfor element in path {  // üõë\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Multiple Actions with TestStore\nDESCRIPTION: This snippet demonstrates how to send multiple actions to the `TestStore` and assert the state after each action. This enables testing complex user flows and state transitions.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nawait store.send(.incrementButtonTapped) {\n  $0.count = 1\n}\nawait store.send(.incrementButtonTapped) {\n  $0.count = 2\n}\nawait store.send(.decrementButtonTapped) {\n  $0.count = 1\n}\n```\n\n----------------------------------------\n\nTITLE: Modeling Navigation with Optionals in Swift\nDESCRIPTION: This code snippet demonstrates a potentially problematic approach to modeling navigation using multiple optional state variables. It highlights the risk of creating invalid states where multiple destinations are active simultaneously.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TreeBasedNavigation.md#_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n@ObservableState\nstruct State {\n  @Presents var detailItem: DetailFeature.State?\n  @Presents var editItem: EditFeature.State?\n  @Presents var addItem: AddFeature.State?\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Sharing Logic with Actions - Inefficient\nDESCRIPTION: This snippet demonstrates an inefficient approach to sharing logic between actions by sending a 'sharedComputation' action from multiple other actions. This results in unnecessary overhead and complicates testing.  It is recommended to avoid this pattern due to performance concerns and reduced flexibility.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/Performance.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Reducer\nstruct Feature {\n  @ObservableState\n  struct State { /* ... */ }\n  enum Action { /* ... */ }\n\n  var body: some Reducer<State, Action> {\n    Reduce { state, action in\n      switch action {\n      case .buttonTapped:\n        state.count += 1\n        return .send(.sharedComputation)\n\n      case .toggleChanged:\n        state.isEnabled.toggle()\n        return .send(.sharedComputation)\n\n      case let .textFieldChanged(text):\n        state.description = text\n        return .send(.sharedComputation)\n\n      case .sharedComputation:\n        // Some shared work to compute something.\n        return .run { send in\n          // A shared effect to compute something\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Timer Effect with Task Sleep in Swift\nDESCRIPTION: This demonstrates the initial implementation of the timer effect using `Task.sleep` to simulate time passing. This approach introduces uncontrolled, real-world asynchrony, which can slow down tests.\nSOURCE: https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Documentation.docc/Articles/TestingTCA.md#_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\nreturn .run { send in\n  for _ in 1...5 {\n    try await Task.sleep(for: .seconds(1))  // ‚¨ÖÔ∏è\n    await send(.timerTick)\n  }\n}\n```"
  }
]