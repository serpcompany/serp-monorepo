[
  {
    "owner": "timescale",
    "repo": "timescaledb",
    "content": "TITLE: Running TimescaleDB with Docker (Bash)\nDESCRIPTION: This snippet demonstrates how to quickly start a detached TimescaleDB instance in a Docker container, exposing it on port 5432 and setting the default PostgreSQL password via environment variable. Requires Docker installed and network access to pull the official timescale/timescaledb image. The container will persist data only as long as it existsâ€”bind mounts or Docker volumes should be used for persistence in production. The POSTGRES_PASSWORD parameter must be replaced in a secure setup.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\ndocker run -d --name timescaledb -p 5432:5432 -e POSTGRES_PASSWORD=password timescale/timescaledb:latest-pg17\n```\n\n----------------------------------------\n\nTITLE: Creating a Continuous Aggregate Materialized View (SQL)\nDESCRIPTION: This SQL creates a continuous aggregate materialized view for daily summaries in the 'conditions_summary_daily' view, aggregating average, maximum, and minimum temperatures by location and daily buckets. Requires TimescaleDB 2.0+ and an existing hypertable. The 'timescaledb.continuous' option enables background incremental updates. Output is precomputed for faster query performance.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/README.md#_snippet_8\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE MATERIALIZED VIEW conditions_summary_daily\nWITH (timescaledb.continuous) AS\nSELECT\n  location,\n  time_bucket(INTERVAL '1 day', time) AS bucket,\n  AVG(temperature),\n  MAX(temperature),\n  MIN(temperature)\nFROM\n  conditions\nGROUP BY\n  location,\n  bucket;\n```\n\n----------------------------------------\n\nTITLE: Aggregating Data with Time Buckets (SQL)\nDESCRIPTION: This query uses the time_bucket function to group temperature readings by daily intervals, outputting the average temperature per day. Requires TimescaleDB extension and a hypertable with 'time' and 'temperature' columns. GROUP BY and ORDER BY ensure the output is organized chronologically. Useful for downsampling or summarizing time-series data.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/README.md#_snippet_7\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT\n  time_bucket('1 day', time) AS bucket,\n  AVG(temperature) AS avg_temp\nFROM\n  conditions\nGROUP BY\n  bucket\nORDER BY\n  bucket ASC;\n```\n\n----------------------------------------\n\nTITLE: Illustrating SkipScan SQL Plan with Merge Append (Multiple Chunks)\nDESCRIPTION: Shows a query plan using SkipScan across multiple TimescaleDB chunks. Each chunk gets its own `Custom Scan (SkipScan)` wrapping an `Index Scan`. A `Merge Append` node is used to combine the sorted results from each chunk's SkipScan before the final `Unique` operation ensures distinctness across all chunks.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/nodes/skip_scan/README.md#_snippet_2\n\nLANGUAGE: SQL\nCODE:\n```\nUnique\n  ->  Merge Append\n        Sort Key: _hyper_2_1_chunk.dev_name\n        ->  Custom Scan (SkipScan) on _hyper_2_1_chunk\n              ->  Index Scan using _hyper_2_1_chunk_idx on _hyper_2_1_chunk\n        ->  Custom Scan (SkipScan) on _hyper_2_2_chunk\n              ->  Index Scan using _hyper_2_2_chunk_idx on _hyper_2_2_chunk\n```\n\n----------------------------------------\n\nTITLE: Creating and Converting a Table to a Hypertable (SQL)\nDESCRIPTION: This SQL snippet creates the TimescaleDB extension if not present, defines a regular table called conditions, and then converts it to a hypertable partitioned by the 'time' column. Requires a PostgreSQL database with TimescaleDB extension installed. The conditions table models typical time-series metrics. create_hypertable() is TimescaleDB-specific and automatically manages chunk partitioning.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/README.md#_snippet_2\n\nLANGUAGE: SQL\nCODE:\n```\n-- Create timescaledb extension\nCREATE EXTENSION IF NOT EXISTS timescaledb;\n\n-- Create a regular SQL table\nCREATE TABLE conditions (\n  time        TIMESTAMPTZ       NOT NULL,\n  location    TEXT              NOT NULL,\n  temperature DOUBLE PRECISION  NULL,\n  humidity    DOUBLE PRECISION  NULL\n);\n\n-- Convert the table into a hypertable that is partitioned by time\nSELECT create_hypertable('conditions', by_range('time'));\n```\n\n----------------------------------------\n\nTITLE: Gap Filling with Interpolation - SQL\nDESCRIPTION: This snippet showcases gap filling with interpolation by pairing time_bucket_gapfill and interpolate functions within TimescaleDB. The interpolate call marks the value for linear interpolation between known points, filling missing time intervals with calculated values. The TimescaleDB planner and execution nodes handle the logic; the input is time-value pairs, and the output contains interpolated values for gaps. Requires TimescaleDB with interpolation support.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/nodes/gapfill/README.md#_snippet_2\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT\ntime_bucket_gapfill(1,time,0,6) AS time,\ninterpolate(min(value)) AS value\nFROM (values (0,1),(5,6)) v(time,value)\nGROUP BY 1 ORDER BY 1;\n```\n\n----------------------------------------\n\nTITLE: Illustrating SkipScan SQL Plan with Unique Node (Single Table)\nDESCRIPTION: Demonstrates how TimescaleDB integrates SkipScan into a query plan for a single table or chunk. A `Unique` node remains at the top, processing the output of the `Custom Scan (SkipScan)`, which itself contains the optimized `Index Scan`. This structure allows leveraging existing planning logic while benefiting from the SkipScan optimization.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/nodes/skip_scan/README.md#_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\nUnique\n  ->  Custom Scan (SkipScan) on skip_scan\n        ->  Index Scan using skip_scan_dev_name_idx on skip_scan\n```\n\n----------------------------------------\n\nTITLE: Scheduling Continuous Aggregate Refresh Policy (SQL)\nDESCRIPTION: This SQL schedules the automatic refresh of the 'conditions_summary_daily' continuous aggregate materialized view every hour using add_continuous_aggregate_policy. The policy parameters set the refresh to cover data from one month ago to one day ago, and to run every hour. Works only with continuous aggregates; ensures timely, efficient data analytics.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/README.md#_snippet_9\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT\n  add_continuous_aggregate_policy(\n    'conditions_summary_daily',\n    start_offset => INTERVAL '1 month',\n    end_offset => INTERVAL '1 day',\n    schedule_interval => INTERVAL '1 hour'\n);\n```\n\n----------------------------------------\n\nTITLE: Enabling Compression with Columnstore on a Hypertable (SQL)\nDESCRIPTION: This snippet uses the ALTER TABLE command to enable compression with TimescaleDB's columnstore feature. 'timescaledb.compress' activates compression, and 'timescaledb.compress_segmentby' groups compressed chunks by the specified column, here 'location'. Requirements: the table must already be a TimescaleDB hypertable. Compression settings affect storage and performance, and 'segmentby' impacts compression ratios and query speed.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/README.md#_snippet_3\n\nLANGUAGE: SQL\nCODE:\n```\nALTER TABLE conditions SET (\n  timescaledb.compress,\n  timescaledb.compress_segmentby = 'location'\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Object-Oriented Programming Style with Function Pointers in C\nDESCRIPTION: A comprehensive example demonstrating how to mimic object-oriented programming constructs in C using struct embedding, function pointers for virtual functions, and namespaced methods. It shows a base Shape struct with a function pointer, a draw method that calls the virtual function, and a derived Circle struct embedding Shape. The example elaborates upcasting, downcasting, encapsulation of behavior, and modularity in C.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/docs/StyleGuide.md#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\ntypedef struct Shape\n{\n    int color;\n    void (*draw)(Shape *, Canvas *);\n} Shape;\n\nvoid\nshape_draw(Shape *shape)\n{\n    /* open canvas for drawing */\n    Canvas *c = canvas_open();\n\n    /* other common shape code */\n    ...\n\n    shape->draw(shape, c);\n\n    canvas_close(c);\n}\n\ntypedef struct Circle\n{\n    Shape shape;\n    float diameter;\n} Circle;\n\nCircle blue_circle = {\n    .shape = {\n        .color = BLUE,\n        .draw = circle_draw,\n    },\n    .diameter = 10.1,\n};\n\nvoid\ncircle_draw(Shape *shape, Canvas *canvas)\n{\n    Circle *circle = (Circle *) shape;\n\n    /* draw circle */\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Gap Filling with LOCF (Last Observation Carried Forward) - SQL\nDESCRIPTION: This SQL query illustrates combining time_bucket_gapfill with the locf (last observation carried forward) function to fill missing values with the most recent known observation, instead of NULL. The function serves as a marker and is processed by the TimescaleDB planner to enable LOCF behavior across missing time intervals. Inputs are timeseries (time, value) pairs, and output includes all buckets; missing intervals replay the last value.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/nodes/gapfill/README.md#_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT\ntime_bucket_gapfill(1,time,0,6) AS time,\nlocf(min(value)) AS value\nFROM (values (0,1),(5,6)) v(time,value)\nGROUP BY 1 ORDER BY 1;\n```\n\n----------------------------------------\n\nTITLE: Filling Gaps in Time-Series Data using time_bucket_gapfill - SQL\nDESCRIPTION: This SQL snippet demonstrates the use of the time_bucket_gapfill function in TimescaleDB to automatically generate missing time intervals in a time-series query aggregation, without requiring a join to generate_series. The query aggregates sample data on regular buckets and outputs minimum values per interval, filling gaps with NULL where data is missing. Requires TimescaleDB with gapfill support and a source relation for aggregation. Inputs are values as (time, value) pairs; the output lists all intervals including those without original data.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/nodes/gapfill/README.md#_snippet_0\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT\ntime_bucket_gapfill(1,time,0,6) AS time,\nmin(value) AS value\nFROM (values (0,1),(5,6)) v(time,value)\nGROUP BY 1 ORDER BY 1;\n```\n\n----------------------------------------\n\nTITLE: Adding a Compression Policy to a Hypertable (SQL)\nDESCRIPTION: This query schedules automatic compression of hypertable chunks older than seven days using the add_compression_policy function. Only available on hypertables with TimescaleDB compression enabled. Policy ensures that older data consumes less storage and is optimized for analytics. The target table and interval ('7 days') are configurable.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/README.md#_snippet_4\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT add_compression_policy('conditions', INTERVAL '7 days');\n```\n\n----------------------------------------\n\nTITLE: Basic Node Lifecycle and Query TAP Test with TimescaleNode - Perl\nDESCRIPTION: Demonstrates creating a new TimescaleDB node, initializing, starting it, performing a test query via psql, asserting the result, and stopping the node. Used for validating connections and command execution in a TAP test context. Dependencies: TimescaleNode class, access to psql, Test::More for assertions.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/perl/README.md#_snippet_2\n\nLANGUAGE: Perl\nCODE:\n```\nmy $node = get_new_ts_node('access_node');\n$node->init;\n$node->start;\n\nmy $ret = $node->safe_psql('postgres', 'SELECT 1');\nis($ret, '1', 'SELECT 1 returns 1');\n\n$node->stop('fast');\n```\n\n----------------------------------------\n\nTITLE: Counting Recent Entries in a Hypertable (SQL)\nDESCRIPTION: This SQL statement returns the total number of records in the 'conditions' table with a time newer than 12 hours ago, leveraging TimescaleDB's time-based partitioning for efficient query performance. Input: none; output: single integer. Works for any hypertable with a 'time' column defined.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/README.md#_snippet_6\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT\n  COUNT(*)\nFROM\n  conditions\nWHERE\n  time > NOW() - INTERVAL '12 hours';\n```\n\n----------------------------------------\n\nTITLE: Running PostgreSQL Regression Tests With TimescaleDB Extension Using Make\nDESCRIPTION: This shell snippet shows how to invoke the `pginstallcheck` target using `make`. Once CMake is configured, running this target initiates PostgreSQL's standard test suite with the TimescaleDB extension loaded. This target depends on the PostgreSQL source code being compiled (specifically the `src/test/regress` directory) and verifies that TimescaleDB's planner and DDL hooks are compatible with PostgreSQL's test schedule.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/pgtest/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ make pginstallcheck\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Debug Build - Bash\nDESCRIPTION: This Bash snippet provides detailed steps to build TimescaleDB in Debug mode and execute the full suite of tests on a local development environment. It requires a compatible Unix-like shell, CMake, a working C/C++ compiler toolchain, and the TimescaleDB source code. Developers must run './bootstrap -DCMAKE_BUILD_TYPE=Debug' to configure a Debug build, then use 'make' within the build directory, followed by 'make installcheck' to execute all tests; all commands must be executed in the TimescaleDB root directory. The script assumes all dependencies are met and that the user has necessary system privileges.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Use Debug build mode for full battery of tests\n./bootstrap -DCMAKE_BUILD_TYPE=Debug\ncd build && make\nmake installcheck\n```\n\n----------------------------------------\n\nTITLE: Defining Test Target for Regression Checks with pg_regress (CMake)\nDESCRIPTION: Defines a custom CMake target 'regresscheck' to run regression tests using 'pg_regress' if it is available. Environment variables such as TEST_PGPORT, TEST_SCHEDULE, and various option flags are passed via CMake's -E env helper. The test suite executes 'pg_regress.sh' with appropriate parameters and a temporary config file. The target is appended to _install_checks for later aggregation. Dependencies include pg_regress and relevant environment setup.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(\n  regresscheck\n  COMMAND\n    ${CMAKE_COMMAND} -E env ${PG_REGRESS_ENV}\n    TEST_PGPORT=${TEST_PGPORT_TEMP_INSTANCE} TEST_SCHEDULE=${TEST_SCHEDULE}\n    ${CMAKE_CURRENT_SOURCE_DIR}/pg_regress.sh ${PG_REGRESS_OPTS_BASE}\n    ${PG_REGRESS_OPTS_EXTRA} ${PG_REGRESS_OPTS_INOUT}\n    ${PG_REGRESS_OPTS_TEMP_INSTANCE}\n    --temp-config=${TEST_OUTPUT_DIR}/postgresql.conf\n  USES_TERMINAL)\n\nlist(APPEND _install_checks regresscheck)\n```\n\n----------------------------------------\n\nTITLE: Defining Test Target for TAP-Style Test Checks (CMake)\nDESCRIPTION: Creates the 'provecheck' custom CMake target to run TAP (Test Anything Protocol) tests using the 'pg_prove.sh' script when TAP_CHECKS are enabled. Sets up all required testing environment variables like CONFDIR, PATH, PG_REGRESS, SRC_DIR, and others. Uses rm to remove previous temp directories before invoking the TAP suite. Appends the target to _install_checks for aggregation. Assumes Perl and TAP harness prerequisites are met.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(\n  provecheck\n  COMMAND rm -rf ${CMAKE_CURRENT_BINARY_DIR}/tmp_check\n  COMMAND\n    CONFDIR=${CMAKE_BINARY_DIR}/test PATH=\"${PG_BINDIR}:$ENV{PATH}\"\n    PG_REGRESS=${PG_REGRESS} SRC_DIR=${PG_SOURCE_DIR}\n    CM_SRC_DIR=${CMAKE_SOURCE_DIR} PG_LIBDIR=${PG_LIBDIR}\n    PG_PKGLIBDIR=${PG_PKGLIBDIR} PG_VERSION_MAJOR=${PG_VERSION_MAJOR}\n    ${PRIMARY_TEST_DIR}/pg_prove.sh\n  USES_TERMINAL)\nlist(APPEND _install_checks provecheck)\n```\n\n----------------------------------------\n\nTITLE: Setting Position-Independent Code for Test Library in CMake\nDESCRIPTION: This snippet sets the `POSITION_INDEPENDENT_CODE` property to `ON` for the `TSL_TESTS_LIB_NAME` library.  This is crucial because the test library is designed to be linked into a loadable extension module, which requires position-independent code (PIC) to function correctly, typically achieved using the `-fPIC` compiler flag.  This ensures that the library can be loaded at any memory address.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/src/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset_target_properties(${TSL_TESTS_LIB_NAME} PROPERTIES POSITION_INDEPENDENT_CODE\n                                                       ON)\n```\n\n----------------------------------------\n\nTITLE: Connecting to TimescaleDB Instance Using Docker Exec (Bash)\nDESCRIPTION: This command connects interactively to the TimescaleDB container's PostgreSQL instance using the psql command-line tool. Assumes the timescaledb container is running and exposes PostgreSQL on localhost with authentication parameters as shown. Users must have Docker and psql installed to execute this command. The connection string specifies the default database and user.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\ndocker exec -it timescaledb psql -d \"postgres://postgres:password@localhost/postgres\"\n```\n\n----------------------------------------\n\nTITLE: Defining Test Target for Isolation Checks with pg_isolation_regress (CMake)\nDESCRIPTION: Adds a CMake target 'isolationcheck' for running isolation tests using 'pg_isolation_regress' if available. Configures custom environment variables including SPECS_DIR and TEST_PGPORT, and executes 'pg_regress.sh' with isolation-specific flags. Appends the new target to _install_checks. Assumes all isolation test requirements and PostgreSQL build tools are present.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(\n  isolationcheck\n  COMMAND\n    ${CMAKE_COMMAND} -E env ${PG_ISOLATION_REGRESS_ENV}\n    SPECS_DIR=${CMAKE_CURRENT_SOURCE_DIR}/isolation/specs\n    TEST_PGPORT=${TEST_PGPORT_TEMP_INSTANCE}\n    ${CMAKE_CURRENT_SOURCE_DIR}/pg_regress.sh ${PG_REGRESS_OPTS_BASE}\n    ${PG_ISOLATION_REGRESS_OPTS_EXTRA} ${PG_ISOLATION_REGRESS_OPTS_INOUT}\n    ${PG_REGRESS_OPTS_TEMP_INSTANCE}\n    --temp-config=${TEST_OUTPUT_DIR}/postgresql.conf\n  USES_TERMINAL)\n\nlist(APPEND _install_checks isolationcheck)\n```\n\n----------------------------------------\n\nTITLE: Building TimescaleDB from Source - Unix (Bash)\nDESCRIPTION: This Bash script demonstrates the steps to build TimescaleDB from source code on Unix-based systems. It assumes the necessary prerequisites such as PostgreSQL, a C compiler (e.g., gcc or clang), and CMake are installed. The script clones the TimescaleDB repository, navigates to the directory, checks out a specific release tag, bootstraps the build system, builds the extension, and installs it. Users should replace `2.15.0` with the actual release tag.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/docs/BuildSource.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:timescale/timescaledb.git\ncd timescaledb\n# Find the latest release and checkout, e.g. for 2.15.0:\ngit checkout 2.15.0\n# Bootstrap the build system\n./bootstrap\n# To build the extension\ncd build && make\n# To install\nmake install\n```\n\n----------------------------------------\n\nTITLE: Setting Parallel Test Group Size in CMake\nDESCRIPTION: Determines the size of groups for parallel test execution. If the `TEST_GROUP_SIZE` variable is not defined, it defaults `PARALLEL_GROUP_SIZE` to 20. Otherwise, it uses the value provided in `TEST_GROUP_SIZE`.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/shared/sql/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT TEST_GROUP_SIZE)\n  set(PARALLEL_GROUP_SIZE 20)\nelse()\n  set(PARALLEL_GROUP_SIZE ${TEST_GROUP_SIZE})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Illustrating Basic SkipScan SQL Query Plan Structure\nDESCRIPTION: Shows the fundamental structure of a SkipScan query plan in TimescaleDB. A `Custom Scan (SkipScan)` node wraps an underlying `Index Scan`. The `Index Scan` initially uses a condition like `key > NULL`, which is updated iteratively during execution to skip directly to the next distinct value based on the index.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/nodes/skip_scan/README.md#_snippet_0\n\nLANGUAGE: SQL\nCODE:\n```\nCustom Scan (SkipScan) on table\n   ->  Index Scan using table_key_idx on table\n       Index Cond: (key > NULL)\n```\n\n----------------------------------------\n\nTITLE: Building TimescaleDB from Source - Windows (Bash)\nDESCRIPTION: This Bash script outlines the steps to build TimescaleDB from source on Windows using command line tools. It assumes the prerequisites like PostgreSQL, OpenSSL, Microsoft Visual Studio, CMake, and Git are set up. It clones the repository, checks out a specific release tag, bootstraps the build system using `bootstrap.bat`, builds the extension using CMake, and installs the extension. The user needs to replace `2.15.0` with the correct release tag.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/docs/BuildSource.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:timescale/timescaledb.git\ncd timescaledb\n\n# Find the latest release and checkout, e.g. for 2.15.0:\ngit checkout 2.15.0\n# Bootstrap the build system\nbootstrap.bat\n# To build the extension from command line\ncmake --build ./build --config Release\n# To install\ncmake --build ./build --config Release --target install\n\n# Alternatively, build in Visual Studio via its built-in support for\n# CMake or by opening the generated build/timescaledb.sln solution file.\n```\n\n----------------------------------------\n\nTITLE: Aggregating and Defining Custom Install/Test Targets (CMake)\nDESCRIPTION: Creates generalized CMake targets 'installcheck', 'installchecklocal', and 'installcheck-post-hook', along with a post-build custom command. These aggregate all previously defined test checks (_install_checks and _local_install_checks), enabling a single invocation to run all grouped test suites. A post-hook allows dependent custom actions, e.g., code coverage or post-processing, once tests complete. Implements dependencies via CMake's DEPENDS and add_custom_command constructs.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(installcheck DEPENDS ${_install_checks})\n\nadd_custom_target(installcheck-post-hook COMMENT \"Post test hook\")\nadd_custom_command(\n  TARGET installcheck\n  POST_BUILD\n  COMMAND cmake --build ${CMAKE_CURRENT_BINARY_DIR} --target\n          installcheck-post-hook)\n\nadd_custom_target(installchecklocal DEPENDS ${_local_install_checks})\n```\n\n----------------------------------------\n\nTITLE: Creating installchecklocal Target\nDESCRIPTION: Defines a custom target `installchecklocal-t` that depends on all the targets accumulated in the `_local_install_checks` list.  This target is used to run all the local instance tests during the installation check. Then sets dependency for installcheck target to installchecklocal-t target.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/CMakeLists.txt#_snippet_14\n\nLANGUAGE: cmake\nCODE:\n```\nif(_local_install_checks)\n  add_custom_target(installchecklocal-t DEPENDS ${_local_install_checks})\n  add_dependencies(installchecklocal installchecklocal-t)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring the TimescaleDB Test Library Build in CMake\nDESCRIPTION: This CMake code defines the source files for the TimescaleDB test library using `set(SOURCES ...)`.\nIt then creates an object library named `${TESTS_LIB_NAME}` using `add_library()`.\nThe `set_target_properties()` command ensures the library is compiled with position-independent code (`-fPIC`).\nA preprocessor definition `MODULE_NAME=timescaledb` is added using `target_compile_definitions()`.\nInclude directories are set using `target_include_directories()`.\nFinally, `add_subdirectory()` includes tests for background workers (bgw), networking (net), telemetry (conditionally based on `USE_TELEMETRY`), and the loader.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/src/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    adt_tests.c\n    metadata.c\n    symbol_conflict.c\n    test_scanner.c\n    test_time_to_internal.c\n    test_time_utils.c\n    test_tss_callbacks.c\n    test_utils.c\n    test_with_clause_parser.c)\n\ninclude(${PROJECT_SOURCE_DIR}/src/build-defs.cmake)\n\nadd_library(${TESTS_LIB_NAME} OBJECT ${SOURCES})\n\n# Since the test library will be linked into the loadable extension module, it\n# needs to be compiled as position-independent code (e.g., the -fPIC compiler\n# flag for GCC)\nset_target_properties(${TESTS_LIB_NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)\n\n# Set the MODULE_NAME for the symbol conflict test (see symbol_conflict.c)\ntarget_compile_definitions(${TESTS_LIB_NAME} PUBLIC MODULE_NAME=timescaledb)\ntarget_include_directories(${TESTS_LIB_NAME}\n                           PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})\n\nadd_subdirectory(bgw)\nadd_subdirectory(net)\nif(USE_TELEMETRY)\n  add_subdirectory(telemetry)\nendif()\n\nadd_subdirectory(loader)\n```\n\n----------------------------------------\n\nTITLE: Configuring Regression Test Tools in CMake\nDESCRIPTION: Sets up regression testing tools for TimescaleDB by locating pg_regress and pg_isolation_regress executables. These are PostgreSQL's test frameworks that allow validating the extension's functionality through regression tests and isolation tests.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_25\n\nLANGUAGE: CMake\nCODE:\n```\nif(REGRESS_CHECKS)\n  find_program(PG_REGRESS pg_regress\n               HINTS \"${PG_BINDIR}\" \"${PG_PKGLIBDIR}/pgxs/src/test/regress/\")\n\n  if(NOT PG_REGRESS)\n    message(STATUS \"Regress checks disabled: program 'pg_regress' not found\")\n  endif()\n\n  find_program(\n    PG_ISOLATION_REGRESS\n    NAMES pg_isolation_regress\n    HINTS ${PG_BINDIR} ${PG_PKGLIBDIR}/pgxs/src/test/isolation\n          ${PG_SOURCE_DIR}/src/test/isolation ${BINDIR})\n\n  if(NOT PG_ISOLATION_REGRESS)\n    message(\n      STATUS\n        \"Isolation regress checks disabled: 'pg_isolation_regress' not found\")\n  endif()\nelse()\n  message(STATUS \"Regress checks and isolation checks disabled\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Checking PostgreSQL Headers and Configuring Assertions in CMake\nDESCRIPTION: Verifies that the PostgreSQL headers are present and configures assertion checking for TimescaleDB. The code checks for pg_config.h, determines if PostgreSQL was built with assertions enabled, and configures TimescaleDB accordingly, with appropriate status messages.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_27\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT EXISTS ${PG_INCLUDEDIR}/pg_config.h)\n  message(\n    FATAL_ERROR\n      \"Could not find pg_config.h in ${PG_INCLUDEDIR}. \"\n      \"Make sure PG_PATH points to a valid PostgreSQL installation that includes development headers.\"\n  )\nendif()\n\nfile(READ ${PG_INCLUDEDIR}/pg_config.h PG_CONFIG_H)\nstring(REGEX MATCH \"#define USE_ASSERT_CHECKING 1\" PG_USE_ASSERT_CHECKING\n             ${PG_CONFIG_H})\n\nif(PG_USE_ASSERT_CHECKING AND NOT ASSERTIONS)\n  message(\n    STATUS\n      \"Assertion checks are OFF although enabled in PostgreSQL build (pg_config.h). \"\n      \"The PostgreSQL setting for assertions will take precedence.\")\nelseif(ASSERTIONS)\n  message(STATUS \"Assertion checks are ON\")\n  add_compile_definitions(USE_ASSERT_CHECKING=1)\nelseif(CMAKE_BUILD_TYPE MATCHES Debug)\n  message(\n    \"Assertion checks are OFF in Debug build. Set -DASSERTIONS=ON to enable assertions.\"\n  )\nelse()\n  message(STATUS \"Assertion checks are OFF\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Generating versioned SQL update scripts using CMake\nDESCRIPTION: This snippet processes a list of SQL module files representing database schema updates, verifying file name patterns to extract start and end version numbers. For each module, it builds pre-update and post-update file lists, ensures inclusion of version check scripts, and concatenates appropriate SQL segments using a custom 'cat_files' function to create comprehensive update scripts. It handles cases where no changes exist and prepares a list of update scripts for later inclusion in build and install targets. Dependencies include standard CMake variables and the custom functions 'cat_files', 'version_files', and 'version_check_file'. The input is lists of SQL update files and version variables; the output is versioned SQL update scripts ready for installation.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/sql/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(transition_mod_file ${MOD_FILES_LIST})\n\n  if(NOT (${transition_mod_file} MATCHES ${MOD_FILE_REGEX}))\n    message(FATAL_ERROR \"Cannot parse update file name ${transition_mod_file}\")\n  endif()\n\n  set(START_VERSION ${CMAKE_MATCH_1})\n  set(END_VERSION ${CMAKE_MATCH_2})\n  set(PRE_FILES ${PRE_UPDATE_FILES_VERSIONED})\n  set(POST_FILES_PROCESSED ${POST_UPDATE_FILES_VERSIONED}.processed)\n  cat_files(\n    \"${SET_POST_UPDATE_STAGE};${POST_UPDATE_FILES_VERSIONED};${UNSET_UPDATE_STAGE}\"\n    ${POST_FILES_PROCESSED})\n  # Check for version-specific update code with fixes\n  if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/updates/${START_VERSION}.sql)\n    version_files(\"updates/${START_VERSION}.sql\" ORIGIN_MOD_FILE)\n    list(APPEND PRE_FILES ${ORIGIN_MOD_FILE})\n  endif()\n\n  version_check_file(\"updates/version_check.sql\" VERSION_CHECK_VERSIONED)\n  list(PREPEND PRE_FILES ${VERSION_CHECK_VERSIONED})\n\n  # There might not have been any changes in the modfile, in which case the\n  # modfile need not be present\n  if(EXISTS ${transition_mod_file})\n    # Prepend the modfile as we are moving through the versions in descending\n    # order\n    list(INSERT CURR_MOD_FILES 0 ${transition_mod_file})\n  endif()\n\n  set(UPDATE_SCRIPT\n      ${CMAKE_CURRENT_BINARY_DIR}/timescaledb--${START_VERSION}--${PROJECT_VERSION_MOD}.sql\n  )\n  list(APPEND UPDATE_SCRIPTS ${UPDATE_SCRIPT})\n  if(CURR_MOD_FILES)\n    cat_files(\n      \"${PRE_FILES};${CURR_MOD_FILES};${PRE_INSTALL_FUNCTION_FILES_VERSIONED};${SOURCE_FILES_VERSIONED};${POST_FILES_PROCESSED}\"\n      ${UPDATE_SCRIPT})\n  else()\n    cat_files(\n      \"${PRE_FILES};${PRE_INSTALL_FUNCTION_FILES_VERSIONED};${SOURCE_FILES_VERSIONED};${POST_FILES_PROCESSED}\"\n      ${UPDATE_SCRIPT})\n  endif()\n\nendforeach(transition_mod_file)\n```\n\n----------------------------------------\n\nTITLE: Defining the TSL Shared Library Target in CMake\nDESCRIPTION: Creates the TSL shared library target using `add_library` with the `MODULE` type. It conditionally includes test object files (`$<TARGET_OBJECTS:${TSL_TESTS_LIB_NAME}>`) if the build type is 'Debug' or if `COMPRESSION_FUZZING` is enabled, linking test code directly into debug builds.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES Debug OR COMPRESSION_FUZZING)\n  add_library(${TSL_LIBRARY_NAME} MODULE\n              ${SOURCES} $<TARGET_OBJECTS:${TSL_TESTS_LIB_NAME}>)\nelse()\n  add_library(${TSL_LIBRARY_NAME} MODULE ${SOURCES})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Generating Version-Specific Tests from Templates in CMake\nDESCRIPTION: Iterates through each template file listed in `TEST_TEMPLATES_SHARED`. For each template, it calculates the base name, constructs a version-specific output filename using the `TEST_VERSION_SUFFIX` variable, uses `configure_file` to copy the template content to the new file in the source directory (`CMAKE_CURRENT_SOURCE_DIR`), and appends the generated filename to the `TEST_FILES_SHARED` list. This allows tests to vary based on the PostgreSQL version.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/shared/sql/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\n# Regression tests that vary with PostgreSQL version. Generated test files are\n# put in the original source directory since all tests must be in the same\n# directory. These files are updated when the template is edited, but not when\n# the output file is deleted. If the output is deleted either recreate it\n# manually, or rerun cmake on the root dir.\nforeach(TEMPLATE_FILE ${TEST_TEMPLATES_SHARED})\n  string(LENGTH ${TEMPLATE_FILE} TEMPLATE_NAME_LEN)\n  math(EXPR TEMPLATE_NAME_LEN ${TEMPLATE_NAME_LEN}-7)\n  string(SUBSTRING ${TEMPLATE_FILE} 0 ${TEMPLATE_NAME_LEN} TEMPLATE)\n  set(TEST_FILE ${TEMPLATE}-${TEST_VERSION_SUFFIX}.sql)\n  configure_file(${TEMPLATE_FILE} ${CMAKE_CURRENT_SOURCE_DIR}/${TEST_FILE}\n                 COPYONLY)\n  list(APPEND TEST_FILES_SHARED ${TEST_FILE})\nendforeach(TEMPLATE_FILE)\n```\n\n----------------------------------------\n\nTITLE: Checking PostgreSQL Version Compatibility in CMake\nDESCRIPTION: Executes pg_config to retrieve PostgreSQL version, parses the version string using regex, and verifies compatibility with TimescaleDB. The code extracts major and minor version numbers and validates that PostgreSQL 15, 16, or 17 is being used.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_19\n\nLANGUAGE: CMake\nCODE:\n```\nexecute_process(\n  COMMAND ${PG_CONFIG} --version\n  OUTPUT_VARIABLE PG_VERSION_STRING\n  OUTPUT_STRIP_TRAILING_WHITESPACE)\n\nif(NOT ${PG_VERSION_STRING} MATCHES\n   \"^PostgreSQL[ ]+([0-9]+)(\\\\.([0-9]+)|beta|devel|rc[0-9]+)\")\n  message(FATAL_ERROR \"Could not parse PostgreSQL version ${PG_VERSION_STRING}\")\nendif()\n\nset(PG_VERSION_MAJOR ${CMAKE_MATCH_1})\nif(${CMAKE_MATCH_COUNT} GREATER \"2\")\n  set(PG_VERSION_MINOR ${CMAKE_MATCH_3})\nelse()\n  set(PG_VERSION_MINOR 0)\nendif()\nset(PG_VERSION \"${PG_VERSION_MAJOR}.${PG_VERSION_MINOR}\")\n\nmessage(\n  STATUS\n    \"Compiling against PostgreSQL version ${PG_VERSION} using pg_config '${PG_CONFIG}'\"\n)\n\nif((${PG_VERSION_MAJOR} LESS \"15\")\n   OR (${PG_VERSION_MAJOR} GREATER \"17\")\n   AND NOT (${EXPERIMENTAL}))\n  message(FATAL_ERROR \"TimescaleDB only supports PostgreSQL 15, 16 and 17\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring PostgreSQL Source Directory for TimescaleDB Tests Using Shell\nDESCRIPTION: This shell snippet demonstrates the commands necessary to create a build directory, move into it, and invoke CMake to configure the build with the PostgreSQL source directory specified. The `PG_SOURCE_DIR` variable points to the PostgreSQL source code directory, required to locate PostgreSQL's test suite sources for integration testing with TimescaleDB. The setup ensures that TimescaleDB's changes are tested against PostgreSQL's standard regression tests.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/pgtest/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n# In top-level directory of a TimescaleDB source tree\n$ mkdir build && cd build\n$ cmake -DPG_SOURCE_DIR=<path/to/pg/source> ..\n```\n\n----------------------------------------\n\nTITLE: Checking for Supported Compilers\nDESCRIPTION: Checks if the compiler used is a supported compiler. It compares the `CMAKE_C_COMPILER_ID` against a list of supported compilers. If an unsupported compiler is detected, it raises a fatal error. This check prevents compilation with unsupported compilers.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nset(SUPPORTED_COMPILERS \"GNU\" \"Clang\" \"AppleClang\" \"MSVC\")\n\n# Check for a supported compiler\nif(NOT CMAKE_C_COMPILER_ID IN_LIST SUPPORTED_COMPILERS)\n  message(\n    FATAL_ERROR\n      \"Unsupported compiler ${CMAKE_C_COMPILER_ID}. Supported compilers are: ${SUPPORTED_COMPILERS}\"\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Retrieving PostgreSQL Configuration Settings in CMake\nDESCRIPTION: Uses pg_config to fetch various PostgreSQL directories and compilation flags. This includes include directories, library paths, shared directories, binary paths, and compiler flags that will be used during the TimescaleDB build process.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_20\n\nLANGUAGE: CMake\nCODE:\n```\nget_pg_config(PG_INCLUDEDIR --includedir)\nget_pg_config(PG_INCLUDEDIR_SERVER --includedir-server)\nget_pg_config(PG_LIBDIR --libdir)\nget_pg_config(PG_PKGLIBDIR --pkglibdir)\nget_pg_config(PG_SHAREDIR --sharedir)\nget_pg_config(PG_BINDIR --bindir)\nget_pg_config(PG_CFLAGS --cflags)\nget_pg_config(PG_CFLAGS_SL --cflags_sl)\nget_pg_config(PG_CPPFLAGS --cppflags)\nget_pg_config(PG_LDFLAGS --ldflags)\nget_pg_config(PG_LIBS --libs)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Clang-Tidy Linter in CMake\nDESCRIPTION: Configures clang-tidy as a C code linter for the TimescaleDB project. This tool checks for common programming errors, style violations, and potential bugs. The configuration includes specific checks to enable or disable based on project preferences and can be set to treat warnings as errors.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_26\n\nLANGUAGE: CMake\nCODE:\n```\noption(LINTER \"Enable linter support using clang-tidy\" OFF)\nset(CLANG_TIDY_EXTRA_OPTS\n    \"\"\n    CACHE STRING \"Additional options for clang-tidy\")\n\nif(LINTER)\n  find_program(\n    CLANG_TIDY clang-tidy\n    PATHS /usr/bin /usr/local/bin /usr/local/opt/ /usr/local/opt/llvm/bin\n          /opt/bin\n    DOC \"The path to the clang-tidy linter\" REQUIRED)\n\n  message(STATUS \"Using clang-tidy ${CLANG_TIDY}\")\n  execute_process(COMMAND ${CLANG_TIDY} --version)\n  string(\n    CONCAT\n      CMAKE_C_CLANG_TIDY\n      \"${CLANG_TIDY}\"\n      \";--checks=clang-diagnostic-*,clang-analyzer-*\"\n      \",-clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling\"\n      \",-clang-analyzer-deadcode.DeadStores\"\n      \",bugprone-*\"\n      \",-bugprone-branch-clone\"\n      \",-bugprone-easily-swappable-parameters\"\n      \",-bugprone-implicit-widening-of-multiplication-result\"\n      \",-bugprone-narrowing-conversions\"\n      \",-bugprone-reserved-identifier\"\n      \",-bugprone-suspicious-include\"\n      \",readability-*\"\n      \",-readability-avoid-const-params-in-decls\"\n      \",-readability-braces-around-statements\"\n      \",-readability-else-after-return\"\n      \",-readability-function-cognitive-complexity\"\n      \",-readability-function-size\"\n      \",-readability-identifier-length\"\n      \",-readability-isolate-declaration\"\n      \",-readability-magic-numbers\"\n      \",-readability-non-const-parameter\"\n      \"${CLANG_TIDY_EXTRA_OPTS}\")\n  if(WARNINGS_AS_ERRORS)\n    set(CMAKE_C_CLANG_TIDY \"${CMAKE_C_CLANG_TIDY};--warnings-as-errors=*\")\n  else()\n    set(CMAKE_C_CLANG_TIDY \"${CMAKE_C_CLANG_TIDY};--quiet\")\n  endif(WARNINGS_AS_ERRORS)\nendif(LINTER)\n```\n\n----------------------------------------\n\nTITLE: Conditional Inclusion of Test Subdirectories (CMake)\nDESCRIPTION: Includes test suite subdirectories (e.g., 'sql', 'isolation', 't', 'pgtest', 'src', 'perl') using CMake's add_subdirectory function. Some are always included, while others like 'pgtest' and 'src' are conditionally included based on PG_SOURCE_DIR and build type. This modularly structures the test environment to scale with different project builds. No direct input/output, but enables inclusion of additional tests and targets defined in subdirectories.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(sql)\nadd_subdirectory(isolation)\nadd_subdirectory(t)\n\nif(PG_SOURCE_DIR)\n  add_subdirectory(pgtest)\nendif(PG_SOURCE_DIR)\n\nif(CMAKE_BUILD_TYPE MATCHES Debug)\n  add_subdirectory(src)\nendif(CMAKE_BUILD_TYPE MATCHES Debug)\n\nadd_subdirectory(perl)\n```\n\n----------------------------------------\n\nTITLE: Setting Warnings as Errors\nDESCRIPTION: Sets the compiler to treat warnings as errors based on the build type. If the build type is Debug, it sets the `WARNINGS_AS_ERRORS` option to ON, otherwise to OFF. Then, based on the chosen value and compiler ID, it adds the corresponding compiler flags. This can help to identify potential issues during the build process.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\n# Option to treat warnings as errors when compiling (default on for debug\n# builds, off for all other build types)\nif(CMAKE_BUILD_TYPE STREQUAL Debug)\n  option(WARNINGS_AS_ERRORS \"Make compiler warnings into errors (default ON)\"\n         ON)\nelse()\n  option(WARNINGS_AS_ERRORS \"Make compiler warnings into errors (default ON)\"\n         OFF)\nendif()\n\nif(WARNINGS_AS_ERRORS)\n  if(CMAKE_C_COMPILER_ID MATCHES \"GNU|Clang|AppleClang\")\n    add_compile_options(-Werror)\n  elseif(CMAKE_C_COMPILER_ID MATCHES \"MSVC\")\n    add_compile_options(/WX)\n  endif()\nendif(WARNINGS_AS_ERRORS)\n```\n\n----------------------------------------\n\nTITLE: Extracting pg_config Values\nDESCRIPTION: This function calls `pg_config` (PostgreSQL configuration utility) to extract values and store them in a CMake variable.  It handles potential errors by translating \"not recorded\" values on Windows into undefined variables. It takes the name of the variable as input and uses `execute_process` to run `pg_config` with the provided arguments, retrieving the output and setting the parent scope variable.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(GET_PG_CONFIG var)\n  set(_temp)\n\n  # Only call pg_config if the variable didn't already have a value.\n  if(NOT ${var})\n    execute_process(\n      COMMAND ${CMAKE_COMMAND} -E env LC_MESSAGES=C ${PG_CONFIG} ${ARGN}\n      OUTPUT_VARIABLE _temp\n      OUTPUT_STRIP_TRAILING_WHITESPACE)\n  endif()\n\n  # On Windows, fields that are not recorded will be given the value \"not\n  # recorded\", so we translate this into <var>-NOTFOUND to make it undefined.\n  #\n  # It will then also show as, e.g., \"PG_LDFLAGS-NOTFOUND\" in any string\n  # interpolation, making it obvious that it is an undefined CMake variable.\n  if(\"${_temp}\" STREQUAL \"not recorded\")\n    set(_temp ${var}-NOTFOUND)\n  endif()\n\n  set(${var}\n      ${_temp}\n      PARENT_SCOPE)\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Creating Library with Sources\nDESCRIPTION: This snippet creates the shared library using the collected source files and git commit info.  The `add_library` command specifies the library name and the list of source files. The source files and the git commit information are compiled together into a single library, and then output to the build directory.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES Debug)\n  add_library(${PROJECT_NAME} MODULE ${SOURCES} ${GITCOMMIT_H}\n                                     $<TARGET_OBJECTS:${TESTS_LIB_NAME}>)\nelse()\n  add_library(${PROJECT_NAME} MODULE ${SOURCES} ${GITCOMMIT_H})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Including Subdirectories in the CMake Build\nDESCRIPTION: Uses the `add_subdirectory` command multiple times to include other CMake build configurations located in specified subdirectories (bgw_policy, compression, continuous_aggs, import, hypercore, nodes). This incorporates these components (and their respective targets and build logic) into the main TSL build process.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/CMakeLists.txt#_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(bgw_policy)\nadd_subdirectory(compression)\nadd_subdirectory(continuous_aggs)\nadd_subdirectory(import)\nadd_subdirectory(hypercore)\nadd_subdirectory(nodes)\n```\n\n----------------------------------------\n\nTITLE: Adding src Subdirectory for Debug Builds\nDESCRIPTION: Conditionally adds the `src` subdirectory to the build process if the build type is `Debug` or if `COMPRESSION_FUZZING` is enabled. This is likely to include source code that is relevant during debug builds.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/CMakeLists.txt#_snippet_16\n\nLANGUAGE: cmake\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES Debug OR COMPRESSION_FUZZING)\n  add_subdirectory(src)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Update and Downgrade SQL File Lists for TimescaleDB with CMake\nDESCRIPTION: This snippet sets CMake lists for SQL files representing incremental modification scripts for TimescaleDB versions (MOD_FILES) and downgrade scripts (OLD_REV_FILES). These lists specify the relative paths to SQL scripts that apply version-specific changes and reversions. The CURRENT_REV_FILE variable holds the filename for the current downgrade script. These variables are used later to generate the extension update/downgrade scripts. Dependencies include accurate versioning naming conventions in the SQL files, and the files must reside in the specified 'updates' directory.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/sql/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(MOD_FILES\n    updates/2.9.0--2.9.1.sql\n    updates/2.9.1--2.9.2.sql\n    updates/2.9.2--2.9.3.sql\n    updates/2.9.3--2.10.0.sql\n    updates/2.10.0--2.10.1.sql\n    updates/2.10.1--2.10.2.sql\n    updates/2.10.2--2.10.3.sql\n    updates/2.10.3--2.11.0.sql\n    updates/2.11.0--2.11.1.sql\n    updates/2.11.1--2.11.2.sql\n    updates/2.11.2--2.12.0.sql\n    updates/2.12.0--2.12.1.sql\n    updates/2.12.1--2.12.2.sql\n    updates/2.12.2--2.13.0.sql\n    updates/2.13.0--2.13.1.sql\n    updates/2.13.1--2.14.0.sql\n    updates/2.14.0--2.14.1.sql\n    updates/2.14.1--2.14.2.sql\n    updates/2.14.2--2.15.0.sql\n    updates/2.15.0--2.15.1.sql\n    updates/2.15.1--2.15.2.sql\n    updates/2.15.2--2.15.3.sql\n    updates/2.15.3--2.16.0.sql\n    updates/2.16.0--2.16.1.sql\n    updates/2.16.1--2.17.0.sql\n    updates/2.17.0--2.17.1.sql\n    updates/2.17.1--2.17.2.sql\n    updates/2.17.2--2.18.0.sql\n    updates/2.18.0--2.18.1.sql\n    updates/2.18.1--2.18.2.sql\n    updates/2.18.2--2.19.0.sql\n    updates/2.19.0--2.19.1.sql\n    updates/2.19.1--2.19.2.sql\n    updates/2.19.2--2.19.3.sql)\n\nset(CURRENT_REV_FILE reverse-dev.sql)\n\nset(OLD_REV_FILES\n    2.9.1--2.9.0.sql\n    2.9.2--2.9.1.sql\n    2.9.3--2.9.2.sql\n    2.10.0--2.9.3.sql\n    2.10.1--2.10.0.sql\n    2.10.2--2.10.1.sql\n    2.10.3--2.10.2.sql\n    2.11.0--2.10.3.sql\n    2.11.1--2.11.0.sql\n    2.11.2--2.11.1.sql\n    2.12.0--2.11.2.sql\n    2.12.1--2.12.0.sql\n    2.12.2--2.12.1.sql\n    2.13.0--2.12.2.sql\n    2.13.1--2.13.0.sql\n    2.14.0--2.13.1.sql\n    2.14.1--2.14.0.sql\n    2.14.2--2.14.1.sql\n    2.15.0--2.14.2.sql\n    2.15.1--2.15.0.sql\n    2.15.2--2.15.1.sql\n    2.15.3--2.15.2.sql\n    2.16.0--2.15.3.sql\n    2.16.1--2.16.0.sql\n    2.17.0--2.16.1.sql\n    2.17.1--2.17.0.sql\n    2.17.2--2.17.1.sql\n    2.18.0--2.17.2.sql\n    2.18.1--2.18.0.sql\n    2.18.2--2.18.1.sql\n    2.19.0--2.18.2.sql\n    2.19.1--2.19.0.sql\n    2.19.2--2.19.1.sql\n    2.19.3--2.19.2.sql)\n```\n\n----------------------------------------\n\nTITLE: Enabling Code Coverage with CMake\nDESCRIPTION: This snippet describes how to enable code coverage for TimescaleDB builds using CMake. It involves setting the `-DCODECOVEAGE=ON` option during the CMake configuration. This enables the compiler's `--coverage` option, which generates code coverage statistics. This is a prerequisite for generating the reports. This setting is required to utilize tools like codecov.io.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/codecov/README.md#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake -DCODECOVEAGE=ON ...\n```\n\n----------------------------------------\n\nTITLE: Generating HTML Code Coverage Report (CMake)\nDESCRIPTION: This snippet details how to generate an HTML-based code coverage report after the test suite has been executed.  It uses the `coverage` target in CMake.  The primary prerequisite is the successful completion of the `installcheck` target. The steps involves building, running installcheck, and then building the coverage target.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/codecov/README.md#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ncmake --build\ncmake --build --target installcheck\ncmake --build --target coverage\n```\n\n----------------------------------------\n\nTITLE: Setting and Appending Source Files Conditionally in CMake - CMake\nDESCRIPTION: This CMake snippet defines a SOURCES variable containing several C source files located in the current directory. It conditionally appends an extra source file, import/analyze.c, if the detected PostgreSQL version is greater than or equal to 17.0. Finally, it assigns all gathered source files to the build target specified by TSL_LIBRARY_NAME, ensuring that the modular C components are compiled into the TimescaleDB library. The build process depends on the CMake tool and the correct definition of PG_VERSION and TSL_LIBRARY_NAME; paths must resolve correctly, and the underlying sources should exist.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/hypercore/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/arrow_tts.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/arrow_cache.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/arrow_array.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/arrow_cache_explain.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/attr_capture.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/hypercore_handler.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/hypercore_proxy.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/relstats.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/utils.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/vector_quals.c)\nif(PG_VERSION VERSION_GREATER_EQUAL \"17.0\")\n  list(APPEND SOURCES ${CMAKE_CURRENT_SOURCE_DIR}/import/analyze.c)\nendif()\ntarget_sources(${TSL_LIBRARY_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Conditionally Include and Build Sources Without Static Analysis in CMake\nDESCRIPTION: This CMake code checks if the `USE_UMASH` variable is true. If so, it adds `umash.c` to the `SOURCES` list. It then creates an OBJECT library named `target_no_static_code_analysis` from any files listed in `SOURCES`. Static analysis via `clang-tidy` is explicitly disabled for this object library using `set_target_properties`. Finally, the object files generated by this library are linked privately into the main target specified by the variable `TSL_LIBRARY_NAME` using generator expressions.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/import/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES)\n\nif(USE_UMASH)\n  list(APPEND SOURCES ${CMAKE_CURRENT_SOURCE_DIR}/umash.c)\nendif()\n\nif(SOURCES)\n  # Disable clang-tidy for imported code\n  add_library(target_no_static_code_analysis OBJECT ${SOURCES})\n  set_target_properties(target_no_static_code_analysis PROPERTIES C_CLANG_TIDY\n                                                                  \"\")\n  target_sources(${TSL_LIBRARY_NAME}\n                 PRIVATE $<TARGET_OBJECTS:target_no_static_code_analysis>)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Project Definition and Configuration\nDESCRIPTION: Defines the project's name, version, and language. It also sets the build type (Debug, Release, etc.) if not already specified. Sets flags for build types. It validates that the build type is supported and prints messages with status updates of the configuration.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\n# Set project name, version, and language. Language needs to be set for compiler\n# checks\nproject(\n  timescaledb\n  VERSION ${VERSION}\n  LANGUAGES C)\n\nif(NOT CMAKE_BUILD_TYPE)\n  # Default to Release builds\n  set(CMAKE_BUILD_TYPE\n      Release\n      CACHE\n        STRING\n        \"Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel\"\n        FORCE)\nendif()\n\nset(SUPPORTED_BUILD_TYPES Debug Release RelWithDebInfo MinSizeRel)\nif(NOT CMAKE_BUILD_TYPE IN_LIST SUPPORTED_BUILD_TYPES)\n  message(\n    FATAL_ERROR \"Bad CMAKE_BUILD_TYPE. Expected one of ${SUPPORTED_BUILD_TYPES}\"\n  )\nendif()\n\nmessage(\n  STATUS\n    \"TimescaleDB version ${PROJECT_VERSION_MOD}. Can be updated from version ${PREVIOUS_VERSION}\"\n)\nmessage(STATUS \"Build type is ${CMAKE_BUILD_TYPE}\")\n\n```\n\n----------------------------------------\n\nTITLE: Configuring TAP Test Support with Perl in CMake\nDESCRIPTION: Sets up support for TAP (Test Anything Protocol) tests based on the TAP_CHECKS option. It finds the Perl interpreter (version 5.8 or later), locates the 'prove' test harness executable, and verifies the availability of the 'IPC::Run' Perl module. If any dependency is missing, TAP testing is disabled, and a status message is printed.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_31\n\nLANGUAGE: CMake\nCODE:\n```\n# TAP test support\noption(TAP_CHECKS \"Enable TAP test support\" ON)\n\nif(TAP_CHECKS)\n  find_package(Perl 5.8)\n\n  if(PERL_FOUND)\n    get_filename_component(PERL_BIN_PATH ${PERL_EXECUTABLE} DIRECTORY)\n\n    find_program(\n      PROVE prove\n      HINTS ${PERL_BIN_PATH}\n      PATHS \"/usr/bin\")\n\n    if(NOT PROVE)\n      message(STATUS \"Not running TAP tests: 'prove' binary not found.\")\n      set(TAP_CHECKS OFF)\n    endif()\n\n    # Check for the IPC::Run module\n    execute_process(\n      COMMAND ${PERL_EXECUTABLE} -MIPC::Run -e \"\"\n      ERROR_QUIET\n      RESULT_VARIABLE PERL_MODULE_STATUS)\n\n    if(PERL_MODULE_STATUS)\n      message(STATUS \"Not running TAP tests: IPC::Run Perl module not found.\")\n      set(TAP_CHECKS OFF)\n    endif()\n  else()\n    message(STATUS \"Not running TAP tests: Perl not found.\")\n    set(TAP_CHECKS OFF)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding UMASH Compile Definition Conditionally in CMake\nDESCRIPTION: Checks if the `USE_UMASH` option is enabled. If true, it first verifies that UMASH is actually supported on the platform (`UMASH_SUPPORTED` is true), issuing a fatal error otherwise. If supported and enabled, it adds the `TS_USE_UMASH` preprocessor definition to the build using `add_compile_definitions`, allowing C code to conditionally compile UMASH-related features.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/CMakeLists.txt#_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\nif(USE_UMASH)\n  if(NOT UMASH_SUPPORTED)\n    message(\n      FATAL_ERROR\n        \"UMASH use is requested, but it is not supported in the current configuration\"\n    )\n  endif()\n  add_compile_definitions(TS_USE_UMASH)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Job State Machine Diagram in DITAA Format\nDESCRIPTION: A diagram illustrating the state machine for background worker jobs in TimescaleDB. It shows the transitions between SCHEDULED, STARTING, TERMINATING, and DISABLED states.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/bgw/README.md#_snippet_0\n\nLANGUAGE: ditaa\nCODE:\n```\n      +---------+         +--------+\n+---> |SCHEDULED+-------> |DISABLED|\n|     +----+----+         +--------+\n|          |\n|          |\n|          v\n|      +---+----+\n+<-----+STARTING|\n|      +---+----+\n|          |\n|          |\n|          v\n|      +---+-------+\n+<-----+TERMINATING|\n       +-----------+\n```\n\n----------------------------------------\n\nTITLE: Checking Platform Support for UMASH Hashing in CMake\nDESCRIPTION: Performs checks to determine if the UMASH hashing library is supported on the current platform, unless explicitly disabled via `USE_UMASH`. It checks for the PCLMUL instruction set (`-mpclmul` flag) using `check_c_compiler_flag` and adds the flag if available (avoiding this check when cross-compiling). It then uses `check_c_source_compiles` with specific required flags and a test C source snippet to verify compilation using necessary intrinsics (_mm_cvtsi64_si128 for x86_64, __ARM_FEATURE_CRYPTO for ARM), setting the `UMASH_SUPPORTED` variable accordingly.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\n# We use the UMASH library for hashing in vectorized grouping. If it was not\n# explicitly disabled already, detect if we can compile it on this platform.\nif((NOT DEFINED USE_UMASH) OR USE_UMASH)\n  # Check whether we can enable the pclmul instruction required for the UMASH\n  # hashing on amd64. Shouldn't be done if the user has manually specified the\n  # target architecture, no idea how to detect this, but at least we shouldn't\n  # do this when cross-compiling.\n  if(NOT CMAKE_CROSSCOMPILING)\n    check_c_compiler_flag(-mpclmul CC_PCLMUL)\n    if(CC_PCLMUL)\n      add_compile_options(-mpclmul)\n    endif()\n  endif()\n\n  # The C compiler flags that we add using add_compile_options() are not\n  # automatically used by check_c_source_compiles() because it works in a\n  # separate project, so we have to add them manually.\n  get_directory_property(DIR_COMPILE_OPTIONS_LIST COMPILE_OPTIONS)\n  list(JOIN DIR_COMPILE_OPTIONS_LIST \" \" DIR_COMPILE_OPTIONS)\n  set(CMAKE_REQUIRED_FLAGS\n      \"${CMAKE_REQUIRED_FLAGS} ${CMAKE_C_FLAGS} ${DIR_COMPILE_OPTIONS} -Werror=implicit-function-declaration\"\n  )\n\n  check_c_source_compiles(\n    \"\n#if defined(__PCLMUL__)\n#include <stdint.h>\n#include <immintrin.h>\n/*\n * For some reason, this doesn't compile on our i386 CI, but I also can't detect\n * it using the standard condition of defined(__x86_64__) && !defined(__ILP32__),\n * as described at https://wiki.debian.org/X32Port .\n */\nint main() { (void) _mm_cvtsi64_si128((uint64_t) 0); return 0; }\n#elif defined(__ARM_FEATURE_CRYPTO)\n/* OK */\nint main() { return 0; }\n#else\n#error Unsupported platform for UMASH\n#endif\n\"\n    UMASH_SUPPORTED)\n  unset(CMAKE_REQUIRED_FLAGS)\nelse()\n  set(UMASH_SUPPORTED OFF)\nendif()\n```\n\nLANGUAGE: c\nCODE:\n```\n#if defined(__PCLMUL__)\n#include <stdint.h>\n#include <immintrin.h>\n/*\n * For some reason, this doesn't compile on our i386 CI, but I also can't detect\n * it using the standard condition of defined(__x86_64__) && !defined(__ILP32__),\n * as described at https://wiki.debian.org/X32Port .\n */\nint main() { (void) _mm_cvtsi64_si128((uint64_t) 0); return 0; }\n#elif defined(__ARM_FEATURE_CRYPTO)\n/* OK */\nint main() { return 0; }\n#else\n#error Unsupported platform for UMASH\n#endif\n```\n\n----------------------------------------\n\nTITLE: Defining Build Options\nDESCRIPTION: Defines various build options, such as enabling Apache-specific code, requiring all tests to run, enabling OpenSSL, sending telemetry, using telemetry functionality, enabling PostgreSQL regress checks, enabling optimizer debug, enabling debug utilities, and enabling assertions.  These options allow users to customize the build process based on their requirements.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\noption(APACHE_ONLY \"only compile apache code\" off)\n# This requires all tests to run. This defaults to OFF but can be enabled to\n# ensure that no tests are skipped because of missing tools.\noption(REQUIRE_ALL_TESTS \"Require all tests to run.\" OFF)\noption(USE_OPENSSL \"Enable use of OpenSSL if available\" ON)\noption(SEND_TELEMETRY_DEFAULT \"The default value for whether to send telemetry\"\n       ON)\noption(\n  USE_TELEMETRY\n  \"Include telemetry functionality in the build. Disabling will exclude all telemetry code from the build.\"\n  ON)\n\noption(REGRESS_CHECKS \"PostgreSQL regress checks through installcheck\" ON)\noption(\n  ENABLE_OPTIMIZER_DEBUG\n  \"Enable OPTIMIZER_DEBUG when building. Requires Postgres server to be built with OPTIMIZER_DEBUG.\"\n  OFF)\noption(ENABLE_DEBUG_UTILS \"Enable debug utilities for the extension.\" ON)\n\n# Option to enable assertions. Note that if we include headers from a PostgreSQL\n# build that has assertions enabled, we might inherit that setting without\n# explicitly enabling assertions via the ASSERTIONS option defined here. Thus,\n# this option is mostly useful to enable assertions when the PostgreSQL we\n# compile against has it disabled.\noption(ASSERTIONS \"Compile with assertion checks (default OFF)\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Adding C Source File to CMake Target (CMake)\nDESCRIPTION: This CMake code defines a variable `SOURCES` holding the path to `frozen_chunk_dml.c` relative to the current source directory. It then uses the `target_sources` command to add this C source file to the private sources of the CMake target specified by the variable `${TSL_LIBRARY_NAME}`. This requires `${TSL_LIBRARY_NAME}` to be defined elsewhere in the CMake build configuration.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/nodes/frozen_chunk_dml/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Add all *.c to sources in upperlevel directory\nset(SOURCES ${CMAKE_CURRENT_SOURCE_DIR}/frozen_chunk_dml.c)\ntarget_sources(${TSL_LIBRARY_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Adding C Source Files to Project - CMake\nDESCRIPTION: This snippet defines a list of C source files using the `set()` command and then associates these files with the project using `target_sources()`.  The `SOURCES` variable stores the file paths and the `CMAKE_CURRENT_SOURCE_DIR` variable is used to specify the directory. The `target_sources()` command adds the source files to the `PROJECT_NAME` target, with the `PRIVATE` option indicating that these sources are only required internally by the target.  No external dependencies are required.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/telemetry/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Add all *.c to sources in upperlevel directory\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/functions.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/replication.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/stats.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/telemetry_metadata.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/telemetry.c)\ntarget_sources(${PROJECT_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.15. This ensures compatibility with the project's build scripts and features. It is a prerequisite for using more modern CMake features.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15)\n```\n\n----------------------------------------\n\nTITLE: Defining and Adding Source Files in CMake for TimescaleDB\nDESCRIPTION: This CMake snippet defines a set of C source files to be included in the TimescaleDB build and adds them to the project target. It includes core database components like catalog management, compression settings, continuous aggregation, and metadata handling.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/ts_catalog/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/array_utils.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/catalog.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/chunk_column_stats.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/compression_chunk_size.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/compression_settings.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/continuous_agg.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/continuous_aggs_watermark.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/metadata.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/tablespace.c)\ntarget_sources(${PROJECT_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Concatenating and Generating SQL Extension Files in TimescaleDB with CMake\nDESCRIPTION: This snippet provides two CMake functions: 'cat_files' concatenates multiple input SQL source files into a single output file using an external script 'cat.cmake'. 'cat_create_files' does the same but strips out 'OR REPLACE' statements to avoid privilege escalation risks in CREATE scripts. Both functions handle differences between Windows and other platforms for correct command-line argument formatting and attach generation of output files as a build step, specifying dependencies and working directory. These functions automate building consolidated SQL scripts for extension installation and updates.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/sql/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(cat_files SRC_FILE_LIST OUTPUT_FILE)\n  if(WIN32)\n    set(\"SRC_ARG\" \"-DSRC_FILE_LIST=${SRC_FILE_LIST}\")\n  else()\n    set(\"SRC_ARG\" \"'-DSRC_FILE_LIST=${SRC_FILE_LIST}'\")\n  endif()\n  add_custom_command(\n    OUTPUT ${OUTPUT_FILE}\n    DEPENDS ${SRC_FILE_LIST}\n    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n    COMMAND ${CMAKE_COMMAND} \"${SRC_ARG}\" \"-DOUTPUT_FILE=${OUTPUT_FILE}\" -P\n            cat.cmake\n    COMMENT \"Generating ${OUTPUT_FILE}\")\nendfunction()\n\nfunction(cat_create_files SRC_FILE_LIST OUTPUT_FILE)\n  if(WIN32)\n    set(\"SRC_ARG\" \"-DSRC_FILE_LIST=${SRC_FILE_LIST}\")\n  else()\n    set(\"SRC_ARG\" \"'-DSRC_FILE_LIST=${SRC_FILE_LIST}'\")\n  endif()\n  if(WIN32)\n    add_custom_command(\n      OUTPUT ${OUTPUT_FILE}\n      DEPENDS ${SRC_FILE_LIST}\n      WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n      COMMAND ${CMAKE_COMMAND} \"${SRC_ARG}\" \"-DOUTPUT_FILE=${OUTPUT_FILE}\"\n              \"-DSTRIP_REPLACE=ON\" -P cat.cmake\n      COMMENT \"Generating ${OUTPUT_FILE}\")\n  else()\n    add_custom_command(\n      OUTPUT ${OUTPUT_FILE}\n      DEPENDS ${SRC_FILE_LIST}\n      WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n      COMMAND ${CMAKE_COMMAND} \"'-DSRC_FILE_LIST=${SRC_FILE_LIST}'\"\n              \"-DOUTPUT_FILE=${OUTPUT_FILE}\" \"-DSTRIP_REPLACE=ON\" -P cat.cmake\n      COMMENT \"Generating ${OUTPUT_FILE}\")\n  endif()\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Defining and Adding C Source Files in CMake\nDESCRIPTION: This CMake code defines a variable `SOURCES` containing a list of C source files located in the current source directory. These files implement functionality related to parsing and handling SQL `WITH` clauses for table creation, alteration, and materialized view creation. The `target_sources` command subsequently adds these files as private sources to the CMake target identified by the `${PROJECT_NAME}` variable, ensuring they are compiled as part of the project.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/with_clause/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/alter_table_with_clause.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/create_table_with_clause.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/create_materialized_view_with_clause.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/with_clause_parser.c)\n\ntarget_sources(${PROJECT_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Appending Isolation Checks to Lists\nDESCRIPTION: Appends `isolationchecklocal-t` and `isolationcheck-t` to the lists that accumulate the test targets.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/CMakeLists.txt#_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND _local_install_checks isolationchecklocal-t)\nlist(APPEND _install_checks isolationcheck-t)\n```\n\n----------------------------------------\n\nTITLE: Defining and Linking Source Files in CMake for TimescaleDB\nDESCRIPTION: This snippet demonstrates how to define a list of C source files in a CMake project using the set command and subsequently link them privately to the main project target using target_sources. The SOURCES variable holds relative paths to C files essential for TimescaleDB functionality, including modules like allpaths.c, ht_hypertable_modify.c, and planner.c. This setup ensures proper inclusion of source files during the build process.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/import/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/allpaths.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/ht_hypertable_modify.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/list.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/planner.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/ts_explain.c)\n\ntarget_sources(${PROJECT_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Configuring Version File\nDESCRIPTION: Copies the `version.config` file to the build directory and reads its content to extract version-related information like version number, and project version. This information is used throughout the build process, particularly for setting the project version and determining update paths.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nconfigure_file(\"version.config\" \"version.config\" COPYONLY)\nfile(READ version.config VERSION_CONFIG)\n```\n\n----------------------------------------\n\nTITLE: Including Subdirectory in CMake\nDESCRIPTION: This CMake command adds the subdirectory 'specs' to the build. It allows CMake to find and process the CMakeLists.txt file within the 'specs' directory, effectively integrating its build instructions into the main project. This is a standard way to structure CMake projects with multiple components or modules.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/isolation/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(specs)\n```\n\n----------------------------------------\n\nTITLE: Inserting Data into a Hypertable (SQL)\nDESCRIPTION: This SQL statement inserts multiple rows into the 'conditions' hypertable. Each row records a temperature and humidity reading for a specific location at the current timestamp (NOW()). TimescaleDB processes this insert like standard PostgreSQL, but partitions the data automatically in background. Columns must match the hypertableâ€™s schema.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/README.md#_snippet_5\n\nLANGUAGE: SQL\nCODE:\n```\nINSERT INTO conditions\n  VALUES\n    (NOW(), 'office',   70.0, 50.0),\n    (NOW(), 'basement', 66.5, 60.0),\n    (NOW(), 'garage',   77.0, 65.2);\n```\n\n----------------------------------------\n\nTITLE: Defining Source Files in CMake for TimescaleDB\nDESCRIPTION: This snippet sets up a list of C source files for the TimescaleDB project, including job handling, statistics, scheduler, and timer modules, and assigns them as private sources to the target project. It ensures these source files are compiled and linked appropriately during the build process.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/bgw/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/job.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/job_stat.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/job_stat_history.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/launcher_interface.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/scheduler.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/timer.c)\ntarget_sources(${PROJECT_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Extracting Version Information\nDESCRIPTION: Extracts version information from the `version.config` file using regular expressions. The `VERSION` variable stores the main version number. It also defines `VERSION_MOD`, `PROJECT_VERSION_MOD`, `UPDATE_FROM_VERSION`, `DOWNGRADE_TO_VERSION`, and `PREVIOUS_VERSION`. The matching ensures that the version information is properly parsed from the config file.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif(VERSION_CONFIG\n   MATCHES\n   \"(^|.*[^a-z])version[\t ]*=[\t ]*([0-9]+\\.[0-9]+\\.*[0-9]*)(-([a-z]+[0-9]*|dev))?.*\"\n)\n  set(VERSION ${CMAKE_MATCH_2})\n  set(VERSION_MOD ${CMAKE_MATCH_4}) # This is used in config.h\n  if(CMAKE_MATCH_3)\n    set(PROJECT_VERSION_MOD ${CMAKE_MATCH_2}${CMAKE_MATCH_3})\n  else()\n    set(PROJECT_VERSION_MOD ${CMAKE_MATCH_2})\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Include SQL Subdirectory with CMake\nDESCRIPTION: This CMake command adds the 'sql' subdirectory to the current build. It allows CMake to process the CMakeLists.txt file located in the 'sql' directory and include its contents into the build process.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/shared/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(sql)\n```\n\n----------------------------------------\n\nTITLE: Creating and Installing Extension Control File in CMake\nDESCRIPTION: Configures and installs the PostgreSQL extension control file for TimescaleDB. The control file is necessary for PostgreSQL to recognize TimescaleDB as a valid extension and contains metadata about the extension.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_23\n\nLANGUAGE: CMake\nCODE:\n```\nset(EXT_CONTROL_FILE ${PROJECT_NAME}.control)\nconfigure_file(${EXT_CONTROL_FILE}.in ${EXT_CONTROL_FILE})\n\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/${EXT_CONTROL_FILE}\n        DESTINATION \"${PG_SHAREDIR}/extension\")\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories in CMake\nDESCRIPTION: This snippet adds the `test` and `src` subdirectories to the CMake build process. The `add_subdirectory` command incorporates these directories, allowing CMake to process their respective `CMakeLists.txt` files, build targets, and dependencies. This is necessary to include the test suites and source code associated with the project.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Add the subdirectories\nadd_subdirectory(test)\nadd_subdirectory(src)\n```\n\n----------------------------------------\n\nTITLE: Adding Local Regression Test Target\nDESCRIPTION: Adds a custom target named `regresschecklocal-t` that executes the `pg_regress.sh` script to run PostgreSQL regression tests against a local PostgreSQL instance. Similar to `regresscheck-t`, it sets up environment variables but uses the local PostgreSQL port and instance settings.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(\n    regresschecklocal-t\n    COMMAND\n      ${CMAKE_COMMAND} -E env ${PG_REGRESS_ENV}\n      EXE_DIR=${CMAKE_CURRENT_SOURCE_DIR} TEST_PGPORT=${TEST_PGPORT_LOCAL}\n      TEST_SCHEDULE=${TEST_SCHEDULE} ${PRIMARY_TEST_DIR}/pg_regress.sh\n      ${PG_REGRESS_OPTS_BASE} ${PG_REGRESS_OPTS_EXTRA} ${PG_REGRESS_OPTS_INOUT}\n      ${PG_REGRESS_OPTS_LOCAL_INSTANCE}\n    USES_TERMINAL)\n```\n\n----------------------------------------\n\nTITLE: Defining Source Files\nDESCRIPTION: This snippet defines a list of source files that will be compiled as part of the TimescaleDB project. It initializes a variable `SOURCES` and sets its value to a list of `.c` files. These files are used in the build process to create the TimescaleDB library.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    uuid.c\n    agg_bookend.c\n    func_cache.c\n    cache.c\n    cache_invalidate.c\n    chunk.c\n    chunk_adaptive.c\n    chunk_constraint.c\n    chunk_index.c\n    chunk_scan.c\n    constraint.c\n    cross_module_fn.c\n    copy.c\n    dimension.c\n    dimension_slice.c\n    dimension_vector.c\n    estimate.c\n    event_trigger.c\n    extension.c\n    extension_constants.c\n    expression_utils.c\n    foreign_key.c\n    gapfill.c\n    guc.c\n    histogram.c\n    hypercube.c\n    hypertable.c\n    hypertable_cache.c\n    hypertable_restrict_info.c\n    indexing.c\n    init.c\n    jsonb_utils.c\n    license_guc.c\n    osm_callbacks.c\n    partitioning.c\n    process_utility.c\n    scanner.c\n    scan_iterator.c\n    sort_transform.c\n    subspace_store.c\n    timezones.c\n    time_bucket.c\n    time_utils.c\n    custom_type_cache.c\n    trigger.c\n    utils.c\n    version.c\n    tss_callbacks.c)\n```\n\n----------------------------------------\n\nTITLE: Generating Git Commit Information\nDESCRIPTION: This section sets up a custom target `gitcheck` to generate `gitcommit.h`, containing git revision details. The generation process uses the git commit details from git to be included during build. It uses a temporary file `tmp_gitcommit.h` for writing, and copies to the actual `gitcommit.h` when it changes to avoid unnecessary recompilations.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(GITREV_TMP ${CMAKE_CURRENT_BINARY_DIR}/tmp_gitcommit.h)\nset(GITREV_FILE ${CMAKE_CURRENT_BINARY_DIR}/gitcommit.h)\n\n# The commands for generating gitcommit.h need to be executed on every make run\n# and not on cmake run to detect branch switches, commit changes or local\n# modifications. That's why we add the commands in a custom target and run them\n# on every make run. We do the generation part in a temporary file and only\n# overwrite the actual file when the content is different to not trigger\n# unnecessary recompilations.\n\nadd_custom_target(\n  gitcheck\n  COMMAND\n    ${CMAKE_COMMAND} \"-DGIT_FOUND=${GIT_FOUND}\"\n    \"-DSOURCE_DIR=${CMAKE_CURRENT_SOURCE_DIR}\"\n    \"-DGIT_EXECUTABLE=${GIT_EXECUTABLE}\"\n    \"-DINPUT_FILE=${CMAKE_CURRENT_SOURCE_DIR}/gitcommit.h.in\"\n    \"-DOUTPUT_FILE=${GITREV_TMP}\" -P ${CMAKE_CURRENT_SOURCE_DIR}/gitcommit.cmake\n  COMMAND ${CMAKE_COMMAND} -E copy_if_different ${GITREV_TMP} ${GITREV_FILE})\n```\n\n----------------------------------------\n\nTITLE: Subspace Store Cache Tree Structure\nDESCRIPTION: This ASCII diagram depicts the internal tree structure of a `SubspaceStore`. The tree organizes cached data hierarchically based on hypertable dimensions. The root leads to an internal node for the time dimension, which branches into nodes for subsequent dimensions (like hash partitions), eventually reaching leaf nodes that store the actual cached objects (e.g., `ChunkInsertState`). The structure facilitates efficient lookup and time-based eviction.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/subspace_store.README.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nSubspaceStore\n    |\n    V\nSubspaceStoreInternalNode (time)\n       | (.vector)\n       V\n  |  o  | ... | ... | ... |\n     |\n     V\n  DimensionSlice (00:00 - 01:00)\n     |\n     V\n    SubspaceStoreInternalNode (dim 1)\n     |\n     V\n     .\n     .\n     .\n     |\n     V\n    ChunkInsertState (or other leaf object)\n```\n\n----------------------------------------\n\nTITLE: Finding Genhtml and Generating HTML Report in CMake\nDESCRIPTION: This block first uses `find_program` to locate the `genhtml` executable (part of the lcov suite). If found, it defines a custom command to generate an HTML code coverage report using `genhtml`. The command takes the final combined tracefile (`${OUTPUT_FILE}`) as input and generates the report in the directory specified by `REPORT_DIR`. It enables branch coverage reporting and sets the report title. A status message informs the user how to generate the report.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/codecov/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nfind_program(GENHTML genhtml)\n\nif(GENHTML)\n  message(\n    STATUS\n      \"Generate a code coverage report using the 'coverage' target after tests have run.\"\n  )\n\n  add_custom_command(\n    OUTPUT ${REPORT_DIR}/index.html\n    COMMENT\n      \"Generating HTML code coverage report in ${CMAKE_CURRENT_BINARY_DIR}/${REPORT_DIR}\"\n    COMMAND\n      ${GENHTML} --prefix ${CMAKE_SOURCE_DIR} --branch-coverage\n      --ignore-errors source --legend --title \"TimescaleDB\" --output-directory\n      ${REPORT_DIR} ${OUTPUT_FILE}\n    DEPENDS ${OUTPUT_FILE})\n  # ... rest of if(GENHTML) block ...\nelse()\n  message(STATUS \"Install genhtml to generate code coverage reports\")\nendif(GENHTML)\n```\n\n----------------------------------------\n\nTITLE: Adding C Source Files to CMake Target - CMake\nDESCRIPTION: This CMake snippet defines a variable `SOURCES` containing a list of C source file paths relative to the current directory. It then uses the `target_sources` command to add these files to the private sources of the CMake target named by the `${TSL_LIBRARY_NAME}` variable. This is a standard way to specify the compilation units for a library or executable in CMake.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/nodes/decompress_chunk/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Add all *.c to sources in upperlevel directory\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/batch_array.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/batch_queue_heap.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/batch_queue_fifo.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/compressed_batch.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/decompress_chunk.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/detoaster.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/exec.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/planner.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/pred_text.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/pred_vector_array.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/qual_pushdown.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/vector_predicates.c)\ntarget_sources(${TSL_LIBRARY_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Conditional Downgrade Script Generation Using Git in TimescaleDB with CMake\nDESCRIPTION: This snippet contains logic for generating downgrade scripts when building TimescaleDB using CMake. It first checks flags and Git availability before calling a custom 'generate_downgrade_script' macro to produce downgrade SQL scripts for the current and old versions. The function accepts parameters such as SOURCE_VERSION, TARGET_VERSION, INPUT_DIRECTORY, and FILES to specify the versions and SQL files for script generation. This mechanism ensures downgrade scripts are generated only if enabled and Git is available, preventing skipped versions during downgrades.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/sql/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT GENERATE_DOWNGRADE_SCRIPT)\n  message(\n    STATUS \"Not generating downgrade script: downgrade generation disabled.\")\nelseif(NOT GIT_FOUND)\n  message(STATUS \"Not generating downgrade script: Git not available.\")\nelse()\n  generate_downgrade_script(\n    SOURCE_VERSION\n    ${PROJECT_VERSION_MOD}\n    TARGET_VERSION\n    ${PREVIOUS_VERSION}\n    INPUT_DIRECTORY\n    ${CMAKE_CURRENT_SOURCE_DIR}/updates\n    FILES\n    ${CURRENT_REV_FILE})\n  if(GENERATE_OLD_DOWNGRADE_SCRIPTS)\n    foreach(_downgrade_file ${OLD_REV_FILES})\n      if(${_downgrade_file} MATCHES\n         \"([0-9]+\\\\.[0-9]+\\\\.*[0-9]*)--([0-9]+\\\\.[0-9]+\\\\.*[0-9]*).sql\")\n        set(_source_version ${CMAKE_MATCH_1})\n        set(_target_version ${CMAKE_MATCH_2})\n        generate_downgrade_script(\n          SOURCE_VERSION\n          ${_source_version}\n          TARGET_VERSION\n          ${_target_version}\n          INPUT_DIRECTORY\n          ${CMAKE_CURRENT_SOURCE_DIR}/updates\n          FILES\n          ${_downgrade_file})\n      else()\n        message(FATAL_ERROR \"${_downgrade_file} is not a downgrade file\")\n      endif()\n    endforeach()\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Finding pg_config Program in CMake\nDESCRIPTION: Locates the pg_config utility which is essential for getting PostgreSQL configuration information. The function looks for the binary in the previously found PostgreSQL path, checks if it exists, and reports a fatal error if it cannot be found.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_18\n\nLANGUAGE: CMake\nCODE:\n```\nfind_program(\n  PG_CONFIG pg_config\n  HINTS ${PG_PATH}\n  PATH_SUFFIXES bin\n  DOC \"The path to the pg_config of the PostgreSQL version to compile against\")\n\nif(NOT PG_CONFIG)\n  message(FATAL_ERROR \"Unable to find 'pg_config'\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Finding PostgreSQL Binary Paths on Windows and Unix Systems in CMake\nDESCRIPTION: Sets up platform-specific search paths to locate PostgreSQL binaries. On Windows, it looks in standard installation directories with version-specific bin subdirectories, while on Unix it searches in home directory, system directories, and version-specific paths.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_17\n\nLANGUAGE: CMake\nCODE:\n```\nif(WIN32)\n  find_path(\n    PG_PATH postgres.exe\n    PATHS \"C:/PostgreSQL\" \"C:/Program Files/PostgreSQL\"\n    PATH_SUFFIXES bin 15/bin 16/bin\n    DOC \"The path to a PostgreSQL installation\")\nelseif(UNIX)\n  find_path(\n    PG_PATH postgres\n    PATHS $ENV{HOME} /opt/local/pgsql /usr/local/pgsql /usr/lib/postgresql\n    PATH_SUFFIXES bin 15/bin 16/bin\n    DOC \"The path to a PostgreSQL installation\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Source Files and Linking to TimescaleDB Library with CMake\nDESCRIPTION: This CMake snippet defines a list of source files for the TimescaleDB project and links them to the library target.  It uses `CMAKE_CURRENT_SOURCE_DIR` to locate the source files.  `TSL_LIBRARY_NAME` is assumed to be defined elsewhere.  The `PRIVATE` keyword ensures that the specified sources are only visible within the library's scope.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/nodes/skip_scan/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES ${CMAKE_CURRENT_SOURCE_DIR}/planner.c\n            ${CMAKE_CURRENT_SOURCE_DIR}/exec.c)\ntarget_sources(${TSL_LIBRARY_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Creating Gcov Symlink for Lcov Compatibility in CMake\nDESCRIPTION: This custom command creates a symbolic link named 'gcov' within the CMake build directory, pointing to the actual gcov executable (which might be 'llvm-cov-X'). This is necessary because lcov expects to call its gcov tool simply as 'gcov', and llvm-cov needs to be invoked with 'gcov' as its first argument (or have its executable name be 'gcov') to operate in gcov compatibility mode.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/codecov/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# We can't directly use llvm-cov as --gcov-tool, because it has to be called\n# like \"llvm-cov gcov <gcov args>\" for that. Thankfully, if its $0 is gcov, it\n# will understand that we want it to operate like gcov. Just create a symlink.\nadd_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/gcov\n                   COMMAND ln -s ${GCOV} ${CMAKE_CURRENT_BINARY_DIR}/gcov)\n```\n\n----------------------------------------\n\nTITLE: Adding Source Files to CMake Targets (CMake)\nDESCRIPTION: This CMake script defines a SOURCES variable containing the path to the 'columnar_scan.c' file within the current directory, and then adds it to the TSL_LIBRARY_NAME build target using target_sources. Dependencies include a CMake build environment and defined variables such as TSL_LIBRARY_NAME. The main parameter is SOURCES, which lists source files to be compiled. Expected input is a valid path to a C file, and no direct output is produced other than updated build targets. This approach ensures modular addition of sources and supports easier future extension.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/nodes/columnar_scan/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES ${CMAKE_CURRENT_SOURCE_DIR}/columnar_scan.c)\n\ntarget_sources(${TSL_LIBRARY_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Adding Isolation Test Target\nDESCRIPTION: Adds a custom target `isolationcheck-t` for running PostgreSQL isolation tests using `pg_regress.sh` against a temporary PostgreSQL instance.  It utilizes environment variables and options tailored for isolation testing.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(\n    isolationcheck-t\n    COMMAND\n      ${CMAKE_COMMAND} -E env ${PG_ISOLATION_REGRESS_ENV}\n      EXE_DIR=${CMAKE_CURRENT_SOURCE_DIR}\n      SPECS_DIR=${CMAKE_CURRENT_BINARY_DIR}/isolation/specs\n      TEST_PGPORT=${TEST_PGPORT_TEMP_INSTANCE} ${PRIMARY_TEST_DIR}/pg_regress.sh\n      ${PG_REGRESS_OPTS_BASE} ${PG_ISOLATION_REGRESS_OPTS_EXTRA}\n      ${PG_ISOLATION_REGRESS_OPTS_INOUT} ${PG_REGRESS_OPTS_TEMP_INSTANCE}\n      --temp-config=${TEST_OUTPUT_DIR}/postgresql.conf\n    USES_TERMINAL)\n```\n\n----------------------------------------\n\nTITLE: Adding C Source to CMake Target\nDESCRIPTION: This CMake code snippet first defines a variable `SOURCES` containing the path to the C source file `constraint_aware_append.c` relative to the current source directory. It then adds this source file to the list of private sources for the CMake target defined by the `${PROJECT_NAME}` variable. This ensures the C file is compiled and linked as part of the target build process.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/nodes/constraint_aware_append/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(SOURCES ${CMAKE_CURRENT_SOURCE_DIR}/constraint_aware_append.c)\ntarget_sources(${PROJECT_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Adding Regression Test Target\nDESCRIPTION: Adds a custom target named `regresscheck-t` that executes the `pg_regress.sh` script to run PostgreSQL regression tests against a temporary PostgreSQL instance. It sets up the environment variables required by the test script and passes various options like test schedule, port, and configuration file.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(\n    regresscheck-t\n    COMMAND\n      ${CMAKE_COMMAND} -E env ${PG_REGRESS_ENV}\n      EXE_DIR=${CMAKE_CURRENT_SOURCE_DIR} TEST_SCHEDULE=${TEST_SCHEDULE}\n      TEST_PGPORT=${TEST_PGPORT_TEMP_INSTANCE} ${PRIMARY_TEST_DIR}/pg_regress.sh\n      ${PG_REGRESS_OPTS_BASE} ${PG_REGRESS_OPTS_EXTRA} ${PG_REGRESS_OPTS_INOUT}\n      ${PG_REGRESS_OPTS_TEMP_INSTANCE}\n      --temp-config=${TEST_OUTPUT_DIR}/postgresql.conf\n    USES_TERMINAL)\n```\n\n----------------------------------------\n\nTITLE: Adding Shared Regression Test Target\nDESCRIPTION: Adds a custom target named `regresscheck-shared` that executes the `pg_regress.sh` script to run PostgreSQL regression tests for shared modules against a temporary PostgreSQL instance. It configures specific options for shared module tests.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(\n    regresscheck-shared\n    COMMAND\n      ${CMAKE_COMMAND} -E env ${PG_REGRESS_ENV}\n      EXE_DIR=${CMAKE_CURRENT_SOURCE_DIR}/shared\n      TEST_SCHEDULE=${TEST_SCHEDULE_SHARED}\n      TEST_PGPORT=${TEST_PGPORT_TEMP_INSTANCE} ${PRIMARY_TEST_DIR}/pg_regress.sh\n      ${PG_REGRESS_OPTS_BASE} ${PG_REGRESS_SHARED_OPTS_EXTRA}\n      ${PG_REGRESS_SHARED_OPTS_INOUT} ${PG_REGRESS_OPTS_TEMP_INSTANCE}\n      --temp-config=${TEST_OUTPUT_DIR}/postgresql.conf\n    USES_TERMINAL)\n```\n\n----------------------------------------\n\nTITLE: Adding Test Library as Object in CMake\nDESCRIPTION: This snippet creates an object library named `TSL_TESTS_LIB_NAME` using the `add_library()` command. The library is of type `OBJECT`, meaning it's a collection of object files that can be linked into other targets. The library is created using the source files defined previously in the `SOURCES` variable. This object library will be linked into the loadable extension module.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/src/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(${TSL_TESTS_LIB_NAME} OBJECT ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Filtering PostgreSQL Compiler Flags in CMake\nDESCRIPTION: Processes the compiler flags obtained from PostgreSQL to filter out warning flags. This ensures that PostgreSQL's warning settings don't conflict with TimescaleDB's own warning settings, while preserving other important compiler options.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_21\n\nLANGUAGE: CMake\nCODE:\n```\nseparate_arguments(PG_CFLAGS)\nforeach(option ${PG_CFLAGS})\n  if(NOT ${option} MATCHES ^-W)\n    set(filtered \"${filtered} ${option}\")\n  endif()\nendforeach()\nset(PG_CFLAGS \"${filtered} ${PG_CFLAGS_SL}\")\n```\n\n----------------------------------------\n\nTITLE: Defining Test Target for Regression Checks (Local Instance) with pg_regress (CMake)\nDESCRIPTION: Creates the 'regresschecklocal' custom CMake target to run regression tests using a local PostgreSQL instance with 'pg_regress'. Passes the TEST_PGPORT_LOCAL environment variable to target a local server, and invokes 'pg_regress.sh' with necessary flags. This provides test coverage against user-supplied or pre-existing databases. The target is appended to _local_install_checks for aggregation.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(\n  regresschecklocal\n  COMMAND\n    ${CMAKE_COMMAND} -E env ${PG_REGRESS_ENV} TEST_PGPORT=${TEST_PGPORT_LOCAL}\n    ${CMAKE_CURRENT_SOURCE_DIR}/pg_regress.sh ${PG_REGRESS_OPTS_BASE}\n    ${PG_REGRESS_OPTS_EXTRA} ${PG_REGRESS_OPTS_INOUT}\n    ${PG_REGRESS_OPTS_LOCAL_INSTANCE}\n  USES_TERMINAL)\n\nlist(APPEND _local_install_checks regresschecklocal)\n```\n\n----------------------------------------\n\nTITLE: Defining Test Target for Isolation Checks (Local Instance) with pg_isolation_regress (CMake)\nDESCRIPTION: Defines the 'isolationchecklocal' custom target to execute isolation tests against a locally running PostgreSQL database. Passes specific environment variables to target the isolated test suite using a local port configuration. The target is appended to _local_install_checks for use in local validation pipelines.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(\n  isolationchecklocal\n  COMMAND\n    ${CMAKE_COMMAND} -E env ${PG_ISOLATION_REGRESS_ENV}\n    SPECS_DIR=${CMAKE_CURRENT_SOURCE_DIR}/isolation/specs\n    TEST_PGPORT=${TEST_PGPORT_LOCAL} ${CMAKE_CURRENT_SOURCE_DIR}/pg_regress.sh\n    ${PG_REGRESS_OPTS_BASE} ${PG_ISOLATION_REGRESS_OPTS_EXTRA}\n    ${PG_ISOLATION_REGRESS_OPTS_INOUT} ${PG_REGRESS_OPTS_LOCAL_INSTANCE}\n  USES_TERMINAL)\n\nlist(APPEND _local_install_checks isolationchecklocal)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Subspaces in a Hypertable\nDESCRIPTION: This ASCII diagram illustrates how a 2-dimensional hypertable (with time intervals horizontally and integer partitions vertically) is divided into conceptual subspaces. Each cell represents a distinct subspace within the hypertable's multidimensional space.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/subspace_store.README.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n     00:00   01:00   02:00   03:00\n---|-------|-------|-------|-------|--- - -\n 1 |       |       |       |       |\n---|-------|-------|-------|-------|--- - -\n 2 |       |       |       |       |\n---|-------|-------|-------|-------|--- - -\n 3 |       |       |       |       |\n---|-------|-------|-------|-------|--- - -\n```\n\n----------------------------------------\n\nTITLE: Adding C Source Files to Project Target - CMake\nDESCRIPTION: This CMake snippet defines a variable `SOURCES` containing a list of C source files located in the current source directory. It then uses the `target_sources` command to add these files to the main project target (`${PROJECT_NAME}`), marking them as `PRIVATE` sources.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/bgw_policy/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES ${CMAKE_CURRENT_SOURCE_DIR}/policy.c\n            ${CMAKE_CURRENT_SOURCE_DIR}/chunk_stats.c)\n```\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories\nDESCRIPTION: Adds the `shared`, `sql`, `isolation`, and `t` subdirectories to the build process. These subdirectories likely contain source code or scripts relevant to specific aspects of the TimescaleDB project.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/CMakeLists.txt#_snippet_13\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(shared)\nadd_subdirectory(sql)\nadd_subdirectory(isolation)\nadd_subdirectory(t)\n```\n\n----------------------------------------\n\nTITLE: Setting and Using PostgreSQL Regress Directory in CMake\nDESCRIPTION: Defines the variable for PostgreSQL's regression test directory and sets up directories containing test inputs, outputs, and expected results. It conditionally appends directories based on their existence, copies relevant test data for the build environment, and prepares the directory for tablespace testing. This snippet depends on CMake variables such as PG_SOURCE_DIR and file commands like file(COPY) and file(MAKE_DIRECTORY).\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/pgtest/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(PG_REGRESS_DIR\n    ${PG_SOURCE_DIR}/src/test/regress\n    CACHE PATH \"Path to PostgreSQL's regress directory\")\n\n# input and output directory got removed in PG15\nset(PGTEST_DIRS ${PG_REGRESS_DIR}/data ${PG_REGRESS_DIR}/sql\n                ${PG_REGRESS_DIR}/expected)\nif(EXISTS ${PG_REGRESS_DIR}/input AND EXISTS ${PG_REGRESS_DIR}/output)\n  list(APPEND PGTEST_DIRS ${PG_REGRESS_DIR}/input ${PG_REGRESS_DIR}/output)\nendif()\n\n# Copy the input and output files from PostgreSQL's test suite. The test suite\n# generates some SQL scripts and output files from template source files and\n# require directories to be colocated\nfile(COPY ${PGTEST_DIRS} DESTINATION ${CMAKE_CURRENT_BINARY_DIR})\n\nfile(READ ${PG_REGRESS_DIR}/parallel_schedule PG_TEST_SCHEDULE)\n\n# create directory for tablespace test\nfile(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/testtablespace)\n```\n\n----------------------------------------\n\nTITLE: Configuring Source Files for TimescaleDB Extension in CMake\nDESCRIPTION: Defines the source file 'hypertable_modify.c' for the TimescaleDB project and associates it with the main target. It also includes subdirectories for modules dealing with chunk append operations, chunk dispatching, and constraint-aware append functionality, enabling a modular build system.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/nodes/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES ${CMAKE_CURRENT_SOURCE_DIR}/hypertable_modify.c)\\ntarget_sources(${PROJECT_NAME} PRIVATE ${SOURCES})\\nadd_subdirectory(chunk_append)\\nadd_subdirectory(chunk_dispatch)\\nadd_subdirectory(constraint_aware_append)\n```\n\n----------------------------------------\n\nTITLE: Sorting Test List and Managing Schedule File in CMake\nDESCRIPTION: Sorts the `TEST_FILES_SHARED` list alphabetically if it's not empty using `list(SORT ...)`. It then removes any existing test schedule file specified by the `TEST_SCHEDULE_SHARED` variable using `file(REMOVE ...)`, preparing for regeneration.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/shared/sql/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nif(TEST_FILES_SHARED)\n  list(SORT TEST_FILES_SHARED)\nendif()\nfile(REMOVE ${TEST_SCHEDULE_SHARED})\n```\n\n----------------------------------------\n\nTITLE: Adding Project Subdirectories in CMake\nDESCRIPTION: Includes various subdirectories containing parts of the TimescaleDB project into the build process using add_subdirectory. The 'scripts' directory is included only on UNIX systems. The 'tsl' (TimescaleDB License) directory is included unless APACHE_ONLY is set. The 'codecov' directory is included only if CODECOVERAGE is enabled. 'sql', 'test', and 'src' directories are always included.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_32\n\nLANGUAGE: CMake\nCODE:\n```\nif(UNIX)\n  add_subdirectory(scripts)\nendif(UNIX)\n\nadd_subdirectory(sql)\nadd_subdirectory(test)\nadd_subdirectory(src)\n\nif(NOT APACHE_ONLY)\n  add_subdirectory(tsl)\nendif()\n\n# This needs to be the last subdirectory so that other targets are already\n# defined\nif(CODECOVERAGE)\n  add_subdirectory(codecov)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Checking OpenSSL Support in PostgreSQL for TimescaleDB in CMake\nDESCRIPTION: Verifies that PostgreSQL was built with OpenSSL support if TimescaleDB is configured to use OpenSSL. This is important for compatibility as TimescaleDB needs PostgreSQL's OpenSSL integration for full functionality. The check aborts the build if there's a mismatch.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_28\n\nLANGUAGE: CMake\nCODE:\n```\ncheck_symbol_exists(USE_OPENSSL ${PG_INCLUDEDIR}/pg_config.h PG_USE_OPENSSL)\n\nif(USE_OPENSSL AND (NOT PG_USE_OPENSSL))\n  message(\n    FATAL_ERROR\n      \"PostgreSQL was built without OpenSSL support, which TimescaleDB needs for full compatibility. Please rebuild PostgreSQL using `--with-openssl` or if you want to continue without OpenSSL, re-run bootstrap with `-DUSE_OPENSSL=0`\"\n  )\nendif(USE_OPENSSL AND (NOT PG_USE_OPENSSL))\n```\n\n----------------------------------------\n\nTITLE: Defining Test Coverage Target and Dependencies in CMake\nDESCRIPTION: Creates a custom target `coverage_test` that depends on the generation of the test coverage file (`${OUTPUT_FILE}.test`). It then adds `coverage_test` as a dependency to the `installcheck-post-hook` target (assuming this hook runs after tests), ensuring the test coverage data is captured only after the `installcheck` process finishes.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/codecov/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\n# Make sure coverage_test runs after tests (installcheck) finish\nadd_custom_target(coverage_test DEPENDS ${OUTPUT_FILE}.test)\nadd_dependencies(installcheck-post-hook coverage_test)\n```\n\n----------------------------------------\n\nTITLE: Verifying Tool Presence and Setting Variables in CMake\nDESCRIPTION: This block checks if gcov and lcov were found. If either is missing, it prints a status message indicating the missing tool. If both are found, it prints status messages showing the paths and versions of the located tools using execute_process. It also defines CMake variables for the final coverage tracefile name (OUTPUT_FILE) and the HTML report directory (REPORT_DIR).\nSOURCE: https://github.com/timescale/timescaledb/blob/main/codecov/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT GCOV)\n  message(STATUS \"Install gcov to generate code coverage reports\")\nelseif(NOT LCOV)\n  message(STATUS \"Install lcov to generate code coverage reports\")\nelse()\n  message(STATUS \"Using lcov ${LCOV}:\")\n  execute_process(COMMAND ${LCOV} --version)\n  message(STATUS \"Using gcov ${GCOV}:\")\n  execute_process(COMMAND ${GCOV} --version)\n\n  # Final tracefile for code coverage\n  set(OUTPUT_FILE \"timescaledb-codecov.info\")\n\n  # Directory where to generate the HTML report\n  set(REPORT_DIR \"codecov-report\")\n\n  # ... rest of the else block ...\nendif()\n```\n\n----------------------------------------\n\nTITLE: Including CMake Modules\nDESCRIPTION: Includes essential CMake modules for various build functionalities like compiler checks, symbol existence checks, Git integration, script generation, and dependent options.  These modules enable the CMake build system to perform checks, generate necessary files, and manage dependencies.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(CheckCCompilerFlag)\ninclude(CheckSymbolExists)\ninclude(GitCommands)\ninclude(GenerateScripts)\ninclude(CMakeDependentOption)\n```\n\n----------------------------------------\n\nTITLE: Setting Source Files in CMake for TimescaleDB - CMake\nDESCRIPTION: This snippet uses CMake commands to list C source files and assign them to a CMake variable called SOURCES. The files encompass different functional modules like common utilities, create, insert, invalidate, materialize, options, planner, refresh, repair, and other related logic for the TimescaleDB extension. It then assigns these source files to a target library (represented by TSL_LIBRARY_NAME), ensuring that all specified modules are included in the build. Dependencies include the CMake build system, presence of the referenced C source files, and correct definition of the TSL_LIBRARY_NAME variable. Expected input is the file directory structure matching the source file list; output is proper inclusion of all modules in the library build. This configuration is restricted to the CMake environment and is intended for use with TimescaleDB development only.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/continuous_aggs/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/common.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/create.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/finalize.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/insert.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/invalidation_threshold.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/invalidation.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/materialize.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/options.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/planner.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/refresh.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/repair.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/utils.c)\ntarget_sources(${TSL_LIBRARY_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Initializing a Perl TAP Test Script for TimescaleDB - Perl\nDESCRIPTION: This snippet shows the required boilerplate for a Perl TAP test script, including strict coding standards, loading Timescale and PostgreSQL-specific test infrastructure, and specifying an explicit test plan. Replace the 'tests => 1' argument with the total number of tests in the script. Dependencies: Test::More, TimescaleNode, TestLib.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/perl/README.md#_snippet_1\n\nLANGUAGE: Perl\nCODE:\n```\nuse strict;\nuse warnings;\nuse TimescaleNode;\nuse TestLib;\n# Replace with the number of tests to execute:\nuse Test::More tests => 1;\n```\n\n----------------------------------------\n\nTITLE: Generating Final Combined Code Coverage File in CMake\nDESCRIPTION: Defines a custom command to generate the final, combined code coverage tracefile (`${OUTPUT_FILE}`). This command uses `lcov` with the `--add-tracefile` option to merge the baseline coverage data (`${OUTPUT_FILE}.base`) and the test coverage data (`${OUTPUT_FILE}.test`) into a single file. It depends on the test coverage file being available.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/codecov/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_command(\n  OUTPUT ${OUTPUT_FILE}\n  COMMENT \"Generating final code coverage file\"\n  COMMAND\n    ${LCOV} --rc lcov_branch_coverage=1 --add-tracefile ${OUTPUT_FILE}.base\n    --add-tracefile ${OUTPUT_FILE}.test --output-file ${OUTPUT_FILE}\n    --gcov-tool ${CMAKE_CURRENT_BINARY_DIR}/gcov\n  DEPENDS ${OUTPUT_FILE}.test coverage_test)\n```\n\n----------------------------------------\n\nTITLE: Configuring Source Files for TimescaleDB Build using CMake\nDESCRIPTION: This snippet initializes a list of source files, including various .c files related to functions, min/max templates, sum templates, and accumulation templates, then adds these sources to the build target specified by 'TSL_LIBRARY_NAME'. It enables modular compilation of TimescaleDB extension components.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/nodes/vector_agg/function/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/functions.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/minmax_templates.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/int24_sum_templates.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/sum_float_templates.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/float48_accum_templates.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/int24_avg_accum_templates.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/int128_accum_templates.c)\n```\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${TSL_LIBRARY_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Defining Initial Test File Lists in CMake\nDESCRIPTION: Sets CMake variables `TEST_FILES_SHARED`, `TEST_TEMPLATES_SHARED`, and `SOLO_TESTS` to define lists of SQL test files. `TEST_FILES_SHARED` contains common SQL test files, `TEST_TEMPLATES_SHARED` lists template files (ending in .sql.in) used for generating version-specific tests, and `SOLO_TESTS` lists tests intended to be run individually.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/shared/sql/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(TEST_FILES_SHARED\n    cagg_compression.sql\n    chunkwise_agg_gather_sort.sql\n    classify_relation.sql\n    compat.sql\n    compress_unique_index.sql\n    compression_dml.sql\n    compression_nulls_not_distinct.sql\n    constify_timestamptz_op_interval.sql\n    constraint_aware_append.sql\n    constraint_exclusion_prepared.sql\n    decompress_join.sql\n    decompress_placeholdervar.sql\n    decompress_tracking.sql\n    generated_columns.sql\n    memoize.sql\n    security_barrier.sql\n    space_constraint.sql\n    subtract_integer_from_now.sql)\n\nset(TEST_TEMPLATES_SHARED\n    gapfill.sql.in ordered_append.sql.in ordered_append_join.sql.in\n    transparent_decompress_chunk.sql.in)\n\nset(SOLO_TESTS merge_dml.sql)\n```\n\n----------------------------------------\n\nTITLE: Defining TSL Module Source Files in CMake\nDESCRIPTION: Sets the `SOURCES` CMake variable to a list of C source files that constitute the core TSL module. These files will be compiled together to create the TSL shared library.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(SOURCES\n    chunk_api.c\n    chunk.c\n    chunkwise_agg.c\n    init.c\n    partialize_finalize.c\n    planner.c\n    process_utility.c\n    reorder.c)\n```\n\n----------------------------------------\n\nTITLE: Adding C source files to CMake target in CMakeLists.txt\nDESCRIPTION: Defines a SOURCES variable containing paths to several C source files located in the current source directory and associates these source files as private to the main project target using target_sources. This snippet depends on the variables PROJECT_NAME and CMAKE_CURRENT_SOURCE_DIR being previously defined in the CMake context. It supports compiling specific .c files within the build system, enabling modular source management.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/nodes/chunk_append/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/chunk_append.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/exec.c ${CMAKE_CURRENT_SOURCE_DIR}/planner.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/transform.c)\ntarget_sources(${PROJECT_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Appending TAP Check to List\nDESCRIPTION: Appends `provecheck-t` to `_install_checks` to include the TAP tests as part of the overall test suite.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND _install_checks provecheck-t)\n```\n\n----------------------------------------\n\nTITLE: Configuring Loader Module Build and Installation - CMake\nDESCRIPTION: This snippet sets up the build instructions for the TimescaleDB loader using CMake. It defines source files, sets additional test sources for debug builds, and adds a library target for the loader module. The configuration uses conditional logic to include test code and symbol conflict definitions in debug mode. It also specifies output naming conventions and installation directory, relying on variables such as PROJECT_NAME and PG_PKGLIBDIR. No external dependencies are required beyond CMake and standard C compilation for the listed sources.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/loader/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    loader.c\n    bgw_message_queue.c\n    bgw_counter.c\n    bgw_launcher.c\n    bgw_interface.c\n    function_telemetry.c\n    lwlocks.c)\n\nset(TEST_SOURCES ${PROJECT_SOURCE_DIR}/test/src/symbol_conflict.c)\n\nadd_library(${PROJECT_NAME}-loader MODULE ${SOURCES})\n\nif(CMAKE_BUILD_TYPE MATCHES Debug)\n  # Include code for tests in Debug build\n  target_sources(${PROJECT_NAME}-loader PRIVATE ${TEST_SOURCES})\n  # This define generates extension-specific code for symbol conflict testing\n  target_compile_definitions(${PROJECT_NAME}-loader PUBLIC MODULE_NAME=loader)\nendif(CMAKE_BUILD_TYPE MATCHES Debug)\n\nset_target_properties(${PROJECT_NAME}-loader\n                      PROPERTIES OUTPUT_NAME ${PROJECT_NAME} PREFIX \"\")\n\ninstall(TARGETS ${PROJECT_NAME}-loader DESTINATION ${PG_PKGLIBDIR})\n```\n\n----------------------------------------\n\nTITLE: Installing the TSL Library in CMake\nDESCRIPTION: Specifies installation rules for the compiled TSL library target using the `install` command. The built shared library (`${TSL_LIBRARY_NAME}`) will be installed into the PostgreSQL package library directory (`${PG_PKGLIBDIR}`), making it available for PostgreSQL to load.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\ninstall(TARGETS ${TSL_LIBRARY_NAME} DESTINATION ${PG_PKGLIBDIR})\n```\n\n----------------------------------------\n\nTITLE: Setting Source Files with CMake\nDESCRIPTION: This snippet sets the source files for the test library.  It defines a variable `SOURCES` containing a list of C source files. These files are part of the test suite's implementation. No dependencies outside of the listed files themselves.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/src/net/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/test_conn.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/test_http.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/conn_mock.c)\n```\n\n----------------------------------------\n\nTITLE: Filtering and Modifying PostgreSQL Regression Test Schedules in CMake\nDESCRIPTION: Manages a list of PostgreSQL regression tests to ignore when running on TimescaleDB. Depending on the PostgreSQL major version, it either prepends ignore statements or removes test entries from the test schedule string. This snippet handles version-specific behavior differences between PostgreSQL versions before and after 16 and manipulates the PG_TEST_SCHEDULE variable accordingly.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/pgtest/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Tests to ignore\nset(PG_IGNORE_TESTS\n    amutils\n    database\n    event_trigger\n    jsonb_jsonpath\n    opr_sanity\n    sanity_check\n    type_sanity\n    create_am\n    # Ignoring because it spawns different number of workers in different\n    # versions.\n    select_parallel\n    psql)\n\n# Modify the test schedule to ignore some tests\nforeach(IGNORE_TEST ${PG_IGNORE_TESTS})\n  # ignored schedules was removed in PG16\n  # https://github.com/postgres/postgres/commit/bd8d453e9b5f8b632a400a9e796fc041aed76d82\n  if(${PG_VERSION_MAJOR} LESS \"16\")\n    string(CONCAT PG_TEST_SCHEDULE \"ignore: ${IGNORE_TEST}\\n\"\n                  ${PG_TEST_SCHEDULE})\n  else()\n    # remove the ignored test from the schedule\n    string(REPLACE \"test: ${IGNORE_TEST}\\n\" \"\" PG_TEST_SCHEDULE\n                   \"${PG_TEST_SCHEDULE}\")\n    string(REPLACE \" ${IGNORE_TEST} \" \" \" PG_TEST_SCHEDULE\n                   \"${PG_TEST_SCHEDULE}\")\n    string(REPLACE \" ${IGNORE_TEST}\\n\" \"\\n\" PG_TEST_SCHEDULE\n                   \"${PG_TEST_SCHEDULE}\")\n  endif()\nendforeach(IGNORE_TEST)\n\n# Write the final test schedule\nfile(WRITE ${CMAKE_CURRENT_BINARY_DIR}/schedule ${PG_TEST_SCHEDULE})\n```\n\n----------------------------------------\n\nTITLE: Defining Source Files for TimescaleDB Network Connection in CMake\nDESCRIPTION: Sets up source file variables for network connection handling in TimescaleDB, including plain connections, HTTP functionality, and conditionally SSL connections when OpenSSL is enabled. The defined sources are then added to the project target.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/net/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/conn.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/conn_plain.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/http.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/http_response.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/http_request.c)\n\nif(USE_OPENSSL)\n  list(APPEND SOURCES ${CMAKE_CURRENT_SOURCE_DIR}/conn_ssl.c)\nendif(USE_OPENSSL)\n\ntarget_sources(${PROJECT_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Targeting Source Files for Tests Library in CMake\nDESCRIPTION: This CMake command associates the specified source files with the tests library. `target_sources` links the source files defined in the `SOURCES` variable to the target specified by `${TESTS_LIB_NAME}`.  It compiles these files into the library. `TESTS_LIB_NAME` must be previously defined.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/src/net/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${TESTS_LIB_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Status Message and Optimizer Debug\nDESCRIPTION: Prints the compiler used and, if optimizer debug is enabled, adds a definition and prints a corresponding status message. This configures compiler behavior, and lets developers know the build configuration.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_16\n\nLANGUAGE: CMake\nCODE:\n```\nmessage(STATUS \"Using compiler ${CMAKE_C_COMPILER_ID}\")\n\nif(ENABLE_OPTIMIZER_DEBUG)\n  message(\n    STATUS\n      \"Enabling OPTIMIZER_DEBUG. Make sure that ${PG_SOURCE_DIR} is installed and built with OPTIMIZER_DEBUG.\"\n  )\n  add_definitions(-DOPTIMIZER_DEBUG)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Output Properties for the TSL Library in CMake\nDESCRIPTION: Configures output properties for the TSL library target using `set_target_properties`. It sets the final output filename (`OUTPUT_NAME`) to include the project version (`${PROJECT_VERSION_MOD}`) and removes any default library prefix (like 'lib' on Linux or empty on Windows) by setting `PREFIX` to an empty string.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nset_target_properties(\n  ${TSL_LIBRARY_NAME}\n  PROPERTIES OUTPUT_NAME ${TSL_LIBRARY_NAME}-${PROJECT_VERSION_MOD} PREFIX \"\")\n```\n\n----------------------------------------\n\nTITLE: Defining Main Coverage Target and Post-Build Message in CMake\nDESCRIPTION: Inside the `if(GENHTML)` block, this defines the main `coverage` target, which users can invoke (e.g., `make coverage`). This target depends on the HTML report's index file (`${REPORT_DIR}/index.html`), ensuring `genhtml` runs. It also depends on the `coverage_final` target. Finally, a post-build command is added to the `coverage` target to print a message indicating the location of the generated HTML report file after the target completes successfully.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/codecov/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\n  # ... inside if(GENHTML) block ...\n  add_custom_target(coverage DEPENDS ${REPORT_DIR}/index.html)\n  add_dependencies(coverage coverage_final)\n\n  add_custom_command(\n    COMMAND\n      echo\n      \"Open file://${CMAKE_CURRENT_BINARY_DIR}/${REPORT_DIR}/index.html in a browser to view the report\"\n      TARGET coverage POST_BUILD\n    COMMENT)\n  # ... end of if(GENHTML) block ...\n```\n\n----------------------------------------\n\nTITLE: Setting and Exporting CMake Directory Variables (CMake)\nDESCRIPTION: Initializes the PRIMARY_TEST_DIR variable with the current list directory and exports it to the parent CMake scope. This allows the test directory reference to be shared across subprojects or included CMake scripts. No input/output is produced directly; it enables subsequent scripts to reliably locate test resources in this directory.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(PRIMARY_TEST_DIR ${CMAKE_CURRENT_LIST_DIR})\nset(PRIMARY_TEST_DIR\n    ${CMAKE_CURRENT_LIST_DIR}\n    PARENT_SCOPE)\n```\n\n----------------------------------------\n\nTITLE: Generating Local Code Coverage Data Files with lcov (CMake)\nDESCRIPTION: This outlines the steps involved in generating local code coverage data files using the `lcov` tool. It leverages CMake targets (`coverage_base`, `coverage_test`, and `coverage_final`) to generate the necessary data.  This process typically involves running a baseline, executing tests, and then combining results. The `lcov` tool must be installed. Filtering of paths to exclude certain files from the coverage report is also mentioned as an optional step.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/codecov/README.md#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ncoverage_base target\ncoverage_test target\ncoverage_final target\n```\n\n----------------------------------------\n\nTITLE: Generating PostgreSQL Test Execution Schedule - CMake Macro\nDESCRIPTION: This code calls the custom generate_test_schedule CMake macro to automate the creation of a test execution plan for the regression suite. It takes as arguments the output schedule file, the compiled list of test files, indicators for solo tests, and the group size for parallel test execution. It depends on the existence of a GenerateTestSchedule CMake module and previously set variables for test lists and group size. Inputs are the scheduled test files and configuration variables; the macro outputs the final test execution schedule.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/sql/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ngenerate_test_schedule(\n  ${TEST_SCHEDULE}\n  TEST_FILES\n  ${TEST_FILES}\n  SOLO\n  ${SOLO_TESTS}\n  GROUP_SIZE\n  ${PARALLEL_GROUP_SIZE})\n```\n\n----------------------------------------\n\nTITLE: Adding CMake Module Path\nDESCRIPTION: This adds the `cmake` directory within the current source directory to the CMake module search path. This allows the project to use custom CMake modules located in the specified directory, extending CMake's functionality.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake)\n```\n\n----------------------------------------\n\nTITLE: CMake - Finding NM Program\nDESCRIPTION: This snippet uses the `find_program` function to locate the 'nm' program on the system. It searches for the executable with the name 'nm' in several standard paths including /usr/bin, /usr/local/bin, and /opt/local/bin. The result is stored in the NM variable. If 'nm' is found a status message informs the user, otherwise a message instructs the user to install it to allow export checks.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/scripts/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfind_program(\n  NM\n  NAMES nm\n  PATHS /usr/bin /usr/local/bin /opt/local/bin)\nif(NM)\n  message(STATUS \"Using nm ${NM}\")\nelse()\n  message(STATUS \"Install nm to be able to run export checks\")\nendif(NM)\n```\n\n----------------------------------------\n\nTITLE: Adding PostgreSQL Include Directories in CMake\nDESCRIPTION: Specifies the PostgreSQL server include directory (`${PG_INCLUDEDIR}`) as a private include path for the TSL library target using `target_include_directories`. This ensures the TSL source files can locate necessary PostgreSQL headers during compilation.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${TSL_LIBRARY_NAME} PRIVATE ${PG_INCLUDEDIR})\n```\n\n----------------------------------------\n\nTITLE: Generating Test Schedule from Spec Files in CMake\nDESCRIPTION: Processes each test file in the list, extracts the test name by removing the .spec extension, and appends an entry to the isolation test schedule file.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/isolation/specs/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMAKE\nCODE:\n```\nforeach(TEST_FILE ${TEST_FILES})\n  string(REGEX REPLACE \"(.+)\\.spec\" \"\\\\1\" TESTS_TO_RUN ${TEST_FILE})\n  file(APPEND ${ISOLATION_TEST_SCHEDULE} \"test: ${TESTS_TO_RUN}\\n\")\nendforeach(TEST_FILE)\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories in CMake\nDESCRIPTION: This command adds an include directory for the test library.  `target_include_directories` specifies the directory containing header files needed for compiling the test library `${TESTS_LIB_NAME}`. `${PROJECT_SOURCE_DIR}/src/net` should contain the necessary header files for network related operations.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/src/net/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${TESTS_LIB_NAME}\n                           PRIVATE ${PROJECT_SOURCE_DIR}/src/net)\n```\n\n----------------------------------------\n\nTITLE: Configuring OpenSSL and Dependencies\nDESCRIPTION: This snippet configures OpenSSL if `USE_OPENSSL` is enabled. It adds the include directory for OpenSSL to the project and links the OpenSSL libraries for MSVC builds. It also specifies the necessary dependencies and include directories to support secure communication using OpenSSL.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif(USE_OPENSSL)\n  set(TS_USE_OPENSSL ${USE_OPENSSL})\n  target_include_directories(${PROJECT_NAME} SYSTEM\n                             PUBLIC ${OPENSSL_INCLUDE_DIR})\n  if(MSVC)\n    target_link_libraries(${PROJECT_NAME} ${OPENSSL_LIBRARIES})\n  endif(MSVC)\nendif(USE_OPENSSL)\n```\n\n----------------------------------------\n\nTITLE: Locating PostgreSQL Source Code in CMake\nDESCRIPTION: Searches for PostgreSQL source code in common development directories. Finding the source code enables enhanced development features like better LSP (Language Server Protocol) integration for code navigation when the PG_SOURCE_INCLUDES option is enabled.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_22\n\nLANGUAGE: CMake\nCODE:\n```\nfind_path(\n  PG_SOURCE_DIR src/include/pg_config.h.in\n  HINTS $ENV{HOME} $ENV{HOME}/projects $ENV{HOME}/Projects\n        $ENV{HOME}/development $ENV{HOME}/Development $ENV{HOME}/workspace\n  PATH_SUFFIXES postgres postgresql pgsql\n  DOC \"The path to the PostgreSQL source tree\")\n\noption(PG_SOURCE_INCLUDES \"Add PG source to include directories\" OFF)\n\nif(PG_SOURCE_DIR)\n  message(STATUS \"Found PostgreSQL source in ${PG_SOURCE_DIR}\")\n  if(PG_SOURCE_INCLUDES)\n    # Add the PostgreSQL source dir include directories to the build system\n    # includes BEFORE the installed PG include files. This will allow the LSP\n    # (e.g., clangd) to navigate to the PostgreSQL source instead of the install\n    # path directory that only has the headers.\n    include_directories(BEFORE SYSTEM ${PG_SOURCE_DIR}/src/include)\n  endif(PG_SOURCE_INCLUDES)\nendif(PG_SOURCE_DIR)\n```\n\n----------------------------------------\n\nTITLE: Displaying TimescaleDB Deprecation Table in Markdown\nDESCRIPTION: A markdown table showing the deprecated TimescaleDB features alongside their replacements. The table includes procedures, functions, views, and parameters that will be removed in the next major release.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CHANGELOG.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Deprecated | Replacement | Type |\n| --- | --- | --- |\n| decompress_chunk | convert_to_rowstore | Procedure |\n| compress_chunk | convert_to_columnstore | Procedure |\n| add_compression_policy | add_columnstore_policy | Function |\n| remove_compression_policy | remove_columnstore_policy | Function |\n| hypertable_compression_stats | hypertable_columnstore_stats | Function |\n| chunk_compression_stats | chunk_columnstore_stats | Function |\n| hypertable_compression_settings | hypertable_columnstore_settings | View |\n| chunk_compression_settings | chunk_columnstore_settings | View |\n| compression_settings | columnstore_settings | View |\n| timescaledb.compress | timescaledb.enable_columnstore | Parameter |\n| timescaledb.compress_segmentby | timescaledb.segmentby | Parameter |\n| timescaledb.compress_orderby  | timescaledb.orderby | Parameter |\n```\n\n----------------------------------------\n\nTITLE: Configuring TimescaleDB TSL Library Build Structure with CMake\nDESCRIPTION: This CMake snippet initializes an empty sources variable, adds these sources to the TSL library target, and includes multiple subdirectories that contain component-specific source files for the TimescaleDB TSL library.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/nodes/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES)\ntarget_sources(${TSL_LIBRARY_NAME} PRIVATE ${SOURCES})\nadd_subdirectory(decompress_chunk)\nadd_subdirectory(columnar_scan)\nadd_subdirectory(frozen_chunk_dml)\nadd_subdirectory(gapfill)\nadd_subdirectory(skip_scan)\nadd_subdirectory(vector_agg)\n```\n\n----------------------------------------\n\nTITLE: Configuring Git Commit Message Hook in CMake\nDESCRIPTION: Checks for the existence of the '.git' directory at the project's source root. If found, it copies the Python script 'scripts/githooks/commit_msg.py' to '.git/hooks/commit-msg' using configure_file with the COPYONLY option. This sets up a client-side Git hook to potentially validate commit messages.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_34\n\nLANGUAGE: CMake\nCODE:\n```\nif(IS_DIRECTORY ${PROJECT_SOURCE_DIR}/.git)\n  configure_file(${PROJECT_SOURCE_DIR}/scripts/githooks/commit_msg.py\n                 ${PROJECT_SOURCE_DIR}/.git/hooks/commit-msg COPYONLY)\nendif()\n```\n\nLANGUAGE: Python\nCODE:\n```\n${PROJECT_SOURCE_DIR}/scripts/githooks/commit_msg.py\n```\n\n----------------------------------------\n\nTITLE: Setting Target Properties and Installation\nDESCRIPTION: This snippet sets properties for the target library, specifically the output name, and then installs the created target to the specified destination directory. It defines the output file name by appending a project version and removes any prefix.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset_target_properties(\n  ${PROJECT_NAME} PROPERTIES OUTPUT_NAME ${PROJECT_NAME}-${PROJECT_VERSION_MOD}\n                             PREFIX \"\")\n\ninstall(TARGETS ${PROJECT_NAME} DESTINATION ${PG_PKGLIBDIR})\n```\n\n----------------------------------------\n\nTITLE: Conditionally Appending Debug Tests in CMake\nDESCRIPTION: Checks if the `CMAKE_BUILD_TYPE` variable matches 'Debug'. If it does, specific SQL test files (`extension.sql`, `timestamp_limits.sql`, `with_clause_parser.sql`, `constify_now.sql`) are appended to the `TEST_FILES_SHARED` list using the `list(APPEND ...)` command.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/shared/sql/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES Debug)\n  list(APPEND TEST_FILES_SHARED extension.sql timestamp_limits.sql\n       with_clause_parser.sql)\n  list(APPEND TEST_FILES_SHARED constify_now.sql)\nendif(CMAKE_BUILD_TYPE MATCHES Debug)\n```\n\n----------------------------------------\n\nTITLE: Setting TSL Compile Definitions in CMake\nDESCRIPTION: Adds public compile definitions (`TS_TSL`, `TS_SUBMODULE`) to the TSL library target using `target_compile_definitions`. These preprocessor macros can be used within the TSL C source code to control conditional compilation specific to the TSL module context.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_compile_definitions(${TSL_LIBRARY_NAME} PUBLIC TS_TSL)\ntarget_compile_definitions(${TSL_LIBRARY_NAME} PUBLIC TS_SUBMODULE)\n```\n\n----------------------------------------\n\nTITLE: Defining and Appending Source Files for a CMake Target\nDESCRIPTION: This CMake script initializes a variable `SOURCES` with a list of C source files for fixed-size hash strategies. It then checks the `USE_UMASH` flag; if true, it appends source files for text and serialized hash strategies to the `SOURCES` list. Finally, it adds all files listed in `SOURCES` as private source files to the CMake target specified by the `TSL_LIBRARY_NAME` variable.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/nodes/vector_agg/hashing/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/hash_strategy_single_fixed_2.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/hash_strategy_single_fixed_4.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/hash_strategy_single_fixed_8.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/hash_strategy_common.c)\n\nif(USE_UMASH)\n  list(APPEND SOURCES ${CMAKE_CURRENT_SOURCE_DIR}/hash_strategy_single_text.c\n       ${CMAKE_CURRENT_SOURCE_DIR}/hash_strategy_serialized.c)\nendif()\n\ntarget_sources(${TSL_LIBRARY_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Defining Compile Definitions for Test Library in CMake\nDESCRIPTION: This snippet adds a public compile definition `TS_SUBMODULE` to the `TSL_TESTS_LIB_NAME` library.  This is achieved using `target_compile_definitions()`. This definition makes `TS_SUBMODULE` available to the compilation process, enabling conditional compilation logic based on whether this module is included. This can be used to enable/disable certain parts of the test library.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/src/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_definitions(${TSL_TESTS_LIB_NAME} PUBLIC TS_SUBMODULE)\n```\n\n----------------------------------------\n\nTITLE: Generating Parallel Test Schedule in CMake\nDESCRIPTION: Generates the content for the test schedule file specified by `TEST_SCHEDULE_SHARED`. It iterates through both `TEST_FILES_SHARED` and `SOLO_TESTS`, extracting the base name (without .sql) using `string(REGEX REPLACE ...)`. Tests are grouped into lines prefixed with 'test: ', with the number of tests per line controlled by `PARALLEL_GROUP_SIZE`. The `file(APPEND ...)` command writes the formatted test names to the schedule file.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/shared/sql/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nset(GROUP_MEMBERS 0)\nforeach(TEST_FILE ${TEST_FILES_SHARED})\n  string(REGEX REPLACE \"(.+)\\.sql\" \"\\\\1\" TESTS_TO_RUN ${TEST_FILE})\n  if(GROUP_MEMBERS EQUAL 0)\n    file(APPEND ${TEST_SCHEDULE_SHARED} \"\\ntest: \")\n  endif()\n  file(APPEND ${TEST_SCHEDULE_SHARED} \"${TESTS_TO_RUN} \")\n  math(EXPR GROUP_MEMBERS \"(${GROUP_MEMBERS}+1)%${PARALLEL_GROUP_SIZE}\")\nendforeach(TEST_FILE)\nfile(APPEND ${TEST_SCHEDULE_SHARED} \"\\n\")\n\nset(GROUP_MEMBERS 0)\nforeach(TEST_FILE ${SOLO_TESTS})\n  string(REGEX REPLACE \"(.+)\\.sql\" \"\\\\1\" TESTS_TO_RUN ${TEST_FILE})\n  if(GROUP_MEMBERS EQUAL 0)\n    file(APPEND ${TEST_SCHEDULE_SHARED} \"\\ntest: \")\n  endif()\n  file(APPEND ${TEST_SCHEDULE_SHARED} \"${TESTS_TO_RUN} \")\n  math(EXPR GROUP_MEMBERS \"(${GROUP_MEMBERS}+1)%${PARALLEL_GROUP_SIZE}\")\nendforeach(TEST_FILE)\nfile(APPEND ${TEST_SCHEDULE_SHARED} \"\\n\")\n```\n\n----------------------------------------\n\nTITLE: Appending Shared Regression Checks to Lists\nDESCRIPTION: Appends `regresscheck-shared` and `regresschecklocal-shared` to appropriate install check lists.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND _install_checks regresscheck-shared)\nlist(APPEND _local_install_checks regresschecklocal-shared)\n```\n\n----------------------------------------\n\nTITLE: Coccinelle Block Dependencies Example\nDESCRIPTION: This snippet shows how to create dependencies between Coccinelle blocks using the `depends on` keyword. `b2` depends on `name`, and `b3` depends on `name` but excludes `b2` using the `!` operator. This ensures specific execution order and conditional matching.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/coccinelle/README.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n@ b2 depends on name @\n@@\n@ b3 depends on name && !b2 @\n@@\n```\n\n----------------------------------------\n\nTITLE: Selecting the Appropriate Gcov Tool in CMake\nDESCRIPTION: This snippet sets the preferred gcov tool name. If the C compiler is Clang or AppleClang, it prioritizes using the corresponding llvm-cov version (e.g., llvm-cov-10 for Clang 10) because the standard gcov can have issues with Clang-generated coverage data. It extracts the major version from the compiler version string and prepends the llvm-cov tool name to the search list.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/codecov/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(GCOV_NAMES \"gcov\")\nif(CMAKE_C_COMPILER_ID MATCHES \"Clang|AppleClang\")\n  string(REGEX MATCH \"^[0-9]+\" CMAKE_C_COMPILER_VERSION_MAJOR\n               ${CMAKE_C_COMPILER_VERSION})\n  list(PREPEND GCOV_NAMES \"llvm-cov-${CMAKE_C_COMPILER_VERSION_MAJOR}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Declarations Before Code in C\nDESCRIPTION: Illustrates permissible placement of code statements before declarations inside functions, supported in C99 and allowed in TimescaleDB C code. This snippet shows calling a function before declaring and initializing variables within a function body.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/docs/StyleGuide.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid some_function()\n{\n    prepare();\n\tint result = fetch();\n\t...\n}\n```\n\n----------------------------------------\n\nTITLE: Copy Test Files to Build Directory Using CMake configure_file\nDESCRIPTION: This CMake snippet iterates through each file name stored in the `PROVE_TEST_FILES` list. For each file, it uses the `configure_file` command with the `COPYONLY` option to copy the file from its source location to the current binary build directory specified by `CMAKE_CURRENT_BINARY_DIR`. This makes the test files available in the build output.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/t/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(P_FILE ${PROVE_TEST_FILES})\n  configure_file(${P_FILE} ${CMAKE_CURRENT_BINARY_DIR}/${P_FILE} COPYONLY)\nendforeach(P_FILE)\n```\n\n----------------------------------------\n\nTITLE: Defining Functions and Variables Using Lowercase Underscore Naming in C\nDESCRIPTION: Provides a correct example of function and variable naming conventions using lowercase letters and underscores, as preferred for clarity and consistency in TimescaleDB C code. The snippet shows a static void function with a parameter and local variable using the prescribed naming format.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/docs/StyleGuide.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nstatic void\nmy_function_name(int my_parameter)\n{\n    int my_variable;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring for Windows Builds\nDESCRIPTION: Configures build types specifically for Windows. If the platform is WIN32 and `CMAKE_CONFIGURATION_TYPES` is not set, it sets the supported configuration types to \"Release\". This ensures MSBuild.exe behaves as intended.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\n# On Windows, default to only include Release builds so MSBuild.exe 'just works'\nif(WIN32 AND NOT CMAKE_CONFIGURATION_TYPES)\n  set(CMAKE_CONFIGURATION_TYPES\n      Release\n      CACHE\n        STRING\n        \"Semicolon separated list of supported configuration types, only supports Debug, Release, MinSizeRel, and RelWithDebInfo, anything else will be ignored.\"\n        FORCE)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Incorrect Typedef Declaration Using Lowercase Underscore Naming in C\nDESCRIPTION: Demonstrates the non-preferred typedef style where composite type names use lowercase letters with underscores, which contradicts the TimescaleDB naming guidelines for typedefs requiring UpperCamelCase.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/docs/StyleGuide.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\ntypedef struct my_type\n{\n    ...\n} my_type;\n```\n\n----------------------------------------\n\nTITLE: Migration SQL Script for TimescaleDB v2.15.X\nDESCRIPTION: SQL script required when migrating from TimescaleDB v2.14.x and earlier to v2.15.x. The script fixes hypertable foreign keys after running ALTER EXTENSION.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CHANGELOG.md#_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\nhttps://github.com/timescale/timescaledb-extras/blob/master/utils/2.15.X-fix_hypertable_foreign_keys.sql\n```\n\n----------------------------------------\n\nTITLE: Configuring Compression Fuzzing in CMake\nDESCRIPTION: This snippet checks the `COMPRESSION_FUZZING` option and adds a compile definition (`TS_COMPRESSION_FUZZING=1`) if enabled.  This defines a preprocessor symbol to enable fuzzing-related code.  The `option` command sets the default value to `OFF`. This is crucial for enabling fuzzing-related features during compilation, which leverages Libfuzzer to perform fuzzing on the compression components.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\noption(CODECOVERAGE \"Enable fuzzing of compression using Libfuzzer\" OFF)\n\nif(COMPRESSION_FUZZING)\n  add_compile_definitions(TS_COMPRESSION_FUZZING=1)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Launcher Per-DB State Machine Diagram in Markdown\nDESCRIPTION: A ASCII diagram showing the state machine implemented by the launcher for each database. It illustrates states (ENABLED, ALLOCATED, STARTED, DISABLED) and transitions between them based on message types (start, stop, restart) and automatic transitions.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/loader/README.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n                   stop\n      ENABLED+--------------+\n         +   ^--------------||\n         |   start/restart ||\n         |                 ||\n         |                 ||\n         v                 +v\n      ALLOCATED+------> DISABLED\n        ^+       stop       ^\n        ||                  |\n restart ||                  |\n        ||                  |\n        +v                  |\n      STARTED+--------------+\n                stop / scheduler quit\n```\n\n----------------------------------------\n\nTITLE: Formatting Perl Test Scripts with perltidy - Shell\nDESCRIPTION: This shell command formats a Perl test script using perltidy, enforcing the project style as specified in the .perltidyrc file. Replace /path/to/taptest with the path to your Perl test script. Requires perltidy installed and the $TS_SRC_DIR environment variable pointing to the TimescaleDB source directory.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/perl/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nperltidy --profile=$TS_SRC_DIR/.perltidyrc /path/to/taptest\n```\n\n----------------------------------------\n\nTITLE: Setting Debug Compiler Flags\nDESCRIPTION: Sets additional compiler flags for debug builds.  It adds `-DDEBUG=1` and `-DTS_DEBUG=1` flags if the `CMAKE_BUILD_TYPE` is set to Debug. This helps to enable debug-specific code and optimizations during the build process.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES Debug)\n  # CMAKE_BUILD_TYPE is set at CMake configuration type. But usage of\n  # CMAKE_C_FLAGS_DEBUG is determined at build time by running cmake --build .\n  # --config Debug (at least on Windows). Therefore, we only set these flags if\n  # the configuration-time CMAKE_BUILD_TYPE is set to Debug. Then Debug enabled\n  # builds will only happen on Windows if both the configuration- and build-time\n  # settings are Debug.\n  set(CMAKE_C_FLAGS_DEBUG \"${CMAKE_C_FLAGS_DEBUG} -DDEBUG=1 -DTS_DEBUG=1\")\nendif(CMAKE_BUILD_TYPE MATCHES Debug)\n```\n\n----------------------------------------\n\nTITLE: Adding Debug-Only Test Files in CMake\nDESCRIPTION: Conditionally adds additional isolation test files only when building in Debug mode, providing more extensive testing for development purposes.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/isolation/specs/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMAKE\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES Debug)\n  list(APPEND TEST_FILES concurrent_add_dimension.spec\n       concurrent_query_and_drop_chunks.spec dropchunks_race.spec\n       multi_transaction_indexing.spec)\nendif(CMAKE_BUILD_TYPE MATCHES Debug)\n```\n\n----------------------------------------\n\nTITLE: Conditionally Add Test File for Debug Build in CMake\nDESCRIPTION: This CMake snippet checks if the build type is 'Debug' using the `CMAKE_BUILD_TYPE` variable. If it matches 'Debug', it appends the specific test file `001_replication_telemetry.pl` to the `PROVE_TEST_FILES` list. This is useful for including tests that are relevant only during debugging.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/t/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES Debug)\n  list(APPEND PROVE_TEST_FILES 001_replication_telemetry.pl)\nendif(CMAKE_BUILD_TYPE MATCHES Debug)\n```\n\n----------------------------------------\n\nTITLE: Finding Gcov and Lcov executables in CMake\nDESCRIPTION: These commands search the system's PATH for the gcov (using the prioritized list from the previous step) and lcov executables. The paths to the found programs are stored in the GCOV and LCOV CMake variables respectively.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/codecov/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfind_program(GCOV NAMES ${GCOV_NAMES})\n\n# Find lcov for html output\nfind_program(LCOV lcov)\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Isolation Test Files in CMake\nDESCRIPTION: Initializes a list of isolation test specification files (.spec) that will be used for testing TimescaleDB's behavior under concurrent operations.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/isolation/specs/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMAKE\nCODE:\n```\nset(TEST_FILES\n    deadlock_dropchunks_select.spec\n    insert_dropchunks_race.spec\n    isolation_nop.spec\n    read_committed_insert.spec\n    read_uncommitted_insert.spec\n    repeatable_read_insert.spec\n    serializable_insert_rollback.spec\n    serializable_insert.spec)\n```\n\n----------------------------------------\n\nTITLE: Defining the USE_UMASH Build Option in CMake\nDESCRIPTION: Defines a CMake build option `USE_UMASH` using the `option` command. This allows users to explicitly enable or disable the use of UMASH hashing. The option's default value is set to the result of the platform support check (`${UMASH_SUPPORTED}`).\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\noption(USE_UMASH\n       \"Use the UMASH hash for string and multi-column vectorized grouping\"\n       ${UMASH_SUPPORTED})\n```\n\n----------------------------------------\n\nTITLE: Conditionally Appending Build Info Test in CMake\nDESCRIPTION: Checks if the `GIT_FOUND` variable is defined (indicating Git is available). If it is, the `build_info.sql` test file is appended to the `TEST_FILES_SHARED` list.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/shared/sql/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(DEFINED GIT_FOUND)\n  list(APPEND TEST_FILES_SHARED build_info.sql)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Generating TimescaleDB Downgrade Script via Bootstrap (Shell)\nDESCRIPTION: This command demonstrates how to initiate the TimescaleDB build process (`bootstrap`) with the option to generate a downgrade script enabled. It sets the CMake definition `GENERATE_DOWNGRADE_SCRIPT` to `ON`, which requires the source code to be located within a Git repository for accessing previous versions.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/sql/updates/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n./bootstrap -DGENERATE_DOWNGRADE_SCRIPT=ON\n```\n\n----------------------------------------\n\nTITLE: Configuring Debug Build Settings in CMake\nDESCRIPTION: Checks if the `CMAKE_BUILD_TYPE` variable matches 'Debug'. If it does, it sets the CMake variables `TS_DEBUG` and `DEBUG` to 1, which are typically used to enable debug-specific code paths or preprocessor definitions.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n# Add test source code in Debug builds\nif(CMAKE_BUILD_TYPE MATCHES Debug)\n  set(TS_DEBUG 1)\n  set(DEBUG 1)\nendif(CMAKE_BUILD_TYPE MATCHES Debug)\n```\n\n----------------------------------------\n\nTITLE: Installing Perl 5.8.0 and Dependencies with perlbrew and cpanm - Shell\nDESCRIPTION: This sequence of shell commands uses perlbrew to install Perl version 5.8.0 and the cpanm module installer, then installs the IPC::Run Perl module. Ensures compatibility for running TimescaleDB TAP tests. Dependencies: perlbrew, cpanm, internet access for downloads.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/perl/README.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nperlbrew --force install 5.8.0\nperlbrew use 5.8.0\nperlbrew install-cpanm\ncpanm install IPC::Run\n```\n\n----------------------------------------\n\nTITLE: Conditionally Installing Perl Test Files (CMake)\nDESCRIPTION: This snippet checks if TAP tests are enabled and if the test directory exists. If both conditions are met, it installs the files specified in the `PERL_FILES` variable to the test directory. It relies on `TAP_CHECKS` and the existence of the test directory inside PostgreSQL's package library directory (`PG_PKGLIBDIR`).  The output is the installation of the Perl file to the PostgreSQL test directory.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/perl/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Check if PostgreSQL was compiled with --enable-tap-tests\nif(TAP_CHECKS AND EXISTS \"${PG_PKGLIBDIR}/pgxs/src/test/perl\")\n  install(FILES ${PERL_FILES} DESTINATION \"${PG_PKGLIBDIR}/pgxs/src/test/perl\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Debug Source Code\nDESCRIPTION: This snippet conditionally adds a debug-related source file (`debug_point.c`) to the list of sources if the `CMAKE_BUILD_TYPE` is set to `Debug`. It defines `TS_DEBUG` and `DEBUG` flags, which might be used in the source code for debugging purposes. This allows for different build configurations, optimizing for debugging and development builds separately.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES Debug)\n  set(TS_DEBUG 1)\n  set(DEBUG 1)\n  list(APPEND SOURCES debug_point.c)\nendif(CMAKE_BUILD_TYPE MATCHES Debug)\n```\n\n----------------------------------------\n\nTITLE: Including Build Definitions in CMake\nDESCRIPTION: This includes a CMake file containing build definitions using the `include()` command. This file is located within the project's source directory and is used to centralize common build settings and configurations. It likely contains settings for compiler flags, include paths, and other project-specific configurations. This ensures consistency across the build system.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/src/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(${PROJECT_SOURCE_DIR}/tsl/src/build-defs.cmake)\n```\n\n----------------------------------------\n\nTITLE: CMake - Configuring export_prefix_check.sh\nDESCRIPTION: This snippet uses `configure_file` to generate 'export_prefix_check.sh' from 'export_prefix_check.sh.in'. The `@ONLY` option ensures the configuration happens. The input file contains the template, and the output file will be a generated shell script.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/scripts/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nconfigure_file(export_prefix_check.sh.in export_prefix_check.sh @ONLY)\n```\n\n----------------------------------------\n\nTITLE: Clearing and Preparing Test Schedule File in CMake\nDESCRIPTION: Removes any existing test schedule file to prepare for generating a new one with the current test configuration.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/isolation/specs/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMAKE\nCODE:\n```\nfile(REMOVE ${ISOLATION_TEST_SCHEDULE})\n\nset(TEST_TEMPLATES)\n```\n\n----------------------------------------\n\nTITLE: Including test definitions\nDESCRIPTION: Includes the `test-defs.cmake` file from the `PRIMARY_TEST_DIR` directory. This file likely contains common definitions and configurations used across different tests in the project.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(\"${PRIMARY_TEST_DIR}/test-defs.cmake\")\n```\n\n----------------------------------------\n\nTITLE: Setting the TSL Library Name in CMake\nDESCRIPTION: Defines the CMake variable `TSL_LIBRARY_NAME` by concatenating the main project name (`${PROJECT_NAME}`) with '-tsl'. This variable provides a consistent name for the TSL library target used later in the script.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(TSL_LIBRARY_NAME ${PROJECT_NAME}-tsl)\n```\n\n----------------------------------------\n\nTITLE: Versioning Source Files by Replacing Placeholders with CMake Functions for TimescaleDB\nDESCRIPTION: Defines two CMake functions, 'version_files' and 'version_check_file', which automate creation of versioned copies of source SQL files by replacing placeholders like @MODULE_PATHNAME@ or @VARIABLE@ with actual version values. 'version_files' generates output files named identically to source files, while 'version_check_file' appends the start version to filenames. Both functions check for the source files' existence and run CMake's 'configure_file' to perform substitutions. These functions facilitate maintaining consistency across versioned SQL scripts for building and updating TimescaleDB extensions.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/sql/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(version_files SRC_FILE_LIST OUTPUT_FILE_LIST)\n  set(result \"\")\n  foreach(unversioned_file ${SRC_FILE_LIST})\n    set(versioned_file ${unversioned_file})\n    list(APPEND result ${CMAKE_CURRENT_BINARY_DIR}/${versioned_file})\n    if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/${unversioned_file})\n      configure_file(${unversioned_file} ${versioned_file} @ONLY)\n    endif()\n  endforeach(unversioned_file)\n  set(${OUTPUT_FILE_LIST}\n      \"${result}\"\n      PARENT_SCOPE)\nendfunction()\n\nfunction(version_check_file SRC_FILE_LIST OUTPUT_FILE_LIST)\n  set(result \"\")\n  foreach(unversioned_file ${SRC_FILE_LIST})\n    set(versioned_file ${unversioned_file}-${START_VERSION})\n    list(APPEND result ${CMAKE_CURRENT_BINARY_DIR}/${versioned_file})\n    if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/${unversioned_file})\n      configure_file(${unversioned_file} ${versioned_file} @ONLY)\n    endif()\n  endforeach(unversioned_file)\n  set(${OUTPUT_FILE_LIST}\n      \"${result}\"\n      PARENT_SCOPE)\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Configuring OpenSSL Dependency for MSVC in CMake\nDESCRIPTION: Checks if USE_OPENSSL and MSVC flags are set. If so, it finds the OpenSSL package using find_package, validates that the version is 1.0 or greater, and ensures library paths are correctly resolved, especially for Debug builds. It exits with a fatal error if OpenSSL is required but not found or if the version requirement is not met.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_29\n\nLANGUAGE: CMake\nCODE:\n```\n# OpenSSL libraries.\nif(USE_OPENSSL AND MSVC)\n  # Try to find a local OpenSSL installation\n  find_package(OpenSSL)\n\n  if(NOT OPENSSL_FOUND)\n    message(\n      FATAL_ERROR\n        \"TimescaleDB requires OpenSSL but it wasn't found. If you want to continue without OpenSSL, re-run bootstrap with `-DUSE_OPENSSL=0`\"\n    )\n  endif(NOT OPENSSL_FOUND)\n\n  if(${OPENSSL_VERSION} VERSION_LESS \"1.0\")\n    message(FATAL_ERROR \"TimescaleDB requires OpenSSL version 1.0 or greater\")\n  endif()\n\n  set(_libraries)\n  foreach(_path ${OPENSSL_LIBRARIES})\n    if(EXISTS \"${_path}\")\n      list(APPEND _libraries ${_path})\n    else()\n      # check if a release version of the libraries are available\n      if(CMAKE_BUILD_TYPE STREQUAL \"Debug\" AND MSVC)\n        get_filename_component(_dir ${_path} DIRECTORY)\n        get_filename_component(_name ${_path} NAME_WE)\n        string(REGEX REPLACE \"[Dd]$\" \"\" _fixed ${_name})\n        get_filename_component(_ext ${_path} EXT)\n        set(_new_path \"${_dir}/${_fixed}${_ext}\")\n        if(EXISTS \"${_new_path}\")\n          list(APPEND _libraries ${_new_path})\n        endif()\n      endif()\n    endif()\n  endforeach()\n  set(OPENSSL_LIBRARIES ${_libraries})\n\n  foreach(_path ${OPENSSL_LIBRARIES})\n    message(STATUS \"OpenSSL libraries: ${_path}\")\n  endforeach()\n  message(STATUS \"Using OpenSSL version ${OPENSSL_VERSION}\")\nendif(USE_OPENSSL AND MSVC)\n```\n\n----------------------------------------\n\nTITLE: Setting Perl File Variable (CMake)\nDESCRIPTION: This snippet defines a CMake variable `PERL_FILES` and assigns it the value `TimescaleNode.pm`. This variable is used later to install the specified Perl file to a test directory. There are no dependencies beyond the CMake environment itself.  The output is simply a variable assignment within the CMake build system.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/perl/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(PERL_FILES TimescaleNode.pm)\n```\n\n----------------------------------------\n\nTITLE: Coccinelle Variable Referencing Example\nDESCRIPTION: This code snippet illustrates how to reference variables from previous blocks in Coccinelle. The expression `name.var1` inside block `b2` will refer to the match of `var1` in the block named `name`. This enables re-use of matched expressions across different semantic patches.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/coccinelle/README.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n@ b2 depends on name @\nExpression name.var1;\n@@\n```\n\n----------------------------------------\n\nTITLE: Defining test check lists\nDESCRIPTION: Initializes two lists, `_local_install_checks` and `_install_checks`. These lists are used to accumulate the names of the different test targets that need to be run as part of the installation check.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(_local_install_checks)\nset(_install_checks)\n```\n\n----------------------------------------\n\nTITLE: Defining custom build and install targets in CMake for TimescaleDB update scripts\nDESCRIPTION: This snippet defines a custom CMake target 'sqlupdatescripts' that depends on all generated update SQL scripts to ensure they are built during the project build process. Additionally, it sets up an install target to copy the generated extension control file and all update scripts to the PostgreSQL extension directory specified by PG_SHAREDIR. It requires variables pointing to generated files and the PostgreSQL share directory. The inputs are the build directory files and update scripts; the output is the installed extension and update SQL scripts for PostgreSQL deployment.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/sql/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(sqlupdatescripts ALL DEPENDS ${UPDATE_SCRIPTS})\n\n# Install target for the extension file and update scripts\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/${INSTALL_FILE} ${UPDATE_SCRIPTS}\n        DESTINATION \"${PG_SHAREDIR}/extension\")\n```\n\n----------------------------------------\n\nTITLE: Namespaced Function Declaration for Modular Code in C\nDESCRIPTION: Example of defining a function with a module-name prefix to implement logical grouping of code similar to namespaces or classes. This style supports modularity and clarity, as emphasized in TimescaleDB's Cache module design.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/docs/StyleGuide.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nvoid\ncache_initialize(Cache *c)\n{\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Extension Installation SQL File as Build Target in TimescaleDB with CMake\nDESCRIPTION: Uses the 'cat_create_files' function to combine pre-install source files, main source files, and a notice file into a single SQL installation file suitable for CREATE EXTENSION commands. The resulting file path is constructed from build directory and version information. A custom build target 'sqlfile' is also created that depends on this generated installation file, ensuring it is always built when invoking the build system.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/sql/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ncat_create_files(\n  \"${PRE_INSTALL_SOURCE_FILES_VERSIONED};${SOURCE_FILES_VERSIONED};${NOTICE_FILE}\"\n  ${CMAKE_CURRENT_BINARY_DIR}/${INSTALL_FILE})\nadd_custom_target(sqlfile ALL\n                  DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${INSTALL_FILE})\n```\n\n----------------------------------------\n\nTITLE: Generating Baseline Code Coverage File in CMake\nDESCRIPTION: Defines a custom command to generate the initial code coverage baseline file (`${OUTPUT_FILE}.base`). This command runs `lcov` with the `--initial` flag before any tests are executed to capture the state of coverage for all instrumented code, establishing which lines are initially uncovered. It uses the previously created symlink (`${CMAKE_CURRENT_BINARY_DIR}/gcov`) as the gcov tool. This command depends on the TimescaleDB targets and the gcov symlink.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/codecov/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_command(\n  OUTPUT ${OUTPUT_FILE}.base\n  COMMENT \"Generating code coverage base file\"\n  COMMAND\n    ${LCOV} --rc lcov_branch_coverage=1 --capture --initial # Initial run\n    --no-external # Do not include external source files\n    --base-directory ${CMAKE_SOURCE_DIR} --directory ${CMAKE_BINARY_DIR}\n    --output-file ${OUTPUT_FILE}.base --gcov-tool\n    ${CMAKE_CURRENT_BINARY_DIR}/gcov\n  DEPENDS timescaledb-tsl timescaledb timescaledb-loader\n          ${CMAKE_CURRENT_BINARY_DIR}/gcov)\n```\n\n----------------------------------------\n\nTITLE: Creating a log table for background worker message capture in SQL\nDESCRIPTION: Defines a table 'public.bgw_log' in SQL for storing background worker log messages, including message sequence number, virtual time, application name, and message content. This table assists in verifying background worker output during tests.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/src/bgw/README.md#_snippet_0\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE TABLE public.bgw_log(\n    msg_no INT,\n    mock_time BIGINT,\n    application_name TEXT,\n    msg TEXT\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring PostgreSQL Regression Test Files - CMake\nDESCRIPTION: This CMake code snippet sets up variables containing lists of SQL test files and template files required for regression testing of the TimescaleDB extension under PostgreSQL. It uses set, list(APPEND), if, foreach, and string commands to conditionally populate these lists based on CMake build type, PostgreSQL version macros, and custom options (like USE_TELEMETRY). Template files are transformed into test files with versioned suffixes via configure_file during the build. Key inputs are build options and the list of test SQLs; the outputs are consolidated lists for the test schedule generator. Requires CMake, configured PostgreSQL include dirs, and template files. Limitations: strictly CMake syntax; context-specific to TimescaleDB project.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/sql/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(GenerateTestSchedule)\n\nset(TEST_FILES\n    agg_partials_pushdown.sql\n    bgw_job_ddl.sql\n    ...\n    vectorized_aggregation.sql)\n\nset(TEST_TEMPLATES\n    cagg_query.sql.in\n    cagg_query_using_merge.sql.in\n    ...\n    transparent_decompression_ordered_index.sql.in)\n\nif(USE_TELEMETRY)\n  list(APPEND TEST_FILES bgw_telemetry.sql)\nendif()\n\nif(CMAKE_BUILD_TYPE MATCHES Debug)\n  list(APPEND TEST_FILES ...)\n  list(APPEND TEST_TEMPLATES ...)\n  if(USE_TELEMETRY)\n    list(APPEND TEST_FILES telemetry_stats.sql)\n  endif()\nendif()\n\nif((${PG_VERSION_MAJOR} GREATER_EQUAL \"16\"))\n  list(APPEND TEST_FILES ...)\nendif()\n\nif((${PG_VERSION_MAJOR} GREATER_EQUAL \"17\"))\n  list(APPEND TEST_FILES privilege_maintain.sql)\nendif()\n\nset(SOLO_TESTS\n    # ...\n    telemetry_stats)\n\nset(PG_CONFIG_H \"${PG_INCLUDEDIR}/pg_config.h\")\nif(EXISTS ${PG_CONFIG_H})\n  file(STRINGS \"${PG_CONFIG_H}\" PG_USE_LLVM\n       REGEX \"^#[\\t ]*define[\\t ]+USE_LLVM[\\t ]+1.*\")\n  if(PG_USE_LLVM)\n    list(APPEND TEST_FILES jit.sql)\n  endif()\nendif()\n\nforeach(TEMPLATE_FILE ${TEST_TEMPLATES})\n  string(LENGTH ${TEMPLATE_FILE} TEMPLATE_NAME_LEN)\n  math(EXPR TEMPLATE_NAME_LEN ${TEMPLATE_NAME_LEN}-7)\n  string(SUBSTRING ${TEMPLATE_FILE} 0 ${TEMPLATE_NAME_LEN} TEMPLATE)\n  set(TEST_FILE ${TEMPLATE}-${TEST_VERSION_SUFFIX}.sql)\n  configure_file(${TEMPLATE_FILE} ${CMAKE_CURRENT_SOURCE_DIR}/${TEST_FILE}\n                 COPYONLY)\n  list(APPEND TEST_FILES ${TEST_FILE})\nendforeach(TEMPLATE_FILE)\n\nif(NOT TEST_GROUP_SIZE)\n  set(PARALLEL_GROUP_SIZE 10)\nelse()\n  set(PARALLEL_GROUP_SIZE ${TEST_GROUP_SIZE})\nendif()\n\n```\n\n----------------------------------------\n\nTITLE: Memory Leak Suppression Configuration for TimescaleDB\nDESCRIPTION: A complete list of memory leak suppressions for TimescaleDB, organized by components including PostgreSQL frontend utilities, initialization functions, database utilities, and test-only functions. These suppressions are used to ignore known or acceptable memory leaks during testing or debugging.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/scripts/suppressions/suppr_leak.txt#_snippet_0\n\nLANGUAGE: configuration\nCODE:\n```\nleak:save_ps_display_args\nleak:psql/startup.c\n#don't care about the frontend leaks\nleak:fe_memutils.c\nleak:fe-connect.c\nleak:fe-exec.c\nleak:initdb.c\n#annoingly have to supress strdup because it leaks in PostmasterMain -D option\nleak:strdup\nleak:ProcessConfigFileInternal\nleak:internal_load_library\n\nleak:pg_timezone_abbrev_initialize\nleak:check_timezone_abbreviations\nleak:check_session_authorization\nleak:InitializeGUCOptions\nleak:CheckMyDatabase\n\n\n#pg_dump\nleak:getSchemaData\nleak:dumpDumpableObject\n\n#should live as long as the process\nleak:ShmemInitHash\n\n#test only functions\nleak:deserialize_test_parameters\nleak:ts_params_get\nleak:test_job_dispatcher\n\n#openssl\nleak:CRYPTO_zalloc\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Targets to Run PostgreSQL Regression Tests with TimescaleDB in CMake\nDESCRIPTION: Creates custom CMake build targets to execute PostgreSQL's regression tests using the PG_REGRESS tool. It sets options such as the test schedule file, loading the TimescaleDB extension, and specifying the dynamic library path. Targets include 'pginstallcheck' and 'pginstallchecklocal' that run tests on different PostgreSQL instances, leveraging terminal output and environment variables for proper test execution.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/pgtest/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Need --dlpath set to PostgreSQL's test directory so that the tests can load\n# libraries there\nset(PG_REGRESS_OPTS_PGTEST\n    --schedule=${CMAKE_CURRENT_BINARY_DIR}/schedule\n    --load-extension=timescaledb --dlpath=${PG_REGRESS_DIR})\n\nadd_custom_target(\n  pginstallcheck\n  COMMAND ${PG_REGRESS} ${PG_REGRESS_OPTS_BASE} ${PG_REGRESS_OPTS_PGTEST}\n          ${PG_REGRESS_OPTS_TEMP_INSTANCE_PGTEST}\n  USES_TERMINAL)\n\nadd_custom_target(\n  pginstallchecklocal\n  COMMAND ${PG_REGRESS} ${PG_REGRESS_OPTS_BASE} ${PG_REGRESS_OPTS_PGTEST}\n          ${PG_REGRESS_OPTS_LOCAL_INSTANCE}\n  USES_TERMINAL)\n```\n\n----------------------------------------\n\nTITLE: Incorrect CamelCase Naming of Functions and Variables in C\nDESCRIPTION: Example snippet demonstrating disallowed naming style where function and parameter names use uppercase letters and camel casing. This contrasts with the coding standard that requires lowercase underscored names for functions and variables in TimescaleDB.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/docs/StyleGuide.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nstatic void\nMyFunctionName(int myParameter)\n{\n    int myVariable;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Shared memory-based configuration setup for background worker tests in C\nDESCRIPTION: Explains the storage of test settings and timer parameters in shared memory, which must be initialized with 'ts_bgw_params_create' before use. Facilitates configuration management for test environment control.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/src/bgw/README.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\n// Shared memory segment for storing background worker test configurations, initialized with ts_bgw_params_create()\n```\n\n----------------------------------------\n\nTITLE: Typedef Declaration of Composite Types Using UpperCamelCase in C\nDESCRIPTION: Shows the correct way to declare new composite or aggregate types using typedef with UpperCamelCase naming for the type identifier. This style is recommended for type declarations to distinguish them from regular variables or functions.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/docs/StyleGuide.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\ntypedef struct MyType\n{\n    ...\n} MyType;\n```\n\n----------------------------------------\n\nTITLE: Perldoc Query for Test Module Documentation - Shell\nDESCRIPTION: This shell command shows how to access documentation for test modules using perldoc. Replace 'src/test/perl/PostgresNode.pm' with the relevant module file. This is useful for exploring test framework APIs and available helper methods. Requires perldoc installed and valid path to module.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/perl/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nperldoc src/test/perl/PostgresNode.pm\n```\n\n----------------------------------------\n\nTITLE: Description of timer mock implementation for deterministic testing in C\nDESCRIPTION: Details the virtualized timer system that uses shared memory to store a microsecond counter, allowing background processes to read current time and wait for specific durations, ensuring deterministic test execution. Includes the ability to reset time manually for multiple tests.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/src/bgw/README.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n// Timer mock implementation stores microsecond counter in shared memory\n// Provides functions to read, wait, and reset virtual time for background worker testing\n```\n\n----------------------------------------\n\nTITLE: Verifying Perl Interpreter Selection in TimescaleDB Build - Shell\nDESCRIPTION: This shell command greps the config.log file in the project root to verify which Perl interpreter was detected during TimescaleDB's configure phase. Ensures proper Perl version is being used to avoid test failures. Requires completed configuration and a config.log present.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/perl/README.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\ngrep ^PERL= config.log\n```\n\n----------------------------------------\n\nTITLE: Comment explaining background worker log table structure and intended usage in SQL\nDESCRIPTION: Provides documentation on the 'public.bgw_log' table structure, describing each column's purpose and how it is used to track background worker messages during testing, including message ordering, timing, and source application.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/src/bgw/README.md#_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\n/*\n  msg_no: sequence number of the message in total order\n  mock_time: virtual timestamp at message time\n  application_name: name of the message sender\n  msg: message content\n*/\n```\n\n----------------------------------------\n\nTITLE: Non-Namespaced Function Declaration (Discouraged) in C\nDESCRIPTION: Illustrates an example function declaration where the module name is used as a suffix rather than a prefix. This is discouraged because it reduces modular clarity, unlike the recommended namespaced prefix style in TimescaleDB.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/docs/StyleGuide.md#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nvoid\ninitialize_cache(Cache *c)\n{\n\n}\n```\n\n----------------------------------------\n\nTITLE: Adding TAP Test Target\nDESCRIPTION: Adds a custom target named `provecheck-t` that executes the `pg_prove.sh` script to run TAP tests.  It sets up necessary environment variables like `CONFDIR`, `PATH`, `PG_REGRESS`, `SRC_DIR`, `CM_SRC_DIR`, `PG_LIBDIR` and `PG_VERSION_MAJOR`.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(\n    provecheck-t\n    COMMAND rm -rf ${CMAKE_CURRENT_BINARY_DIR}/tmp_check\n    COMMAND\n      CONFDIR=${CMAKE_BINARY_DIR}/tsl/test PATH=\"${PG_BINDIR}:$ENV{PATH}\"\n      PG_REGRESS=${PG_REGRESS} SRC_DIR=${PG_SOURCE_DIR}\n      CM_SRC_DIR=${CMAKE_SOURCE_DIR} PG_LIBDIR=${PG_LIBDIR}\n      PG_VERSION_MAJOR=${PG_VERSION_MAJOR} ${PRIMARY_TEST_DIR}/pg_prove.sh\n    USES_TERMINAL)\n```\n\n----------------------------------------\n\nTITLE: Defining Baseline Coverage Target and Dependencies in CMake\nDESCRIPTION: Creates a custom target named `coverage_base` that depends on the successful generation of the baseline coverage file (`${OUTPUT_FILE}.base`). It then adds `coverage_base` as a dependency to the `installcheck` target, ensuring the baseline coverage data is captured before the tests (run via `installcheck`) are executed.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/codecov/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(coverage_base DEPENDS ${OUTPUT_FILE}.base)\n\n# Ensure baseline file is generated before tests\nadd_dependencies(installcheck coverage_base)\n```\n\n----------------------------------------\n\nTITLE: Defining Custom `licensecheck` Target in CMake\nDESCRIPTION: Defines a custom target named 'licensecheck' using add_custom_target. Running this target (e.g., via 'make licensecheck' or 'ninja licensecheck') executes the shell script 'scripts/check_license_all.sh' located in the project source directory.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_33\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(licensecheck\n                  COMMAND ${PROJECT_SOURCE_DIR}/scripts/check_license_all.sh)\n```\n\nLANGUAGE: Shell\nCODE:\n```\n${PROJECT_SOURCE_DIR}/scripts/check_license_all.sh\n```\n\n----------------------------------------\n\nTITLE: Configuring and Copying Perl Prove Test Files in CMake\nDESCRIPTION: This CMake script defines two lists of Perl test files: `PROVE_TEST_FILES` for standard tests and `PROVE_DEBUG_TEST_FILES` for debug-only tests. It checks if the `CMAKE_BUILD_TYPE` variable matches 'Debug'. If it does, the debug test files are appended to the standard list. Finally, it iterates through the resulting `PROVE_TEST_FILES` list and copies each file to the CMake current binary directory (`CMAKE_CURRENT_BINARY_DIR`) using the `configure_file` command with the `COPYONLY` option. This prepares the test files for execution within the build environment.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/t/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(PROVE_TEST_FILES 001_job_crash_log.pl 002_logrepl_decomp_marker.pl)\n\nset(PROVE_DEBUG_TEST_FILES 003_mvcc_cagg.pl)\n\nif(CMAKE_BUILD_TYPE MATCHES Debug)\n  list(APPEND PROVE_TEST_FILES ${PROVE_DEBUG_TEST_FILES})\nendif(CMAKE_BUILD_TYPE MATCHES Debug)\n\nforeach(P_FILE ${PROVE_TEST_FILES})\n  configure_file(${P_FILE} ${CMAKE_CURRENT_BINARY_DIR}/${P_FILE} COPYONLY)\nendforeach(P_FILE)\n```\n\n----------------------------------------\n\nTITLE: Adding Local Shared Regression Test Target\nDESCRIPTION: Adds a custom target named `regresschecklocal-shared` that executes the `pg_regress.sh` script to run PostgreSQL regression tests for shared modules against a local PostgreSQL instance. It configures specific options for shared module local tests.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(\n    regresschecklocal-shared\n    COMMAND\n      ${CMAKE_COMMAND} -E env ${PG_REGRESS_ENV}\n      EXE_DIR=${CMAKE_CURRENT_SOURCE_DIR}/shared\n      TEST_SCHEDULE=${TEST_SCHEDULE_SHARED} TEST_PGPORT=${TEST_PGPORT_LOCAL}\n      ${PRIMARY_TEST_DIR}/pg_regress.sh ${PG_REGRESS_OPTS_BASE}\n      ${PG_REGRESS_SHARED_OPTS_EXTRA} ${PG_REGRESS_SHARED_OPTS_INOUT}\n      ${PG_REGRESS_OPTS_LOCAL_INSTANCE}\n    USES_TERMINAL)\n```\n\n----------------------------------------\n\nTITLE: Defining Final Coverage Target and Dependencies in CMake\nDESCRIPTION: Creates a custom target `coverage_final` that depends on the generation of the final combined coverage tracefile (`${OUTPUT_FILE}`). It also establishes that `coverage_final` depends on the `coverage_test` target, ensuring the correct order of operations (baseline -> test -> final combination).\nSOURCE: https://github.com/timescale/timescaledb/blob/main/codecov/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(coverage_final DEPENDS ${OUTPUT_FILE})\nadd_dependencies(coverage_final coverage_test)\n```\n\n----------------------------------------\n\nTITLE: Configuring Code Coverage and Downgrade Script\nDESCRIPTION: Configures code coverage, an experimental compatibility check skip and downgrade script generation. Code coverage is optional and turned off by default. The downgrade script generation is controlled by `GENERATE_DOWNGRADE_SCRIPT` and `GENERATE_OLD_DOWNGRADE_SCRIPTS`. The script is required to properly manage different versions.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\n# Code coverage is optional and OFF by default\noption(CODECOVERAGE \"Enable code coverage for the build\" OFF)\noption(EXPERIMENTAL \"Skip postgres version compatibility check\" OFF)\n\n# Generate downgrade script\noption(GENERATE_DOWNGRADE_SCRIPT\n       \"Generate downgrade script. Defaults to not generate a downgrade script.\"\n       OFF)\ncmake_dependent_option(\n  GENERATE_OLD_DOWNGRADE_SCRIPTS\n  \"Generate downgrade scripts for old versions. Requires setting GENERATE_DOWNGRADE_SCRIPT to ON. Defaults to OFF.\"\n  OFF\n  \"GENERATE_DOWNGRADE_SCRIPT\"\n  ON)\n```\n\n----------------------------------------\n\nTITLE: Adding Local Isolation Test Target\nDESCRIPTION: Adds a custom target `isolationchecklocal-t` for running PostgreSQL isolation tests against a local PostgreSQL instance, similar to `isolationcheck-t` but using local instance settings.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/CMakeLists.txt#_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(\n    isolationchecklocal-t\n    COMMAND\n      ${CMAKE_COMMAND} -E env ${PG_ISOLATION_REGRESS_ENV}\n      EXE_DIR=${CMAKE_CURRENT_SOURCE_DIR}\n      SPECS_DIR=${CMAKE_CURRENT_BINARY_DIR}/isolation/specs\n      TEST_PGPORT=${TEST_PGPORT_LOCAL} ${PRIMARY_TEST_DIR}/pg_regress.sh\n      ${PG_REGRESS_OPTS_BASE} ${PG_ISOLATION_REGRESS_OPTS_EXTRA}\n      ${PG_ISOLATION_REGRESS_OPTS_INOUT} ${PG_REGRESS_OPTS_LOCAL_INSTANCE}\n    USES_TERMINAL)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Code Formatting Tools in CMake\nDESCRIPTION: Configures code formatting tools like clang-format, cmake-format, and perltidy. These tools help maintain consistent code style across the TimescaleDB codebase. The configuration checks for tool availability and creates custom targets for running the formatters.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_24\n\nLANGUAGE: CMake\nCODE:\n```\nfind_program(\n  CLANG_FORMAT\n  NAMES clang-format-14 clang-format\n  PATHS /usr/bin /usr/local/bin /usr/local/opt/ /usr/local/opt/llvm/bin /opt/bin\n  DOC \"The path to clang-format\")\n\nif(CLANG_FORMAT)\n  execute_process(\n    COMMAND ${CLANG_FORMAT} --version\n    OUTPUT_VARIABLE CLANG_FORMAT_VERSION_OUTPUT\n    OUTPUT_STRIP_TRAILING_WHITESPACE)\n\n  if(NOT ${CLANG_FORMAT_VERSION_OUTPUT} MATCHES\n     \"version[ ]+([0-9]+)\\\\.([0-9]+)(\\\\.([0-9]+))*\")\n    message(\n      FATAL_ERROR\n        \"Could not parse clang-format version ${CLANG_FORMAT_VERSION_OUTPUT}\")\n  endif()\n\n  if((${CMAKE_MATCH_1} LESS \"14\"))\n    message(WARNING \"clang-format version 14 or greater required\")\n    set(CLANG_FORMAT False)\n  endif()\nendif()\n\nif(CLANG_FORMAT)\n  message(STATUS \"Using local clang-format\")\n  add_custom_target(\n    clang-format COMMAND ${CMAKE_COMMAND} -E env CLANG_FORMAT=${CLANG_FORMAT}\n                         ${PROJECT_SOURCE_DIR}/scripts/clang_format_all.sh)\nendif()\n\nfind_program(\n  CMAKE_FORMAT\n  NAMES cmake-format\n  PATHS /usr/bin /usr/local/bin /usr/local/opt/ /usr/local/opt/llvm/bin /opt/bin\n  DOC \"The path to cmake-format\")\n\nif(CMAKE_FORMAT)\n  add_custom_target(\n    cmake-format COMMAND ${CMAKE_COMMAND} -E env CMAKE_FORMAT=${CMAKE_FORMAT}\n                         ${PROJECT_SOURCE_DIR}/scripts/cmake_format_all.sh)\nendif()\n\nfind_program(\n  PERLTIDY\n  NAMES perltidy\n  PATHS /bin /usr/bin /usr/local/bin /usr/local/opt/ /opt/bin\n  DOC \"The path to perltidy\")\n\nif(PERLTIDY)\n  message(STATUS \"Using perltidy ${PERLTIDY}\")\n  add_custom_target(\n    perltidy\n    COMMAND\n      ${CMAKE_COMMAND} -E env PERLTIDY=${PERLTIDY}\n      PERLTIDY_CONFIG=\"${PROJECT_SOURCE_DIR}/.perltidyrc\"\n      ${PROJECT_SOURCE_DIR}/scripts/perltidy_format_all.sh)\nendif()\n\nif(TARGET clang-format\n   OR TARGET cmake-format\n   OR TARGET perltidy)\n  add_custom_target(format)\n  if(TARGET clang-format)\n    add_dependencies(format clang-format)\n  endif()\n  if(TARGET cmake-format)\n    add_dependencies(format cmake-format)\n  endif()\n  if(TARGET perltidy)\n    add_dependencies(format perltidy)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Define and Attach C Sources to CMake Target\nDESCRIPTION: Uses the CMake `set` command to define a variable `SOURCES` containing a list of C file paths relative to the current source directory. Subsequently, the `target_sources` command is used to add these specified `SOURCES` to a target named by the variable `${TESTS_LIB_NAME}`. This configures the build process to compile these C files for the designated target.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/src/bgw/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/log.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/timer_mock.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/scheduler_mock.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/params.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/test_job_refresh.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/test_job_utils.c)\n\ntarget_sources(${TESTS_LIB_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Enabling Code Coverage Build Options in CMake\nDESCRIPTION: Checks if the CODECOVERAGE option is enabled via a CMake variable. If true, it adds the '--coverage' flag to compiler and linker options and sets the optimization level to '-O0'. This flag typically enables coverage instrumentation for compilers like GCC or Clang.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_30\n\nLANGUAGE: CMake\nCODE:\n```\nif(CODECOVERAGE)\n  message(STATUS \"Code coverage is enabled.\")\n  # Note that --coverage is synonym for the necessary compiler and linker flags\n  # for the given compiler.  For example, with GCC, --coverage translates to\n  # -fprofile-arcs -ftest-coverage when compiling and -lgcov when linking\n  add_compile_options(--coverage -O0)\n  add_link_options(--coverage)\nendif(CODECOVERAGE)\n```\n\n----------------------------------------\n\nTITLE: Set Source Files for Planner - CMake\nDESCRIPTION: This CMake snippet defines a variable named SOURCES and assigns a list of C source files to it. These files represent the source code for different parts of the TimescaleDB planner, such as the main planner logic, aggregation handling, constraint management, and hypertable expansion.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/planner/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/planner.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/add_hashagg.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/agg_bookend.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/constify_now.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/constraint_cleanup.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/expand_hypertable.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/partialize.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/space_constraint.c)\n```\n\n----------------------------------------\n\nTITLE: Generating Test Code Coverage File in CMake\nDESCRIPTION: Defines a custom command to generate the test code coverage file (`${OUTPUT_FILE}.test`). This command runs `lcov` after the tests have been executed (implied by dependency structure). It captures the coverage information generated during the test run. It depends on the baseline file having been generated first.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/codecov/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_command(\n  OUTPUT ${OUTPUT_FILE}.test\n  COMMENT \"Generating code coverage test file\"\n  COMMAND\n    ${LCOV} --rc lcov_branch_coverage=1 --capture --no-external\n    --base-directory ${CMAKE_SOURCE_DIR} --directory ${CMAKE_BINARY_DIR}\n    --output-file ${OUTPUT_FILE}.test --gcov-tool\n    ${CMAKE_CURRENT_BINARY_DIR}/gcov\n  DEPENDS ${OUTPUT_FILE}.base coverage_base)\n```\n\n----------------------------------------\n\nTITLE: Setting Compression Module Source Files in CMake\nDESCRIPTION: Defines a list of source files for the compression module including API, metadata, DML operations, storage, and other compression-related functionality. The files are then added as sources to the TSL library and the algorithms subdirectory is included.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/compression/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/api.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/batch_metadata_builder_minmax.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/compression.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/compression_dml.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/compression_scankey.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/compression_storage.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/create.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/recompress.c)\ntarget_sources(${TSL_LIBRARY_NAME} PRIVATE ${SOURCES})\n\nadd_subdirectory(algorithms)\n```\n\n----------------------------------------\n\nTITLE: Setting Project Install Method and Build Commands\nDESCRIPTION: Sets the install method (source) and enables the generation of compilation database files. The installation method specifies the target platform for the binary being built. Compilation database generation is used for code analysis and IDE integration. These options affect how the project is installed and the available build functionality.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nset(PROJECT_INSTALL_METHOD\n    source\n    CACHE STRING \"Specify what install platform this binary\nis built for\")\nmessage(STATUS \"Install method is '${PROJECT_INSTALL_METHOD}'\")\n\n# Build compilation database by default\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n```\n\n----------------------------------------\n\nTITLE: Configuring Header Files and Dependencies\nDESCRIPTION: This snippet configures the header file generation from `config.h.in` to `config.h`, sets dependencies for the `gitcheck` target, and includes source directories.  It specifies header files to be generated and includes required source directories. The use of `add_dependencies` ensures the git check target runs before the main target.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nconfigure_file(config.h.in config.h)\nadd_dependencies(${PROJECT_NAME} gitcheck)\ninclude_directories(${CMAKE_CURRENT_SOURCE_DIR})\n```\n\n----------------------------------------\n\nTITLE: Setting Telemetry Default\nDESCRIPTION: This snippet configures the default setting for telemetry based on `SEND_TELEMETRY_DEFAULT`.  If `SEND_TELEMETRY_DEFAULT` is true, it sets `TELEMETRY_DEFAULT` to `TELEMETRY_BASIC`; otherwise, it sets `TELEMETRY_DEFAULT` to `TELEMETRY_OFF`. This controls the telemetry functionality of the program and its default behaviour.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif(USE_TELEMETRY)\n  if(SEND_TELEMETRY_DEFAULT)\n    set(TELEMETRY_DEFAULT TELEMETRY_BASIC)\n  else()\n    set(TELEMETRY_DEFAULT TELEMETRY_OFF)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding C Source Files to CMake Target for TimescaleDB\nDESCRIPTION: This snippet uses CMake commands to add specific C source files, 'chunk_dispatch.c' and 'chunk_insert_state.c', located in the current directory, to the build target associated with the project. It ensures that these source files are included when compiling the TimescaleDB extension. Dependencies include CMake version supporting 'target_sources' and the project target variable '${PROJECT_NAME}'.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/nodes/chunk_dispatch/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Add all *.c to sources in upperlevel directory\nset(SOURCES ${CMAKE_CURRENT_SOURCE_DIR}/chunk_dispatch.c\n            ${CMAKE_CURRENT_SOURCE_DIR}/chunk_insert_state.c)\ntarget_sources(${PROJECT_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Adding C Compiler Options\nDESCRIPTION: Adds specific compiler flags based on the detected compiler (GNU, Clang, AppleClang, or MSVC). Adds a set of standard warning flags. Includes checks and specific flags based on compiler features. This is essential for ensuring code quality and portability across different compilers.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_C_COMPILER_ID MATCHES \"GNU|AppleClang|Clang\")\n  # These two flags generate too many errors currently, but we probably want\n  # these optimizations enabled.\n  #\n  # -fdelete-null-pointer-checks -Wnull-dereference\n\n  # This flag avoid some subtle bugs related to standard conversions, but\n  # currently does not compile because we are using too many implicit\n  # conversions that potentially lose precision.\n  #\n  # -Wconversions\n\n  # These flags are supported on all compilers.\n  add_compile_options(\n    -Wempty-body\n    -Wvla\n    -Wall\n    -Wextra\n    # The SQL function arguments macro PG_FUNCTION_ARGS often inroduces unused\n    # arguments.\n    -Wno-unused-parameter\n    -Wundef\n    -Wmissing-prototypes\n    -Wpointer-arith\n    -Werror=vla\n    -Wendif-labels\n    -fno-strict-aliasing\n    -fno-omit-frame-pointer)\n\n  # These flags are just supported on some of the compilers, so we check them\n  # before adding them.\n  check_c_compiler_flag(-Wno-unused-command-line-argument\n                        CC_SUPPORTS_NO_UNUSED_CLI_ARG)\n  if(CC_SUPPORTS_NO_UNUSED_CLI_ARG)\n    add_compile_options(-Wno-unused-command-line-argument)\n  endif()\n\n  check_c_compiler_flag(-Wno-format-truncation CC_SUPPORTS_NO_FORMAT_TRUNCATION)\n  if(CC_SUPPORTS_NO_FORMAT_TRUNCATION)\n    add_compile_options(-Wno-format-truncation)\n  else()\n    message(STATUS \"Compiler does not support -Wno-format-truncation\")\n  endif()\n\n  check_c_compiler_flag(-Wstringop-truncation CC_STRINGOP_TRUNCATION)\n  if(CC_STRINGOP_TRUNCATION)\n    add_compile_options(-Wno-stringop-truncation)\n  else()\n    message(STATUS \"Compiler does not support -Wno-stringop-truncation\")\n  endif()\n\n  check_c_compiler_flag(-Wimplicit-fallthrough CC_SUPPORTS_IMPLICIT_FALLTHROUGH)\n  if(CC_SUPPORTS_IMPLICIT_FALLTHROUGH)\n    add_compile_options(-Wimplicit-fallthrough)\n  else()\n    message(STATUS \"Compiler does not support -Wimplicit-fallthrough\")\n  endif()\n\n  check_c_compiler_flag(-Wnewline-eof CC_SUPPORTS_NEWLINE_EOF)\n  if(CC_SUPPORTS_NEWLINE_EOF)\n    add_compile_options(-Wnewline-eof)\n  endif()\n\n  # strict overflow check produces false positives on gcc < 8\n  if(CMAKE_COMPILER_IS_GNUCC AND CMAKE_C_COMPILER_VERSION VERSION_LESS 8)\n    add_compile_options(-Wno-strict-overflow)\n  endif()\n\n  # -Wclobbered produces false positives on gcc < 9\n  if(CMAKE_COMPILER_IS_GNUCC AND CMAKE_C_COMPILER_VERSION VERSION_LESS 9)\n    add_compile_options(-Wno-clobbered)\n  endif()\n\n  if(CMAKE_COMPILER_IS_GNUCC)\n    add_compile_options(\n      # Seems to be broken in GCC 11 with designated initializers.\n      -Wno-missing-field-initializers)\n  endif()\n\n  # On UNIX, the compiler needs to support -fvisibility=hidden to hide symbols\n  # by default\n  check_c_compiler_flag(-fvisibility=hidden CC_SUPPORTS_VISIBILITY_HIDDEN)\n\n  if(NOT CC_SUPPORTS_VISIBILITY_HIDDEN)\n    message(\n      FATAL_ERROR\n        \"The compiler ${CMAKE_C_COMPILER_ID} does not support -fvisibility=hidden\"\n    )\n  endif(NOT CC_SUPPORTS_VISIBILITY_HIDDEN)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Source Files and Subdirectories to a CMake Target\nDESCRIPTION: This CMake snippet includes the 'function' and 'hashing' subdirectories in the build process. It defines a list of C source files related to query execution, grouping policies, and planning, and adds them as private sources to the CMake target specified by the TSL_LIBRARY_NAME variable. Assumes TSL_LIBRARY_NAME is defined previously.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/nodes/vector_agg/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(function)\nadd_subdirectory(hashing)\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/exec.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/grouping_policy_batch.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/grouping_policy_hash.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/plan.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/plan_decompress_chunk.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/plan_tam.c)\ntarget_sources(${TSL_LIBRARY_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Creating installcheck Target\nDESCRIPTION: Defines a custom target `installcheck-t` that depends on all the targets accumulated in the `_install_checks` list. Then sets dependency for installcheck target to installcheck-t target.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/CMakeLists.txt#_snippet_15\n\nLANGUAGE: cmake\nCODE:\n```\nif(_install_checks)\n  add_custom_target(installcheck-t DEPENDS ${_install_checks})\n  add_dependencies(installcheck installcheck-t)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories for Test Library in CMake\nDESCRIPTION: This snippet defines the include directories for the test library using `target_include_directories()`. It adds private include paths for the test source directory (`${CMAKE_SOURCE_DIR}/test/src`) and the PostgreSQL include directory (`${PG_INCLUDEDIR}`). These directories are used during compilation to locate header files required by the test source code. This is necessary for successful compilation of the test library.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/src/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${TSL_TESTS_LIB_NAME}\n                           PRIVATE ${CMAKE_SOURCE_DIR}/test/src)\ntarget_include_directories(${TSL_TESTS_LIB_NAME} PRIVATE ${PG_INCLUDEDIR})\n```\n\n----------------------------------------\n\nTITLE: Linking the TSL Library against PostgreSQL in CMake\nDESCRIPTION: Links the TSL library target against the PostgreSQL client library (`libpq`). It conditionally links against `${PG_LIBDIR}/libpq.lib` on Windows (`WIN32`) and `pq` (which resolves to `libpq.so` or similar) on other platforms like Linux or macOS.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nif(WIN32)\n  target_link_libraries(${TSL_LIBRARY_NAME} ${PG_LIBDIR}/libpq.lib)\nelse()\n  target_link_libraries(${TSL_LIBRARY_NAME} pq)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Gapfill C Source Files in TimescaleDB with CMake - CMake\nDESCRIPTION: This CMake snippet sets up a list of C source files related to the gapfill functionality in TimescaleDB, including modules for gapfill execution, planning, interpolation, and LOCF. It then attaches these files as private sources to a specified library target using the target_sources command. Dependencies include a correct CMake environment and the visibility of the TSL_LIBRARY_NAME variable, and the expectation is that all listed C files exist within the specified directory structure. Input: defined C source file paths. Output: registration of these sources in the library build process. This configuration is required for correct compilation and linkage of the TimescaleDB extension's gapfill logic.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/nodes/gapfill/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/gapfill_functions.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/gapfill_plan.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/gapfill_exec.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/locf.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/interpolate.c)\ntarget_sources(${TSL_LIBRARY_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Adding C Test Source Files to CMake Target\nDESCRIPTION: This CMake snippet sets a variable `SOURCES` with the paths to `test_privacy.c` and `test_telemetry.c` located in the current source directory. It then uses `target_sources` to add these files as private sources to the CMake target specified by the `${TESTS_LIB_NAME}` variable, ensuring they are compiled into the library but not exposed publicly.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/src/telemetry/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(SOURCES ${CMAKE_CURRENT_SOURCE_DIR}/test_privacy.c\n            ${CMAKE_CURRENT_SOURCE_DIR}/test_telemetry.c)\n\ntarget_sources(${TESTS_LIB_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Link Source Files to Project - CMake\nDESCRIPTION: This CMake snippet uses the target_sources command to link the previously defined SOURCES variable to the TimescaleDB project (specified by ${PROJECT_NAME}).  The PRIVATE keyword indicates that these sources are only used to build the target and are not exposed to other dependent projects.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/planner/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Configuring C Source Files for TimescaleDB Using CMake\nDESCRIPTION: This CMake code snippet defines a list of C source files related to various functionalities such as array operations, data serialization, delta encoding, and compression. It then adds these sources to the target library specified by ${TSL_LIBRARY_NAME} as private dependencies, facilitating modular build configuration and dependency management within the TimescaleDB project.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/compression/algorithms/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/array.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/datum_serialize.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/deltadelta.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/dictionary.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/gorilla.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/bool_compress.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/null.c)\n```\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${TSL_LIBRARY_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Configuring Source Files and Target for TimescaleDB TSL Library in CMake\nDESCRIPTION: Defines the source files to be compiled into the TimescaleDB TSL library and configures the target with appropriate include directories. The source files include implementations for various TimescaleDB features like compression, continuous aggregates, jobs, policies, and data management utilities.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/src/bgw_policy/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    ${CMAKE_CURRENT_SOURCE_DIR}/compression_api.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/continuous_aggregate_api.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/job.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/job_api.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/reorder_api.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/retention_api.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/policy_utils.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/policies_v2.c)\ntarget_sources(${TSL_LIBRARY_NAME} PRIVATE ${SOURCES})\ntarget_include_directories(${TSL_LIBRARY_NAME} PRIVATE ${CMAKE_SOURCE_DIR})\n```\n\n----------------------------------------\n\nTITLE: Defining Test Sources in CMake\nDESCRIPTION: This snippet defines the source files for the test library using the `set()` command. It specifies a list of C source files, including files for chunk statistics, merging, compression, decompression, continuous aggregates, and hypercore tests. This list of files is then used later to create an object library.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/src/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    test_chunk_stats.c\n    test_merge_chunk.c\n    compression_unit_test.c\n    compression_sql_test.c\n    decompress_text_test_impl.c\n    test_continuous_agg.c\n    test_hypercore.c)\n```\n\n----------------------------------------\n\nTITLE: Coccinelle Block Header Example\nDESCRIPTION: This code snippet demonstrates the basic structure of a Coccinelle block header, including variable definitions. The header starts with `@ name @` followed by optional variable declarations like `Expression var1;` and `Expression var2;`.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/coccinelle/README.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n@ name @\nExpression var1;\nExpression var2;\n@@\n```\n\n----------------------------------------\n\nTITLE: Suppressing getaddrinfo Function via Interceptor Configuration\nDESCRIPTION: This configuration line uses the `interceptor_via_fun` directive to target and suppress the `getaddrinfo` system call. As noted in the associated comment ('#suppress getaddrinfo due to internal error on macos'), this is specifically implemented to prevent internal errors linked to this function when running on macOS.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/scripts/suppressions/suppr_asan.txt#_snippet_0\n\nLANGUAGE: Configuration\nCODE:\n```\n#suppress getaddrinfo due to internal error on macos\ninterceptor_via_fun:getaddrinfo\n```\n\n----------------------------------------\n\nTITLE: Reference to params.c and params.h for configuration details in C\nDESCRIPTION: Indicates that 'params.c' and 'params.h' files contain further details on the management of shared memory configuration and parameters used for background worker testing.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/src/bgw/README.md#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\n// Consult params.c and params.h for implementation and structure of configuration parameters\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories\nDESCRIPTION: This snippet adds multiple subdirectories to the build process, effectively incorporating various modules or components of TimescaleDB. The build system then processes the CMakeLists.txt files within these subdirectories, expanding the build process to include more features. This enhances the build by including other components.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(bgw)\nadd_subdirectory(net)\nif(USE_TELEMETRY)\n  add_subdirectory(telemetry)\nendif()\nadd_subdirectory(loader)\nadd_subdirectory(bgw_policy)\nadd_subdirectory(compat)\nadd_subdirectory(ts_catalog)\nadd_subdirectory(import)\nadd_subdirectory(nodes)\nadd_subdirectory(planner)\nadd_subdirectory(with_clause)\n```\n\n----------------------------------------\n\nTITLE: Reference to detailed implementation in log.c for background worker logging\nDESCRIPTION: Mentions that detailed logic for background worker logging resides in 'log.c', which manages how log messages are captured and stored during testing.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/src/bgw/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n// See log.c for detailed implementation of background worker logging functions\n```\n\n----------------------------------------\n\nTITLE: Appending Regression Checks to Lists\nDESCRIPTION: Appends the names of the newly created custom targets, `regresschecklocal-t` and `regresscheck-t`, to the `_local_install_checks` and `_install_checks` lists respectively. This ensures these targets will be run during installation checks.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/tsl/test/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND _local_install_checks regresschecklocal-t)\nlist(APPEND _install_checks regresscheck-t)\n```\n\n----------------------------------------\n\nTITLE: Configuring Private Sources in CMake for TimescaleDB\nDESCRIPTION: This snippet sets the SOURCES variable (currently empty) and assigns those source files as private target sources for the TimescaleDB project. It requires CMake as a build-system generator and assumes the PROJECT_NAME variable is defined and corresponds to a valid CMake target. It is typically used in the project's build configuration to organize source files and control their visibility during compilation. Since SOURCES is empty, no files are currently added.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/src/compat/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES)\n\ntarget_sources(${PROJECT_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Setting extSchema Variable\nDESCRIPTION: Sets the `extschema` variable to \"@extschema@\". This variable likely represents the schema name for the extension. This ensures proper configuration during the build process by making sure that the appropriate schema name can be utilized.  This helps avoid potential conflicts when updating or downgrading.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\n# a hack to avoid change of SQL extschema variable\nset(extschema \"@extschema@\")\n```\n\n----------------------------------------\n\nTITLE: Reference to timer_mock.c for timer mock detailed implementation\nDESCRIPTION: Indicates that 'timer_mock.c' contains the complete implementation of the virtual timer, including functions for initializing, reading, waiting, and resetting the timer during tests.\nSOURCE: https://github.com/timescale/timescaledb/blob/main/test/src/bgw/README.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\n// See timer_mock.c for full implementation of the virtualized timer\n```"
  }
]