[
  {
    "owner": "rileylemm",
    "repo": "graphrag-hybrid",
    "content": "TITLE: Implementing DocumentationGPTTool Class with Neo4j and Qdrant Integration in Python\nDESCRIPTION: A comprehensive implementation of a documentation search tool that combines vector similarity search using Qdrant with graph-based document relationships in Neo4j. The class handles database connections, embedding generation, and hybrid search functionality with error handling and version compatibility.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/index.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom typing import Dict, List, Optional, Any, Union\nfrom neo4j import GraphDatabase\nfrom qdrant_client import QdrantClient\nfrom sentence_transformers import SentenceTransformer\n\nclass DocumentationGPTTool:\n    \"\"\"MCP Tool for querying the GraphRAG documentation system.\"\"\"\n    \n    def __init__(self):\n        # Neo4j connection\n        self.neo4j_uri = os.getenv(\"NEO4J_URI\", \"bolt://localhost:7687\")\n        self.neo4j_user = os.getenv(\"NEO4J_USER\", \"neo4j\")\n        self.neo4j_password = os.getenv(\"NEO4J_PASSWORD\", \"password\")\n        self.neo4j_driver = None\n        \n        # Qdrant connection\n        self.qdrant_host = os.getenv(\"QDRANT_HOST\", \"localhost\")\n        self.qdrant_port = int(os.getenv(\"QDRANT_PORT\", \"6333\"))\n        self.qdrant_collection = os.getenv(\"QDRANT_COLLECTION\", \"document_chunks\")\n        self.qdrant_client = None\n        \n        # Embedding model\n        self.model_name = \"all-MiniLM-L6-v2\"\n        self.model = None\n        \n        # Initialize connections\n        self._connect()\n    \n    def _connect(self):\n        \"\"\"Establish connections to Neo4j and Qdrant.\"\"\"\n        # Connect to Neo4j\n        try:\n            self.neo4j_driver = GraphDatabase.driver(\n                self.neo4j_uri, \n                auth=(self.neo4j_user, self.neo4j_password)\n            )\n            # Test connection\n            with self.neo4j_driver.session() as session:\n                result = session.run(\"MATCH (d:Document) RETURN count(d) AS count\")\n                record = result.single()\n                print(f\"Connected to Neo4j with {record['count']} documents\")\n        except Exception as e:\n            print(f\"Neo4j connection error: {e}\")\n        \n        # Connect to Qdrant\n        try:\n            # Handle potential version compatibility issues\n            try:\n                self.qdrant_client = QdrantClient(host=self.qdrant_host, port=self.qdrant_port)\n                collection_info = self.qdrant_client.get_collection(self.qdrant_collection)\n                \n                # Check for vectors count based on client version\n                vectors_count = 0\n                if hasattr(collection_info, 'vectors_count'):\n                    vectors_count = collection_info.vectors_count\n                elif hasattr(collection_info, 'points_count'):\n                    vectors_count = collection_info.points_count\n                else:\n                    # Try to navigate the config structure based on observed variations\n                    try:\n                        if hasattr(collection_info.config, 'params'):\n                            if hasattr(collection_info.config.params, 'vectors'):\n                                vectors_count = collection_info.config.params.vectors.size\n                    except:\n                        pass\n                \n                print(f\"Connected to Qdrant collection '{self.qdrant_collection}' with {vectors_count} vectors\")\n            except Exception as e:\n                print(f\"Qdrant connection warning: {e}\")\n                # Fallback for older versions if needed\n        except Exception as e:\n            print(f\"Qdrant connection error: {e}\")\n        \n        # Load the embedding model\n        try:\n            self.model = SentenceTransformer(self.model_name)\n            print(f\"Loaded embedding model: {self.model_name}\")\n        except Exception as e:\n            print(f\"Error loading embedding model: {e}\")\n    \n    def search_documentation(self, query: str, limit: int = 5, category: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Search for documentation using semantic search and optionally expand with graph context.\n        \n        Args:\n            query: The search query\n            limit: Maximum number of results to return\n            category: Optional category filter\n            \n        Returns:\n            Dictionary with search results and related documents\n        \"\"\"\n        results = {\n            \"query\": query,\n            \"chunks\": [],\n            \"related_documents\": []\n        }\n        \n        # Generate embedding for query\n        if self.model is None:\n            try:\n                self.model = SentenceTransformer(self.model_name)\n            except Exception as e:\n                results[\"error\"] = f\"Failed to load embedding model: {e}\"\n                return results\n        \n        query_embedding = self.model.encode(query)\n        \n        # Search Qdrant\n        try:\n            # Handle version compatibility issues with the search API\n            try:\n                # Newer versions use query_vector\n                search_result = self.qdrant_client.search(\n                    collection_name=self.qdrant_collection,\n                    query_vector=query_embedding.tolist(),\n                    limit=limit\n                )\n            except TypeError:\n                # Fall back to older versions using vector parameter\n                search_result = self.qdrant_client.search(\n                    collection_name=self.qdrant_collection,\n                    vector=query_embedding.tolist(),\n                    limit=limit\n                )\n                \n            # Add search results to response\n            for result in search_result:\n                # Extract ID and score\n                chunk_id = result.id\n                score = result.score\n                \n                # Get text content from payload\n                text = \"\"\n                if hasattr(result, 'payload') and 'text' in result.payload:\n                    text = result.payload['text']\n                \n                results[\"chunks\"].append({\n                    \"chunk_id\": chunk_id,\n                    \"text\": text,\n                    \"score\": score\n                })\n        except Exception as e:\n            results[\"error\"] = f\"Qdrant search error: {e}\"\n        \n        # Expand with related documents from Neo4j\n        if self.neo4j_driver and len(results[\"chunks\"]) > 0:\n            try:\n                with self.neo4j_driver.session() as session:\n                    # Build a query to find documents containing these chunks\n                    # and their related documents\n                    chunk_ids = [chunk[\"chunk_id\"] for chunk in results[\"chunks\"]]\n                    \n                    cypher_query = \"\"\"\n                    MATCH (c:Chunk) \n                    WHERE c.id IN $chunk_ids\n                    MATCH (c)-[:PART_OF]->(d:Document)\n                    OPTIONAL MATCH (d)-[:RELATED_TO]->(related:Document)\n                    WITH DISTINCT d, related\n                    RETURN d.id as doc_id, d.title as title, \n                           collect(DISTINCT {doc_id: related.id, title: related.title}) as related_docs\n                    \"\"\"\n                    \n                    if category:\n                        cypher_query = \"\"\"\n                        MATCH (c:Chunk) \n                        WHERE c.id IN $chunk_ids\n                        MATCH (c)-[:PART_OF]->(d:Document)-[:HAS_CATEGORY]->(cat:Category {name: $category})\n                        OPTIONAL MATCH (d)-[:RELATED_TO]->(related:Document)\n                        WITH DISTINCT d, related\n                        RETURN d.id as doc_id, d.title as title, \n                               collect(DISTINCT {doc_id: related.id, title: related.title}) as related_docs\n                        \"\"\"\n                    \n                    result = session.run(cypher_query, chunk_ids=chunk_ids, category=category)\n                    \n                    # Process results\n                    related_docs = set()\n                    for record in result:\n                        doc_id = record[\"doc_id\"]\n                        title = record[\"title\"]\n                        \n                        # Add the document itself\n                        results[\"related_documents\"].append({\n                            \"doc_id\": doc_id,\n                            \"title\": title\n                        })\n                        \n                        # Add related documents\n                        for related in record[\"related_docs\"]:\n                            if related[\"doc_id\"] not in related_docs:\n                                related_docs.add(related[\"doc_id\"])\n                                results[\"related_documents\"].append({\n                                    \"doc_id\": related[\"doc_id\"],\n                                    \"title\": related[\"title\"]\n                                })\n                                \n                                # Limit the number of related documents\n                                if len(related_docs) >= limit:\n                                    break\n                        \n            except Exception as e:\n                results[\"error\"] = f\"Neo4j query error: {e}\"\n        \n        return results\n```\n\n----------------------------------------\n\nTITLE: Importing Documents into GraphRAG\nDESCRIPTION: Command to import documents into the GraphRAG system. This processes Markdown files, extracts metadata, chunks documents, and stores data in Neo4j and Qdrant.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython scripts/import_docs.py --docs-dir ./your_docs_here --recursive\n```\n\n----------------------------------------\n\nTITLE: Running Queries with GraphRAG Demo Script\nDESCRIPTION: Examples of using the query demo script to perform various types of searches and retrieve information from the GraphRAG system.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/README.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Hybrid search\npython scripts/query_demo.py --query \"What is GraphRAG?\" --type hybrid --limit 5\n\n# Category search\npython scripts/query_demo.py --query \"documentation\" --type category --category \"user-guide\"\n\n# Get document by ID\npython scripts/query_demo.py --document \"doc_123456\"\n\n# List all categories\npython scripts/query_demo.py --list-categories\n\n# Show system statistics\npython scripts/query_demo.py --stats\n```\n\n----------------------------------------\n\nTITLE: GraphRAG Example Runner Implementation\nDESCRIPTION: Demonstrates how to run multiple GraphRAG examples using asyncio, including basic search, category search, and system health checks.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/examples.md#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nasync def main():\n    # Basic search\n    await basic_search()\n    \n    # Category search\n    await category_search()\n    \n    # Health check\n    await system_health_check()\n    \nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing GraphRAG Query Class in Python\nDESCRIPTION: Defines a GraphRAGQuery class that handles query embedding generation, Qdrant vector search, Neo4j context expansion, and result ranking. It includes methods for each step of the query process and combines results from both databases.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/query.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import List, Dict, Any\nimport numpy as np\nfrom sentence_transformers import SentenceTransformer\n\nclass GraphRAGQuery:\n    def __init__(self, manager, model_name=\"all-MiniLM-L6-v2\"):\n        self.manager = manager\n        self.embedding_model = SentenceTransformer(model_name)\n        \n    def generate_embedding(self, text: str) -> np.ndarray:\n        \"\"\"Generate embedding vector for query text.\"\"\"\n        return self.embedding_model.encode(text)\n        \n    async def search(self, query: str, limit: int = 5) -> List[Dict[Any, Any]]:\n        \"\"\"Perform hybrid search using both Qdrant and Neo4j.\"\"\"\n        # Generate query embedding\n        query_vector = self.generate_embedding(query)\n        \n        # Search Qdrant\n        qdrant_results = self.search_qdrant(query_vector, limit)\n        \n        # Get related documents from Neo4j\n        neo4j_results = self.expand_context(qdrant_results)\n        \n        # Combine and rank results\n        final_results = self.rank_results(query, qdrant_results, neo4j_results)\n        \n        return final_results\n        \n    def search_qdrant(self, query_vector: np.ndarray, limit: int) -> List[Dict[Any, Any]]:\n        \"\"\"Search Qdrant for similar vectors.\"\"\"\n        try:\n            results = self.manager.qdrant.client.search(\n                collection_name=self.manager.collection_name,\n                query_vector=query_vector.tolist(),\n                limit=limit\n            )\n            return [\n                {\n                    'doc_id': hit.payload.get('doc_id'),\n                    'score': hit.score,\n                    'category': hit.payload.get('category')\n                }\n                for hit in results\n            ]\n        except Exception as e:\n            print(f\"Qdrant search error: {str(e)}\")\n            return []\n            \n    def expand_context(self, qdrant_results: List[Dict[Any, Any]]) -> List[Dict[Any, Any]]:\n        \"\"\"Get related documents from Neo4j.\"\"\"\n        doc_ids = [result['doc_id'] for result in qdrant_results]\n        \n        try:\n            with self.manager.neo4j.driver.session() as session:\n                query = \"\"\"\n                MATCH (d:Document)\n                WHERE d.doc_id IN $doc_ids\n                OPTIONAL MATCH (d)-[r]-(related)\n                RETURN d.doc_id as doc_id,\n                       d.title as title,\n                       d.content as content,\n                       collect(DISTINCT {\n                           type: type(r),\n                           doc_id: related.doc_id,\n                           title: related.title\n                       }) as related_docs\n                \"\"\"\n                result = session.run(query, doc_ids=doc_ids)\n                return [dict(record) for record in result]\n        except Exception as e:\n            print(f\"Neo4j query error: {str(e)}\")\n            return []\n            \n    def rank_results(self, query: str, \n                    qdrant_results: List[Dict[Any, Any]], \n                    neo4j_results: List[Dict[Any, Any]]) -> List[Dict[Any, Any]]:\n        \"\"\"Combine and rank results from both databases.\"\"\"\n        # Create a mapping of doc_ids to Neo4j results\n        neo4j_map = {doc['doc_id']: doc for doc in neo4j_results}\n        \n        # Combine results\n        ranked_results = []\n        for qdrant_hit in qdrant_results:\n            doc_id = qdrant_hit['doc_id']\n            if doc_id in neo4j_map:\n                neo4j_doc = neo4j_map[doc_id]\n                ranked_results.append({\n                    'doc_id': doc_id,\n                    'title': neo4j_doc['title'],\n                    'content': neo4j_doc['content'],\n                    'score': qdrant_hit['score'],\n                    'category': qdrant_hit['category'],\n                    'related_docs': neo4j_doc['related_docs']\n                })\n                \n        return ranked_results\n```\n\n----------------------------------------\n\nTITLE: Testing Database Connections in Python\nDESCRIPTION: Implementation of connection testing for Neo4j and Qdrant databases. Includes logging configuration, error handling, and status reporting for both database connections.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/testing.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport logging\nfrom neo4j import GraphDatabase\nfrom qdrant_client import QdrantClient\nimport warnings\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Suppress Qdrant version warnings\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"qdrant_client\")\n\ndef test_neo4j_connection():\n    \"\"\"Test connection to Neo4j with the verified port\"\"\"\n    logger.info(\"Testing Neo4j connection...\")\n    \n    \n    uri = \"bolt://localhost:7687\"\n    username = \"neo4j\"\n    password = \"password\"\n    \n    try:\n        driver = GraphDatabase.driver(uri, auth=(username, password))\n        with driver.session() as session:\n            result = session.run(\"RETURN 'Neo4j connection successful' as message\")\n            logger.info(result.single()[\"message\"])\n            \n            # Count nodes\n            count = session.run(\"MATCH (n) RETURN count(n) as count\").single()[\"count\"]\n            logger.info(f\"Neo4j database contains {count} nodes\")\n        driver.close()\n        return True\n    except Exception as e:\n        logger.error(f\"Neo4j connection failed: {e}\")\n        return False\n\ndef test_qdrant_connection():\n    \"\"\"Test connection to Qdrant with the verified port\"\"\"\n    logger.info(\"Testing Qdrant connection...\")\n    \n    # Use the verified non-standard port\n    try:\n        client = QdrantClient(host=\"localhost\", port=6333)\n        # Check if Qdrant is running by making a simple API call\n        status = client.get_collections()\n        logger.info(f\"Qdrant connection successful. Collections: {len(status.collections)}\")\n        \n        # Check document_chunks collection\n        if any(c.name == \"document_chunks\" for c in status.collections):\n            collection_info = client.get_collection(\"document_chunks\")\n            logger.info(f\"document_chunks collection info: {collection_info}\")\n            \n            # Get vector count\n            try:\n                vectors_count = collection_info.vectors_count\n                logger.info(f\"Collection contains {vectors_count} vectors\")\n            except AttributeError:\n                # Try alternative attribute names for different Qdrant versions\n                if hasattr(collection_info, \"vectors_count\"):\n                    logger.info(f\"Collection contains {collection_info.vectors_count} vectors\")\n                elif hasattr(collection_info, \"points_count\"):\n                    logger.info(f\"Collection contains {collection_info.points_count} vectors\")\n                else:\n                    logger.warning(\"Could not determine vector count - check Qdrant version compatibility\")\n                    \n        return True\n    except Exception as e:\n        logger.error(f\"Qdrant connection failed: {e}\")\n        return False\n\ndef main():\n    \"\"\"Run all connection tests\"\"\"\n    logger.info(\"Starting connection tests...\")\n    \n    neo4j_success = test_neo4j_connection()\n    qdrant_success = test_qdrant_connection()\n    \n    if neo4j_success and qdrant_success:\n        logger.info(\"\\n✅ All database connections successful!\")\n    else:\n        logger.error(\"\\n❌ Some connections failed. Please check the logs above.\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n----------------------------------------\n\nTITLE: Custom Result Ranking in GraphRAG\nDESCRIPTION: Implements a custom ranking system for GraphRAG search results, allowing weighted scoring based on multiple factors including similarity, related documents, and categories.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/examples.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom graphrag import GraphRAGTool\nfrom typing import List, Dict, Any\n\nclass CustomRankedSearch:\n    def __init__(self):\n        self.tool = GraphRAGTool()\n        \n    def rank_results(self, results: List[Dict[Any, Any]], \n                    weights: Dict[str, float]) -> List[Dict[Any, Any]]:\n        \"\"\"Custom ranking function.\"\"\"\n        for result in results:\n            # Calculate weighted score\n            score = result['score'] * weights.get('similarity', 1.0)\n            \n            # Adjust score based on related documents\n            related_count = len(result['related_docs'])\n            score += related_count * weights.get('relations', 0.1)\n            \n            # Adjust score based on category\n            if result['category'] == weights.get('preferred_category'):\n                score *= weights.get('category_boost', 1.2)\n                \n            result['adjusted_score'] = score\n            \n        # Sort by adjusted score\n        return sorted(results, key=lambda x: x['adjusted_score'], reverse=True)\n        \n    async def search(self, query: str, weights: Dict[str, float]):\n        try:\n            # Execute basic search\n            response = await self.tool.execute(query=query, limit=10)\n            \n            if response['status'] == 'success':\n                # Apply custom ranking\n                ranked_results = self.rank_results(\n                    response['results'],\n                    weights\n                )\n                return {\n                    'status': 'success',\n                    'results': ranked_results[:5]  # Return top 5\n                }\n            return response\n        finally:\n            self.tool.cleanup()\n\n# Usage example\nweights = {\n    'similarity': 1.0,      # Base similarity score weight\n    'relations': 0.1,       # Weight for related documents\n    'category_boost': 1.2,  # Boost for preferred category\n    'preferred_category': 'setup'\n}\n\nsearcher = CustomRankedSearch()\nresults = await searcher.search(\n    \"Database configuration\",\n    weights\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Hybrid Search with Vector and Graph-Based Relevance\nDESCRIPTION: Advanced implementation of a hybrid search function that combines vector similarity search with graph-based context expansion using Neo4j. Includes error handling and optional context expansion.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/index.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef hybrid_search(self, query: str, limit: int = 5, category: Optional[str] = None, \n                  expand_context: bool = True) -> Dict[str, Any]:\n    \"\"\"\n    Perform hybrid search using both vector similarity and graph context.\n    \n    Args:\n        query: Search query\n        limit: Maximum results\n        category: Optional category filter\n        expand_context: Whether to expand results with graph context\n        \n    Returns:\n        Combined search results\n    \"\"\"\n    # Get vector search results\n    vector_results = self.search_documentation(query, limit=limit*2, category=category)\n    \n    # If we don't want expanded context, return vector results\n    if not expand_context:\n        return vector_results\n    \n    # Extract document IDs from vector results\n    doc_ids = [doc[\"doc_id\"] for doc in vector_results.get(\"related_documents\", [])]\n    \n    # Expand with graph context\n    try:\n        with self.neo4j_driver.session() as session:\n            cypher_query = \"\"\"\n            MATCH (d:Document)\n            WHERE d.id IN $doc_ids\n            OPTIONAL MATCH (d)-[:RELATED_TO*1..2]->(related:Document)\n            WITH related, d\n            WHERE related IS NOT NULL AND related.id NOT IN $doc_ids\n            RETURN DISTINCT related.id as doc_id, related.title as title,\n                   count(*) as relevance_score\n            ORDER BY relevance_score DESC\n            LIMIT $limit\n            \"\"\"\n            \n            result = session.run(cypher_query, doc_ids=doc_ids, limit=limit)\n            \n            # Add expanded results\n            for record in result:\n                vector_results[\"related_documents\"].append({\n                    \"doc_id\": record[\"doc_id\"],\n                    \"title\": record[\"title\"],\n                    \"graph_score\": record[\"relevance_score\"]\n                })\n    except Exception as e:\n        vector_results[\"error\"] = f\"Graph expansion error: {e}\"\n    \n    return vector_results\n```\n\n----------------------------------------\n\nTITLE: Neo4j Connection with Error Handling\nDESCRIPTION: Advanced Neo4j connection implementation with retry logic, error handling for different scenarios, and exponential backoff.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/connection.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j import GraphDatabase\nfrom neo4j.exceptions import ServiceUnavailable, AuthError\n\ndef connect_to_neo4j(uri, user, password, max_retries=3):\n    \"\"\"Connect to Neo4j with retry logic and error handling.\"\"\"\n    retry_count = 0\n    \n    while retry_count < max_retries:\n        try:\n            driver = GraphDatabase.driver(uri, auth=(user, password))\n            \n            # Verify connection\n            with driver.session() as session:\n                result = session.run(\"RETURN 1 AS test\")\n                result.single()\n                \n            print(f\"✅ Successfully connected to Neo4j at {uri}\")\n            return driver\n            \n        except ServiceUnavailable as e:\n            retry_count += 1\n            wait_time = 2 ** retry_count  # Exponential backoff\n            print(f\"❌ Neo4j connection failed (attempt {retry_count}/{max_retries}): {e}\")\n            print(f\"   Retrying in {wait_time} seconds...\")\n            time.sleep(wait_time)\n            \n        except AuthError as e:\n            print(f\"❌ Neo4j authentication failed: {e}\")\n            print(\"   Please check username and password.\")\n            break\n            \n        except Exception as e:\n            print(f\"❌ Unexpected error connecting to Neo4j: {e}\")\n            break\n    \n    if retry_count >= max_retries:\n        print(f\"❌ Failed to connect to Neo4j after {max_retries} attempts\")\n    \n    return None\n```\n\n----------------------------------------\n\nTITLE: Implementing Retry Logic with Connection Manager\nDESCRIPTION: Asynchronous connection manager that implements retry logic for failed operations. Includes configurable retry attempts and delay between retries.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/error_handling.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass ConnectionManager:\n    def __init__(self, max_retries: int = 3, retry_delay: float = 1.0):\n        self.max_retries = max_retries\n        self.retry_delay = retry_delay\n        \n    async def with_retry(self, func, *args, **kwargs):\n        \"\"\"Execute function with retry logic.\"\"\"\n        for attempt in range(self.max_retries):\n            try:\n                return await func(*args, **kwargs)\n            except Exception as e:\n                if attempt == self.max_retries - 1:\n                    raise e\n                print(f\"Attempt {attempt + 1} failed: {str(e)}\")\n                await asyncio.sleep(self.retry_delay)\n```\n\n----------------------------------------\n\nTITLE: Initializing GraphRAG Connection Manager Class in Python\nDESCRIPTION: Primary class implementation for managing Neo4j and Qdrant database connections with retry logic and environment variable configuration. Includes methods for connection establishment, verification, and closure.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/connection.md#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass GraphRAGConnectionManager:\n    \"\"\"Manager for connections to Neo4j and Qdrant databases.\"\"\"\n    \n    def __init__(self):\n        # Neo4j connection parameters\n        self.neo4j_uri = os.getenv(\"NEO4J_URI\", \"bolt://localhost:7688\")\n        self.neo4j_user = os.getenv(\"NEO4J_USER\", \"neo4j\")\n        self.neo4j_password = os.getenv(\"NEO4J_PASSWORD\", \"password\")\n        self.neo4j_driver = None\n        \n        # Qdrant connection parameters\n        self.qdrant_host = os.getenv(\"QDRANT_HOST\", \"localhost\")\n        self.qdrant_port = int(os.getenv(\"QDRANT_PORT\", \"6335\"))\n        self.qdrant_collection = os.getenv(\"QDRANT_COLLECTION\", \"document_chunks\")\n        self.qdrant_client = None\n        \n        # Embedding model\n        self.model_name = \"all-MiniLM-L6-v2\"\n        self.model = None\n```\n\n----------------------------------------\n\nTITLE: Error Logging System Implementation\nDESCRIPTION: Implements a comprehensive error logging system with context tracking and formatted output. Uses Python's logging module with customizable log levels and file output.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/error_handling.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport logging\nfrom datetime import datetime\n\nclass ErrorLogger:\n    def __init__(self, log_file: str = \"graphrag_errors.log\"):\n        logging.basicConfig(\n            filename=log_file,\n            level=logging.ERROR,\n            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n        )\n        self.logger = logging.getLogger(\"GraphRAG\")\n        \n    def log_error(self, error: Exception, context: Dict[str, Any] = None):\n        \"\"\"Log error with context information.\"\"\"\n        error_info = {\n            'timestamp': datetime.utcnow().isoformat(),\n            'error_type': type(error).__name__,\n            'error_message': str(error),\n            'context': context or {}\n        }\n        self.logger.error(error_info)\n```\n\n----------------------------------------\n\nTITLE: Implementing GraphRAG as an MCP Tool in Python\nDESCRIPTION: Creates a GraphRAGTool class that extends BaseTool for integration with the MCP framework. It initializes the GraphRAG manager and query engine, and provides methods for executing searches and cleaning up resources.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/query.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional, Dict, Any\nfrom mcp.tools import BaseTool\n\nclass GraphRAGTool(BaseTool):\n    name = \"GraphRAG\"\n    description = \"Search through documents using hybrid Neo4j and Qdrant search\"\n    \n    def __init__(self):\n        super().__init__()\n        self.manager = GraphRAGManager(\n            neo4j_uri=NEO4J_URI,\n            neo4j_user=NEO4J_USER,\n            neo4j_password=NEO4J_PASSWORD,\n            qdrant_host=QDRANT_HOST,\n            qdrant_port=QDRANT_PORT,\n            collection_name=QDRANT_COLLECTION\n        )\n        self.query_engine = GraphRAGQuery(self.manager)\n        \n    async def execute(self, query: str, \n                     limit: Optional[int] = 5,\n                     category: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"Execute a search query.\"\"\"\n        try:\n            results = await self.query_engine.search(query, limit)\n            \n            # Filter by category if specified\n            if category:\n                results = [r for r in results if r['category'] == category]\n                \n            return {\n                'status': 'success',\n                'results': results,\n                'count': len(results)\n            }\n        except Exception as e:\n            return {\n                'status': 'error',\n                'error': str(e)\n            }\n            \n    def cleanup(self):\n        \"\"\"Clean up database connections.\"\"\"\n        self.manager.close()\n```\n\n----------------------------------------\n\nTITLE: Handling Neo4j Connection Errors in Python\nDESCRIPTION: Demonstrates error handling for Neo4j connection issues including refused connections and authentication failures. Uses try-except blocks to catch specific Neo4j exceptions and provide appropriate error messages.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/error_handling.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j.exceptions import ServiceUnavailable\n\ntry:\n    with driver.session() as session:\n        result = session.run(\"MATCH (n) RETURN count(n)\")\nexcept ServiceUnavailable as e:\n    if \"Connection refused\" in str(e):\n        print(\"Neo4j is not running or wrong port\")\n    elif \"unauthorized\" in str(e).lower():\n        print(\"Invalid credentials\")\n    else:\n        print(f\"Neo4j connection error: {str(e)}\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for Neo4j and Qdrant\nDESCRIPTION: Environment variable configuration for connecting to Neo4j graph database and Qdrant vector database. Includes connection URIs, authentication credentials, and collection settings.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/index.md#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# Neo4j Configuration\nNEO4J_URI=bolt://localhost:7687  \nNEO4J_USER=neo4j\nNEO4J_PASSWORD=password\n\n# Qdrant Configuration\nQDRANT_HOST=localhost\nQDRANT_PORT=6333\nQDRANT_COLLECTION=document_chunks\n```\n\n----------------------------------------\n\nTITLE: Qdrant Collection Setup\nDESCRIPTION: Python code for initializing a Qdrant collection with appropriate vector settings and payload indexes for document chunks.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/database_setup.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qdrant_client import QdrantClient\nfrom qdrant_client.http import models\nimport warnings\n\n# Suppress version compatibility warnings\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"qdrant_client\")\n\n# Connect to Qdrant\nclient = QdrantClient(\"localhost\", port=6333)\n\n# Create a collection for document embeddings\n# Using 384 dimensions for all-MiniLM-L6-v2 embeddings\nclient.create_collection(\n    collection_name=\"document_chunks\",\n    vectors_config=models.VectorParams(\n        size=384,  # Dimension size for the embedding model\n        distance=models.Distance.COSINE\n    ),\n)\n\n# Create a payload index for efficient filtering\nclient.create_payload_index(\n    collection_name=\"document_chunks\",\n    field_name=\"metadata.doc_id\",\n    field_schema=models.PayloadSchemaType.KEYWORD,\n)\n\n# Create payload index for chunk sequence\nclient.create_payload_index(\n    collection_name=\"document_chunks\",\n    field_name=\"metadata.sequence\",\n    field_schema=models.PayloadSchemaType.INTEGER,\n)\n```\n\n----------------------------------------\n\nTITLE: Registering Documentation Search Tool in MCP\nDESCRIPTION: Configuration function to register a documentation search tool within the Model Context Protocol server. Defines the tool parameters including query, category, and result limit options.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/index.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom documentation_tool import DocumentationGPTTool\n\ndef register_documentation_tool():\n    return {\n        \"name\": \"documentation_search\",\n        \"description\": \"Search the documentation for information about the GraphRAG system\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"query\": {\n                    \"type\": \"string\",\n                    \"description\": \"The search query to find relevant documentation\"\n                },\n                \"category\": {\n                    \"type\": \"string\",\n                    \"description\": \"Optional category to filter results (e.g., 'setup', 'api', 'usage')\"\n                },\n                \"limit\": {\n                    \"type\": \"integer\",\n                    \"description\": \"Maximum number of results to return (default: 5)\"\n                }\n            },\n            \"required\": [\"query\"]\n        },\n        \"implementation\": DocumentationGPTTool().search_documentation\n    }\n```\n\n----------------------------------------\n\nTITLE: Qdrant Basic Operations\nDESCRIPTION: Python code demonstrating basic Qdrant operations including inserting documents and performing similarity searches with error handling.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/database_setup.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qdrant_client import QdrantClient\nfrom sentence_transformers import SentenceTransformer\nimport warnings\n\n# Suppress version compatibility warnings\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"qdrant_client\")\n\n# Initialize clients\nqdrant = QdrantClient(host=\"localhost\", port=6333)\nmodel = SentenceTransformer('all-MiniLM-L6-v2')\n\n# Insert a document\ntext = \"This document describes the GraphRAG architecture.\"\nembedding = model.encode(text).tolist()\nqdrant.upsert(\n    collection_name=\"document_chunks\",\n    points=[\n        {\n            \"id\": \"chunk1\",\n            \"vector\": embedding,\n            \"payload\": {\n                \"text\": text,\n                \"metadata\": {\n                    \"doc_id\": \"doc1\",\n                    \"chunk_id\": \"chunk1\",\n                    \"sequence\": 1\n                }\n            }\n        }\n    ]\n)\n\n# Search for similar documents\nquery = \"Tell me about the GraphRAG architecture\"\nquery_vector = model.encode(query).tolist()\n\n# Handle different Qdrant versions with compatible search approach\ntry:\n    # Newer Qdrant versions\n    search_result = qdrant.search(\n        collection_name=\"document_chunks\",\n        query_vector=query_vector,\n        limit=5\n    )\nexcept Exception as e:\n    # Fallback for compatibility issues\n    print(f\"Using fallback search due to: {str(e)}\")\n    search_result = qdrant.search(\n        collection_name=\"document_chunks\",\n        query_vector=query_vector,\n        limit=5\n    )\n\nfor result in search_result:\n    print(f\"ID: {result.id}, Score: {result.score}\")\n    print(f\"Text: {result.payload['text']}\")\n    print(\"---\")\n```\n\n----------------------------------------\n\nTITLE: Cloning and Setting Up the GraphRAG Project\nDESCRIPTION: Steps to clone the repository, create a virtual environment, install dependencies, and set up the configuration file for the GraphRAG project.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/yourusername/graphrag.git\ncd graphrag\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install -r requirements.txt\ncp .env.example .env\n# Edit .env with your configuration\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic GraphRAG Search in Python\nDESCRIPTION: Demonstrates the basic search functionality using GraphRAGTool, including initialization, query execution, and result processing. Shows how to perform a simple document search with limit parameters.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/examples.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom graphrag import GraphRAGTool\n\nasync def basic_search():\n    # Initialize the tool\n    tool = GraphRAGTool()\n    \n    try:\n        # Execute a simple search\n        results = await tool.execute(\n            query=\"How to configure Neo4j authentication?\",\n            limit=5\n        )\n        \n        # Process results\n        if results['status'] == 'success':\n            for doc in results['results']:\n                print(f\"Title: {doc['title']}\")\n                print(f\"Score: {doc['score']:.4f}\")\n                print(f\"Content: {doc['content'][:200]}...\")\n                print(\"---\")\n    finally:\n        tool.cleanup()\n```\n\n----------------------------------------\n\nTITLE: Configuring Neo4j and Qdrant Connection Parameters\nDESCRIPTION: Example configuration for connecting to Neo4j and Qdrant databases. Includes URIs, ports, and authentication details for both databases.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Neo4j Configuration\nNEO4J_HTTP_URI=http://localhost:7474\nNEO4J_BOLT_URI=bolt://localhost:7687\nNEO4J_USER=neo4j\nNEO4J_PASSWORD=password\n\n# Qdrant Configuration\nQDRANT_HOST=localhost\nQDRANT_PORT=6333\nQDRANT_COLLECTION=document_chunks\n```\n\n----------------------------------------\n\nTITLE: Basic Qdrant Connection\nDESCRIPTION: Example of connecting to Qdrant vector database with collection information retrieval and version compatibility handling.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/connection.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qdrant_client import QdrantClient\n\n# Connection parameters\nqdrant_host = \"localhost\"\nqdrant_port = 6335  # Note the non-standard port\nqdrant_collection = \"document_chunks\"\n\n# Connect to Qdrant\nclient = QdrantClient(host=qdrant_host, port=qdrant_port)\n\n# Test connection\ndef test_collection():\n    try:\n        collection_info = client.get_collection(qdrant_collection)\n        \n        # Handle different API versions\n        vectors_count = None\n        if hasattr(collection_info, 'vectors_count'):\n            vectors_count = collection_info.vectors_count\n        elif hasattr(collection_info, 'points_count'):\n            vectors_count = collection_info.points_count\n        \n        return vectors_count\n    except Exception as e:\n        print(f\"Error getting collection info: {e}\")\n        return None\n\n# Print collection size\nvector_count = test_collection()\nif vector_count is not None:\n    print(f\"Connected to Qdrant collection '{qdrant_collection}' with {vector_count} vectors\")\n```\n\n----------------------------------------\n\nTITLE: Using GraphRAG Tool in MCP Environment (Python)\nDESCRIPTION: Demonstrates how to initialize the GraphRAGTool, execute a search query, process the results, and clean up resources. It includes error handling and showcases the usage of optional parameters like limit and category.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/query.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Initialize the tool\ngraphrag_tool = GraphRAGTool()\n\n# Execute a search\nresults = await graphrag_tool.execute(\n    query=\"How to configure Neo4j authentication?\",\n    limit=5,\n    category=\"setup\"\n)\n\n# Process results\nif results['status'] == 'success':\n    for doc in results['results']:\n        print(f\"Document: {doc['title']}\")\n        print(f\"Score: {doc['score']}\")\n        print(f\"Related docs: {len(doc['related_docs'])}\")\n        print(\"---\")\nelse:\n    print(f\"Error: {results['error']}\")\n\n# Clean up\ngraphrag_tool.cleanup()\n```\n\n----------------------------------------\n\nTITLE: Embedding Model Setup\nDESCRIPTION: Functions for loading the sentence transformer model and generating embeddings for vector database queries.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/connection.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom sentence_transformers import SentenceTransformer\n\ndef load_embedding_model(model_name=\"all-MiniLM-L6-v2\"):\n    \"\"\"Load the sentence transformer model for creating embeddings.\"\"\"\n    try:\n        model = SentenceTransformer(model_name)\n        print(f\"✅ Loaded embedding model: {model_name}\")\n        return model\n    except Exception as e:\n        print(f\"❌ Error loading embedding model: {e}\")\n        return None\n\n# Load the model\nmodel = load_embedding_model()\n\n# Generate an embedding for a query\ndef generate_embedding(text, model):\n    if model is None:\n        return None\n    \n    try:\n        embedding = model.encode(text)\n        return embedding\n    except Exception as e:\n        print(f\"❌ Error generating embedding: {e}\")\n        return None\n```\n\n----------------------------------------\n\nTITLE: MCP Server Integration with GraphRAG\nDESCRIPTION: Implements GraphRAG integration with MCP server, extending BaseTool to create a custom tool for searching documentation through the MCP framework.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/examples.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom mcp.tools import BaseTool\nfrom graphrag import GraphRAGTool\n\nclass GraphRAGMCPTool(BaseTool):\n    name = \"GraphRAG\"\n    description = \"Search through documentation using GraphRAG\"\n    \n    def __init__(self):\n        super().__init__()\n        self.tool = GraphRAGTool()\n        \n    async def execute(self, query: str, **kwargs):\n        try:\n            # Extract parameters\n            limit = kwargs.get('limit', 5)\n            category = kwargs.get('category')\n            \n            # Execute search\n            results = await self.tool.execute(\n                query=query,\n                limit=limit,\n                category=category\n            )\n            \n            # Format response for MCP\n            if results['status'] == 'success':\n                return {\n                    'success': True,\n                    'data': {\n                        'results': results['results'],\n                        'count': results['count']\n                    }\n                }\n            else:\n                return {\n                    'success': False,\n                    'error': results.get('error', 'Unknown error')\n                }\n        except Exception as e:\n            return {\n                'success': False,\n                'error': str(e)\n            }\n        finally:\n            self.tool.cleanup()\n            \n    def cleanup(self):\n        \"\"\"Clean up resources when the tool is unloaded.\"\"\"\n        if hasattr(self, 'tool'):\n            self.tool.cleanup()\n```\n\n----------------------------------------\n\nTITLE: Defining YAML Front Matter for GraphRAG Documents\nDESCRIPTION: Required YAML front matter format for documents to be imported into the GraphRAG system. Includes required fields like title and category, and optional fields like updated date, related documents, and key concepts.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/your_docs_here/index.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\ntitle: \"Document Title\"          # The title of your document (required)\ncategory: \"path/to/category\"     # Category path for organization (required)\nupdated: \"YYYY-MM-DD\"            # Last updated date (optional)\nrelated:                         # Related documents (optional)\n  - path/to/related1.md\n  - path/to/related2.md\nkey_concepts:                    # Key concepts for indexing (optional)\n  - concept_one\n  - concept_two\n---\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker Compose for Neo4j and Qdrant\nDESCRIPTION: Docker Compose configuration for setting up Neo4j and Qdrant services with appropriate ports, volumes, and network settings. Includes environment variables for Neo4j authentication and APOC plugins.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/database_setup.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nversion: '3'\n\nservices:\n  neo4j:\n    image: neo4j:5.13.0\n    container_name: graphrag_neo4j\n    ports:\n      - \"7474:7474\"  \n      - \"7687:7687\"  \n    environment:\n      - NEO4J_AUTH=neo4j/password\n      - NEO4J_apoc_export_file_enabled=true\n      - NEO4J_apoc_import_file_enabled=true\n      - NEO4J_apoc_import_file_use__neo4j__config=true\n      - NEO4J_PLUGINS=[\"apoc\"]\n    volumes:\n      - neo4j_data:/data\n      - neo4j_logs:/logs\n      - neo4j_import:/var/lib/neo4j/import\n      - neo4j_plugins:/plugins\n    networks:\n      - graphrag_network\n\n  qdrant:\n    image: qdrant/qdrant:v1.5.1\n    container_name: graphrag_qdrant\n    ports:\n      - \"6335:6333\"  # HTTP (mapped to non-standard port)\n      - \"6334:6334\"  # gRPC\n    volumes:\n      - qdrant_data:/qdrant/storage\n    environment:\n      - QDRANT_ALLOW_CORS=true\n    networks:\n      - graphrag_network\n\nvolumes:\n  neo4j_data:\n  neo4j_logs:\n  neo4j_import:\n  neo4j_plugins:\n  qdrant_data:\n\nnetworks:\n  graphrag_network:\n    driver: bridge\n```\n\n----------------------------------------\n\nTITLE: Testing DocumentationGPTTool Search Functionality\nDESCRIPTION: Implementation of functional testing for the DocumentationGPTTool, including search functionality testing with result verification and error handling.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/testing.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom your_mcp_package import DocumentationGPTTool\n\ndef test_search_functionality():\n    \"\"\"Test the search functionality of the DocumentationGPTTool\"\"\"\n    print(\"Testing search functionality...\")\n    \n    # Initialize the tool\n    doc_tool = DocumentationGPTTool()\n    \n    # Test with a simple query\n    test_query = \"database setup\"\n    print(f\"Searching for: '{test_query}'\")\n    \n    results = doc_tool.search_documentation(\n        query=test_query,\n        limit=3\n    )\n    \n    # Print results\n    print(f\"Found {len(results)} results:\")\n    for i, result in enumerate(results):\n        print(f\"\\nResult {i+1}:\")\n        print(f\"Score: {result.get('score')}\")\n        print(f\"Text snippet: {result.get('text')[:150]}...\")\n        doc_info = result.get('document', {})\n        print(f\"Document: {doc_info.get('title', 'Unknown')} ({doc_info.get('id', 'Unknown')})\")\n    \n    # Clean up\n    doc_tool.close()\n    \n    return len(results) > 0\n\nif __name__ == \"__main__\":\n    if test_search_functionality():\n        print(\"\\n✅ Search functionality working correctly!\")\n    else:\n        print(\"\\n❌ Search functionality test failed!\")\n```\n\n----------------------------------------\n\nTITLE: Environment Variables Configuration for Database Connections\nDESCRIPTION: Example environment variable configuration for Neo4j and Qdrant connection parameters.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/connection.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n# .env file\nNEO4J_URI=bolt://localhost:7688\nNEO4J_USER=neo4j\nNEO4J_PASSWORD=password\nQDRANT_HOST=localhost\nQDRANT_PORT=6335\nQDRANT_COLLECTION=document_chunks\n```\n\n----------------------------------------\n\nTITLE: Initializing GraphRAG Components in Python\nDESCRIPTION: Demonstrates the initialization and setup of core GraphRAG components including configuration loading, database helpers, and query engine. Shows the basic import structure and component instantiation pattern.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/src/index.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom src.config import load_config\nfrom src.utils.neo4j_utils import Neo4jHelper\nfrom src.utils.qdrant_utils import QdrantHelper\nfrom src.utils.query_utils import QueryEngine\nfrom src.processors.markdown_processor import MarkdownProcessor\n\n# Example usage\nconfig = load_config()\nneo4j = Neo4jHelper(config)\nqdrant = QdrantHelper(config)\nquery_engine = QueryEngine(neo4j, qdrant)\n```\n\n----------------------------------------\n\nTITLE: Loading Environment Variables in Python\nDESCRIPTION: Shows how to load and use environment variables for database connection configuration using python-dotenv.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/connection.md#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom dotenv import load_dotenv\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Get connection parameters\nneo4j_uri = os.getenv(\"NEO4J_URI\")\nneo4j_user = os.getenv(\"NEO4J_USER\")\nneo4j_password = os.getenv(\"NEO4J_PASSWORD\")\nqdrant_host = os.getenv(\"QDRANT_HOST\")\nqdrant_port = int(os.getenv(\"QDRANT_PORT\"))\nqdrant_collection = os.getenv(\"QDRANT_COLLECTION\")\n```\n\n----------------------------------------\n\nTITLE: Usage Example of GraphRAG Connection Manager\nDESCRIPTION: Demonstrates how to create and use the connection manager instance, including establishing connections and proper cleanup.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/connection.md#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Create the connection manager\nmanager = GraphRAGConnectionManager()\n\n# Connect to databases\nif manager.connect():\n    print(\"All connections established successfully\")\n    \n    # Use the connections...\n    \n    # Close connections when done\n    manager.close()\nelse:\n    print(\"Failed to establish all connections\")\n```\n\n----------------------------------------\n\nTITLE: Running Connection Test Script with Virtual Environment\nDESCRIPTION: Instructions for running the connection test script, including activating the virtual environment, installing required dependencies, and executing the test script.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/testing/index.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Activate virtual environment\nsource venv/bin/activate\n\n# Install dependencies if needed\npip install neo4j qdrant-client\n\n# Run the test\npython scripts/testing/test_connections.py\n```\n\n----------------------------------------\n\nTITLE: Error Handling in GraphRAG Searches\nDESCRIPTION: Implements robust error handling with retry logic for GraphRAG searches, including error logging and graceful failure handling.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/examples.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom graphrag import GraphRAGTool, ErrorLogger\n\nasync def robust_search():\n    tool = GraphRAGTool()\n    logger = ErrorLogger()\n    \n    try:\n        # Attempt search with retry\n        for attempt in range(3):\n            try:\n                results = await tool.execute(\n                    query=\"Database optimization techniques\"\n                )\n                if results['status'] == 'success':\n                    return results\n            except Exception as e:\n                logger.log_error(e, {\n                    'attempt': attempt + 1,\n                    'operation': 'search'\n                })\n                if attempt < 2:\n                    print(f\"Retrying... (attempt {attempt + 2}/3)\")\n                    await asyncio.sleep(1)\n                else:\n                    print(\"All attempts failed\")\n                    return None\n    finally:\n        tool.cleanup()\n```\n\n----------------------------------------\n\nTITLE: Importing Documents into GraphRAG System\nDESCRIPTION: Bash commands for importing markdown documents into the GraphRAG hybrid retrieval system. Shows options for importing all documents from a directory, specific files, or rebuilding the database by clearing existing data.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/your_docs_here/index.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Import all documents from this directory\npython scripts/import_docs.py --docs-dir your_docs_here/\n\n# Or import specific documents\npython scripts/import_docs.py --files your_docs_here/file1.md your_docs_here/file2.md\n\n# To reimport (clear and rebuild)\npython scripts/import_docs.py --docs-dir your_docs_here/ --clear\n```\n\n----------------------------------------\n\nTITLE: Port Availability Check for Database Services\nDESCRIPTION: Command to check if the required ports (7474, 7687, 6333) are already in use by other services, which could prevent the databases from starting properly.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/test_db_connection/index.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nlsof -i :7474 -i :7687 -i :6333\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for Neo4j and Qdrant Connections\nDESCRIPTION: This snippet defines environment variables for connecting to Neo4j and Qdrant databases. It includes URIs, authentication details, and collection information.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/testing/connection_info.md#2025-04-21_snippet_0\n\nLANGUAGE: env\nCODE:\n```\n# Neo4j\nNEO4J_URI=bolt://localhost:7687\nNEO4J_USER=neo4j\nNEO4J_PASSWORD=password\n\n# Qdrant\nQDRANT_HOST=localhost\nQDRANT_PORT=6333\nQDRANT_COLLECTION=document_chunks\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependencies for GraphRAG Hybrid Project in Python\nDESCRIPTION: This snippet defines the required Python packages and their minimum versions for the GraphRAG Hybrid project. It includes core dependencies, database connectors, NLP tools, and utility libraries necessary for the project's functionality.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/requirements.txt#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n# Core dependencies\npython-dotenv>=1.0.0\npyyaml>=6.0\nloguru>=0.7.0\n\n# Neo4j dependencies\nneo4j>=5.11.0\n\n# Qdrant dependencies\nqdrant-client>=1.5.0\n\n# NLP and embedding dependencies\ntransformers>=4.35.0\ntorch>=2.0.0\nsentence-transformers>=2.2.2\nnumpy>=1.24.0\n\n# Utilities\ntqdm>=4.65.0\nrequests>=2.31.0\npython-dateutil>=2.8.2\nuuid>=1.30\n```\n\n----------------------------------------\n\nTITLE: Related Documents Search with GraphRAG\nDESCRIPTION: Implements a search functionality that includes related documents in the results, demonstrating how to process and display interconnected documentation.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/examples.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nasync def related_docs_search():\n    tool = GraphRAGTool()\n    \n    try:\n        # Search with related documents\n        results = await tool.execute(\n            query=\"Neo4j backup strategies\",\n            limit=2\n        )\n        \n        if results['status'] == 'success':\n            for doc in results['results']:\n                print(f\"Main Document: {doc['title']}\")\n                print(\"\\nRelated Documents:\")\n                for related in doc['related_docs']:\n                    print(f\"- {related['title']} ({related['type']})\")\n                print(\"---\")\n    finally:\n        tool.cleanup()\n```\n\n----------------------------------------\n\nTITLE: Installing Required Dependencies\nDESCRIPTION: Installation commands for required Python packages including neo4j, qdrant-client, and sentence-transformers.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/connection.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install neo4j==5.9.0 qdrant-client==1.6.0 sentence-transformers==2.2.2\n```\n\n----------------------------------------\n\nTITLE: Category-Filtered GraphRAG Search Implementation\nDESCRIPTION: Shows how to perform category-specific searches using GraphRAG, filtering results by a specified category parameter and limiting the number of results.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/examples.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def category_search():\n    tool = GraphRAGTool()\n    \n    try:\n        # Search within a specific category\n        results = await tool.execute(\n            query=\"How to set up replication?\",\n            category=\"deployment\",\n            limit=3\n        )\n        \n        if results['status'] == 'success':\n            print(f\"Found {results['count']} results:\")\n            for doc in results['results']:\n                print(f\"Category: {doc['category']}\")\n                print(f\"Title: {doc['title']}\")\n                print(\"---\")\n    finally:\n        tool.cleanup()\n```\n\n----------------------------------------\n\nTITLE: GraphRAG Setup and Dependency Installation\nDESCRIPTION: Shows the required setup steps and package installation for running GraphRAG examples, including database prerequisites and environment configuration.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/examples.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\npip install neo4j qdrant-client sentence-transformers\n```\n\n----------------------------------------\n\nTITLE: Configuring MCP Server Environment Variables for Database Connections\nDESCRIPTION: This snippet provides environment variables for the MCP server configuration. It includes connection details for Neo4j and Qdrant, as well as embedding model information.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/testing/connection_info.md#2025-04-21_snippet_1\n\nLANGUAGE: env\nCODE:\n```\nNEO4J_URI=bolt://localhost:7687\nNEO4J_USER=neo4j\nNEO4J_PASSWORD=password\nQDRANT_HOST=localhost\nQDRANT_PORT=6333\nEMBEDDING_MODEL=all-MiniLM-L6-v2\nEMBEDDING_DIMENSION=384\n```\n\n----------------------------------------\n\nTITLE: Managing Qdrant Connection Issues in Python\nDESCRIPTION: Handles connection errors and collection management for Qdrant vector database. Includes timeout handling and collection creation if not found.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/error_handling.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qdrant_client.http.exceptions import UnexpectedResponse\n\ntry:\n    client = QdrantClient(host=host, port=port)\n    client.get_collection(collection_name)\nexcept ConnectionError:\n    print(\"Qdrant is not running or wrong port\")\nexcept UnexpectedResponse as e:\n    if \"404\" in str(e):\n        print(f\"Collection '{collection_name}' not found\")\n    else:\n        print(f\"Qdrant error: {str(e)}\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for Neo4j and Qdrant\nDESCRIPTION: Environment variable configuration for connecting to Neo4j and Qdrant databases using standard ports. Sets the Neo4j URI, username, password, and Qdrant host and port information.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/testing/index.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Neo4j\nNEO4J_URI=bolt://localhost:7687\nNEO4J_USERNAME=neo4j\nNEO4J_PASSWORD=password\n\n# Qdrant\nQDRANT_HOST=localhost\nQDRANT_PORT=6333\n```\n\n----------------------------------------\n\nTITLE: Neo4j Schema Setup\nDESCRIPTION: Cypher commands for setting up the Neo4j database schema including constraints and indexes for Content, Document, Topic, and Entity nodes.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/database_setup.md#2025-04-21_snippet_2\n\nLANGUAGE: cypher\nCODE:\n```\n// Node labels\nCREATE CONSTRAINT IF NOT EXISTS FOR (c:Content) REQUIRE c.id IS UNIQUE;\nCREATE CONSTRAINT IF NOT EXISTS FOR (d:Document) REQUIRE d.id IS UNIQUE;\nCREATE CONSTRAINT IF NOT EXISTS FOR (t:Topic) REQUIRE t.name IS UNIQUE;\nCREATE CONSTRAINT IF NOT EXISTS FOR (e:Entity) REQUIRE e.name IS UNIQUE;\n\n// Indexes for faster lookups\nCREATE INDEX IF NOT EXISTS FOR (c:Content) ON (c.text);\nCREATE INDEX IF NOT EXISTS FOR (d:Document) ON (d.title);\nCREATE INDEX IF NOT EXISTS FOR (d:Document) ON (d.category);\nCREATE INDEX IF NOT EXISTS FOR (d:Document) ON (d.path);\n```\n\n----------------------------------------\n\nTITLE: Environment Configuration for Database Connections\nDESCRIPTION: Environment variables for connecting to Neo4j and Qdrant databases with the correct connection parameters. These parameters should be set in the .env file for all scripts.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/testing/index.md#2025-04-21_snippet_2\n\nLANGUAGE: env\nCODE:\n```\nNEO4J_URI=bolt://localhost:7687\nNEO4J_USER=neo4j\nNEO4J_PASSWORD=password\nQDRANT_HOST=localhost\nQDRANT_PORT=6333\n```\n\n----------------------------------------\n\nTITLE: Qdrant Connection with Version Compatibility\nDESCRIPTION: Advanced Qdrant connection implementation with version compatibility checks, error handling, and retry logic.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/connection.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport warnings\nfrom qdrant_client import QdrantClient\n\n# Suppress version compatibility warnings\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"qdrant_client\")\n\ndef connect_to_qdrant(host, port, collection_name, max_retries=3):\n    \"\"\"Connect to Qdrant with error handling and version compatibility.\"\"\"\n    retry_count = 0\n    \n    while retry_count < max_retries:\n        try:\n            # Connect to Qdrant\n            client = QdrantClient(host=host, port=port)\n            \n            # Verify connection by checking collection\n            collection_info = client.get_collection(collection_name)\n            \n            # Try to get vector count using different API versions\n            vectors_count = None\n            \n            # Try approach for newer versions\n            if hasattr(collection_info, 'vectors_count'):\n                vectors_count = collection_info.vectors_count\n            # Try approach for other versions\n            elif hasattr(collection_info, 'points_count'):\n                vectors_count = collection_info.points_count\n            # Try to navigate the potentially nested structure\n            else:\n                try:\n                    if hasattr(collection_info.config, 'params'):\n                        if hasattr(collection_info.config.params, 'vectors'):\n                            vectors_count = collection_info.config.params.vectors.size\n                except:\n                    pass\n            \n            if vectors_count is not None:\n                print(f\"✅ Connected to Qdrant collection '{collection_name}' with {vectors_count} vectors\")\n            else:\n                print(f\"✅ Connected to Qdrant collection '{collection_name}', but couldn't determine vector count\")\n                \n            return client\n            \n        except ConnectionError as e:\n            retry_count += 1\n            wait_time = 2 ** retry_count  # Exponential backoff\n            print(f\"❌ Qdrant connection failed (attempt {retry_count}/{max_retries}): {e}\")\n            print(f\"   Retrying in {wait_time} seconds...\")\n            time.sleep(wait_time)\n            \n        except Exception as e:\n            print(f\"❌ Error connecting to Qdrant: {e}\")\n            break\n    \n    if retry_count >= max_retries:\n        print(f\"❌ Failed to connect to Qdrant after {max_retries} attempts\")\n    \n    return None\n```\n\n----------------------------------------\n\nTITLE: Basic Neo4j Connection Example\nDESCRIPTION: Simple example of connecting to Neo4j database using the GraphDatabase driver, including connection testing and proper cleanup.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/connection.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j import GraphDatabase\n\n# Connection parameters\nneo4j_uri = \"bolt://localhost:7688\"  # Note the non-standard port\nneo4j_user = \"neo4j\"\nneo4j_password = \"password\"\n\n# Establish connection\ndriver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))\n\n# Test connection\ndef test_connection():\n    with driver.session() as session:\n        result = session.run(\"MATCH (n) RETURN count(n) AS node_count\")\n        return result.single()[\"node_count\"]\n\n# Print node count\nprint(f\"Connected to Neo4j database with {test_connection()} nodes\")\n\n# Close connection when done\ndriver.close()\n```\n\n----------------------------------------\n\nTITLE: Batch Processing with GraphRAG\nDESCRIPTION: Implements batch processing functionality for executing multiple queries in sequence using GraphRAG, with error handling for individual queries.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/examples.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom graphrag import GraphRAGTool\nfrom typing import List\n\nasync def batch_search(queries: List[str]):\n    tool = GraphRAGTool()\n    \n    try:\n        results = []\n        for query in queries:\n            # Execute search for each query\n            response = await tool.execute(query=query)\n            if response['status'] == 'success':\n                results.append({\n                    'query': query,\n                    'results': response['results']\n                })\n            else:\n                print(f\"Failed query: {query}\")\n                print(f\"Error: {response.get('error')}\")\n                \n        return results\n    finally:\n        tool.cleanup()\n\n# Usage example\nqueries = [\n    \"Neo4j backup strategies\",\n    \"Qdrant optimization techniques\",\n    \"Database security best practices\"\n]\n\nresults = await batch_search(queries)\nfor item in results:\n    print(f\"\\nQuery: {item['query']}\")\n    print(f\"Found {len(item['results'])} results\")\n```\n\n----------------------------------------\n\nTITLE: Starting Neo4j and Qdrant Using Docker\nDESCRIPTION: Command to start Neo4j and Qdrant databases using Docker Compose, which sets up the required infrastructure for the GraphRAG system.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose up -d\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Neo4j Connection in Python\nDESCRIPTION: Defines the environment variables required for connecting to the Neo4j database in the GraphRAG system. Includes the URI, HTTP URI, username, and password.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/AI_ENTRY.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nNEO4J_URI=bolt://localhost:7687\nNEO4J_HTTP_URI=http://localhost:7474\nNEO4J_USERNAME=neo4j\nNEO4J_PASSWORD=password\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Qdrant Connection in Python\nDESCRIPTION: Specifies the environment variables needed for connecting to the Qdrant vector database in the GraphRAG system. Includes the host, port, and collection name.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/AI_ENTRY.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nQDRANT_HOST=localhost\nQDRANT_PORT=6333\nQDRANT_COLLECTION=document_chunks\n```\n\n----------------------------------------\n\nTITLE: Setting Up GraphRAG Databases\nDESCRIPTION: Command to initialize both Neo4j and Qdrant databases with required schemas and collections using the setup script.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/scripts/index.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Initialize both databases with required schemas/collections\npython scripts/setup_databases.py\n```\n\n----------------------------------------\n\nTITLE: Verifying Database Connections with Python Scripts\nDESCRIPTION: Commands to run Python scripts that verify database connections and perform detailed database checks for the GraphRAG system. These scripts validate both Neo4j and Qdrant connections and ensure proper alignment between the databases.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/test_db_connection/connection_info.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Run the connection test script\npython test_db_connection/test_connections.py\n\n# Run the detailed database checker\npython check_databases.py\n```\n\n----------------------------------------\n\nTITLE: Verifying Database Connections\nDESCRIPTION: Command to run a Python script that verifies the connections to both Neo4j and Qdrant databases, ensuring proper setup of the GraphRAG system.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/README.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npython test_db_connection/test_connections.py\n```\n\n----------------------------------------\n\nTITLE: GraphRAG System Health Monitoring\nDESCRIPTION: Implements health checking functionality for GraphRAG system components, monitoring Neo4j and Qdrant status and reporting system health metrics.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/examples.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom graphrag import GraphRAGTool, HealthCheck\n\nasync def system_health_check():\n    tool = GraphRAGTool()\n    health_checker = HealthCheck(tool.manager)\n    \n    try:\n        # Check system health\n        status = await health_checker.check_health()\n        \n        print(\"System Health Status:\")\n        print(f\"Timestamp: {status['timestamp']}\")\n        \n        # Neo4j status\n        print(\"\\nNeo4j:\")\n        print(f\"Status: {status['neo4j']['status']}\")\n        if 'message' in status['neo4j']:\n            print(f\"Message: {status['neo4j']['message']}\")\n        elif 'error' in status['neo4j']:\n            print(f\"Error: {status['neo4j']['error']}\")\n            \n        # Qdrant status\n        print(\"\\nQdrant:\")\n        print(f\"Status: {status['qdrant']['status']}\")\n        if status['qdrant']['status'] == 'healthy':\n            print(f\"Vectors: {status['qdrant']['vectors_count']}\")\n        elif 'error' in status['qdrant']:\n            print(f\"Error: {status['qdrant']['error']}\")\n    finally:\n        tool.cleanup()\n```\n\n----------------------------------------\n\nTITLE: Neo4j Port Testing Function\nDESCRIPTION: Function to test Neo4j connectivity across multiple ports to identify the correct port for connection.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/connection.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef find_neo4j_port(host=\"localhost\", ports=[7687, 7688, 7689]):\n    \"\"\"Try to connect to Neo4j on different ports.\"\"\"\n    for port in ports:\n        uri = f\"bolt://{host}:{port}\"\n        try:\n            with GraphDatabase.driver(uri, auth=(\"neo4j\", \"password\")) as driver:\n                with driver.session() as session:\n                    session.run(\"RETURN 1\").single()\n                    print(f\"✅ Neo4j found on port {port}\")\n                    return port\n        except Exception as e:\n            print(f\"❌ Neo4j not available on port {port}: {e}\")\n    \n    print(\"❌ Could not connect to Neo4j on any of the specified ports\")\n    return None\n```\n\n----------------------------------------\n\nTITLE: Qdrant Port Testing Function\nDESCRIPTION: Function to test Qdrant connectivity across multiple ports to identify the correct port for connection.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/connection.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef find_qdrant_port(host=\"localhost\", ports=[6333, 6334, 6335]):\n    \"\"\"Try to connect to Qdrant on different ports.\"\"\"\n    for port in ports:\n        try:\n            client = QdrantClient(host=host, port=port)\n            collections = client.get_collections().collections\n            print(f\"✅ Qdrant found on port {port} with {len(collections)} collections\")\n            return port\n        except Exception as e:\n            print(f\"❌ Qdrant not available on port {port}: {e}\")\n    \n    print(\"❌ Could not connect to Qdrant on any of the specified ports\")\n    return None\n```\n\n----------------------------------------\n\nTITLE: Docker Container Status Check for GraphRAG Services\nDESCRIPTION: Command to verify if Neo4j and Qdrant Docker containers are running by filtering the docker ps output for GraphRAG-related containers.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/test_db_connection/index.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker ps | grep graphrag\n```\n\n----------------------------------------\n\nTITLE: Running Query Tester Script for Neo4j and Qdrant\nDESCRIPTION: Command to execute the query_tester.py script that tests various queries against both Neo4j and Qdrant databases.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/testing/index.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython scripts/testing/query_tester.py\n```\n\n----------------------------------------\n\nTITLE: Docker Compose Commands\nDESCRIPTION: Basic Docker Compose commands for starting and stopping the database services.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/database_setup.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose up -d\ndocker-compose down\n```\n\n----------------------------------------\n\nTITLE: Importing Documents to GraphRAG\nDESCRIPTION: Command to import documents from a specified directory into the GraphRAG system using the import script.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/scripts/index.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Import documents from the your_docs_here directory\npython scripts/import_docs.py --docs-dir ./your_docs_here\n```\n\n----------------------------------------\n\nTITLE: Environment Configuration Check for Database Connections\nDESCRIPTION: Command to verify that the .env file contains the correct connection information for Neo4j and Qdrant databases by filtering for relevant environment variables.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/test_db_connection/index.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncat .env | grep -E \"NEO4J|QDRANT\"\n```\n\n----------------------------------------\n\nTITLE: Running Neo4j and Qdrant Connection Tests with Python\nDESCRIPTION: Command to activate a virtual environment and run the test script that verifies connections to both Neo4j and Qdrant databases, checking connectivity and database content.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/test_db_connection/index.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Activate virtual environment if needed\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Run the test script\npython test_db_connection/test_connections.py\n```\n\n----------------------------------------\n\nTITLE: Running MCP Query Tester\nDESCRIPTION: Command-line instructions for activating the virtual environment and running the query testing script to validate the MCP tool implementation.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/index.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Activate virtual environment\nsource venv/bin/activate\n\n# Run the test script\npython scripts/testing/query_tester.py\n```\n\n----------------------------------------\n\nTITLE: Querying GraphRAG System\nDESCRIPTION: Command to run an interactive query demo for testing and exploring the GraphRAG system functionality.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/scripts/index.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Run an interactive query demo\npython scripts/query_demo.py\n```\n\n----------------------------------------\n\nTITLE: Non-Standard Database Connection Parameters\nDESCRIPTION: Corrected environment variables for connecting to Neo4j and Qdrant databases on non-standard ports that were discovered during testing.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/testing/index.md#2025-04-21_snippet_4\n\nLANGUAGE: env\nCODE:\n```\nNEO4J_URI=bolt://localhost:7688\nNEO4J_USER=neo4j\nNEO4J_PASSWORD=password\nQDRANT_HOST=localhost\nQDRANT_PORT=6335\n```\n\n----------------------------------------\n\nTITLE: Port Mapping Verification in Docker Compose File\nDESCRIPTION: Command to check if the required ports (7474, 7687, 6333) are correctly mapped in the docker-compose.yml file for Neo4j and Qdrant services.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/test_db_connection/index.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncat docker-compose.yml | grep -E \"7474|7687|6333\"\n```\n\n----------------------------------------\n\nTITLE: Neo4j Basic Operations\nDESCRIPTION: Example Cypher queries demonstrating basic Neo4j operations including creating nodes, relationships, and querying related content.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/database_setup.md#2025-04-21_snippet_3\n\nLANGUAGE: cypher\nCODE:\n```\n// Create a document node\nCREATE (d:Document {id: \"doc1\", title: \"GraphRAG Architecture\", path: \"/docs/architecture.md\"})\n\n// Create content chunks for the document\nCREATE (c1:Content {id: \"chunk1\", text: \"This document describes the GraphRAG architecture combining Neo4j and Qdrant.\"})\nCREATE (c2:Content {id: \"chunk2\", text: \"The system uses a hybrid approach with vector similarity and graph relationships.\"})\n\n// Create relationships\nMATCH (d:Document {id: \"doc1\"})\nMATCH (c1:Content {id: \"chunk1\"})\nMATCH (c2:Content {id: \"chunk2\"})\nCREATE (d)-[:CONTAINS]->(c1)\nCREATE (d)-[:CONTAINS]->(c2)\nCREATE (c1)-[:NEXT]->(c2)\n\n// Query related content\nMATCH (c:Content {id: \"chunk1\"})-[r:NEXT]->(related)\nRETURN c.text AS source, related.text AS related_content\n```\n\n----------------------------------------\n\nTITLE: Example Markdown Document with YAML Frontmatter\nDESCRIPTION: Sample structure of a Markdown document with YAML frontmatter, demonstrating the required format for documents to be processed by the GraphRAG system.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/README.md#2025-04-21_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: Analytics and Monitoring              # Document title (required)\ncategory: frontend/ux                        # Category path (required)\nupdated: '2023-04-01'                        # Last updated date (optional)\nrelated:                                     # Related documents (optional)\n- ui/DATA_FETCHING.md\n- ui/STATE_MANAGEMENT.md\n- ux/USER_FLOWS.md\nkey_concepts:                                # Key concepts for indexing (optional)\n- analytics_integration\n- user_behavior_tracking\n- performance_monitoring\n---\n\n# Analytics and Monitoring\n\nThis document outlines the approach to analytics and monitoring within the application.\n\n## Analytics Strategy\n\n### Core Principles\n\nThe analytics implementation adheres to these principles:\n\n- **Purpose-Driven**: Collection tied to specific business or UX questions\n- **Privacy-First**: Minimal data collection with clear user consent\n\n## Performance Monitoring\n\nCode examples should use language identifiers:\n\n```javascript\nfunction trackEvent(eventName, properties) {\n  analytics.track(eventName, {\n    timestamp: new Date().toISOString(),\n    ...properties\n  });\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Displaying Directory Structure for GraphRAG Project in Bash\nDESCRIPTION: Shows the directory structure of the GraphRAG project, including source code, scripts, documentation, and configuration files.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/AI_ENTRY.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngraphrag/\n├── src/                          # Source code\n│   ├── config.py                 # Configuration management\n│   ├── query_engine.py           # Hybrid query engine\n│   ├── database/                 # Database managers\n│   │   ├── neo4j_manager.py      # Neo4j database manager\n│   │   └── qdrant_manager.py     # Qdrant vector database manager\n│   └── processors/               # Data processors\n│       ├── document_processor.py # Document parsing and chunking\n│       └── embedding_processor.py # Text embedding generation\n├── scripts/                      # Utility scripts\n│   ├── import_docs.py            # Document import script\n│   └── query_demo.py             # Query demonstration script\n├── your_docs_here/               # Add markdown documents here\n├── data/                         # Data storage directory\n├── guides/                       # User guides and documentation\n│   └── mcp/                      # MCP integration guides\n├── test_db_connection/           # Database connection testing\n├── docker-compose.yml            # Docker-compose for Neo4j and Qdrant\n├── requirements.txt              # Python dependencies\n└── .env.example                  # Example environment variables\n```\n\n----------------------------------------\n\nTITLE: Generating JWT Token in JavaScript\nDESCRIPTION: This function generates a JSON Web Token (JWT) for user authentication. It takes a userId and scopes as input, and returns a signed token with an expiration time of 1 hour. The token includes subject, scopes, and issued-at claims.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/your_docs_here/sample.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction generateToken(userId, scopes) {\n  return jwt.sign(\n    { \n      sub: userId,\n      scopes: scopes,\n      iat: Math.floor(Date.now() / 1000)\n    },\n    process.env.JWT_SECRET,\n    { expiresIn: '1h' }\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Tracking Events in JavaScript\nDESCRIPTION: JavaScript function for tracking events with analytics, including timestamp and custom properties. This is an example of how to integrate analytics in the frontend.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/README.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nfunction trackEvent(eventName, properties) {\n  analytics.track(eventName, {\n    timestamp: new Date().toISOString(),\n    ...properties\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Testing MCP API Integration with cURL\nDESCRIPTION: Example cURL command for testing the MCP API endpoint with the DocumentationGPTTool integration.\nSOURCE: https://github.com/rileylemm/graphrag-hybrid/blob/main/guides/mcp/testing.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl -X POST http://localhost:8000/api/tools/execute \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"tool\": \"documentation_search\",\n    \"parameters\": {\n      \"query\": \"How to set up Neo4j\",\n      \"limit\": 3\n    }\n  }'\n```"
  }
]