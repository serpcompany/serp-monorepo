[
  {
    "owner": "drhagen",
    "repo": "parsita",
    "content": "TITLE: Hello World Parser Implementation in Parsita\nDESCRIPTION: Example parser that extracts a name from a 'Hello, {name}!' string format. Demonstrates basic parser construction using Parsita's ParserContext, literal matching, and regular expressions. Includes success and failure cases with error handling.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/index.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass HelloWorldParsers(ParserContext, whitespace=r'[ ]*'):\n    hello_world = lit('Hello') >> ',' >> reg(r'[A-Z][a-z]*') << '!'\n\n# A successful parse produces the parsed value\nname = HelloWorldParsers.hello_world.parse('Hello, David!').unwrap()\nassert name == 'David'\n\n# A parsing failure produces a useful error message\nname = HelloWorldParsers.hello_world.parse('Hello David!').unwrap()\n# parsita.state.ParseError: Expected ',' but found 'David'\n# Line 1, character 7\n#\n# Hello David!\n#       ^\n```\n\n----------------------------------------\n\nTITLE: Creating a Hello World Parser with Parsita\nDESCRIPTION: Example showing how to create a simple parser that extracts a name from a 'Hello, {name}!' string. It demonstrates parser context creation, literal matching, regular expression matching, and handling of successful and failed parses.\nSOURCE: https://github.com/drhagen/parsita/blob/master/README.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass HelloWorldParsers(ParserContext, whitespace=r'[ ]*'):\n    hello_world = lit('Hello') >> ',' >> reg(r'[A-Z][a-z]*') << '!'\n\n# A successful parse produces the parsed value\nname = HelloWorldParsers.hello_world.parse('Hello, David!').unwrap()\nassert name == 'David'\n\n# A parsing failure produces a useful error message\nname = HelloWorldParsers.hello_world.parse('Hello David!').unwrap()\n# parsita.state.ParseError: Expected ',' but found 'David'\n# Line 1, character 7\n#\n# Hello David!\n#       ^\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Numeric List Parser in Python using Parsita\nDESCRIPTION: Demonstrates how to create a parser class that inherits from ParserContext to parse lists of integers. The parser handles whitespace and uses regular expressions to match integer patterns.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/getting_started.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass NumericListParsers(ParserContext, whitespace=r'[ ]*'):\n    integer_list = '[' >> repsep(reg('[+-]?[0-9]+') > int, ',') << ']'\n```\n\n----------------------------------------\n\nTITLE: Using Basic Sequential Parser (&) for URL Parsing in Python\nDESCRIPTION: This example demonstrates the basic sequential parser operator '&' in Parsita, which combines multiple parsers in sequence. The URL parser matches components of a URL (protocol, separator, domain, path) in order and returns all matched values as a list.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/sequential_parsers.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass UrlParsers(ParserContext):\n    url = lit('http', 'ftp') & '://' & reg(r'[^/]+') & reg(r'.*')\n\nassert UrlParsers.url.parse('http://drhagen.com/blog/sane-equality/') == \\\n    Success(['http', '://', 'drhagen.com', '/blog/sane-equality/'])\n```\n\n----------------------------------------\n\nTITLE: Implementing Alternative Number Parsers in Python Using Parsita\nDESCRIPTION: Demonstrates using the '|' operator to create alternative parsers for parsing integers and real numbers. Shows how to combine parsers for different number formats and convert results to appropriate types.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/alternative_parsers.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass NumberParsers(ParserContext):\n    integer = reg(r'[-+]?[0-9]+') > int\n    real = reg(r'[+-]?\\d+\\.\\d+(e[+-]?\\d+)?') | 'nan' | 'inf' > float\n    number = real | integer\n\nassert NumberParsers.number.parse('4.0000') == Success(4.0)\n```\n\n----------------------------------------\n\nTITLE: Using Discard Operators (>> and <<) for Point Coordinate Parsing in Python\nDESCRIPTION: This example demonstrates the discard left (>>) and discard right (<<) operators in Parsita, which match the same text as the basic sequential operator but discard unwanted elements. Here they're used to parse coordinate points, keeping only the numeric values.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/sequential_parsers.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass PointParsers(ParserContext, whitespace=r'[ ]*'):\n    integer = reg(r'[-+]?[0-9]+') > int\n    point = '(' >> integer << ',' & integer << ')'\n\nassert PointParsers.point.parse('(4, 3)') == Success([4, 3])\n```\n\n----------------------------------------\n\nTITLE: Implementing Summation Parser with Repeated Elements in Python\nDESCRIPTION: Demonstrates how to create a parser that handles repeated integers separated by plus signs and calculates their sum. Uses the rep() function to match multiple integers and combines them using a lambda function.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/repeated_parsers.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass SummationParsers(ParserContext, whitespace=r'[ ]*'):\n    integer = reg(r'[-+]?[0-9]+') > int\n    summation = integer & rep('+' >> integer) > (lambda x: sum([x[0]] + x[1]))\n\nassert SummationParsers.summation.parse('1 + 1 + 2 + 3 + 5') == Success(12)\n```\n\n----------------------------------------\n\nTITLE: Implementing Validation Logic with Parsita's Transformation Parser\nDESCRIPTION: Uses the >= operator to implement fallible conversion for input validation. The example creates a Percent class and ensures that parsed integer values are between 0 and 100, returning failures for invalid inputs.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/conversion_parsers.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\nfrom parsita import *\n\n@dataclass\nclass Percent:\n    number: int\n\ndef to_percent(number: int) -> Parser[str, Percent]:\n    if not 0 <= number <= 100:\n        return failure(\"a number between 0 and 100\")\n    else:\n        return success(Percent(number))\n\nclass PercentParsers(ParserContext):\n    percent = (reg(r\"[0-9]+\") > int) >= to_percent\n\nassert PercentParsers.percent.parse('50') == Success(Percent(50))\nassert isinstance(PercentParsers.percent.parse('150'), Failure)\n```\n\n----------------------------------------\n\nTITLE: Converting Text to Integers with Parsita's Conversion Parser\nDESCRIPTION: Uses the > operator to convert parsed string values to integers. The example creates an IntegerParsers class that defines an integer parser which matches number patterns and converts them to Python int objects.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/conversion_parsers.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass IntegerParsers(ParserContext):\n    integer = reg(r'[-+]?[0-9]+') > int\n\nassert IntegerParsers.integer.parse('-128') == Success(-128)\n```\n\n----------------------------------------\n\nTITLE: Using literal parsers with Parsita\nDESCRIPTION: Demonstrates how to create and use a literal parser with the `lit` function in Parsita. The example shows creating a parser that matches the exact string 'Hello World!' and how success and failure cases are handled.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/terminal_parsers.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass HelloParsers(ParserContext):\n    hello = lit('Hello World!')\n\nassert HelloParsers.hello.parse('Hello World!') == Success('Hello World!')\nassert isinstance(HelloParsers.hello.parse('Goodbye'), Failure)\n```\n\n----------------------------------------\n\nTITLE: Using regular expression parsers with Parsita\nDESCRIPTION: Shows how to create and use a regular expression parser with the `reg` function in Parsita. The example demonstrates creating a parser that matches integer strings using a regex pattern and tests it with a negative integer.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/terminal_parsers.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass IntegerParsers(ParserContext):\n    integer = reg(r'[-+]?[0-9]+')\n\nassert IntegerParsers.integer.parse('-128') == Success('-128')\n```\n\n----------------------------------------\n\nTITLE: Creating List Parser with Separated Repeated Elements in Python\nDESCRIPTION: Shows how to implement a parser for comma-separated integers within square brackets using repsep(). The parser handles multiple integers separated by commas and returns them as a list.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/repeated_parsers.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass ListParsers(ParserContext, whitespace=r'[ ]*'):\n    integer = reg(r'[-+]?[0-9]+') > int\n    my_list = '[' >> repsep(integer, ',') << ']'\n\nassert ListParsers.my_list.parse('[1,2,3]') == Success([1, 2, 3])\n```\n\n----------------------------------------\n\nTITLE: Creating Context-Dependent Parsers with Parsita's Transformation Parser\nDESCRIPTION: Uses the >= operator to select different parsers based on previous parsing results. The example parses a type specifier first ('int' or 'decimal') and then selects the appropriate parser for the subsequent number.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/conversion_parsers.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\ndef select_parser(type: str):\n    if type == 'int':\n        return reg(r\"[0-9]+\") > int\n    elif type == 'decimal':\n        return reg(r\"[0-9]+\\.[0-9]+\") > float\n\nclass NumberParsers(ParserContext, whitespace=r'[ ]*'):\n    type = lit('int', 'decimal')\n    number = type >= select_parser\n\nassert NumberParsers.number.parse('int 5') == Success(5)\nassert isinstance(NumberParsers.number.parse('int 2.0'), Failure)\n```\n\n----------------------------------------\n\nTITLE: Using Predicate Parser to Validate Parsed Values\nDESCRIPTION: Demonstrates how to use the pred() parser to validate an ordered pair in an interval. The predicate parser matches the initial parser and then validates the result with a test function, only succeeding if the function returns True.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/miscellaneous_parsers.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass IntervalParsers(ParserContext, whitespace=r'[ ]*'):\n    number = reg('\\d+') > int\n    pair = '[' >> number << ',' & number << ']'\n    interval = pred(pair, lambda x: x[0] <= x[1], 'ordered pair')\n\nassert IntervalParsers.interval.parse('[1, 2]') == Success([1, 2])\nassert IntervalParsers.interval.parse('[2, 1]') != Success([2, 1])\n```\n\n----------------------------------------\n\nTITLE: Using Longest Alternative Parser in Parsita\nDESCRIPTION: Shows implementation of the longest() parser which matches multiple parsers and returns the result of the one that consumed the most input. Used for parsing expressions with functions and names.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/alternative_parsers.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass ExpressionParsers(ParserContext):\n    name = reg(r'[a-zA-Z_]+')\n    function = name & '(' >> expression << ')'\n    expression = longest(name, function)\n\nassert ExpressionParsers.expression.parse('f(x)') == Success(['f', 'x'])\n```\n\n----------------------------------------\n\nTITLE: First Alternative Parser Implementation in Parsita\nDESCRIPTION: Demonstrates the first() parser which returns the result of the first successful parser match. Shows example with keyword, function and name parsing with early return behavior.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/alternative_parsers.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass ExpressionParsers(ParserContext):\n    keyword = lit('pi', 'nan', 'inf')\n    name = reg(r'[a-zA-Z_]+')\n    function = name & '(' >> expression << ')'\n    expression = first(keyword, function, name)\n\nassert ExpressionParsers.expression.parse('f(x)') == Success(['f', 'x'])\nassert str(ExpressionParsers.expression.parse('pi(x)').failure()) == (\n    \"Expected end of source but found '('\\\n\"\n    \"Line 1, character 3\\n\\n\"\n    \"pi(x)\\n\"\n    \"  ^  \"\n)\n```\n\n----------------------------------------\n\nTITLE: Optional Parser Implementation in Parsita\nDESCRIPTION: Shows usage of opt() parser which makes elements optional in the grammar. Demonstrates parsing declarations with optional type annotations.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/alternative_parsers.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass DeclarationParsers(ParserContext, whitespace=r'[ ]*'):\n    id = reg(r'[A-Za-z_][A-Za-z0-9_]*')\n    declaration = id & opt(':' >> id)\n\nassert DeclarationParsers.declaration.parse('x: int') == Success(['x', ['int']])\nassert DeclarationParsers.declaration.parse('x') == Success(['x', []])\n```\n\n----------------------------------------\n\nTITLE: Creating Forward Declarations with fwd() Parser\nDESCRIPTION: Demonstrates how to use the fwd() parser to create forward declarations for recursive parsers. This is useful when working outside of ParserContext classes or to make IDEs happier with parser definitions.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/miscellaneous_parsers.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass AddingParsers(ParserContext):\n    number = reg(r'[+-]?\\d+') > int\n    expr = fwd()\n    base = '(' >> expr << ')' | number\n    expr.define(rep1sep(base, '+') > sum)\n\nassert AddingParsers.expr.parse('2+(1+2)+3') == Success(8)\n```\n\n----------------------------------------\n\nTITLE: Implementing Heredoc Parsing with until() Parser\nDESCRIPTION: Shows how to use the until() parser to implement heredoc-style parsing, where content is consumed until a specific token is encountered. The until parser consumes input without matching the member parser.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/miscellaneous_parsers.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass TestParser(ParserContext, whitespace=r'\\s*'):\n    heredoc = reg(\"[A-Za-z]+\") >= (lambda token: until(token) << token)\n\ncontent = \"EOF\\nAnything at all\\nEOF\"\nassert TestParser.heredoc.parse(content) == Success(\"Anything at all\\n\")\n```\n\n----------------------------------------\n\nTITLE: Using any1 Parser for Single Element Matching\nDESCRIPTION: Demonstrates the any1 parser which matches any single input element. This is particularly useful when parsing non-text input types and combining with the pred() parser to apply predicates to single tokens.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/miscellaneous_parsers.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass DigitParsers(ParserContext):\n    digit = pred(any1, lambda x: x['type'] == 'digit', 'a digit') > \\\n        (lambda x: x['payload'])\n\nassert DigitParsers.digit.parse([{'type': 'digit', 'payload': 3}]) == \\\n    Success(3)\n```\n\n----------------------------------------\n\nTITLE: Using constant() to create a function that always returns the same value\nDESCRIPTION: Demonstrates how to use the constant() utility function to create parsers that evaluate to specific values regardless of input. This example creates boolean parsers that convert string literals into Python boolean values.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/utility_functions.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\nfrom parsita.util import constant\n\nclass BooleanParsers(ParserContext):\n    true = lit('true') > constant(True)\n    false = lit('false') > constant(False)\n    boolean = true | false\n\nassert BooleanParsers.boolean.parse('false') == Success(False)\n```\n\n----------------------------------------\n\nTITLE: Using splat() to convert a multi-argument function for use with sequential parsers\nDESCRIPTION: Shows how to use the splat() utility function to adapt a multi-argument function to work with the single list argument that sequential parsers produce. This example creates a URL parser that builds a named tuple from components.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/utility_functions.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom collections import namedtuple\nfrom parsita import *\nfrom parsita.util import splat\n\nUrl = namedtuple('Url', ['host', 'port', 'path'])\n\nclass UrlParsers(ParserContext):\n    host = reg(r'[A-Za-z0-9.]+')\n    port = reg(r'[0-9]+') > int\n    path = reg(r'[-._~A-Za-z0-9/]*')\n    url = 'https://' >> host << ':' & port & path > splat(Url)\nassert UrlParsers.url.parse('https://drhagen.com:443/blog/') == \\\n    Success(Url('drhagen.com', 443, '/blog/'))\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Parser Results with Python 3.10+\nDESCRIPTION: Shows how to use pattern matching with Success and Failure cases when parsing input strings. This example demonstrates modern Python 3.10+ syntax for handling parser results.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/getting_started.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass NumericListParsers(ParserContext, whitespace=r'[ ]*'):\n    integer_list = '[' >> repsep(reg('[+-]?[0-9]+') > int, ',') << ']'\n\nresult = NumericListParsers.integer_list.parse('[1, 1, 2, 3, 5]')\n\nmatch result:\n    case Success(value):\n        python_list = value\n    case Failure(error):\n        raise error\n```\n\n----------------------------------------\n\nTITLE: Pre-Python 3.10 Parser Result Handling\nDESCRIPTION: Demonstrates how to handle parser results using isinstance() checks for Python versions before 3.10. Shows traditional error handling approach with Success and Failure cases.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/getting_started.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass NumericListParsers(ParserContext, whitespace=r'[ ]*'):\n    integer_list = '[' >> repsep(reg('[+-]?[0-9]+') > int, ',') << ']'\n\nresult = NumericListParsers.integer_list.parse('[1, 1, 2, 3, 5]')\n\nif isinstance(result, Success):\n    python_list = result.unwrap()\nelif isinstance(result, Failure):\n    raise result.failure()\n```\n\n----------------------------------------\n\nTITLE: Handling End of File with eof Parser\nDESCRIPTION: Shows how to use the eof parser to match the end of the input stream. This is useful for indicating that a preceding parser is only valid at the end of input or when an end token may be omitted at the end.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/miscellaneous_parsers.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass OptionsParsers(ParserContext):\n    option = reg(r'[A-Za-z]+') << '=' & reg(r'[A-Za-z]+') << (';' | eof)\n    options = rep(option)\n\nassert OptionsParsers.options.parse('log=warn;detail=minimal;') == \\\n    Success([['log', 'warn'], ['detail', 'minimal']])\nassert OptionsParsers.options.parse('log=warn;detail=minimal') == \\\n    Success([['log', 'warn'], ['detail', 'minimal']])\n```\n\n----------------------------------------\n\nTITLE: Debugging Parsers with debug() Parser\nDESCRIPTION: Shows how to use the debug() parser for debugging parsing issues. It provides a verbose flag and a callback hook without affecting input or output, allowing for inspection of parsing state through breakpoints.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/miscellaneous_parsers.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom decimal import Decimal\n\nfrom parsita import *\n\ndef temp(parser, reader):\n    # Can put a breakpoint here to inspect why the decimal parser is capturing\n    # Spoiler: use `\\.` instead of `.` in regexes\n    pass\n\nclass NumberParsers(ParserContext):\n    integer = reg(r'[-+]?[0-9]+') > int\n    decimal = debug(reg(r'[-+]?[0-9]+.[0-9]+'), callback=temp) > Decimal\n    scientific = reg(r'[-+]?[0-9]+e[-+]?[0-9]+') > float\n    number = decimal | scientific | integer\n\n# Assertion is broken and needs debugged\nassert isinstance(NumberParsers.number.parse('1e5').unwrap(), float)\n```\n\n----------------------------------------\n\nTITLE: Using success() Parser as a Value Placeholder\nDESCRIPTION: Shows how to use the success() parser which always succeeds with a given value while consuming no input. It's useful for inserting arbitrary values in complex parsers, especially during prototyping.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/miscellaneous_parsers.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass HostnameParsers(ParserContext):\n    port = success(80)  # TODO: do not just ignore other ports\n    host = rep1sep(reg('[A-Za-z0-9]+([-]+[A-Za-z0-9]+)*'), '.')\n    server = host & port\n\nassert HostnameParsers.server.parse('drhagen.com') == Success([['drhagen', 'com'], 80])\n```\n\n----------------------------------------\n\nTITLE: Using failure() Parser for Custom Error Messages\nDESCRIPTION: Demonstrates the failure() parser which always fails with a custom message. This is useful for marking unimplemented sections or providing better error messages for common input mistakes during development.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/miscellaneous_parsers.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita import *\n\nclass HostnameParsers(ParserContext):\n    # TODO: implement allowing different port\n    port = lit('80') | reg('[0-9]+') & failure('no other port than 80')\n    host = rep1sep(reg('[A-Za-z0-9]+([-]+[A-Za-z0-9]+)*'), '.')\n    server = host << ':' & port\n\nassert str(HostnameParsers.server.parse('drhagen.com:443').failure()) == (\n    'Expected no other port than 80 but found end of source'\n)\n```\n\n----------------------------------------\n\nTITLE: Using unsplat() to convert a single-list function to take multiple arguments\nDESCRIPTION: Demonstrates the unsplat() utility function, which is the opposite of splat(). It converts a function that takes a single list argument into one that accepts multiple arguments. This example compares the behavior of splat() and unsplat() with sum functions.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/utility_functions.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom parsita.util import splat, unsplat\n\ndef sum_args(*x):\n    return sum(x)\n\ndef sum_list(x):\n    return sum(x)\n\nsplatted_sum_args = splat(sum_args)\nunsplatted_sum_list = unsplat(sum_list)\n\nassert unsplatted_sum_list(2, 3, 5) == sum_args(2, 3, 5)\nassert splatted_sum_args([2, 3, 5]) == sum_list([2, 3, 5])\n```\n\n----------------------------------------\n\nTITLE: Installing Parsita using pip\nDESCRIPTION: Command to install the Parsita library from PyPI using pip package manager.\nSOURCE: https://github.com/drhagen/parsita/blob/master/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install parsita\n```\n\n----------------------------------------\n\nTITLE: Installing Parsita via pip\nDESCRIPTION: Installation command for the Parsita library using pip package manager from PyPI.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/index.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install parsita\n```\n\n----------------------------------------\n\nTITLE: Cloning Parsita Repository with Git\nDESCRIPTION: Command to clone the Parsita repository from GitHub using Git.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/contributing.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/drhagen/parsita.git\n```\n\n----------------------------------------\n\nTITLE: Installing Parsita and Dependencies with Poetry\nDESCRIPTION: Commands to install Poetry and use it to install Parsita and its dependencies from source.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/contributing.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install poetry\npoetry install\n```\n\n----------------------------------------\n\nTITLE: Running Parsita Tests with Nox\nDESCRIPTION: Command to run Parsita tests using Nox, which will test with all compatible Python versions.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/contributing.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npoetry run nox -s test\n```\n\n----------------------------------------\n\nTITLE: Running Parsita Tests for Specific Python Version\nDESCRIPTION: Command to run Parsita tests using Nox for a specific Python version (e.g., 3.9).\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/contributing.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npoetry run nox -s test-3.9\n```\n\n----------------------------------------\n\nTITLE: Running Code Quality Checks with Nox\nDESCRIPTION: Commands to run code formatting and linting checks using Nox.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/contributing.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\npoetry run nox -s format\npoetry run nox -s lint\n```\n\n----------------------------------------\n\nTITLE: Serving Parsita Documentation Locally\nDESCRIPTION: Command to serve Parsita documentation locally using MkDocs for development purposes.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/contributing.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\npoetry run mkdocs serve\n```\n\n----------------------------------------\n\nTITLE: Deploying Parsita Documentation to GitHub Pages\nDESCRIPTION: Command to deploy the current Parsita documentation to GitHub Pages using MkDocs.\nSOURCE: https://github.com/drhagen/parsita/blob/master/docs/contributing.md#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\npoetry run mkdocs gh-deploy\n```"
  }
]