[
  {
    "owner": "dapperlib",
    "repo": "dapper",
    "content": "TITLE: Basic Dapper API Usage Examples in C#\nDESCRIPTION: Core API examples showing how to perform database operations with Dapper. Demonstrates the main methods for executing queries that return single/multiple rows, and executing commands that don't return results.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// insert/update/delete etc\nvar count  = connection.Execute(sql [, args]);\n\n// multi-row query\nIEnumerable<T> rows = connection.Query<T>(sql [, args]);\n\n// single-row query ({Single|First}[OrDefault])\nT row = connection.QuerySingle<T>(sql [, args]);\n```\n\n----------------------------------------\n\nTITLE: Mapping Query Results to Typed Objects in Dapper\nDESCRIPTION: Example showing how to execute a query and map the results to a list of strongly-typed objects. Demonstrates parameter passing with anonymous types and mapping to a POCO class with properties.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Dog\n{\n    public int? Age { get; set; }\n    public Guid Id { get; set; }\n    public string Name { get; set; }\n    public float? Weight { get; set; }\n\n    public int IgnoredProperty { get { return 1; } }\n}\n\nvar guid = Guid.NewGuid();\nvar dog = connection.Query<Dog>(\"select Age = @Age, Id = @Id\", new { Age = (int?)null, Id = guid });\n\nAssert.Equal(1,dog.Count());\nAssert.Null(dog.First().Age);\nAssert.Equal(guid, dog.First().Id);\n```\n\n----------------------------------------\n\nTITLE: Query Methods in Dapper SqlMapper\nDESCRIPTION: Core querying methods that execute SQL and map results to dynamic or strongly-typed objects. Supports parameterized queries, transactions, and command timeouts.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.SqlMapper.Query<T>(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, bool buffered = true, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Collections.Generic.IEnumerable<T>!\n```\n\n----------------------------------------\n\nTITLE: Async Query Methods in Dapper SqlMapper\nDESCRIPTION: Asynchronous versions of query methods that return Tasks. Enables non-blocking database operations with the same functionality as synchronous methods.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.SqlMapper.QueryAsync<T>(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<T>!>!\n```\n\n----------------------------------------\n\nTITLE: Querying Customers with Dapper in C#\nDESCRIPTION: Demonstrates a basic Dapper query that selects customers from a database based on their region. Shows parameter passing and strong typing with the Customer class.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/docs/readme.md#2025-04-16_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nstring region = ...\nvar customers = connection.Query<Customer>(\n    \"select * from Customers where Region = @region\", // SQL\n    new { region } // parameters\n    ).AsList();\n```\n\n----------------------------------------\n\nTITLE: Mapping Query Results to Dynamic Objects in Dapper\nDESCRIPTION: Example demonstrating how to execute a SQL query and map the results to a list of dynamic objects. This allows accessing result properties without defining a class in advance.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar rows = connection.Query(\"select 1 A, 2 B union all select 3, 4\").AsList();\n\nAssert.Equal(1, (int)rows[0].A);\nAssert.Equal(2, (int)rows[0].B);\nAssert.Equal(3, (int)rows[1].A);\nAssert.Equal(4, (int)rows[1].B);\n```\n\n----------------------------------------\n\nTITLE: Executing Non-Query Commands in Dapper\nDESCRIPTION: Example showing how to execute a SQL command that doesn't return results, such as INSERT, UPDATE, DELETE or DDL statements. The return value is the number of affected rows.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar count = connection.Execute(@\"\n  set nocount on\n  create table #t(i int)\n  set nocount off\n  insert #t\n  select @a a union all select @b\n  set nocount on\n  drop table #t\", new {a=1, b=2 });\nAssert.Equal(2, count);\n```\n\n----------------------------------------\n\nTITLE: Basic Parameter Passing with Anonymous Objects in Dapper\nDESCRIPTION: Shows how to pass parameters using anonymous objects in Dapper queries, mapping parameter names automatically to SQL parameters.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nnew {A = 1, B = \"b\"} // A will be mapped to the param @A, B to the param @B\n```\n\n----------------------------------------\n\nTITLE: Executing Parameterized SQL Query with Dapper in C#\nDESCRIPTION: This method executes a parameterized SQL query using Dapper. It supports various parameter types and command types. The method returns the number of rows affected by the query.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic static int Execute(this IDbConnection cnn, string sql, object? param = null, IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null) =>\n    ExecuteImpl(cnn, new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.Buffered, default));\n```\n\n----------------------------------------\n\nTITLE: Retrieving First or Default Row from Query in Dapper\nDESCRIPTION: Methods for retrieving the first row from a query or a default value if no rows are returned. Provides both synchronous and asynchronous variants with support for dynamic, strongly typed, and object-typed results with various parameter options.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.SqlMapper.QueryFirstOrDefault(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> dynamic?\nstatic Dapper.SqlMapper.QueryFirstOrDefault(this System.Data.IDbConnection! cnn, System.Type! type, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> object?\nstatic Dapper.SqlMapper.QueryFirstOrDefault<T>(this System.Data.IDbConnection! cnn, Dapper.CommandDefinition command) -> T?\nstatic Dapper.SqlMapper.QueryFirstOrDefault<T>(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> T?\nstatic Dapper.SqlMapper.QueryFirstOrDefaultAsync(this System.Data.IDbConnection! cnn, Dapper.CommandDefinition command) -> System.Threading.Tasks.Task<dynamic?>!\nstatic Dapper.SqlMapper.QueryFirstOrDefaultAsync(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<dynamic?>!\nstatic Dapper.SqlMapper.QueryFirstOrDefaultAsync(this System.Data.IDbConnection! cnn, System.Type! type, Dapper.CommandDefinition command) -> System.Threading.Tasks.Task<object?>!\nstatic Dapper.SqlMapper.QueryFirstOrDefaultAsync(this System.Data.IDbConnection! cnn, System.Type! type, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<object?>!\nstatic Dapper.SqlMapper.QueryFirstOrDefaultAsync<T>(this System.Data.IDbConnection! cnn, Dapper.CommandDefinition command) -> System.Threading.Tasks.Task<T?>!\nstatic Dapper.SqlMapper.QueryFirstOrDefaultAsync<T>(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<T?>!\n```\n\n----------------------------------------\n\nTITLE: Executing SQL Query Asynchronously with Dapper in C#\nDESCRIPTION: This method executes a SQL query asynchronously using Dapper. It supports command type specification, parameter objects, and transaction management. The method returns the number of rows affected by the query.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic static Task<int> ExecuteAsync(this IDbConnection cnn, string sql, object? param = null, IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null) =>\n    ExecuteAsync(new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.Buffered, default));\n```\n\n----------------------------------------\n\nTITLE: Processing Multiple Result Sets in Dapper\nDESCRIPTION: Demonstrates how to process multiple result grids from a single query using Dapper's QueryMultiple method. This is useful for retrieving related data sets in a single database call.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nvar sql =\n@\"\nselect * from Customers where CustomerId = @id\nselect * from Orders where CustomerId = @id\nselect * from Returns where CustomerId = @id\";\n\nusing (var multi = connection.QueryMultiple(sql, new {id=selectedId}))\n{\n   var customer = multi.Read<Customer>().Single();\n   var orders = multi.Read<Order>().ToList();\n   var returns = multi.Read<Return>().ToList();\n   ...\n}\n```\n\n----------------------------------------\n\nTITLE: Dapper CommandDefinition Structure\nDESCRIPTION: Core structure for defining database commands in Dapper with support for command text, parameters, transactions, timeouts and command types.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nDapper.CommandDefinition.CommandDefinition(string! commandText, object? parameters = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null, Dapper.CommandFlags flags = Dapper.CommandFlags.Buffered, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> void\n```\n\n----------------------------------------\n\nTITLE: Querying Single or Default Records Asynchronously in Dapper\nDESCRIPTION: Static extension methods for asynchronously querying a single record or default value from a database using Dapper. These methods return the default value if no results exist and throw an exception if multiple results exist.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.SqlMapper.QuerySingleOrDefaultAsync(this System.Data.IDbConnection! cnn, Dapper.CommandDefinition command) -> System.Threading.Tasks.Task<dynamic?>!\nstatic Dapper.SqlMapper.QuerySingleOrDefaultAsync(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<dynamic?>!\nstatic Dapper.SqlMapper.QuerySingleOrDefaultAsync(this System.Data.IDbConnection! cnn, System.Type! type, Dapper.CommandDefinition command) -> System.Threading.Tasks.Task<object?>!\nstatic Dapper.SqlMapper.QuerySingleOrDefaultAsync(this System.Data.IDbConnection! cnn, System.Type! type, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<object?>!\nstatic Dapper.SqlMapper.QuerySingleOrDefaultAsync<T>(this System.Data.IDbConnection! cnn, Dapper.CommandDefinition command) -> System.Threading.Tasks.Task<T?>!\nstatic Dapper.SqlMapper.QuerySingleOrDefaultAsync<T>(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<T?>!\n```\n\n----------------------------------------\n\nTITLE: Batch Processing with Execute Method in Dapper\nDESCRIPTION: Examples of executing a command multiple times with different parameter values, useful for bulk operations. Demonstrates passing an array of anonymous types or a collection of objects as parameters.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar count = connection.Execute(@\"insert MyTable(colA, colB) values (@a, @b)\",\n    new[] { new { a=1, b=1 }, new { a=2, b=2 }, new { a=3, b=3 } }\n  );\nAssert.Equal(3, count); // 3 rows inserted: \"1,1\", \"2,2\" and \"3,3\"\n```\n\n----------------------------------------\n\nTITLE: Querying Single Records Asynchronously in Dapper\nDESCRIPTION: Static extension methods for querying exactly one record asynchronously from a database using Dapper. These methods throw an exception if there are no results or multiple results.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.SqlMapper.QuerySingleAsync(this System.Data.IDbConnection! cnn, System.Type! type, Dapper.CommandDefinition command) -> System.Threading.Tasks.Task<object!>!\nstatic Dapper.SqlMapper.QuerySingleAsync(this System.Data.IDbConnection! cnn, System.Type! type, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<object!>!\nstatic Dapper.SqlMapper.QuerySingleAsync<T>(this System.Data.IDbConnection! cnn, Dapper.CommandDefinition command) -> System.Threading.Tasks.Task<T>!\nstatic Dapper.SqlMapper.QuerySingleAsync<T>(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<T>!\n```\n\n----------------------------------------\n\nTITLE: Implementing Multi-Mapping in Dapper with Join Queries\nDESCRIPTION: Shows how to map rows from a join query to multiple objects using Dapper's multi-mapping functionality. This example joins posts and users tables and maps the results to nested Post objects containing User objects.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n(post, user) => { post.Owner = user; return post; }\n```\n\nLANGUAGE: csharp\nCODE:\n```\n<Post, User, Post>\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar sql =\n@\"select * from #Posts p\nleft join #Users u on u.Id = p.OwnerId\nOrder by p.Id\";\n\nvar data = connection.Query<Post, User, Post>(sql, (post, user) => { post.Owner = user; return post;});\nvar post = data.First();\n\nAssert.Equal(\"Sams Post1\", post.Content);\nAssert.Equal(1, post.Id);\nAssert.Equal(\"Sam\", post.Owner.Name);\nAssert.Equal(99, post.Owner.Id);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Single Row from Query in Dapper\nDESCRIPTION: Methods for retrieving exactly one row from a query, failing if no rows or multiple rows are returned. Provides both synchronous and asynchronous variants with support for dynamic, strongly typed, and object-typed results with various parameter options.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.SqlMapper.QuerySingle(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> dynamic!\nstatic Dapper.SqlMapper.QuerySingle(this System.Data.IDbConnection! cnn, System.Type! type, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> object!\nstatic Dapper.SqlMapper.QuerySingle<T>(this System.Data.IDbConnection! cnn, Dapper.CommandDefinition command) -> T\nstatic Dapper.SqlMapper.QuerySingle<T>(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> T\nstatic Dapper.SqlMapper.QuerySingleAsync(this System.Data.IDbConnection! cnn, Dapper.CommandDefinition command) -> System.Threading.Tasks.Task<dynamic!>!\nstatic Dapper.SqlMapper.QuerySingleAsync(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<dynamic!>!\n```\n\n----------------------------------------\n\nTITLE: Executing Multiple Queries in Dapper\nDESCRIPTION: Methods for executing multiple queries within a single command and processing the results through a GridReader. Provides both synchronous and asynchronous variants with support for CommandDefinition or direct SQL execution with various parameter options.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.SqlMapper.QueryMultiple(this System.Data.IDbConnection! cnn, Dapper.CommandDefinition command) -> Dapper.SqlMapper.GridReader!\nstatic Dapper.SqlMapper.QueryMultiple(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> Dapper.SqlMapper.GridReader!\nstatic Dapper.SqlMapper.QueryMultipleAsync(this System.Data.IDbConnection! cnn, Dapper.CommandDefinition command) -> System.Threading.Tasks.Task<Dapper.SqlMapper.GridReader!>!\nstatic Dapper.SqlMapper.QueryMultipleAsync(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<Dapper.SqlMapper.GridReader!>!\n```\n\n----------------------------------------\n\nTITLE: Querying Single or Default Records in Dapper\nDESCRIPTION: Static extension methods for querying a single record or default value from a database using Dapper. These methods return the default value if no results exist and throw an exception if multiple results exist.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.SqlMapper.QuerySingleOrDefault(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> dynamic?\nstatic Dapper.SqlMapper.QuerySingleOrDefault(this System.Data.IDbConnection! cnn, System.Type! type, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> object?\nstatic Dapper.SqlMapper.QuerySingleOrDefault<T>(this System.Data.IDbConnection! cnn, Dapper.CommandDefinition command) -> T?\nstatic Dapper.SqlMapper.QuerySingleOrDefault<T>(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> T?\n```\n\n----------------------------------------\n\nTITLE: Querying Unbuffered Results Asynchronously in Dapper\nDESCRIPTION: Static extension methods for executing SQL queries with async enumerable results that stream results without buffering the entire result set in memory. These methods are useful for processing large result sets efficiently.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.SqlMapper.QueryUnbufferedAsync(this System.Data.Common.DbConnection! cnn, string! sql, object? param = null, System.Data.Common.DbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Collections.Generic.IAsyncEnumerable<dynamic!>!\nstatic Dapper.SqlMapper.QueryUnbufferedAsync<T>(this System.Data.Common.DbConnection! cnn, string! sql, object? param = null, System.Data.Common.DbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Collections.Generic.IAsyncEnumerable<T>!\n```\n\n----------------------------------------\n\nTITLE: Selecting User Records with Dapper.Rainbow and Dapper in C#\nDESCRIPTION: C# code showing how to retrieve user records from the database. Demonstrates fetching a single user by ID using Dapper.Rainbow and retrieving all users using standard Dapper.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.Rainbow/readme.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar user = db.Users.Get(id); // Single user by ID\nvar users = connection.Query<User>(\"SELECT * FROM Users\"); // All users\n```\n\n----------------------------------------\n\nTITLE: Dynamic Parameter Building in Dapper\nDESCRIPTION: Demonstrates building SQL parameters dynamically using DynamicParameters class, allowing for conditional parameter addition and type specification.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n    var sqlPredicates = new List<string>();\n    var queryParams = new DynamicParameters();\n    if (boolExpression)\n    {\n        sqlPredicates.Add(\"column1 = @param1\");\n        queryParams.Add(\"param1\", dynamicValue1, System.Data.DbType.Guid);\n    } else {\n        sqlPredicates.Add(\"column2 = @param2\");\n        queryParams.Add(\"param2\", dynamicValue2, System.Data.DbType.String);\n    }\n```\n\n----------------------------------------\n\nTITLE: Executing a SQL Command with Parameters in Dapper (C#)\nDESCRIPTION: Extension method that executes a SQL command with parameters against an IDbConnection. It supports command type specification, command timeout, and transaction context.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Unshipped.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic static int Execute(this IDbConnection cnn, string sql, object? param = null, IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null) =>\n    CommandExecuter.ExecuteImpl(cnn, new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.Buffered));\n```\n\n----------------------------------------\n\nTITLE: Multiple Parameter Object Support in Dapper\nDESCRIPTION: Shows how to combine parameters from multiple objects using DynamicParameters' AddDynamicParams method.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n    var queryParams = new DynamicParameters(objectOfType1);\n    queryParams.AddDynamicParams(objectOfType2);\n```\n\n----------------------------------------\n\nTITLE: Executing a SQL Query Returning a Scalar Value in Dapper (C#)\nDESCRIPTION: Extension method that executes a SQL query with parameters, returning a scalar value. It supports type specification, command type, timeout, and transaction context.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Unshipped.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static T ExecuteScalar<T>(this IDbConnection cnn, string sql, object? param = null, IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null) =>\n    CommandExecuter.ExecuteScalarImpl<T>(cnn, new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.Buffered));\n```\n\n----------------------------------------\n\nTITLE: Bulk Insert with Existing Collection in Dapper\nDESCRIPTION: Example showing how to execute a bulk insert operation using an existing collection of objects. Dapper accepts any parameter that implements IEnumerable<T> for batch operations.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar foos = new List<Foo>\n{\n    { new Foo { A = 1, B = 1 } }\n    { new Foo { A = 2, B = 2 } }\n    { new Foo { A = 3, B = 3 } }\n};\n\nvar count = connection.Execute(@\"insert MyTable(colA, colB) values (@a, @b)\", foos);\nAssert.Equal(foos.Count, count);\n```\n\n----------------------------------------\n\nTITLE: List Parameter Handling in Dapper\nDESCRIPTION: Demonstrates Dapper's automatic parameterization of IEnumerable values in queries.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nconnection.Query<int>(\"select * from (select 1 as Id union all select 2 union all select 3) as X where Id in @Ids\", new { Ids = new int[] { 1, 2, 3 } });\n```\n\n----------------------------------------\n\nTITLE: Executing Stored Procedures with Dapper\nDESCRIPTION: Shows how to execute stored procedures using Dapper, with examples of both simple execution and handling output parameters and return values.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\nvar user = cnn.Query<User>(\"spGetUser\", new {Id = 1},\n        commandType: CommandType.StoredProcedure).SingleOrDefault();\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar p = new DynamicParameters();\np.Add(\"@a\", 11);\np.Add(\"@b\", dbType: DbType.Int32, direction: ParameterDirection.Output);\np.Add(\"@c\", dbType: DbType.Int32, direction: ParameterDirection.ReturnValue);\n\ncnn.Execute(\"spMagicProc\", p, commandType: CommandType.StoredProcedure);\n\nint b = p.Get<int>(\"@b\");\nint c = p.Get<int>(\"@c\");\n```\n\n----------------------------------------\n\nTITLE: Generated SQL for List Parameters in Dapper\nDESCRIPTION: Shows how Dapper translates list parameters into individual SQL parameters internally.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nselect * from (select 1 as Id union all select 2 union all select 3) as X where Id in (@Ids1, @Ids2, @Ids3)\" // @Ids1 = 1 , @Ids2 = 2 , @Ids2 = 3\n```\n\n----------------------------------------\n\nTITLE: Defining Database Context and Entity Classes for Dapper.Rainbow\nDESCRIPTION: C# class definitions for database context and entity model. The MyDatabase class inherits from Database<T> and contains a Table<User> property, following Dapper.Rainbow conventions.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.Rainbow/readme.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing Dapper;\nusing System.Data;\n\npublic class MyDatabase : Database<MyDatabase>\n{\n    public Table<User> Users { get; set; }\n}\n\npublic class User\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public string Email { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Multiple Types with Async in Dapper (3-4 Type Parameters)\nDESCRIPTION: Methods for executing asynchronous queries that map to multiple object types (3-4 parameters) and combine them into a result using a mapping function. Supports both SQL string and CommandDefinition with options for parameters, transactions, buffering, and command timeouts.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.SqlMapper.QueryAsync<TFirst, TSecond, TThird, TFourth, TReturn>(this System.Data.IDbConnection! cnn, Dapper.CommandDefinition command, System.Func<TFirst, TSecond, TThird, TFourth, TReturn>! map, string! splitOn = \"Id\") -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<TReturn>!>!\nstatic Dapper.SqlMapper.QueryAsync<TFirst, TSecond, TThird, TFourth, TReturn>(this System.Data.IDbConnection! cnn, string! sql, System.Func<TFirst, TSecond, TThird, TFourth, TReturn>! map, object? param = null, System.Data.IDbTransaction? transaction = null, bool buffered = true, string! splitOn = \"Id\", int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<TReturn>!>!\nstatic Dapper.SqlMapper.QueryAsync<TFirst, TSecond, TThird, TReturn>(this System.Data.IDbConnection! cnn, Dapper.CommandDefinition command, System.Func<TFirst, TSecond, TThird, TReturn>! map, string! splitOn = \"Id\") -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<TReturn>!>!\nstatic Dapper.SqlMapper.QueryAsync<TFirst, TSecond, TThird, TReturn>(this System.Data.IDbConnection! cnn, string! sql, System.Func<TFirst, TSecond, TThird, TReturn>! map, object? param = null, System.Data.IDbTransaction? transaction = null, bool buffered = true, string! splitOn = \"Id\", int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<TReturn>!>!\n```\n\n----------------------------------------\n\nTITLE: Inserting User Records with Dapper.Rainbow in C#\nDESCRIPTION: C# code demonstrating how to insert a new user record into the database using Dapper.Rainbow. This snippet creates a new User object and inserts it into the Users table.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.Rainbow/readme.md#2025-04-16_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar db = new MyDatabase { Connection = connection };\nvar newUser = new User { Name = \"John Doe\", Email = \"john.doe@example.com\" };\nvar insertedUser = db.Users.Insert(newUser);\n```\n\n----------------------------------------\n\nTITLE: Querying Multiple Types with Async in Dapper (6-7 Type Parameters)\nDESCRIPTION: Methods for executing asynchronous queries that map to multiple object types (up to 6-7 parameters) and combine them into a result using a mapping function. Supports both SQL string and CommandDefinition with options for parameters, transactions, buffering, and command timeouts.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.SqlMapper.QueryAsync<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn>(this System.Data.IDbConnection! cnn, string! sql, System.Func<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn>! map, object? param = null, System.Data.IDbTransaction? transaction = null, bool buffered = true, string! splitOn = \"Id\", int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<TReturn>!>!\nstatic Dapper.SqlMapper.QueryAsync<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn>(this System.Data.IDbConnection! cnn, Dapper.CommandDefinition command, System.Func<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn>! map, string! splitOn = \"Id\") -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<TReturn>!>!\nstatic Dapper.SqlMapper.QueryAsync<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn>(this System.Data.IDbConnection! cnn, string! sql, System.Func<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn>! map, object? param = null, System.Data.IDbTransaction? transaction = null, bool buffered = true, string! splitOn = \"Id\", int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<TReturn>!>!\n```\n\n----------------------------------------\n\nTITLE: Executing SQL Query with Command Definition in Dapper C#\nDESCRIPTION: This method executes a SQL query using a CommandDefinition object in Dapper. It handles different command types and supports both synchronous and asynchronous execution based on the cancellation token.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static int Execute(this IDbConnection cnn, CommandDefinition command) =>\n    ExecuteImpl(cnn, command);\n```\n\n----------------------------------------\n\nTITLE: Dapper SqlMapper Settings Configuration\nDESCRIPTION: Static properties to configure global settings for Dapper's SqlMapper behavior. These settings control various aspects like null handling, parameter tokens, command timeouts, and optimizations for query execution.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.SqlMapper.Settings.ApplyNullValues.get -> bool\nstatic Dapper.SqlMapper.Settings.ApplyNullValues.set -> void\nstatic Dapper.SqlMapper.Settings.SupportLegacyParameterTokens.get -> bool\nstatic Dapper.SqlMapper.Settings.SupportLegacyParameterTokens.set -> void\nstatic Dapper.SqlMapper.Settings.CommandTimeout.get -> int?\nstatic Dapper.SqlMapper.Settings.CommandTimeout.set -> void\nstatic Dapper.SqlMapper.Settings.FetchSize.get -> long\nstatic Dapper.SqlMapper.Settings.FetchSize.set -> void\nstatic Dapper.SqlMapper.Settings.InListStringSplitCount.get -> int\nstatic Dapper.SqlMapper.Settings.InListStringSplitCount.set -> void\nstatic Dapper.SqlMapper.Settings.PadListExpansions.get -> bool\nstatic Dapper.SqlMapper.Settings.PadListExpansions.set -> void\nstatic Dapper.SqlMapper.Settings.SetDefaults() -> void\nstatic Dapper.SqlMapper.Settings.UseIncrementalPseudoPositionalParameterNames.get -> bool\nstatic Dapper.SqlMapper.Settings.UseIncrementalPseudoPositionalParameterNames.set -> void\nstatic Dapper.SqlMapper.Settings.UseSingleResultOptimization.get -> bool\nstatic Dapper.SqlMapper.Settings.UseSingleResultOptimization.set -> void\nstatic Dapper.SqlMapper.Settings.UseSingleRowOptimization.get -> bool\nstatic Dapper.SqlMapper.Settings.UseSingleRowOptimization.set -> void\n```\n\n----------------------------------------\n\nTITLE: Basic SqlBuilder Template Example in C#\nDESCRIPTION: Demonstrates how to use SqlBuilder to generate multiple SQL templates from a composed query. Shows building WHERE and ORDER BY clauses and retrieving both count and detailed data results.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.SqlBuilder/Readme.md#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = new SqlBuilder()\n    .Where(\"a = @a\", new { a = 1 })\n    .Where(\"b = @b\", new { b = 2 })\n    .OrderBy(\"a\")\n    .OrderBy(\"b\");\nvar counter = builder.AddTemplate(\"select count(*) from table /**where**/);\nvar selector = builder.AddTemplate(\"select * from table /**where**/ /**orderby**/);\nvar count = cnn.Query(counter.RawSql, counter.Parameters).Single();\nvar rows = cnn.Query(selector.RawSql, selector.Parameters);\n```\n\n----------------------------------------\n\nTITLE: Executing a Command Definition for Scalar Value in Dapper (C#)\nDESCRIPTION: Extension method that executes a pre-configured CommandDefinition against an IDbConnection, returning a scalar value of type T.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Unshipped.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic static T ExecuteScalar<T>(this IDbConnection cnn, CommandDefinition command) =>\n    CommandExecuter.ExecuteScalarImpl<T>(cnn, command);\n```\n\n----------------------------------------\n\nTITLE: Defining Entity Classes for Multi-Mapping in Dapper\nDESCRIPTION: Defines Post and User classes that demonstrate the relationship structure needed for multi-mapping in Dapper. This allows joining related tables and mapping results to nested object structures.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nclass Post\n{\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public string Content { get; set; }\n    public User Owner { get; set; }\n}\n\nclass User\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Multi-Mapping Query Methods in Dapper\nDESCRIPTION: Methods for mapping multiple result sets to different types with custom mapping functions. Supports up to seven type parameters for complex object relationships.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.SqlMapper.Query<TFirst, TSecond, TReturn>(this System.Data.IDbConnection! cnn, string! sql, System.Func<TFirst, TSecond, TReturn>! map, object? param = null, System.Data.IDbTransaction? transaction = null, bool buffered = true, string! splitOn = \"Id\", int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Collections.Generic.IEnumerable<TReturn>!\n```\n\n----------------------------------------\n\nTITLE: Retrieving First Row from Query in Dapper\nDESCRIPTION: Methods for retrieving only the first row from a query, failing if no rows are returned. Provides both synchronous and asynchronous variants with support for dynamic, strongly typed, and object-typed results with various parameter options.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.SqlMapper.QueryFirst(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> dynamic!\nstatic Dapper.SqlMapper.QueryFirst(this System.Data.IDbConnection! cnn, System.Type! type, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> object!\nstatic Dapper.SqlMapper.QueryFirst<T>(this System.Data.IDbConnection! cnn, Dapper.CommandDefinition command) -> T\nstatic Dapper.SqlMapper.QueryFirst<T>(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> T\nstatic Dapper.SqlMapper.QueryFirstAsync(this System.Data.IDbConnection! cnn, Dapper.CommandDefinition command) -> System.Threading.Tasks.Task<dynamic!>!\nstatic Dapper.SqlMapper.QueryFirstAsync(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<dynamic!>!\nstatic Dapper.SqlMapper.QueryFirstAsync(this System.Data.IDbConnection! cnn, System.Type! type, Dapper.CommandDefinition command) -> System.Threading.Tasks.Task<object!>!\nstatic Dapper.SqlMapper.QueryFirstAsync(this System.Data.IDbConnection! cnn, System.Type! type, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<object!>!\nstatic Dapper.SqlMapper.QueryFirstAsync<T>(this System.Data.IDbConnection! cnn, Dapper.CommandDefinition command) -> System.Threading.Tasks.Task<T>!\nstatic Dapper.SqlMapper.QueryFirstAsync<T>(this System.Data.IDbConnection! cnn, string! sql, object? param = null, System.Data.IDbTransaction? transaction = null, int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<T>!\n```\n\n----------------------------------------\n\nTITLE: Dapper DynamicParameters Class Methods\nDESCRIPTION: Methods for handling dynamic parameter addition and manipulation in database queries with support for various parameter types and directions.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nDapper.DynamicParameters.Add(string! name, object? value = null, System.Data.DbType? dbType = null, System.Data.ParameterDirection? direction = null, int? size = null, byte? precision = null, byte? scale = null) -> void\n```\n\n----------------------------------------\n\nTITLE: Dapper GridReader Implementation\nDESCRIPTION: Methods for reading multiple result sets from database queries with support for different return types and mapping functions.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nDapper.SqlMapper.GridReader.Read<TFirst, TSecond, TReturn>(System.Func<TFirst, TSecond, TReturn>! func, string! splitOn = \"id\", bool buffered = true) -> System.Collections.Generic.IEnumerable<TReturn>!\n```\n\n----------------------------------------\n\nTITLE: SqlBuilder Extension Methods Overview in C#\nDESCRIPTION: Lists all available extension methods in the Dapper.SqlBuilder library, providing various SQL clause building functionality like Select, Where, OrderBy, etc.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.SqlBuilder/Readme.md#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nSqlBuilder AddParameters(dynamic parameters);\nSqlBuilder Select(string sql, dynamic parameters = null);\nSqlBuilder Where(string sql, dynamic parameters = null);\nSqlBuilder OrWhere(string sql, dynamic parameters = null);\nSqlBuilder OrderBy(string sql, dynamic parameters = null);\nSqlBuilder GroupBy(string sql, dynamic parameters = null);\nSqlBuilder Having(string sql, dynamic parameters = null);\nSqlBuilder Set(string sql, dynamic parameters = null);\nSqlBuilder Join(string sql, dynamic parameters = null);\nSqlBuilder InnerJoin(string sql, dynamic parameters = null);\nSqlBuilder LeftJoin(string sql, dynamic parameters = null);\nSqlBuilder RightJoin(string sql, dynamic parameters = null);\nSqlBuilder Intersect(string sql, dynamic parameters = null);\n```\n\n----------------------------------------\n\nTITLE: Using ANSI String Parameters in Dapper\nDESCRIPTION: Demonstrates how to properly pass varchar parameters in Dapper using the DbString class, which allows specifying string properties like length, fixed length, and ANSI vs Unicode.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\nQuery<Thing>(\"select * from Thing where Name = @Name\", new {Name = new DbString { Value = \"abcde\", IsFixedLength = true, Length = 10, IsAnsi = true }});\n```\n\n----------------------------------------\n\nTITLE: Querying with Dynamic Type Arrays in Dapper\nDESCRIPTION: Method for executing queries with dynamic type mapping using an array of types and a mapping function. The query results are combined into a return type using the provided mapping function with support for various parameters and options.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.SqlMapper.QueryAsync<TReturn>(this System.Data.IDbConnection! cnn, string! sql, System.Type![]! types, System.Func<object![]!, TReturn>! map, object? param = null, System.Data.IDbTransaction? transaction = null, bool buffered = true, string! splitOn = \"Id\", int? commandTimeout = null, System.Data.CommandType? commandType = null) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<TReturn>!>!\nstatic Dapper.SqlMapper.QueryCachePurged -> System.EventHandler?\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Switching Per Row in Dapper\nDESCRIPTION: Shows how to parse different rows as different data types using IDataReader.GetRowParser. This technique allows mapping rows to different object types based on a type discriminator column.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\nvar shapes = new List<IShape>();\nusing (var reader = connection.ExecuteReader(\"select * from Shapes\"))\n{\n    // Generate a row parser for each type you expect.\n    // The generic type <IShape> is what the parser will return.\n    // The argument (typeof(*)) is the concrete type to parse.\n    var circleParser = reader.GetRowParser<IShape>(typeof(Circle));\n    var squareParser = reader.GetRowParser<IShape>(typeof(Square));\n    var triangleParser = reader.GetRowParser<IShape>(typeof(Triangle));\n\n    var typeColumnIndex = reader.GetOrdinal(\"Type\");\n\n    while (reader.Read())\n    {\n        IShape shape;\n        var type = (ShapeType)reader.GetInt32(typeColumnIndex);\n        switch (type)\n        {\n            case ShapeType.Circle:\n            \tshape = circleParser(reader);\n            \tbreak;\n            case ShapeType.Square:\n            \tshape = squareParser(reader);\n            \tbreak;\n            case ShapeType.Triangle:\n            \tshape = triangleParser(reader);\n            \tbreak;\n            default:\n            \tthrow new NotImplementedException();\n        }\n\n      \tshapes.Add(shape);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing a SQL Reader Operation in Dapper (C#)\nDESCRIPTION: Extension method that executes a SQL query with parameters and provides the raw data reader. It supports command type specification, timeout, and transaction context.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Unshipped.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic static IDataReader ExecuteReader(this IDbConnection cnn, string sql, object? param = null, IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null) =>\n    CommandExecuter.ExecuteReaderImpl(cnn, new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.Buffered), CommandBehavior.Default);\n```\n\n----------------------------------------\n\nTITLE: Updating User Records with Dapper.Rainbow in C#\nDESCRIPTION: C# code showing how to update an existing user record in the database. The snippet retrieves a user, modifies its email property, and then updates the record.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.Rainbow/readme.md#2025-04-16_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar userToUpdate = db.Users.Get(id);\nuserToUpdate.Email = \"new.email@example.com\";\ndb.Users.Update(userToUpdate);\n```\n\n----------------------------------------\n\nTITLE: Executing a SQL Reader with Command Behavior in Dapper (C#)\nDESCRIPTION: Extension method that executes a SQL query with parameters and provides a data reader with specified behavior. Supports command type, timeout, and transaction context.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Unshipped.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic static IDataReader ExecuteReader(this IDbConnection cnn, string sql, CommandBehavior commandBehavior, object? param = null, IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null) =>\n    CommandExecuter.ExecuteReaderImpl(cnn, new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.Buffered), commandBehavior);\n```\n\n----------------------------------------\n\nTITLE: Deleting User Records with Dapper.Rainbow in C#\nDESCRIPTION: C# code demonstrating how to delete a user record from the database. This snippet uses the Delete method with the user's ID to remove the record.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.Rainbow/readme.md#2025-04-16_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\ndb.Users.Delete(id);\n```\n\n----------------------------------------\n\nTITLE: Creating SQL Table Schema with Primary Key for Dapper.Rainbow\nDESCRIPTION: SQL script to create a Users table that follows the Dapper.Rainbow convention of having a primary key named 'Id'. This schema is required for Dapper.Rainbow to function properly.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.Rainbow/readme.md#2025-04-16_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE Users (\n    Id INT IDENTITY(1,1) PRIMARY KEY,\n    Name VARCHAR(100),\n    Email VARCHAR(100)\n);\n```\n\n----------------------------------------\n\nTITLE: Working with Foreign Keys in Dapper.Rainbow and Dapper\nDESCRIPTION: C# code showing how to insert related data with foreign key relationships. This snippet inserts a User record and then a Post record that references the user through its foreign key.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.Rainbow/readme.md#2025-04-16_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar newUser = new User { Name = \"Jane Doe\", Email = \"jane.doe@example.com\" };\nvar userId = db.Users.Insert(newUser);\n\nvar newPost = new Post { UserId = userId, Content = \"Hello, World!\" };\ndb.Connection.Insert(newPost); // Using Dapper for the child table\n```\n\n----------------------------------------\n\nTITLE: Using Literal Replacement in Dapper SQL Queries\nDESCRIPTION: Demonstrates how to use literal replacement in Dapper queries by using the {=value} syntax. This feature allows better execution plans and filtered index usage but should be used sparingly.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Readme.md#2025-04-16_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nconnection.Query(\"select * from User where UserTypeId = {=Admin}\", new { UserTypeId.Admin });\n```\n\n----------------------------------------\n\nTITLE: Dynamic Filtering and Paging Implementation with SqlBuilder in C#\nDESCRIPTION: A comprehensive example showing how to implement dynamic filtering and paging using SqlBuilder. Demonstrates conditional WHERE clauses, ordering, and pagination with ROW_NUMBER() in SQL Server.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.SqlBuilder/Readme.md#2025-04-16_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = new SqlBuilder();\nvar selectTemplate = builder.AddTemplate(@\"select X.* from (\n        select us.*, ROW_NUMBER() OVER (/**orderby**/) AS RowNumber \n        from Users us \n        /**where**/\n    ) as X \n    where RowNumber between @start and @finish\", new { start, finish });\nvar countTemplate = builder.AddTemplate(@\"select count(*) from Users /**where**/);\n\nif (userId.HasValue())\n    builder.Where($\"t.userId = @{nameof(userId)}\", new { userId });\nif (isCancel)\n    builder.Where($\"t.isCancel = @{nameof(isCancel)}\", new { isCancel });\n\nbuilder.OrderBy(string.Format(\"t.id {0}\", orderDesc ? \"desc\" : \"asc\"));\n\nvar users = conn.Query<User>(selectTemplate.RawSql, selectTemplate.Parameters);\nvar count = conn.ExecuteScalar<int>(countTemplate.RawSql, countTemplate.Parameters);\n//..etc..\n```\n\n----------------------------------------\n\nTITLE: Executing a Command Definition for Reader in Dapper (C#)\nDESCRIPTION: Extension method that executes a pre-configured CommandDefinition against an IDbConnection, returning a data reader with default command behavior.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Unshipped.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic static IDataReader ExecuteReader(this IDbConnection cnn, CommandDefinition command) =>\n    CommandExecuter.ExecuteReaderImpl(cnn, command, CommandBehavior.Default);\n```\n\n----------------------------------------\n\nTITLE: Implementing a CommandBuilder for SQL Queries in C#\nDESCRIPTION: This code defines a CommandBuilder class that helps build database commands with parameters. It includes methods for creating commands, adding conditions, and building the final SQL query with proper parameter handling.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.EntityFramework/PublicAPI.Unshipped.txt#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace Dapper.SqlBuilder\n{\n    /// <summary>\n    /// Represents the WHERE clause in a query, and a parameter bag.\n    /// </summary>\n    public class CommandBuilder\n    {\n        private readonly List<(string, object?)> _params = new();\n        private readonly List<string> _parts = new();\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"CommandBuilder\"/> class.\n        /// </summary>\n        public CommandBuilder() { }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"CommandBuilder\"/> class with a column and value pair.\n        /// </summary>\n        /// <param name=\"column\">Name of the column.</param>\n        /// <param name=\"value\">The value. Pass DBNull.Value to emit \"column IS NULL\".</param>\n        public CommandBuilder(string column, object? value)\n            => And(column, value);\n\n        /// <summary>\n        /// Adds a condition to this builder with AND logic (key = @value).\n        /// </summary>\n        /// <param name=\"column\">Name of the column.</param>\n        /// <param name=\"value\">The value. Pass DBNull.Value to emit \"column IS NULL\".</param>\n        /// <returns>The same builder (for fluent usage).</returns>\n        public CommandBuilder And(string column, object? value)\n            => And(column, value, \"=\");\n\n        /// <summary>\n        /// Adds a condition to this builder with AND logic (key {op} @value).\n        /// </summary>\n        /// <param name=\"column\">Name of the column.</param>\n        /// <param name=\"value\">The value. Pass DBNull.Value to emit \"column IS NULL\".</param>\n        /// <param name=\"op\">The operator to use.</param>\n        /// <returns>The same builder (for fluent usage).</returns>\n        public virtual CommandBuilder And(string column, object? value, string op)\n        {\n            if (Convert.IsDBNull(value))\n            {\n                _parts.Add($\"{column} IS NULL\");\n            }\n            else\n            {\n                string name = AddParam(value);\n                _parts.Add($\"{column} {op} @{name}\");\n            }\n            return this;\n        }\n\n        /// <summary>\n        /// Adds a raw sql condition to this builder with AND logic.\n        /// </summary>\n        /// <param name=\"rawSql\">Raw SQL condition.</param>\n        /// <returns>The same builder (for fluent usage).</returns>\n        public CommandBuilder AndRaw(string rawSql)\n        {\n            _parts.Add(rawSql);\n            return this;\n        }\n\n        /// <summary>\n        /// Gets a unique parameter name.\n        /// </summary>\n        /// <returns>A string.</returns>\n        protected virtual string GetParameterName()\n            => $\"p{_params.Count}\";\n\n        /// <summary>\n        /// Adds a parameter to the parameter bag and returns the parameter name.\n        /// </summary>\n        /// <param name=\"value\">The value to add.</param>\n        /// <returns>The parameter name.</returns>\n        public virtual string AddParam(object? value)\n        {\n            string name = GetParameterName();\n            _params.Add((name, value));\n            return name;\n        }\n\n        /// <summary>\n        /// Adds a parameter name/value to the parameter bag.\n        /// </summary>\n        /// <param name=\"name\">The parameter name.</param>\n        /// <param name=\"value\">The parameter value.</param>\n        /// <returns>The same builder (for fluent usage).</returns>\n        public CommandBuilder AddParam(string name, object? value)\n        {\n            _params.Add((name, value));\n            return this;\n        }\n\n        /// <summary>\n        /// Get the built SQL condition. This is the part that would go in the where clause.\n        /// Use <see cref=\"GetParameters\"/> to get the parameter bag.\n        /// </summary>\n        /// <param name=\"joiner\">The string to use for concatenation. Defaults to \" AND \".</param>\n        /// <returns>The raw SQL.</returns>\n        public virtual string GetCondition(string joiner = \" AND \")\n            => _parts.Count > 0 ? string.Join(joiner, _parts) : \"1=1\";\n\n        /// <summary>\n        /// Get the parameter dictionary.\n        /// </summary>\n        /// <returns>The parameter object to be passed to Dapper.</returns>\n        public virtual DynamicParameters GetParameters()\n        {\n            var result = new DynamicParameters();\n            foreach (var (name, value) in _params)\n            {\n                result.Add(name, value);\n            }\n            return result;\n        }\n\n        /// <summary>\n        /// Gets a dictionary of the parameters.\n        /// </summary>\n        /// <returns>A dictionary.</returns>\n        public virtual Dictionary<string, object?> GetDictionary()\n            => _params.ToDictionary(x => x.Item1, x => x.Item2);\n\n        /// <summary>\n        /// Is this builder empty (no conditions)?\n        /// </summary>\n        public bool IsEmpty => _parts.Count == 0;\n\n        /// <summary>\n        /// Gets a default (empty) instance of this builder.\n        /// </summary>\n        public static CommandBuilder Default { get; } = new CommandBuilder();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing a Command Definition with Reader Behavior in Dapper (C#)\nDESCRIPTION: Extension method that executes a pre-configured CommandDefinition against an IDbConnection, returning a data reader with specified command behavior.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Unshipped.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic static IDataReader ExecuteReader(this IDbConnection cnn, CommandDefinition command, CommandBehavior commandBehavior) =>\n    CommandExecuter.ExecuteReaderImpl(cnn, command, commandBehavior);\n```\n\n----------------------------------------\n\nTITLE: Implementing IN and LIKE Operators in SQL Command Builder for Dapper\nDESCRIPTION: This code provides implementations for common SQL operators like IN and LIKE in the CommandBuilder class. It allows for easily adding these types of conditions to SQL queries with proper parameter handling.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.EntityFramework/PublicAPI.Unshipped.txt#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace Dapper.SqlBuilder\n{\n    /// <summary>\n    /// Extension methods for <see cref=\"CommandBuilder\"/>.\n    /// </summary>\n    public static class CommandBuilderExtensions\n    {\n        /// <summary>\n        /// Adds an \"IN\" condition to this builder with AND logic.\n        /// </summary>\n        /// <typeparam name=\"T\">Type of values.</typeparam>\n        /// <param name=\"builder\">The builder to extend.</param>\n        /// <param name=\"column\">Name of the column.</param>\n        /// <param name=\"values\">The values to check in.</param>\n        /// <returns>The same builder (for fluent usage).</returns>\n        public static CommandBuilder AndIn<T>(this CommandBuilder builder, string column, IEnumerable<T>? values)\n        {\n            if (values is null)\n            {\n                return builder.AndRaw(\"1=0\");\n            }\n\n            var valuesList = values.ToList();\n            if (valuesList.Count == 0)\n            {\n                return builder.AndRaw(\"1=0\");\n            }\n\n            var parameters = new List<string>();\n            foreach (var value in valuesList)\n            {\n                string name = builder.AddParam(value);\n                parameters.Add($\"@{name}\");\n            }\n\n            return builder.AndRaw($\"{column} IN ({string.Join(\", \", parameters)})\");\n        }\n\n        /// <summary>\n        /// Adds an \"IN\" condition to this builder with AND logic (more efficient version).\n        /// </summary>\n        /// <param name=\"builder\">The builder to extend.</param>\n        /// <param name=\"column\">Name of the column.</param>\n        /// <param name=\"values\">The values to check in.</param>\n        /// <returns>The same builder (for fluent usage).</returns>\n        public static CommandBuilder AndIn(this CommandBuilder builder, string column, object? values)\n        {\n            if (values is null)\n            {\n                return builder.AndRaw(\"1=0\");\n            }\n\n            string name = builder.AddParam(values);\n            return builder.AndRaw($\"{column} IN @{name}\");\n        }\n\n        /// <summary>\n        /// Adds a \"LIKE\" condition to this builder with AND logic.\n        /// </summary>\n        /// <param name=\"builder\">The builder to extend.</param>\n        /// <param name=\"column\">Name of the column.</param>\n        /// <param name=\"value\">The value to search for.</param>\n        /// <returns>The same builder (for fluent usage).</returns>\n        public static CommandBuilder AndLike(this CommandBuilder builder, string column, string? value)\n        {\n            if (string.IsNullOrEmpty(value))\n            {\n                return builder;\n            }\n\n            return builder.And(column, $\"%{value}%\", \"LIKE\");\n        }\n\n        /// <summary>\n        /// Adds a \"LIKE\" condition to this builder with AND logic, using the prefix search pattern.\n        /// </summary>\n        /// <param name=\"builder\">The builder to extend.</param>\n        /// <param name=\"column\">Name of the column.</param>\n        /// <param name=\"value\">The value to search for.</param>\n        /// <returns>The same builder (for fluent usage).</returns>\n        public static CommandBuilder AndStartsWith(this CommandBuilder builder, string column, string? value)\n        {\n            if (string.IsNullOrEmpty(value))\n            {\n                return builder;\n            }\n\n            return builder.And(column, $\"{value}%\", \"LIKE\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Value Conversion and Type Handling in Dapper\nDESCRIPTION: Static methods for reading and converting values from the database, handling character types, and managing type mappings and handlers. These methods handle data type conversions and customization of type handling in Dapper.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.SqlMapper.ReadChar(object! value) -> char\nstatic Dapper.SqlMapper.ReadNullableChar(object! value) -> char?\nstatic Dapper.SqlMapper.RemoveTypeMap(System.Type! type) -> void\nstatic Dapper.SqlMapper.ReplaceLiterals(this Dapper.SqlMapper.IParameterLookup! parameters, System.Data.IDbCommand! command) -> void\nstatic Dapper.SqlMapper.ResetTypeHandlers() -> void\nstatic Dapper.SqlMapper.SanitizeParameterValue(object? value) -> object!\nstatic Dapper.SqlMapper.SetDbType(System.Data.IDataParameter! parameter, object! value) -> void\nstatic Dapper.SqlMapper.SetTypeMap(System.Type! type, Dapper.SqlMapper.ITypeMap? map) -> void\nstatic Dapper.SqlMapper.SetTypeName(this System.Data.DataTable! table, string! typeName) -> void\nstatic Dapper.SqlMapper.ThrowDataException(System.Exception! ex, int index, System.Data.IDataReader! reader, object? value) -> void\nstatic Dapper.SqlMapper.ThrowNullCustomQueryParameter(string! name) -> void\nstatic Dapper.SqlMapper.TypeHandlerCache<T>.Parse(object! value) -> T?\nstatic Dapper.SqlMapper.TypeHandlerCache<T>.SetValue(System.Data.IDbDataParameter! parameter, object! value) -> void\nstatic Dapper.SqlMapper.TypeMapProvider -> System.Func<System.Type!, Dapper.SqlMapper.ITypeMap!>!\n```\n\n----------------------------------------\n\nTITLE: Executing a Command Definition in Dapper (C#)\nDESCRIPTION: Extension method that executes a pre-configured CommandDefinition against an IDbConnection. This provides more control over execution parameters through the CommandDefinition object.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Unshipped.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic static int Execute(this IDbConnection cnn, CommandDefinition command) =>\n    CommandExecuter.ExecuteImpl(cnn, command);\n```\n\n----------------------------------------\n\nTITLE: Type Handling and Parser Methods\nDESCRIPTION: Utility methods for type mapping, parsing, and handling database reader results. Includes cache management and type deserializer configuration.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI.Shipped.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.SqlMapper.GetTypeDeserializer(System.Type! type, System.Data.IDataReader! reader, int startBound = 0, int length = -1, bool returnNullIfFirstMissing = false) -> System.Func<System.Data.IDataReader!, object!>!\n```\n\n----------------------------------------\n\nTITLE: Implementing PostgreSQL Array Parameter Support in Dapper\nDESCRIPTION: This code snippet extends the CommandBuilder class to add support for PostgreSQL array parameters. It specializes in handling arrays by using the ANY operator and properly formatting array parameters for PostgreSQL.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.EntityFramework/PublicAPI.Unshipped.txt#2025-04-16_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace Dapper.SqlBuilder\n{\n    /// <summary>\n    /// Adds support for PostgreSQL arrays to <see cref=\"CommandBuilder\"/>.\n    /// </summary>\n    public class PgArrayCommandBuilder : CommandBuilder\n    {\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"PgArrayCommandBuilder\"/> class.\n        /// </summary>\n        public PgArrayCommandBuilder() { }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"PgArrayCommandBuilder\"/> class with a column and value pair.\n        /// </summary>\n        /// <param name=\"column\">Name of the column.</param>\n        /// <param name=\"value\">The value.</param>\n        public PgArrayCommandBuilder(string column, object? value)\n            : base(column, value) { }\n\n        /// <summary>\n        /// Adds a condition to this builder with AND logic (key {op} @value).\n        /// Special case for arrays, to use the ANY function over arrays.\n        /// </summary>\n        /// <param name=\"column\">Name of the column.</param>\n        /// <param name=\"value\">The value.</param>\n        /// <param name=\"op\">The operator.</param>\n        /// <returns>The same builder (for fluent usage).</returns>\n        public override CommandBuilder And(string column, object? value, string op)\n        {\n            if (value is null || Convert.IsDBNull(value))\n            {\n                return base.And(column, value, op);\n            }\n\n            Type type = value.GetType();\n            if (!IsArrayType(type))\n            {\n                return base.And(column, value, op);\n            }\n\n            string name = AddParam(value);\n            return AndRaw($\"{column} {op} ANY(@{name})\");\n        }\n\n        private static bool IsArrayType(Type type)\n            => type.IsArray || (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(List<>));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SQL Builder Raw SQL Equivalent Example in C#\nDESCRIPTION: Shows the raw SQL equivalent of the SqlBuilder template example, demonstrating how the library handles parameter merging and clause generation automatically.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.SqlBuilder/Readme.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar count = cnn.Query(\"select count(*) from table where a = @a and b = @b\", new { a = 1, b = 1 });\nvar rows = cnn.Query(\"select * from table where a = @a and b = @b order by a, b\", new { a = 1, b = 1 });\n```\n\n----------------------------------------\n\nTITLE: Establishing Database Connection with SqlConnection in C#\nDESCRIPTION: C# code snippet for creating and opening a SQL Server database connection using System.Data.SqlClient. This connection will be used for subsequent database operations.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.Rainbow/readme.md#2025-04-16_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Data.SqlClient;\n\nvar connectionString = \"your_connection_string_here\";\nusing var connection = new SqlConnection(connectionString);\nconnection.Open(); // Open the connection\n```\n\n----------------------------------------\n\nTITLE: Creating SQL Table Schema with Foreign Key for Related Data\nDESCRIPTION: SQL script to create a Posts table with a foreign key relationship to the Users table. This schema demonstrates how to model parent-child relationships in the database.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.Rainbow/readme.md#2025-04-16_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE Posts (\n    Id INT IDENTITY(1,1) PRIMARY KEY,\n    UserId INT,\n    Content VARCHAR(255),\n    FOREIGN KEY (UserId) REFERENCES Users(Id)\n);\n```\n\n----------------------------------------\n\nTITLE: Abstract BulkCopy Class Definition in C#\nDESCRIPTION: Defines the abstract BulkCopy class in Dapper.ProviderTools namespace with methods for mapping columns and writing data to servers. The class provides cross-provider bulk data transfer capabilities with various overloads for different data sources.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.ProviderTools/PublicAPI.Shipped.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Dapper.ProviderTools.BulkCopy.AddColumnMapping(int sourceColumn, int destinationColumn) -> void\nabstract Dapper.ProviderTools.BulkCopy.AddColumnMapping(string! sourceColumn, string! destinationColumn) -> void\nabstract Dapper.ProviderTools.BulkCopy.DestinationTableName.get -> string!\nabstract Dapper.ProviderTools.BulkCopy.DestinationTableName.set -> void\nabstract Dapper.ProviderTools.BulkCopy.Dispose(bool disposing) -> void\nabstract Dapper.ProviderTools.BulkCopy.Wrapped.get -> object!\nabstract Dapper.ProviderTools.BulkCopy.WriteToServer(System.Data.DataRow![]! source) -> void\nabstract Dapper.ProviderTools.BulkCopy.WriteToServer(System.Data.DataTable! source) -> void\nabstract Dapper.ProviderTools.BulkCopy.WriteToServer(System.Data.IDataReader! source) -> void\nabstract Dapper.ProviderTools.BulkCopy.WriteToServerAsync(System.Data.Common.DbDataReader! source, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nabstract Dapper.ProviderTools.BulkCopy.WriteToServerAsync(System.Data.DataRow![]! source, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\nabstract Dapper.ProviderTools.BulkCopy.WriteToServerAsync(System.Data.DataTable! source, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Handlers Registration Method in Dapper.EntityFramework\nDESCRIPTION: Static method for registering the DbGeographyHandler and DbGeometryHandler with Dapper's type handling system. This method must be called to enable Dapper to work with Entity Framework spatial types.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.EntityFramework/PublicAPI.Shipped.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic Dapper.EntityFramework.Handlers.Register() -> void\n```\n\n----------------------------------------\n\nTITLE: BulkCopy Implementation Details in C#\nDESCRIPTION: Concrete implementations of the BulkCopy class including properties for configuration such as BatchSize, BulkCopyTimeout, and EnableStreaming. Also includes static factory methods for creating BulkCopy instances from DbConnection objects.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.ProviderTools/PublicAPI.Shipped.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nDapper.ProviderTools.BulkCopy\nDapper.ProviderTools.BulkCopy.BatchSize.get -> int\nDapper.ProviderTools.BulkCopy.BatchSize.set -> void\nDapper.ProviderTools.BulkCopy.BulkCopy() -> void\nDapper.ProviderTools.BulkCopy.BulkCopyTimeout.get -> int\nDapper.ProviderTools.BulkCopy.BulkCopyTimeout.set -> void\nDapper.ProviderTools.BulkCopy.Dispose() -> void\nDapper.ProviderTools.BulkCopy.EnableStreaming.get -> bool\nDapper.ProviderTools.BulkCopy.EnableStreaming.set -> void\nstatic Dapper.ProviderTools.BulkCopy.Create(System.Data.Common.DbConnection! connection) -> Dapper.ProviderTools.BulkCopy!\nstatic Dapper.ProviderTools.BulkCopy.TryCreate(System.Data.Common.DbConnection! connection) -> Dapper.ProviderTools.BulkCopy?\n```\n\n----------------------------------------\n\nTITLE: Default Handler Instances in Dapper.EntityFramework\nDESCRIPTION: Static readonly properties that provide access to the default instances of DbGeographyHandler and DbGeometryHandler. These singleton instances are used by Dapper for processing spatial data types.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.EntityFramework/PublicAPI.Shipped.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly Dapper.EntityFramework.DbGeographyHandler.Default -> Dapper.EntityFramework.DbGeographyHandler!\nstatic readonly Dapper.EntityFramework.DbGeometryHandler.Default -> Dapper.EntityFramework.DbGeometryHandler!\n```\n\n----------------------------------------\n\nTITLE: Defining ITypeHandler Interface for Custom Type Handling in Dapper\nDESCRIPTION: This code snippet defines the ITypeHandler interface, which is used to implement custom type handlers in Dapper. It includes methods for setting parameter values and parsing database results.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/netstandard2.0/PublicAPI.Unshipped.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Dapper\n{\n    /// <summary>\n    /// Implement this interface to perform custom type-based parameter handling and value parsing\n    /// </summary>\n    public interface ITypeHandler\n    {\n        /// <summary>\n        /// Assign the value of a parameter before a command executes\n        /// </summary>\n        /// <param name=\"parameter\">The parameter to configure</param>\n        /// <param name=\"value\">Parameter value</param>\n        void SetValue(IDbDataParameter parameter, object? value);\n\n        /// <summary>\n        /// Parse a database value back to a typed value\n        /// </summary>\n        /// <param name=\"value\">The value from the database</param>\n        /// <param name=\"destinationType\">The type to parse to</param>\n        /// <returns>The typed value</returns>\n        object? Parse(object? value, Type destinationType);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: DbGeometryHandler Implementation Methods in Dapper.EntityFramework\nDESCRIPTION: Implementation of the Parse and SetValue methods for the DbGeometryHandler class. Parse converts database values to DbGeometry objects, while SetValue assigns DbGeometry values to database parameters.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.EntityFramework/PublicAPI.Shipped.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\noverride Dapper.EntityFramework.DbGeometryHandler.Parse(object? value) -> System.Data.Entity.Spatial.DbGeometry?\noverride Dapper.EntityFramework.DbGeometryHandler.SetValue(System.Data.IDbDataParameter! parameter, System.Data.Entity.Spatial.DbGeometry? value) -> void\n```\n\n----------------------------------------\n\nTITLE: Initializing DbString Class Properties for Dapper\nDESCRIPTION: Implements a strongly-typed string parameter with configurable properties including length, fixed length status, and collation settings for database operations. The class enables precise control over string parameter behavior in Dapper queries.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/net461/PublicAPI.Shipped.txt#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n\nnamespace Dapper\n{\n    /// <summary>\n    /// Represents a DB string that can be used as a parameter.\n    /// </summary>\n    public sealed class DbString : ICustomQueryParameter\n    {\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"DbString\"/> class.\n        /// </summary>\n        public DbString() { Length = -1; }\n\n        /// <summary>\n        /// Specifies the length of the string.\n        /// </summary>\n        public int Length { get; set; }\n\n        /// <summary>\n        /// Indicates whether the parameter is fixed-length.\n        /// </summary>\n        public bool IsFixed { get; set; }\n\n        /// <summary>\n        /// Gets or sets the string value.\n        /// </summary>\n        public string? Value { get; set; }\n\n        /// <summary>\n        /// Gets or sets the collation name of the parameter.\n        /// </summary>\n        public string? Collation { get; set; }\n\n        /// <summary>\n        /// Gets the SQL bits needed to build the parameter.\n        /// </summary>\n        internal static System.Data.DbType? IsAnsiFlags(bool isFixed, bool isAnsi) =>\n            isAnsi ? (isFixed ? System.Data.DbType.AnsiStringFixedLength : System.Data.DbType.AnsiString) :\n            isFixed ? System.Data.DbType.StringFixedLength : System.Data.DbType.String;\n\n        void ICustomQueryParameter.AddParameter(IDbCommand command, string name)\n        {\n            var param = command.CreateParameter();\n            param.ParameterName = name;\n            param.Value = (object?)Value ?? DBNull.Value;\n            param.DbType = IsAnsiFlags(IsFixed, IsAnsi) ?? System.Data.DbType.String;\n            if (Length <= 0)\n            {\n                param.Size = -1;\n            }\n            else\n            {\n                param.Size = Length;\n            }\n            if (Collation != null)\n            {\n                param.Size = -1;\n                var dbProvider = GetDbProvider(command);\n                var collationPart = dbProvider == DbProvider.PostgreSql\n                    ? \" COLLATE \\\"\" + Collation + \"\\\"\"\n                    : \" COLLATE \" + Collation;\n                name = \"CAST(@\" + name.Substring(1) + \" AS varchar(8000)\" + collationPart + \")\";\n            }\n        }\n\n        private static DbProvider GetDbProvider(IDbCommand command)\n        {\n            var type = command.GetType().FullName;\n            switch(type)\n            {\n                case \"System.Data.SqlClient.SqlCommand\":\n                case \"Microsoft.Data.SqlClient.SqlCommand\":\n                    return DbProvider.SqlServer;\n\n                case \"Npgsql.NpgsqlCommand\":\n                    return DbProvider.PostgreSql;\n\n                default:\n                    return DbProvider.SqlServer;\n            }\n        }\n\n        private enum DbProvider\n        {\n            SqlServer,\n            PostgreSql,\n        }\n\n        /// <summary>\n        /// Indicates whether the parameter should be treated as an ANSI DbType.\n        /// </summary>\n        public bool IsAnsi { get; set; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dapper via NuGet Package Manager\nDESCRIPTION: Commands to install Dapper using NuGet Package Manager. Two options are provided: standard Dapper package and Dapper.StrongName. Adding '-Pre' suffix will install the latest pre-release build.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/docs/index.md#2025-04-16_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\nInstall-Package Dapper\n```\n\nLANGUAGE: powershell\nCODE:\n```\nInstall-Package Dapper.StrongName\n```\n\n----------------------------------------\n\nTITLE: DbGeographyHandler and DbGeometryHandler Class Definitions in Dapper.EntityFramework\nDESCRIPTION: Defines handler classes for Entity Framework spatial data types (DbGeography and DbGeometry). These handlers enable Dapper to serialize and deserialize spatial data when working with databases.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.EntityFramework/PublicAPI.Shipped.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nDapper.EntityFramework.DbGeographyHandler\nDapper.EntityFramework.DbGeographyHandler.DbGeographyHandler() -> void\nDapper.EntityFramework.DbGeometryHandler\nDapper.EntityFramework.DbGeometryHandler.DbGeometryHandler() -> void\n```\n\n----------------------------------------\n\nTITLE: Installing Dapper and Dapper.Rainbow via PowerShell\nDESCRIPTION: Commands to install the required packages (Dapper and Dapper.Rainbow) using the NuGet Package Manager in PowerShell. The x.x.x placeholder should be replaced with the desired version numbers.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.Rainbow/readme.md#2025-04-16_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\nInstall-Package Dapper -Version x.x.x\nInstall-Package Dapper.Rainbow -Version x.x.x\n```\n\n----------------------------------------\n\nTITLE: Implementing StringBuilderCache Utility Class in C#\nDESCRIPTION: Defines a StringBuilderCache utility class that provides thread-static caching of StringBuilder instances to improve performance by reducing allocations. The class includes methods to acquire, return, and get string output from StringBuilder objects.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.ProviderTools/PublicAPI.Unshipped.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Dapper\n{\n    internal static class StringBuilderCache\n    {\n        [ThreadStatic]\n        private static System.Text.StringBuilder? _cache;\n\n        public static System.Text.StringBuilder Acquire(int capacity = 16)\n        {\n            var sb = _cache;\n            if (sb == null)\n            {\n                return new System.Text.StringBuilder(capacity);\n            }\n\n            // Avoid StringBuilder.Clear() which was only introduced in .NET Core 2.0\n            if (sb.Length > 0)\n            {\n                sb.Length = 0;\n            }\n\n            _cache = null; // we've loaned out the builder; start with a fresh one next time\n            return sb;\n        }\n\n        public static void Release(System.Text.StringBuilder sb)\n        {\n            _cache = sb;\n        }\n\n        public static string GetStringAndRelease(System.Text.StringBuilder sb)\n        {\n            var s = sb.ToString();\n            Release(sb);\n            return s;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SqlDataRecordList Class Definition in C#\nDESCRIPTION: Defines a generic class that implements IEnumerable<SqlDataRecord> for passing enumerable data to SQL Server. The class manages SqlMetaData definitions and converts values from a source collection into SqlDataRecord objects.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.SqlBuilder/PublicAPI.Unshipped.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing SQL Query Execution in Dapper C#\nDESCRIPTION: This private method implements the core logic for executing SQL queries in Dapper. It handles connection management, command preparation, and execution based on the provided CommandDefinition.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/netstandard2.0/PublicAPI.Shipped.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nprivate static int ExecuteImpl(this IDbConnection cnn, CommandDefinition command)\n{\n    object? param = command.Parameters;\n    IDbTransaction? transaction = command.Transaction;\n    int? commandTimeout = command.CommandTimeout;\n    CommandType? commandType = command.CommandType;\n    var flags = command.Flags;\n    string sql = command.CommandText;\n    CancellationToken cancellationToken = command.CancellationToken;\n    if ((flags & CommandFlags.Pipelined) != 0)\n    {\n        return ExecuteMultiImplAsync(cnn, command, false).Result;\n    }\n    bool wasClosed = cnn.State == ConnectionState.Closed;\n    int result;\n    try\n    {\n        if (wasClosed) cnn.Open();\n        using var cmd = command.SetupCommand(cnn, param);\n        result = cmd.ExecuteNonQuery();\n        command.OnCompleted();\n    }\n    finally\n    {\n        if (wasClosed) cnn.Close();\n    }\n    return result;\n}\n```\n\n----------------------------------------\n\nTITLE: DbConnection and DbException Extension Methods in C#\nDESCRIPTION: Extension methods for DbConnection to handle connection pools and retrieve client connection IDs, as well as DbException extensions to check error numbers. These utilities provide cross-provider database connection management capabilities.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.ProviderTools/PublicAPI.Shipped.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nDapper.ProviderTools.DbConnectionExtensions\nDapper.ProviderTools.DbExceptionExtensions\nstatic Dapper.ProviderTools.DbConnectionExtensions.TryClearAllPools(this System.Data.Common.DbConnection! connection) -> bool\nstatic Dapper.ProviderTools.DbConnectionExtensions.TryClearPool(this System.Data.Common.DbConnection! connection) -> bool\nstatic Dapper.ProviderTools.DbConnectionExtensions.TryGetClientConnectionId(this System.Data.Common.DbConnection! connection, out System.Guid clientConnectionId) -> bool\nstatic Dapper.ProviderTools.DbExceptionExtensions.IsNumber(this System.Data.Common.DbException! exception, int number) -> bool\n```\n\n----------------------------------------\n\nTITLE: DbGeographyHandler Implementation Methods in Dapper.EntityFramework\nDESCRIPTION: Implementation of the Parse and SetValue methods for the DbGeographyHandler class. Parse converts database values to DbGeography objects, while SetValue assigns DbGeography values to database parameters.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper.EntityFramework/PublicAPI.Shipped.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\noverride Dapper.EntityFramework.DbGeographyHandler.Parse(object? value) -> System.Data.Entity.Spatial.DbGeography?\noverride Dapper.EntityFramework.DbGeographyHandler.SetValue(System.Data.IDbDataParameter! parameter, System.Data.Entity.Spatial.DbGeography? value) -> void\n```\n\n----------------------------------------\n\nTITLE: Testing Dapper Query with Dynamic Tags in C#\nDESCRIPTION: Test that verifies Dapper's Query method works correctly with dynamically typed tag parameters. The test executes a query with a dynamic tag object and verifies the expected result.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/net461/PublicAPI.Unshipped.txt#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic void Query_WithDynamicTag_ShouldMatch_ParameterValues()\n{\n    var tag = new { Id = 2, Name = \"Steve\" };\n    var result = connection.Query<TagA>(\"select @Id as Id, @Name as Name\", tag, tag).AsList();\n\n    Assert.Single(result);\n    Assert.Equal(2, result[0].Id);\n    Assert.Equal(\"Steve\", result[0].Name);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Dapper QuerySingleOrDefault with Dynamic Tags in C#\nDESCRIPTION: Test that verifies Dapper's QuerySingleOrDefault method works correctly with dynamically typed tag parameters. The test executes a query with a dynamic tag object and verifies the expected result.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/net461/PublicAPI.Unshipped.txt#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic void QuerySingleOrDefault_WithDynamicTag_ShouldMatch_ParameterValues()\n{\n    var tag = new { Id = 2, Name = \"Steve\" };\n    var result = connection.QuerySingleOrDefault<TagA>(\"select @Id as Id, @Name as Name\", tag, tag);\n\n    Assert.Equal(2, result.Id);\n    Assert.Equal(\"Steve\", result.Name);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Dapper QueryFirstOrDefault with Dynamic Tags in C#\nDESCRIPTION: Test that verifies Dapper's QueryFirstOrDefault method works correctly with dynamically typed tag parameters. The test executes a query with a dynamic tag object and verifies the expected result.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/net461/PublicAPI.Unshipped.txt#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic void QueryFirstOrDefault_WithDynamicTag_ShouldMatch_ParameterValues()\n{\n    var tag = new { Id = 2, Name = \"Steve\" };\n    var result = connection.QueryFirstOrDefault<TagA>(\"select @Id as Id, @Name as Name\", tag, tag);\n\n    Assert.Equal(2, result.Id);\n    Assert.Equal(\"Steve\", result.Name);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Dapper QueryFirst with Dynamic Tags in C#\nDESCRIPTION: Test that verifies Dapper's QueryFirst method works correctly with dynamically typed tag parameters. The test executes a query with a dynamic tag object and verifies the expected result.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/net461/PublicAPI.Unshipped.txt#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic void QueryFirst_WithDynamicTag_ShouldMatch_ParameterValues()\n{\n    var tag = new { Id = 2, Name = \"Steve\" };\n    var result = connection.QueryFirst<TagA>(\"select @Id as Id, @Name as Name\", tag, tag);\n\n    Assert.Equal(2, result.Id);\n    Assert.Equal(\"Steve\", result.Name);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Dapper QueryFirstOrDefault with Static Tags in C#\nDESCRIPTION: Test that verifies Dapper's QueryFirstOrDefault method works correctly with a statically typed tag parameter. The test executes a query that should return the first row with an ID of 2.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/net461/PublicAPI.Unshipped.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic void QueryFirstOrDefault_WithTag_ShouldMatch_ParameterValues()\n{\n    var tag = new TagA();\n    var result = connection.QueryFirstOrDefault<TagA>(\"select @Id as Id, @Name as Name\", tag, tag);\n\n    Assert.Equal(2, result.Id);\n    Assert.Equal(\"Steve\", result.Name);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeHandler<T> Abstract Class for Type-Specific Handling in Dapper\nDESCRIPTION: This code snippet defines the TypeHandler<T> abstract class, which provides a base implementation for type-specific handlers in Dapper. It includes abstract methods for setting parameter values and parsing database results.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/netstandard2.0/PublicAPI.Unshipped.txt#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nnamespace Dapper\n{\n    /// <summary>\n    /// Base-class for simple type-handlers\n    /// </summary>\n    public abstract class TypeHandler<T> : ITypeHandler\n    {\n        /// <summary>\n        /// Parse a database value back to a typed value\n        /// </summary>\n        /// <param name=\"value\">The value from the database</param>\n        /// <returns>The typed value</returns>\n        public abstract T? Parse(object? value);\n\n        /// <summary>\n        /// Assign the value of a parameter before a command executes\n        /// </summary>\n        /// <param name=\"parameter\">The parameter to configure</param>\n        /// <param name=\"value\">Parameter value</param>\n        public abstract void SetValue(IDbDataParameter parameter, T? value);\n\n        /// <summary>\n        /// Parse a database value back to a typed value\n        /// </summary>\n        /// <param name=\"value\">The value from the database</param>\n        /// <param name=\"destinationType\">The type to parse to</param>\n        /// <returns>The typed value</returns>\n        object? ITypeHandler.Parse(object? value, Type destinationType) => Parse(value);\n\n        /// <summary>\n        /// Assign the value of a parameter before a command executes\n        /// </summary>\n        /// <param name=\"parameter\">The parameter to configure</param>\n        /// <param name=\"value\">Parameter value</param>\n        void ITypeHandler.SetValue(IDbDataParameter parameter, object? value) => SetValue(parameter, (T?)value);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Dapper QueryFirst with Static Tags in C#\nDESCRIPTION: Test that verifies Dapper's QueryFirst method works correctly with a statically typed tag parameter. The test executes a query that should return the first row with an ID of 2.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/net461/PublicAPI.Unshipped.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic void QueryFirst_WithTag_ShouldMatch_ParameterValues()\n{\n    var tag = new TagA();\n    var result = connection.QueryFirst<TagA>(\"select @Id as Id, @Name as Name\", tag, tag);\n\n    Assert.Equal(2, result.Id);\n    Assert.Equal(\"Steve\", result.Name);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Dapper QuerySingle with Static Tags in C#\nDESCRIPTION: Test that verifies Dapper's QuerySingle method works correctly with a statically typed tag parameter. The test executes a query that should return a single row with an ID of 2.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/net461/PublicAPI.Unshipped.txt#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic void QuerySingle_WithTag_ShouldMatch_ParameterValues()\n{\n    var tag = new TagA();\n    var result = connection.QuerySingle<TagA>(\"select @Id as Id, @Name as Name\", tag, tag);\n\n    Assert.Equal(2, result.Id);\n    Assert.Equal(\"Steve\", result.Name);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Dapper QuerySingleOrDefault with Static Tags in C#\nDESCRIPTION: Test that verifies Dapper's QuerySingleOrDefault method works correctly with a statically typed tag parameter. The test executes a query that should return a single row with an ID of 2.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/net461/PublicAPI.Unshipped.txt#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic void QuerySingleOrDefault_WithTag_ShouldMatch_ParameterValues()\n{\n    var tag = new TagA();\n    var result = connection.QuerySingleOrDefault<TagA>(\"select @Id as Id, @Name as Name\", tag, tag);\n\n    Assert.Equal(2, result.Id);\n    Assert.Equal(\"Steve\", result.Name);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Dapper Query with Static Tags in C#\nDESCRIPTION: Test that verifies Dapper's Query method works correctly with a statically typed tag parameter. The test executes a query that should return a collection with a single row containing an ID of 2.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/net461/PublicAPI.Unshipped.txt#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic void Query_WithTag_ShouldMatch_ParameterValues()\n{\n    var tag = new TagA();\n    var result = connection.Query<TagA>(\"select @Id as Id, @Name as Name\", tag, tag).AsList();\n\n    Assert.Single(result);\n    Assert.Equal(2, result[0].Id);\n    Assert.Equal(\"Steve\", result[0].Name);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Dapper QueryMultiple with Static Tags in C#\nDESCRIPTION: Test that verifies Dapper's QueryMultiple method works correctly with a statically typed tag parameter. The test executes multiple queries in a single command and verifies the results match the expected values.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/net461/PublicAPI.Unshipped.txt#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic void QueryMultiple_WithTag_ShouldMatch_ParameterValues()\n{\n    var tag = new TagA();\n    using var multi = connection.QueryMultiple(\"select @Id as Id, @Name as Name; select @Id as Id, @Name as Name, @Id + 3 as [Value]\", tag, tag);\n\n    var result1 = multi.Read<TagA>().AsList();\n    var result2 = multi.Read<TagB>().AsList();\n\n    Assert.Single(result1);\n    Assert.Equal(2, result1[0].Id);\n    Assert.Equal(\"Steve\", result1[0].Name);\n\n    Assert.Single(result2);\n    Assert.Equal(2, result2[0].Id);\n    Assert.Equal(\"Steve\", result2[0].Name);\n    Assert.Equal(5, result2[0].Value);\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: This directive enables C# nullable reference type annotations for the file, indicating that the Dapper codebase uses C# 8.0+ nullable reference types feature for improved null safety.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/net8.0/PublicAPI.Unshipped.txt#2025-04-16_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: C# Nullable Enable Directive\nDESCRIPTION: Enables nullable reference types for this file, which is a C# 8.0+ feature that helps catch potential null reference exceptions at compile time.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/net8.0/PublicAPI.Shipped.txt#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Testing Dapper QuerySingle with Dynamic Tags in C#\nDESCRIPTION: Test that verifies Dapper's QuerySingle method works correctly with dynamically typed tag parameters. The test executes a query with a dynamic tag object and verifies the expected result.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/net461/PublicAPI.Unshipped.txt#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic void QuerySingle_WithDynamicTag_ShouldMatch_ParameterValues()\n{\n    var tag = new { Id = 2, Name = \"Steve\" };\n    var result = connection.QuerySingle<TagA>(\"select @Id as Id, @Name as Name\", tag, tag);\n\n    Assert.Equal(2, result.Id);\n    Assert.Equal(\"Steve\", result.Name);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Dapper QueryMultiple with Dynamic Tags in C#\nDESCRIPTION: Test that verifies Dapper's QueryMultiple method works correctly with dynamically typed tag parameters. The test executes multiple queries in a single command using a dynamic tag object.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/net461/PublicAPI.Unshipped.txt#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic void QueryMultiple_WithDynamicTag_ShouldMatch_ParameterValues()\n{\n    var tag = new { Id = 2, Name = \"Steve\" };\n    using var multi = connection.QueryMultiple(\"select @Id as Id, @Name as Name; select @Id as Id, @Name as Name, @Id + 3 as [Value]\", tag, tag);\n\n    var result1 = multi.Read<TagA>().AsList();\n    var result2 = multi.Read<TagB>().AsList();\n\n    Assert.Single(result1);\n    Assert.Equal(2, result1[0].Id);\n    Assert.Equal(\"Steve\", result1[0].Name);\n\n    Assert.Single(result2);\n    Assert.Equal(2, result2[0].Id);\n    Assert.Equal(\"Steve\", result2[0].Name);\n    Assert.Equal(5, result2[0].Value);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Invalid SQL in Dapper QueryFirst with Tags in C#\nDESCRIPTION: Test that verifies Dapper throws the expected exception when executing an invalid SQL query with the QueryFirst method using a tag parameter.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/net461/PublicAPI.Unshipped.txt#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic void Invalid_SQL_ShouldThrow_SqlException()\n{\n    var tag = new TagA();\n    var ex = Assert.Throws<SqlException>(() => connection.QueryFirst<TagA>(\"INVALID SQL\", tag, tag));\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Tag Model Classes in C#\nDESCRIPTION: Definition of model classes used in Dapper tag-based tests. TagA includes ID and Name properties, while TagB extends those with a Value property.\nSOURCE: https://github.com/DapperLib/Dapper/blob/main/Dapper/PublicAPI/net461/PublicAPI.Unshipped.txt#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nprivate sealed class TagA\n{\n    public int Id { get; set; } = 2;\n    public string Name { get; set; } = \"Steve\";\n}\n\nprivate sealed class TagB\n{\n    public int Id { get; set; }\n    public string Name { get; set; } = \"\";\n    public int Value { get; set; }\n}\n```"
  }
]