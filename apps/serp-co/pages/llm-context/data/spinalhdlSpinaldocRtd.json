[
  {
    "owner": "spinalhdl",
    "repo": "spinaldoc-rtd",
    "content": "TITLE: Generating VHDL and Verilog from SpinalHDL\nDESCRIPTION: This Scala code demonstrates how to generate VHDL and Verilog code from a SpinalHDL component. It defines a simple component named 'MyTopLevel' with input and output signals and uses the 'SpinalVhdl' and 'SpinalVerilog' functions to generate the respective HDL code. The 'MyTopLevel' component performs a simple AND operation between two input signals and assigns the result to an output signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/vhdl_generation.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core._\n\n   // A simple component definition.\n   class MyTopLevel extends Component {\n     // Define some input/output signals. Bundle like a VHDL record or a Verilog struct.\n     val io = new Bundle {\n       val a = in  Bool()\n       val b = in  Bool()\n       val c = out Bool()\n     }\n\n     // Define some asynchronous logic.\n     io.c := io.a & io.b\n   }\n\n   // This is the main function that generates the VHDL and the Verilog corresponding to MyTopLevel.\n   object MyMain {\n     def main(args: Array[String]) {\n       SpinalVhdl(new MyTopLevel)\n       SpinalVerilog(new MyTopLevel)\n     }\n   }\n```\n\n----------------------------------------\n\nTITLE: Example Toplevel SoC Design - Scala\nDESCRIPTION: This snippet demonstrates a simple System-on-Chip (SoC) toplevel design using SpinalHDL and the tilelink.fabric.Node API. It includes a CPU fiber, a RAM fiber, and a GPIO fiber, connected via the Tilelink interconnect, showcasing memory mapping.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/tilelink/tilelink_fabric.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval cpu = new CpuFiber()\n\nval ram = new RamFiber()\nram.up at(0x10000, 0x200) of cpu.down // map the ram at [0x10000-0x101FF], the ram will infer its own size from it\n\nval gpio = new GpioFiber()\ngpio.up at 0x20000 of cpu.down // map the gpio at [0x20000-0x20FFF], its range of 4KB being fixed internally\n```\n\n----------------------------------------\n\nTITLE: Stream Mux Implementation in SpinalHDL (Scala)\nDESCRIPTION: Illustrates the use of StreamMux to select one of multiple input streams based on a select signal. The output stream is connected to the selected input stream.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/stream.rst#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval inputStreams = Vec(Stream(Bits(8 bits)), portCount)\nval select = UInt(log2Up(inputStreams.length) bits)\nval outputStream = StreamMux(select, inputStreams)\n```\n\n----------------------------------------\n\nTITLE: AvalonMMConfig definition\nDESCRIPTION: Defines the AvalonMMConfig case class in Scala, which is used to configure the AvalonMM bus. It includes various parameters such as addressWidth, dataWidth, burstCountWidth, and flags for enabling different features like byte enables, debug access, read/write capabilities, response signals, lock signals, wait request signals, read data validity, burst counts, address units, burst count units, burst behavior, hold time, linewrap bursts, maximum pending read transactions, maximum pending write transactions, read latency, read wait time, setup time, and write wait time.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/avalon/avalonmm.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class AvalonMMConfig( addressWidth : Int,\n                            dataWidth : Int,\n                            burstCountWidth : Int,\n                            useByteEnable : Boolean,\n                            useDebugAccess : Boolean,\n                            useRead : Boolean,\n                            useWrite : Boolean,\n                            useResponse : Boolean,\n                            useLock : Boolean,\n                            useWaitRequestn : Boolean,\n                            useReadDataValid : Boolean,\n                            useBurstCount : Boolean,\n                            // useEndOfPacket : Boolean,\n\n                            addressUnits : AddressUnits = symbols,\n                            burstCountUnits : AddressUnits = words,\n                            burstOnBurstBoundariesOnly : Boolean = false,\n                            constantBurstBehavior : Boolean = false,\n                            holdTime : Int = 0,\n                            linewrapBursts : Boolean = false,\n                            maximumPendingReadTransactions : Int = 1,\n                            maximumPendingWriteTransactions : Int = 0, // unlimited\n                            readLatency : Int = 0,\n                            readWaitTime : Int = 0,\n                            setupTime : Int = 0,\n                            writeWaitTime : Int = 0\n                            )\n```\n\n----------------------------------------\n\nTITLE: Bundle IO Direction (master/slave) - Scala\nDESCRIPTION: Demonstrates using the `IMasterSlave` trait to define IO directions in a master/slave topology. The `asMaster` function defines the direction of each signal from the master's perspective, allowing the use of `master()` and `slave()` syntax.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bundle.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ncase class HandShake(payloadWidth: Int) extends Bundle with IMasterSlave {\n  val valid   = Bool()\n  val ready   = Bool()\n  val payload = Bits(payloadWidth bits)\n\n  // You have to implement this asMaster function.\n  // This function should set the direction of each signals from an master point of view\n  override def asMaster(): Unit = {\n    out(valid, payload)\n    in(ready)\n  }\n}\n\nval io = new Bundle {\n  val input  = slave(HandShake(8))\n  val output = master(HandShake(8))\n}\n```\n\n----------------------------------------\n\nTITLE: Clock Domain Application in Scala\nDESCRIPTION: This snippet shows how to apply a gated clock domain to synchronous elements using the `gated()` and `gated on` syntaxes. It creates a gated clock `gatedClk` and then instantiates two counters, `gatedCounter` and `gatedCounter2`, within the gated clock domain.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass Counters extends Component {\n  val io = new Bundle {\n    val enable = in Bool ()\n    val freeCount, gatedCount, gatedCount2 = out UInt (4 bits)\n  }\n  val freeCounter = CounterFreeRun(16)\n  io.freeCount := freeCounter.value\n\n  // In a real design consider using a glitch free single purpose CLKGATE primitive instead\n  val gatedClk = ClockDomain.current.readClockWire && io.enable\n  val gated = ClockDomain(gatedClk, ClockDomain.current.readResetWire)\n\n  // Here the \"gated\" clock domain is applied on \"gatedCounter\" and \"gatedCounter2\"\n  val gatedCounter = gated(CounterFreeRun(16))\n  io.gatedCount := gatedCounter.value\n  val gatedCounter2 = gated on CounterFreeRun(16)\n  io.gatedCount2 := gatedCounter2.value\n\n  assert(gatedCounter.value === gatedCounter2.value, \"gated count mismatch\")\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Logic with WhenBuilder in Scala\nDESCRIPTION: This code demonstrates the use of 'WhenBuilder' for parameterizing conditional logic in SpinalHDL.  It allows creating a sequence of 'when' conditions, which can be more convenient for generating parameters dynamically. It requires importing `spinal.lib._`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/when_switch.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.lib._\n\nval conds = Bits(8 bits)\nval result = UInt(8 bits)\n\nval ctx = WhenBuilder()\nctx.when(conds(0)) {\n  result := 0\n}\nctx.when(conds(1)) {\n  result := 1\n}\nif(true) {\n  ctx.when(conds(2)) {\n    result := 2\n  }\n}\nctx.when(conds(3)) {\n  result := 3\n}\n```\n\n----------------------------------------\n\nTITLE: AHB-Lite3 Bus Instantiation and Usage in SpinalHDL\nDESCRIPTION: This code demonstrates how to instantiate an AHB-Lite3 bus in SpinalHDL. It first creates an `AhbLite3Config` object, specifying the address and data widths. Then, it creates two `AhbLite3` instances using this configuration.  Finally, it provides a conditional statement based on `ahbY.HSEL` as a usage example.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/amba3/ahblite3.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval ahbConfig = AhbLite3Config(\n     addressWidth = 12,\n     dataWidth    = 32\n   )\n   val ahbX = AhbLite3(ahbConfig)\n   val ahbY = AhbLite3(ahbConfig)\n\n   when(ahbY.HSEL) {\n     // ...\n   }\n```\n\n----------------------------------------\n\nTITLE: Making an Instant Entry State - Scala\nDESCRIPTION: This code demonstrates how to bypass the default boot state behavior and directly make a state machine boot into a user state by using makeInstantEntry(). The onEntry of that state will only be called when it transitions from another state to this state and not during boot.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/fsm.rst#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\n// State sequance: IDLE, STATE_A, STATE_B, ...\nval fsm = new StateMachine {\n  // IDLE is named BOOT in simulation\n  val IDLE = makeInstantEntry()\n  val STATE_A, STATE_B, STATE_C = new State\n  \n  IDLE.whenIsActive(goto(STATE_A))\n  STATE_A.whenIsActive(goto(STATE_B))\n  STATE_B.whenIsActive(goto(STATE_C))\n  STATE_C.whenIsActive(goto(STATE_B))\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\n//  State sequence : BOOT, IDLE, STATE_A, STATE_B, ...\nval fsm = new StateMachine {\n  val IDLE, STATE_A, STATE_B, STATE_C = new State\n  setEntry(IDLE)\n  \n  IDLE.whenIsActive(goto(STATE_A))\n  STATE_A.whenIsActive(goto(STATE_B))\n  STATE_B.whenIsActive(goto(STATE_C))\n  STATE_C.whenIsActive(goto(STATE_B))\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Don't Care Values to Bits in SpinalHDL (Scala)\nDESCRIPTION: This snippet demonstrates how to assign a 'don't care' value to all bits of a Bits signal in SpinalHDL. The assignDontCare() method sets all bits to 'x', effectively making them undefined.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/index.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval myBits  = Bits(8 bits)\nmyBits.assignDontCare() // Will assign all the bits to 'x'\n```\n\n----------------------------------------\n\nTITLE: Type Casting - Scala\nDESCRIPTION: This example shows various type casting operations in SpinalHDL between SInt, Bits, UInt, and Vec[Bool].  It demonstrates casting to Bits, creating a vector of Bools, casting to SInt, and conversions using intoSInt, twoComplement and abs. It includes assertions for conversions with sign extension and absolute values.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Int.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n// Cast an SInt to Bits\nval myBits = mySInt.asBits\n\n// Create a Vector of Bool\nval myVec = myUInt.asBools\n\n// Cast a Bits to SInt\nval mySInt = S(myBits)\n\n// UInt to SInt conversion\nval UInt_30 = U(30, 8 bit)\n\nval SInt_30 = UInt_30.intoSInt\nassert(SInt_30 === S(30, 9 bit))\n\nmySInt := UInt_30.twoComplement(booleanDoInvert)\n    // if booleanDoInvert is True then we get S(-30, 9 bit)\n    // otherwise we get S(30, 9 bit)\n\n// absolute values\nval SInt_n_4 = S(-3, 3 bit)\nval abs_en = SInt_n_3.abs(booleanDoAbs)\n    // if booleanDoAbs is True we get U(3, 3 bit)\n    // otherwise we get U\"3'b101\" or U(5, 3 bit) (raw bit pattern of -3)\n\nval SInt_n_128 = S(-128, 8 bit)\nval abs = SInt_n_128.abs\nassert(abs === U(128, 8 bit))\nval sym_abs = SInt_n_128.absWithSym\nassert(sym_abs === U(127, 7 bit))\n```\n\n----------------------------------------\n\nTITLE: Implement JTAG ID Code Instruction\nDESCRIPTION: Implements the JTAG ID code instruction. It returns a specified ID code to the JTAG master. Additionally, when a reset occurs, it sets the instruction register (IR) to its own instruction ID.  It captures the ID code during CAPTURE_DR and sets TDO to the LSB of the ID code during SHIFT_DR.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Advanced ones/jtag.rst#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nclass JtagInstructionIdcode(owner: JtagTapAccess, instructionId: Bits, val idcode: Bits) extends JtagInstruction(owner, instructionId) {\n  Component.current.addPrePopTask(() => {\n    val fsm = owner.getFsmState()\n\n    val shiftRegister = Reg(Bits(idcode.getWidth() bits))\n    when(fsm === JtagState.CAPTURE_DR) {\n      shiftRegister := idcode\n    }\n\n    when(fsm === JtagState.TEST_LOGIC_RESET) {\n    }\n\n    when(fsm === JtagState.SHIFT_DR) {\n      owner.getTdo().write(shiftRegister.lsb)\n    }\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a State Machine - Style B - Scala\nDESCRIPTION: This example showcases defining a state machine in SpinalHDL using style B, separating state declarations from their logic definitions. It uses the StateMachine class from spinal.lib.fsm and defines states stateA, stateB, and stateC. Logic is then associated with each state using methods like whenIsActive, onEntry, onExit, and goto. A counter and output signal are also utilized.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/fsm.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.lib.fsm._\n\nclass TopLevel extends Component {\n  val io = new Bundle {\n    val result = out Bool()\n  }\n\n  val fsm = new StateMachine {\n    val stateA = new State with EntryPoint\n    val stateB = new State\n    val stateC = new State\n\n    val counter = Reg(UInt(8 bits)) init(0)\n    io.result := False\n\n    stateA\n      .whenIsActive(goto(stateB))\n\n    stateB\n      .onEntry(counter := 0)\n      .whenIsActive {\n        counter := counter + 1\n        when(counter === 4) {\n          goto(stateC)\n        }\n      }\n      .onExit(io.result := True)\n\n    stateC\n      .whenIsActive(goto(stateA))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Bundle Comparison Example - Scala\nDESCRIPTION: Compares two `Color` bundles for equality.  It initializes two `Color` bundles with the same RGB values and then uses the `===` operator to check if they are equal. Demonstrates the comparison of all elements within the bundle.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bundle.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval color1 = Color(8)\ncolor1.r := 0 \ncolor1.g := 0 \ncolor1.b := 0\n\nval color2 = Color(8)\ncolor2.r := 0\ncolor2.g := 0 \ncolor2.b := 0\n\nmyBool := color1 === color2  // Compare all elements of the bundle\n// is equivalent to:\n// myBool := color1.r === color2.r && color1.g === color2.g && color1.b === color2.b\n```\n\n----------------------------------------\n\nTITLE: Instantiating VHDL/Verilog IP with BlackBox in SpinalHDL\nDESCRIPTION: This snippet demonstrates how to instantiate a VHDL or Verilog component into a SpinalHDL design using the `BlackBox` construct. It defines a RAM component (`Ram_1w_1r`) as a BlackBox with generics and IO signals. The user needs to provide the external VHDL/Verilog implementation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/miscelenea/core/core_components.rst#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nclass Ram_1w_1r(_wordWidth: Int, _wordCount: Int) extends BlackBox {\n     val generic = new Generic {\n       val wordCount = _wordCount\n       val wordWidth = _wordWidth\n     }\n\n     val io = new Bundle {\n       val clk = in Bool()\n\n       val wr = new Bundle {\n         val en = in Bool()\n         val addr = in UInt (log2Up(_wordCount) bits)\n         val data = in Bits (_wordWidth bits)\n       }\n       val rd = new Bundle {\n         val en = in Bool()\n         val addr = in UInt (log2Up(_wordCount) bits)\n         val data = out Bits (_wordWidth bits)\n       }\n     }\n\n     mapClockDomain(clock=io.clk)\n   }\n```\n\n----------------------------------------\n\nTITLE: StageLink Usage Scala\nDESCRIPTION: This snippet demonstrates the usage of StageLink to connect two nodes with registers on the `data` and `valid` signals and arbitration on the `ready` signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval c01 = StageLink(n0, n1)\n```\n\n----------------------------------------\n\nTITLE: Using StateFsm - Scala\nDESCRIPTION: This snippet illustrates how to use StateFsm in SpinalHDL to define a state containing a nested state machine. whenCompleted is executed when the nested state machine is done (exited).\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/fsm.rst#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n// internalFsm is a function defined below\nval stateC = new StateFsm(fsm=internalFsm()) {\n  whenCompleted {\n    goto(stateD)\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef internalFsm() = new StateMachine {\n  val counter = Reg(UInt(8 bits)) init(0)\n\n  val stateA : State = new State with EntryPoint {\n    whenIsActive {\n      goto(stateB)\n    }\n  }\n\n  val stateB : State = new State {\n    onEntry (counter := 0)\n    whenIsActive {\n      when(counter === 4) {\n        exit()\n      }\n      counter := counter + 1\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: AXI4 Bus Definition in SpinalHDL\nDESCRIPTION: Defines the Axi4 class in SpinalHDL, which represents an AXI4 bus with AW, W, B, AR, and R channels.  It includes an asMaster() function to specify the master/slave relationship of the signals. The required dependency is the SpinalHDL library.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/amba4/axi4.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Axi4(config: Axi4Config) extends Bundle with IMasterSlave {\n     val aw = Stream(Axi4Aw(config))\n     val w  = Stream(Axi4W(config))\n     val b  = Stream(Axi4B(config))\n     val ar = Stream(Axi4Ar(config))\n     val r  = Stream(Axi4R(config))\n\n     override def asMaster(): Unit = {\n       master(ar,aw,w)\n       slave(r,b)\n     }\n   }\n```\n\n----------------------------------------\n\nTITLE: Bundle to Bits Conversion - Scala\nDESCRIPTION: Converts a `Color` bundle to a `Bits` type using the `asBits` operator. The elements of the bundle are mapped to bits in the order they are defined, LSB first. Shows how a composite data structure can be flattened for transmission or storage.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bundle.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval color1 = Color(8)\nval myBits := color1.asBits\n```\n\n----------------------------------------\n\nTITLE: AXI4 Bus Instantiation Example in SpinalHDL\nDESCRIPTION: Demonstrates how to instantiate an AXI4 bus in SpinalHDL using the Axi4Config class to define the bus parameters (addressWidth, dataWidth, idWidth).  It also shows an example of using the axiY.aw.valid signal within a when statement. The required dependency is the SpinalHDL library.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/amba4/axi4.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval axiConfig = Axi4Config(\n     addressWidth = 32,\n     dataWidth    = 32,\n     idWidth      = 4\n   )\n   val axiX = Axi4(axiConfig)\n   val axiY = Axi4(axiConfig)\n\n   when(axiY.aw.valid) {\n     // ...\n   }\n```\n\n----------------------------------------\n\nTITLE: Bool Type Casting in SpinalHDL (Scala)\nDESCRIPTION: This snippet demonstrates how to cast Bool signals to other data types in SpinalHDL, such as Bits, UInt, and SInt. It covers using the asBits, asUInt, and asSInt methods for type conversion.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bool.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// Add the carry to an SInt value\nval carry = Bool()\nval res = mySInt + carry.asSInt\n```\n\n----------------------------------------\n\nTITLE: StreamFifo Component Definition - Scala\nDESCRIPTION: Defines a StreamFifo component in SpinalHDL, which implements a FIFO buffer using the Stream interface. It takes a dataType and depth as parameters and provides push and pop Stream interfaces for interacting with the FIFO.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/stream.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass StreamFifo[T <: Data](dataType: T, depth: Int) extends Component {\n  val io = new Bundle {\n    val push = slave Stream (dataType)\n    val pop = master Stream (dataType)\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Bundle IO Direction (in/out) - Scala\nDESCRIPTION: Illustrates defining a Bundle within the IO definition of a component and specifying the direction (input or output) for the entire bundle. Simplifies IO declaration when all bundle elements share the same direction.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bundle.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval io = new Bundle {\n  val input  = in (Color(8))\n  val output = out(Color(8))\n}\n```\n\n----------------------------------------\n\nTITLE: WidthAdapterFiber Example - Scala\nDESCRIPTION: This code demonstrates a WidthAdapterFiber in SpinalHDL for bridging memory buses with different data widths. It handles the negotiation of data width parameters between the master (up) and slave (down) sides. The fiber propagates parameter proposals and supported parameters, performs data width mismatch handling, and generates the hardware for the width adapter using the tilelink.WidthAdapter.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/tilelink/tilelink_fabric.rst#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nclass WidthAdapterFiber() extends Area {\n  val up = Node.up()\n  val down = Node.down()\n\n  // Populate the MemoryConnection graph\n  new MemoryConnection {\n    override def up = up\n    override def down = down\n    override def transformers = Nil\n    override def mapping = SizeMapping(0, BigInt(1) << WidthAdapterFiber.this.up.m2s.parameters.addressWidth)\n    populate()\n  }\n\n  // Fiber in which we will negotiate the data width parameters and generate the hardware\n  val logic = Fiber build new Area {\n    // First, we propagate downward the parameter proposal, hopping that the downward side will agree\n    down.m2s.proposed.load(up.m2s.proposed)\n\n    // Second, we will propagate upward what is actually supported, but will take care of any dataWidth mismatch\n    up.m2s.supported load down.m2s.supported.copy(\n      dataWidth = up.m2s.proposed.dataWidth\n    )\n\n    // Third, we propagate downward the final bus parameter, but will take care of any dataWidth mismatch\n    down.m2s.parameters load up.m2s.parameters.copy(\n      dataWidth = down.m2s.supported.dataWidth\n    )\n\n    // No alteration on s2m parameters\n    up.s2m.from(down.s2m)\n\n    // Finally, we generate the hardware\n    val bridge = new tilelink.WidthAdapter(up.bus.p, down.bus.p)\n    bridge.io.up << up.bus\n    bridge.io.down >> down.bus\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Resizing Bits\nDESCRIPTION: Demonstrates how to resize a bit vector in SpinalHDL using Scala. It covers automatic resizing with `.resized`, resizing to a specific width with `.resize(width)`, and resizing from the left with `.resizeLeft(width)`. Each method offers different behavior in terms of which bits are retained.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bits.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nmyBits_32bits := B\"32'x112233344\"\nmyBits_8bits  := myBits_32bits.resized       // automatic resize (myBits_8bits = 0x44)\nmyBits_8bits  := myBits_32bits.resize(8)     // resize to 8 bits (myBits_8bits = 0x44)\nmyBits_8bits  := myBits_32bits.resizeLeft(8) // resize to 8 bits (myBits_8bits = 0x11)\n```\n\n----------------------------------------\n\nTITLE: Synthesizing UartCtrl (115200-N-8-1) in Scala\nDESCRIPTION: This snippet shows a simple usage example of instantiating and synthesizing a UartCtrl with fixed settings (115200 baud, no parity, 8 data bits, 1 stop bit) using the UartCtrlInitConfig. This is achieved by creating an object UartCtrl with an apply method.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/uart.rst#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core._\n\nobject UartExample {\n  def main(args: Array[String]): Unit = {\n    SpinalConfig(defaultConfigForClockDomains = ClockDomainConfig(resetKind = ASYNC, resetActiveLevel = LOW)).generateVerilog(new Component {\n      val baudrate = 115200\n      val clockFrequency = 100000000 // 100 MHz\n      val uartConfig = UartCtrlInitConfig(baudrate * 100 / clockFrequency, 8, ParityType.NONE, StopBitCount.ONE)\n      val io = new Bundle {\n        val uart = master(Uart(Bool(), Bool()))\n      }\n\n      val uartCtrl = UartCtrl(uartConfig)\n      io.uart <> uartCtrl.io.uart\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Node and Payload Access Example - SpinalHDL\nDESCRIPTION: This example showcases how to access signals referenced by a Payload within a Node using the `node(Payload)` API in SpinalHDL.  It defines two nodes, a Payload (PC), and demonstrates assigning a value to the PC Payload in the first node.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval n0, n1 = Node()\n\nval PC = Payload(UInt(32 bits))\n```\n\n----------------------------------------\n\nTITLE: UartCtrl Usage Example Scala\nDESCRIPTION: This code provides a top-level example of using the `UartCtrl` component within a SpinalHDL design. It configures the UART with specific settings (921600 baud, no parity, 1 stop bit), echoes received bytes to LEDs, and periodically sends switch values via the UART.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/uart.rst#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ncase class UartCtrlUsageExample(uartCtrlConfig : UartCtrlMemoryMappedConfig) extends Component {\n  val io = new Bundle {\n    val leds = out(Bits(8 bits))\n    val switches = in(Bits(8 bits))\n  }\n\n  val uartCtrl = new UartCtrl(uartCtrlConfig)\n  uartCtrl.io.uart.rxd := False\n\n  val rx = uartCtrl.io.bus.newSlave(addressOffset = 0)\n  val tx = uartCtrl.io.bus.newSlave(addressOffset = 4)\n  val status = uartCtrl.io.bus.newSlave(addressOffset = 8)\n\n  val rxBuffer = StreamFifo(Bits(8 bits), 32)\n  rxBuffer.io.push.valid := rx.valid\n  rxBuffer.io.push.payload := rx.payload\n  rx.ready := rxBuffer.io.push.ready\n\n  io.leds := rxBuffer.io.pop.payload\n  rxBuffer.io.pop.ready := True\n\n  tx.valid := False\n  tx.payload := 0\n  val switchCounter = Reg(UInt(12 bits)) init(0)\n  switchCounter := switchCounter + 1\n  when(switchCounter === 0){\n    tx.valid := True\n    tx.payload := io.switches\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: USB Device Controller Definition in SpinalHDL\nDESCRIPTION: This code defines a USB device top-level module using SpinalHDL. It instantiates a USB Device Controller (`UsbDeviceCtrl`) and a USB Device PHY (`UsbDevicePhyNative`), connecting them and exposing the controller's BMB interface and PHY's USB interface. It also defines clock domains for the controller and PHY.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Com/usb_device.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core._\nimport spinal.core.sim._\nimport spinal.lib.bus.bmb.BmbParameter\nimport spinal.lib.com.usb.phy.UsbDevicePhyNative\nimport spinal.lib.com.usb.sim.UsbLsFsPhyAbstractIoAgent\nimport spinal.lib.com.usb.udc.{UsbDeviceCtrl, UsbDeviceCtrlParameter}\n\n\ncase class UsbDeviceTop() extends Component {\n  val ctrlCd = ClockDomain.external(\"ctrlCd\", frequency = FixedFrequency(100 MHz))\n  val phyCd = ClockDomain.external(\"phyCd\", frequency = FixedFrequency(48 MHz))\n\n  val ctrl = ctrlCd on new UsbDeviceCtrl(\n    p = UsbDeviceCtrlParameter(\n      addressWidth = 14\n    ),\n    bmbParameter = BmbParameter(\n      addressWidth = UsbDeviceCtrl.ctrlAddressWidth,\n      dataWidth = 32,\n      sourceWidth = 0,\n      contextWidth = 0,\n      lengthWidth = 2\n    )\n  )\n\n  val phy = phyCd on new UsbDevicePhyNative(sim = true)\n  ctrl.io.phy.cc(ctrlCd, phyCd) <> phy.io.ctrl\n\n  val bmb = ctrl.io.ctrl.toIo()\n  val usb = phy.io.usb.toIo()\n  val power = phy.io.power.toIo()\n  val pullup = phy.io.pullup.toIo()\n  val interrupts = ctrl.io.interrupt.toIo()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Subdivide a Signal in SpinalHDL (Scala)\nDESCRIPTION: This snippet showcases the usage of `subdivideIn` to divide a UInt signal into smaller parts (slices).  It demonstrates how to access these slices using an index and reverse the order of the slices.  It also shows how to assign values to parts of signal created by subdivideIn.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Int.rst#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n// Subdivide\n   val sel = UInt(2 bits)\n   val myUIntWord = myUInt_128bits.subdivideIn(32 bits)(sel)\n       // sel = 3 => myUIntWord = myUInt_128bits(127 downto 96)\n       // sel = 2 => myUIntWord = myUInt_128bits( 95 downto 64)\n       // sel = 1 => myUIntWord = myUInt_128bits( 63 downto 32)\n       // sel = 0 => myUIntWord = myUInt_128bits( 31 downto  0)\n\n    // If you want to access in reverse order you can do:\n    val myVector   = myUInt_128bits.subdivideIn(32 bits).reverse\n    val myRevUIntWord = myVector(sel)\n\n    // We can also assign through subdivides\n    val output8 = UInt(8 bit)\n    val pieces = output8.subdivideIn(2 slices)\n    // assign to output8\n    pieces(0) := 0xf\n    pieces(1) := 0x5\n```\n\n----------------------------------------\n\nTITLE: Defining a State as an Entry Point - Scala\nDESCRIPTION: This code shows two ways to define a state as the entry point of a SpinalHDL state machine using the EntryPoint trait or the setEntry method. Either approach designates the initial state of the FSM.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/fsm.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval stateA = new State with EntryPoint\n```\n\nLANGUAGE: scala\nCODE:\n```\nval stateA = new State\nsetEntry(stateA)\n```\n\n----------------------------------------\n\nTITLE: StreamFifo Instantiation and Connection - Scala\nDESCRIPTION: Instantiates a StreamFifo component and connects it to two Stream interfaces (streamA and streamB).  streamA is connected to the FIFO's push interface, and streamB is connected to the FIFO's pop interface, effectively buffering the data flow between the two streams.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/stream.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval streamA,streamB = Stream(Bits(8 bits))\n// ...\nval myFifo = StreamFifo(\n  dataType = Bits(8 bits),\n  depth    = 128\n)\nmyFifo.io.push << streamA\nmyFifo.io.pop  >> streamB\n```\n\n----------------------------------------\n\nTITLE: Conditional Assignment with When/ElseWhen/Otherwise in Scala\nDESCRIPTION: This code demonstrates the basic usage of 'when', 'elsewhen', and 'otherwise' for conditional signal assignment in SpinalHDL. It allows executing different code blocks based on the truthiness of specified conditions.  The conditions are evaluated sequentially, and the 'otherwise' block is executed if none of the preceding conditions are met.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/when_switch.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nwhen(cond1) {\n  // Execute when cond1 is true\n} elsewhen(cond2) {\n  // Execute when (not cond1) and cond2\n} otherwise {\n  // Execute when (not cond1) and (not cond2)\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a SpinalEnum with custom encoding\nDESCRIPTION: This code snippet shows how to declare a SpinalEnum with a custom default encoding. This allows users to specify the encoding to use for the enumeration values, rather than relying on the default.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/enum.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject Enumeration extends SpinalEnum(defaultEncoding=encodingOfYourChoice) {\n  val element0, element1, ..., elementN = newElement()\n}\n```\n\n----------------------------------------\n\nTITLE: AvalonMM UartCtrl Definition\nDESCRIPTION: Defines a SpinalHDL component, AvalonMMUartCtrl, with an AvalonMM slave interface (bus) and a Uart master interface (uart).  The AvalonMM interface is configured using AvalonMMUartCtrl.getAvalonMMConfig. The uart interface is a conduit.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/EDA/altera/qsysify.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class AvalonMMUartCtrl(...) extends Component {\n  val io = new Bundle {\n    val bus =  slave(AvalonMM(AvalonMMUartCtrl.getAvalonMMConfig))\n    val uart = master(Uart())\n  }\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: RegNext Abstraction in SpinalHDL\nDESCRIPTION: This code snippet illustrates that RegNext is an abstraction built on top of the Reg syntax. It shows two equivalent ways of achieving the same functionality: using Reg directly with an assignment and using the RegNext shortcut.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Sequential logic/registers.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// Standard way\nval something = Bool()\nval value = Reg(Bool())\nvalue := something\n\n// Short way\nval something = Bool()\nval value = RegNext(something)\n```\n\n----------------------------------------\n\nTITLE: StreamFifoCC Instantiation and Connection - Scala\nDESCRIPTION: Instantiates a StreamFifoCC component, a dual-clock domain FIFO, and connects it to two Stream interfaces (streamA and streamB) operating in different clock domains (clockA and clockB). The push side of the FIFO operates in clockA, and the pop side operates in clockB.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/stream.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval clockA = ClockDomain(???)\nval clockB = ClockDomain(???)\nval streamA,streamB = Stream(Bits(8 bits))\n// ...\nval myFifo = StreamFifoCC(\n  dataType  = Bits(8 bits),\n  depth     = 128,\n  pushClock = clockA,\n  popClock  = clockB\n)\nmyFifo.io.push << streamA\nmyFifo.io.pop  >> streamB\n```\n\n----------------------------------------\n\nTITLE: Defining APB3 Bus with SpinalHDL Case Classes\nDESCRIPTION: This Scala code snippet defines an APB3 bus configuration and hardware representation using SpinalHDL case classes. It demonstrates how SpinalHDL allows parameterization and reusability in interface definitions, addressing limitations of VHDL records and Verilog structs. The `Apb3Config` case class defines configuration parameters, and the `Apb3` case class defines the bus signals.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Foreword/index.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// Class which can be instantiated to represent a given APB3 configuration\n   case class Apb3Config(\n     addressWidth  : Int,\n     dataWidth     : Int,\n     selWidth      : Int     = 1,\n     useSlaveError : Boolean = true\n   )\n\n   // Class which can be instantiated to represent a given hardware APB3 bus\n   case class Apb3(config: Apb3Config) extends Bundle with IMasterSlave {\n     val PADDR      = UInt(config.addressWidth bits)\n     val PSEL       = Bits(config.selWidth bits)\n     val PENABLE    = Bool()\n     val PREADY     = Bool()\n     val PWRITE     = Bool()\n     val PWDATA     = Bits(config.dataWidth bits)\n     val PRDATA     = Bits(config.dataWidth bits)\n     val PSLVERROR  = if(config.useSlaveError) Bool() else null  // Optional signal\n\n     // Can be used to setup a given APB3 bus into a master interface of the host component\n     // `asSlave` is automatically implemented by symmetry\n     override def asMaster(): Unit = {\n       out(PADDR, PSEL, PENABLE, PWRITE, PWDATA)\n       in(PREADY, PRDATA)\n       if(config.useSlaveError) in(PSLVERROR)\n     }\n   }\n```\n\n----------------------------------------\n\nTITLE: Creating and Connecting AdderCell Instances in SpinalHDL\nDESCRIPTION: This code demonstrates how to create instances of the AdderCell component within another component (Adder) and how to connect their input and output ports to build a hierarchy. It shows example instantiating a single cell and also an array of cells.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/components_hierarchy.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Adder(width: Int) extends Component {\n  ...\n  // Create 2 AdderCell instances\n  val cell0 = new AdderCell()\n  val cell1 = new AdderCell()\n  cell1.io.cin := cell0.io.cout   // Connect cout of cell0 to cin of cell1\n\n  // Another example which creates an array of ArrayCell instances\n  val cellArray = Array.fill(width)(new AdderCell())\n  cellArray(1).io.cin := cellArray(0).io.cout   // Connect cout of cell(0) to cin of cell(1)\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Automatic Field Allocation with RegIf in Scala\nDESCRIPTION: Illustrates automatic field allocation within a register using RegIf in SpinalHDL. It defines fields fd0, fd1, fd2, and fd3 with specified bit widths and access types (RW). Reserved bits are automatically inserted between fields, optimizing register space.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval M_REG0  = busif.newReg(doc=\"REG1\")\n  val fd0 = M_REG0.field(Bits(2 bit), RW, doc= \"fields 0\")\n  M_REG0.reserved(5 bits)\n  val fd1 = M_REG0.field(Bits(3 bit), RW, doc= \"fields 0\")\n  val fd2 = M_REG0.field(Bits(3 bit), RW, doc= \"fields 0\")\n  // auto reserved 2 bits\n  val fd3 = M_REG0.fieldAt(pos=16, Bits(4 bit), doc= \"fields 3\")\n  // auto reserved 12 bits\n```\n\n----------------------------------------\n\nTITLE: APB3 Bus Definition\nDESCRIPTION: Defines the Apb3 Bundle in SpinalHDL, which represents the AMBA3-APB bus interface. It includes signals like PADDR, PSEL, PENABLE, PREADY, PWRITE, PWDATA, PRDATA, and PSLVERROR. The configuration is provided through an Apb3Config object, determining the width of address and data signals, as well as the presence of PSLVERROR.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/amba3/apb3.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Apb3(config: Apb3Config) extends Bundle with IMasterSlave {\n     val PADDR      = UInt(config.addressWidth bits)\n     val PSEL       = Bits(config.selWidth bits)\n     val PENABLE    = Bool()\n     val PREADY     = Bool()\n     val PWRITE     = Bool()\n     val PWDATA     = Bits(config.dataWidth bits)\n     val PRDATA     = Bits(config.dataWidth bits)\n     val PSLVERROR  = if(config.useSlaveError) Bool() else null\n     // ...\n   }\n```\n\n----------------------------------------\n\nTITLE: Register Instantiation Examples in SpinalHDL\nDESCRIPTION: This code snippet demonstrates various ways to instantiate registers in SpinalHDL using Reg, RegNext, RegInit, and RegNextWhen. It showcases how to define registers of different types (UInt), update them based on conditions, and initialize them with specific values or reset values.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Sequential logic/registers.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// UInt register of 4 bits\nval reg1 = Reg(UInt(4 bits))\n\n// Register that updates itself every cycle with a sample of reg1 incremented by 1\nval reg2 = RegNext(reg1 + 1)\n\n// UInt register of 4 bits initialized with 0 when the reset occurs\nval reg3 = RegInit(U\"0000\")\nreg3 := reg2\nwhen(reg2 === 5) {\n  reg3 := 0xF\n}\n\n// Register that samples reg3 when cond is True\nval reg4 = RegNextWhen(reg3, cond)\n```\n\n----------------------------------------\n\nTITLE: Uart TX Queue Implementation Scala\nDESCRIPTION: This example demonstrates adding a queue to the UART's write interface and implementing flow control using a StreamFifo. This allows for buffering data before transmission, improving system performance and reliability.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/uart.rst#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nval txBuffer = StreamFifo(Bits(8 bits), 32)\n  txBuffer.io.push << tx\n  uartCtrl.io.uart.txd := txBuffer.io.pop.valid ? txBuffer.io.pop.payload | True\n  txBuffer.io.pop.ready := uartCtrl.io.uart.txd\n```\n\n----------------------------------------\n\nTITLE: Assigning Fixed-Point Values in SpinalHDL\nDESCRIPTION: This snippet illustrates valid and invalid assignments to SFix (signed fixed-point) signals in SpinalHDL. It highlights the importance of avoiding bit loss during assignment and demonstrates how the `truncated` function can be used to resize the source number to match the destination size, preventing errors.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Fix.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval i16_m2 = SFix(16 exp, -2 exp)\nval i16_0  = SFix(16 exp,  0 exp)\nval i8_m2  = SFix( 8 exp, -2 exp)\nval o16_m2 = SFix(16 exp, -2 exp)\nval o16_m0 = SFix(16 exp,  0 exp)\nval o14_m2 = SFix(14 exp, -2 exp)\n\no16_m2 := i16_m2            // OK\no16_m0 := i16_m2            // Not OK, Bit loss\no14_m2 := i16_m2            // Not OK, Bit loss\no16_m0 := i16_m2.truncated  // OK, as it is resized to match assignment target\no14_m2 := i16_m2.truncated  // OK, as it is resized to match assignment target\nval o18_m2 = i16_m2.truncated(18 exp, -2 exp)\nval o18_22b = i16_m2.truncated(18 exp, 22 bit)\n```\n\n----------------------------------------\n\nTITLE: Register Vectors in SpinalHDL\nDESCRIPTION: This snippet shows how to define vectors of registers using Vec and Vec.fill. It also demonstrates how to initialize these registers using the init method and the foreach iteration.  Furthermore it demonstrates deferred intialization in more advanced compositions using initFunc.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Sequential logic/registers.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval vecReg1 = Vec(Reg(UInt(8 bits)), 4)\nval vecReg2 = Vec.fill(8)(Reg(Bool()))\n\nval vecReg1 = Vec(Reg(UInt(8 bits)) init(0), 4)\nval vecReg2 = Vec.fill(8)(Reg(Bool()))\nvecReg2.foreach(_ init(False))\n\ncase class ShiftRegister[T <: Data](dataType: HardType[T], depth: Int, initFunc: T => Unit) extends Component {\n   val io = new Bundle {\n      val input  = in (dataType())\n      val output = out(dataType())\n   }\n\n   val regs = Vec.fill(depth)(Reg(dataType()))\n   regs.foreach(initFunc)\n\n   for (i <- 1 to (depth-1)) {\n         regs(i) := regs(i-1)\n   }\n\n   regs(0) := io.input\n   io.output := regs(depth-1)\n}\n\nobject SRConsumer {\n   def initIdleFlow[T <: Data](flow: Flow[T]): Unit = {\n      flow.valid init(False)\n   }\n}\n\nclass SRConsumer() extends Component {\n   // ...\n   val sr = ShiftRegister(Flow(UInt(8 bits)), 4, SRConsumer.initIdleFlow[UInt])\n}\n```\n\n----------------------------------------\n\nTITLE: Stream Demux Implementation in SpinalHDL (Scala)\nDESCRIPTION: Shows how to use StreamDemux to route an input stream to one of multiple output streams based on a select signal. Only the selected output stream is active.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/stream.rst#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval inputStream = Stream(Bits(8 bits))\nval select = UInt(log2Up(portCount) bits)\nval outputStreams = StreamDemux(inputStream, select, portCount)\n```\n\n----------------------------------------\n\nTITLE: Registers in SpinalHDL (Scala)\nDESCRIPTION: This snippet shows how to define and initialize a register in SpinalHDL. Registers are explicitly specified, unlike in VHDL where they are often inferred.  The register is initialized to 0 on reset.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_perspective.rst#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval counter = Reg(UInt(8 bits))  init(0)  \ncounter := counter + 1   // Count up each cycle\n\n// init(0) means that the register should be initialized to zero when a reset occurs\n```\n\n----------------------------------------\n\nTITLE: TopLevel Component Definition in SpinalHDL\nDESCRIPTION: Defines a TopLevel component in SpinalHDL. This component instantiates the PLL BlackBox, creates a new clock domain driven by the PLL output, and adapts an external asynchronous reset to a synchronous reset within the new clock domain. It serves as the top-level module for integrating the PLL and reset logic into a larger hardware system.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Simple ones/pll_resetctrl.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ncase class TopLevel(pllDiv : Int) extends Component {\n  val config = ClockDomainConfig(resetKind = ASYNC)\n\n  val pllCd = new ClockDomain(\n    clock = in Bool(),\n    reset = in Bool(),\n    config = config\n  )\n\n  pllCd.clockDomain. নামকরণ(\"pllCd\")\n\n  val coreCd = ClockDomain.internal(\"coreCd\",\n    frequency = FixedFrequency(100 MHz))\n\n  coreCd. নামকরণ(\"coreCd\")\n\n  val pll = PLL(pllDiv)\n  pll.clkIn := pllCd.clock\n\n  coreCd.clock := pll.clkOut\n\n  val asyncResetIn = in Bool()\n  coreCd.reset := pllCd.clockDomain { //Connect asyncResetIn to coreCd.reset asynchronously\n    AsyncReset(False) //False means reset is low active\n    val resetCtrl = out(ResetController(config))\n    resetCtrl.io.asyncReset := asyncResetIn\n    resetCtrl.io.clockEnable := True\n    resetCtrl.reset\n  }\n\n  //your wishbone slave, on coreCd clock domain\n  val bus = slave(wishbone.Wishbone(wishbone.WishboneConfig(addressWidth = 32, dataWidth = 32)))\n  bus.setName(\"bus\")\n  bus.addAttribute(ClockDomainTag(coreCd))\n\n  when(coreCd.isResetActive) {\n    bus.ack #= False\n    bus.writeDataMux.removeAssignments()\n    bus.writeDataMux.default #= 0\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: UInt/SInt Declaration and Assignment - Scala\nDESCRIPTION: This snippet demonstrates how to declare UInt and SInt variables in SpinalHDL, and different ways to assign values to them. It covers the use of U() and S() constructors, string literals with base specification, and Scala Int literals.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Int.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval myUInt = UInt(8 bit)\nmyUInt := U(2, 8 bit)\nmyUInt := U(2)\nmyUInt := U\"0000_0101\"  // Base per default is binary => 5\nmyUInt := U\"h1A\"        // Base could be x (base 16)\n                           //               h (base 16)\n                           //               d (base 10)\n                           //               o (base 8)\n                           //               b (base 2)                       \nmyUInt := U\"8'h1A\"       \nmyUInt := 2             // You can use a Scala Int as a literal value\n\nval myBool = Bool()\nmyBool := myUInt === U(7 -> true, (6 downto 0) -> false)\nmyBool := myUInt === U(8 bit, 7 -> true, default -> false)\nmyBool := myUInt === U(myUInt.range -> true)\n\n// For assignment purposes, you can omit the U/S\n// which also allows the use of \"default -> ???\"\nmyUInt := (default -> true)                        // Assign myUInt with \"11111111\"\nmyUInt := (myUInt.range -> true)                   // Assign myUInt with \"11111111\"\nmyUInt := (7 -> true, default -> false)            // Assign myUInt with \"10000000\"\nmyUInt := ((4 downto 1) -> true, default -> false) // Assign myUInt with \"00011110\"\n```\n\n----------------------------------------\n\nTITLE: Counter Instantiation and Usage - Scala\nDESCRIPTION: This snippet demonstrates the instantiation and usage of the Counter tool in SpinalHDL. It shows how to create a counter with a specific range, as well as how to use the various methods and signals available for controlling and monitoring the counter's state.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/utils.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval counter = Counter(2 to 9) // Creates a counter of 8 states (2 to 9)\n// Methods\ncounter.clear()               // Resets the counter\ncounter.increment()           // Increments the counter\n// Signals\ncounter.value                 // Current value\ncounter.valueNext             // Next value\ncounter.willOverflow          // True if the counter overflows this cycle\ncounter.willOverflowIfInc     // True if the counter would overflow this cycle if an increment was done\n// Cast\nwhen(counter === 5){ ... }    // counter is implicitly casted to its current value\n```\n\n----------------------------------------\n\nTITLE: Bundle Signal Assignment in SpinalHDL\nDESCRIPTION: Illustrates how to perform bundle assignments in SpinalHDL by grouping signals together using Scala tuples. Shows how to convert collections of signals into a single bit-bus for assignment purposes using .asBits.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/assignments.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval a, b, c = UInt(4 bits)\nval d       = UInt(12 bits)\nval e       = Bits(10 bits)\nval f       = SInt(2  bits)\nval g       = Bits()\n\n(a, b, c) := B(0, 12 bits)\n(a, b, c) := d.asBits\n(a, b, c) := (e, f).asBits           // both sides\ng         := (a, b, c, e, f).asBits  // and on the right hand side\n```\n\n----------------------------------------\n\nTITLE: ClockDomain Instantiation in Scala\nDESCRIPTION: This code snippet demonstrates how to instantiate a ClockDomain in SpinalHDL with clock, reset, softReset, clockEnable, frequency, and config parameters. It shows the basic syntax for defining a clock domain.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nClockDomain(\n  clock: Bool \n  [,reset: Bool]\n  [,softReset: Bool]\n  [,clockEnable: Bool]\n  [,frequency: IClockDomainFrequency]\n  [,config: ClockDomainConfig]\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a StateMachine Instance - Scala\nDESCRIPTION: This snippet demonstrates how to create a new instance of the StateMachine class in SpinalHDL. This is the base class for defining state machines, and state definitions will be added inside.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/fsm.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval myFsm = new StateMachine {\n  // Definition of states\n}\n```\n\n----------------------------------------\n\nTITLE: Stream Fork Implementation in SpinalHDL (Scala)\nDESCRIPTION: Presents different ways to implement StreamFork, creating copies of the input stream to multiple output streams. Shows synchronous and asynchronous variants.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/stream.rst#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval inputStream = Stream(Bits(8 bits))\nval (outputstream1, outputstream2) = StreamFork2(inputStream, synchronous=false)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval inputStream = Stream(Bits(8 bits))\nval outputStreams = StreamFork(inputStream,portCount=2, synchronous=true)\n```\n\n----------------------------------------\n\nTITLE: Conditional Signal in Bundle - Scala\nDESCRIPTION: This snippet showcases how to conditionally define signals within a SpinalHDL Bundle based on a condition.  The `data` signal (of type UInt) is only included in the bundle if `dataWidth` is greater than 0. This leverages the `generate` method.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bundle.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase class myBundle(dataWidth: Int) extends Bundle {\n  val data = (dataWidth > 0) generate (UInt(dataWidth bits))\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Pipeline Example - SpinalHDL\nDESCRIPTION: This example demonstrates a basic pipeline setup with three nodes connected by stage links. It defines Payload instances for data transfer, binds the input and output streams to the pipeline, and generates the hardware using the Builder. This showcases the core components of the pipelining API.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core._\nimport spinal.core.sim._\nimport spinal.lib._\nimport spinal.lib.misc.pipeline._\n\nclass TopLevel extends Component {\n  val io = new Bundle {\n    val up = slave Stream (UInt(16 bits))\n    val down = master Stream (UInt(16 bits))\n  }\n\n  // Let's define 3 Nodes for our pipeline\n  val n0, n1, n2 = Node()\n\n  // Let's connect those nodes by using simples registers\n  val s01 = StageLink(n0, n1)\n  val s12 = StageLink(n1, n2)\n\n  // Let's define a few Payload things that can go through the pipeline\n  val VALUE = Payload(UInt(16 bits))\n  val RESULT = Payload(UInt(16 bits))\n\n  // Let's bind io.up to n0\n  io.up.ready := n0.ready\n  n0.valid := io.up.valid\n  n0(VALUE) := io.up.payload\n\n  // Let's do some processing on n1\n  n1(RESULT) := n1(VALUE) + 0x1200\n\n  // Let's bind n2 to io.down\n  n2.ready := io.down.ready\n  io.down.valid := n2.valid\n  io.down.payload := n2(RESULT)\n\n  // Let's ask the builder to generate all the required hardware\n  Builder(s01, s12)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Apb3SpiXdrMasterCtrl in Scala\nDESCRIPTION: This Scala code configures the Apb3SpiXdrMasterCtrl, specifying parameters such as data width, timer width, and the physical SPI interface. It defines the SPI's data width, IO rate, and chip select width. It also configures full-duplex and half-duplex modes with specific IDs, rates, DDR settings, and SPI width. The configuration also includes FIFO depths for command and response queues, and specifies an XIP configuration (which is set to null in this example).\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Com/spiXdr.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nApb3SpiXdrMasterCtrl(\n        SpiXdrMasterCtrl.MemoryMappingParameters(\n          SpiXdrMasterCtrl.Parameters(\n            dataWidth = 8, // Each transfer will be 8 bits\n            timerWidth = 12, // The timer is used to slow down the transmission\n            spi = SpiXdrParameter( // Specify the physical SPI interface\n              dataWidth = 4, // Number of physical SPI data pins\n              ioRate = 1, // Specify the number of transfer that each spi pin can do per clock 1 => SDR, 2 => DDR\n              ssWidth = 1 // Number of chip selects\n            )\n          )\n          .addFullDuplex(id = 0) // Add support for regular SPI (MISO / MOSI) using the mode id 0\n          .addHalfDuplex( // Add another mode\n            id = 1,  // mapped on mode id 1\n            rate = 1, // When rate is 1, the clock will do up to one toggle per cycle, divided by the (timer+1)\n                      // When rate bigger (ex 2), the controller will ignore the timer, and use the SpiXdrParameter.ioRate\n                      // capabilities to emit up to \"rate\" transition per clock cycle.\n            ddr = false, // sdr => 1 bit per SPI clock, DDR => 2 bits per SPI clock\n            spiWidth = 4 // Number of physical SPI data pin used for serialization\n          ),\n          cmdFifoDepth = 32,\n          rspFifoDepth = 32,\n          xip = null\n        )\n      )\n```\n\n----------------------------------------\n\nTITLE: StreamCCByToggle Instantiation and Connection - Scala\nDESCRIPTION: Instantiates a StreamCCByToggle component, a cross-clock domain bridge based on toggling signals, and connects it to two Stream interfaces (streamA and streamB) operating in different clock domains (clockA and clockB). This component provides a low-area, low-bandwidth clock domain crossing solution.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/stream.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval clockA = ClockDomain(???)\nval clockB = ClockDomain(???)\nval streamA,streamB = Stream(Bits(8 bits))\n// ...\nval bridge = StreamCCByToggle(\n  dataType    = Bits(8 bits),\n  inputClock  = clockA,\n  outputClock = clockB\n)\nbridge.io.input  << streamA\nbridge.io.output >> streamB\n```\n\n----------------------------------------\n\nTITLE: Conditional Assignment with Switch/Is/Default in Scala\nDESCRIPTION: This code demonstrates the basic usage of 'switch', 'is', and 'default' for conditional signal assignment based on the value of a signal. It allows executing different code blocks based on the value of 'x'. The 'default' block is executed if none of the 'is' conditions are met.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/when_switch.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nswitch(x) {\n  is(value1) {\n    // Execute when x === value1\n  }\n  is(value2) {\n    // Execute when x === value2\n  }\n  default {\n    // Execute if none of precedent conditions met\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: TriState Usage Example in Scala\nDESCRIPTION: This example shows how to use the TriState bundle in SpinalHDL. It creates a dataBus signal of type TriState(Bits(32 bits)). It then sets the writeEnable signal to True and the write signal to 0x12345678. It also shows a conditional statement based on the value of the read signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/IO/tristate.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval io = new Bundle {\n  val dataBus = master(TriState(Bits(32 bits)))\n}\n\nio.dataBus.writeEnable := True\nio.dataBus.write := 0x12345678\nwhen(io.dataBus.read === 42) {\n\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an AdderCell Component in SpinalHDL\nDESCRIPTION: This code defines a simple AdderCell component in SpinalHDL with input ports a, b, cin and output ports sum, cout. It also shows how to connect these ports using SpinalHDL syntax.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/components_hierarchy.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass AdderCell() extends Component {\n  // Declaring external ports in a Bundle called `io` is recommended\n  val io = new Bundle {\n    val a, b, cin = in port Bool()\n    val sum, cout = out port Bool()\n  }\n  // Do some logic\n  io.sum := io.a ^ io.b ^ io.cin\n  io.cout := (io.a & io.b) | (io.a & io.cin) | (io.b & io.cin)\n}\n```\n\n----------------------------------------\n\nTITLE: Counter with Clear Implementation in SpinalHDL (Scala)\nDESCRIPTION: This Scala code defines a SpinalHDL component named 'Counter' with a 'clear' input and a 'value' output. The counter increments its value on each clock cycle unless the 'clear' input is asserted, in which case the counter resets to zero. The component inherits from 'Component' and uses 'Bool' and 'UInt' data types.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Simple ones/counter_with_clear.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Counter(\n  width: Int\n) extends Component {\n  val io = new Bundle {\n    val clear = in Bool()\n    val value = out UInt (width bits)\n  }\n\n  val counter = Reg(UInt(width bits)) init (0)\n  when(io.clear) {\n    counter := 0\n  } otherwise {\n    counter := counter + 1\n  }\n  io.value := counter\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a SpinalEnum\nDESCRIPTION: This code shows how to declare an enumeration in SpinalHDL using the SpinalEnum object. It defines an enumeration with multiple elements, each created using the newElement() method. This example demonstrates the default enumeration encoding.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/enum.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject Enumeration extends SpinalEnum {\n  val element0, element1, ..., elementN = newElement()\n}\n```\n\n----------------------------------------\n\nTITLE: ROV Register Field Example with RegIf in Scala\nDESCRIPTION: Demonstrates the use of ROV (ReadOnly Value) register fields in RegIf.  This allows embedding a constant value into the register, useful for version information or other fixed parameters. The value is specified directly during field definition.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval version = M_REG0.field(Bits(32 bit), RO, 0, \"xx-device version\")\n   version := BigInt(\"F000A801\", 16)\n```\n\nLANGUAGE: scala\nCODE:\n```\nM_REG0.field(Bits(32 bit), ROV, BigInt(\"F000A801\", 16), \"xx-device version\")(Symbol(\"Version\"))\n```\n\n----------------------------------------\n\nTITLE: Timeout Instantiation and Usage - Scala\nDESCRIPTION: This snippet demonstrates the instantiation and usage of the Timeout tool in SpinalHDL. It shows how to create a timeout with a specific duration, as well as how to use the various methods and signals available for checking and clearing the timeout flag.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/utils.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval timeout = Timeout(10 ms)  // Timeout who tick after 10 ms\nwhen(timeout) {               // Check if the timeout has tick\n    timeout.clear()           // Ask the timeout to clear its flag\n}\n```\n\n----------------------------------------\n\nTITLE: Component Definition in SpinalHDL\nDESCRIPTION: This code demonstrates how to define components in SpinalHDL, similar to modules in VHDL and Verilog. It shows the creation of an 'AdderCell' component with input and output signals defined within an 'io' Bundle. The component performs a full adder function. It also shows an example of instantiating it twice and in an array.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/miscelenea/core/core_components.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nclass AdderCell extends Component {\n  // Declaring all in/out in an io Bundle is probably a good practice\n  val io = new Bundle {\n    val a, b, cin = in Bool()\n    val sum, cout = out Bool()\n  }\n  // Do some logic\n  io.sum := io.a ^ io.b ^ io.cin\n  io.cout := (io.a & io.b) | (io.a & io.cin) | (io.b & io.cin)\n}\n\nclass Adder(width: Int) extends Component {\n  ...\n  // Create 2 AdderCell\n  val cell0 = new AdderCell\n  val cell1 = new AdderCell\n  cell1.io.cin := cell0.io.cout // Connect carrys\n  ...\n  val cellArray = Array.fill(width)(new AdderCell)\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UartCtrl Configuration Bundles in Scala\nDESCRIPTION: This snippet defines the UartCtrlFrameConfig and UartCtrlConfig bundles, which are used as IO elements to configure the UartCtrl. UartCtrlFrameConfig contains settings for the data width, parity type, and stop bit count. UartCtrlConfig includes the frame configuration and the clock divider value. These bundles allow for configurable UART parameters.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/uart.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ncase class UartCtrlFrameConfig(generics: UartCtrlGenerics) extends Bundle {\n  val dataLength = UInt(log2Up(generics.dataWidthMax + 1) bits)\n  val parity     = ParityType()\n  val stop       = StopBitCount()\n\n  def getFullWidth(): Int = dataLength.maxValue.toInt + 1 + parity.maxId + 1 + stop.maxId + 1\n}\n\n\ncase class UartCtrlConfig(generics: UartCtrlGenerics) extends Bundle {\n  val frame = UartCtrlFrameConfig(generics)\n  val clockDivider = UInt(generics.clockDividerWidth bits)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UartCtrlTx in Scala\nDESCRIPTION: This snippet implements the UartCtrlTx component, responsible for transmitting data over the UART. It takes UartCtrlGenerics as a parameter.  It includes a clock divider, a tick counter, and a state machine to handle the transmission process. The component has inputs for the frame configuration, sampling tick, and data to write, and an output for the UART txd pin.  RegNext is used to ensure the txd output is registered.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/uart.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass UartCtrlTx(g : UartCtrlGenerics) extends Component {\n    import g._\n\n    val io = new Bundle {\n      val configFrame  = in(UartCtrlFrameConfig(g))\n      val samplingTick = in Bool()\n      val write        = slave Stream (Bits(dataWidthMax bits))\n      val txd          = out Bool()\n    }\n\n    // Provide one clockDivider.tick each rxSamplePerBit pulses of io.samplingTick\n    // Used by the stateMachine as a baud rate time reference\n    val clockDivider = new Area {\n      val counter = Reg(UInt(log2Up(getRxSamplePerBit()) bits)) init(0)\n      val tick = False\n      when(io.samplingTick){\n        counter := counter + 1\n        tick := counter === getRxSamplePerBit() - 1\n      }\n    }\n\n    // Count up each clockDivider.tick, used by the state machine to count up data bits and stop bits\n    val tickCounter = new Area {\n      val value = Reg(UInt(Math.max(dataWidthMax, 2) bits))\n      def reset() = value := 0\n      when(clockDivider.tick) {\n        value := value + 1\n      }\n    }\n\n    val stateMachine = new Area {\n      import UartCtrlTxState._\n\n      val state = RegInit(IDLE)\n      val parity = Reg(Bool())\n      val txd = True\n\n      io.write.ready := (state === IDLE)\n\n      switch(state) {\n        is(IDLE) {\n          when(io.write.valid) {\n            state := START\n            tickCounter.reset()\n          }\n        }\n        is(START) {\n          txd := False\n          when(clockDivider.tick) {\n            state := DATA\n            tickCounter.reset()\n            parity := False\n          }\n        }\n        is(DATA) {\n          txd := io.write.payload(tickCounter.value)\n          parity := parity ^ txd\n          when(clockDivider.tick) {\n            when(tickCounter.value === io.configFrame.dataLength - 1) {\n              when(io.configFrame.parity === ParityType.NONE) {\n                state := STOP\n              } otherwise {\n                state := PARITY\n              }\n            } otherwise {\n              tickCounter.value := tickCounter.value + 1\n            }\n          }\n        }\n        is(PARITY) {\n          when(io.configFrame.parity === ParityType.EVEN) {\n            txd := parity\n          } otherwise {\n            txd := !parity\n          }\n          when(clockDivider.tick) {\n            state := STOP\n          }\n        }\n        is(STOP) {\n          txd := True\n          when(clockDivider.tick) {\n            when(io.configFrame.stop === StopBitCount.ONE) {\n              state := IDLE\n            } otherwise {\n              when(tickCounter.value === 1) {\n                state := IDLE\n              } otherwise {\n                tickCounter.value := tickCounter.value + 1\n              }\n            }\n          }\n        }\n      }\n    }\n\n    io.txd := RegNext(stateMachine.txd) init(True)\n  }\n```\n\n----------------------------------------\n\nTITLE: Complete SoC Example - Scala\nDESCRIPTION: This shows a complete SoC example where memory mappings are printed based on the configuration of CpuFiber, RamFiber, and GpioFiber instances connected via tilelink.fabric.Node.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/tilelink/tilelink_fabric.rst#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval cpu = new CpuFiber()\n\nval ram = new RamFiber()\nram.up at(0x10000, 0x200) of cpu.down\n        \n// Create a peripherals namespace to keep things clean\nval peripherals = new Area {\n  // Create a intermediate node in the interconnect\n  val access = tilelink.fabric.Node()\n  access at 0x20000 of cpu.down\n\n  val gpioA = new GpioFiber()\n  gpioA.up at 0x0000 of access\n\n  val gpioB = new GpioFiber()\n  gpioB.up at 0x1000 of access\n}\n```\n\n----------------------------------------\n\nTITLE: Parametrization from Scala in SpinalHDL\nDESCRIPTION: This Scala code demonstrates how to parametrize the VHDL/Verilog generation process in SpinalHDL using the 'SpinalConfig' object.  It shows how to set options like the target directory and generation mode (VHDL or Verilog).  The example sets the target directory and specifies either VHDL or Verilog generation for a 'UartCtrl' component.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/vhdl_generation.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nSpinalConfig(mode=VHDL, targetDirectory=\"temp/myDesign\").generate(new UartCtrl)\n\n   // Or for Verilog in a more scalable formatting:\n   SpinalConfig(\n     mode=Verilog,\n     targetDirectory=\"temp/myDesign\"\n   ).generate(new UartCtrl)\n```\n\n----------------------------------------\n\nTITLE: Implementing UartCtrlRx in Scala\nDESCRIPTION: This code snippet shows the implementation of the UartCtrlRx component, which is responsible for receiving data through UART. This includes a sampler, a bit timer and a bit counter which work together to filter the incoming signal, sync to the baudrate, and count the number of bits received. The state machine controls the overall reception process.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/uart.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nclass UartCtrlRx(g : UartCtrlGenerics) extends Component {\n    import g._\n    val io = new Bundle {\n      val configFrame  = in(UartCtrlFrameConfig(g))\n      val samplingTick = in Bool()\n      val read         = master Flow (Bits(dataWidthMax bits))\n      val rxd          = in Bool()\n    }\n\n    // Implement the rxd sampling with a majority vote over samplingSize bits\n    // Provide a new sampler.value each time sampler.tick is high\n    val sampler = new Area {\n      val syncroniser = BufferCC(io.rxd)\n      val samples     = History(that=syncroniser,when=io.samplingTick,length=samplingSize)\n      val value       = RegNext(MajorityVote(samples))\n      val tick        = RegNext(io.samplingTick)\n    }\n\n    // Provide a bitTimer.tick each rxSamplePerBit\n    // reset() can be called to recenter the counter over a start bit.\n    val bitTimer = new Area {\n      val counter = Reg(UInt(log2Up(getRxSamplePerBit()) bits))\n      def reset() = counter := preSamplingSize + (samplingSize - 1) / 2 - 1\n      val tick = False\n      when(sampler.tick) {\n        counter := counter + 1\n        tick := counter === getRxSamplePerBit() - 1\n      }\n    }\n\n    // Provide bitCounter.value that count up each bitTimer.tick, Used by the state machine to count data bits and stop bits\n    // reset() can be called to reset it to zero\n    val bitCounter = new Area {\n      val value = Reg(UInt(Math.max(dataWidthMax, 2) bits))\n      def reset() = value := 0\n      when(bitTimer.tick) {\n        value := value + 1\n      }\n    }\n\n    val stateMachine = new Area {\n      import UartCtrlRxState._\n\n      val state   = RegInit(IDLE)\n      val parity  = Reg(Bool())\n      val shifter = Reg(io.read.payload)\n\n      io.read.valid := False\n\n      switch(state) {\n        is(IDLE) {\n          when(!sampler.value) {\n            state := START\n            bitCounter.reset()\n            bitTimer.reset()\n          }\n        }\n        is(START) {\n          when(bitTimer.tick) {\n            state := DATA\n            bitCounter.reset()\n          }\n        }\n        is(DATA) {\n          when(bitTimer.tick) {\n            shifter(bitCounter.value) := sampler.value\n            parity := parity ^ sampler.value\n            when(bitCounter.value === io.configFrame.dataLength - 1) {\n              when(io.configFrame.parity === ParityType.NONE) {\n                state := STOP\n              } otherwise {\n                state := PARITY\n              }\n            } otherwise {\n              bitCounter.value := bitCounter.value + 1\n            }\n          }\n        }\n        is(PARITY) {\n          when(bitTimer.tick) {\n            when(io.configFrame.parity === ParityType.EVEN) {\n              when(parity === sampler.value) {\n                state := STOP\n              } otherwise {\n                state := IDLE //TODO error\n              }\n            } otherwise {\n              when(parity === !sampler.value) {\n                state := STOP\n              } otherwise {\n                state := IDLE //TODO error\n              }\n            }\n          }\n        }\n        is(STOP) {\n          when(bitTimer.tick) {\n            io.read.valid := True\n            when(io.configFrame.stop === StopBitCount.ONE) {\n              state := IDLE\n            } otherwise {\n              when(bitCounter.value === 1) {\n                state := IDLE\n              } otherwise {\n                bitCounter.value := bitCounter.value + 1\n              }\n            }\n          }\n        }\n      }\n    }\n\n    io.read.payload := shifter\n  }\n```\n\n----------------------------------------\n\nTITLE: Parametrization from Shell in SpinalHDL\nDESCRIPTION: This Scala code demonstrates how to parametrize SpinalHDL component generation from the command line. It defines a 'main' function that uses 'SpinalConfig.shell(args)' to parse command line arguments and then generates the hardware description for a 'UartCtrl' component. The function takes an array of string arguments from the command line and processes them to configure the SpinalHDL generation process.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/vhdl_generation.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef main(args: Array[String]): Unit = {\n     SpinalConfig.shell(args)(new UartCtrl)\n   }\n```\n\n----------------------------------------\n\nTITLE: Using Configuration Classes for SpinalHDL Components\nDESCRIPTION: This code shows how to use configuration classes (case classes) to manage multiple parameters for a SpinalHDL component. This approach promotes code reusability and makes design parameters more manageable.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/components_hierarchy.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ncase class MySocConfig(axiFrequency  : HertzNumber,\n                         onChipRamSize : BigInt,\n                         cpu           : RiscCoreConfig,\n                         iCache        : InstructionCacheConfig)\n\nclass MySoc(config: MySocConfig) extends Component {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Stream Width Adapter Initialization in SpinalHDL (Scala)\nDESCRIPTION: Illustrates how to initialize a StreamWidthAdapter to convert between streams with different data widths. The first example uses default settings for data placement, while the second specifies a different ordering.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/stream.rst#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval inStream = Stream(Bits(8 bits))\nval outStream = Stream(Bits(16 bits))\nval adapter = StreamWidthAdapter(inStream, outStream)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval inStream = Stream(Bits(8 bits))\nval outStream = Stream(Bits(16 bits))\nval adapter = StreamWidthAdapter(inStream, outStream, order = SlicesOrder.HIGHER_FIRST)\n```\n\n----------------------------------------\n\nTITLE: Clock Domain Frequency Specification in Scala\nDESCRIPTION: This example demonstrates how to define a clock domain with a fixed frequency and how to use that frequency value to calculate a clock divider for a UART controller.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval coreClockDomain = ClockDomain(coreClock, coreReset, frequency=FixedFrequency(100e6))\n\nval coreArea = new ClockingArea(coreClockDomain) {\n  val ctrl = new UartCtrl()\n  ctrl.io.config.clockDivider := (coreClk.frequency.getValue / 57.6e3 / 8).toInt\n}\n```\n\n----------------------------------------\n\nTITLE: Clock Domain Crossing with Registers in Scala\nDESCRIPTION: This example illustrates how to handle clock domain crossing by using two register stages to avoid metastability issues. It showcases tagging a signal with `crossClockDomain` when reading a signal from a different clock domain.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\n// Implementation where clock and reset pins are given by components' IO\nclass CrossingExample extends Component {\n  val io = new Bundle {\n    val clkA = in Bool()\n    val rstA = in Bool()\n\n    val clkB = in Bool()\n    val rstB = in Bool()\n\n    val dataIn  = in Bool()\n    val dataOut = out Bool()\n  }\n\n  // sample dataIn with clkA\n  val area_clkA = new ClockingArea(ClockDomain(io.clkA,io.rstA)) {\n    val reg = RegNext(io.dataIn) init(False)\n  }\n\n  // 2 register stages to avoid metastability issues\n  val area_clkB = new ClockingArea(ClockDomain(io.clkB,io.rstB)) {\n    val buf0   = RegNext(area_clkA.reg) init(False) addTag(crossClockDomain)\n    val buf1   = RegNext(buf0)          init(False)\n  }\n\n  io.dataOut := area_clkB.buf1\n}\n\n\n// Alternative implementation where clock domains are given as parameters\nclass CrossingExample(clkA : ClockDomain,clkB : ClockDomain) extends Component {\n  val io = new Bundle {\n    val dataIn  = in Bool()\n    val dataOut = out Bool()\n  }\n\n  // sample dataIn with clkA\n  val area_clkA = new ClockingArea(clkA) {\n    val reg = RegNext(io.dataIn) init(False)\n  }\n\n  // 2 register stages to avoid metastability issues\n  val area_clkB = new ClockingArea(clkB) {\n    val buf0   = RegNext(area_clkA.reg) init(False) addTag(crossClockDomain)\n    val buf1   = RegNext(buf0)          init(False)\n  }\n\n  io.dataOut := area_clkB.buf1\n}\n```\n\n----------------------------------------\n\nTITLE: Synchronous Enable Quirk Example in SpinalHDL\nDESCRIPTION: This example illustrates a quirk related to synchronous enables within conditional blocks (when statements). It highlights that the condition of the when statement is not considered when inferring the enable signal, and suggests including the condition directly in the enable signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Sequential logic/memory.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval rom = Mem(Bits(10 bits), 32)\nwhen(cond) {\n  io.rdata := rom.readSync(io.addr, io.rdEna)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nio.rdata := rom.readSync(io.addr, io.rdEna & cond)\n```\n\n----------------------------------------\n\nTITLE: Creating a Reset Area in Scala\nDESCRIPTION: This example demonstrates how to create a `ResetArea` where a special reset signal is combined with the current clock domain reset, allowing for either exclusive reset or a combination of resets.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n\n  val specialReset = Bool()\n\n  // The reset of this area is done with the specialReset signal \n  val areaRst_1 = new ResetArea(specialReset, false) {\n    val counter = out(CounterFreeRun(16).value)\n  }\n\n  // The reset of this area is a combination between the current reset and the specialReset\n  val areaRst_2 = new ResetArea(specialReset, true) {\n    val counter = out(CounterFreeRun(16).value)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Concatenating Bits\nDESCRIPTION: Illustrates how to concatenate multiple bit vectors into a single bit vector in SpinalHDL using Scala. It shows two equivalent methods: using the `##` operator and the `Cat` function.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bits.rst#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nmyBits_24bits := bits_8bits_1 ## bits_8bits_2 ## bits_8bits_3\n// or\nmyBits_24bits := Cat(bits_8bits_1, bits_8bits_2, bits_8bits_3)\n```\n\n----------------------------------------\n\nTITLE: Simulation Testbench for Asynchronous Adder - SpinalHDL Scala\nDESCRIPTION: This snippet provides a simulation testbench for the 'Dut' component using SpinalHDL's simulation framework. It initializes the simulation with waveform tracing enabled, compiles the 'Dut' component, and then performs 100 simulation iterations. In each iteration, it generates random 8-bit inputs for a, b, and c, applies them to the DUT, waits for one simulation timestep, and asserts that the output is equal to (a + b - c) & 0xFF.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/examples/asynchronous.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nSimConfig.withWave.compile(new Dut).doSim{ dut =>\n    var idx = 0\n    while(idx < 100) {\n      val a, b, c = Random.nextInt(256)\n      dut.io.a #= a\n      dut.io.b #= b\n      dut.io.c #= c\n      sleep(1) // Sleep 1 simulation timestep\n      assert(dut.io.result.toInt == ((a + b - c) & 0xFF))\n      idx += 1\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Binary-List to Int/Long/BigInt Conversion in Scala\nDESCRIPTION: Illustrates how to convert a binary list to an Int, Long or BigInt value using the `binIntsToInt`, `binIntsToLong`, and `binIntsToBigInt` methods respectively. This functionality depends on the `spinal.core.lib._` import. Examples are provided to show their usage and outputs.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/binarySystem.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core.lib._\n\n   $: List(1, 1, 1, 0, 0, 1).binIntsToInt\n   39\n   $: List(1, 1, 1, 0:, 0, 1).binIntsToLong\n   39\n   $: List(0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1).binIntsToBigInt\n   1302309988\n```\n\n----------------------------------------\n\nTITLE: USB OHCI Controller Instantiation and Configuration in SpinalHDL\nDESCRIPTION: This Scala code snippet demonstrates how to instantiate and configure the `UsbOhci` controller within a SpinalHDL component. It showcases the creation of a `UsbOhciTop` component that incorporates the OHCI controller, a USB PHY, and clock domain crossings. It also shows the configuration of Bmb parameters for the controller's memory interface and how to propagate signals to external IO ports.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Com/usb_ohci.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport spinal.core._\nimport spinal.core.sim._\nimport spinal.lib.bus.bmb._\nimport spinal.lib.bus.bmb.sim._\nimport spinal.lib.bus.misc.SizeMapping\nimport spinal.lib.com.usb.ohci._\nimport spinal.lib.com.usb.phy.UsbHubLsFs.CtrlCc\nimport spinal.lib.com.usb.phy._\n\nclass UsbOhciTop(val p : UsbOhciParameter) extends Component {\n  val ohci = UsbOhci(p, BmbParameter(\n    addressWidth = 12,\n    dataWidth = 32,\n    sourceWidth = 0,\n    contextWidth = 0,\n    lengthWidth = 2\n  ))\n\n  val phyCd = ClockDomain.external(\"phyCd\", frequency = FixedFrequency(48 MHz))\n  val phy = phyCd(UsbLsFsPhy(p.portCount, sim=true))\n\n  val phyCc = CtrlCc(p.portCount, ClockDomain.current, phyCd)\n  phyCc.input <> ohci.io.phy\n  phyCc.output <> phy.io.ctrl\n\n  // propagate io signals\n  val irq = ohci.io.interrupt.toIo\n  val ctrl = ohci.io.ctrl.toIo\n  val dma = ohci.io.dma.toIo\n  val usb = phy.io.usb.toIo\n  val management = phy.io.management.toIo\n}\n```\n\n----------------------------------------\n\nTITLE: State Logic Definition - Scala\nDESCRIPTION: This example shows how to define the logic associated with a state using onEntry, onExit, whenIsActive, and whenIsNext blocks within a SpinalHDL state machine. These blocks specify actions to be performed when entering, exiting, or being active in a given state.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/fsm.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval stateB : State = new State {\n  onEntry(counter := 0)\n  whenIsActive {\n    counter := counter + 1\n    when(counter === 4) {\n      goto(stateC)\n    }\n  }\n  onExit(io.result := True)\n}\n```\n\n----------------------------------------\n\nTITLE: RO Register Field Example with RegIf in Scala\nDESCRIPTION: Illustrates the usage of a read-only (RO) register field in RegIf.  It demonstrates how to connect an external signal to the RO field, ensuring the register reflects the external signal's value. This example shows driving the 'counter' field with the 'io.cnt' input.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval io = new Bundle {\n     val cnt = in UInt(8 bit)\n   }\n\n   val counter = M_REG0.field(UInt(8 bit), RO, 0, \"counter\")\n   counter :=  io.cnt\n```\n\nLANGUAGE: scala\nCODE:\n```\nval xxstate = M_REG0.field(UInt(8 bit), RO, 0, \"xx-ctrl state\").asInput\n```\n\nLANGUAGE: scala\nCODE:\n```\nval overflow = M_REG0.field(Bits(32 bit), RO, 0, \"xx-ip parameter\")\n   val ovfreg = Reg(32 bit)\n   overflow := ovfreg\n```\n\nLANGUAGE: scala\nCODE:\n```\nval inc    = in Bool()\n   val counter = M_REG0.field(UInt(8 bit), RO, 0, \"counter\")\n   val cnt = Counter(100,  inc)\n   counter := cnt\n```\n\n----------------------------------------\n\nTITLE: Defining the Uart Interface in Scala\nDESCRIPTION: This snippet defines the Uart interface bundle, which represents the UART interface without flow control. It includes the txd (transmitter output) and rxd (receiver input) signals. This interface is used for connecting the UART controller to external devices.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/uart.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class Uart(\n  txd: Bool, // Data to send\n  rxd: Bool  // Data received\n) extends Bundle\n```\n\n----------------------------------------\n\nTITLE: Parasite Field Interrupt Raw Reg\nDESCRIPTION: Illustrates the usage of parasite fields for interrupt raw registers with a force interface.  This allows software to both observe the raw interrupt status and force interrupts for debugging purposes.  Dependencies include the `newRegAt` and `field` methods of the `RegIf` library.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval RAW    = this.newRegAt(offset,\"Interrupt Raw status Register\\n set when event \\n clear raw when write 1\")\nval FORCE  = this.newReg(\"Interrupt Force  Register\\n for SW debug use \\n write 1 set raw\")\n\nval raw    = RAW.field(Bool(), AccessType.W1C,    resetValue = 0, doc = s\"raw, default 0\" )\n             FORCE.parasiteField(raw, AccessType.W1S,   resetValue = 0, doc = s\"force, write 1 set, debug use\" )\n```\n\n----------------------------------------\n\nTITLE: Defining UartCtrlTx State Enumeration in Scala\nDESCRIPTION: This snippet defines the UartCtrlTxState enumeration, representing the possible states of the UartCtrlTx state machine. The states are IDLE, START, DATA, PARITY, and STOP. The state machine controls the transmission sequence of the UART.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/uart.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject UartCtrlTxState extends SpinalEnum(binarySequential) {\n  val IDLE, START, DATA, PARITY, STOP = newElement()\n}\n```\n\n----------------------------------------\n\nTITLE: Automatic Address Allocation with RegIf in Scala\nDESCRIPTION: Demonstrates automatic address allocation using the RegIf in SpinalHDL. It creates a register bank with registers M_REG0, M_REG1, M_REG2, M_REGn, and M_REGn1 using Apb3BusInterface. An address is explicitly assigned to M_REGn, while others are automatically allocated.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass RegBankExample extends Component {\n    val io = new Bundle {\n      apb = slave(Apb3(Apb3Config(16,32)))\n    }\n    val busif = Apb3BusInterface(io.apb,(0x0000, 100 Byte))\n    val M_REG0  = busif.newReg(doc=\"REG0\")\n    val M_REG1  = busif.newReg(doc=\"REG1\")\n    val M_REG2  = busif.newReg(doc=\"REG2\")\n\n    val M_REGn  = busif.newRegAt(address=0x40, doc=\"REGn\")\n    val M_REGn1 = busif.newReg(doc=\"REGn1\")\n\n    busif.accept(HtmlGenerator(\"regif\", \"AP\"))\n    // busif.accept(CHeaderGenerator(\"header\", \"AP\"))\n    // busif.accept(JsonGenerator(\"regif\"))\n    // busif.accept(RalfGenerator(\"regbank\"))\n    // busif.accept(SystemRdlGenerator(\"regif\", \"AP\"))\n  }\n```\n\n----------------------------------------\n\nTITLE: Creating and Assigning Vec Elements - Scala\nDESCRIPTION: This code demonstrates how to create a Vec of signed integers, access its elements using indices, and assign values to them. It showcases basic Vec initialization and element assignment.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Vec.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// Create a vector of 2 signed integers\nval myVecOfSInt = Vec.fill(2)(SInt(8 bits))\nmyVecOfSInt(0) := 2                   // assignment to populate index 0\nmyVecOfSInt(1) := myVecOfSInt(0) + 3  // assignment to populate index 1\n```\n\n----------------------------------------\n\nTITLE: Tilelink Bus Instantiation (Coherent) - Scala\nDESCRIPTION: This code snippet shows the instantiation of two coherent Tilelink buses in SpinalHDL.  It defines more detailed bus parameters, including sink width, BCE support, and data channel configurations (A, B, C, D). It then creates two bus instances (busA and busB) based on these parameters and connects them.  Note that the node parameter is set to null, which might require further attention depending on the intended use.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/tilelink/tilelink.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport spinal.lib.bus.tilelink\nval param = tilelink.BusParameter(\n  addressWidth = 32,\n  dataWidth = 64,\n  sizeBytes = 64,\n  sourceWidth = 4,\n  sinkWidth = 0,\n  withBCE = false,\n  withDataA = true,\n  withDataB = false,\n  withDataC = false,\n  withDataD = true,\n  node = null\n)\nval busA, busB = tilelink.Bus(param)\nbusA << busB\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple SpinalHDL Component in Scala\nDESCRIPTION: This code snippet defines a simple SpinalHDL component named `MyTopLevel`. It includes input and output ports, a register, and combinatorial logic. The component increments a counter based on input conditions and sets output signals based on the counter's value.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Introduction/A simple example.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class MyTopLevel() extends Component {\n  val io = new Bundle {\n    val cond0 = in port Bool()\n    val cond1 = in port Bool()\n    val flag  = out port Bool()\n    val state = out port UInt(8 bits)\n  }\n\n  val counter = Reg(UInt(8 bits)) init 0\n\n  when(io.cond0) {\n    counter := counter + 1\n  }\n\n  io.state := counter\n  io.flag  := (counter === 0) | io.cond1\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing stateReg Value - Scala\nDESCRIPTION: This snippet shows how to access the state value using `stateReg` within the state machine definition. Using the `postBuild` method ensures that `stateReg` is initialized.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/fsm.rst#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\n//  After or inside the fsm's definition.    \nfsm.postBuild{\n  io.status := fsm.stateReg.asBits //io.status is the signal user want to assigned to.\n}\n```\n\n----------------------------------------\n\nTITLE: VGA Controller Component Definition in Scala\nDESCRIPTION: Defines the VgaCtrl SpinalHDL Component, taking RgbConfig and timingsWidth as parameters. It includes input signals for soft reset, timings, and pixel stream, as well as output signals for error, frame start, and the VGA interface.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/vga.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ncase class VgaCtrl(rgbConfig: RgbConfig, timingsWidth: Int = 12) extends Component {\n  import rgbConfig._\n  val io = new Bundle {\n    val softReset = in Bool()\n    val timings = in(VgaTimingsHV(timingsWidth))\n    val pixels = slave Stream Bits(colorWidth bits)\n\n    val error = out Bool()\n    val frameStart = out Bool()\n    val vga = master(Vga(rgbConfig))\n  }\n```\n\n----------------------------------------\n\nTITLE: HSRW/RWHS Register Field Example with RegIf in Scala\nDESCRIPTION: Illustrates the usage of HSRW (Hardware Set, Software Read/Write) and RWHS (Software Read/Write, Hardware Set) register fields in RegIf. This allows both hardware and software to modify the register, with priority determined by the access type.  'xxx_set' enables hardware setting, and 'xxx_set_val' provides the hardware value.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval io = new Bundle {\n     val xxx_set = in Bool()\n     val xxx_set_val = in Bits(32 bit)\n   }\n\n   val reg0 = M_REG0.fieldHSRW(io.xxx_set, io.xxx_set_val, 0, \"xx-device version\")  // 0x0000\n   val reg1 = M_REG1.fieldRWHS(io.xxx_set, io.xxx_set_val, 0, \"xx-device version\")  // 0x0004\n```\n\n----------------------------------------\n\nTITLE: Defining UartCtrlGenerics in Scala\nDESCRIPTION: This snippet defines the UartCtrlGenerics case class, which groups the construction parameters (generics) for the UartCtrl component. These parameters include dataWidthMax (maximum data bits), clockDividerWidth, preSamplingSize, samplingSize, and postSamplingSize. The case class is used as a single parameter for the UartCtrl constructor to simplify the implementation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/uart.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class UartCtrlGenerics(\n  dataWidthMax      : Int,  // Maximum number of data bits that could be sent using a single UART frame\n  clockDividerWidth : Int,  // Number of bits that the clock divider has\n  preSamplingSize   : Int,  // Number of samples to drop at the beginning of the sampling window\n  samplingSize      : Int,  // Number of samples use at the middle of the window to get the filtered RXD value\n  postSamplingSize  : Int   // Number of samples to drop at the end of the sampling window\n) {\n  def getRxTimeBase(): Int = preSamplingSize + samplingSize + postSamplingSize\n  def getRxSamplePerBit(): Int = getRxTimeBase()\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Memory Blackboxing in SpinalHDL\nDESCRIPTION: This example shows how to enable automatic blackboxing of memories in SpinalHDL using the SpinalConfig. It demonstrates how to add a standard memory blackboxing policy and generate VHDL code for a top-level module.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Sequential logic/memory.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef main(args: Array[String]) {\n  SpinalConfig()\n    .addStandardMemBlackboxing(blackboxAll)\n    .generateVhdl(new TopLevel)\n}\n```\n\n----------------------------------------\n\nTITLE: External Clock Definition in Scala\nDESCRIPTION: This code shows how to define an external clock domain using `ClockDomain.external`. It highlights the use of named external clock and reset signals for top-level connections.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nClockDomain.external(\n  name: String,\n  [config: ClockDomainConfig,] \n  [withReset: Boolean,] \n  [withSoftReset: Boolean,]\n  [withClockEnable: Boolean,]\n  [frequency: IClockDomainFrequency]\n)\n```\n\n----------------------------------------\n\nTITLE: APB3 UART Controller Implementation in Scala\nDESCRIPTION: Defines an Apb3UartCtrl component which instantiates a UartCtrl and creates the memory mapping logic between it and the APB3 bus using Apb3SlaveFactory. It includes registers for clock divider, frame configuration, write command, write busy status, and read data.  The component utilizes the UartCtrl component for UART functionality and the APB3 bus interface for memory mapping.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Advanced ones/memory_mapped_uart.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class Apb3UartCtrl(\n    apb3Config: Apb3Config,\n    uartCtrlConfig: UartCtrl.Config\n) extends Component {\n  import spinal.core._\n  import spinal.lib._\n  import spinal.lib.bus.amba3.apb._\n  import spinal.lib.bus.misc.BusSlaveFactory\n\n  val io = new Bundle {\n    val apb3 = slave(Apb3(apb3Config))\n    val uart = master(Uart())\n  }\n\n  val uartCtrl = new UartCtrl(uartCtrlConfig)\n  io.uart <> uartCtrl.io.uart\n\n  val busCtrl = Apb3SlaveFactory(io.apb3, 0)\n  busCtrl.driveAndRead(uartCtrl.io.config.clockDivider, 0, \"clockDivider\")\n  busCtrl.driveAndRead(uartCtrl.io.config.frame, 4, \"frame\")\n\n  // write\n  uartCtrl.io.write.valid := busCtrl.isWriting(8)\n  uartCtrl.io.write.payload := busCtrl.write(8)(7 downto 0)\n  busCtrl.read(uartCtrl.io.write.ready, 8, 0, \"writeBusy\")\n\n  // read\n  busCtrl.read(uartCtrl.io.read.payload, 12, 0, \"read\")\n  busCtrl.read(uartCtrl.io.read.valid, 12, 31, \"readValid\")\n}\n```\n\n----------------------------------------\n\nTITLE: Bool Comparison in SpinalHDL (Scala)\nDESCRIPTION: This snippet shows how to compare Bool signals in SpinalHDL using the === (equality) and =/= (inequality) operators.  It also demonstrates the implicit comparison to True and False when using a Bool in a when statement.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bool.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nwhen(myBool) { // Equivalent to when(myBool === True)\n    // do something when myBool is True\n}\n\nwhen(!myBool) { // Equivalent to when(myBool === False)\n    // do something when myBool is False\n}\n```\n\n----------------------------------------\n\nTITLE: Area Usage in SpinalHDL\nDESCRIPTION: This example shows how to use 'Area' in SpinalHDL to group related logic without creating a full component. It defines a 'timer' area with a counter and a 'tick' signal.  It also defines a 'tickCounter' area which increments based on the 'timer.tick' signal. This provides a way to organize code within a component.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/miscelenea/core/core_components.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nclass UartCtrl extends Component {\n  ...\n  val timer = new Area {\n    val counter = Reg(UInt(8 bits))\n    val tick = counter === 0\n    counter := counter - 1\n    when(tick) {\n      counter := 100\n    }\n  }\n  val tickCounter = new Area {\n    val value = Reg(UInt(3 bits))\n    val reset = False\n    when(timer.tick) {          // Refer to the tick from timer area\n      value := value + 1\n    }\n    when(reset) {\n      value := 0\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Forking a Standard Reset/Clock Process - Scala\nDESCRIPTION: This snippet illustrates how to fork a standard reset and clock process in SpinalHDL using the forkStimulus function. The period parameter determines the clock cycle duration. This example utilizes the implicit clock domain.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/clock.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndut.clockDomain.forkStimulus(period = 10)\n```\n\n----------------------------------------\n\nTITLE: FixPoint Rounding Operations in SpinalHDL (Scala)\nDESCRIPTION: This snippet demonstrates various rounding operations for fixpoint numbers in SpinalHDL, including `roundToInf`, `floor`, `ceil`, `roundUp`, `roundDown`, and `roundToZero`. It covers the usage of the `align` parameter and explains how different rounding modes affect the bit width of the resulting signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Int.rst#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval A  = SInt(16 bits)\n   val B  = A.roundToInf(6 bits)         // default 'align = false' with carry, got 11 bit\n   val B  = A.roundToInf(6 bits, align = true) // sat 1 carry bit, got 10 bit\n   val B  = A.floor(6 bits)              // return 10 bit\n   val B  = A.floorToZero(6 bits)        // return 10 bit\n   val B  = A.ceil(6 bits)               // ceil with carry so return 11 bit\n   val B  = A.ceil(6 bits, align = true) // ceil with carry then sat 1 bit return 10 bit\n   val B  = A.ceilToInf(6 bits)\n   val B  = A.roundUp(6 bits)\n   val B  = A.roundDown(6 bits)\n   val B  = A.roundToInf(6 bits)\n   val B  = A.roundToZero(6 bits)\n   val B  = A.round(6 bits)              // SpinalHDL uses roundToInf as the default rounding mode\n\n   val B0 = A.roundToInf(6 bits, align = true)         //  ---+\n                                                       //     |--> equal\n   val B1 = A.roundToInf(6 bits, align = false).sat(1) //  ---+\n```\n\n----------------------------------------\n\nTITLE: Standard Signal Assignment in SpinalHDL\nDESCRIPTION: Demonstrates standard signal assignment using the := operator in SpinalHDL. Shows how assignments work in conjunction with other signals and the consequences of assignment overlaps.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/assignments.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval a, b, c = UInt(4 bits)\na := 0\nb := a\n// a := 1 // this would cause an `assignment overlap` error,\n           // if manually overridden the assignment would take assignment priority\nc := a\n\nvar x = UInt(4 bits)\nval y, z = UInt(4 bits)\nx := 0\ny := x      // y read x with the value 0\nx \\= x + 1\nz := x      // z read x with the value 1\n\n// Automatic connection between two UART interfaces.\nuartCtrl.io.uart <> io.uart\n```\n\n----------------------------------------\n\nTITLE: VGA Controller Definition in SpinalHDL (Scala)\nDESCRIPTION: Defines the VGA controller as a SpinalHDL Component. It includes input signals for soft reset and VGA timings, output signals for frame start and error, and a slave stream for pixel data. The timingsWidth parameter sets the width of the timing signals. The frameStart signal pulses at the beginning of each new frame, and the error signal is high when pixel data is needed but not available.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Graphics/vga.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ncase class VgaCtrl(rgbConfig: RgbConfig, timingsWidth: Int = 12) extends Component {\n  val io = new Bundle {\n    val softReset = in Bool()\n    val timings   = in(VgaTimings(timingsWidth))\n\n    val frameStart = out Bool()\n    val pixels     = slave Stream (Rgb(rgbConfig))\n    val vga        = master(Vga(rgbConfig))\n\n    val error      = out Bool()\n  }\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Signals to Registers with setAsReg()\nDESCRIPTION: This code shows how to transform an existing signal into a register using the setAsReg() function.  It demonstrates using this on a port of a bundle and also setting the initial value.  It also describes the note that register is created in the clock domain of the signal where the bundle is defined.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Sequential logic/registers.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval io = new Bundle {\n   val apb = master(Apb3(apb3Config))\n}\n\nio.apb.PADDR.setAsReg()\nio.apb.PWRITE.setAsReg() init(False)\n\nwhen(someCondition) {\n   io.apb.PWRITE := True\n}\n```\n\n----------------------------------------\n\nTITLE: Simulation with simSuccess() and Thread Suspension\nDESCRIPTION: This snippet shows an alternative approach to ending a simulation with simSuccess(). The simThread.suspend() call prevents the doSim block from completing, allowing the simulation to continue until simSuccess() is called from the forked thread.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/bootstraps.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nSimConfig.compile(new TopLevel).doSim{ dut =>\n  SimTimeout(1000)\n  dut.clockDomain.forkStimulus(10)\n  fork {\n    dut.clockDomain.waitSamplingWhere(dut.counter.toInt == 20)\n    println(\"done\")\n    simSuccess()\n  }\n  simThread.suspend() // Avoid the \"doSim\" completion\n}\n```\n\n----------------------------------------\n\nTITLE: APB3 Bus Instantiation Example\nDESCRIPTION: Demonstrates how to instantiate the Apb3 bus in SpinalHDL using the Apb3Config object. It creates two APB3 interfaces, apbX and apbY, with specified address and data widths. It also shows a simple usage example where actions are performed when PENABLE is asserted on apbY.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/amba3/apb3.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval apbConfig = Apb3Config(\n     addressWidth = 12,\n     dataWidth    = 32\n   )\n   val apbX = Apb3(apbConfig)\n   val apbY = Apb3(apbConfig)\n\n   when(apbY.PENABLE) {\n     // ...\n   }\n```\n\n----------------------------------------\n\nTITLE: Dual Port RAM Example in SpinalHDL\nDESCRIPTION: This example demonstrates how to create a simple dual-port RAM with 32-bit data width and 256 words using the Mem class in SpinalHDL. It shows how to define write and read ports with enable signals and address inputs.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Sequential logic/memory.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval mem = Mem(Bits(32 bits), wordCount = 256)\nmem.write(\n  enable  = io.writeValid,\n  address = io.writeAddress,\n  data    = io.writeData\n)\n\nio.readData := mem.readSync(\n  enable  = io.readValid,\n  address = io.readAddress\n)\n```\n\n----------------------------------------\n\nTITLE: Allowing Assignment Override - Scala\nDESCRIPTION: This example shows how to explicitly allow overriding a previous assignment using the `allowOverride` method. This is useful when the override is intentional and necessary. The call to `a.allowOverride` disables the assignment overlap check for signal 'a', permitting the subsequent assignment to overwrite the initial one.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/assignment_overlap.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val a = UInt(8 bits)\n  a := 42\n  a.allowOverride\n  a := 66\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UartCtrl in Scala\nDESCRIPTION: This snippet defines the UartCtrl component, which instantiates UartCtrlRx and UartCtrlTx, generates the clock divider, and connects them. The UartCtrl takes a UartCtrlGenerics object and configures the rx and tx components.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/uart.rst#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nclass UartCtrl(g : UartCtrlGenerics) extends Component {\n    import g._\n\n    val io = new Bundle {\n      val config  = slave  UartCtrlConfig(g)\n      val uart    = master Uart(Bool(),Bool())\n      val write   = slave  Stream (Bits(dataWidthMax bits))\n      val read    = master Flow (Bits(dataWidthMax bits))\n    }\n\n    val clockDivider = new Area {\n      val counter = Reg(UInt(clockDividerWidth bits)) init(0)\n      val tick = False\n\n      counter := counter + 1\n      tick := counter === io.config.clockDivider\n    }\n\n    val frameConfig = new Area {\n      val config = Reg(UartCtrlFrameConfig(g))\n      when(clockDivider.tick) {\n        config.load(io.config.frame)\n      }\n    }\n\n    val uartTx = new UartCtrlTx(g)\n    uartTx.io.configFrame := frameConfig.config\n    uartTx.io.samplingTick := clockDivider.tick\n    uartTx.io.write << io.write\n    io.uart.txd := uartTx.io.txd\n\n    val uartRx = new UartCtrlRx(g)\n    uartRx.io.configFrame := frameConfig.config\n    uartRx.io.samplingTick := clockDivider.tick\n    uartRx.io.rxd := io.uart.rxd\n    io.read >> uartRx.io.read\n  }\n```\n\n----------------------------------------\n\nTITLE: Signal Instantiation in SpinalHDL (Scala)\nDESCRIPTION: This example shows how to instantiate signals in SpinalHDL. It demonstrates creating UInt signals, assigning values to them, and using them in expressions. It also illustrates how to assign a value to a component output.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_perspective.rst#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ncase class MyComponent(offset: Int) extends Component {\n  val io = new Bundle {\n    val a, b, c = UInt(8 bits)\n    val result  = UInt(8 bits)\n  }\n  val ab = UInt(8 bits)\n  ab := a + b\n\n  val abc = ab + c            // You can define a signal directly with its value\n  io.result := abc + offset\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Toplevel Component\nDESCRIPTION: This code snippet defines a basic toplevel SpinalHDL component with an 8-bit counter. The counter is incremented every clock cycle and exposed as an output.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/bootstraps.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n   val counter = out(Reg(UInt(8 bits)) init (0))\n   counter := counter + 1\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrate JTAG TAP Usage in SpinalHDL\nDESCRIPTION: Demonstrates how to create an application-specific JTAG TAP using the defined components and functions. This example creates a JTAG TAP to read switch and key inputs and write to LED outputs, including the ability to identify the TAP via a specified UID.  It instantiates the JtagTap, adds the specific instructions, and connects them accordingly.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Advanced ones/jtag.rst#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nclass SimpleJtagTap extends Component {\n  val io = new Bundle {\n    val jtag = slave(Jtag(Bool, Bool, TriState(Bool)))\n    val leds = out Bits (4 bits)\n    val switchs = in Bits (4 bits)\n    val keys = in Bits (2 bits)\n  }\n\n  val tap = new JtagTap(io.jtag, instructionWidth = 3)\n\n  import tap._\n  idcode(0x87654321)(instructionId = 1)\n  read(io.switchs ## io.keys)(instructionId = 2)\n  write(io.leds)(instructionId = 3)\n\n  io.leds := 0\n}\n```\n\n----------------------------------------\n\nTITLE: ClockDomain Example in Scala\nDESCRIPTION: This code defines a clock domain using `ClockDomain` and applies it to an `Area` named `coreArea`. Inside the `coreArea`, a register `coreClockedRegister` is instantiated, implicitly using the defined clock domain. This demonstrates how to create and use a clock domain within a specific region of the design.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval coreClock = Bool()\nval coreReset = Bool()\n\n// Define a new clock domain\nval coreClockDomain = ClockDomain(coreClock, coreReset)\n\n// Use this domain in an area of the design\nval coreArea = new ClockingArea(coreClockDomain) {\n  val coreClockedRegister = Reg(UInt(4 bits))\n}\n```\n\n----------------------------------------\n\nTITLE: MyBus Bundle with Parameterized Width in SpinalHDL (Scala)\nDESCRIPTION: This snippet defines a `MyBus` Bundle in SpinalHDL that accepts an integer `width` parameter. This parameter is used to define the width of the `mySignal` UInt signal within the bundle. This allows for creating different bus interfaces with varying signal widths based on the provided parameter.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/parametrization.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class MyBus(width : Int) extends Bundle {\n  val mySignal = UInt(width bits)\n}\n```\n\n----------------------------------------\n\nTITLE: Parametrizing a SpinalHDL Component\nDESCRIPTION: This code illustrates how to parameterize a SpinalHDL component by passing parameters to its constructor. It shows an example of a parameterized adder and demonstrates how to instantiate it with a specific width.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/components_hierarchy.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass MyAdder(width: BitCount) extends Component {\n  val io = new Bundle {\n    val a, b   = in port UInt(width)\n    val result = out port UInt(width)\n  }\n  io.result := io.a + io.b\n}\n\nobject Main {\n  def main(args: Array[String]) {\n    SpinalVhdl(new MyAdder(32 bits))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Flow Example in SpinalHDL\nDESCRIPTION: This Scala code snippet defines a `FlowExample` case class demonstrating the use of the Flow interface in SpinalHDL. The code shows the basic structure of a component utilizing Flow for data transfer. It serves as an example for implementing custom logic around the Flow interface.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/flow.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class FlowExample()\n```\n\n----------------------------------------\n\nTITLE: Internal Clock Creation in Scala\nDESCRIPTION: This code shows how to create an internal clock domain using `ClockDomain.internal`.  It defines the parameters for the internal clock domain, including name, config, and whether to include reset, soft reset, and clock enable. The advantage is to create clock and reset signals with a specified name.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nClockDomain.internal(\n  name: String,\n  [config: ClockDomainConfig,] \n  [withReset: Boolean,] \n  [withSoftReset: Boolean,]\n  [withClockEnable: Boolean,]\n  [frequency: IClockDomainFrequency]\n)\n```\n\n----------------------------------------\n\nTITLE: Defining APB3 Configuration Class in Scala\nDESCRIPTION: This Scala code defines a configuration class `Apb3Config` to specify the parameters of the APB3 bus, such as address width, data width, and selection width. These parameters are used to customize the APB3 interface.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Simple ones/apb3.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Apb3Config(\n  addressWidth : Int,\n  dataWidth    : Int,\n  selWidth     : Int\n) {\n  def getAddrSpace(): Long = (1l << addressWidth)\n  def getDataSpace(): Long = dataWidth / 8\n}\n```\n\n----------------------------------------\n\nTITLE: Easy Interrupt Creation with Factory\nDESCRIPTION: Demonstrates how to use the interrupt factory to automatically generate interrupt registers (RAW, FORCE, MASK, STATUS) and their associated logic. Dependencies include Apb3 and BusInterface.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nclass EasyInterrupt extends Component {\n val io = new Bundle {\n   val apb = slave(Apb3(Apb3Config(16,32)))\n   val a, b, c, d, e = in Bool()\n }\n\n val busif = BusInterface(io.apb,(0x000,1 KiB), 0, regPre = \"AP\")\n\n busif.interruptFactory(\"T\", io.a, io.b, io.c, io.d, io.e)\n\n busif.accept(CHeaderGenerator(\"intrreg\",\"AP\"))\n busif.accept(HtmlGenerator(\"intrreg\", \"Interupt Example\"))\n busif.accept(JsonGenerator(\"intrreg\"))\n busif.accept(RalfGenerator(\"intrreg\"))\n busif.accept(SystemRdlGenerator(\"intrreg\", \"AP\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Type Casting Vec to Bits - Scala\nDESCRIPTION: This code demonstrates how to cast a Vec to Bits. It shows how to convert a Vec into a single Bits value representing the concatenation of all elements.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Vec.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// Create a vector of 2 signed integers\nval vec1 = Vec.fill(2)(SInt(8 bits))\n\nmyBits_16bits := vec1.asBits\n```\n\n----------------------------------------\n\nTITLE: Valid Ready Payload Bus Definition - Scala\nDESCRIPTION: Defines a custom bus 'MyBus' with valid, ready, and payload signals using Scala's case class and SpinalHDL's Bundle. Includes methods for direction definition (asMaster), connecting two buses (<<), and connecting to a FIFO (queue). It showcases the creation of a reusable hardware bus with associated logic.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/function.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ncase class MyBus(payloadWidth: Int) extends Bundle with IMasterSlave {\n  val valid   = Bool()\n  val ready   = Bool()\n  val payload = Bits(payloadWidth bits)\n\n  // Define the direction of the data in a master mode\n  override def asMaster(): Unit = {\n    out(valid, payload)\n    in(ready)\n  }\n\n  // Connect that to this\n  def <<(that: MyBus): Unit = {\n    this.valid   := that.valid\n    that.ready   := this.ready\n    this.payload := that.payload\n  }\n\n  // Connect this to the FIFO input, return the fifo output\n  def queue(size: Int): MyBus = {\n    val fifo = new MyBusFifo(payloadWidth, size)\n    fifo.io.push << this\n    return fifo.io.pop\n  }\n}\n\nclass MyBusFifo(payloadWidth: Int, depth: Int) extends Component {\n\n  val io = new Bundle {\n    val push = slave(MyBus(payloadWidth))\n    val pop  = master(MyBus(payloadWidth))\n  }\n\n  val mem = Mem(Bits(payloadWidth bits), depth)\n\n  // ...\n\n}\n```\n\n----------------------------------------\n\nTITLE: SpinalHDL Component Structure in Scala\nDESCRIPTION: This code snippet illustrates the basic structure of a SpinalHDL component in Scala. It shows how to define a component, declare an IO bundle for ports, and include the component's logic within the class definition. The component logic will define internal signals and how the ports are connected.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Introduction/A simple example.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class MyTopLevel() extends Component {\n  val io = new Bundle {\n    // port definitions go here\n  }\n\n  // component logic goes here\n}\n```\n\n----------------------------------------\n\nTITLE: Testing the Identity Component with SpinalSim\nDESCRIPTION: This code demonstrates how to create a testbench for the Identity component using SpinalSim. It iterates through all possible input values, applies them to the component, and verifies that the output matches the input. This testbench utilizes SimConfig for simulation setup and assertions for result verification.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/bootstraps.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core.sim._\n\nobject TestIdentity extends App {\n  // Use the component with n = 3 bits as \"dut\" (device under test)\n  SimConfig.withWave.compile(new Identity(3)).doSim{ dut =>\n    // For each number from 3'b000 to 3'b111 included\n    for (a <- 0 to 7) {\n      // Apply input\n      dut.io.a #= a\n      // Wait for a simulation time unit\n      sleep(1)\n      // Read output\n      val z = dut.io.z.toInt\n      // Check result\n      assert(z == a, s\"Got $z, expected $a\")\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced Pipeline Example - SpinalHDL\nDESCRIPTION: This example illustrates a more advanced usage of the pipelining API with NodesBuilder. It demonstrates how to create nodes that connect to input and output streams, perform processing, and generate a staged pipeline using the genStagedPipeline method.  It highlights the flexibility and control offered by the NodesBuilder.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core._\nimport spinal.core.sim._\nimport spinal.lib._\nimport spinal.lib.misc.pipeline._\n\nclass TopLevel extends Component {\n  val VALUE = Payload(UInt(16 bits))\n\n  val io = new Bundle {\n    val up = slave Stream(VALUE)  // VALUE can also be used as a HardType\n    val down = master Stream(VALUE)\n  }\n      \n  // NodesBuilder will be used to register all the nodes created, connect them via stages and generate the hardware\n  val builder = new NodesBuilder()\n\n  // Let's define a Node which connect from io.up\n  val n0 = new builder.Node {\n    arbitrateFrom(io.up)\n    VALUE := io.up.payload\n  }\n\n  // Let's define a Node which do some processing\n  val n1 = new builder.Node {\n    val RESULT = insert(VALUE + 0x1200)\n  }\n\n  //  Let's define a Node which connect to io.down\n  val n2 = new builder.Node {\n    arbitrateTo(io.down)\n    io.down.payload := n1.RESULT\n  }\n\n  // Let's connect those nodes by using registers stages and generate the related hardware\n  builder.genStagedPipeline()\n}\n```\n\n----------------------------------------\n\nTITLE: Uart RX Queue Implementation Scala\nDESCRIPTION: This snippet shows how to queue data received from the UART using a StreamFifo in SpinalHDL.  It sets up a FIFO buffer to store incoming UART data, enabling asynchronous processing of received bytes.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/uart.rst#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nval rxBuffer = StreamFifo(Bits(8 bits), 32)\n  rxBuffer.io.push.valid := rx.valid\n  rxBuffer.io.push.payload := rx.payload\n  rx.ready := rxBuffer.io.push.ready\n```\n\n----------------------------------------\n\nTITLE: Tilelink Bus Instantiation (Non-Coherent) - Scala\nDESCRIPTION: This code snippet demonstrates the instantiation of two non-coherent Tilelink buses using SpinalHDL. It defines bus parameters such as address width, data width, size in bytes, and source width, and then creates two bus instances (busA and busB) that are connected using the '<<' operator.  The 'simple' constructor is used for BusParameter.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/tilelink/tilelink.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport spinal.lib.bus.tilelink\nval param = tilelink.BusParameter.simple(\n  addressWidth = 32,\n  dataWidth    = 64,\n  sizeBytes    = 64,\n  sourceWidth  = 4\n)\nval busA, busB = tilelink.Bus(param)\nbusA << busB\n```\n\n----------------------------------------\n\nTITLE: Define a Three-Stage Addition Module - Scala\nDESCRIPTION: This code defines a reusable module `Plus3` that performs a series of three increment operations (+1) over three pipeline stages. It takes an input payload of type UInt and adds 1 at each stage. This example simulates a more complex operation like multiplication that might require multiple stages for FMax optimization.  It demonstrates how to insert intermediate results into the pipeline using `stageX.insert()`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\nclass Plus3(INPUT: Payload[UInt], stage1: Node, stage2: Node, stage3: Node) extends Area {\n  val ONE = stage1.insert(stage1(INPUT) + 1)\n  val TWO = stage2.insert(stage2(ONE) + 1)\n  val THREE = stage3.insert(stage3(TWO) + 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise Selection with muxListDc in Scala\nDESCRIPTION: This example showcases the use of `muxListDc` for selecting bits from a configurable width vector. It does not require covering all possible cases and will add a default case if needed, setting uncovered values to X's during simulation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/when_switch.rst#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ncase class Example(width: Int = 3) extends Component {\n  // 2 bit wide for default width\n  val sel = UInt(log2Up(count) bit)\n  val data = Bits(width*8 bit)\n  // no need to cover missing case 3 for default width\n  val dataByte = sel.muxListDc(for(i <- 0 until count) yield (i, data(index*8, 8 bit)))\n}\n```\n\n----------------------------------------\n\nTITLE: Nameable API usage in SpinalHDL (Scala)\nDESCRIPTION: Demonstrates how to use the Nameable API in SpinalHDL to explicitly set names for signals. It shows how to force a name, propose a name weakly, and create a composite name based on an existing signal's name.  This ensures specific signal names are used in the generated hardware.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass MyComponent extends Component {\n  val a, b, c, d = Bool()\n  b.setName(\"rawrr\") // Force name\n  c.setName(\"rawrr\", weak = true) // Propose a name, will not be applied if a stronger name is already applied\n  d.setCompositeName(b, postfix = \"wuff\") // Force toto to be named as b.getName() + _wuff\"\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise Selection with Mux in Scala\nDESCRIPTION: This code demonstrates the use of the 'mux' method for bitwise selection based on the value of a 'UInt' signal.  It allows selecting different operations (AND, OR, XOR) based on the value of 'bitwiseSelect'. All possible values must be covered to prevent latches.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/when_switch.rst#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval bitwiseSelect = UInt(2 bits)\nval bitwiseResult = bitwiseSelect.mux(\n  0 -> (io.src0 & io.src1),\n  1 -> (io.src0 | io.src1),\n  2 -> (io.src0 ^ io.src1),\n  3 -> (io.src0)\n)\n```\n\n----------------------------------------\n\nTITLE: TriState Bundle Definition in Scala\nDESCRIPTION: This code defines the TriState bundle in SpinalHDL. It includes read, write, and writeEnable signals. The read signal is used to read the outside value, writeEnable enables the output, and write sets the value driven on the output. It extends Bundle and IMasterSlave traits.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/IO/tristate.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class TriState[T <: Data](dataType : HardType[T]) extends Bundle with IMasterSlave {\n  val read,write : T = dataType()\n  val writeEnable = Bool()\n\n  override def asMaster(): Unit = {\n    out(write,writeEnable)\n    in(read)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Unsigned Fixed-Point Numbers (UFix) in SpinalHDL\nDESCRIPTION: This snippet demonstrates how to declare UFix (unsigned fixed-point) numbers in SpinalHDL using different constructors. It showcases the use of peak and resolution or peak and width to define the fixed-point representation. The ExpNumber type is used to represent powers of two for clarity.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Fix.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n// Unsigned Fixed-Point\nval UQ_8_2 = UFix(peak = 8 exp, resolution = -2 exp) // bit width = 8 - (-2) = 10 bits\nval UQ_8_2 = UFix(8 exp, -2 exp)\n\nval UQ_8_2 = UFix(peak = 8 exp, width = 10 bits)\nval UQ_8_2 = UFix(8 exp, 10 bits)\n```\n\n----------------------------------------\n\nTITLE: Node Payload Access and Manipulation Scala\nDESCRIPTION: This snippet demonstrates how to access and manipulate payloads within a Node in SpinalHDL. It shows how to assign values to payloads and conditionally execute code based on payload values.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nn0(PC) := 0x42\n    n0(PC, \"true\") := 0x42\n    n0(PC, 0x666) := 0xEE\n    val SOMETHING = n0.insert(myHardwareSignal) // This create a new Payload\n    when(n1(SOMETHING) === 0xFFAA){ ... }\n```\n\n----------------------------------------\n\nTITLE: RGB to Gray Converter in SpinalHDL Scala\nDESCRIPTION: This Scala code defines a SpinalHDL component, `RgbToGray`, that converts RGB color values to grayscale. It includes input signals for red, green, and blue, and output signals for memory write enable, address, and data (grayscale value). The component clears internal registers via an input signal and increments the memory address with each write.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Simple ones/rgb_to_gray.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class RgbToGray(\n  width : Int\n) extends Component{\n  import spinal.core._\n\n  val io = new Bundle{\n    val clear   = in  Bool()\n    val r,g,b = in UInt(width bits)\n\n    val wr      = out Bool()\n    val address = out UInt(32 bits)\n    val data    = out UInt(8 bits)\n  }\n\n  val grayLevel = (io.r + io.g + io.b) / 3\n  io.data := grayLevel.resized\n\n  val addressCounter = Reg(UInt(32 bits)) init(0)\n  when(io.clear){\n    addressCounter := 0\n  } otherwise {\n    addressCounter := addressCounter + 1\n  }\n\n  io.address := addressCounter\n  io.wr := True\n\n```\n\n----------------------------------------\n\nTITLE: Simple CPU Testbench using SpinalHDL (Scala)\nDESCRIPTION: This Scala code sets up a testbench for the CPU component using SpinalHDL's simulation framework. It initializes memory with a sequence of instructions to make the LED count up, and then runs the simulation for 100 clock cycles, demonstrating the CPU's basic operation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nSimConfig.withFstWave.compile(new Cpu).doSim(seed = 2){ dut =>\n  def nop() = BigInt(0)\n  def add(value: Int) = BigInt(1 | (value << 8))\n  def jump(target: Int) = BigInt(2 | (target << 8))\n  def led() = BigInt(3)\n  def delay(cycles: Int) = BigInt(4 | (cycles << 8))\n  val mem = dut.fetcher.mem\n  mem.setBigInt(0, nop())\n  mem.setBigInt(1, nop())\n  mem.setBigInt(2, add(0x1))\n  mem.setBigInt(3, led())\n  mem.setBigInt(4, delay(16))\n  mem.setBigInt(5, jump(0x2))\n\n  dut.clockDomain.forkStimulus(10)\n  dut.clockDomain.waitSampling(100)\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating and assigning a SpinalEnum\nDESCRIPTION: This code demonstrates how to instantiate an enumerated signal and assign a value to it in SpinalHDL. It first defines an enumeration `UartCtrlTxState`, then creates a signal `stateNext` of that type, and assigns the `sIdle` value to it. It also shows how to import the enumeration elements for easier access.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/enum.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject UartCtrlTxState extends SpinalEnum {\n  val sIdle, sStart, sData, sParity, sStop = newElement()\n}\n\nval stateNext = UartCtrlTxState()\nstateNext := UartCtrlTxState.sIdle\n\n// You can also import the enumeration to have visibility of its elements\nimport UartCtrlTxState._\nstateNext := sIdle\n```\n\n----------------------------------------\n\nTITLE: Using StateParallelFsm - Scala\nDESCRIPTION: This example shows how to use StateParallelFsm in SpinalHDL to handle multiple nested state machines. whenCompleted is executed when all nested state machines are done.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/fsm.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval stateD = new StateParallelFsm (internalFsmA(), internalFsmB()) {\n  whenCompleted {\n    goto(stateE)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Functions and Requirements to Configuration Classes in SpinalHDL\nDESCRIPTION: This code extends the configuration class example by demonstrating how to add functions and requirements to the configuration class. This allows for more complex parameter validation and calculation based on the configuration parameters.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/components_hierarchy.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ncase class MyBusConfig(addressWidth: Int, dataWidth: Int) {\n  def bytePerWord = dataWidth / 8\n  def addressType = UInt(addressWidth bits)\n  def dataType = Bits(dataWidth bits)\n\n  require(dataWidth == 32 || dataWidth == 64, \"Data width must be 32 or 64\")\n}\n```\n\n----------------------------------------\n\nTITLE: APB Timer Example in SpinalHDL Scala\nDESCRIPTION: This code instantiates a prescaler, a 32-bit timer, and three 16-bit timers. It then uses an Apb3SlaveFactory and the driveFrom function defined in the Timer component to create the APB3 bus bridging logic for all the timers.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Advanced ones/timer.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase class ApbTimer() extends Component {\n  import spinal.lib.bus.amba3.apb._\n  import spinal.lib._\n\n  val apbConfig = Apb3Config(addressWidth = 12, dataWidth = 32)\n  val io = new Bundle {\n    val apb = slave(Apb3(apbConfig))\n    val interrupt = out Bool()\n  }\n\n  val apbBridge = Apb3SlaveFactory(io.apb)\n  val prescaler = new Area {\n    val timer = new Timer(16)\n    timer.driveFrom(apbBridge, 0x000, List(True), List())\n  }\n\n  val timerMain = new Area {\n    val timer = new Timer(32)\n    timer.driveFrom(apbBridge, 0x100, List(prescaler.timer.io.full), List())\n  }\n\n  val timers = for(idx <- 0 to 2) yield new Area {\n    val timer = new Timer(16)\n    timer.driveFrom(apbBridge, 0x200 + idx*0x10, List(prescaler.timer.io.full), List())\n  }\n\n  io.interrupt := False //TODO\n}\n```\n\n----------------------------------------\n\nTITLE: SpinalHDL Component Instantiation\nDESCRIPTION: This SpinalHDL code shows a simplified way to instantiate a component using an object-oriented approach.  It demonstrates direct access to the component's IO signals.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\n   val divider = new UnsignedDivider()\n\n   // And then if you want to access IO signals of that divider:\n   divider.io.cmd.valid := True\n```\n\n----------------------------------------\n\nTITLE: CtrlLink Payload Access and Bypass Scala\nDESCRIPTION: This snippet illustrates how to access Payload data and conditionally bypass it using a CtrlLink.  It shows how to set a value and then selectively override that value when a condition (hazard) is met.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval c01 = CtrlLink(n0, n1)\n\n    val PC = Payload(UInt(32 bits))\n    c01(PC) := 0x42\n    c01(PC, 0x666) := 0xEE\n\n    val DATA = Payload(UInt(32 bits))\n    // Let's say Data is inserted in the pipeline before c01\n    when(hazard) {\n        c01.bypass(DATA) := fixedValue\n    }\n    \n    // c01(DATA) and below will get the hazard patch\n```\n\n----------------------------------------\n\nTITLE: Stream Arbiter Configuration in SpinalHDL (Scala)\nDESCRIPTION: Shows how to create Stream arbiters using the StreamArbiterFactory to select from multiple input streams.  Demonstrates round-robin and lower-first arbitration strategies.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/stream.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval streamA, streamB, streamC = Stream(Bits(8 bits))\nval arbitredABC = StreamArbiterFactory.roundRobin.onArgs(streamA, streamB, streamC)\n\nval streamD, streamE, streamF = Stream(Bits(8 bits))\nval arbitredDEF = StreamArbiterFactory.lowerFirst.noLock.onArgs(streamD, streamE, streamF)\n```\n\n----------------------------------------\n\nTITLE: Defining Area for Tick Counter Logic in SpinalHDL (Scala)\nDESCRIPTION: This code snippet defines an Area named 'tickCounter' within a SpinalHDL Component. It includes a register 'value', a signal 'reset', and logic to increment the counter on each 'timer.tick' and reset the counter when 'reset' is asserted. The tickCounter Area depends on the timer Area for the 'tick' signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/area.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n     val tickCounter = new Area {\n       val value = Reg(UInt(3 bits))\n       val reset = False\n       when(timer.tick) {          // Refer to the tick from timer area\n         value := value + 1\n       }\n       when(reset) {\n         value := 0\n       }\n     }\n```\n\n----------------------------------------\n\nTITLE: Building a SpinalHDL Pipeline - Scala\nDESCRIPTION: This snippet demonstrates how to finalize and build a SpinalHDL pipeline after all stages and configurations have been specified. It triggers the hardware generation process based on the defined pipeline structure.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\npip.build()\n```\n\n----------------------------------------\n\nTITLE: Parasite Field Example\nDESCRIPTION: Demonstrates how to use parasite fields to share the same register on multiple addresses, allowing software to interact with the same data in different ways (e.g., setting, clearing, or reading).  This example shows clock gate enable registers.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval M_CG_ENS_SET = busif.newReg(doc=\"Clock Gate Enables\")  // x00000\nval M_CG_ENS_CLR = busif.newReg(doc=\"Clock Gate Enables\")  // 0x0004\nval M_CG_ENS_RO  = busif.newReg(doc=\"Clock Gate Enables\")  // 0x0008\n\nval xx_sys_cg_en = M_CG_ENS_SET.field(Bits(4 bit), W1S, 0, \"clock gate enables, write 1 set\" )\n                   M_CG_ENS_CLR.parasiteField(xx_sys_cg_en, W1C, 0, \"clock gate enables, write 1 clear\" )\n                   M_CG_ENS_RO.parasiteField(xx_sys_cg_en, RO, 0, \"clock gate enables, read only\"\n```\n\n----------------------------------------\n\nTITLE: Parameter Grouping with Case Class (Scala)\nDESCRIPTION: Demonstrates how to group parameters of a `Component` or `Bundle` inside a case class for better maintainability and easier manipulation.  Shows how to define a configuration case class and then use it to define a Bundle.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/coding_conventions.rst#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ncase class RgbConfig(rWidth: Int, gWidth: Int, bWidth: Int) {\n     def getWidth = rWidth + gWidth + bWidth\n   }\n\n   case class Rgb(c: RgbConfig) extends Bundle {\n     val r = UInt(c.rWidth bits)\n     val g = UInt(c.gWidth bits)\n     val b = UInt(c.bWidth bits)\n   }\n```\n\n----------------------------------------\n\nTITLE: BusSlaveFactoryDelayed Elements - Scala\nDESCRIPTION: This code defines the case classes used to store primitives in the BusSlaveFactoryDelayed implementation. These case classes represent read, write, onWrite, onRead, and nonStopWrite operations, capturing the necessary data for later hardware generation based on the collected primitives.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/bus_slave_factory_impl.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntrait BusSlaveFactoryElement\n\n   // Ask to make `that` readable when a access is done on `address`.\n   // bitOffset specify where `that` is placed on the answer\n   case class BusSlaveFactoryRead(that : Data,\n                                  address : BigInt,\n                                  bitOffset : Int) extends BusSlaveFactoryElement\n\n   // Ask to make `that` writable when a access is done on `address`.\n   // bitOffset specify where `that` get bits from the request\n   case class BusSlaveFactoryWrite(that : Data,\n                                   address : BigInt,\n                                   bitOffset : Int) extends BusSlaveFactoryElement\n\n   // Ask to execute `doThat` when a write access is done on `address`\n   case class BusSlaveFactoryOnWrite(address : BigInt,\n                                     doThat : () => Unit) extends BusSlaveFactoryElement\n\n   // Ask to execute `doThat` when a read access is done on `address`\n   case class BusSlaveFactoryOnRead( address : BigInt,\n                                     doThat : () => Unit) extends BusSlaveFactoryElement\n\n   // Ask to constantly drive `that` with the data bus\n   // bitOffset specify where `that` get bits from the request\n   case class BusSlaveFactoryNonStopWrite(that : Data,\n```\n\n----------------------------------------\n\nTITLE: Combinational Logic in SpinalHDL (Scala)\nDESCRIPTION: This Scala code defines a SpinalHDL component 'TopLevel' with combinational logic. It includes input signals 'cond' and 'value', and output signals 'withoutProcess' and 'withProcess'. The 'withoutProcess' output is directly assigned the 'value' input.  The 'withProcess' output is assigned '8', '9' or 'io.value+1' depending on the value of the 'cond' input and 'value' input.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/vhdl_generation.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n     val io = new Bundle {\n       val cond           = in  Bool()\n       val value          = in  UInt(4 bits)\n       val withoutProcess = out UInt(4 bits)\n       val withProcess    = out UInt(4 bits)\n     }\n     io.withoutProcess := io.value\n     io.withProcess := 0\n     when(io.cond) {\n       switch(io.value) {\n         is(U\"0000\") {\n           io.withProcess := 8\n         }\n         is(U\"0001\") {\n           io.withProcess := 9\n         }\n         default {\n           io.withProcess := io.value+1\n         }\n       }\n     }\n   }\n```\n\n----------------------------------------\n\nTITLE: Stream Dispatcher Sequential in SpinalHDL (Scala)\nDESCRIPTION: Demonstrates StreamDispatcherSequencial, which routes an input stream to multiple output streams in a sequential, round-robin order.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/stream.rst#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nval inputStream = Stream(Bits(8 bits))\nval dispatchedStreams = StreamDispatcherSequencial(\n  input = inputStream,\n  outputCount = 3\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing Raw Fixed-Point Value in SpinalHDL\nDESCRIPTION: This snippet demonstrates how to access and modify the underlying integer representation of a UFix signal using the `raw` property in SpinalHDL. This allows direct manipulation of the fixed-point value at the bit level.  The example also shows assigning a UInt value to the raw property.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Fix.rst#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval UQ_8_2 = UFix(8 exp, 10 bits)\nUQ_8_2.raw := 4        // Assign the value corresponding to 1.0\nUQ_8_2.raw := U(17)    // Assign the value corresponding to 4.25\n```\n\n----------------------------------------\n\nTITLE: Uart Reception Implementation Scala\nDESCRIPTION: This snippet illustrates the reception logic for a UART using SpinalHDL. It focuses on using only the `rxd` pin for receiving serial data. The code captures and deserializes the incoming data stream, making it available for further processing.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/uart.rst#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nrxd_buffer := BufferCC(uartCtrl.io.uart.rxd)\n  rx.valid := False\n  rx.payload := 0\n  when(uartCtrl.io.uart.rxd && !rxd_buffer){\n    rx.valid := True\n    rx.payload := counter\n  }\n```\n\n----------------------------------------\n\nTITLE: Register Bank Creation with Apb3\nDESCRIPTION: Demonstrates batch creation of registers and fields for a register bank using the Apb3 bus interface.  It generates documentation in various formats (C header, HTML, JSON, RALF, SystemRDL).  Dependencies include spinal.lib.bus.regif.* and Apb3.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.lib.bus.regif._\n\nclass RegBank extends Component {\n  val io = new Bundle {\n    val apb = slave(Apb3(Apb3Config(16, 32)))\n    val stats = in Vec(Bits(16 bit), 10)\n    val IQ  = out Vec(Bits(16 bit), 10)\n  }\n  val busif = Apb3BusInterface(io.apb, (0x000, 100 Byte), regPre = \"AP\")\n\n  (0 to 9).map { i =>\n    // here use setName give REG uniq name for Docs usage\n    val REG = busif.newReg(doc = s\"Register${i}\").setName(s\"REG${i}\")\n    val real = REG.field(SInt(8 bit), AccessType.RW, 0, \"Complex real\")\n    val imag = REG.field(SInt(8 bit), AccessType.RW, 0, \"Complex imag\")\n    val stat = REG.field(Bits(16 bit), AccessType.RO, 0, \"Accelerator status\")\n    io.IQ(i)( 7 downto 0) := real.asBits\n    io.IQ(i)(15 downto 8) := imag.asBits\n    stat := io.stats(i)\n  }\n\n  def genDocs() = {\n    busif.accept(CHeaderGenerator(\"regbank\", \"AP\"))\n    busif.accept(HtmlGenerator(\"regbank\", \"Interupt Example\"))\n    busif.accept(JsonGenerator(\"regbank\"))\n    busif.accept(RalfGenerator(\"regbank\"))\n    busif.accept(SystemRdlGenerator(\"regbank\", \"AP\"))\n  }\n\n  this.genDocs()\n}\n\nSpinalVerilog(new RegBank())\n```\n\n----------------------------------------\n\nTITLE: NullPointerException example in SpinalHDL (Scala)\nDESCRIPTION: This code snippet demonstrates a common NullPointerException that occurs in SpinalHDL due to Scala's execution order. The variable 'b' is used before it is initialized, resulting in a null reference error when SpinalHDL tries to generate the hardware description. This is because SpinalHDL uses Scala's execution as part of the hardware generation process.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/miscelenea/frequent_errors.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval a = b + 1         // b can't be read at that time, because b isn't instantiated yet\nval b = UInt(4 bits)\n```\n\n----------------------------------------\n\nTITLE: Resizing Signal in SpinalHDL (Smart Way)\nDESCRIPTION: This demonstrates the 'smart' way to resize a signal in SpinalHDL. The `resized` method automatically infers the target bit width, simplifying the resizing process.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\n// The smart way\nmy8BitsSignal := my4BitsSignal.resized\n```\n\n----------------------------------------\n\nTITLE: StreamArbiter Component Definition - Scala\nDESCRIPTION: Defines a StreamArbiter component in SpinalHDL, which arbitrates between multiple input Stream interfaces and a single output Stream interface. It takes a dataType and portCount as parameters and provides a Vec of input Stream interfaces and a single output Stream interface.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/stream.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass StreamArbiter[T <: Data](dataType: T,portCount: Int) extends Component {\n  val io = new Bundle {\n    val inputs = Vec(slave Stream (dataType),portCount)\n    val output = master Stream (dataType)\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Component Stubbing Example - Scala\nDESCRIPTION: This snippet demonstrates how to create a stub of a SpinalHDL Component, effectively removing all internal logic and children. The SubSysModule is instantiated as a stub within the TopLevel component. This is achieved using the `.stub` method call. This method simplifies the module for initial verification or hardware prototyping by reducing logic complexity.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/stub.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass SubSysModule extends Component {\n       val io = new Bundle {\n         val dx = slave(Stream(Bits(32 bits)))\n         val dy = master(Stream(Bits(32 bits)))\n       }\n       io.dy <-< io.dx\n    }\n    class TopLevel extends Component {\n       val dut = new SubSysModule().stub   // instance an SubSysModule as empty stub\n    }\n```\n\n----------------------------------------\n\nTITLE: Implement JTAG Read Instruction\nDESCRIPTION: Implements a JTAG instruction that reads a signal. It takes the JtagTapAccess instance, the instruction ID, and the signal to be read as input. During the SHIFT_DR state, it shifts out the value of the signal via the TDO pin.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Advanced ones/jtag.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nclass JtagInstructionRead(owner: JtagTapAccess, instructionId: Bits, val read: Bits) extends JtagInstruction(owner, instructionId) {\n  Component.current.addPrePopTask(() => {\n    val fsm = owner.getFsmState()\n\n    when(fsm === JtagState.SHIFT_DR) {\n      //owner.getTdo().write(read.lsb)\n      //read := read >> 1\n    }\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Mux Implementation in Scala\nDESCRIPTION: This code demonstrates the use of 'Mux' for conditional signal selection based on a 'Bool' condition. It provides two equivalent syntaxes: using the 'Mux' function and using the ternary operator '? |'. Both achieve the same result of selecting either 'whenTrue' or 'whenFalse' based on 'cond'.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/when_switch.rst#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval cond = Bool()\nval whenTrue, whenFalse = UInt(8 bits)\nval muxOutput  = Mux(cond, whenTrue, whenFalse)\nval muxOutput2 = cond ? whenTrue | whenFalse\n```\n\n----------------------------------------\n\nTITLE: Renaming IOs of a BlackBox in SpinalHDL (Scala)\nDESCRIPTION: This code demonstrates how to rename IO signals of a SpinalHDL BlackBox using the `addPrePopTask` function. It flattens the IO bundle, iterates through the signals, and renames them based on whether they belong to portA or portB. The `renameIO` function is executed during compilation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/blackbox.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nclass MyRam() extends Blackbox {\n\n  val io = new Bundle {\n    val clk = in Bool()\n    val portA = new Bundle {\n      val cs   = in Bool()\n      val rwn  = in Bool()\n      val dIn  = in Bits(32 bits)\n      val dOut = out Bits(32 bits)\n    }\n    val portB = new Bundle {\n      val cs   = in Bool()\n      val rwn  = in Bool()\n      val dIn  = in Bits(32 bits)\n      val dOut = out Bits(32 bits)\n    }\n  }\n\n  // Map the clk \n  mapCurrentClockDomain(io.clk)\n\n  // Remove io_ prefix \n  noIoPrefix() \n\n  // Function used to rename all signals of the blackbox \n  private def renameIO(): Unit = {\n    io.flatten.foreach(bt => {\n      if(bt.getName().contains(\"portA\")) bt.setName(bt.getName().replace(\"portA_\", \"\") + \"_A\") \n      if(bt.getName().contains(\"portB\")) bt.setName(bt.getName().replace(\"portB_\", \"\") + \"_B\") \n    })\n  }\n\n  // Execute the function renameIO after the creation of the component \n  addPrePopTask(() => renameIO())\n}\n```\n\n----------------------------------------\n\nTITLE: Define RGB Processing Pipeline - Scala\nDESCRIPTION: This code defines a `RgbToSomething` component that processes an input stream of RGB values and outputs a processed 16-bit value. The processing involves summing the R, G, and B components, inverting the sum, and multiplying the result by 0xEE. The component allows for flexible stage assignment for each operation, enabling retiming and performance optimization. The `addAt`, `invAt`, `mulAt`, and `resultAt` parameters specify the pipeline stage at which each operation is performed.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\nclass RgbToSomething(addAt : Int,\n                     invAt : Int,\n                     mulAt : Int,\n                     resultAt : Int) extends Component {\n\n  val io = new Bundle {\n    val up = slave Stream(spinal.lib.graphic.Rgb(8, 8, 8))\n    val down = master Stream (UInt(16 bits))\n  }\n\n  // Let's define the Nodes for our pipeline.\n  val nodes = Array.fill(resultAt+1)(Node())\n\n  // Let's specify which node will be used for what part of the pipeline.\n  val insertNode = nodes(0)\n  val addNode = nodes(addAt)\n  val invNode = nodes(invAt)\n  val mulNode = nodes(mulAt)\n  val resultNode = nodes(resultAt)\n\n  // Define the hardware which will feed the io.up stream into the pipeline.\n  val inserter = new insertNode.Area {\n    arbitrateFrom(io.up)\n    val RGB = insert(io.up.payload)\n  }\n\n  // Sum the r g b values of the color.\n  val adder = new addNode.Area {\n    val SUM = insert(inserter.RGB.r + inserter.RGB.g + inserter.RGB.b)\n  }\n\n  // Flip all the bit of the RGB sum.\n  val inverter = new invNode.Area {\n    val INV = insert(~adder.SUM)\n  }\n\n  // Multiply the inverted bits with 0xEE.\n  val multiplier = new mulNode.Area {\n    val MUL = insert(inverter.INV*0xEE)\n  }\n\n  // Connect the end of the pipeline to the io.down stream.\n  val resulter = new resultNode.Area {\n    arbitrateTo(io.down)\n    io.down.payload := multiplier.MUL\n  }\n\n  // Let's connect those nodes sequentially by using simples registers.\n  val links = for (i <- 0 to resultAt - 1) yield StageLink(nodes(i), nodes(i + 1))\n\n  // Let's ask the builder to generate all the required hardware\n  Builder(links)\n}\n```\n\n----------------------------------------\n\nTITLE: Bundle Declaration Example - Scala\nDESCRIPTION: This snippet demonstrates how to declare a Bundle in SpinalHDL using a case class that extends the Bundle trait.  It defines a bundle with named signals (bundleItem0, bundleItem1, bundleItemN) of arbitrary types.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bundle.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class myBundle extends Bundle {\n  val bundleItem0 = AnyType\n  val bundleItem1 = AnyType\n  val bundleItemN = AnyType\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected UInt Operator Usage with Resizing in SpinalHDL (Scala)\nDESCRIPTION: This code presents the corrected implementation of the bitwise OR operation in SpinalHDL by resizing one of the operands to match the width of the other. 'b' is resized to match the width of 'a' before the operation. This requires the SpinalHDL library.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/width_mismatch.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val a = UInt(8 bits)\n  val b = UInt(4 bits)\n  val result = a | (b.resized)\n}\n```\n\n----------------------------------------\n\nTITLE: Stream Connection with throwWhen - Scala\nDESCRIPTION: Demonstrates how to connect two Stream interfaces with a throwWhen condition. The sink Stream receives data from the source Stream, but transactions are dropped when the source's payload is black (as determined by the RGB.isBlack method).\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/stream.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval source = Stream(RGB(8))\nval sink   = Stream(RGB(8))\nsink <-< source.throwWhen(source.payload.isBlack)\n```\n\n----------------------------------------\n\nTITLE: Saturating and Trimming SInt in SpinalHDL\nDESCRIPTION: This code demonstrates how to saturate and trim SInt signals in SpinalHDL. The sat function limits the signal within a range by setting values to max/min when overflowing. The trim function discards higher bits. Symmetry operation mirrors the negative range to positive.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Int.rst#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval A  = SInt(8 bits)\nval B  = A.sat(3 bits)      // return 5 bits with saturated highest 3 bits\nval B  = A.sat(3)           // equal to sat(3 bits)\nval B  = A.trim(3 bits)     // return 5 bits with the highest 3 bits discarded\nval B  = A.trim(3 bits)     // return 5 bits with the highest 3 bits discarded\nval C  = A.symmetry         // return 8 bits and symmetry as (-128~127 to -127~127)\nval C  = A.sat(3).symmetry  // return 5 bits and symmetry as (-16~15 to -15~15)\n```\n\n----------------------------------------\n\nTITLE: Hardware Generation with Scala for Loop in SpinalHDL (Scala)\nDESCRIPTION: This snippet shows how to generate multiple instances of hardware using a Scala for loop. The `amount` parameter determines the number of `Area` instances that will be created and stored in the `myHardware` collection. This allows for the creation of arrays of hardware elements based on a parameter.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/parametrization.rst#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ncase class MyComponent(amount : Int) extends Component {\n  val myHardware = for(i <- 0 until amount) yield new Area {\n    // hardware here\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Carry Adder Component in SpinalHDL (Scala)\nDESCRIPTION: This code defines a carry adder component in SpinalHDL using Scala. It takes two inputs, 'a' and 'b', and produces a 'result' output, which is the sum of the two inputs. The addition is implemented using a carry adder logic, ensuring a combinatorial output.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Simple ones/carry_adder.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class CarryAdder(width: Int) extends Component {\n  import spinal.core._\n\n  val io = new Bundle {\n    val a      = in  UInt(width bits)\n    val b      = in  UInt(width bits)\n    val result = out UInt(width bits)\n  }\n\n  import io._\n\n  val c = Array.fill(width + 1)(Reg(Bool()).init(False))\n  for (i <- 0 until width) {\n    val a_i = a(i)\n    val b_i = b(i)\n    c(i + 1) := a_i & b_i | a_i & c(i) | b_i & c(i)\n    result(i) := a_i ^ b_i ^ c(i)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Single Read-Write Port RAM Component in VHDL\nDESCRIPTION: This VHDL code declares a single read-write port RAM component. It shares the same port for both read and write operations. Generics control word count, word width, read-under-write behavior, and the memory technology. This reduces the number of ports but serializes read and write access.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Sequential logic/memory.rst#_snippet_7\n\nLANGUAGE: VHDL\nCODE:\n```\n   component Ram_1wrs is\n     generic(\n       wordCount : integer;\n       wordWidth : integer;\n       readUnderWrite : string;\n       technology : string\n     );\n     port(\n       clk : in std_logic;\n       en : in std_logic;\n       wr : in std_logic;\n       addr : in unsigned;\n       wrData : in std_logic_vector;\n       rdData : out std_logic_vector\n     );\n   end component;\n```\n\n----------------------------------------\n\nTITLE: Bool Concatenation in SpinalHDL (Scala)\nDESCRIPTION: This snippet demonstrates how to concatenate Bool signals into a single Bits type in SpinalHDL using the ## operator.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bool.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval a, b, c = Bool()\n\n// Concatenation of three Bool into a single Bits(3 bits) type\nval myBits = a ## b ## c\n```\n\n----------------------------------------\n\nTITLE: String to Int/Long/BigInt Conversion in Scala\nDESCRIPTION: Demonstrates how to convert strings representing hexadecimal, decimal, octal, and binary values into BigInt using the asHex, asDec, asOct, and asBin methods respectively. This functionality requires the `spinal.core.lib._` import. The snippet showcase example usages.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/binarySystem.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core.lib._\n\n   $: \"32FF190\".asHex\n\n   $: \"12384798999999\".asDec\n\n   $: \"123456777777700\".asOct\n\n   $: \"10100011100111111\".asBin\n```\n\n----------------------------------------\n\nTITLE: Clock Enable Area Example in Scala\nDESCRIPTION: This example shows how to use a `ClockEnableArea` and highlights the signal priorities between asyncReset, clockEnable, syncReset and softReset. The reset functionality may be impacted if clockEnable is disabled.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval clockedArea = new ClockEnableArea(clockEnable) {\n  val reg = RegNext(io.input) init(False)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Rgb Bundle Class in SpinalHDL (Scala)\nDESCRIPTION: This code defines an Rgb bundle class in SpinalHDL, extending the Bundle class and defining r, g, and b fields as UInt signals with specified widths.  The `rWidth`, `gWidth`, and `bWidth` parameters are used to configure the bit widths of the color components.  This is an example of creating a custom hardware data type in SpinalHDL.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/interaction.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Rgb(rWidth: Int, gWidth: Int, bWidth: Int) extends Bundle {\n  val r = UInt(rWidth bits)\n  val g = UInt(gWidth bits)\n  val b = UInt(bWidth bits)\n}\n```\n\n----------------------------------------\n\nTITLE: GpioFiber Implementation - Scala\nDESCRIPTION: This snippet presents the implementation of a GpioFiber, a simple Tilelink peripheral that can read/drive a 32-bit tristate array. It defines an upward-facing node, specifies the supported parameters (address width, data width, transfers), and uses tilelink.SlaveFactory to generate logic for controlling the pins.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/tilelink/tilelink_fabric.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport spinal.lib._\nimport spinal.lib.bus.tilelink\nimport spinal.core.fiber.Fiber\nclass GpioFiber extends Area {\n  // Define a node facing upward (toward masters only)\n  val up = tilelink.fabric.Node.up()\n\n  // Define a elaboration thread to specify the \"up\" parameters and generate the hardware\n  val fiber = Fiber build new Area {\n    // Here we first define what our up node support. m2s mean master to slave requests\n    up.m2s.supported load tilelink.M2sSupport(\n      addressWidth = 12,\n      dataWidth = 32,\n      // Transfers define which kind of memory transactions our up node will support.\n      // Here it only support 4 bytes get/putfull\n      transfers = tilelink.M2sTransfers(\n        get = tilelink.SizeRange(4),\n        putFull = tilelink.SizeRange(4)\n      )\n    )\n    // s2m mean slave to master requests, those are only use for memory coherency purpose\n    // So here we specify we do not need any\n    up.s2m.none()\n\n    // Then we can finally generate some hardware\n    // Starting by defining a 32 bits TriStateArray (Array meaning that each pin has its own writeEnable bit\n    val pins = master(TriStateArray(32 bits)) \n    \n    // tilelink.SlaveFactory is a utility allowing to easily generate the logic required \n    // to control some hardware from a tilelink bus.\n    val factory = new tilelink.SlaveFactory(up.bus, allowBurst = false)\n    \n    // Use the SlaveFactory API to generate some hardware to read / drive the pins\n    val writeEnableReg = factory.drive(pins.writeEnable, 0x0) init (0)\n    val writeReg = factory.drive(pins.write, 0x4) init(0)\n    factory.read(pins.read, 0x8)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using StateDelay - Scala\nDESCRIPTION: This example demonstrates the usage of StateDelay in SpinalHDL, allowing a state to wait for a fixed number of cycles before executing statements in whenCompleted. It shows both the verbose and the compact syntax.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/fsm.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval stateG : State = new StateDelay(cyclesCount=40) {\n  whenCompleted {\n    goto(stateH)\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval stateG : State = new StateDelay(40) { whenCompleted(goto(stateH)) }\n```\n\n----------------------------------------\n\nTITLE: MyComponent with Parameterized Bus Width in SpinalHDL (Scala)\nDESCRIPTION: This snippet defines a `MyComponent` Component in SpinalHDL that accepts an integer `width` parameter. It creates a `MyBus` instance using the provided `width` parameter, demonstrating how to pass parameters to child components or bundles. The `bus` field is then an instance of MyBus using that width.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/parametrization.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ncase class MyComponent(width : Int) extends Component {\n  val bus = MyBus(width)\n}\n```\n\n----------------------------------------\n\nTITLE: Simulating a StreamFifo with Random Data - Scala\nDESCRIPTION: This code compiles and simulates a StreamFifo using SpinalHDL's simulation framework. It sets up clock and reset signals, creates push and pop threads that randomize input data and verify output data against a software queue model. The simulation continues until a success condition is met or a timeout occurs.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/examples/single_clock_fifo.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core._\nimport spinal.core.sim._\n\nimport scala.collection.mutable.Queue\n\n\nobject SimStreamFifoExample {\n  def main(args: Array[String]): Unit = {\n    // Compile the Component for the simulator.\n    val compiled = SimConfig.withWave.allOptimisation.compile(\n      rtl = new StreamFifo(\n        dataType = Bits(32 bits),\n        depth = 32\n      )\n    )\n\n    // Run the simulation.\n    compiled.doSimUntilVoid{dut =>\n      val queueModel = mutable.Queue[Long]()\n\n      dut.clockDomain.forkStimulus(period = 10)\n      SimTimeout(1000000*10)\n\n      // Push data randomly, and fill the queueModel with pushed transactions.\n      val pushThread = fork {\n        dut.io.push.valid #= false\n        while(true) {\n          dut.io.push.valid.randomize()\n          dut.io.push.payload.randomize()\n          dut.clockDomain.waitSampling()\n          if(dut.io.push.valid.toBoolean && dut.io.push.ready.toBoolean) {\n            queueModel.enqueue(dut.io.push.payload.toLong)\n          }\n        }\n      }\n\n      // Pop data randomly, and check that it match with the queueModel.\n      val popThread = fork {\n        dut.io.pop.ready #= true\n        for(i <- 0 until 100000) {\n          dut.io.pop.ready.randomize()\n          dut.clockDomain.waitSampling()\n          if(dut.io.pop.valid.toBoolean && dut.io.pop.ready.toBoolean) {\n            assert(dut.io.pop.payload.toLong == queueModel.dequeue())\n          }\n        }\n        simSuccess()\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ColorSumming Component in SpinalHDL (Scala)\nDESCRIPTION: This snippet defines a `ColorSumming` component in SpinalHDL using Scala. The component takes a vector of `Color` instances as input (`sources`) and outputs the sum of these colors (`result`). The component utilizes a `ReduceTree` to efficiently compute the sum of the input colors.  The `sourcesCount` parameter configures the size of the input vector, and `maxValue` configures the bit width of the color components.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Simple ones/color_summing.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class ColorSumming(\n  sourcesCount: Int,\n  maxValue: Int\n) extends Component {\n  val io = new Bundle {\n    val sources = in(Vec(Color(maxValue), sourcesCount))\n    val result = out(Color(maxValue))\n  }\n\n  import spinal.lib._\n  io.result := io.sources.reduceBalancedTree(_ + _)\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Single Port RAM Component in VHDL\nDESCRIPTION: This VHDL code declares a single port RAM component. It has generics for word count, word width, read-under-write behavior, and technology. The port includes clock, enable, write enable, address, write data, and read data signals. This component allows single read or write access at a time.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Sequential logic/memory.rst#_snippet_6\n\nLANGUAGE: VHDL\nCODE:\n```\n   component Ram_1p is\n     generic(\n       wordCount : integer;\n       wordWidth : integer;\n       readUnderWrite : string;\n       technology : string\n     );\n     port(\n       clk : in std_logic;\n       en : in std_logic;\n       wr : in std_logic;\n       addr : in unsigned;\n       wrData : in std_logic_vector;\n       rdData : out std_logic_vector\n     );\n   end component;\n```\n\n----------------------------------------\n\nTITLE: Uart Transmission Implementation Scala\nDESCRIPTION: This code snippet demonstrates how to implement the transmission logic for a UART in SpinalHDL. It uses the `rxt` pin for transmitting data. The code defines the logic for serializing data and sending it through the UART.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/uart.rst#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nuartCtrl.io.uart.txd := tx.valid\n  when(tx.valid){\n    uartCtrl.io.uart.txd := tx.payload\n  }\n```\n\n----------------------------------------\n\nTITLE: Using CombInit in helper functions\nDESCRIPTION: Demonstrates using CombInit within a helper function to ensure the return value does not inadvertently reference an input signal due to conditional logic.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/assignments.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n// note that condition is an elaboration time constant\ndef invertedIf(b: Bits, condition: Boolean): Bits = if(condition) { ~b } else { CombInit(b) }\n\nval a2 = invertedIf(a1, c)\n\nwhen(sel) {\n   a2 := 0\n}\n```\n\n----------------------------------------\n\nTITLE: Illegal Assignment: Signal X can't be assigned by Y (Scala)\nDESCRIPTION: This code shows an example of a hierarchy violation where signal 'X' in 'ComponentX' is incorrectly assigned by 'Y' in 'ComponentY'. This happens because you can only assign to input signals of subcomponents from the parent component. The second code snippet highlights a case where the direction of signal 'X' is not defined.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/miscelenea/frequent_errors.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass ComponentX extends Component {\n  ...\n  val X = Bool()\n  ...\n}\n\nclass ComponentY extends Component {\n  ...\n  val componentX = new ComponentX\n  val Y = Bool()\n  componentX.X := Y // This assignment is not legal\n  ...\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass ComponentX extends Component {\n  val io = new Bundle {\n    val X = Bool() // Forgot to specify an in/out direction\n  }\n  ...\n}\n\nclass ComponentY extends Component {\n  ...\n  val componentX = new ComponentX\n  val Y = Bool()\n  componentX.io.X := Y // This assignment will be detected as not legal\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Complete SineRom Component in SpinalHDL/Scala\nDESCRIPTION: This snippet shows the complete code for the SineRom component. It includes the component definition, the ROM initialization with sine wave samples, the phase counter for reading the ROM, and the first-order low-pass filter for generating the filtered output.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Simple ones/sinus_rom.rst#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ncase class SineRom(\n  resolutionWidth: Int,\n  sampleCount:     Int\n) extends Component {\n  import spinal.core._\n  val io = new Bundle {\n    val sin       = out(SInt(resolutionWidth bits))\n    val sinFiltered = out(SInt(resolutionWidth bits))\n  }\n\n  val rom = Mem(SInt(resolutionWidth bits), sampleCount)\n\n    // Calculate sin values\n    val sinTable = for (sampleIndex <- 0 until sampleCount) yield {\n      val sinValue = Math.sin(2 * Math.PI * sampleIndex.toDouble / sampleCount) * ((1 << (resolutionWidth - 1)) - 1)\n      sinValue.toInt\n    }\n\n    rom.initBigInt(sinTable.map(value => BigInt(value & ((1 << resolutionWidth) - 1))))\n\n\n  val counter = Counter(sampleCount)\n  counter.increment()\n\n  io.sin := rom.readSync(counter)\n\n  val alpha = 0.95 // Adjust this value to change the filter characteristics\n  val sinFiltered_r = Reg(SInt(resolutionWidth bits)) init (0)\n  sinFiltered_r := (sinFiltered_r * alpha).resized + (io.sin * (1 - alpha)).resized\n  io.sinFiltered := sinFiltered_r\n```\n\n----------------------------------------\n\nTITLE: Register Interface Documentation Generation in SpinalHDL\nDESCRIPTION: This Scala code snippet illustrates how to automatically generate documentation for a register interface using various formats (C header, HTML, JSON, Ralf, SystemRdl). The `busif.accept` method is used with different generator classes like CHeaderGenerator, HtmlGenerator, JsonGenerator, RalfGenerator and SystemRdlGenerator to produce the respective documentation formats based on the register map defined in the `busif` instance. The generated files are named with the \"intrreg\" prefix.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\n      def genDoc() = {\n        busif.accept(CHeaderGenerator(\"intrreg\",\"Intr\"))\n        busif.accept(HtmlGenerator(\"intrreg\", \"Interrupt Example\"))\n        busif.accept(JsonGenerator(\"intrreg\"))\n        busif.accept(RalfGenerator(\"intrreg\"))\n        busif.accept(SystemRdlGenerator(\"intrreg\", \"Intr\"))\n        this\n      }\n\n      this.genDoc()\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Connecting BlackBox in SpinalHDL (Scala)\nDESCRIPTION: This code showcases how to instantiate a BlackBox within a SpinalHDL component and connect its signals to the component's IO. It initializes a Ram_1w_1r blackbox with specific wordWidth and wordCount and connects the wr and rd bundles to the corresponding IO signals.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/blackbox.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// Create the top level and instantiate the Ram\nclass TopLevel extends Component {\n  val io = new Bundle {    \n    val wr = new Bundle {\n      val en   = in Bool()\n      val addr = in UInt (log2Up(16) bits)\n      val data = in Bits (8 bits)\n    }\n    val rd = new Bundle {\n      val en   = in Bool()\n      val addr = in UInt (log2Up(16) bits)\n      val data = out Bits (8 bits)\n    }\n  }\n\n  // Instantiate the blackbox\n  val ram = new Ram_1w_1r(8,16)\n\n  // Connect all the signals\n  io.wr.en   <> ram.io.wr.en\n  io.wr.addr <> ram.io.wr.addr\n  io.wr.data <> ram.io.wr.data\n  io.rd.en   <> ram.io.rd.en\n  io.rd.addr <> ram.io.rd.addr\n  io.rd.data <> ram.io.rd.data\n}\n\nobject Main {\n  def main(args: Array[String]): Unit = {\n    SpinalVhdl(new TopLevel)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing SpinalEnum values\nDESCRIPTION: This code snippet demonstrates how to compare SpinalEnum values using equality (`===`) and inequality operators within a `when` statement and a `switch` statement. This is crucial for conditional logic based on the enumeration state.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/enum.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport UartCtrlTxState._\n\nval stateNext = UartCtrlTxState()\nstateNext := sIdle\n\nwhen(stateNext === sStart) {\n  ...\n}\n\nswitch(stateNext) {\n  is(sIdle) {\n    ...\n  }\n  is(sStart) {\n    ...\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Parallel Processing Pipeline - Scala\nDESCRIPTION: This code defines a `TopLevel` component that processes multiple input lanes in parallel within a single pipeline. It takes a stream of `lanesCount` UInt values as input and produces a stream of `lanesCount` UInt values as output. It uses the `Plus3` module to process each lane in parallel and demonstrates how to connect input and output streams to the pipeline stages using `arbitrateFrom` and `arbitrateTo`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\nclass TopLevel(lanesCount : Int) extends Component {\n  val io = new Bundle {\n    val up = slave Stream(Vec.fill(lanesCount)(UInt(16 bits))) \n    val down = master Stream(Vec.fill(lanesCount)(UInt(16 bits)))\n  }\n\n  // Let's define 3 Nodes for our pipeline\n  val n0, n1, n2 = Node()\n\n  // Let's connect those nodes by using simples registers\n  val s01 = StageLink(n0, n1)\n  val s12 = StageLink(n1, n2)\n\n  // Let's bind io.up to n0\n  n0.arbitrateFrom(io.up)\n  val LANES_INPUT = io.up.payload.map(n0.insert(_))\n\n  // Let's use our \"reusable\" Plus3 area to generate each processing lane\n  val lanes = for(i <- 0 until lanesCount) yield new Plus3(LANES_INPUT(i), n0, n1, n2)\n\n  // Let's bind n2 to io.down\n  n2.arbitrateTo(io.down)\n  for(i <- 0 until lanesCount) io.down.payload(i) := n2(lanes(i).THREE)\n\n  // Let's ask the builder to generate all the required hardware\n  Builder(s01, s12)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining State Machine with SpinalHDL\nDESCRIPTION: This Scala code snippet demonstrates the usage of a state machine abstraction defined on top of SpinalHDL. It shows how SpinalHDL's meta-hardware description capabilities enable the creation of custom tools and abstractions for defining hardware in abstract ways, such as state machines. It defines states, registers, and transitions between states.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Foreword/index.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n// Define a new state machine\n   val fsm = new StateMachine {\n     // Define all states\n     val stateA, stateB, stateC = new State\n\n     // Set the entry point\n     setEntry(stateA)\n\n     // Define a register used into the state machine\n     val counter = Reg(UInt(8 bits)) init (0)\n\n     // Define the state machine behavior for each state\n     stateA.whenIsActive (goto(stateB))\n\n     stateB.onEntry(counter := 0)\n     stateB.onExit(io.result := True)\n     stateB.whenIsActive {\n       counter := counter + 1\n       when(counter === 4) {\n         goto(stateC)\n       }\n     }\n\n     stateC.whenIsActive(goto(stateA))\n   }\n```\n\n----------------------------------------\n\nTITLE: Function Definition (Scala)\nDESCRIPTION: Defines a function `sinTable` that generates a sine wave lookup table. This example showcases the use of `map` to generate a sequence of values, which are then used to initialize a memory block.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/coding_conventions.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef sinTable = (0 until sampleCount).map(sampleIndex => {\n     val sinValue = Math.sin(2 * Math.PI * sampleIndex / sampleCount)\n     S((sinValue * ((1 << resolutionWidth) / 2 - 1)).toInt, resolutionWidth bits)\n   })\n\n   val rom =  Mem(SInt(resolutionWidth bits), initialContent = sinTable)\n```\n\n----------------------------------------\n\nTITLE: Implementing AvalonMMSlaveFactory in Scala\nDESCRIPTION: This code implements the AvalonMMSlaveFactory class, which extends BusSlaveFactoryDelayed and adapts it for the AvalonMM bus. It overrides the build() method to handle different types of BusSlaveFactoryElements based on read/write operations and address matching. It utilizes a Flow to stage the read response.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/bus_slave_factory_impl.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass AvalonMMSlaveFactory(bus : AvalonMM) extends BusSlaveFactoryDelayed {\n  assert(bus.c == AvalonMMSlaveFactory.getAvalonConfig(bus.c.addressWidth,bus.c.dataWidth))\n\n  val readAtCmd = Flow(Bits(bus.c.dataWidth bits))\n  val readAtRsp = readAtCmd.stage()\n\n  bus.readDataValid := readAtRsp.valid\n  bus.readData := readAtRsp.payload\n\n  readAtCmd.valid := bus.read\n  readAtCmd.payload := 0\n\n  override def build(): Unit = {\n    for(element <- elements) element match {\n      case element : BusSlaveFactoryNonStopWrite =>\n        element.that.assignFromBits(bus.writeData(element.bitOffset, element.that.getBitsWidth bits))\n      case _ =>\n    }\n\n    for((address,jobs) <- elementsPerAddress) {\n      when(bus.address === address) {\n        when(bus.write) {\n          for(element <- jobs) element match {\n            case element : BusSlaveFactoryWrite => {\n              element.that.assignFromBits(bus.writeData(element.bitOffset, element.that.getBitsWidth bits))\n            }\n            case element : BusSlaveFactoryOnWrite => element.doThat()\n            case _ =>\n          }\n        }\n        when(bus.read) {\n          for(element <- jobs) element match {\n            case element : BusSlaveFactoryRead => {\n              readAtCmd.payload(element.bitOffset, element.that.getBitsWidth bits) := element.that.asBits\n            }\n            case element : BusSlaveFactoryOnRead => element.doThat()\n            case _ =>\n          }\n        }\n      }\n    }\n  }\n\n  override def busDataWidth: Int = bus.c.dataWidth\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Cross Clock Domain Signals in SpinalHDL\nDESCRIPTION: This code illustrates how to handle signals crossing clock domains in SpinalHDL by adding the 'crossClockDomain' tag to the destination signal. This prevents compile-time errors related to unwanted/unspecified cross-clock-domain signal reads. The example shows two registers, with a tag added to the first register.  It also shows a shorthand using `RegNext`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/miscelenea/core/core_components.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval asynchronousSignal = UInt(8 bits)\n...\nval buffer0 = Reg(UInt(8 bits)).addTag(crossClockDomain)\nval buffer1 = Reg(UInt(8 bits))\nbuffer0 := asynchronousSignal\nbuffer1 := buffer0   // Second register stage to be avoid metastability issues\n```\n\nLANGUAGE: scala\nCODE:\n```\n// Or in less lines:\nval buffer0 = RegNext(asynchronousSignal).addTag(crossClockDomain)\nval buffer1 = RegNext(buffer0)\n```\n\n----------------------------------------\n\nTITLE: Bit Access and Assignment in SpinalHDL (Scala)\nDESCRIPTION: This snippet demonstrates accessing and assigning bits within a UInt signal using static and dynamic indexing, as well as range selection. It covers basic bit access, assignment using :=, and indexing with a UInt signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Int.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n// get the element at the index 4\n   val myBool = myUInt(4)\n   // assign element 1\n   myUInt(1) := True\n\n   // index dynamically\n   val index = UInt(2 bit)\n   val indexed = myUInt(index, 2 bit)\n\n   // range index\n   val myUInt_8bit = myUInt_16bit(7 downto 0)\n   val myUInt_7bit = myUInt_16bit(0 to 6)\n   val myUInt_6bit = myUInt_16bit(0 until 6)\n   // assign to myUInt_16bit(3 downto 0)\n   myUInt_8bit(3 downto 0) := myUInt_4bit\n\n   // equivalent slices, no reversing occurs\n   val a = myUInt_16bit(8 downto 4)\n   val b = myUInt_16bit(4 to 8)\n\n   // read / assign the msb / leftmost bit / x.high bit\n   val isNegative = mySInt_16bit.sign\n   myUInt_16bit.msb := False\n```\n\n----------------------------------------\n\nTITLE: Mux Latch Fix - Scala\nDESCRIPTION: This SpinalHDL code snippet demonstrates how to fix the mux latch issue by adding a default case. If none of the explicit cases match, the 'default' case will be used, ensuring that 'u1' always has a defined output.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/latch_detected.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval u1 = UInt(1 bit)\nu1.mux(\n  0 -> False,\n  default -> True\n)\n```\n\n----------------------------------------\n\nTITLE: MemoryConnection SpinalTag Definition - Scala\nDESCRIPTION: This code defines the MemoryConnection SpinalTag, which allows representing connections between memory masters and slaves. It includes methods for specifying the memory mapping, address transformations, and conversion of slave MemoryTransfers capabilities into master ones. The SpinalTag can be used to create a graph of memory connections, which is bus agnostic.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/tilelink/tilelink_fabric.rst#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ntrait MemoryConnection extends SpinalTag {\n  def up : Nameable with SpinalTagReady // Side toward the masters of the system\n  def down : Nameable with SpinalTagReady // Side toward the slaves of the system\n  def mapping : AddressMapping // Specify the memory mapping of the slave from the master address (before transformers are applied)\n  def transformers : List[AddressTransformer]  // List of alteration done to the address on this connection (ex offset, interleaving, ...)\n  def sToM(downs : MemoryTransfers, args : MappedNode) : MemoryTransfers = downs // Convert the slave MemoryTransfers capabilities into the master ones\n}\n```\n\n----------------------------------------\n\nTITLE: Optional Hardware Generation with 'generate' in SpinalHDL (Scala)\nDESCRIPTION: This snippet demonstrates how to conditionally generate a complete hardware area using the `generate` method.  If `flag` is true, the code within the `Area` block will be generated; otherwise, the `myHardware` will be null. This allows for selective inclusion of larger blocks of hardware in the design based on a parameter.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/parametrization.rst#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ncase class MyComponent(flag : Boolean) extends Component {\n  val myHardware = flag generate new Area {\n    // optional hardware here\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Running a Simulation\nDESCRIPTION: This snippet shows how to configure a SpinalHDL simulation using SimConfig. It sets the clock frequency, enables wave capture, applies optimizations, sets the workspace path, compiles the toplevel component, and then runs the simulation with a timeout.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/bootstraps.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval spinalConfig = SpinalConfig(defaultClockDomainFrequency = FixedFrequency(10 MHz))\n\nSimConfig\n  .withConfig(spinalConfig)\n  .withWave\n  .allOptimisation\n  .workspacePath(\"~/tmp\")\n  .compile(new TopLevel)\n  .doSim { dut =>\n    SimTimeout(1000)\n    // Simulation code here\n}\n```\n\n----------------------------------------\n\nTITLE: APB Interface with IMasterSlave Trait in Scala\nDESCRIPTION: This example implements the APB interface using the `IMasterSlave` trait from `spinal.lib`.  This provides a cleaner way to define master and slave interfaces using the `master()` and `slave()` functions.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/types.rst#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval apbConfig = APBConfig(addressWidth = 8,dataWidth = 32,selWidth = 4,useSlaveError = false)\n   val io = new Bundle {\n     val masterBus = master(apbConfig)\n     val slaveBus  = slave(apbConfig)\n   }\n```\n\n----------------------------------------\n\nTITLE: Defining inout Signal in SpinalHDL\nDESCRIPTION: This code snippet shows how to define an Analog signal as an inout signal in SpinalHDL, making it bidirectional. The asMaster() function configures the DQ signal as an inout. This allows the component to both drive and sample the DQ signal. The SdramLayout case class defines the width of the data signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/analog_inout.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class SdramInterface(g : SdramLayout) extends Bundle with IMasterSlave {\n  val DQ    = Analog(Bits(g.dataWidth bits)) // Bidirectional data bus\n  val DQM   = Bits(g.bytePerWord bits)\n  val ADDR  = Bits(g.chipAddressWidth bits)\n  val BA    = Bits(g.bankWidth bits)\n  val CKE, CSn, CASn, RASn, WEn  = Bool()\n\n  override def asMaster() : Unit = {\n    out(ADDR, BA, CASn, CKE, CSn, DQM, RASn, WEn)\n    inout(DQ) // Set the Analog DQ as an inout signal of the component\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Vec Elements - Scala\nDESCRIPTION: This code illustrates how to compare two Vecs for equality.  It shows how the === operator compares all elements of the Vecs.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Vec.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// Create a vector of 2 signed integers\nval vec2 = Vec.fill(2)(SInt(8 bits))\nval vec1 = Vec.fill(2)(SInt(8 bits))\n\nmyBool := vec2 === vec1  // Compare all elements\n// is equivalent to:\n// myBool := vec2(0) === vec1(0) && vec2(1) === vec1(1)\n```\n\n----------------------------------------\n\nTITLE: SineRom Component Definition in SpinalHDL/Scala\nDESCRIPTION: Defines the SineRom component in SpinalHDL using Scala.  This component has parameters for resolution width and sample count, and outputs for the sine wave and its filtered version. It encapsulates the logic for generating a sine wave from a ROM and filtering it.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Simple ones/sinus_rom.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class SineRom(\n  resolutionWidth: Int,\n  sampleCount:     Int\n) extends Component {\n  import spinal.core._\n  val io = new Bundle {\n    val sin       = out(SInt(resolutionWidth bits))\n    val sinFiltered = out(SInt(resolutionWidth bits))\n  }\n\n  val rom = Mem(SInt(resolutionWidth bits), sampleCount)\n```\n\n----------------------------------------\n\nTITLE: Bits Declaration and Initialization in SpinalHDL (Scala)\nDESCRIPTION: This code snippet demonstrates various ways to declare and initialize Bits variables in SpinalHDL using Scala. It covers inferring bit count, assigning integer values, using base notation (hex, decimal, octal, binary), and initializing with default values or specific bit patterns.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bits.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval myBits1 = Bits(32 bits)   \nval myBits2 = B(25, 8 bits)\nval myBits3 = B\"8'xFF\"   // Base could be x,h (base 16)                         \n                         //               d   (base 10)\n                         //               o   (base 8)\n                         //               b   (base 2)    \nval myBits4 = B\"1001_0011\"  // _ can be used for readability\n\n// Bits with all ones (\"11111111\")\nval myBits5 = B(8 bits, default -> True)\n\n// initialize with \"10111000\" through a few elements\nval myBits6 = B(8 bits, (7 downto 5) -> B\"101\", 4 -> true, 3 -> True, default -> false)\n\n// \"10000000\" (For assignment purposes, you can omit the B)\nval myBits7 = Bits(8 bits)\nmyBits7 := (7 -> true, default -> false)\n```\n\n----------------------------------------\n\nTITLE: Defining APB3 Configuration in Scala\nDESCRIPTION: Defines the Apb3Config that will be used for the controller.  This is defined within a Scala object as a function to be accessible from different locations. The configuration includes address width and data width settings. This configuration is essential for proper APB3 bus communication.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Advanced ones/memory_mapped_uart.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject Apb3UartCtrl {\n  import spinal.core._\n  import spinal.lib._\n\n  def getApb3Config() = Apb3Config(addressWidth = 4, dataWidth = 32)\n\n```\n\n----------------------------------------\n\nTITLE: Clock Domain Crossing with BufferCC in Scala\nDESCRIPTION: This example demonstrates how to use the `BufferCC` function to mitigate metastability issues in clock domain crossing. It instantiates the necessary flip-flops based on the `bufferDepth` parameter.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nclass CrossingExample(clkA : ClockDomain,clkB : ClockDomain) extends Component {\n  val io = new Bundle {\n    val dataIn  = in Bool()\n    val dataOut = out Bool()\n  }\n\n  // sample dataIn with clkA\n  val area_clkA = new ClockingArea(clkA) {\n    val reg = RegNext(io.dataIn) init(False)\n  }\n\n  // BufferCC to avoid metastability issues\n  val area_clkB = new ClockingArea(clkB) {\n    val buf1   = BufferCC(area_clkA.reg, False)\n  }\n\n  io.dataOut := area_clkB.buf1\n}\n```\n\n----------------------------------------\n\nTITLE: Implement JTAG TAP Core in SpinalHDL\nDESCRIPTION: Implements the core logic of a JTAG TAP (Test Access Port), managing the instruction register (IR) and bypass functionality. It includes the TAP state machine, instruction register, and data register selection logic.  The TDO tri-state buffer is also managed here. Note that the implementation includes an extension point defined by a trait (`JtagTapAccess`).\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Advanced ones/jtag.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.lib._\n\nclass JtagTap(val jtag: Jtag, val instructionWidth: Int) extends Area {\n  import JtagState._\n\n  val fsm = new JtagFsm(jtag, instructionWidth)\n\n  val instructionBypass = Bits(instructionWidth bits).assignAll() //All ones\n  val instruction = Reg(Bits(instructionWidth bits)) init(instructionBypass)\n  val instructionCapture = Bits(instructionWidth bits)\n  val instructionShift = Bits(instructionWidth bits)\n\n  instruction := instructionShift\n  fsm.instructionNext := instruction\n\n  when(fsm.state === CAPTURE_IR) {\n    fsm.instructionNext := instructionCapture\n  }\n\n  val bypass = new Area {\n    val dr = Reg(Bool) init(True)\n    when(fsm.state === SHIFT_DR) {\n      dr := jtag.tdi\n    }\n  }\n\n  jtag.tdo.write(bypass.dr)\n  jtag.tdo.high()\n  when(fsm.state === SHIFT_DR) {\n    jtag.tdo.write(bypass.dr)\n    jtag.tdo.low()\n  } otherwise {\n    jtag.tdo.high()\n  }\n\n  val tdoEnable = fsm.state === SHIFT_DR\n}\n```\n\n----------------------------------------\n\nTITLE: Using InOutWrapper in SpinalHDL\nDESCRIPTION: This example demonstrates how to use the InOutWrapper to automatically convert TriState/TriStateArray bundles into native inout(Analog(...)) signals. This simplifies top-level integration by handling tristate signal conversions. The Apb3Gpio component has a TriStateArray signal that InOutWrapper converts.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/analog_inout.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase class Apb3Gpio(gpioWidth : Int) extends Component {\n  val io = new Bundle {\n    val gpio = master(TriStateArray(gpioWidth bits))\n    val apb  = slave(Apb3(Apb3Gpio.getApb3Config()))\n  }\n  ...\n}\n\nSpinalVhdl(InOutWrapper(Apb3Gpio(32)))\n```\n\n----------------------------------------\n\nTITLE: Automatic UInt Resizing in SpinalHDL\nDESCRIPTION: Demonstrates how SpinalHDL automatically resizes weak bit count inferred signals, such as literals created with U(...), to match the width of the target signal on the left-hand side of an assignment.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/assignments.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// U(3) creates an UInt of 2 bits, which doesn't match the left side (8 bits)\nmyUIntOf_8bits := U(3)\n```\n\n----------------------------------------\n\nTITLE: Instantiating Peripherals with SpinalHDL and APB3 Decoder\nDESCRIPTION: This Scala code snippet demonstrates instantiating peripherals and adding an APB3 decoder in SpinalHDL. It showcases SpinalHDL's concise syntax for component instantiation and interconnection using an object-oriented approach.  It instantiates an AXI4 to APB3 bridge, several APB3 peripherals, and an APB3 decoder to map the peripherals to memory regions.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Foreword/index.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// Instantiate an AXI4 to APB3 bridge\n   val apbBridge = Axi4ToApb3Bridge(\n     addressWidth = 20,\n     dataWidth    = 32,\n     idWidth      = 4\n   )\n\n   // Instantiate some APB3 peripherals\n   val gpioACtrl = Apb3Gpio(gpioWidth = 32)\n   val gpioBCtrl = Apb3Gpio(gpioWidth = 32)\n   val timerCtrl = PinsecTimerCtrl()\n   val uartCtrl = Apb3UartCtrl(uartCtrlConfig)\n   val vgaCtrl = Axi4VgaCtrl(vgaCtrlConfig)\n\n   // Instantiate an APB3 decoder\n   // - Driven by the apbBridge\n   // - Map each peripheral in a memory region\n   val apbDecoder = Apb3Decoder(\n     master = apbBridge.io.apb,\n     slaves = List(\n       gpioACtrl.io.apb -> (0x00000, 4 KiB),\n       gpioBCtrl.io.apb -> (0x01000, 4 KiB),\n       uartCtrl.io.apb  -> (0x10000, 4 KiB),\n       timerCtrl.io.apb -> (0x20000, 4 KiB),\n       vgaCtrl.io.apb   -> (0x30000, 4 KiB)\n     )\n   )\n```\n\n----------------------------------------\n\nTITLE: Adding RTL Source Files to SpinalHDL BlackBox (Scala)\nDESCRIPTION: This code shows how to associate RTL source files (Verilog and VHDL) with a SpinalHDL BlackBox using the `addRTLPath()` function. It demonstrates adding specific files, files using environment variables, and merging all sources into a single output file using `mergeRTLSource()`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/blackbox.rst#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nclass MyBlackBox() extends Blackbox {\n\n  val io = new Bundle {\n    val clk   = in  Bool()\n    val start = in Bool()\n    val dIn   = in  Bits(32 bits)\n    val dOut  = out Bits(32 bits)    \n    val ready = out Bool()\n  }\n\n  // Map the clk \n  mapCurrentClockDomain(io.clk)\n\n  // Remove io_ prefix \n  noIoPrefix() \n\n  // Add all rtl dependencies\n  addRTLPath(\"./rtl/RegisterBank.v\")                         // Add a verilog file \n  addRTLPath(s\"./rtl/myDesign.vhd\")                          // Add a vhdl file \n  addRTLPath(s\"${sys.env(\"MY_PROJECT\")}/myTopLevel.vhd\")     // Use an environment variable MY_PROJECT (System.getenv(\"MY_PROJECT\"))\n}\n\n...\n\nclass TopLevel() extends Component {\n  // ...\n  val bb = new MyBlackBox()\n  // ...\n}\n\nval report = SpinalVhdl(new TopLevel)\nreport.mergeRTLSource(\"mergeRTL\") // Merge all rtl sources into mergeRTL.vhd and mergeRTL.v files\n```\n\n----------------------------------------\n\nTITLE: Using Vec Library Helper Functions - Scala\nDESCRIPTION: This code demonstrates the usage of various library helper functions for Vec, including counting elements matching a condition, checking for existence of an element, finding the first element matching a condition, and reducing elements using a balanced tree. You must import spinal.lib._ to use these functions.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Vec.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.lib._\n\n// Create a vector with 4 unsigned integers\nval vec1 = Vec.fill(4)(UInt(8 bits))\n\n// ... the vector is actually assigned somewhere\n\nval c1: UInt = vec1.sCount(_ < 128) // how many values are lower than 128 in vec\nval c2: UInt = vec1.sCount(0) // how many values are equal to zero in vec\n\nval b1: Bool = vec1.sExists(_ > 250) // is there a element bigger than 250\nval b2: Bool = vec1.sContains(0) // is there a zero in vec\n\nval (u1Found, u1): (Bool, UInt) = vec1.sFindFirst(_ < 10) // get the index of the first element lower than 10\nval u2: UInt = vec1.reduceBalancedTree(_ + _) // sum all elements together\n```\n\n----------------------------------------\n\nTITLE: Counter Manipulation with a Function in SpinalHDL (Scala)\nDESCRIPTION: This snippet shows how to use a function to assign a value to a register in SpinalHDL. The `setCounter` function encapsulates the register assignment logic. This is functionally equivalent to directly assigning to the register within the `when` clauses.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/rules.rst#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval inc, clear = Bool()\nval counter = Reg(UInt(8 bits))\n\ndef setCounter(value : UInt): Unit = {\n  counter := value\n}\n\nwhen(inc) {\n  setCounter(counter + 1)  // Set counter with counter + 1\n}\nwhen(clear) {\n  counter := 0\n}\n```\n\n----------------------------------------\n\nTITLE: Simulating StreamFifoCC with Random Clocks in SpinalHDL (Scala)\nDESCRIPTION: This snippet demonstrates a simulation setup for a StreamFifoCC, designed to cross clock domains. It initializes the simulation, defines clock management threads with randomized toggling, and includes data pushing and popping threads to test the FIFO's functionality. It uses a scala.collection.mutable.Queue as a reference model.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/examples/dual_clock_fifo.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core._\nimport spinal.core.sim._\n\nimport scala.collection.mutable.Queue\n\n\nobject SimStreamFifoCCExample {\n  def main(args: Array[String]): Unit = {\n    // Compile the Component for the simulator.\n    val compiled = SimConfig.withWave.allOptimisation.compile(\n      rtl = new StreamFifoCC(\n        dataType = Bits(32 bits),\n        depth = 32,\n        pushClock = ClockDomain.external(\"clkA\"),\n        popClock = ClockDomain.external(\"clkB\",withReset = false)\n      )\n    )\n\n    // Run the simulation.\n    compiled.doSimUntilVoid{dut =>\n      val queueModel = mutable.Queue[Long]()\n\n      // Fork a thread to manage the clock domains signals\n      val clocksThread = fork {\n        // Clear the clock domains' signals, to be sure the simulation captures their first edges.\n        dut.pushClock.fallingEdge()\n        dut.popClock.fallingEdge()\n        dut.pushClock.deassertReset()\n        sleep(0)\n\n        // Do the resets.\n        dut.pushClock.assertReset()\n        sleep(10)\n        dut.pushClock.deassertReset()\n        sleep(1)\n\n        // Forever, randomly toggle one of the clocks.\n        // This will create asynchronous clocks without fixed frequencies.\n        while(true) {\n          if(Random.nextBoolean()) {\n            dut.pushClock.clockToggle()\n          } else {\n            dut.popClock.clockToggle()\n          }\n          sleep(1)\n        }\n      }\n\n      // Push data randomly, and fill the queueModel with pushed transactions.\n      val pushThread = fork {\n        while(true) {\n          dut.io.push.valid.randomize()\n          dut.io.push.payload.randomize()\n          dut.pushClock.waitSampling()\n          if(dut.io.push.valid.toBoolean && dut.io.push.ready.toBoolean) {\n            queueModel.enqueue(dut.io.push.payload.toLong)\n          }\n        }\n      }\n\n      // Pop data randomly, and check that it match with the queueModel.\n      val popThread = fork {\n        for(i <- 0 until 100000) {\n          dut.io.pop.ready.randomize()\n          dut.popClock.waitSampling()\n          if(dut.io.pop.valid.toBoolean && dut.io.pop.ready.toBoolean) {\n            assert(dut.io.pop.payload.toLong == queueModel.dequeue())\n          }\n        }\n        simSuccess()\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Unassigned Register by Assignment - Scala\nDESCRIPTION: This code shows how to fix the unassigned register error by assigning a default value (42) to the register 'a'.  This ensures that the register has a known value at the start, preventing SpinalHDL from throwing the unassigned register error.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/unassigned_register.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass TopLevel extends Component {\n  val result = out(UInt(8 bits))\n  val a = Reg(UInt(8 bits))\n  a := 42\n  result := a\n}\n```\n\n----------------------------------------\n\nTITLE: Install GHDL Dependencies and Build on Linux\nDESCRIPTION: This script installs the necessary dependencies (build-essential, libboost-dev, git, and gnat) using apt-get, clones the GHDL repository, configures the build environment, and installs GHDL from source.  It ensures that GHDL is built with the required bug fixes for SpinalHDL. OpenJDK corresponding to the current Java version needs to be also installed.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/install/GHDL.rst#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nsudo apt-get install build-essential libboost-dev git\nsudo apt-get install gnat # Ada compiler used to buid GHDL\ngit clone https://github.com/ghdl/ghdl.git\ncd ghdl\nmkdir build\ncd build\n../configure\nmake\nsudo make install\n```\n\n----------------------------------------\n\nTITLE: CPU Component Definition in SpinalHDL (Scala)\nDESCRIPTION: This Scala code defines a simple CPU component using SpinalHDL. It includes three pipeline stages (fetch, decode, execute), registers, memory, and logic for handling instructions such as add, jump, LED control, and delay. The component demonstrates the structure and signal connections within a SpinalHDL design.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\nclass Cpu extends Component {\n  val fetch, decode, execute = CtrlLink()\n  val f2d = StageLink(fetch.down, decode.up)\n  val d2e = StageLink(decode.down, execute.up)\n\n  val PC = Payload(UInt(8 bits))\n  val INSTRUCTION = Payload(Bits(16 bits))\n\n  val led = out(Reg(Bits(8 bits))) init(0)\n\n  val fetcher = new fetch.Area {\n    val pcReg = Reg(PC) init (0)\n    up(PC) := pcReg\n    up.valid := True\n    when(up.isFiring) {\n      pcReg := PC + 1\n    }\n\n    val mem = Mem.fill(256)(INSTRUCTION).simPublic\n    INSTRUCTION := mem.readAsync(PC)\n  }\n\n  val decoder = new decode.Area {\n    val opcode = INSTRUCTION(7 downto 0)\n    val IS_ADD   = insert(opcode === 0x1)\n    val IS_JUMP  = insert(opcode === 0x2)\n    val IS_LED   = insert(opcode === 0x3)\n    val IS_DELAY = insert(opcode === 0x4)\n  }\n\n\n  val alu = new execute.Area {\n    val regfile = Reg(UInt(8 bits)) init(0)\n    \n    val flush = False\n    for (stage <- List(fetch, decode)) {\n      stage.throwWhen(flush, usingReady = true)\n    }\n\n    val delayCounter = Reg(UInt(8 bits)) init (0)\n\n    when(isValid) {\n      when(decoder.IS_ADD) {\n        regfile := regfile + U(INSTRUCTION(15 downto 8))\n      }\n      when(decoder.IS_JUMP) {\n        flush := True\n        fetcher.pcReg := U(INSTRUCTION(15 downto 8))\n      }\n      when(decoder.IS_LED) {\n        led := B(regfile)\n      }\n      when(decoder.IS_DELAY) {\n        delayCounter := delayCounter + 1\n        when(delayCounter === U(INSTRUCTION(15 downto 8))) {\n          delayCounter := 0\n        } otherwise {\n          execute.haltIt()\n        }\n      }\n    }\n  }\n\n  Builder(fetch, decode, execute, f2d, d2e)\n}\n```\n\n----------------------------------------\n\nTITLE: Node Stream Driving Scala\nDESCRIPTION: This snippet demonstrates how to drive a Node from a Stream and how to drive a Stream from a Node using the `driveFrom` and `driveTo` methods respectively. It uses a lambda function to connect the data.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval n0, n1, n2 = Node()\n\n    val IN = Payload(UInt(16 bits))\n    val OUT = Payload(UInt(16 bits))\n\n    n1(OUT) := n1(IN) + 0x42\n\n    // Define the input / output stream that will be later connected to the pipeline\n    val up = slave Stream(UInt(16 bits))\n    val down = master Stream(UInt(16 bits)) // Note master Stream(OUT) is good as well\n\n    n0.driveFrom(up)((self, payload) => self(IN) := payload)\n    n2.driveTo(down)((payload, self) => payload := self(OUT))\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Operators - Scala\nDESCRIPTION: This example demonstrates arithmetic operations with UInt signals in SpinalHDL, including addition, addition with carry, and addition with saturation. Simulation assertions (===) compare signal values.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Int.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval a, b, c = UInt(8 bits)\na := U\"xf0\"\nb := U\"x0f\"\n\nc := a + b\nassert(c === U\"8'xff\")\n\nval d = a +^ b\nassert(d === U\"9'x0ff\")\n\n// 0xf0 + 0x20 would overflow, the result therefore saturates\nval e = a +| U\"8'x20\"\nassert(e === U\"8'xff\")\n```\n\n----------------------------------------\n\nTITLE: Simulation of Synchronous Adder in SpinalSim (Scala)\nDESCRIPTION: This code simulates the 'Dut' Component defined above using SpinalSim. It compiles the component with waveform tracing enabled, then executes a simulation loop 100 times. Inside the loop, it generates random inputs for 'a', 'b', and 'c', drives them into the DUT, waits for a clock cycle, and asserts that the DUT's output matches the expected result calculated by a software model. The clock is generated using `forkStimulus`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/examples/synchronous.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n def main(args: Array[String]): Unit = {\n      SimConfig.withWave.compile(new Dut).doSim{ dut =>\n        dut.clockDomain.forkStimulus(period = 10)\n\n        var resultModel = 0\n        for(idx <- 0 until 100) {\n          dut.io.a #= Random.nextInt(256)\n          dut.io.b #= Random.nextInt(256)\n          dut.io.c #= Random.nextInt(256)\n          dut.clockDomain.waitSampling()\n          assert(dut.io.result.toInt == resultModel)\n          resultModel = (dut.io.a.toInt + dut.io.b.toInt - dut.io.c.toInt) & 0xFF\n        }\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Composite for Namespacing (Scala)\nDESCRIPTION: Explains and demonstrates the use of Composite in SpinalHDL for namespacing. The example shows how a Composite uses its construction parameter as a namespace prefix. It emphasizes returning elements within the Composite rather than the Composite itself for correct naming.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nclass MyComponent extends Component {\n  // Basically, a Composite is an Area that use its construction parameter as namespace prefix\n  def isZero(value: UInt) = new Composite(value) {\n    val comparator = value === 0\n  }.comparator  // Note we don't return the Composite,\n                  //  but the element of the composite that we are interested in\n\n  val value = in UInt (8 bits)\n  val result = out Bool()\n  result := isZero(value)\n}\n```\n\n----------------------------------------\n\nTITLE: Define UART Bus with TXD and RXD Signals in SpinalHDL\nDESCRIPTION: This code defines the Uart bus as a Bundle in SpinalHDL. It includes a txd (transmit data) signal for emitting frames and an rxd (receive data) signal for receiving frames. The asMaster() function configures txd as an output and rxd as an input, defining the master-slave relationship.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Com/uart.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Uart() extends Bundle with IMasterSlave {\n     val txd = Bool() // Used to emit frames\n     val rxd = Bool() // Used to receive frames\n\n     override def asMaster(): Unit = {\n       out(txd)\n       in(rxd)\n     }\n   }\n```\n\n----------------------------------------\n\nTITLE: Timer Bus Interface in SpinalHDL Scala\nDESCRIPTION: This function defines the bus interface for the Timer component using the BusSlaveFactory. It maps registers for enabling tick and clear signals, setting the limit value, and reading the current value. Writing to the limit register also clears the timer.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Advanced ones/timer.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class Timer(width : Int) extends Component {\n             ...\n\n  def driveFrom(busCtrl : BusSlaveFactory, baseAddress : BigInt, ticks : Seq[Bool], clears : Seq[Bool]) : Unit = {\n    val ticksEnable  = Reg(Bits(ticks.length bits)) init(0)\n    val clearsEnable = Reg(Bits(clears.length bits)) init(0)\n\n    busCtrl.read(io.value, baseAddress + 8, 0)\n    busCtrl.write(io.limit, baseAddress + 4, 0)\n    busCtrl.onWrite(baseAddress + 4){\n      io.clear := True\n    }\n\n    busCtrl.readWrite(ticksEnable,  baseAddress + 0, 0, 0, ticks.length)\n    busCtrl.readWrite(clearsEnable, baseAddress + 0, 0, 16, clears.length)\n\n    io.tick  := False\n    io.clear := False\n    for((tick, idx) <- ticks.zipWithIndex){\n      io.tick  := io.tick  | (ticksEnable (idx)  & tick)\n    }\n    for((clear, idx) <- clears.zipWithIndex){\n      io.clear := io.clear | (clearsEnable(idx) & clear)\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Manual Analog Bundle Driving in SpinalHDL\nDESCRIPTION: This code demonstrates how to manually drive an Analog bundle with a TriState signal in SpinalHDL. It shows how to connect the read signal, and conditionally assign the write signal based on the writeEnable.  If not driven the analog signal defaults to high-Z.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/analog_inout.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ncase class Example extends Component {\n  val io = new Bundle {\n    val tri = slave(TriState(Bits(16 bits)))\n    val analog = inout(Analog(Bits(16 bits)))\n  }\n  io.tri.read := io.analog\n  when(io.tri.writeEnable) { io.analog := io.tri.write }\n```\n\n----------------------------------------\n\nTITLE: Reserved Address Read Value Implementation in Verilog\nDESCRIPTION: This Verilog code snippet demonstrates the hardware implementation for handling reads from reserved memory addresses.  When the address falls into the default case (reserved), the bus interface read data (`busif_rdata`) is assigned a predefined value (0x0000EF00), and the read error signal (`busif_rderr`) is set to 0, indicating a successful read even though the address is reserved. This implementation is part of the APB bus interface logic.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_20\n\nLANGUAGE: Verilog\nCODE:\n```\n   default: begin\n      busif_rdata  <= 32'h0000EF00 ;\n      busif_rderr  <= 1'b0         ;\n   end\n```\n\n----------------------------------------\n\nTITLE: Reading a word from memory in simulation\nDESCRIPTION: This code shows how to read a word from a memory component using `Mem.getBigInt(address: Long)`. The address is the word address within the memory. It highlights the need to ensure the data is available before attempting to read it.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/signal.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// do a write\ndut.io.enable #= true\ndut.clockDomain.waitSampling()\nprintln(s\"Read back ${dut.mem.getBigInt(0)}\")\nassert(dut.mem\n```\n\n----------------------------------------\n\nTITLE: Specifying Initial Value of Reset - Scala\nDESCRIPTION: This snippet demonstrates how to specify the initial value of the reset signal using `ClockDomain.current.readResetWire initial(False)`. This ensures that the reset signal starts with the correct value during formal verification.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Formal verification/index.rst#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nClockDomain.current.readResetWire initial(False)\n```\n\n----------------------------------------\n\nTITLE: Installing Verilator via MSYS2 Package Manager (Windows)\nDESCRIPTION: This script installs Verilator and essential tools via the MSYS2 package manager on Windows.  It updates the package database, installs the base development tools, git, flex, cmake and then installs Verilator from a specific repository. You must add `C:\\msys64\\usr\\bin;C:\\msys64\\mingw64\\bin` to your Windows PATH.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/install/Verilator.rst#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\npacman -Syuu\n# Close the MSYS2 shell once you're asked to\npacman -Syuu\npacman -S --needed base-devel mingw-w64-x86_64-toolchain \\\n                      git flex\\\n                      mingw-w64-x86_64-cmake\n\n   pacman -U http://repo.msys2.org/mingw/x86_64/mingw-w64-x86_64-verilator-4.032-1-any.pkg.tar.xz\n   \n   # Add C:\\msys64\\usr\\bin;C:\\msys64\\mingw64\\bin to your Windows PATH\n```\n\n----------------------------------------\n\nTITLE: Advanced Register Compositions in SpinalHDL\nDESCRIPTION: This example demonstrates more advanced ways to instantiate and configure registers in SpinalHDL, including initialization values, Scala named parameter argument format, and conditional updates using RegNextWhen. It shows how to combine multiple features and how assignments work with enable signals and the 'last assignment wins' rule.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Sequential logic/registers.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// UInt register of 6 bits (initialized with 42 when the reset occurs)\nval reg1 = Reg(UInt(6 bits)) init(42)\n\n// Register that samples reg1 each cycle (initialized with 0 when the reset occurs)\n// using Scala named parameter argument format\nval reg2 = RegNext(reg1, init=0)\n\n// Register that has multiple features combined\n\n// My register enable signal\nval reg3Enable = Bool()\n// UInt register of 6 bits (inferred from reg1 type)\n//   assignment preconfigured to update from reg1\n//   only updated when reg3Enable is set\n//   initialized with 99 when the reset occurs\nval reg3 = RegNextWhen(reg1, reg3Enable, U(99))\n// when(reg3Enable) {\n//   reg3 := reg1; // this expression is implied in the constructor use case\n// }\n\nwhen(cond2) {      // this is a valid assignment, will take priority when executed\n   reg3 := U(0)    //  (due to last assignment wins rule), assignment does not require\n}                  //  reg3Enable condition, you would use `when(cond2 & reg3Enable)` for that\n\n// UInt register of 8 bits, initialized with 99 when the reset occurs\nval reg4 = Reg(UInt(8 bits), U(99))\n// My register enable signal\nval reg4Enable = Bool()\n// no implied assignments exist, you must use enable explicitly as necessary\nwhen(reg4Enable) {\n   reg4 := newValue\n}\n```\n\n----------------------------------------\n\nTITLE: Sleep Simulation Thread - Scala\nDESCRIPTION: Pauses the execution of the current simulation thread for a specified duration. The `sleep()` function takes an integer representing the number of simulation time units to sleep. This allows controlling the timing of events within the simulation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/threadFull.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n// Sleep 1000 units of time\nsleep(1000)\n```\n\n----------------------------------------\n\nTITLE: Component Definition in SpinalHDL (Scala)\nDESCRIPTION: This snippet shows how to define a component in SpinalHDL, similar to a VHDL entity and architecture. It includes input and output signals, and a construction parameter (similar to a VHDL generic).  The component performs a simple addition operation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_perspective.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class MyComponent(offset: Int) extends Component {\n  val io = new Bundle {\n    val a, b, c = in UInt(8 bits)\n    val result  = out UInt(8 bits)\n  }\n  io.result := a + b + c + offset\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning values to SpinalHDL signals\nDESCRIPTION: This code snippet demonstrates how to assign Scala values (Int, Long, BigInt) to SpinalHDL signals. It shows different ways to assign the same value to a signal using different data types. Required dependencies include SpinalHDL core libraries.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/signal.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndut.io.a #= 42\ndut.io.a #= 42l\ndut.io.a #= BigInt(\"101010\", 2)\ndut.io.a #= BigInt(\"0123456789ABCDEF\", 16)\nprintln(dut.io.b.toInt)\n```\n\n----------------------------------------\n\nTITLE: Latency Analysis - SpinalHDL Scala\nDESCRIPTION: This code provides an example of using the LatencyAnalysis utility to determine the shortest logical path (in clock cycles) between two signals in a SpinalHDL design. In this case, it is used to analyze the latency of the VexRiscv FPU design.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/spinalhdl_datamodel.rst#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(\"cpuDecode to fpuDispatch \" + LatencyAnalysis(vex.decode.arbitration.isValid, logic.decode.input.valid))\n    println(\"fpuDispatch to cpuRsp    \" + LatencyAnalysis(logic.decode.input.valid, plugin.port.rsp.valid))\n```\n\n----------------------------------------\n\nTITLE: Comparison Operators - Scala\nDESCRIPTION: This snippet illustrates the use of comparison operators (>, =/=, ===) in SpinalHDL with UInt signals, within a conditional statement (when/elsewhen/otherwise). Signal assignment is based on comparison results.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Int.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval a = U(5, 8 bits)\nval b = U(10, 8 bits)\nval c = UInt(2 bits)\n\nwhen (a > b) {\n  c := U\"10\"\n} elsewhen (a =/= b) {\n  c := U\"01\"\n} elsewhen (a === U(0)) {\n  c.setAll()\n} otherwise {\n  c.clearAll()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Assigning Combinational Signals in SpinalHDL (Scala)\nDESCRIPTION: This snippet demonstrates the concurrent nature of combinational signal assignments in SpinalHDL. The order in which signals 'a', 'b', and 'c' are assigned doesn't affect the final values due to SpinalHDL's parallel behavioral model. The `:=` operator specifies a new rule for the signal/register on the left-hand side.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/rules.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval a, b, c = UInt(8 bits) // Define 3 combinational signals\nc := a + b  // c will be set to 7\nb := 2      // b will be set to 2\na := b + 3  // a will be set to 5\n```\n\n----------------------------------------\n\nTITLE: Creating Vec with Mixed Data Types - Scala\nDESCRIPTION: This code illustrates how to create a Vec with elements of different data types and how to create a Vec referencing existing signals.  It showcases the flexibility of Vec in handling heterogeneous data types.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Vec.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// Create a vector of 3 different type elements\nval myVecOfMixedUInt = Vec(UInt(3 bits), UInt(5 bits), UInt(8 bits))\n\nval x, y, z = UInt(8 bits)\nval myVecOf_xyz_ref = Vec(x, y, z)\n```\n\n----------------------------------------\n\nTITLE: TriStateArray Bundle Definition in Scala\nDESCRIPTION: This code defines the TriStateArray bundle in SpinalHDL. It includes read, write, and writeEnable signals as Bits with a specified width.  The writeEnable is a Bits type which allows control over each output buffer. It extends Bundle and IMasterSlave traits.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/IO/tristate.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ncase class TriStateArray(width : BitCount) extends Bundle with IMasterSlave {\n  val read,write,writeEnable = Bits(width)\n\n  override def asMaster(): Unit = {\n    out(write,writeEnable)\n    in(read)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Scala for Loop for Hardware Elaboration in SpinalHDL (Scala)\nDESCRIPTION: This code demonstrates using a Scala `for` loop to set all bits of a `Bits` register to `True` when a condition is met. The `for` loop is executed during hardware elaboration, resulting in the unrolled assignment of each bit. The loop iterates from 0 to 7 and sets the corresponding bit to True when `something` is asserted.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/interaction.rst#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval value = Reg(Bits(8 bits))\nwhen(something) {\n  // Set all bits of value by using a Scala for loop (evaluated during hardware elaboration)\n  for(idx <- 0 to 7) {\n    value(idx) := True\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Custom State Encoding - Scala\nDESCRIPTION: This snippet demonstrates how to set a custom encoding for the states of a SpinalHDL state machine using varargs of type (State, BigInt). This allows the user to define specific binary values for each state in the FSM.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/fsm.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval fsm = new StateMachine {\n  val stateA = new State with EntryPoint\n  val stateB = new State\n  ...\n  setEncoding((stateA -> 0x23), (stateB -> 0x22))\n}\n```\n\n----------------------------------------\n\nTITLE: SpinalEnum Usage\nDESCRIPTION: Shows how to use SpinalEnum as a field type, where the resetValue specifies the index of the enum elements. Dependencies include SpinalEnum from SpinalHDL core.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nobject UartCtrlTxState extends SpinalEnum(defaultEncoding = binaryOneHot) {\n   val sIdle, sStart, sData, sParity, sStop = newElement()\n}\n\nval raw = M_REG2.field(UartCtrlTxState(), AccessType.RW, resetValue = 2, doc=\"state\")\n// raw will be init to sData\n```\n\n----------------------------------------\n\nTITLE: Horizontal and Vertical Logic in Scala\nDESCRIPTION: Defines the HVArea class that implements the horizontal and vertical synchronization signal generation using PWM-like counters. It utilizes the Area construct to avoid creating a new Component for verbosity reasons.  This logic increments the horizontal counter each clock cycle, and the vertical counter increments on each horizontal sync signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/vga.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ncase class VgaCtrl(rgbConfig: RgbConfig, timingsWidth: Int = 12) extends Component {\n  import rgbConfig._\n  val io = new Bundle {\n    val softReset = in Bool()\n    val timings = in(VgaTimingsHV(timingsWidth))\n    val pixels = slave Stream Bits(colorWidth bits)\n\n    val error = out Bool()\n    val frameStart = out Bool()\n    val vga = master(Vga(rgbConfig))\n  }\n\n  val hCounter = Counter(0, 2048)\n  val vCounter = Counter(0, 2048)\n\n  val hv = new Area {\n    def sync(counter: Counter, timings: VgaTimingsHV#HV) = new Area {\n      val sync = counter >= timings.syncStart && counter < timings.syncEnd\n      val colorEnable = counter >= timings.colorStart && counter < timings.colorEnd\n    }\n\n    val h = sync(hCounter, io.timings.h)\n    val v = sync(vCounter, io.timings.v)\n  }\n```\n\n----------------------------------------\n\nTITLE: VGA Timings Definition in SpinalHDL (Scala)\nDESCRIPTION: Defines the VGA timing structure using SpinalHDL's Bundle. `VgaTimingsHV` defines horizontal and vertical timings, including color start/end and sync start/end. `VgaTimings` groups horizontal and vertical timings.  The functions `setAs_h640_v480_r60` and `driveFrom` are part of the `VgaTimings` bundle for configuring and interfacing with a bus.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Graphics/vga.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ncase class VgaTimingsHV(timingsWidth: Int) extends Bundle {\n  val colorStart = UInt(timingsWidth bits)\n  val colorEnd = UInt(timingsWidth bits)\n  val syncStart = UInt(timingsWidth bits)\n  val syncEnd = UInt(timingsWidth bits)\n}\n\ncase class VgaTimings(timingsWidth: Int) extends Bundle {\n  val h = VgaTimingsHV(timingsWidth)\n  val v = VgaTimingsHV(timingsWidth)\n\n   def setAs_h640_v480_r60 = ...\n   def driveFrom(busCtrl : BusSlaveFactory,baseAddress : Int) = ...\n}\n```\n\n----------------------------------------\n\nTITLE: UInt Declaration and Assignment in SpinalHDL (Scala)\nDESCRIPTION: This code shows various methods to declare and assign values to a UInt (unsigned integer) type in SpinalHDL using Scala. It covers assigning integer literals, using different base representations, and assigning based on bit ranges.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/types.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval myUInt = UInt(8 bits)\nmyUInt := U(2,8 bits)\nmyUInt := U(2)\nmyUInt := U\"0000_0101\"  // Base per default is binary => 5\nmyUInt := U\"h1A\"        // Base could be x (base 16)\n                           //               h (base 16)\n                           //               d (base 10)\n                           //               o (base 8)\n                           //               b (base 2)\nmyUInt := U\"8'h1A\"\nmyUInt := 2             // You can use scala Int as literal value\n\nval myBool := myUInt === U(7 -> true,(6 downto 0) -> false)\nval myBool := myUInt === U(myUInt.range -> true)\n\n// For assignment purposes, you can omit the B/U/S, which also alow the use of the [default -> ???] feature\nmyUInt := (default -> true)                       // Assign myUInt with \"11111111\"\nmyUInt := (myUInt.range -> true)                  // Assign myUInt with \"11111111\"\nmyUInt := (7 -> true,default -> false)            // Assign myUInt with \"10000000\"\nmyUInt := ((4 downto 1) -> true,default -> false) // Assign myUInt with \"00011110\"\n```\n\n----------------------------------------\n\nTITLE: Simulation Support for Flow in SpinalHDL (Scala)\nDESCRIPTION: This Scala code provides simulation support for the Flow interface in SpinalHDL. It likely includes utilities like `FlowMonitor` and `FlowDriver` for testing Flow-based designs. The code aids in verifying the functionality and performance of SpinalHDL components using the Flow interface.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/flow.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Enabling forking in SBT Scala for SpinalHDL\nDESCRIPTION: This snippet configures the Scala Build Tool (SBT) to enable forking, which is often necessary when running simulations within SpinalHDL.  By setting `fork := true`, the simulation will run in a separate process.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/install/Verilator.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nfork := true\n```\n\n----------------------------------------\n\nTITLE: Manual Interrupt Writing with Apb3\nDESCRIPTION: Shows an example of manually writing interrupt handling logic, including raw, force, mask, and status registers.  Uses Apb3 bus interface.  Illustrates a tedious approach that is improved upon by the interrupt factory.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nclass cpInterruptExample extends Component {\n   val io = new Bundle {\n     val tx_done, rx_done, frame_end = in Bool()\n     val interrupt = out Bool()\n     val apb = slave(Apb3(Apb3Config(16, 32)))\n   }\n   val busif = Apb3BusInterface(io.apb, (0x000, 100 Byte), regPre = \"AP\")\n   val M_CP_INT_RAW   = busif.newReg(doc=\"cp int raw register\")\n   val tx_int_raw      = M_CP_INT_RAW.field(Bool(), W1C, doc=\"tx interrupt enable register\")\n   val rx_int_raw      = M_CP_INT_RAW.field(Bool(), W1C, doc=\"rx interrupt enable register\")\n   val frame_int_raw   = M_CP_INT_RAW.field(Bool(), W1C, doc=\"frame interrupt enable register\")\n\n   val M_CP_INT_FORCE = busif.newReg(doc=\"cp int force register\\n for debug use\")\n   val tx_int_force     = M_CP_INT_FORCE.field(Bool(), RW, doc=\"tx interrupt enable register\")\n   val rx_int_force     = M_CP_INT_FORCE.field(Bool(), RW, doc=\"rx interrupt enable register\")\n   val frame_int_force  = M_CP_INT_FORCE.field(Bool(), RW, doc=\"frame interrupt enable register\")\n\n   val M_CP_INT_MASK    = busif.newReg(doc=\"cp int mask register\")\n   val tx_int_mask      = M_CP_INT_MASK.field(Bool(), RW, doc=\"tx interrupt mask register\")\n   val rx_int_mask      = M_CP_INT_MASK.field(Bool(), RW, doc=\"rx interrupt mask register\")\n   val frame_int_mask   = M_CP_INT_MASK.field(Bool(), RW, doc=\"frame interrupt enable register\")\n\n   val M_CP_INT_STATUS   = busif.newReg(doc=\"cp int state register\")\n   val tx_int_status      = M_CP_INT_STATUS.field(Bool(), RO, doc=\"tx interrupt state register\")\n   val rx_int_status      = M_CP_INT_STATUS.field(Bool(), RO, doc=\"rx interrupt state register\")\n   val frame_int_status   = M_CP_INT_STATUS.field(Bool(), RO, doc=\"frame interrupt state register\")\n\n   rx_int_raw.setWhen(io.rx_done)\n   tx_int_raw.setWhen(io.tx_done)\n   frame_int_raw.setWhen(io.frame_end)\n\n   rx_int_status := (rx_int_raw || rx_int_force) && (!rx_int_mask)\n   tx_int_status := (tx_int_raw || rx_int_force) && (!rx_int_mask)\n   frame_int_status := (frame_int_raw || frame_int_force) && (!frame_int_mask)\n\n   io.interrupt := rx_int_status || tx_int_status || frame_int_status\n\n}\n```\n\n----------------------------------------\n\nTITLE: BusSlaveFactory Utility Implementations - Scala\nDESCRIPTION: This code block showcases the implementation of various utility functions within the BusSlaveFactory trait in Scala. These utilities are built upon the primitive functions and provide higher-level abstractions for common bus slave operations, such as read/write registers, driving signals, and handling data streams.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/bus_slave_factory_impl.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntrait BusSlaveFactory  extends Are {\n     // ...\n     def readAndWrite(that : Data,\n                      address: BigInt,\n                      bitOffset : Int = 0): Unit = {\n       write(that,address,bitOffset)\n       read(that,address,bitOffset)\n     }\n\n     def drive(that : Data,\n               address : BigInt,\n               bitOffset : Int = 0) : Unit = {\n       val reg = Reg(that)\n       write(reg,address,bitOffset)\n       that := reg\n     }\n\n     def driveAndRead(that : Data,\n                      address : BigInt,\n                      bitOffset : Int = 0) : Unit = {\n       val reg = Reg(that)\n       write(reg,address,bitOffset)\n       read(reg,address,bitOffset)\n       that := reg\n     }\n\n     def driveFlow[T <: Data](that : Flow[T],\n                              address: BigInt,\n                              bitOffset : Int = 0) : Unit = {\n       that.valid := False\n       onWrite(address) {\n         that.valid := True\n       }\n       nonStopWrite(that.payload,bitOffset)\n     }\n\n     def createReadWrite[T <: Data](dataType: T,\n                                    address: BigInt,\n                                    bitOffset : Int = 0): T = {\n       val reg = Reg(dataType)\n       write(reg,address,bitOffset)\n       read(reg,address,bitOffset)\n       reg\n     }\n\n     def createAndDriveFlow[T <: Data](dataType : T,\n                                    address: BigInt,\n                                    bitOffset : Int = 0) : Flow[T] = {\n       val flow = Flow(dataType)\n       driveFlow(flow,address,bitOffset)\n       flow\n     }\n\n     def doBitsAccumulationAndClearOnRead(   that : Bits,\n                                             address : BigInt,\n                                             bitOffset : Int = 0): Unit = {\n       assert(that.getWidth <= busDataWidth)\n       val reg = Reg(that)\n       reg := reg | that\n       read(reg,address,bitOffset)\n       onRead(address) {\n         reg := that\n       }\n     }\n\n     def readStreamNonBlocking[T <: Data] (that : Stream[T],\n                                           address: BigInt,\n                                           validBitOffset : Int,\n                                           payloadBitOffset : Int) : Unit = {\n       that.ready := False\n       onRead(address) {\n         that.ready := True\n       }\n       read(that.valid  ,address,validBitOffset)\n       read(that.payload,address,payloadBitOffset)\n     }\n\n     def readMultiWord(that : Data,\n                   address : BigInt) : Unit  = {\n       val wordCount = (widthOf(that) - 1) / busDataWidth + 1\n       val valueBits = that.asBits.resize(wordCount*busDataWidth)\n       val words = (0 until wordCount).map(id => valueBits(id * busDataWidth , busDataWidth bits))\n       for (wordId <- (0 until wordCount)) {\n         read(words(wordId), address + wordId*busDataWidth/8)\n       }\n     }\n\n     def writeMultiWord(that : Data,\n                    address : BigInt) : Unit  = {\n       val wordCount = (widthOf(that) - 1) / busDataWidth + 1\n       for (wordId <- (0 until wordCount)) {\n         write(\n           that = new DataWrapper {\n             override def getBitsWidth: Int =\n               Math.min(busDataWidth, widthOf(that) - wordId * busDataWidth)\n\n             override def assignFromBits(value : Bits): Unit = {\n               that.assignFromBits(\n                 bits     = value.resized,\n                 offset   = wordId * busDataWidth,\n                 bitCount = getBitsWidth bits)\n             }\n           },address = address + wordId * busDataWidth / 8,0\n         )\n       }\n     }\n   }\n```\n\n----------------------------------------\n\nTITLE: Conditional Assignment in SpinalHDL (Scala)\nDESCRIPTION: This code demonstrates conditional assignments using if/elsewhen/otherwise blocks and switch statements in SpinalHDL, which are analogous to VHDL's conditional signal assignments. It showcases how to implement logic based on different conditions, including default cases.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_perspective.rst#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval clear   = Bool()\nval counter = Reg(UInt(8 bits))\n\nwhen(clear) {\n  counter := 0\n}.elsewhen(counter === 76) {\n  counter := 79\n}.otherwise {\n  counter(7) := ! counter(7)\n}\n\nswitch(counter) {\n  is(42) {\n    counter := 65\n  }\n  default {\n    counter := counter + 1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Join Simulation Thread - Scala\nDESCRIPTION: Waits for a previously forked simulation thread to complete its execution. The `join()` function blocks the current thread until the specified thread finishes. This ensures synchronization between concurrent simulation tasks.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/threadFull.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n// Wait until `myNewThread` is execution is done.\nmyNewThread.join()\n```\n\n----------------------------------------\n\nTITLE: Area-based Namespacing in SpinalHDL (Scala)\nDESCRIPTION: Illustrates how Areas can be used to create new namespaces within Components. The example shows a Reg declared inside an Area, which results in the register being named with the Area's name as a prefix. This demonstrates a key technique for organizing and naming signals.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass MyComponent extends Component {\n  val logicA = new Area {    // This define a new namespace named \"logicA\n    val toggle = Reg(Bool()) // This register will be named \"logicA_toggle\"\n    toggle := !toggle\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: QuartusProject for Existing Project Compilation and Programming (Scala)\nDESCRIPTION: This Scala code snippet shows how to use the `QuartusProject` class to compile and program an existing Quartus project. It specifies the paths to the Quartus executable and the workspace directory containing the project files. It then calls the `compile()` and `program()` methods to automate the compilation and programming process. The `program()` function automatically finds the Chain Description File of the project.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/EDA/altera/quartus_flow.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval prj = new QuartusProject(\n   quartusPath = \"F:/intelFPGA_lite/20.1/quartus/bin64/\",\n   workspacePath = \"G:/\"\n)\nprj.compile()\nprj.program()  // automatically find Chain Description File of the project \n```\n\n----------------------------------------\n\nTITLE: Corrected UInt Assignment with Resizing in SpinalHDL (Scala)\nDESCRIPTION: This code shows the corrected UInt assignment in SpinalHDL using the 'resized' method to resolve the width mismatch error. The 'a' signal is resized to match the width of 'b' before the assignment.  This snippet relies on SpinalHDL libraries to function correctly.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/width_mismatch.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val a = UInt(8 bits)\n  val b = UInt(4 bits)\n  b := a.resized\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Clock Crossing with crossClockDomain Tag (Scala)\nDESCRIPTION: This code shows how to use the `crossClockDomain` tag to tell SpinalHDL to ignore a specific clock crossing. This tag should be used when the designer understands the clock crossing implications and has taken necessary precautions.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/clock_crossing_violation.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val clkA = ClockDomain.external(\"clkA\")\n  val clkB = ClockDomain.external(\"clkB\")\n\n  val regA = clkA(Reg(UInt(8 bits)))\n  val regB = clkB(Reg(UInt(8 bits))).addTag(crossClockDomain)\n\n\n  val tmp = regA + regA\n  regB := tmp\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Generics in SpinalHDL BlackBox (Scala)\nDESCRIPTION: This code demonstrates two ways to declare generics within a SpinalHDL BlackBox using `addGeneric` and by defining a `Generic` bundle. It shows how to pass wordCount and wordWidth as generics to the blackbox, allowing configuration of the underlying VHDL/Verilog module.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/blackbox.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass Ram(wordWidth: Int, wordCount: Int) extends BlackBox {\n    addGeneric(\"wordCount\", wordCount)\n    addGeneric(\"wordWidth\", wordWidth)\n\n    // OR \n\n    val generic = new Generic {\n      val wordCount = Ram.this.wordCount\n      val wordWidth = Ram.this.wordWidth\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Formal Verification with BMC - Scala\nDESCRIPTION: This snippet demonstrates how to run formal verification on a SpinalHDL component using the `FormalConfig` class with Boundary Model Checking (BMC).  It imports necessary formal verification utilities and specifies the verification depth. It then instantiates the component to be verified within the `doVerify` context.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Formal verification/index.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport spinal.core.formal._\nFormalConfig.withBMC(15).doVerify(new Component {\n    // Toplevel to verify\n})\n```\n\n----------------------------------------\n\nTITLE: Simulating UART Transmission with SpinalHDL in Scala\nDESCRIPTION: This Scala code snippet simulates UART transmission using SpinalHDL. It forks a process that reads characters from the simulation terminal (System.in) and transmits them serially on a simulated UART pin (uartPin). The simulation uses a baud period to control the timing of bit transmission, simulating the behavior of a UART.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/examples/uart_encoder.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n     // Fork a simulation process which will get chars typed into the simulation terminal and transmit them on the simulation uartPin.\n     fork {\n       uartPin #= true\n       while(true) {\n         // System.in is the java equivalent of the C's stdin.\n         if(System.in.available() != 0) {\n           val buffer = System.in.read()\n           uartPin #= false\n           sleep(baudPeriod)\n\n           for(bitId <- 0 to 7) {\n             uartPin #= ((buffer >> bitId) & 1) != 0\n             sleep(baudPeriod)\n           }\n\n           uartPin #= true\n           sleep(baudPeriod)\n         } else {\n           sleep(baudPeriod * 10) // Sleep a little while to avoid polling System.in too often.\n         }\n       }\n     }\n```\n\n----------------------------------------\n\nTITLE: Configuring and Instantiating RISC-V Core Scala\nDESCRIPTION: This code configures and instantiates the RISC-V CPU within the core clock domain. It sets parameters such as address width, start address, branch prediction method, and various bypass settings. It also adds extensions like multiplication, division, and barrel shifter. Finally, it instantiates the RiscvAxi4 core with the specified configurations and enables debugging features.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval core = coreClockDomain {\n  val coreConfig = CoreConfig(\n    pcWidth = 32,\n    addrWidth = 32,\n    startAddress = 0x00000000,\n    regFileReadyKind = sync,\n    branchPrediction = dynamic,\n    bypassExecute0 = true,\n    bypassExecute1 = true,\n    bypassWriteBack = true,\n    bypassWriteBackBuffer = true,\n    collapseBubble = false,\n    fastFetchCmdPcCalculation = true,\n    dynamicBranchPredictorCacheSizeLog2 = 7\n  )\n\n  // The CPU has a systems of plugin which allow to add new feature into the core.\n  // Those extension are not directly implemented into the core, but are kind of additive logic patch defined in a separated area.\n  coreConfig.add(new MulExtension)\n  coreConfig.add(new DivExtension)\n  coreConfig.add(new BarrelShifterFullExtension)\n\n  val iCacheConfig = InstructionCacheConfig(\n    cacheSize =4096,\n    bytePerLine =32,\n    wayCount = 1,  // Can only be one for the moment\n    wrappedMemAccess = true,\n    addressWidth = 32,\n    cpuDataWidth = 32,\n    memDataWidth = 32\n  )\n\n  // There is the instantiation of the CPU by using all those construction parameters\n  new RiscvAxi4(\n    coreConfig = coreConfig,\n    iCacheConfig = iCacheConfig,\n    dCacheConfig = null,\n    debug = true,\n    interruptCount = 2\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Bundle Instantiation and Usage in Scala\nDESCRIPTION: This example shows how to instantiate and use Bundles (VGA in this case) within a SpinalHDL Component.  It demonstrates assigning entire bundles, accessing bundle members, and using internal bundle functions.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/types.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval vgaIn  = VGA(8)        // Create a RGB instance\n   val vgaOut = VGA(8)\n   vgaOut := vgaIn            // Assign the whole bundle\n   vgaOut.color.green := 0    // Fix the green to zero\n   val vgaInRgbIsBlack = vgaIn.rgb.isBlack   // Get if the vgaIn rgb is black\n```\n\n----------------------------------------\n\nTITLE: Stream Simulation Example in SpinalHDL (Scala)\nDESCRIPTION: Example of a simulation testbench using StreamDriver, StreamMonitor, StreamReadyRandomizer and ScoreboardInOrder to test a StreamFifo. It shows how to drive inputs, monitor outputs, randomize ready signals, and verify the data integrity using a scoreboard.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/stream.rst#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core._\nimport spinal.core.sim._\nimport spinal.lib._\nimport spinal.lib.sim.{StreamMonitor, StreamDriver, StreamReadyRandomizer, ScoreboardInOrder}\n\nobject Example extends App {\n  val dut = SimConfig.withWave.compile(StreamFifo(Bits(8 bits), 2))\n\n  dut.doSim(\"simple test\") { dut =>\n    SimTimeout(10000)\n      \n    val scoreboard = ScoreboardInOrder[Int]()\n      \n    dut.io.flush #= false\n      \n    // drive random data and add pushed data to scoreboard\n    StreamDriver(dut.io.push, dut.clockDomain) { payload =>\n      payload.randomize()\n      true\n    }\n    StreamMonitor(dut.io.push, dut.clockDomain) { payload =>\n      scoreboard.pushRef(payload.toInt)\n    }\n\n    // randmize ready on the output and add popped data to scoreboard\n    StreamReadyRandomizer(dut.io.pop, dut.clockDomain)\n    StreamMonitor(dut.io.pop, dut.clockDomain) { payload =>\n      scoreboard.pushDut(payload.toInt)\n    }\n\n    dut.clockDomain.forkStimulus(10)\n\n    dut.clockDomain.waitActiveEdgeWhere(scoreboard.matches == 100)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Color Bundle with Addition Operator in Scala\nDESCRIPTION: This snippet defines a `Color` case class with `r`, `g`, and `b` fields representing red, green, and blue color components respectively. It also defines an addition operator (+) that allows adding two `Color` instances together, resulting in a new `Color` instance where each color component is the sum of the corresponding components of the input colors.  The `maxValue` parameter constraints the maximum value of the color component.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Simple ones/color_summing.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Color(\n  r: UInt, // red\n  g: UInt, // green\n  b: UInt  // blue\n) extends Bundle {\n  def +(that: Color) = Color(r + that.r, g + that.g, b + that.b)\n}\n\nobject Color {\n  def apply(maxValue: Int): Color = Color(UInt(log2Up(maxValue) bits), UInt(log2Up(maxValue) bits), UInt(log2Up(maxValue) bits))\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Combinatorial Loop Check\nDESCRIPTION: This code snippet demonstrates how to disable combinatorial loop checking on a specific signal using `.noCombLoopCheck`. This can be useful in cases where SpinalHDL falsely identifies a loop. In this case, assignment `a(1) := a(0)` is marked as a false positive.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/combinatorial_loop.rst#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass TopLevel extends Component {\n  val a = UInt(8 bits)\n  a := 0\n  a(1) := a(0) // False positive because of this line\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Reset Controller Logic Scala\nDESCRIPTION: This code implements the reset controller logic within the defined clock domain. It uses a counter to keep the reset signal asserted for a specific number of cycles after power-up or an asynchronous reset. The code also includes buffering and synchronization to ensure a reliable reset signal for other clock domains.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval resetCtrl = new ClockingArea(resetCtrlClockDomain) {\n  val axiResetUnbuffered  = False\n  val coreResetUnbuffered = False\n\n  // Implement an counter to keep the reset axiResetOrder high 64 cycles\n  // Also this counter will automaticly do a reset when the system boot.\n  val axiResetCounter = Reg(UInt(6 bits)) init(0)\n  when(axiResetCounter =/= U(axiResetCounter.range -> true)) {\n    axiResetCounter := axiResetCounter + 1\n    axiResetUnbuffered := True\n  }\n  when(BufferCC(io.asyncReset)) {\n    axiResetCounter := 0\n  }\n\n  // When an axiResetOrder happen, the core reset will as well\n  when(axiResetUnbuffered) {\n    coreResetUnbuffered := True\n  }\n\n  // Create all reset used later in the design\n  val axiReset  = RegNext(axiResetUnbuffered)\n  val coreReset = RegNext(coreResetUnbuffered)\n  val vgaReset  = BufferCC(axiResetUnbuffered)\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Scala Boolean as Construction Parameter in SpinalHDL (Scala)\nDESCRIPTION: This code shows the correct way to use a Scala `Boolean` as a construction parameter for a SpinalHDL Component. Using a Scala Boolean allows influencing the component's structure at elaboration time without violating hierarchy rules. `activeHigh` is a standard Scala Boolean.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/interaction.rst#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n// This is right, you can use all the Scala world to parameterize your hardware.\nclass SubComponent(activeHigh: Boolean) extends Component {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Payload Definition Example - SpinalHDL\nDESCRIPTION: This snippet shows how to define Payload instances in SpinalHDL. Payloads are HardType objects with a name, which are used as keys to retrieve signals in pipeline stages. The example defines two Payload instances and shows how to assign values to them in different nodes connected by a stage link. Note that naming convention for `Payload` instances recommends the use of uppercase.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval PC = Payload(UInt(32 bits))\nval PC_PLUS_4 = Payload(UInt(32 bits))\n\nval n0, n1 = Node()\nval s01 = StageLink(n0, n1)\n\nn0(PC) := 0x42\nn1(PC_PLUS_4) := n1(PC) + 4\n```\n\n----------------------------------------\n\nTITLE: Declaring Signed Fixed-Point Numbers (SFix) in SpinalHDL\nDESCRIPTION: This snippet demonstrates how to declare SFix (signed fixed-point) numbers in SpinalHDL using different constructors. Similar to UFix, it shows the use of peak and resolution or peak and width to define the representation, with an additional bit for the sign. The ExpNumber type simplifies power-of-two representation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Fix.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n// Signed Fixed-Point\nval Q_8_2 = SFix(peak = 8 exp, resolution = -2 exp) // bit width = 8 - (-2) + 1 = 11 bits\nval Q_8_2 = SFix(8 exp, -2 exp)\n\nval Q_8_2 = SFix(peak = 8 exp, width = 11 bits)\nval Q_8_2 = SFix(8 exp, 11 bits)\n```\n\n----------------------------------------\n\nTITLE: Adding AXI4 Slaves to Crossbar in Scala\nDESCRIPTION: This snippet shows how to add AXI4 slaves to the crossbar, specifying their base addresses and sizes.  The `addSlaves` function of the `Axi4CrossbarFactory` is used to configure the address mapping for each slave.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\n//          Slave  -> (base address,  size) ,\n\naxiCrossbar.addSlaves(\n  ram.io.axi       -> (0x00000000L,   4 KiB),\n  sdramCtrl.io.axi -> (0x40000000L,  64 MiB),\n  apbBridge.io.axi -> (0xF0000000L,   1 MiB)\n)\n```\n\n----------------------------------------\n\nTITLE: Sequential Logic in SpinalHDL (Scala)\nDESCRIPTION: This Scala code defines a SpinalHDL component 'TopLevel' with sequential logic. It includes input signals 'cond' and 'value', and output signals 'resultA' and 'resultB'. It also defines two registers: 'regWithReset', initialized to 0, and 'regWithoutReset'. 'regWithReset' is always assigned the input 'value'. 'regWithoutReset' is assigned 0 at declaration and assigned the input 'value' only when 'cond' is true. The outputs are assigned to the respective register values.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/vhdl_generation.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n     val io = new Bundle {\n       val cond   = in Bool()\n       val value  = in UInt (4 bits)\n       val resultA = out UInt(4 bits)\n       val resultB = out UInt(4 bits)\n     }\n\n     val regWithReset = Reg(UInt(4 bits)) init(0)\n     val regWithoutReset = Reg(UInt(4 bits))\n\n     regWithReset := io.value\n     regWithoutReset := 0\n     when(io.cond) {\n       regWithoutReset := io.value\n     }\n\n     io.resultA := regWithReset\n     io.resultB := regWithoutReset\n   }\n```\n\n----------------------------------------\n\nTITLE: Defining Area for Timer Logic in SpinalHDL (Scala)\nDESCRIPTION: This code snippet defines an Area named 'timer' within a SpinalHDL Component. It includes a register 'counter', a signal 'tick' that indicates when the counter reaches zero, and logic to decrement the counter and reset it to 100 when 'tick' is asserted.  This Area encapsulates the timer functionality.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/area.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass UartCtrl extends Component {\n     ...\n     val timer = new Area {\n       val counter = Reg(UInt(8 bits))\n       val tick = counter === 0\n       counter := counter - 1\n       when(tick) {\n         counter := 100\n       }\n     }\n```\n\n----------------------------------------\n\nTITLE: Latency Analysis in SpinalHDL (Scala)\nDESCRIPTION: This snippet demonstrates how to use the `LatencyAnalysis` tool in SpinalHDL to analyze the latency between different signals in the design.  It shows examples for various operations like `cpuWriteback` to `fpuAdd`, `add`, `mul`, `fma`, and `short`. It assumes the existence of signals like `vex.writeBack.input(plugin.FPU_COMMIT)`, `logic.commitLogic(0).add.counter`, `logic.decode.add.rs1.mantissa`, etc., within the SpinalHDL design.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/spinalhdl_datamodel.rst#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(\"cpuWriteback to fpuAdd   \" + LatencyAnalysis(vex.writeBack.input(plugin.FPU_COMMIT), logic.commitLogic(0).add.counter))\n\n    println(\"add                      \" + LatencyAnalysis(logic.decode.add.rs1.mantissa, logic.get.merge.arbitrated.value.mantissa))\n    println(\"mul                      \" + LatencyAnalysis(logic.decode.mul.rs1.mantissa, logic.get.merge.arbitrated.value.mantissa))\n    println(\"fma                      \" + LatencyAnalysis(logic.decode.mul.rs1.mantissa, logic.get.decode.add.rs1.mantissa, logic.get.merge.arbitrated.value.mantissa))\n    println(\"short                    \" + LatencyAnalysis(logic.decode.shortPip.rs1.mantissa, logic.get.merge.arbitrated.value.mantissa))\n```\n\n----------------------------------------\n\nTITLE: Limited Counter Formal Verification - Scala\nDESCRIPTION: This example shows how to perform formal verification of a simple counter with a limited range. It uses `FormalDut` to wrap the DUT, `assumeInitial` to specify initial conditions, and `assert` to check that the counter's value stays within the defined bounds.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Formal verification/index.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport spinal.core._\n\n// Here is our DUT\nclass LimitedCounter extends Component {\n  // The value register will always be between [2:10]\n  val value = Reg(UInt(4 bits)) init(2)\n  when(value < 10) {\n    value := value + 1\n  }\n}\n\nobject LimitedCounterFormal extends App {\n  // import utilities to run the formal verification, but also some utilities to describe formal stuff\n  import spinal.core.formal._\n\n  // Here we run a formal verification which will explore the state space up to 15 cycles to find an assertion failure\n  FormalConfig.withBMC(15).doVerify(new Component {\n    // Instantiate our LimitedCounter DUT as a FormalDut, which ensure that all the outputs of the dut are:\n    // - directly and indirectly driven (no latch / no floating signal)\n    // - allows the current toplevel to read every signal across the hierarchy\n    val dut = FormalDut(new LimitedCounter())\n\n    // Ensure that the state space start with a proper reset\n    assumeInitial(ClockDomain.current.isResetActive)\n\n    // Check a few things\n    assert(dut.value >= 2)\n    assert(dut.value <= 10)\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Register Increment and Clear using 'when' in SpinalHDL (Scala)\nDESCRIPTION: This code demonstrates a register 'counter' that is incremented when 'inc' is true and cleared when 'clear' is true. The `when(clear)` block has priority over `when(inc)` due to the 'last valid assignment wins' rule.  It shows basic register usage in SpinalHDL.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/rules.rst#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval inc, clear = Bool()          // Define two combinational signals/wires\nval counter = Reg(UInt(8 bits))  // Define an 8 bit register\n\nwhen(inc) {\n  counter := counter + 1\n}\nwhen(clear) {\n  counter := 0    // If inc and clear are True, then this  assignment wins\n}                 //  (last value assignment wins rule)\n```\n\n----------------------------------------\n\nTITLE: Bit Extraction and Assignment in SpinalHDL (Scala)\nDESCRIPTION: This code demonstrates various methods for extracting and assigning individual bits or ranges of bits from a Bits signal in SpinalHDL. It covers static and dynamic indexing, range selection, and subdivision into slices.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bits.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n// get the element at the index 4\nval myBool = myBits(4)\n// assign element 1\nmyBits(1) := True\n\n// index dynamically\nval index = UInt(2 bit)\nval indexed = myBits(index, 2 bit)\n\n// range index\nval myBits_8bit = myBits_16bit(7 downto 0)\nval myBits_7bit = myBits_16bit(0 to 6)\nval myBits_6bit = myBits_16bit(0 until 6)\n// assign to myBits_16bit(3 downto 0)\nmyBits_8bit(3 downto 0) := myBits_4bit\n\n// equivalent slices, no reversing occurs\nval a = myBits_16bit(8 downto 4)\nval b = myBits_16bit(4 to 8)\n\n// read / assign the msb / leftmost bit / x.high bit\nval isNegative = myBits_16bit.msb\nmyBits_16bit.msb := False\n```\n\n----------------------------------------\n\nTITLE: Using BlackBoxULogic for std_ulogic in SpinalHDL (Scala)\nDESCRIPTION: This code snippet illustrates how to use `BlackBoxULogic` instead of `BlackBox` in SpinalHDL to generate `std_ulogic` instead of `std_logic` signals in the VHDL output. Note that in Verilog, `BlackBoxUlogic` does not change the generated Verilog code.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/blackbox.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Ram_1w_1r(wordWidth: Int, wordCount: Int) extends BlackBoxULogic {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Handle Derivation in Scala\nDESCRIPTION: This Scala code demonstrates how to create new Handles from existing ones using `produce` and `derivate`.  `x.produce` creates a new Handle based on the result of an expression involving `x.get`. `x.derivate` is similar, but also provides the value of `x.get` as an argument to the lambda function.  The code then loads the original Handle `x` with a value, which triggers the calculation and loading of the derived Handles.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/fiber.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval x,y = Handle[Int]\n    val xPlus2 : Handle[Int] = x.produce(x.get + 2) // x.produce can be used to generate a new Handle when x is loaded\n    val xPlus3 : Handle[Int] = x.derivate(_ + 3)    // x.derivate is as x.produce, but also provide the x.get as argument of the lambda function\n    x.load(3) // x will now contain the value 3\n```\n\n----------------------------------------\n\nTITLE: Bool Edge Detection in SpinalHDL (Scala)\nDESCRIPTION: This snippet demonstrates how to detect rising, falling, and toggle edges of Bool signals in SpinalHDL. It covers using the rise, fall, edges, and toggle methods to detect state changes.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bool.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nwhen(myBool_1.rise(False)) {\n    // do something when a rising edge is detected \n}\n\n\nval edgeBundle = myBool_2.edges(False)\nwhen(edgeBundle.rise) {\n    // do something when a rising edge is detected\n}\nwhen(edgeBundle.fall) {\n    // do something when a falling edge is detected\n}\nwhen(edgeBundle.toggle) {\n    // do something at each edge\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a SpinalEnum with dynamic custom encoding\nDESCRIPTION: This code shows how to define a SpinalEnum with a dynamic custom encoding. It uses a function to calculate the integer value for each enumeration value based on its index. The provided example function is `_ * 2 + 1`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/enum.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n/*\n * Dynamic encoding with the function :  _ * 2 + 1\n *   e.g. : e0 => 0 * 2 + 1 = 1\n *          e1 => 1 * 2 + 1 = 3\n *          e2 => 2 * 2 + 1 = 5\n *          e3 => 3 * 2 + 1 = 7\n */\nval encoding = SpinalEnumEncoding(\"dynamicEncoding\", _ * 2 + 1)\n\nobject MyEnumDynamic extends SpinalEnum(encoding) {\n  val e0, e1, e2, e3 = newElement()\n}\n```\n\n----------------------------------------\n\nTITLE: Importing SpinalHDL Libraries\nDESCRIPTION: This code snippet imports necessary libraries from the SpinalHDL framework. These libraries provide the fundamental building blocks for hardware description, including core components, memory management, and utility functions. This import section is the base to use other snippets. \nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Simple ones/pll_resetctrl.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core._\nimport spinal.lib._\n```\n\n----------------------------------------\n\nTITLE: Implement JtagTapAccess in JtagTap class\nDESCRIPTION: Implements the JtagTapAccess trait within the JtagTap class, providing concrete implementations for accessing TDI, TDO, TDO enable, and the FSM state. This links the abstract interface to the specific JtagTap implementation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Advanced ones/jtag.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass JtagTap(val jtag: Jtag, val instructionWidth: Int) extends Area with JtagTapAccess {\n  import JtagState._\n\n  override def getTdi(): Bool = jtag.tdi\n  override def getTdo(): TriState[Bool] = jtag.tdo\n  override def getTdoEnable(): Bool = fsm.state === SHIFT_DR\n  override def getFsmState(): SpinalEnumCraft[JtagState.type] = fsm.state\n\n```\n\n----------------------------------------\n\nTITLE: Defining Stream Queue with SpinalHDL\nDESCRIPTION: This Scala code snippet defines a `Stream` class with a `queue` method that implements a FIFO.  It demonstrates SpinalHDL's meta-hardware description capabilities, allowing users to define custom operators and functions on hardware interfaces. The `>>` operator connects two streams, and the `queue` method creates a FIFO between them.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Foreword/index.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// Define the concept of handshake bus\n   class Stream[T <: Data](dataType:  T) extends Bundle {\n     val valid   = Bool()\n     val ready   = Bool()\n     val payload = cloneOf(dataType)\n\n     // Define an operator to connect the left operand (this) to the right operand (that)\n     def >>(that: Stream[T]): Unit = {\n       that.valid := this.valid\n       this.ready := that.ready\n       that.payload := this.payload\n     }\n\n     // Return a Stream connected to this via a FIFO of depth elements\n     def queue(depth: Int): Stream[T] = {\n       val fifo = new StreamFifo(dataType, depth)\n       this >> fifo.io.push\n       return fifo.io.pop\n     }\n   }\n```\n\n----------------------------------------\n\nTITLE: Generate VHDL from SpinalHDL - Scala\nDESCRIPTION: This code snippet demonstrates how to generate VHDL code from a SpinalHDL component. It defines a main object with a main method that uses `SpinalVhdl` to create the VHDL output for a specified component.  Replace `TheComponentThatIWantToGenerate` with your actual component class and `constructionArguments` with the necessary arguments for its constructor.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/index.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject MyMainObject {\n  def main(args: Array[String]) {\n    SpinalVhdl(new TheComponentThatIWantToGenerate(constructionArguments))   // Or SpinalVerilog\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: CSTM Register Field Example with RegIf in Scala\nDESCRIPTION: Demonstrates the usage of CSTM (Custom) register fields in RegIf. CSTM allows defining custom register access logic in software without generating corresponding hardware. This is useful for special software-controlled features or documentation purposes. The example shows how to define the register and implement the write logic.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval reg = Reg(Bits(16 bit)) init 0\n   REG.registerAtOnlyReadLogic(0, reg, CSTM(\"BMRW\"), resetValue = 0, \"custom field\")\n\n   when(busif.dowrite) {\n      reg :=  reg & ~busif.writeData(31 downto 16) |  busif.writeData(15 downto 0) & busif.writeData(31 downto 16)\n   }\n```\n\n----------------------------------------\n\nTITLE: VGA Timings Bundle Definition in Scala\nDESCRIPTION: Defines a data structure for VGA timings, including horizontal and vertical sync start/end, and color start/end. This version groups horizontal and vertical timings for clarity.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/vga.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase class VgaTimingsHV(timingsWidth: Int) extends Bundle {\n  case class HV() extends Bundle {\n    val syncStart = UInt(timingsWidth bits)\n    val syncEnd = UInt(timingsWidth bits)\n    val colorStart = UInt(timingsWidth bits)\n    val colorEnd = UInt(timingsWidth bits)\n  }\n\n  val h = HV()\n  val v = HV()\n```\n\n----------------------------------------\n\nTITLE: Installing Verilator from Source via MSYS2 (Windows)\nDESCRIPTION: This script installs Verilator from source using MSYS2 on Windows. It involves updating the package database, installing base development tools, cloning the Verilator repository, and building it from source. Also, it exports some path variables to make sure the compilation can find all the necessary files.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/install/Verilator.rst#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\npacman -Syuu\n# Close the MSYS2 shell once you're asked to\npacman -Syuu\npacman -S --needed base-devel mingw-w64-x86_64-toolchain \\\n                      git flex\\\n                      mingw-w64-x86_64-cmake\n\n   git clone https://github.com/verilator/verilator.git\n   unset VERILATOR_ROOT\n   cd verilator\n   git pull        \n   git checkout v4.218   # Can use newer v4.228 and v5.xxx\n   autoconf      \n   ./configure\n   export CPLUS_INCLUDE_PATH=/usr/include:$CPLUS_INCLUDE_PATH\n   export PATH=/usr/bin/core_perl:$PATH\n   cp /usr/include/FlexLexer.h ./src\n\n   make -j$(nproc)\n   make install\n   echo \"DONE\"\n   # Add C:\\msys64\\usr\\bin;C:\\msys64\\mingw64\\bin to your Windows PATH\n```\n\n----------------------------------------\n\nTITLE: Creating a Slow Clock Area in Scala\nDESCRIPTION: This example shows how to create a `SlowArea` to define a new clock domain area that operates at a slower frequency than the parent clock domain. It can be slowed down by a factor or to a specific frequency.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n\n  // Use the current clock domain : 100MHz\n  val areaStd = new Area {    \n    val counter = out(CounterFreeRun(16).value)\n  }\n\n  // Slow the current clockDomain by 4 : 25 MHz\n  val areaDiv4 = new SlowArea(4) {\n    val counter = out(CounterFreeRun(16).value)\n  }\n\n  // Slow the current clockDomain to 50MHz\n  val area50Mhz = new SlowArea(50 MHz) {\n    val counter = out(CounterFreeRun(16).value)\n  }\n}\n\ndef main(args: Array[String]) {\n  new SpinalConfig(\n    defaultClockDomainFrequency = FixedFrequency(100 MHz)\n  ).generateVhdl(new TopLevel)\n}\n```\n\n----------------------------------------\n\nTITLE: Writing to memory in simulation\nDESCRIPTION: This code demonstrates writing a word to a memory component using `Mem.setBigInt(address: Long, data: BigInt)`. The address is the word address within the memory, and the data is a BigInt value.Dependencies include SpinalHDL core libraries.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/signal.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// set some data in memory\ndut.mem.setBigInt(0, 42)\ndut.io.enable #= true\ndut.clockDomain.waitSampling()\nassert(dut.io\n```\n\n----------------------------------------\n\nTITLE: Defining Area for State Machine Logic in SpinalHDL (Scala)\nDESCRIPTION: This code snippet defines an Area named 'stateMachine' within a SpinalHDL Component. The specific content of the state machine is not shown, but it is presented as another example of how Areas can be used to encapsulate related logic within a Component.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/area.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n     val stateMachine = new Area {\n       ...\n     }\n```\n\n----------------------------------------\n\nTITLE: Passing VCS Flags for Compilation and Elaboration (Scala)\nDESCRIPTION: This Scala code shows how to pass custom flags to VCS during the compilation and elaboration stages using SpinalHDL's VCSFlags. It defines a VCSFlags object with specific flags for the compile and elaborate phases and then uses it when configuring the simulation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/install/VCS.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval flags = VCSFlags(\n    compileFlags = List(\"-kdb\"),\n    elaborateFlags = List(\"-kdb\")\n)\n\nval config = \n  SimConfig\n    .withVCS(flags)\n    .withFSDBWave\n    .workspacePath(\"tb\")\n    .compile(UIntAdder(8))\n```\n\n----------------------------------------\n\nTITLE: Defining UartCtrlRx State Enumeration in Scala\nDESCRIPTION: This snippet defines the UartCtrlRxState enumeration, representing the possible states of the UartCtrlRx state machine. These states are IDLE, START, DATA, PARITY, and STOP. The state machine controls the receiving sequence of the UART.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/uart.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nobject UartCtrlRxState extends SpinalEnum(binarySequential) {\n  val IDLE, START, DATA, PARITY, STOP = newElement()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Combinational and Registered Signals\nDESCRIPTION: Explains the difference between combinational and registered signals in SpinalHDL. Shows how to declare a combinational signal using just the datatype, and a registered signal using Reg(...).\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/assignments.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval a = UInt(4 bits)              // Define a combinational signal\nval b = Reg(UInt(4 bits))         // Define a registered signal\nval c = Reg(UInt(4 bits)) init(0) // Define a registered signal which is\n                                    //  set to 0 when a reset occurs\n```\n\n----------------------------------------\n\nTITLE: Sequential Logic in SpinalHDL (VHDL)\nDESCRIPTION: This VHDL code corresponds to the SpinalHDL 'TopLevel' component, containing sequential logic. The entity 'TopLevel' includes input ports 'io_cond', 'io_value', clock ('clk'), reset, and output ports 'io_resultA' and 'io_resultB'.  The architecture 'arch' defines the registers 'regWithReset' and 'regWithoutReset'. The outputs are assigned to the register values. 'regWithReset' is reset to 0 when the reset is active, otherwise it is assigned the value of the input 'io_value'. 'regWithoutReset' is assigned 'io_value' when 'io_cond' is high.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/vhdl_generation.rst#_snippet_6\n\nLANGUAGE: vhdl\nCODE:\n```\nentity TopLevel is\n     port(\n       io_cond : in std_logic;\n       io_value : in unsigned(3 downto 0);\n       io_resultA : out unsigned(3 downto 0);\n       io_resultB : out unsigned(3 downto 0);\n       clk : in std_logic;\n       reset : in std_logic\n     );\n   end TopLevel;\n\n   architecture arch of TopLevel is\n\n     signal regWithReset : unsigned(3 downto 0);\n     signal regWithoutReset : unsigned(3 downto 0);\n   begin\n     io_resultA <= regWithReset;\n     io_resultB <= regWithoutReset;\n     process(clk,reset)\n     begin\n       if reset = '1' then\n         regWithReset <= pkg_unsigned(\"0000\");\n```\n\n----------------------------------------\n\nTITLE: Bitmask Equality Check in SpinalHDL (Scala)\nDESCRIPTION: This snippet shows how to check for equality between a Bits signal and a bit constant pattern containing holes (don't care bits). The 'M' prefix is used to define the bitmask, and '-' indicates the don't care positions.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/index.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval myBits  = Bits(8 bits)\nval itMatch = myBits === M\"00--10--\" // - for don't care value\n```\n\n----------------------------------------\n\nTITLE: S2mLink Usage Scala\nDESCRIPTION: This snippet shows an example of using S2mLink, which connects two nodes using registers on the `ready` signal to improve backpressure combinatorial timings.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval c01 = S2mLink(n0, n1)\n```\n\n----------------------------------------\n\nTITLE: Generic Signal Assignment with a Function in SpinalHDL (Scala)\nDESCRIPTION: This snippet presents a generic function, `setSomethingWhen`, that can conditionally assign a value to any `UInt` signal, based on a boolean condition. This emphasizes that SpinalHDL treats hardware elements as Scala objects that can be manipulated via references. It's important to pass the target signal as an argument.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/rules.rst#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval inc, clear = Bool()\nval counter = Reg(UInt(8 bits))\n\ndef setSomethingWhen(something : UInt, cond : Bool, value : UInt): Unit = {\n  when(cond) {\n    something := value\n  }\n}\n\nsetSomethingWhen(something = counter, cond = inc,   value = counter + 1)\nsetSomethingWhen(something = counter, cond = clear, value = 0)\n```\n\n----------------------------------------\n\nTITLE: Defining SpinalHDL Ports in Scala\nDESCRIPTION: This code snippet demonstrates how to define input and output ports in SpinalHDL using Scala. It showcases the syntax for specifying the direction (in/out) and the data type (Bool/UInt) of each port. `Bool()` creates single bit ports, while `UInt(8 bits)` defines an 8-bit unsigned integer port.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Introduction/A simple example.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval cond0 = in port Bool()\nval cond1 = in port Bool()\nval flag = out port Bool()\nval state = out port UInt(8 bits)\n```\n\n----------------------------------------\n\nTITLE: Custom Clock Configuration in Scala\nDESCRIPTION: This example demonstrates how to configure a ClockDomain using `ClockDomainConfig`. It sets the clock edge to rising, reset kind to asynchronous, and reset active level to low. It then creates an Area that uses this custom clock domain.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass CustomClockExample extends Component {\n  val io = new Bundle {\n    val clk    = in Bool()\n    val resetn = in Bool()\n    val result = out UInt (4 bits)\n  }\n\n  // Configure the clock domain\n  val myClockDomain = ClockDomain(\n    clock  = io.clk,\n    reset  = io.resetn,\n    config = ClockDomainConfig(\n      clockEdge        = RISING,\n      resetKind        = ASYNC,\n      resetActiveLevel = LOW\n    )\n  )\n\n  // Define an Area which use myClockDomain\n  val myArea = new ClockingArea(myClockDomain) {\n    val myReg = Reg(UInt(4 bits)) init(7)\n\n    myReg := myReg + 1\n\n    io.result := myReg\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: GDB Initialization Commands\nDESCRIPTION: These are the GDB initialization commands used to connect to the target, reset the monitor, halt execution, and load the program. These commands are essential for setting up the debugging environment before running the application.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/software.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\ntarget remote localhost:3333\nmonitor reset halt\nload\n```\n\n----------------------------------------\n\nTITLE: Bits SubdivideIn Usage in SpinalHDL (Scala)\nDESCRIPTION: This code illustrates the usage of the `subdivideIn` method to divide a Bits signal into equal-sized slices in SpinalHDL. It shows how to access these slices and also demonstrates the assignment to a bits signal through subdivides.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bits.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n// Subdivide\nval sel = UInt(2 bits)\nval myBitsWord = myBits_128bits.subdivideIn(32 bits)(sel)\n    // sel = 3 => myBitsWord = myBits_128bits(127 downto 96)\n    // sel = 2 => myBitsWord = myBits_128bits( 95 downto 64)\n    // sel = 1 => myBitsWord = myBits_128bits( 63 downto 32)\n    // sel = 0 => myBitsWord = myBits_128bits( 31 downto  0)\n\n // If you want to access in reverse order you can do:\n val myVector   = myBits_128bits.subdivideIn(32 bits).reverse\n val myRevBitsWord = myVector(sel)\n\n // We can also assign through subdivides\n val output8 = Bits(8 bit)\n val pieces = output8.subdivideIn(2 slices)\n // assign to output8\n pieces(0) := 0xf\n pieces(1) := 0x5\n```\n\n----------------------------------------\n\nTITLE: Importing SpinalHDL Libraries for Testbenches (Scala)\nDESCRIPTION: This code snippet imports the necessary SpinalHDL libraries into the testbench source files.  The `spinal.core._` import provides access to the core SpinalHDL features and data types. The `spinal.core.sim._` import specifically provides access to the simulation-related features of SpinalHDL. These imports are essential for writing simulation testbenches in SpinalHDL.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/install/index.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport spinal.core._\nimport spinal.core.sim._\n```\n\n----------------------------------------\n\nTITLE: Verilog Implementation of OR Reduction\nDESCRIPTION: This Verilog code shows the generated hardware for reducing a 64-element boolean vector using OR operations. It uses a series of intermediate signals (_zz_result, _zz_result_1, _zz_result_2) to break down the long expression.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_20\n\nLANGUAGE: verilog\nCODE:\n```\n    module MyComponent (\n      input               conditions_0,\n      input               conditions_1,\n      input               conditions_2,\n      input               conditions_3,\n      ...\n      input               conditions_58,\n      input               conditions_59,\n      input               conditions_60,\n      input               conditions_61,\n      input               conditions_62,\n      input               conditions_63\n    );\n      wire                _zz_result;\n      wire                _zz_result_1;\n      wire                _zz_result_2;\n      wire                result;\n\n      assign _zz_result = ((((((((((((((((_zz_result_1 || conditions_32) || conditions_33) || conditions_34) || conditions_35) || conditions_36) || conditions_37) || conditions_38) || conditions_39) || conditions_40) || conditions_41) || conditions_42) || conditions_43) || conditions_44) || conditions_45) || conditions_46) || conditions_47);\n      assign _zz_result_1 = ((((((((((((((((_zz_result_2 || conditions_16) || conditions_17) || conditions_18) || conditions_19) || conditions_20) || conditions_21) || conditions_22) || conditions_23) || conditions_24) || conditions_25) || conditions_26) || conditions_27) || conditions_28) || conditions_29) || conditions_30) || conditions_31);\n      assign _zz_result_2 = (((((((((((((((conditions_0 || conditions_1) || conditions_2) || conditions_3) || conditions_4) || conditions_5) || conditions_6) || conditions_7) || conditions_8) || conditions_9) || conditions_10) || conditions_11) || conditions_12) || conditions_13) || conditions_14) || conditions_15);\n      assign result = ((((((((((((((((_zz_result || conditions_48) || conditions_49) || conditions_50) || conditions_51) || conditions_52) || conditions_53) || conditions_54) || conditions_55) || conditions_56) || conditions_57) || conditions_58) || conditions_59) || conditions_60) || conditions_61) || conditions_62) || conditions_63);\n\n    endmodule\n```\n\n----------------------------------------\n\nTITLE: Verilog Attribute Declaration Example\nDESCRIPTION: This Verilog code shows how the `addAttribute` function in SpinalHDL translates to a Verilog attribute declaration. The `keep` attribute is applied to the `pcPlus4` signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/vhdl_generation.rst#_snippet_11\n\nLANGUAGE: Verilog\nCODE:\n```\n   (* keep *) wire [31:0] pcPlus4;\n```\n\n----------------------------------------\n\nTITLE: SpinalHDL Area Definition\nDESCRIPTION: This SpinalHDL code shows how to use the 'Area' feature to define sub-areas of logic within a component.  It highlights how signals defined within an Area are accessible from other parts of the component, improving code organization and readability.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n   val timeout = new Area {\n     val counter = Reg(UInt(8 bits)) init(0)\n     val overflow = False\n     when(counter =/= 100) {\n       counter := counter + 1\n     } otherwise {\n       overflow := True\n     }\n   }\n\n   val core = new Area {\n     when(timeout.overflow) {\n       timeout.counter := 0\n     }\n   }\n```\n\n----------------------------------------\n\nTITLE: Sine Wave Generation from ROM in SpinalHDL/Scala\nDESCRIPTION: Generates a sine wave from a ROM by reading samples based on a phase counter. This involves calculating the sine values, storing them in a ROM, and then reading the ROM to produce the sine wave output.  The phase counter increments to cycle through the ROM samples.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Simple ones/sinus_rom.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n    // Calculate sin values\n    val sinTable = for (sampleIndex <- 0 until sampleCount) yield {\n      val sinValue = Math.sin(2 * Math.PI * sampleIndex.toDouble / sampleCount) * ((1 << (resolutionWidth - 1)) - 1)\n      sinValue.toInt\n    }\n\n    rom.initBigInt(sinTable.map(value => BigInt(value & ((1 << resolutionWidth) - 1))))\n\n\n  val counter = Counter(sampleCount)\n  counter.increment()\n\n  io.sin := rom.readSync(counter)\n```\n\n----------------------------------------\n\nTITLE: Initializing AXI4-to-APB3 Bridge in Scala\nDESCRIPTION: This snippet shows how to instantiate an Axi4SharedToApb3Bridge in SpinalHDL. It configures the address width, data width, and ID width for the bridge, which connects an AXI4 interface to an APB3 interface.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nval apbBridge = Axi4SharedToApb3Bridge(\n  addressWidth = 20,\n  dataWidth    = 32,\n  idWidth      = 4\n)\n```\n\n----------------------------------------\n\nTITLE: Modifying IO with Shift Registers - SpinalHDL Scala\nDESCRIPTION: This code snippet shows how to modify the input and output signals of a SpinalHDL Component by adding a three-stage shift register to each. It uses the rework API to execute code within the component's context and setAsDirectionLess to avoid IO direction conflicts. It then utilizes RegNext and addAttribute(\"DONT_TOUCH\") to create registers that are not optimized away.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/spinalhdl_datamodel.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef ffIo[T <: Component](c : T): T = {\n    def buf1[T <: Data](that : T) = KeepAttribute(RegNext(that)).addAttribute(\"DONT_TOUCH\")\n    def buf[T <: Data](that : T) = buf1(buf1(buf1(that)))\n    c.rework {\n      val ios = c.getAllIo.toList\n      ios.foreach{io =>\n        if(io.getName() == \"clk\") {\n          // Do nothing\n        } else if(io.isInput) {\n          io.setAsDirectionLess().allowDirectionLessIo  // allowDirectionLessIo is to disable the io Bundle linting\n          io := buf(in(cloneOf(io).setName(io.getName() + \"_wrap\")))\n        } else if(io.isOutput) {\n          io.setAsDirectionLess().allowDirectionLessIo\n          out(cloneOf(io).setName(io.getName() + \"_wrap\")) := buf(io)\n        } else ???\n      }\n    }\n    c\n  }\n```\n\n----------------------------------------\n\nTITLE: Interrupt Factory and Level Factory Usage in SpinalHDL\nDESCRIPTION: This Scala code snippet demonstrates the use of interruptFactory and interruptLevelFactory methods within a SpinalHDL component. It connects interrupt pulse and level signals to the bus interface (busif) to create system and GPIO interrupts. The interruptFactory is used for pulse-triggered interrupts and interruptLevelFactory is used for level-triggered interrupts. The `io` bundle contains the input and output signals for interrupt handling.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\n      val busif = BusInterface(io.apb,  (0x000,1 KiB), 0, regPre = \"AP\")\n      io.sys_int  := busif.interruptFactory(\"SYS\",io.int_pulse0, io.int_pulse1, io.int_pulse2, io.int_pulse3)\n      io.gpio_int := busif.interruptLevelFactory(\"GPIO\",io.int_level0, io.int_level1, io.int_level2, io.sys_int)\n```\n\n----------------------------------------\n\nTITLE: Parameterized Data Structures in SpinalHDL\nDESCRIPTION: This example illustrates how to parameterize data structures in SpinalHDL, specifically a Stream and a StreamFifo. The Color data type is parameterized with bit widths of 5, 6, and 5 respectively. The color stream pushes data into the color FIFO.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nval colorStream = Stream(Color(5, 6, 5)))\nval colorFifo   = StreamFifo(Color(5, 6, 5), depth = 128)\ncolorFifo.io.push <> colorStream\n```\n\n----------------------------------------\n\nTITLE: Adding Attribute in SpinalHDL (Scala)\nDESCRIPTION: This Scala code demonstrates how to add an attribute named \"keep\" to the signal `pcPlus4` using the `addAttribute` function in SpinalHDL. This attribute can influence the synthesis process by instructing the synthesizer to keep the signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/vhdl_generation.rst#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\n   val pcPlus4 = pc + 4\n   pcPlus4.addAttribute(\"keep\")\n```\n\n----------------------------------------\n\nTITLE: Disabling Combinatorial Loop Check Fix\nDESCRIPTION: This code snippet demonstrates the fix for disabling combinatorial loop checking. By calling `.noCombLoopCheck` on the signal definition, SpinalHDL will no longer perform loop checking on `a`. This is for cases where a false positive is triggered. The `UInt` is 8 bits wide.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/combinatorial_loop.rst#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass TopLevel extends Component {\n  val a = UInt(8 bits).noCombLoopCheck\n  a := 0\n  a(1) := a(0)\n}\n```\n\n----------------------------------------\n\nTITLE: Executing SBT commands from CLI with continuous execution\nDESCRIPTION: This code snippet shows how to execute SBT commands directly from the terminal, with the continuous execution enabled by the `~` prefix. This ensures that the command will be re-executed automatically whenever source files are changed, providing real-time feedback.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/SBT.rst#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nsbt \"~ runMain mylib.MyTopLevelVerilog\"\n```\n\n----------------------------------------\n\nTITLE: Assertion without Reset - Scala\nDESCRIPTION: This code snippet shows how to create an assertion that is not disabled during reset by using `ClockDomain.current.withoutReset()`.  This is useful for checking conditions that should always hold, even during reset.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Formal verification/index.rst#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nClockDomain.current.withoutReset() {\n  assert(wuff === 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Assignment Overlap Error Message - Text\nDESCRIPTION: This snippet shows the error message generated by SpinalHDL when an assignment overlap is detected.  The message clearly indicates the signal involved and mentions that the assignment completely overwrites a previous one. It also provides the source file location of the offending assignment, which aids in debugging.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/assignment_overlap.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nASSIGNMENT OVERLAP completely the previous one of (toplevel/a :  UInt[8 bits])\n  ***\n  Source file location of the a := 66 assignment via the stack trace\n  ***\n```\n\n----------------------------------------\n\nTITLE: CpuFiber Implementation - Scala\nDESCRIPTION: This snippet illustrates a fictional CPU fiber implementation using SpinalHDL and tilelink.fabric.Node. It defines a downward-facing node, forces specific bus parameters (address width, data width), and defines traffic parameters for the CPU as a master.  It also sets up hardware elements.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/tilelink/tilelink_fabric.rst#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport spinal.lib.bus.tilelink\nimport spinal.core.fiber.Fiber\n\nclass CpuFiber extends Area {\n  // Define a node facing downward (toward slaves only)\n  val down = tilelink.fabric.Node.down()\n\n  val fiber = Fiber build new Area {\n    // Here we force the bus parameters to a specific configurations\n    down.m2s forceParameters tilelink.M2sParameters(\n      addressWidth = 32,\n      dataWidth = 64,\n      // We define the traffic of each master using this node. (one master => one M2sAgent)\n      // In our case, there is only the CpuFiber.\n      masters = List(\n        tilelink.M2sAgent(\n          name = CpuFiber.this, // Reference to the original agent.\n          // A agent can use multiple sets of source ID for different purposes\n          // Here we define the usage of every sets of source ID\n          // In our case, let's say we use ID [0-3] to emit get/putFull requests\n          mapping = List(\n            tilelink.M2sSource(\n              id = SizeMapping(0, 4),\n              emits = M2sTransfers(\n                get = tilelink.SizeRange(1, 64), // Meaning the get access can be any power of 2 size in [1, 64]\n                putFull = tilelink.SizeRange(1, 64)\n              )\n            )\n          )\n        )\n      )\n    )\n\n    // Lets say the CPU doesn't support any slave initiated requests (memory coherency)\n    down.s2m.supported load tilelink.S2mSupport.none()\n\n    // Then we can generate some hardware (nothing useful in this example)\n    down.bus.a.setIdle()\n    down.bus.d.ready := True\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: VGA Controller Interconnections in Scala\nDESCRIPTION: Connects the horizontal and vertical timing generators to the VGA output signals. Also manages the error signal based on the pixel stream validity.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/vga.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ncase class VgaCtrl(rgbConfig: RgbConfig, timingsWidth: Int = 12) extends Component {\n  import rgbConfig._\n  val io = new Bundle {\n    val softReset = in Bool()\n    val timings = in(VgaTimingsHV(timingsWidth))\n    val pixels = slave Stream Bits(colorWidth bits)\n\n    val error = out Bool()\n    val frameStart = out Bool()\n    val vga = master(Vga(rgbConfig))\n  }\n\n  val hCounter = Counter(0, 2048)\n  val vCounter = Counter(0, 2048)\n\n  val hv = new Area {\n    def sync(counter: Counter, timings: VgaTimingsHV#HV) = new Area {\n      val sync = counter >= timings.syncStart && counter < timings.syncEnd\n      val colorEnable = counter >= timings.colorStart && counter < timings.colorEnd\n    }\n\n    val h = sync(hCounter, io.timings.h)\n    val v = sync(vCounter, io.timings.v)\n  }\n\n\n  hCounter.increment() init(0)\n  when(hv.h.sync){vCounter.increment()}\n\n  io.vga.hSync := hv.h.sync\n  io.vga.vSync := hv.v.sync\n  io.vga.colorEn := hv.h.colorEnable && hv.v.colorEnable\n  io.vga.color := io.pixels.payload\n\n  io.error := False\n  when(! io.pixels.valid){io.error := True}\n\n  io.frameStart := False\n  when(vCounter.willOverflowIfInc){io.frameStart := True}\n}\n```\n\n----------------------------------------\n\nTITLE: Parameterized Priority Circuits with Switch and Foreach in Scala\nDESCRIPTION: Demonstrates parameterizing priority circuits using a 'switch' statement in conjunction with a 'foreach' loop. This provides a method to iterate over address elements, assigning buffer values to rdata based on the matching address. It is assumed that `addressElements` and `buffer` are defined elsewhere in the code.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/when_switch.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nswitch(addr) {\n  for (i <- addressElements ) {\n    is(i) {\n      rdata :=  buffer(i)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UartCtrlInitConfig in Scala\nDESCRIPTION: This snippet defines the UartCtrlInitConfig case class, holding the settings for a UartCtrl component that is not runtime configurable. This is used when fixed settings are desired, making it easier to use the UART.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/uart.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ncase class UartCtrlInitConfig(\n  clockDivider : Int,\n  dataLength   : Int,\n  parity       : ParityType.E,\n  stop         : StopBitCount.E\n){\n  def getGenerics() : UartCtrlGenerics = {\n    UartCtrlGenerics(\n      dataWidthMax = 8,\n      clockDividerWidth = log2Up(clockDivider + 1),\n      preSamplingSize = 1,\n      samplingSize = 5,\n      postSamplingSize = 2\n    )\n  }\n  def newUartCtrl() : UartCtrl = {\n    val g = getGenerics()\n    val c = UartCtrl(g)\n    c.io.config.clockDivider := clockDivider\n    c.io.config.frame.dataLength := dataLength\n    c.io.config.frame.parity := parity\n    c.io.config.frame.stop := stop\n    c\n  }\n}\n\n\nobject UartCtrl {\n  def apply(initConfig : UartCtrlInitConfig) : UartCtrl = initConfig.newUartCtrl()\n  def apply(g : UartCtrlGenerics) : UartCtrl = new UartCtrl(g)\n}\n```\n\n----------------------------------------\n\nTITLE: Clock Domain Enumeration in SpinalHDL (Scala)\nDESCRIPTION: This snippet demonstrates how to enumerate clock domains in a SpinalHDL design after the elaboration process. It utilizes the `SpinalVerilog` report to walk through the components and statements to identify and collect all clock domains.  It filters the clock domains to identify external clock domains (those without an associated component).\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/spinalhdl_datamodel.rst#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nobject MyTopLevelVerilog extends App {\n      class MyTopLevel extends Component {\n        val cdA = ClockDomain.external(\"rawrr\")\n        val regA = cdA(RegNext(False))\n\n        val sub = new Component {\n          val cdB = ClockDomain.external(\"miaou\")\n          val regB = cdB(RegNext(False))\n\n          val clkC = CombInit(regB)\n          val cdC = ClockDomain(clkC)\n          val regC = cdC(RegNext(False))\n        }\n      }\n\n      val report = SpinalVerilog(new MyTopLevel)\n\n      val clockDomains = mutable.LinkedHashSet[ClockDomain]()\n      report.toplevel.walkComponents(c =>\n        c.dslBody.walkStatements(s =>\n          s.foreachClockDomain(cd =>\n            clockDomains += cd\n          )\n        )\n      )\n\n      println(\"ClockDomains : \" + clockDomains.mkString(\", \"))\n      val externals = clockDomains.filter(_.clock.component == null)\n      println(\"Externals : \" + externals.mkString(\", \"))\n    }\n```\n\n----------------------------------------\n\nTITLE: Bool Logic Operations in SpinalHDL (Scala)\nDESCRIPTION: This snippet shows how to perform logical operations on Bool signals in SpinalHDL. It covers logical AND, OR, XOR, and NOT operations, as well as setting and clearing Bool values based on conditions.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bool.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval a, b, c = Bool()\nval res = (!a & b) ^ c   // ((NOT a) AND b) XOR c\n\nval d = False\nwhen(cond) {\n  d.set()                // equivalent to d := True\n}\n\nval e = False\ne.setWhen(cond)          // equivalent to when(cond) { d := True }\n\nval f = RegInit(False) fallWhen(ack) setWhen(req)\n/** equivalent to\n * when(f && ack) { f := False }\n * when(req) { f := True }\n * or\n * f := req || (f && !ack)\n */\n\n// mind the order of assignments!  last one wins\nval g = RegInit(False) setWhen(req) fallWhen(ack)\n// equivalent to g := ((!g) && req) || (g && !ack)\n```\n\n----------------------------------------\n\nTITLE: Define JTAG TAP Access Interface in SpinalHDL\nDESCRIPTION: Defines an abstract interface, `JtagTapAccess`, for JTAG instructions to interact with the JTAG TAP core. This interface decouples the TAP core from the instruction implementations, allowing the TAP core to be provided by external IPs. It provides access to TDI, TDO, and the TAP FSM state.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Advanced ones/jtag.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait JtagTapAccess {\n  def getTdi(): Bool\n\n  def getTdo(): TriState[Bool]\n\n  def getTdoEnable(): Bool\n\n  def getFsmState(): SpinalEnumCraft[JtagState.type]\n}\n```\n\n----------------------------------------\n\nTITLE: FiberPlugin with Setup and Build Phases in Scala\nDESCRIPTION: This snippet demonstrates a FiberPlugin with both setup and build phases. The `during setup` block executes during the setup phase, and `awaitBuild()` allows code to be executed in the build phase.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Misc/service_plugin.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass MyPlugin extends FiberPlugin {\n  val logic = during setup new Area {\n    // Here we are executing code in the setup phase\n    awaitBuild()\n    // Here we are executing code in the build phase\n  }\n}\n\nclass MyPlugin2 extends FiberPlugin {\n  val logic = during build new Area {\n    // Here we are executing code in the build phase\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Verilator and Dependencies on Linux\nDESCRIPTION: This script installs Verilator and its dependencies on a Linux system. It clones the Verilator repository, checks out a specific version, configures, builds, and installs it. It includes commands to install prerequisite tools like `git`, `make`, `autoconf`, `g++`, `flex`, and `bison` using `apt-get`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/install/Verilator.rst#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nsudo apt-get install git make autoconf g++ flex bison  # First time prerequisites\ngit clone https://github.com/verilator/verilator.git   # Only first time\nunsetenv VERILATOR_ROOT  # For csh; ignore error if on bash\nunset VERILATOR_ROOT  # For bash\ncd verilator\ngit pull             # Make sure we're up-to-date\ngit checkout v4.218  # Can use newer v4.228 and v5.xxx\nautoconf             # Create ./configure script\n./configure\nmake -j$(nproc)\nsudo make install\necho \"DONE\"\n```\n\n----------------------------------------\n\nTITLE: Unassigned Register Error Message - Text\nDESCRIPTION: This is the error message that SpinalHDL generates when it detects an unassigned register, like in the previous Scala snippet. It indicates the register's name, type, and location in the source code.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/unassigned_register.rst#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nUNASSIGNED REGISTER (toplevel/a :  UInt[8 bits]), defined at\n  ***\n  Source file location of the toplevel/a definition via the stack trace\n  ***\n```\n\n----------------------------------------\n\nTITLE: Verilog Generated with Stream and Composite\nDESCRIPTION: Shows the resulting Verilog code generated from the Stream example with nested calls. The signal names clearly reflect the nested calls (source_fifo_io_pop_m2sPipe_valid, source_fifo_io_pop_rData), demonstrating the effectiveness of Composites in preserving names across complex connections.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_15\n\nLANGUAGE: verilog\nCODE:\n```\nmodule MyComponent (\n  input               source_valid,\n  output              source_ready,\n  input      [7:0]    source_payload,\n  output              sink_valid,\n  input               sink_ready,\n  output     [7:0]    sink_payload,\n  input               clk,\n  input               reset\n);\n  wire                source_fifo_io_pop_ready;\n  wire                source_fifo_io_push_ready;\n  wire                source_fifo_io_pop_valid;\n  wire       [7:0]    source_fifo_io_pop_payload;\n  wire       [4:0]    source_fifo_io_occupancy;\n  wire       [4:0]    source_fifo_io_availability;\n  wire                source_fifo_io_pop_m2sPipe_valid;\n  wire                source_fifo_io_pop_m2sPipe_ready;\n  wire       [7:0]    source_fifo_io_pop_m2sPipe_payload;\n  reg                 source_fifo_io_pop_rValid;\n  reg        [7:0]    source_fifo_io_pop_rData;\n\n  StreamFifo source_fifo (\n    .io_push_valid      (source_valid                 ), //i\n    .io_push_ready      (source_fifo_io_push_ready    ), //o\n    .io_push_payload    (source_payload               ), //i\n    .io_pop_valid       (source_fifo_io_pop_valid     ), //o\n    .io_pop_ready       (source_fifo_io_pop_ready     ), //i\n    .io_pop_payload     (source_fifo_io_pop_payload   ), //o\n    .io_flush           (1'b0                         ), //i\n    .io_occupancy       (source_fifo_io_occupancy     ), //o\n    .io_availability    (source_fifo_io_availability  ), //o\n    .clk                (clk                          ), //i\n    .reset              (reset                        )  //i\n  );\n  assign source_ready = source_fifo_io_push_ready;\n```\n\n----------------------------------------\n\nTITLE: SpinalUsage Interrupt Level Factory\nDESCRIPTION: Illustrates the basic usage of interruptLevelFactory. Dependencies include a BusInterface and boolean signals representing interrupt levels.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nbusif.interruptLevelFactory(\"T\", sys_int0, sys_int1)\n```\n\n----------------------------------------\n\nTITLE: Defining Pinsec IO Bundle Scala\nDESCRIPTION: This code defines the input/output (IO) bundle for the Pinsec SoC. It includes clock and reset signals (asyncReset, axiClk, vgaClk), as well as interfaces for JTAG, SDRAM, GPIOs, UART, and VGA. Each signal is defined with its direction (in or master/slave) and data type.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval io = new Bundle {\n  // Clocks / reset\n  val asyncReset = in Bool()\n  val axiClk     = in Bool()\n  val vgaClk     = in Bool()\n\n  // Main components IO\n  val jtag       = slave(Jtag())\n  val sdram      = master(SdramInterface(IS42x320D.layout))\n\n  // Peripherals IO\n  val gpioA      = master(TriStateArray(32 bits))   // Each pin has an individual output enable control\n  val gpioB      = master(TriStateArray(32 bits))\n  val uart       = master(Uart())\n  val vga        = master(Vga(RgbConfig(5,6,5)))\n}\n```\n\n----------------------------------------\n\nTITLE: Stream Transaction Extender Usage in SpinalHDL (Scala)\nDESCRIPTION: Illustrates the StreamTransactionExtender, which repeats the payload from one input transfer multiple times in the output stream based on a count. A lambda function is used for payload modification during the extension process.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/stream.rst#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nval inputStream = Stream(Bits(8 bits))\nval outputStream = Stream(Bits(8 bits))\nval count = UInt(3 bits)\nval extender = StreamTransactionExtender(inputStream, outputStream, count) {\n  // id, is the 0-based index of total output transfers so far in the current input transaction.\n  // last, is the last transfer indication, same as the last signal for extender.\n  // the returned payload is allowed to be modified only based on id and last signals, other translation should be done outside of this.\n  (id, payload, last) => payload\n}\n```\n\n----------------------------------------\n\nTITLE: PixelSolver Component Implementation (Scala)\nDESCRIPTION: Implements the `PixelSolver` component, which performs the Mandelbrot fractal calculation.  It receives pixel tasks, calculates the number of iterations required for each task, and outputs the results. The implementation is a simple, non-pipelined version.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/fractal.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase class PixelSolver(\n  g : PixelSolverGenerics\n) extends Component {\n  import g._\n\n  val io = new Bundle {\n    val cmd = slave Stream(PixelTask(g))\n    val rsp = master Stream(PixelResult(g))\n  }\n\n  val x = Reg(cloneOf(io.cmd.payload.x))\n  val y = Reg(cloneOf(io.cmd.payload.y))\n  val iterationCounter = Reg(iterationType())\n  val x2 = Reg(cloneOf(io.cmd.payload.x))\n  val y2 = Reg(cloneOf(io.cmd.payload.y))\n\n  val cmdBufferValid = RegInit(False)\n\n  io.cmd.ready := !cmdBufferValid\n  io.rsp.valid := cmdBufferValid\n  io.rsp.payload.iteration := iterationCounter\n\n  when(!cmdBufferValid) {\n    when(io.cmd.valid) {\n      x := io.cmd.payload.x\n      y := io.cmd.payload.y\n      cmdBufferValid := True\n      x2 := io.cmd.payload.x * io.cmd.payload.x\n      y2 := io.cmd.payload.y * io.cmd.payload.y\n      iterationCounter := 0\n    }\n  } otherwise {\n    val xNext = x2 - y2 + x\n    val yNext = 2*x*y + y\n    val xNext2 = xNext*xNext\n    val yNext2 = yNext*yNext\n\n    x := xNext\n    y := yNext\n    x2 := xNext2\n    y2 := yNext2\n\n    iterationCounter := iterationCounter + 1\n\n    when(xNext2 + yNext2 > 4 || iterationCounter === iterationMax) {\n      cmdBufferValid := False\n    }\n  }\n}\n// end case class PixelSolver\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Calculation with Fiber Handles in Scala\nDESCRIPTION: This Scala code demonstrates the basic usage of Fiber Handles for asynchronous calculation. It creates two Handles, 'a' and 'b', then defines a 'calculator' Handle that waits for 'a' and 'b' to be loaded before calculating their sum. A 'printer' Handle then waits for the 'calculator' to complete before printing the result. The 'a' and 'b' Handles are loaded synchronously after the definition of the calculator and printer Handles, showcasing the framework's ability to overcome sequential execution.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/fiber.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core.fiber._\n\n  // Create two empty Handles\n  val a, b = Handle[Int] \n\n  // Create a Handle which will be loaded asynchronously by the given body result\n  val calculator = Handle {  \n      a.get + b.get // .get will block until they are loaded\n  }\n\n  // Same as above\n  val printer = Handle {\n      println(s\"a + b = ${calculator.get}\") // .get is blocking until the calculator body is done\n  }\n\n  // Synchronously load a and b, this will unblock a.get and b.get \n  a.load(3)\n  b.load(4)\n```\n\n----------------------------------------\n\nTITLE: Assigning Output Result in Pipeline - Scala\nDESCRIPTION: This snippet shows how to assign the output result from stage 3 of a pipeline to a variable. It retrieves the value associated with the `onSum.VALUE` from the pipeline's control signals at stage 3.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nresult := pip.ctrl(3)(onSum.VALUE)\n```\n\n----------------------------------------\n\nTITLE: Simple Component Definition and VHDL Generation in SpinalHDL\nDESCRIPTION: This snippet defines a simple SpinalHDL component with input and output signals and generates the corresponding VHDL code. It requires the `spinal.core` library. The code defines a component `MyTopLevel` with input signals `a` and `b`, and output signal `c`. The `MyMain` object generates the VHDL code for this component.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/miscelenea/core/core_components.rst#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\n// spinal.core contain all basics (Bool, UInt, Bundle, Reg, Component, ..)\n   import spinal.core._\n\n   // A simple component definition\n   class MyTopLevel extends Component {\n     // Define some input/output. Bundle like a VHDL record or a verilog struct.\n     val io = new Bundle {\n       val a = in Bool()\n       val b = in Bool()\n       val c = out Bool()\n     }\n\n     // Define some asynchronous logic\n     io.c := io.a & io.b\n   }\n\n   // This is the main of the project. It create a instance of MyTopLevel and\n   // call the SpinalHDL library to flush it into a VHDL file.\n   object MyMain {\n     def main(args: Array[String]) {\n       SpinalVhdl(new MyTopLevel)\n     }\n   }\n```\n\n----------------------------------------\n\nTITLE: Detecting Clock Crossing Violation in SpinalHDL\nDESCRIPTION: This code demonstrates a clock crossing violation where regB depends on regA, which are in different clock domains (clkA and clkB). This will cause SpinalHDL to throw an error during compilation, as shown in the text output following the scala code.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/clock_crossing_violation.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val clkA = ClockDomain.external(\"clkA\")\n  val clkB = ClockDomain.external(\"clkB\")\n\n  val regA = clkA(Reg(UInt(8 bits)))   // PlayDev.scala:834\n  val regB = clkB(Reg(UInt(8 bits)))   // PlayDev.scala:835\n\n  val tmp = regA + regA                // PlayDev.scala:838\n  regB := tmp\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Logic with VHDL Processes\nDESCRIPTION: This VHDL code snippet demonstrates implementing combinatorial logic, a register, and a register with asynchronous reset using processes. It shows how the event-driven nature of VHDL requires sensitivity lists and separate processes for different types of logic. It requires the std_logic and unsigned packages.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Foreword/index.rst#_snippet_0\n\nLANGUAGE: vhdl\nCODE:\n```\nsignal mySignal : std_logic;\n   signal myRegister : unsigned(3 downto 0);\n   signal myRegisterWithReset : unsigned(3 downto 0);\n\n   process(cond)\n   begin\n       mySignal <= '0';\n       if cond = '1' then\n           mySignal <= '1';\n       end if;\n   end process;\n\n   process(clk)\n   begin\n       if rising_edge(clk) then\n           if cond = '1' then\n               myRegister <= myRegister + 1;\n           end if;\n       end if;\n   end process;\n\n   process(clk,reset)\n   begin\n       if reset = '1' then\n           myRegisterWithReset <= 0;\n       elsif rising_edge(clk) then\n           if cond = '1' then\n               myRegisterWithReset <= myRegisterWithReset + 1;\n           end if;\n       end if;\n   end process;\n```\n\n----------------------------------------\n\nTITLE: Incorrect SpinalHDL component definition (NullPointerException)\nDESCRIPTION: This Scala code demonstrates a common error in SpinalHDL: assigning a value to a signal before it is declared. This results in a NullPointerException during execution because the signal `a` is accessed before being initialized with `UInt(8 bits)`. The error happens because SpinalHDL hardware descriptions are executed as Scala programs.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/nullpointerexception.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass TopLevel extends Component {\n  a := 42\n  val a = UInt(8 bits)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RgbConfig and Rgb Bundles in SpinalHDL (Scala)\nDESCRIPTION: This code defines the RgbConfig case class which specifies the width of the red, green, and blue color channels. It also defines the Rgb bundle which uses an RgbConfig instance to create UInt signals for each color channel. The getWidth method calculates the total width of the RGB color.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Graphics/colors.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class RgbConfig(rWidth : Int,gWidth : Int,bWidth : Int) {\n  def getWidth = rWidth + gWidth + bWidth\n}\n\ncase class Rgb(c: RgbConfig) extends Bundle {\n  val r = UInt(c.rWidth bits)\n  val g = UInt(c.gWidth bits)\n  val b = UInt(c.bWidth bits)\n}\n```\n\n----------------------------------------\n\nTITLE: Casting SpinalEnum to Bits\nDESCRIPTION: This code demonstrates how to cast a SpinalEnum value to Bits and back, using `.asBits` and `.assignFromBits`. This is useful for interfacing with other modules that operate on raw bit values. The example shows assigning the Bits representation of `sIdle` to `myBits` and then assigning back to `stateNext`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/enum.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport UartCtrlTxState._\n\nval stateNext = UartCtrlTxState()\nmyBits := sIdle.asBits\n\nstateNext.assignFromBits(myBits)\n```\n\n----------------------------------------\n\nTITLE: Combinational Logic in SpinalHDL (VHDL)\nDESCRIPTION: This VHDL code represents the hardware implementation of the SpinalHDL 'TopLevel' component, which exhibits combinational logic. The entity 'TopLevel' defines input ports 'io_cond' (std_logic), 'io_value' (unsigned 4-bit), and output ports 'io_withoutProcess' and 'io_withProcess' (unsigned 4-bit). The architecture 'arch' describes the component's behavior. The 'io_withoutProcess' is directly assigned 'io_value'. When 'io_cond' is '1', 'io_withProcess' is assigned to 8, 9, or the increment of 'io_value' depending on the value of 'io_value'.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/vhdl_generation.rst#_snippet_4\n\nLANGUAGE: vhdl\nCODE:\n```\nentity TopLevel is\n     port(\n       io_cond : in std_logic;\n       io_value : in unsigned(3 downto 0);\n       io_withoutProcess : out unsigned(3 downto 0);\n       io_withProcess : out unsigned(3 downto 0)\n     );\n   end TopLevel;\n\n   architecture arch of TopLevel is\n   begin\n     io_withoutProcess <= io_value;\n     process(io_cond,io_value)\n     begin\n       io_withProcess <= pkg_unsigned(\"0000\");\n       if io_cond = '1' then\n         case io_value is\n           when pkg_unsigned(\"0000\") =>\n             io_withProcess <= pkg_unsigned(\"1000\");\n           when pkg_unsigned(\"0001\") =>\n             io_withProcess <= pkg_unsigned(\"1001\");\n           when others =>\n             io_withProcess <= (io_value + pkg_unsigned(\"0001\"));\n         end case;\n       end if;\n     end process;\n   end arch;\n```\n\n----------------------------------------\n\nTITLE: Adding Pipelining to AXI4 Connections in Scala\nDESCRIPTION: This snippet demonstrates adding pipelining stages to the AXI4 connections to improve FMax.  The `addPipelining` function inserts pipeline registers between the crossbar and specified AXI4 interfaces.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\n// Pipeline the connection between the crossbar and the apbBridge.io.axi\naxiCrossbar.addPipelining(apbBridge.io.axi,(crossbar,bridge) => {\n  crossbar.sharedCmd.halfPipe() >> bridge.sharedCmd\n  crossbar.writeData.halfPipe() >> bridge.writeData\n  crossbar.writeRsp             << bridge.writeRsp\n  crossbar.readRsp              << bridge.readRsp\n})\n\n// Pipeline the connection between the crossbar and the sdramCtrl.io.axi\naxiCrossbar.addPipelining(sdramCtrl.io.axi,(crossbar,ctrl) => {\n  crossbar.sharedCmd.halfPipe()  >>  ctrl.sharedCmd\n  crossbar.writeData            >/-> ctrl.writeData\n  crossbar.writeRsp              <<  ctrl.writeRsp\n  crossbar.readRsp               <<  ctrl.readRsp\n})\n```\n\n----------------------------------------\n\nTITLE: Forking a Thread for Clock and Reset Generation - Scala\nDESCRIPTION: This example demonstrates how to create a thread to generate a reset signal, trigger a falling edge, and then toggle the clock signal every 5 time units using SpinalHDL. It accesses the default clock domain (dut.clockDomain) implicitly created during component instantiation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/clock.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// Example of thread forking to generate a reset, and then toggling the clock each 5 time units.\n// dut.clockDomain refers to the implicit clock domain created during component instantiation.\nfork {\n  dut.clockDomain.assertReset()\n  dut.clockDomain.fallingEdge()\n  sleep(10)\n  while(true) {\n    dut.clockDomain.clockToggle()\n    sleep(5)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Driving Inputs with anyseq - Scala\nDESCRIPTION: This example shows how to drive inputs of the DUT using the `anyseq` statement in the formal testbench. This allows the formal verification tool to explore various input sequences and check the behavior of the design.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Formal verification/index.rst#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass LimitedCounterInc extends Component {\n  // Only increment the value when the inc input is set\n  val inc = in Bool()\n  val value = Reg(UInt(4 bits)) init(2)\n  when(inc && value < 10) {\n    value := value + 1\n  }\n}\n\nobject LimitedCounterIncFormal extends App {\n  import spinal.core.formal._\n\n  FormalConfig.withBMC(15).doVerify(new Component {\n    val dut = FormalDut(new LimitedCounterInc())\n    assumeInitial(ClockDomain.current.isResetActive)\n    assert(dut.value >= 2)\n    assert(dut.value <= 10)\n\n    // Drive dut.inc with random values\n    anyseq(dut.inc)\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Masked Comparison Example in SpinalHDL (Scala)\nDESCRIPTION: This example demonstrates how to perform a masked comparison between a Bits value and a constant with don't-care bits in SpinalHDL using Scala.  The 'M' prefix indicates a masked literal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/types.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval myBits = Bits(8 bits)\nval itMatch = myBits === M\"00--10--\"\n```\n\n----------------------------------------\n\nTITLE: Area in a Function for Naming (Scala)\nDESCRIPTION: Shows how to define Areas inside functions to provide namespacing for the function's content. It demonstrates creating an Area within a function and using it to name a comparator signal. This showcases a more advanced naming strategy using Areas.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nclass MyComponent extends Component {\n  def isZero(value: UInt) = new Area {\n    val comparator = value === 0\n  }\n\n  val value = in UInt (8 bits)\n  val someLogic = isZero(value)\n\n  val result = out Bool()\n  result := someLogic.comparator\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect UInt Operator Usage in SpinalHDL (Scala)\nDESCRIPTION: This code demonstrates an incorrect usage of a bitwise OR operator between two UInt signals with different widths in SpinalHDL, resulting in a width mismatch error.  'a' is 8 bits and 'b' is 4 bits. This code requires SpinalHDL to compile.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/width_mismatch.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val a = UInt(8 bits)\n  val b = UInt(4 bits)\n  val result = a | b\n}\n```\n\n----------------------------------------\n\nTITLE: Latch Detection Example - Scala\nDESCRIPTION: This SpinalHDL code snippet demonstrates how a latch can be inferred when a signal 'a' is conditionally assigned but does not have a default assignment. The 'a' signal is only assigned a value when the 'cond' input is true, leading to a latch when 'cond' is false.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/latch_detected.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val cond = in(Bool())\n  val a = UInt(8 bits)\n\n  when(cond) {\n    a := 42\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Logic with SpinalHDL\nDESCRIPTION: This Scala code snippet demonstrates implementing the same logic as the VHDL example using SpinalHDL. It showcases SpinalHDL's concise syntax and its ability to describe different types of logic within a single `when` block, without explicit sensitivity lists. It uses SpinalHDL's `Bool`, `Reg`, and `UInt` data types.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Foreword/index.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval mySignal             = Bool()\n   val myRegister           = Reg(UInt(4 bits))\n   val myRegisterWithReset  = Reg(UInt(4 bits)) init(0)\n\n   mySignal := False\n   when(cond) {\n       mySignal            := True\n       myRegister          := myRegister + 1\n       myRegisterWithReset := myRegisterWithReset + 1\n   }\n```\n\n----------------------------------------\n\nTITLE: QuartusFlow for Single RTL File Compilation (Scala)\nDESCRIPTION: This Scala code snippet demonstrates how to use the `QuartusFlow` object to compile a single RTL file using Altera's Quartus tool. It creates a new Quartus project, specifies the target FPGA family and device, sets the desired frequency, and reports the used area and maximum frequency. It removes the specified workspace directory before proceeding.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/EDA/altera/quartus_flow.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval report = QuartusFlow(\n   quartusPath=\"/eda/intelFPGA_lite/17.0/quartus/bin/\",\n   workspacePath=\"/home/spinalvm/tmp\",\n   toplevelPath=\"TopLevel.vhd\",\n   family=\"Cyclone V\",\n   device=\"5CSEMA5F31C6\",\n   frequencyTarget = 1 MHz\n)\nprintln(report)\n```\n\n----------------------------------------\n\nTITLE: VHDL Definition of Synchronous Dual Port RAM Blackbox\nDESCRIPTION: This code shows the VHDL definition of a standard synchronous dual-port RAM blackbox used in SpinalHDL. It includes generic parameters for specifying memory characteristics such as word count, word width, clock crossing, and read-under-write policy, and defines the input/output ports for write and read operations, including clock signals and enable signals.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Sequential logic/memory.rst#_snippet_5\n\nLANGUAGE: ada\nCODE:\n```\n-- Simple synchronous dual port (1 write port, 1 read port)\ncomponent Ram_1w_1rs is\n  generic(\n    wordCount : integer;\n    wordWidth : integer;\n    clockCrossing : boolean;\n    technology : string;\n    readUnderWrite : string;\n    wrAddressWidth : integer;\n    wrDataWidth : integer;\n    wrMaskWidth : integer;\n    wrMaskEnable : boolean;\n    rdAddressWidth : integer;\n    rdDataWidth : integer;\n    rdLatency : integer -- Cycles between the rd_en and the actual value on rd_data ports. It will be set to 1, unless the you added the MemReadBufferPhase to the SpinalConfig and the ram can merge a register on the read data path.\n  );\n  port(\n    wr_clk : in std_logic;\n    wr_en : in std_logic;\n    wr_mask : in std_logic_vector;\n    wr_addr : in unsigned;\n    wr_data : in std_logic_vector;\n    rd_clk : in std_logic;\n    rd_en : in std_logic;\n    rd_addr : in unsigned;\n    rd_dataEn : in std_logic; -- Only used if rdLatency > 1, drive the enable of rd_data flip flops\n  );\nend component;\n```\n\n----------------------------------------\n\nTITLE: Unassigned Signal Example in SpinalHDL (Scala)\nDESCRIPTION: This Scala code snippet demonstrates a scenario in SpinalHDL where the \"No Driver On\" error occurs. The signal 'a' is declared but never assigned a value, leading to the error when 'result' depends on it. The snippet uses the SpinalHDL Component and UInt classes.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/no_driver_on.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val result = out(UInt(8 bits))\n  val a = UInt(8 bits)\n  result := a\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Simulation Timeout\nDESCRIPTION: This snippet shows how to set a simulation timeout using SimTimeout. The simulation will fail if it runs for longer than the specified duration. This is useful for preventing infinite loops in the testbench.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/bootstraps.rst#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval period = 10\ndut.clockDomain.forkStimulus(period)\nSimTimeout(1000 * period)\n```\n\n----------------------------------------\n\nTITLE: Automatic Naming Limitations in SpinalHDL (Scala)\nDESCRIPTION: Explains the automatic naming feature and its limitations, emphasizing that only vals within a Component are automatically named. It shows an example where a local variable within a function does not get a name because it's not stored in a Component val. This highlights the importance of storing Data instances within Component vals for automatic naming.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass MyComponent extends Component {\n  val a,b = in UInt(8 bits) // Will be properly named\n  val toto = out UInt(8 bits)   // same\n\n  def doStuff(): Unit = {\n    val tmp = UInt(8 bits) // This will not be named, as it isn't stored anywhere in a\n                           // component val (but there is a solution explained later)\n    tmp := 0x20\n    toto := tmp\n  }\n  doStuff()\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Value Incrementing with past - Scala\nDESCRIPTION: This example uses the `past` primitive to check that the counter's value is incrementing in each cycle.  `pastValid` is used to ensure that the `past` value is valid (i.e., not during the first cycle).\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Formal verification/index.rst#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nFormalConfig.withBMC(15).doVerify(new Component {\n  val dut = FormalDut(new LimitedCounter())\n  assumeInitial(ClockDomain.current.isResetActive)\n\n  // Check that the value is incrementing.\n  // hasPast is used to ensure that the past(dut.value) had at least one sampling out of reset\n  when(pastValid() && past(dut.value) =/= 10) {\n    assert(dut.value === past(dut.value) + 1)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Executing Code at the Beginning - SpinalHDL Scala\nDESCRIPTION: This code demonstrates how to execute a block of code in the context of the beginning of the current SpinalHDL Component's DSL body, effectively bypassing any conditional scopes (when, switch). It uses push, swap, and restore methods to temporarily modify the component's symbol tree.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/spinalhdl_datamodel.rst#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef atBeginingOfCurrentComponent[T](body : => T) : T = {\n    val body = Component.current.dslBody  // Get the head of the current component symbols tree (AST in other words)\n    val ctx = body.push()                 // Now all access to the SpinalHDL API will be append to it (instead of the current context)\n    val swapContext = body.swap()         // Empty the symbol tree (but keep a reference to the old content)\n    val ret = that                        // Execute the block of code (will be added to the recently empty body)\n    ctx.restore()                         // Restore the original context in which this function was called\n    swapContext.appendBack()              // append the original symbols tree to the modified body\n    ret                                   // return the value returned by that\n  }\n  \n  val database = mutable.HashMap[Any, Bool]()\n  def get(key : Any) : Bool = {\n    database.getOrElseUpdate(key, atBeginingOfCurrentComponent(False)\n  }\n  \n  object key\n  \n  when(something) {\n    if(somehow) {\n      get(key) := True\n    }\n  }  \n  when(database(key)) {\n     ...\n  }\n```\n\n----------------------------------------\n\nTITLE: Define JTAG State Machine in SpinalHDL\nDESCRIPTION: Defines the JTAG state machine states including Test-Logic-Reset, Run-Test/Idle, Select DR Scan, Capture DR, Shift DR, Exit1 DR, Pause DR, Exit2 DR, Update DR, Select IR Scan, Capture IR, Shift IR, Exit1 IR, Pause IR, Exit2 IR, and Update IR. The randBoot() on the state variable initializes it to a random state for simulation purposes.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Advanced ones/jtag.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject JtagState extends SpinalEnum {\n  val TEST_LOGIC_RESET, RUN_TEST_IDLE, SELECT_DR_SCAN, CAPTURE_DR, SHIFT_DR, EXIT1_DR, PAUSE_DR, EXIT2_DR, UPDATE_DR, SELECT_IR_SCAN, CAPTURE_IR, SHIFT_IR, EXIT1_IR, PAUSE_IR, EXIT2_IR, UPDATE_IR = newElement()\n}\n\nimport JtagState._\n\nclass JtagFsm(jtag: Jtag, instructionWidth: Int) extends Area {\n  import JtagState._\n\n  val state = Reg(JtagState()).randBoot()\n  val instruction = Reg(Bits(instructionWidth bits))\n  val instructionNext = Bits(instructionWidth bits)\n  instruction := instructionNext //Avoid hazard\n\n  when(True) {\n    switch(state) {\n      is(TEST_LOGIC_RESET) {\n        when(jtag.tms) {\n          state := TEST_LOGIC_RESET\n        } otherwise {\n          state := RUN_TEST_IDLE\n        }\n      }\n      is(RUN_TEST_IDLE) {\n        when(jtag.tms) {\n          state := SELECT_DR_SCAN\n        }\n      }\n      is(SELECT_DR_SCAN) {\n        when(jtag.tms) {\n          state := SELECT_IR_SCAN\n        } otherwise {\n          state := CAPTURE_DR\n        }\n      }\n      is(SELECT_IR_SCAN) {\n        when(jtag.tms) {\n          state := TEST_LOGIC_RESET\n        } otherwise {\n          state := CAPTURE_IR\n        }\n      }\n      is(CAPTURE_DR) {\n        when(jtag.tms) {\n          state := EXIT1_DR\n        } otherwise {\n          state := SHIFT_DR\n        }\n      }\n      is(CAPTURE_IR) {\n        when(jtag.tms) {\n          state := EXIT1_IR\n        } otherwise {\n          state := SHIFT_IR\n        }\n      }\n      is(SHIFT_DR) {\n        when(jtag.tms) {\n          state := EXIT1_DR\n        }\n      }\n      is(SHIFT_IR) {\n        when(jtag.tms) {\n          state := EXIT1_IR\n        }\n      }\n      is(EXIT1_DR) {\n        when(jtag.tms) {\n          state := UPDATE_DR\n        } otherwise {\n          state := PAUSE_DR\n        }\n      }\n      is(EXIT1_IR) {\n        when(jtag.tms) {\n          state := UPDATE_IR\n        } otherwise {\n          state := PAUSE_IR\n        }\n      }\n      is(PAUSE_DR) {\n        when(jtag.tms) {\n          state := EXIT2_DR\n        } otherwise {\n          state := PAUSE_DR\n        }\n      }\n      is(PAUSE_IR) {\n        when(jtag.tms) {\n          state := EXIT2_IR\n        } otherwise {\n          state := PAUSE_IR\n        }\n      }\n      is(EXIT2_DR) {\n        when(jtag.tms) {\n          state := UPDATE_DR\n        } otherwise {\n          state := SHIFT_DR\n        }\n      }\n      is(EXIT2_IR) {\n        when(jtag.tms) {\n          state := UPDATE_IR\n        } otherwise {\n          state := SHIFT_IR\n        }\n      }\n      is(UPDATE_DR) {\n        when(jtag.tms) {\n          state := TEST_LOGIC_RESET\n        } otherwise {\n          state := RUN_TEST_IDLE\n        }\n      }\n      is(UPDATE_IR) {\n        when(jtag.tms) {\n          state := TEST_LOGIC_RESET\n        } otherwise {\n          state := RUN_TEST_IDLE\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: TriStateArray Usage Example in Scala\nDESCRIPTION: This example shows how to use the TriStateArray bundle in SpinalHDL. It creates a dataBus signal of type TriStateArray(32 bits). It then sets the writeEnable signal to 0x87654321 and the write signal to 0x12345678. It also includes a conditional statement based on the value of the read signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/IO/tristate.rst#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval io = new Bundle {\n  val dataBus = master(TriStateArray(32 bits))\n}\n\nio.dataBus.writeEnable := 0x87654321\nio.dataBus.write := 0x12345678\nwhen(io.dataBus.read === 42) {\n\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Verilog from Nameable Example\nDESCRIPTION: Shows the resulting Verilog code generated from the Nameable API example in Scala. It demonstrates how the setName and setCompositeName methods affect the signal names in the generated module.  This highlights how SpinalHDL's naming system translates to hardware.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_1\n\nLANGUAGE: verilog\nCODE:\n```\nmodule MyComponent (\n);\n  wire                a;\n  wire                rawrr;\n  wire                c;\n  wire                rawrr_wuff;\nendmodule\n```\n\n----------------------------------------\n\nTITLE: Accessing internal signals with simPublic\nDESCRIPTION: This code shows how to access internal signals of a SpinalHDL component within the simulation by using the `simPublic()` tag. It can be added directly in the hardware description or after the toplevel component is instantiated. Dependencies include SpinalHDL core and sim libraries.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/signal.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject SimAccessSubSignal {\n  import spinal.core.sim._\n\n  class TopLevel extends Component {\n    val counter = Reg(UInt(8 bits)) init(0) simPublic() // Here we add the simPublic tag on the counter register to make it visible\n    counter := counter + 1\n  }\n\n  def main(args: Array[String]) {\n    SimConfig.compile(new TopLevel).doSim{dut =>\n      dut.clockDomain.forkStimulus(10)\n\n      for(i <- 0 to 3) {\n        dut.clockDomain.waitSampling()\n        println(dut.counter.toInt)\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: UInt Comparison with Literal in SpinalHDL (Scala)\nDESCRIPTION: This snippet demonstrates a UInt comparison with a literal in SpinalHDL. The comparison `value < 42` will result in an out-of-range constant error because the literal 42 requires more bits than the UInt(2 bits) value. This is because SpinalHDL checks for this condition during compilation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/out_of_range_constant.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval value = in UInt(2 bits)\nval result = out(value < 42)\n```\n\n----------------------------------------\n\nTITLE: Setting State Encoding with SpinalEnumEncoding - Scala\nDESCRIPTION: This example shows how to set the state encoding of a SpinalHDL state machine using a SpinalEnumEncoding, specifically binaryOneHot. This configures the encoding scheme for the FSM's state vector.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/fsm.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval fsm = new StateMachine {\n  setEncoding(binaryOneHot)\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: APB Interface Bundle with Configuration Class in Scala\nDESCRIPTION: This code defines an APB interface using a configuration class (APBConfig) in SpinalHDL.  This allows for easier parameterization and reuse of the interface configuration. The [val] keyword makes the configuration public.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/types.rst#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ncase class APBConfig(addressWidth: Int,\n                        dataWidth: Int,\n                        selWidth : Int,\n                        useSlaveError : Boolean)\n\n   class APB(val config: APBConfig) extends Bundle {   // [val] config, make the configuration public\n     val PADDR      = UInt(config.addressWidth bits)\n     val PSEL       = Bits(config.selWidth bits)\n     val PENABLE    = Bool()\n     val PREADY     = Bool()\n     val PWRITE     = Bool()\n     val PWDATA     = Bits(config.dataWidth bits)\n     val PRDATA     = Bits(config.dataWidth bits)\n     val PSLVERROR  = if(config.useSlaveError) Bool() else null\n   }\n\n   // Example of usage\n   val apbConfig = APBConfig(addressWidth = 8,dataWidth = 32,selWidth = 4,useSlaveError = false)\n   val busA = APB(apbConfig)\n   val busB = APB(apbConfig)\n```\n\n----------------------------------------\n\nTITLE: Defining VGA Bus in SpinalHDL (Scala)\nDESCRIPTION: Defines the VGA bus using SpinalHDL's Bundle.  Includes signals for vertical sync (vSync), horizontal sync (hSync), color enable (colorEn), and color data (color) based on the provided RgbConfig. The asMaster function sets the bundle as an output.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Graphics/vga.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Vga (rgbConfig: RgbConfig) extends Bundle with IMasterSlave {\n  val vSync = Bool()\n  val hSync = Bool()\n\n  val colorEn = Bool()  // High when the frame is inside the color area\n  val color = Rgb(rgbConfig)\n\n  override def asMaster() = this.asOutput()\n}\n```\n\n----------------------------------------\n\nTITLE: Unreachable is statement - SpinalHDL - Scala\nDESCRIPTION: This Scala code defines a SpinalHDL component with a switch statement that contains a duplicated 'is' statement, leading to an unreachable code error during compilation. The 'sel' signal determines the value assigned to the 'result' signal within the switch.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/unreachable_is_statement.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val sel = UInt(2 bits)\n  val result = UInt(4 bits)\n  switch(sel) {\n    is(0){ result := 4 }\n    is(1){ result := 6 }\n    is(2){ result := 8 }\n    is(3){ result := 9 }\n    is(0){ result := 2 } // Duplicated is statement!\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using RgbConfig and Rgb Bundles in SpinalHDL (Scala)\nDESCRIPTION: This code shows how to create instances of RgbConfig and Rgb, and how to assign a value to the red channel.  It requires the RgbConfig and Rgb definitions.  The red channel is assigned the maximum value (31) for its width (5 bits).\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Graphics/colors.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval config = RgbConfig(5,6,5)\nval color = Rgb(config)\ncolor.r := 31\n```\n\n----------------------------------------\n\nTITLE: Generated Verilog with Composite Naming\nDESCRIPTION: Displays the Verilog output from the Composite example. The comparator signal is named value_comparator, reflecting the Composite's parameter being used as the namespace prefix. This highlights the Composite's role in signal naming.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_10\n\nLANGUAGE: verilog\nCODE:\n```\nmodule MyComponent (\n  input      [7:0]    value,\n  output              result\n);\n  wire                value_comparator;\n\n  assign value_comparator = (value == 8'h0);\n  assign result = value_comparator;\n\nendmodule\n```\n\n----------------------------------------\n\nTITLE: Defining a SpinalEnum with static custom encoding\nDESCRIPTION: This code shows how to define a SpinalEnum with a static custom encoding.  It maps each enumeration value to a specific integer value. `SpinalEnumEncoding` is used to define the static encoding. \nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/enum.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n/* \n * Static encoding \n */\nobject MyEnumStatic extends SpinalEnum {\n  val e0, e1, e2, e3 = newElement()\n  defaultEncoding = SpinalEnumEncoding(\"staticEncoding\")(\n    e0 -> 0,\n    e1 -> 2,\n    e2 -> 3,\n    e3 -> 7)\n}\n```\n\n----------------------------------------\n\nTITLE: Find All Adders Manually - SpinalHDL Scala\nDESCRIPTION: This example demonstrates how to manually traverse the SpinalHDL netlist to identify all adder operations. It defines a custom Phase that recursively walks through the component hierarchy, statements, and expressions to find instances of the Operator.BitVector.Add class. This showcases direct access to the internal data model without using built-in shortcuts.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/spinalhdl_datamodel.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject FindAllAddersManually {\n      class Toplevel extends Component {\n        val a,b,c = in UInt(8 bits)\n        val result = out(a + b + c)\n      }\n\n      import spinal.core.internals._\n\n      class PrintBaseTypes(message : String) extends Phase {\n        override def impl(pc: PhaseContext) = {\n          println(message)\n\n          recComponent(pc.topLevel)\n\n          def recComponent(c: Component): Unit = {\n            c.children.foreach(recComponent)\n            c.dslBody.foreachStatements(recStatement)\n          }\n\n          def recStatement(s: Statement): Unit = {\n            s.foreachExpression(recExpression)\n            s match {\n              case ts: TreeStatement => ts.foreachStatements(recStatement)\n              case _ =>\n            }\n          }\n\n          def recExpression(e: Expression): Unit = {\n            e match {\n              case op: Operator.BitVector.Add => println(s\"Found ${op.left} + ${op.right}\")\n              case _ =>\n            }\n            e.foreachExpression(recExpression)\n          }\n\n        }\n        override def hasNetlistImpact = false\n\n        override def toString = s\"${super.toString} - $message\"\n      }\n\n      def main(args: Array[String]): Unit = {\n        val config = SpinalConfig()\n\n        // Add a early phase\n        config.addTransformationPhase(new PrintBaseTypes(\"Early\"))\n\n        // Add a late phase\n        config.phasesInserters += {phases =>\n          phases.insert(phases.indexWhere(_.isInstanceOf[PhaseVerilog]), new PrintBaseTypes(\"Late\"))\n        }\n        config.generateVerilog(new Toplevel())\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: Equivalent Combinational Signal Assignments (Scala)\nDESCRIPTION: This snippet illustrates that the order of combinational signal assignments is irrelevant in SpinalHDL. The two code blocks are functionally equivalent because the assignments are evaluated concurrently, and the last valid assignment determines the final value of each signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/rules.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval a, b, c = UInt(8 bits) // Define 3 combinational signals\nb := 2      // b will be set to 2\na := b + 3  // a will be set to 5\nc := a + b  // c will be set to 7\n```\n\n----------------------------------------\n\nTITLE: Safe Clock Domain Crossing with BufferCC (Scala)\nDESCRIPTION: This code snippet illustrates the use of `BufferCC` for safely crossing clock domains with single-bit signals (like Bool) or Gray-coded values. `BufferCC` synchronizes the signal between `pushClock` and `popClock` domains when assigning `popToPushGray` to `popPtrGray` and `pushToPopGray` to `pushPtrGray`. Using `BufferCC` for multi-bit signals is risky due to potential data corruption.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/clock_crossing_violation.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass AsyncFifo extends Component {\n   val popToPushGray = Bits(ptrWidth bits)\n   val pushToPopGray = Bits(ptrWidth bits)\n  \n   val pushCC = new ClockingArea(pushClock) {\n     val pushPtr     = Counter(depth << 1)\n     val pushPtrGray = RegNext(toGray(pushPtr.valueNext)) init(0)\n     val popPtrGray  = BufferCC(popToPushGray, B(0, ptrWidth bits))\n     val full        = isFull(pushPtrGray, popPtrGray)\n     ...\n   }\n  \n   val popCC = new ClockingArea(popClock) {\n     val popPtr      = Counter(depth << 1)\n     val popPtrGray  = RegNext(toGray(popPtr.valueNext)) init(0)\n     val pushPtrGray = BufferCC(pushToPopGray, B(0, ptrWidth bits))\n     val empty       = isEmpty(popPtrGray, pushPtrGray)   \n     ...\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Bundle as Component I/O in Scala\nDESCRIPTION: This example shows how to define a Bundle as an input or output of a SpinalHDL Component.  The key is using parentheses around the Bundle type when defining the io Bundle.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/types.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nclass MyComponent extends Component {\n     val io = Bundle {\n       val cmd = in(RGB(8))    // Don't forget the bracket around the bundle.\n       val rsp = out(RGB(8))\n     }\n   }\n```\n\n----------------------------------------\n\nTITLE: Defining Axi Clocked Area Scala\nDESCRIPTION: This code defines a clocked area for the AXI sub-system. All components connected to the AXI interconnect will be placed within this area, ensuring that they operate under the same clock domain. This helps to manage timing constraints and simplify the design.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval axi = new ClockingArea(axiClockDomain) {\n  // Here will come the rest of Pinsec\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating JTAG Controller Scala\nDESCRIPTION: This code instantiates the JTAG controller for debugging and memory access. It configures parameters such as memory address width, memory data width, remote command width, and the JTAG clock domain. The JTAG controller allows a PC to interact with the system for debugging purposes.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval jtagCtrl = JtagAxi4SharedDebugger(SystemDebuggerConfig(\n  memAddressWidth = 32,\n  memDataWidth    = 32,\n  remoteCmdWidth  = 1,\n  jtagClockDomain = jtagClockDomain\n))\n```\n\n----------------------------------------\n\nTITLE: BigInt Enricher in Scala\nDESCRIPTION: Demonstrates the usage of the `toBigInt` method to convert Int, Long, and Byte values to BigInt. This allows seamless conversion between these numeric types and BigInt. No explicit import is needed within the code snippet context.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/binarySystem.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n$: 32.toBigInt\n   32\n   $: 3211323244L.toBigInt\n   3211323244\n   $: 8.toByte.toBigInt\n   8\n```\n\n----------------------------------------\n\nTITLE: Mapping Clock Domains in SpinalHDL BlackBox (Scala)\nDESCRIPTION: This code demonstrates how to map clock domains to the inputs of a BlackBox in SpinalHDL using `mapClockDomain` and `mapCurrentClockDomain`. It shows how to connect a specific clock domain to one input and the current clock domain to another input of the blackbox.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/blackbox.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass MyRam(clkDomain: ClockDomain) extends BlackBox {\n\n  val io = new Bundle {\n    val clkA = in Bool()\n    ...\n    val clkB = in Bool()\n    ...\n  }\n\n  // Clock A is map on a specific clock Domain \n  mapClockDomain(clkDomain, io.clkA)\n  // Clock B is map on the current clock domain \n  mapCurrentClockDomain(io.clkB)\n}\n```\n\n----------------------------------------\n\nTITLE: Interlocking Plugins using Retainers in Scala\nDESCRIPTION: This snippet demonstrates interlocking plugins using Retainer instances. The SetupPlugin retains the DriverPlugin, modifies a variable (incrementBy), and then releases the DriverPlugin, ensuring proper hardware generation order.  The `retainer.await()` call in DriverPlugin blocks elaboration until SetupPlugin releases the lock.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Misc/service_plugin.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core._\nimport spinal.lib.misc.plugin._\nimport spinal.core.fiber._\n\nclass SubComponent extends Component {\n  val host = new PluginHost()\n}\n\nclass StatePlugin extends FiberPlugin {\n  val logic = during build new Area {\n    val signal = Reg(UInt(32 bits))\n  }\n}\n\nclass DriverPlugin extends FiberPlugin {\n  // incrementBy will be set by others plugin at elaboration time\n  var incrementBy = 0\n  // retainer allows other plugins to create locks, on which this plugin will wait before using incrementBy\n  val retainer = Retainer()\n\n  val logic = during build new Area {\n    val sp = host[StatePlugin].logic.get\n    retainer.await()\n\n    // Generate the incrementer hardware\n    sp.signal := sp.signal + incrementBy\n  }\n}\n\n// Let's define a plugin which will modify the DriverPlugin.incrementBy variable because letting it elaborate its hardware\nclass SetupPlugin extends FiberPlugin {\n  // during setup { body } will spawn the body of code in the Fiber setup phase (it is before the Fiber build phase)\n  val logic = during setup new Area {\n    // *** Setup phase code ***\n    val dp = host[DriverPlugin]\n\n    // Prevent the DriverPlugin from executing its build's body (until release() is called)\n    val lock = dp.retainer()\n    // Wait until the fiber phase reached build phase\n    awaitBuild()\n\n    // *** Build phase code ***\n    // Let's mutate DriverPlugin.incrementBy\n    dp.incrementBy += 1\n\n    // Allows the DriverPlugin to execute its build's body\n    lock.release()\n  }\n}\n\nclass TopLevel extends Component {\n  val sub = new SubComponent()\n\n  sub.host.asHostOf(\n    new DriverPlugin(),\n    new StatePlugin(),\n    new SetupPlugin(),\n    new SetupPlugin() // Let's add a second SetupPlugin, because we can\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: StageCtrlPipeline Usage Scala\nDESCRIPTION: This snippet demonstrates the use of StageCtrlPipeline for creating a pipeline with CtrlLinks.  It shows how to insert data, perform operations, and conditionally drop transactions based on data values.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\n  // Let's define a few inputs/outputs.\n    val a,b = in UInt(8 bits)\n    val result = out(UInt(8 bits))\n\n    // Let's create the pipelining tool.\n    val pip = new StageCtrlPipeline\n\n    // Let's insert a and b into the pipeline at stage 0.\n    val A = pip.ctrl(0).insert(a)\n    val B = pip.ctrl(0).insert(b)\n\n    // Let's sum A and B at stage 1.\n    val onSum = new pip.Ctrl(1) {\n      val VALUE = insert(A + B)\n    }\n\n    // Let's check if the sum is bad (> 128) in stage 2 and if that is the case, we drop the transaction.\n    val onTest = new pip.Ctrl(2) {\n      val isBad = onSum.VALUE > 128\n      throwWhen(isBad)\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining a Clock Domain in SpinalHDL\nDESCRIPTION: This code snippet shows how to define a clock domain in SpinalHDL using the ClockDomain constructor. It takes a clock signal and an optional reset signal as parameters. The example defines a new clock domain called 'coreClockDomain' and uses it in an area of the design where a register 'coreClockedRegister' is instantiated.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/miscelenea/core/core_components.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval coreClock = Bool()\nval coreReset = Bool()\n\n// Define a new clock domain\nval coreClockDomain = ClockDomain(coreClock,coreReset)\n\n...\n\n// Use this domain in an area of the design\nval coreArea = new ClockingArea(coreClockDomain) {\n  val coreClockedRegister = Reg(UInt(4 bits))\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Assignment with When/Otherwise on separate lines in Scala\nDESCRIPTION: This code demonstrates how to use 'when' and '.otherwise' when they are on separate lines. The dot is **required** when `.otherwise` is on another line.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/when_switch.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nwhen(cond1) {\n  // Execute when cond1 is true\n}\n.otherwise {\n  // Execute when (not cond1) and (not cond2)\n}\n```\n\n----------------------------------------\n\nTITLE: Installing jenv on macOS with Homebrew\nDESCRIPTION: This snippet installs `jenv` on macOS using Homebrew.  `jenv` is a tool for managing multiple Java versions.  Requires Homebrew.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Install and setup.rst#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nbrew install jenv\n```\n\n----------------------------------------\n\nTITLE: Defining SDRAM Layout and Timings Scala\nDESCRIPTION: This code defines the layout and timings for the IS42x320D SDRAM device. The layout specifies the bank width, column width, row width, and data width. The timings define parameters like boot refresh count, tPOW, tREF, tRC, tRFC, tRAS, tRP, tRCD, cMRD, tWR, and cWR. These definitions are essential for configuring the SDRAM controller correctly.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nobject IS42x320D {\n  def layout = SdramLayout(\n    bankWidth   = 2,\n    columnWidth = 10,\n    rowWidth    = 13,\n    dataWidth   = 16\n  )\n\n  def timingGrade7 = SdramTimings(\n    bootRefreshCount =   8,\n    tPOW             = 100 us,\n    tREF             =  64 ms,\n    tRC              =  60 ns,\n    tRFC             =  60 ns,\n    tRAS             =  37 ns,\n    tRP              =  15 ns,\n    tRCD             =  15 ns,\n    cMRD             =   2,\n    tWR              =  10 ns,\n    cWR              =   1\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring UART Controller Scala\nDESCRIPTION: This code defines the configuration for the UART controller, including generics for data width, clock divider width, and sampling sizes, as well as the depths for the transmit and receive FIFOs.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval uartCtrlConfig = UartCtrlMemoryMappedConfig(\n  uartCtrlConfig = UartCtrlGenerics(\n    dataWidthMax      = 8,\n    clockDividerWidth = 20,\n    preSamplingSize   = 1,\n    samplingSize      = 5,\n    postSamplingSize  = 2\n  ),\n  txFifoDepth = 16,\n  rxFifoDepth = 16\n)\n```\n\n----------------------------------------\n\nTITLE: Simulation Ending with Explicit simSuccess()\nDESCRIPTION: This example illustrates a simulation that ends by explicitly calling simSuccess(). A forked thread waits for the counter to reach a certain value, prints \"done\", and then calls simSuccess() to terminate the simulation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/bootstraps.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nSimConfig.compile(new TopLevel).doSimUntilVoid{ dut =>\n  SimTimeout(1000)\n  dut.clockDomain.forkStimulus(10)\n  fork {\n    dut.clockDomain.waitSamplingWhere(dut.counter.toInt == 20)\n    println(\"done\")\n    simSuccess()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: SpinalHDL Enum and Report\nDESCRIPTION: This snippet demonstrates how to define an enum in SpinalHDL and use the 'report' function to generate a display message including the enum value and other signals.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/report.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject Enum extends SpinalEnum {\n    val MIAOU, RAWRR = newElement()\n}\n\nclass TopLevel extends Component {\n    val a = Enum.RAWRR()\n    val b = U(0x42)\n    val c = out(Enum.RAWRR())\n    val d = out (U(0x42))\n    report(Seq(\"miaou \", a, b, c, d))\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Signal Behavior in SpinalHDL\nDESCRIPTION: This code snippet demonstrates how to use SpinalHDL's `assert` function to check a condition related to handshake signals. Specifically, it checks that the `valid` signal never drops when the `ready` signal is low. The assertion is configured with an ERROR severity, meaning it indicates a situation that should not occur.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/assertion.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n     val valid = RegInit(False)\n     val ready = in Bool()\n\n     when(ready) {\n       valid := False\n     }\n     // some logic\n\n     assert(\n       assertion = !(valid.fall && !ready),\n       message   = \"Valid dropped when ready was low\",\n       severity  = ERROR\n     )\n   }\n```\n\n----------------------------------------\n\nTITLE: Configuring VCS Simulation with Setup File (Scala)\nDESCRIPTION: This Scala code snippet configures a VCS simulation using SpinalHDL's SimConfig. It specifies a setup file (`synopsys_sim.setup`) and a code block to be executed before the VCS analysis step.  It uses the `withVCSSimSetup` method.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/install/VCS.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval simConfig = SimConfig\n  .withVCS\n  .withVCSSimSetup(\n    setupFile = \"~/work/myproj/sim/synopsys_sim.setup\",\n    beforeAnalysis = () => { // this code block will be run before VCS analysis step.\n      \"pwd\".!\n      println(\"Hello, VCS\")\n    }\n  )\n```\n\n----------------------------------------\n\nTITLE: Fixing Scope Violation in SpinalHDL Scala\nDESCRIPTION: This SpinalHDL code snippet shows the correct way to declare and assign the 'tmp' signal.  By declaring the UInt 'tmp' outside of the 'when' block, its scope is expanded to the entire 'TopLevel' component, resolving the scope violation error. The signal is initialized with a UInt of 8 bits.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/scope_violation.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass TopLevel extends Component {\n  val cond = Bool()\n\n  var tmp : UInt = UInt(8 bits)\n  when(cond) {\n\n  }\n  tmp := U\"x42\"\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected SpinalHDL component definition\nDESCRIPTION: This Scala code demonstrates the correct way to define and assign a value to a signal in SpinalHDL. By declaring the signal `a` before assigning a value to it, the NullPointerException is avoided.  This ensures that the signal is initialized before being used.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/nullpointerexception.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass TopLevel extends Component {\n  val a = UInt(8 bits)\n  a := 42\n}\n```\n\n----------------------------------------\n\nTITLE: Slots Implementation in SpinalHDL (Scala)\nDESCRIPTION: This code snippet demonstrates how to implement an array of slots using SpinalHDL, avoiding the use of Vec. It utilizes Area to define signals, registers, and logic within each slot. The example employs OHMasking.first and onMask for managing the slots. The `reader` API is for SpinalHDL version coming after 1.9.1\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Advanced ones/slots.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core._\n\nobject Slots {\n  def main(args: Array[String]): Unit = {\n    SpinalConfig(targetDirectory = \"spinal_gen\").generateVerilog(new Component {\n      val slotsCount = 8\n\n      val slotsMask = RegInit(False)\n      val slots = for(slotId <- 0 until slotsCount) yield new Area {\n        val valid = RegInit(False)\n        val data = Reg(UInt(8 bits))\n\n        when(! valid && ! slotsMask) { //Claim the slot\n          valid := True\n          data := U(slotId)\n          slotsMask := True\n        }\n        when(valid && data === U(slotId)) { //Release the slot\n          valid := False\n          slotsMask := False\n        }\n      }\n\n      val slotsValid = Vec(slots.map(_.valid))\n      val slotsData = Vec(slots.map(_.data))\n\n      //Which slots is available ?\n      val slotsFree = !slotsValid.orR\n\n      //Get the first free slot id\n      val slotsFreeId = OHMasking.first(slotsValid)\n\n      //Do something on each slots\n      for(slot <- slots) { onMask(slot.valid) {\n          //Do something when the slot is valid\n      }}\n\n      //Read slots data\n      val reader = new Area {\n        import spinal.lib._\n        val cmd = slave Stream(UInt(log2Up(slotsCount) bits))\n        val rsp = master Stream(UInt(8 bits))\n\n        rsp.valid := False\n        rsp.payload := 0\n\n        cmd.ready := True //You may want to add a comb logic to add some latency\n        when(cmd.valid) {\n          rsp.valid := True\n          rsp.payload := slotsData(cmd.payload)\n        }\n      }\n\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting and Reporting Unused Signals in SpinalHDL\nDESCRIPTION: This code demonstrates how to use the printPruned method to detect and report unused signals in a SpinalHDL design. It shows how to define a component with unused signals and then use SpinalVhdl to generate a report of those signals.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/components_hierarchy.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val io = new Bundle {\n    val a,b = in port UInt(8 bits)\n    val result = out port UInt(8 bits)\n  }\n\n  io.result := io.a + io.b\n\n  val unusedSignal = UInt(8 bits)\n  val unusedSignal2 = UInt(8 bits)\n\n  unusedSignal2 := unusedSignal\n}\n\nobject Main {\n  def main(args: Array[String]) {\n    SpinalVhdl(new TopLevel).printPruned()\n    // This will report :\n    //  [Warning] Unused signal detected : toplevel/unusedSignal : UInt[8 bits]\n    //  [Warning] Unused signal detected : toplevel/unusedSignal2 : UInt[8 bits]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: RGB Color Definition in Scala\nDESCRIPTION: Defines a data structure for representing RGB colors with red, green, and blue channels. This structure is used to feed the VGA controller with pixel data and is also used by the VGA bus.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/vga.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class RgbConfig(\n  rWidth: Int,\n  gWidth: Int,\n  bWidth: Int\n) {\n  val colorWidth = rWidth + gWidth + bWidth\n  def rOffset = 0\n  def gOffset = rWidth\n  def bOffset = rWidth + gWidth\n\n  def getR(value: UInt) = value(rOffset, rWidth bits)\n  def getG(value: UInt) = value(gOffset, gWidth bits)\n  def getB(value: UInt) = value(bOffset, bWidth bits)\n}\n\ncase class Rgb(config: RgbConfig) extends Bundle {\n  val r = UInt(config.rWidth bits)\n  val g = UInt(config.gWidth bits)\n  val b = UInt(config.bWidth bits)\n  def asUInt: UInt = {r ## g ## b}\n}\n```\n\n----------------------------------------\n\nTITLE: Waiting for a Rising Edge on the Clock - Scala\nDESCRIPTION: This example shows how to wait for a rising edge on the clock using the waitRisingEdge function within a SpinalHDL testbench.  It assumes that the 'dut' instance and its default clock domain are already defined.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/clock.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndut.clockDomain.waitRisingEdge()\n```\n\n----------------------------------------\n\nTITLE: Optional Signal Generation with 'generate' in SpinalHDL (Scala)\nDESCRIPTION: This snippet shows how to conditionally generate a signal based on a boolean flag using the `generate` method in SpinalHDL. If the `flag` is true, `mySignal` will be a `Bool` signal; otherwise, it will be null.  This allows for selective inclusion of signals in the hardware design.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/parametrization.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ncase class MyComponent(flag : Boolean) extends Component {\n  val mySignal = flag generate (Bool())\n  // equivalent to \"val mySignal = if (flag) Bool() else null\"\n}\n```\n\n----------------------------------------\n\nTITLE: Scala Component with OR Reduction\nDESCRIPTION: This Scala code defines a component with a vector of boolean inputs and reduces them to a single boolean output using the 'or' operator. This highlights how SpinalHDL handles long expression chains.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\n  class MyComponent extends Component {\n    val conditions = in Vec(Bool(), 64)\n    // Perform a logical OR between all the condition elements\n    val result = conditions.reduce(_ || _)\n\n    // For Bits/UInt/SInt signals the 'orR' methods implements this reduction operation\n  }\n```\n\n----------------------------------------\n\nTITLE: Scala: Setting SpinalHDL version to \"dev\"\nDESCRIPTION: This snippet shows how to set the SpinalHDL version to 'dev' in a build.sbt or build.sc file. This indicates that the project should use the locally published, unreleased version of SpinalHDL. Replaces the standard version number.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Introduction/faq.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval spinalVersion = \"1.7.3\"\n// becomes\nval spinalVersion = \"dev\"\n```\n\n----------------------------------------\n\nTITLE: Add User-Friendly Functions to JtagTapAccess\nDESCRIPTION: Adds user-friendly functions to the JtagTapAccess trait to simplify the instantiation of JTAG instructions. These helper functions make it easier to create and configure different types of instructions (e.g., idcode, read, write) without writing boilerplate code.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Advanced ones/jtag.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ntrait JtagTapAccess {\n  def getTdi(): Bool\n\n  def getTdo(): TriState[Bool]\n\n  def getTdoEnable(): Bool\n\n  def getFsmState(): SpinalEnumCraft[JtagState.type]\n\n  def idcode(value: Bits)(instructionId: Bits) = new JtagInstructionIdcode(this, instructionId, value)\n\n  def read(signal: Bits)(instructionId: Bits) = new JtagInstructionRead(this, instructionId, signal)\n\n  def write(signal: Bits)(instructionId: Bits) = new JtagInstructionWrite(this, instructionId, signal)\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Link Implementation Scala\nDESCRIPTION: This snippet defines a trait for implementing custom Links in SpinalHDL. It outlines the required methods for managing up/down nodes and building the link logic.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ntrait Link extends Area {\n      def ups : Seq[Node]\n      def downs : Seq[Node]\n\n      def propagateDown(): Unit\n      def propagateUp(): Unit\n      def build() : Unit\n    }\n```\n\n----------------------------------------\n\nTITLE: Assigning Scala Constants to Fixed-Point Signals in SpinalHDL\nDESCRIPTION: This snippet shows how to assign Scala BigInt or Double constants directly to UFix or SFix signals in SpinalHDL. It demonstrates the implicit conversion from Scala numeric types to fixed-point values, with the raw value being updated accordingly.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Fix.rst#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval i4_m2 = SFix(4 exp, -2 exp)\ni4_m2 := 1.25    // Will load 5 in i4_m2.raw\ni4_m2 := 4       // Will load 16 in i4_m2.raw\n```\n\n----------------------------------------\n\nTITLE: Calling a Static Function in Scala Object\nDESCRIPTION: This demonstrates calling the static function `pow2` defined in the `MathUtils` object. The function is called directly on the object using the dot notation: `MathUtils.pow2(42.0f)`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nMathUtils.pow2(42.0f)\n```\n\n----------------------------------------\n\nTITLE: Defining a Ram BlackBox in SpinalHDL (Scala)\nDESCRIPTION: This code defines a RAM as a BlackBox in SpinalHDL. It demonstrates how to add VHDL generics/Verilog parameters, define IO interfaces with clk, wr (enable, address, data), and rd (enable, address, data) signals, and map the current clock domain to the io.clk pin.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/blackbox.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// Define a Ram as a BlackBox\nclass Ram_1w_1r(wordWidth: Int, wordCount: Int) extends BlackBox {\n  // Add VHDL Generics / Verilog parameters to the blackbox\n  // You can use String, Int, Double, Boolean, and all SpinalHDL base\n  // types as generic values\n  addGeneric(\"wordCount\", wordCount)\n  addGeneric(\"wordWidth\", wordWidth)\n\n  // Define IO of the VHDL entity / Verilog module\n  val io = new Bundle {\n    val clk = in Bool()\n    val wr = new Bundle {\n      val en   = in Bool()\n      val addr = in UInt (log2Up(wordCount) bits)\n      val data = in Bits (wordWidth bits)\n    }\n    val rd = new Bundle {\n      val en   = in Bool()\n      val addr = in UInt (log2Up(wordCount) bits)\n      val data = out Bits (wordWidth bits)\n    }\n  }\n\n  // Map the current clock domain to the io.clk pin\n  mapClockDomain(clock=io.clk)\n}\n```\n\n----------------------------------------\n\nTITLE: Uart TX Header Implementation Scala\nDESCRIPTION: This snippet shows how to prepend a header (0x55) before sending data via the UART. It modifies the write generator to include a specific header value before transmitting the actual data, such as the value of switches.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/uart.rst#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nval txBuffer = StreamFifo(Bits(8 bits), 32)\n  txBuffer.io.push.valid := tx.valid || headerCounter =/= 0\n  txBuffer.io.push.payload := headerCounter === 0 ? tx.payload | B(0x55)\n\n  val headerCounter = Reg(UInt(1 bit)) init(0)\n  when(tx.valid && txBuffer.io.push.ready){\n    headerCounter := 1\n  }\n  when(headerCounter === 1 && txBuffer.io.push.ready){\n    headerCounter := 0\n  }\n\n  txBuffer.io.push << tx\n  uartCtrl.io.uart.txd := txBuffer.io.pop.valid ? txBuffer.io.pop.payload | True\n  txBuffer.io.pop.ready := uartCtrl.io.uart.txd\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Clock Domains with setSynchronousWith (Scala)\nDESCRIPTION: This example demonstrates the use of the `setSynchronousWith` method to declare two clock domains as synchronous. This informs SpinalHDL that clkA and clkB operate synchronously, preventing clock crossing violation errors. The function `setSynchronousWith` is called on a ClockDomain object, and the other ClockDomain object is passed as argument to define the relationship.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/clock_crossing_violation.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val clkA = ClockDomain.external(\"clkA\")\n  val clkB = ClockDomain.external(\"clkB\")\n  clkB.setSynchronousWith(clkA)\n\n  val regA = clkA(Reg(UInt(8 bits)))\n  val regB = clkB(Reg(UInt(8 bits)))\n\n\n  val tmp = regA + regA\n  regB := tmp\n}\n```\n\n----------------------------------------\n\nTITLE: First-Order Low-Pass Filter in SpinalHDL/Scala\nDESCRIPTION: Implements a first-order low-pass filter to generate a filtered version of the sine wave. This filter smooths out the sine wave, reducing high-frequency components.  The filter uses a simple averaging approach.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Simple ones/sinus_rom.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n  val alpha = 0.95 // Adjust this value to change the filter characteristics\n  val sinFiltered_r = Reg(SInt(resolutionWidth bits)) init (0)\n  sinFiltered_r := (sinFiltered_r * alpha).resized + (io.sin * (1 - alpha)).resized\n  io.sinFiltered := sinFiltered_r\n```\n\nLANGUAGE: Scala\nCODE:\n```\nio.sinFiltered := sinFiltered_r\n```\n\n----------------------------------------\n\nTITLE: Generated Verilog with Shortcuted Signal\nDESCRIPTION: Demonstrates how SpinalHDL can \"shortcut\" unnamed signals in the generated Verilog code. The tmp signal in the Scala example is optimized away because it's unnamed and technically shortcutable. This shows how naming affects signal optimization.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_4\n\nLANGUAGE: verilog\nCODE:\n```\nmodule MyComponent (\n  input      [7:0]    a,\n  input      [7:0]    b,\n  output     [7:0]    toto\n);\n  // Note that the tmp signal defined in scala was \"shortcuted\" by SpinalHDL,\n  //  as it was unnamed and technically \"shortcutable\"\n  assign toto = 8'h20;\nendmodule\n```\n\n----------------------------------------\n\nTITLE: Setting LD_LIBRARY_PATH for VCS PLI Features (Bash)\nDESCRIPTION: This bash script sets the LD_LIBRARY_PATH environment variable to include the necessary paths for VCS PLI (Programming Language Interface) features. It prepends several directories containing shared libraries to the existing LD_LIBRARY_PATH.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/install/VCS.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport LD_LIBRARY_PATH=$VERDI_HOME/share/PLI/VCS/LINUX64:$LD_LIBRARY_PATH \nexport LD_LIBRARY_PATH=$VERDI_HOME/share/PLI/IUS/LINUX64:$LD_LIBRARY_PATH \nexport LD_LIBRARY_PATH=$VERDI_HOME/share/PLI/lib/LINUX64:$LD_LIBRARY_PATH \nexport LD_LIBRARY_PATH=$VERDI_HOME/share/PLI/Ius/LINUX64:$LD_LIBRARY_PATH \nexport LD_LIBRARY_PATH=$VERDI_HOME/share/PLI/MODELSIM/LINUX64:$LD_LIBRARY_PATH\n```\n\n----------------------------------------\n\nTITLE: Fixing Register with Only Init - Scala\nDESCRIPTION: This code demonstrates how to fix the register with only init by adding `.allowUnsetRegToAvoidLatch`. This tells SpinalHDL to transform the register into a combinational signal if no assignment is present besides the init value.  This is useful for registers used only under certain conditions.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/unassigned_register.rst#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass TopLevel extends Component {\n  val result = out(UInt(8 bits))\n  val a = Reg(UInt(8 bits)).init(42).allowUnsetRegToAvoidLatch\n\n  if(something)\n    a := somethingElse\n  result := a\n}\n```\n\n----------------------------------------\n\nTITLE: Parameterizing WhenBuilder with a For Loop in Scala\nDESCRIPTION: This code shows how to use a 'for' loop to add multiple 'when' conditions within a 'WhenBuilder' context.  This allows parameterizing priority circuits in a more intuitive and concise manner. It sets a result based on the value of i, between 5 and 7.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/when_switch.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nfor(i <- 5 to 7) ctx.when(conds(i)) {\n  result := i\n}\n\nctx.otherwise {\n  result := 255\n}\n```\n\n----------------------------------------\n\nTITLE: Bool Declaration and Assignment in SpinalHDL (Scala)\nDESCRIPTION: This snippet demonstrates how to declare a Bool signal in SpinalHDL and assign values to it. It covers creating a Bool instance, assigning a Scala Boolean value, and using the assignment operator :=.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bool.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval myBool_1 = Bool()        // Create a Bool\nmyBool_1 := False            // := is the assignment operator (like verilog <=)\n\nval myBool_2 = False         // Equivalent to the code above \n\nval myBool_3 = Bool(5 > 12)  // Use a Scala Boolean to create a Bool\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversion via Import Scala\nDESCRIPTION: This snippet demonstrates importing implicit conversions to use payloads like their data representation. It shows how to add 1 to the value of a payload within a new Area, leveraging the imported implicit conversion.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval VALUE = Payload(UInt(16 bits))\n    val n1 = Node()\n\n    val n1Stuff = new Area {\n        import n1._\n        val PLUS_ONE = insert(VALUE) + 1 // Equivalent to n1.insert(n1(VALUE)) + 1\n    }\n```\n\n----------------------------------------\n\nTITLE: Installing Scala and SBT on Debian/Ubuntu using Coursier\nDESCRIPTION: This snippet demonstrates how to install Java JDK 17, Scala, and SBT on Debian or Ubuntu using Coursier. It updates the package index, installs the JDK, downloads and executes the Coursier installer, and updates the shell environment to include Coursier in the PATH. Requires curl, gzip, and apt-get.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Install and setup.rst#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nsudo apt-get update\nsudo apt-get install openjdk-17-jdk-headless curl git\ncurl -fL \"https://github.com/coursier/launchers/raw/master/cs-x86_64-pc-linux.gz\" | gzip -d > cs\nchmod +x cs\n# should find the just installed jdk, agree to cs' questions for adding to your PATH\n./cs setup\nsource ~/.profile\n```\n\n----------------------------------------\n\nTITLE: RGB to Grayscale Conversion Function - Scala\nDESCRIPTION: Defines a Scala function 'coef' that multiplies a UInt value by a Scala Float, used for RGB to grayscale conversion within SpinalHDL. It takes a UInt and a Float as input, then scales the UInt value. It is then used in an example converting RGB to grayscale by using coefficients.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/function.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n// Input RGB color\nval r, g, b = UInt(8 bits)\n\n// Define a function to multiply a UInt by a Scala Float value.\ndef coef(value: UInt, by: Float): UInt = (value * U((255 * by).toInt, 8 bits) >> 8)\n\n// Calculate the gray level\nval gray = coef(r, 0.3f) + coef(g, 0.4f) + coef(b, 0.3f)\n```\n\n----------------------------------------\n\nTITLE: Generated VHDL with InOutWrapper\nDESCRIPTION: This VHDL code shows the output of using InOutWrapper on the Apb3Gpio component.  The io_gpio signal, originally a TriStateArray Bundle in SpinalHDL, is now an inout std_logic_vector in VHDL. This allows the SpinalHDL design to have native tristate signals in the generated VHDL code.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/analog_inout.rst#_snippet_3\n\nLANGUAGE: vhdl\nCODE:\n```\nentity Apb3Gpio is\n  port(\n    io_gpio : inout std_logic_vector(31 downto 0); -- This io_gpio was originally a TriStateArray Bundle\n    io_apb_PADDR : in unsigned(3 downto 0);\n    io_apb_PSEL : in std_logic_vector(0 downto 0);\n    io_apb_PENABLE : in std_logic;\n    io_apb_PREADY : out std_logic;\n    io_apb_PWRITE : in std_logic;\n    io_apb_PWDATA : in std_logic_vector(31 downto 0);\n    io_apb_PRDATA : out std_logic_vector(31 downto 0);\n    io_apb_PSLVERROR : out std_logic;\n    clk : in std_logic;\n    reset : in std_logic\n  );\nend Apb3Gpio;\n```\n\n----------------------------------------\n\nTITLE: Getting Width of Bits\nDESCRIPTION: Demonstrates how to retrieve the width (number of bits) of a Bits type variable in SpinalHDL using Scala. It prints the width of a 32-bit variable.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bits.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nprintln(myBits_32bits.getWidth) // 32\n```\n\n----------------------------------------\n\nTITLE: Scala Component with Addition\nDESCRIPTION: This Scala code defines a simple component with multiple input UInt signals and calculates their sum.  This showcases how SpinalHDL handles expressions with multiple operators.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\n  class MyComponent extends Component {\n    val a,b,c,d = in UInt(8 bits)\n    val result = a + b + c + d\n  }\n```\n\n----------------------------------------\n\nTITLE: Generated Verilog for Stubbed Module\nDESCRIPTION: This is the Verilog code generated from the stubbed SpinalHDL Component. Notice how all internal logic is removed, and the outputs are simply tied to default values (0). The module still retains its input and output ports with clock and reset.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/stub.rst#_snippet_1\n\nLANGUAGE: Verilog\nCODE:\n```\nmodule SubSysModule (\n      input               io_dx_valid,\n      output              io_dx_ready,\n      input      [31:0]   io_dx_payload,\n      output              io_dy_valid,\n      input               io_dy_ready,\n      output     [31:0]   io_dy_payload,\n      input               clk,\n      input               reset\n    );\n\n\n      assign io_dx_ready = 1'b0;\n      assign io_dy_valid = 1'b0;\n      assign io_dy_payload = 32'h0;\n\n    endmodule\n```\n\n----------------------------------------\n\nTITLE: RGB Bundle Definition (Error)\nDESCRIPTION: This code defines an RGB Bundle with a width parameter. The error occurs because `cloneOf` cannot retrieve the `width` value used in the constructor, which is needed for cloning the Bundle. This often happens when using classes instead of case classes for Bundles.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/spinal_cant_clone.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// cloneOf(this) isn't able to retrieve the width value that was used to construct itself\nclass RGB(width : Int) extends Bundle {\n  val r, g, b = UInt(width bits)\n}\n\nclass TopLevel extends Component {\n  val tmp = Stream(new RGB(8)) // Stream requires the capability to cloneOf(new RGB(8))\n}\n```\n\n----------------------------------------\n\nTITLE: MaskedBoolean usage in SpinalHDL (Scala)\nDESCRIPTION: This snippet shows how to declare a MaskedBoolean signal in SpinalHDL. MaskedBoolean signals allow for \"don't care\" states.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bool.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n// first argument: Scala Boolean value\n// second argument: do we care ? expressed as a Scala Boolean\nval masked = new MaskedBoolean(true, false)\n```\n\n----------------------------------------\n\nTITLE: Publishing SpinalHDL Locally (Unreleased Version)\nDESCRIPTION: This command uses sbt to clean the project, cross-build it for Scala version 2.12.13, and publish it to the local Maven repository. This allows the unreleased version of SpinalHDL to be used in other projects on the same machine.  The Scala version should match the one in your project.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Introduction/faq.rst#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nsbt clean '++ 2.12.13' publishLocal\n```\n\n----------------------------------------\n\nTITLE: Bonus: Stream Fragment Handling in Scala\nDESCRIPTION: Adds a function to VgaCtrl to handle a Stream of Fragments of RGB, asserting softReset when an error occurs and deasserting it at the end of the picture.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/vga.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ncase class VgaCtrl(rgbConfig: RgbConfig, timingsWidth: Int = 12) extends Component {\n  import rgbConfig._\n  val io = new Bundle {\n    val softReset = in Bool()\n    val timings = in(VgaTimingsHV(timingsWidth))\n    val pixels = slave Stream Bits(colorWidth bits)\n\n    val error = out Bool()\n    val frameStart = out Bool()\n    val vga = master(Vga(rgbConfig))\n  }\n\n  val hCounter = Counter(0, 2048)\n  val vCounter = Counter(0, 2048)\n\n  val hv = new Area {\n    def sync(counter: Counter, timings: VgaTimingsHV#HV) = new Area {\n      val sync = counter >= timings.syncStart && counter < timings.syncEnd\n      val colorEnable = counter >= timings.colorStart && counter < timings.colorEnd\n    }\n\n    val h = sync(hCounter, io.timings.h)\n    val v = sync(vCounter, io.timings.v)\n  }\n\n\n  hCounter.increment() init(0)\n  when(hv.h.sync){vCounter.increment()}\n\n  io.vga.hSync := hv.h.sync\n  io.vga.vSync := hv.v.sync\n  io.vga.colorEn := hv.h.colorEnable && hv.v.colorEnable\n  io.vga.color := io.pixels.payload\n\n  io.error := False\n  when(! io.pixels.valid){io.error := True}\n\n  io.frameStart := False\n  when(vCounter.willOverflowIfInc){io.frameStart := True}\n\n  def drive(pixels: Stream[Fragment[Bits]]) = new Area {\n    val reseted = Reg(Bool()).init(False)\n\n    io.softReset := io.error || reseted\n    when(io.error){\n      reseted := True\n    }\n    when(pixels.last){ //was pixels.isLast\n      reseted := False\n    }\n\n    io.pixels << pixels.translateWith(pixels.payload.asBits())\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Virtual Pins for Altera (Scala)\nDESCRIPTION: This Scala code demonstrates how to set the `VIRTUAL_PIN` attribute on a `Vec` of `Flow[Bool]` in SpinalHDL for Altera. This is useful when testing components with a large number of pins. The `addAttribute` function allows adding Altera-specific attributes to the signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/EDA/altera/quartus_flow.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval miaou: Vec[Flow[Bool]] = Vec(master(Flow(Bool())), 666)\nmiaou.addAttribute(\"altera_attribute\", \"-name VIRTUAL_PIN ON\")\n```\n\n----------------------------------------\n\nTITLE: Generating HDL code with SBT runMain\nDESCRIPTION: This code snippet demonstrates how to run a specific HDL code-generation target using the `runMain` command in SBT. It generates either Verilog or VHDL code, depending on the target specified. The target is typically a class name within the project. The generated files will be placed in the `./hw/gen/` directory.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/SBT.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nrunMain projectname.MyTopLevelVerilog\n```\n\n----------------------------------------\n\nTITLE: Conditional Assignment with 'when' Clause in SpinalHDL (Scala)\nDESCRIPTION: This snippet shows how the `when` clause can conditionally assign values to a signal. The 'result' signal is initially set to 1, and then conditionally updated to 2 or 3 based on the values of 'x' and 'y'. The `if(paramIsFalse)` block is not elaborated into hardware because `paramIsFalse` is false during elaboration.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/rules.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n// Every clock cycle  evaluation starts here\nval paramIsFalse = false\nval x, y = Bool()           // Define two combinational signals\nval result = UInt(8 bits)   // Define a combinational signal\n\nresult := 1\nwhen(x) {\n  result := 2\n  when(y) {\n    result := 3\n  }\n}\nif(paramIsFalse) {          // This assignment should win as it is last, but it was never elaborated\n  result := 4               //  into hardware due to the use of if() and it evaluating to false at the time\n}                           //  of elaboration.  The three := assignments above are elaborated into hardware.\n```\n\n----------------------------------------\n\nTITLE: Incorrect Hardware Bool as Construction Parameter in SpinalHDL (Scala)\nDESCRIPTION: This code demonstrates the incorrect way of using a hardware `Bool` as a construction parameter for a SpinalHDL Component. Doing so causes hierarchy violations because hardware signals shouldn't influence the component's structure at elaboration time. The activeHigh parameter of type Bool should not be used.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/interaction.rst#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n// This is wrong, because you can't use a hardware Bool as construction parameter. (It will cause hierarchy violations.)\nclass SubComponent(activeHigh: Bool) extends Component {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a State Machine - Style A - Scala\nDESCRIPTION: This example demonstrates defining a state machine in SpinalHDL using style A, which defines states inline with their logic. It utilizes the StateMachine class from spinal.lib.fsm, defines states stateA, stateB, and stateC, and uses whenIsActive, onEntry, onExit, and goto to define transitions and actions within each state. The FSM includes a counter and an output signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/fsm.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.lib.fsm._\n\nclass TopLevel extends Component {\n  val io = new Bundle {\n    val result = out Bool()\n  }\n\n  val fsm = new StateMachine {\n    val counter = Reg(UInt(8 bits)) init(0)\n    io.result := False\n\n    val stateA : State = new State with EntryPoint {\n      whenIsActive(goto(stateB))\n    }\n    val stateB : State = new State {\n      onEntry(counter := 0)\n      whenIsActive {\n        counter := counter + 1\n        when(counter === 4) {\n          goto(stateC)\n        }\n      }\n      onExit(io.result := True)\n    }\n    val stateC : State = new State {\n      whenIsActive(goto(stateA))\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Pipeline Builder Usage Scala\nDESCRIPTION: This snippet demonstrates how to use the `Builder` to generate the hardware for a pipeline, given a list of links connecting the nodes.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\n // Let's define 3 Nodes for our pipeline\n      val n0, n1, n2 = Node()\n\n      // Let's connect those nodes by using simples registers\n      val s01 = StageLink(n0, n1)\n      val s12 = StageLink(n1, n2)\n\n      // Let's ask the builder to generate all the required hardware\n      Builder(s01, s12)\n```\n\n----------------------------------------\n\nTITLE: MemoryAddress Bundle with Implicit Parameter (Error)\nDESCRIPTION: This code shows an example where an implicit parameter is used in a Bundle. Cloning fails because the implicit parameter is not automatically propagated during the cloning process.  The example triggers the error within the DebugMemory component during RegNext assignment.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/spinal_cant_clone.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase class Xlen(val xlen: Int) {}\n\ncase class MemoryAddress()(implicit xlenConfig: Xlen) extends Bundle {\n    val address = UInt(xlenConfig.xlen bits)\n}\n\nclass DebugMemory(implicit config: Xlen) extends Component {\n    val io = new Bundle {\n        val inputAddress = in(MemoryAddress())\n    }   \n\n    val someAddress = RegNext(io.inputAddress) // -> ERROR *****************************\n}\n```\n\n----------------------------------------\n\nTITLE: SpinalHDL Configuration Object\nDESCRIPTION: This SpinalHDL code presents the use of configuration objects for defining complex hardware parameters.  It demonstrates how to create a 'CoreConfig' object with various settings and add plugins for extending functionality.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\n   val coreConfig = CoreConfig(\n     pcWidth = 32,\n     addrWidth = 32,\n     startAddress = 0x00000000,\n     regFileReadyKind = sync,\n     branchPrediction = dynamic,\n     bypassExecute0 = true,\n     bypassExecute1 = true,\n     bypassWriteBack = true,\n     bypassWriteBackBuffer = true,\n     collapseBubble = false,\n     fastFetchCmdPcCalculation = true,\n     dynamicBranchPredictorCacheSizeLog2 = 7\n   )\n\n   // The CPU has a system of plugins which allows adding new features into the core.\n   // Those extensions are not directly implemented in the core, but are kind of an additive logic patch defined in a separate area.\n   coreConfig.add(new MulExtension)\n   coreConfig.add(new DivExtension)\n   coreConfig.add(new BarrelShifterFullExtension)\n\n   val iCacheConfig = InstructionCacheConfig(\n     cacheSize = 4096,\n     bytePerLine = 32,\n     wayCount = 1,  // Can only be one for the moment\n     wrappedMemAccess = true,\n     addressWidth = 32,\n     cpuDataWidth = 32,\n     memDataWidth = 32\n   )\n\n   new RiscvCoreAxi4(\n     coreConfig = coreConfig,\n     iCacheConfig = iCacheConfig,\n     dCacheConfig = null,\n     debug = debug,\n     interruptCount = interruptCount\n   )\n```\n\n----------------------------------------\n\nTITLE: Conditional Assignment - Scala\nDESCRIPTION: This example demonstrates how to conditionally assign a value to a signal to avoid the assignment overlap error.  The second assignment to 'a' is now within a `when` block, ensuring it only occurs under specific conditions. This resolves the overlap issue by making the assignments mutually exclusive.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/assignment_overlap.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val a = UInt(8 bits)\n  a := 42\n  when(something) {\n    a := 66\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating SDRAM Controller Scala\nDESCRIPTION: This code instantiates the AXI4Shared SDRAM controller. It configures parameters such as AXI data width, AXI ID width, SDRAM layout, SDRAM timings, and CAS latency. The controller utilizes the previously defined layout and timings to properly interface with the SDRAM device.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval sdramCtrl = Axi4SharedSdramCtrl(\n  axiDataWidth = 32,\n  axiIdWidth   = 4,\n  layout       = IS42x320D.layout,\n  timing       = IS42x320D.timingGrade7,\n  CAS          = 3\n)\n```\n\n----------------------------------------\n\nTITLE: Explicitly Blackboxing a Memory in SpinalHDL\nDESCRIPTION: This example shows how to explicitly set a memory to be blackboxed using the generateAsBlackBox() function. This allows specific memories to be blackboxed while potentially leaving others to be inferred.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Sequential logic/memory.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval mem = Mem(Rgb(rgbConfig), 1 << 16)\nmem.generateAsBlackBox()\n```\n\n----------------------------------------\n\nTITLE: Verilog Output of Simple Plugin Example\nDESCRIPTION: This Verilog code is the output generated from the simple plugin example, showing the TopLevel and SubComponent modules. The SubComponent contains a register `StatePlugin_logic_signal` created by `StatePlugin` and incremented by `DriverPlugin`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Misc/service_plugin.rst#_snippet_2\n\nLANGUAGE: verilog\nCODE:\n```\nmodule TopLevel (\n  input  wire          clk,\n  input  wire          reset\n);\n\n\n  SubComponent sub (\n    .clk   (clk  ), // i\n    .reset (reset)  // i\n  );\n\nendmodule\n\nmodule SubComponent (\n  input  wire          clk,\n  input  wire          reset\n);\n\n  reg        [31:0]   StatePlugin_logic_signal; // Created by StatePlugin\n\n  always @(posedge clk) begin\n    StatePlugin_logic_signal <= (StatePlugin_logic_signal + 32'h00000001); // incremented by DriverPlugin\n  end\nendmodule\n```\n\n----------------------------------------\n\nTITLE: Specifying Assumptions During Reset - Scala\nDESCRIPTION: This example shows how to use `ClockDomain.current.duringReset` to specify assumptions that should hold true during the reset period. This allows for specifying constraints on signal values while the system is being reset.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Formal verification/index.rst#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nClockDomain.current.duringReset {\n  assume(rawrrr === 0)\n  assume(wuff === 3)\n}\n```\n\n----------------------------------------\n\nTITLE: Running SpinalHDL Development Container with Podman/Docker\nDESCRIPTION: This command runs a SpinalHDL development container using Podman (or Docker). It mounts the current directory as a workspace within the container, allowing access to project files. This provides a consistent environment for SpinalHDL development and CI regression testing.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Install and setup.rst#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\npodman run -v .:/workspace -it ghcr.io/spinalhdl/docker:master\n```\n\n----------------------------------------\n\nTITLE: Enum Definition and Usage in Scala\nDESCRIPTION: This code demonstrates how to define and use an Enum (enumeration) in SpinalHDL.  It shows defining the enumeration type and instantiating a signal to store the encoded value. The 'import' statement simplifies the enumeration usage.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/types.rst#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nobject UartCtrlTxState extends SpinalEnum { // Or SpinalEnum(defaultEncoding=encodingOfYourChoice)\n     val sIdle, sStart, sData, sParity, sStop = newElement()\n   }\n\n   val stateNext = UartCtrlTxState() // Or UartCtrlTxState(encoding=encodingOfYouChoice)\n   stateNext := UartCtrlTxState.sIdle\n\n   // You can also import the enumeration to have the visibility on its elements\n   import UartCtrlTxState._\n   stateNext := sIdle\n```\n\n----------------------------------------\n\nTITLE: Accessing internal signals with simPublic (alternative)\nDESCRIPTION: This code shows an alternative way to access internal signals of a SpinalHDL component within the simulation by using the `simPublic()` tag after component instantiation. This is an alternative to defining `simPublic()` in the hardware definition. Dependencies include SpinalHDL core and sim libraries.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/signal.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject SimAccessSubSignal {\n  import spinal.core.sim._\n  class TopLevel extends Component {\n    val counter = Reg(UInt(8 bits)) init(0)\n    counter := counter + 1\n  }\n\n  def main(args: Array[String]) {\n    SimConfig.compile {\n      val dut = new TopLevel\n      dut.counter.simPublic()     // Call simPublic() here\n      dut\n    }.doSim{dut =>\n      dut.clockDomain.forkStimulus(10)\n\n      for(i <- 0 to 3) {\n        dut.clockDomain.waitSampling()\n        println(dut.counter.toInt)\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implicit Return in Scala Function\nDESCRIPTION: This example demonstrates Scala's implicit return feature.  The function `sumBiggerThanZero` returns the result of the last expression evaluated, `(a + b) > 0`, without explicitly using the `return` keyword. This is a common Scala convention.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef sumBiggerThanZero(a: Float, b: Float): Boolean = {\n  (a + b) > 0\n}\n```\n\n----------------------------------------\n\nTITLE: Instance Creation (Scala)\nDESCRIPTION: Creates instances of classes `Fifo` and `Bits`. Shows proper naming convention where the instances start with a lowercase letter. It demonstrates how to instantiate a FIFO component and a register.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/coding_conventions.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval fifo   = new Fifo()\n   val buffer = Reg(Bits(8 bits))\n```\n\n----------------------------------------\n\nTITLE: MuxListDc Example - Scala\nDESCRIPTION: This SpinalHDL code snippet uses `muxListDc` which automatically adds a default case if needed. This is useful for generic width code where a default may not always be required.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/latch_detected.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval u1 = UInt(1 bit)\n// automatically adds default if needed\nu1.muxListDc(Seq(0 -> True))\n```\n\n----------------------------------------\n\nTITLE: Configuring SBT to use Local SpinalHDL\nDESCRIPTION: Configures the sbt build file to use a local SpinalHDL clone as a dependency.  It defines `ProjectRef` entries that point to the cloned SpinalHDL directory, and adds the `idslplugin` to `scalacOptions` to ensure the SpinalHDL plugin is invoked during compilation, preventing scope violation errors.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/howotuselocalspinalclone.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nThisBuild / version := \"1.0\"              // change as needed\nThisBuild / scalaVersion := \"2.12.18\"     // change as needed\nThisBuild / organization := \"org.example\" // change as needed\n\nval spinalRoot = file(\"/somewhere/SpinalHDL\")\nlazy val spinalIdslPlugin = ProjectRef(spinalRoot, \"idslplugin\")\nlazy val spinalSim = ProjectRef(spinalRoot, \"sim\")\nlazy val spinalCore = ProjectRef(spinalRoot, \"core\")\nlazy val spinalLib = ProjectRef(spinalRoot, \"lib\")\n\nlazy val projectname = (project in file(\".\"))\n.settings(\n   Compile / scalaSource := baseDirectory.value / \"hw\" / \"spinal\",\n).dependsOn(spinalIdslPlugin, spinalSim, spinalCore, spinalLib)\n\nscalacOptions += (spinalIdslPlugin / Compile / packageBin / artifactPath).map { file =>\n  s\"-Xplugin:${file.getAbsolutePath}\"\n}.value\n\nfork := true\n```\n\n----------------------------------------\n\nTITLE: AHB-Lite3 Bus Definition in SpinalHDL\nDESCRIPTION: This code defines the AHB-Lite3 bus as a Scala case class in SpinalHDL. It specifies the various signals that constitute the AHB-Lite3 interface, including address, control, data, and transfer response signals. The `asMaster` method defines the direction (input/output) of the signals when the bus is used as a master.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/amba3/ahblite3.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class AhbLite3(config: AhbLite3Config) extends Bundle with IMasterSlave {\n     //  Address and control\n     val HADDR = UInt(config.addressWidth bits)\n     val HSEL = Bool()\n     val HREADY = Bool()\n     val HWRITE = Bool()\n     val HSIZE = Bits(3 bits)\n     val HBURST = Bits(3 bits)\n     val HPROT = Bits(4 bits)\n     val HTRANS = Bits(2 bits)\n     val HMASTLOCK = Bool()\n\n     //  Data\n     val HWDATA = Bits(config.dataWidth bits)\n     val HRDATA = Bits(config.dataWidth bits)\n\n     //  Transfer response\n     val HREADYOUT = Bool()\n     val HRESP = Bool()\n\n     override def asMaster(): Unit = {\n       out(HADDR,HWRITE,HSIZE,HBURST,HPROT,HTRANS,HMASTLOCK,HWDATA,HREADY,HSEL)\n       in(HREADYOUT,HRESP,HRDATA)\n     }\n   }\n```\n\n----------------------------------------\n\nTITLE: Implement JTAG Write Instruction\nDESCRIPTION: Implements a JTAG instruction that writes to a register and also reads its current value. It utilizes a shift register and captures the initial value during the CAPTURE_DR state. During the SHIFT_DR state, data is shifted in from TDI to update the register. Then the current value of register is outputted via TDO.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Advanced ones/jtag.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nclass JtagInstructionWrite(owner: JtagTapAccess, instructionId: Bits, val write: Bits) extends JtagInstruction(owner, instructionId) {\n  Component.current.addPrePopTask(() => {\n    val fsm = owner.getFsmState()\n\n    val shiftRegister = Reg(Bits(write.getWidth() bits)) init(0)\n    val shiftRegisterNext = Bits(write.getWidth() bits)\n    shiftRegister := shiftRegisterNext\n\n    when(fsm === JtagState.CAPTURE_DR) {\n      shiftRegisterNext := write\n    } otherwise when(fsm === JtagState.SHIFT_DR) {\n      shiftRegisterNext := (owner.getTdi() ## shiftRegister(write.getWidth() - 1 downto 1))\n    }\n    when(fsm === JtagState.UPDATE_DR) {\n      write := shiftRegister\n    }\n\n    owner.getTdo().write(shiftRegister.lsb)\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Plugin Example in Scala\nDESCRIPTION: This snippet illustrates a simple example with a SubComponent composed of two plugins: StatePlugin and DriverPlugin. StatePlugin creates a register, and DriverPlugin increments it. It showcases the use of `PluginHost` and `FiberPlugin` for modular design.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Misc/service_plugin.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core._\nimport spinal.lib.misc.plugin._\n\n// Let's define a Component with a PluginHost instance\nclass SubComponent extends Component {\n  val host = new PluginHost()\n}\n\n// Let's define a plugin which create a register\nclass StatePlugin extends FiberPlugin {\n  // during build new Area { body } will run the body of code in the Fiber build phase, in the context of the PluginHost\n  val logic = during build new Area {\n    val signal = Reg(UInt(32 bits))\n  }\n}\n\n// Let's define a plugin which will make the StatePlugin's register increment\nclass DriverPlugin extends FiberPlugin {\n  // We define how to get the instance of StatePlugin.logic from the PluginHost. It is a lazy val, because we can't evaluate it until the plugin is bound to its host.\n  lazy val sp = host[StatePlugin].logic.get\n\n  val logic = during build new Area {\n    // Generate the increment hardware\n    sp.signal := sp.signal + 1\n  }\n}\n\nclass TopLevel extends Component {\n  val sub = new SubComponent()\n\n  // Here we create plugins and embed them in sub.host\n  new DriverPlugin().setHost(sub.host)\n  new StatePlugin().setHost(sub.host)\n}\n```\n\n----------------------------------------\n\nTITLE: APB Interface with Master/Slave Functions in Scala\nDESCRIPTION: This example extends the APB interface with functions to define it as either a master or slave interface. The `asMaster` function sets the direction of the signals. The `asSlave` function flips the direction using `flip()`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/types.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core._\n\n   case class APBConfig(addressWidth: Int,\n                        dataWidth: Int,\n                        selWidth : Int,\n                        useSlaveError : Boolean)\n\n   class APB(val config: APBConfig) extends Bundle {\n     val PADDR      = UInt(config.addressWidth bits)\n     val PSEL       = Bits(config.selWidth bits)\n     val PENABLE    = Bool()\n     val PREADY     = Bool()\n     val PWRITE     = Bool()\n     val PWDATA     = Bits(config.dataWidth bits)\n     val PRDATA     = Bits(dataWidth bits)\n     val PSLVERROR  = if(config.useSlaveError) Bool() else null\n\n     def asMaster(): this.type = {\n       out(PADDR,PSEL,PENABLE,PWRITE,PWDATA)\n       in(PREADY,PRDATA)\n       if(config.useSlaveError) in(PSLVERROR)\n       this\n     }\n\n     def asSlave(): this.type = this.asMaster().flip() // Flip reverse all in out configuration.\n   }\n\n   // Example of usage\n   val apbConfig = APBConfig(addressWidth = 8,dataWidth = 32,selWidth = 4,useSlaveError = false)\n   val io = new Bundle {\n     val masterBus = APB(apbConfig).asMaster()\n     val slaveBus = APB(apbConfig).asSlave()\n   }\n```\n\n----------------------------------------\n\nTITLE: Continuous HDL generation with SBT\nDESCRIPTION: This code snippet demonstrates how to enable continuous HDL code generation using the `~` prefix with the `runMain` command in SBT. This triggers recompilation and code generation whenever source files are modified. This feature allows for real-time feedback during development.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/SBT.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n~ runMain projectname.MyTopLevelVerilog\n```\n\n----------------------------------------\n\nTITLE: Connecting Interrupts and Debug Resets in Scala\nDESCRIPTION: This code snippet illustrates the connections between components, particularly interrupts and debug resets. Interrupts from the UART and Timer are connected to the core, and the debug reset signals are handled.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\ncore.io.interrupt(0) := uartCtrl.io.interrupt\ncore.io.interrupt(1) := timerCtrl.io.interrupt\n\ncore.io.debugResetIn := resetCtrl.axiReset\nwhen(core.io.debugResetOut) {\n  resetCtrl.coreResetUnbuffered := True\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring VGA Controller Scala\nDESCRIPTION: This code defines the configuration for the VGA controller, including parameters such as AXI address width, AXI data width, burst length, frame size, FIFO size, RGB configuration, and VGA clock domain. These settings define the memory interface and the video output format.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nval vgaCtrlConfig = Axi4VgaCtrlGenerics(\n  axiAddressWidth = 32,\n  axiDataWidth    = 32,\n  burstLength     = 8,           // In Axi words\n  frameSizeMax    = 2048*1512*2, // In byte\n  fifoSize        = 512,         // In axi words\n  rgbConfig       = RgbConfig(5,6,5),\n  vgaClock        = vgaClockDomain\n)\n```\n\n----------------------------------------\n\nTITLE: Updating MSYS2 and Installing Development Tools\nDESCRIPTION: This snippet shows how to update MSYS2 and install necessary development tools like base-devel, toolchain, iverilog, ghdl, and git using the pacman package manager. It also downloads and installs a specific version of Verilator. This configuration is used in a Windows environment with MSYS2.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Install and setup.rst#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\npacman -Syuu\n# will (request) close down terminal\n# open 'MSYS2 MINGW64' from start menu\npacman -Syuu\npacman -S --needed base-devel mingw-w64-x86_64-toolchain mingw-w64-x86_64-iverilog mingw-w64-x86_64-ghdl-llvm git \ncurl -O https://repo.msys2.org/mingw/mingw64/mingw-w64-x86_64-verilator-4.228-1-any.pkg.tar.zst\npacman -U mingw-w64-x86_64-verilator-4.228-1-any.pkg.tar.zst\n```\n\n----------------------------------------\n\nTITLE: SpinalHDL Width Mismatch Error for Operators (Text)\nDESCRIPTION: This text snippet represents the error message generated by SpinalHDL when a width mismatch occurs during a bitwise OR operation. It displays the widths of the left and right operands. This text is output when compiling the above scala code.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/width_mismatch.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nWIDTH MISMATCH on (UInt | UInt)[8 bits]\n- Left  operand : (toplevel/a :  UInt[8 bits])\n- Right operand : (toplevel/b :  UInt[4 bits])\n  at\n  ***\n  Source file location of the OR operator via the stack trace\n  ***\n```\n\n----------------------------------------\n\nTITLE: Verilog FIFO Logic Implementation\nDESCRIPTION: This Verilog code snippet implements a FIFO (First-In, First-Out) buffer's logic, including signal assignments and register updates based on clock and reset signals. It demonstrates how data is transferred and controlled within the FIFO structure.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_16\n\nLANGUAGE: verilog\nCODE:\n```\n      assign source_fifo_io_pop_ready = ((1'b1 && (! source_fifo_io_pop_m2sPipe_valid)) || source_fifo_io_pop_m2sPipe_ready);\n      assign source_fifo_io_pop_m2sPipe_valid = source_fifo_io_pop_rValid;\n      assign source_fifo_io_pop_m2sPipe_payload = source_fifo_io_pop_rData;\n      assign sink_valid = source_fifo_io_pop_m2sPipe_valid;\n      assign source_fifo_io_pop_m2sPipe_ready = sink_ready;\n      assign sink_payload = source_fifo_io_pop_m2sPipe_payload;\n      always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n          source_fifo_io_pop_rValid <= 1'b0;\n        end else begin\n          if(source_fifo_io_pop_ready)begin\n            source_fifo_io_pop_rValid <= source_fifo_io_pop_valid;\n          end\n        end\n      end\n\n      always @ (posedge clk) begin\n        if(source_fifo_io_pop_ready)begin\n          source_fifo_io_pop_rData <= source_fifo_io_pop_payload;\n        end\n      end\n    endmodule\n```\n\n----------------------------------------\n\nTITLE: Conditional Signal Assignment in SpinalHDL (Scala)\nDESCRIPTION: This code snippet demonstrates how to conditionally assign values to signals within a `when` block in SpinalHDL. The `valid` signal is set to `True` and the `value` signal is set to the value of `red` when the `cond` signal is `True`. Due to the last statement wins rule, `red` value will be assigned when `cond` is true.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/types.rst#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nval cond = in Bool()\nval red = in UInt(4 bits)\n...\nval valid = False          // Bool signal which is by default assigned with False\nval value = U\"0100\"        // UInt signal of 4 bits which is by default assigned with 4\nwhen(cond) {\n  valid := True\n  value := red\n}\n```\n\n----------------------------------------\n\nTITLE: Verilog Display Message\nDESCRIPTION: This Verilog code is the result of the SpinalHDL 'report' function. It demonstrates how SpinalHDL translates the report statement into a display message for simulation debugging.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/report.rst#_snippet_1\n\nLANGUAGE: verilog\nCODE:\n```\n$display(\"NOTE miaou %s%x%s%x\", a_string, b, c_string, d);\n```\n\n----------------------------------------\n\nTITLE: Wave Capture Windowing\nDESCRIPTION: This snippet showcases wave capture windowing by disabling wave recording, waiting for a specific time, and then re-enabling it. This allows for capturing the wave around a specific region of interest.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/bootstraps.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndisableSimWave()\ndelayed(timeFromWhichIWantToCapture)(enableSimWave())\n```\n\n----------------------------------------\n\nTITLE: Corrected is statement - SpinalHDL - Scala\nDESCRIPTION: This Scala code presents a corrected SpinalHDL component with a switch statement that avoids the unreachable code error by removing the duplicated 'is' statement.  The 'sel' signal determines the value assigned to the 'result' signal, and each case is uniquely defined.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/unreachable_is_statement.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val sel = UInt(2 bits)\n  val result = UInt(4 bits)\n  switch(sel) {\n    is(0){ result := 4 }\n    is(1){ result := 6 }\n    is(2){ result := 8 }\n    is(3){ result := 9 }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Function Call with Named Arguments in Scala\nDESCRIPTION: This demonstrates calling a Scala function with named arguments.  By specifying `a = 2.3f` and `b = 5.4f`, the arguments are passed to the `sumBiggerThanZero` function regardless of their original order in the function definition. This improves readability, especially for functions with many parameters.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nsumBiggerThanZero(\n  a = 2.3f,\n  b = 5.4f\n)\n```\n\n----------------------------------------\n\nTITLE: Applying ClockDomainTag to BlackBox Ports in SpinalHDL (Scala)\nDESCRIPTION: This code illustrates how to apply `ClockDomainTag` to specific ports or the entire bundle of a SpinalHDL BlackBox to specify their clock domain, enabling clock crossing checks. It provides examples of applying the tag to individual ports, a bundle, and all ports using `setIoCd()` in SpinalHDL 1.10.2.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/blackbox.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass DemoBlackbox extends BlackBox {\n  val io = new Bundle {\n    val clk, rst = in Bool()\n    val a = in Bool()\n    val b = out Bool()\n  }\n  mapCurrentClockDomain(io.clk, io.rst)\n  ClockDomainTag(this.clockDomain)(\n    io.a,\n    io.b\n  )  \n}\n\nval io = new Bundle {\n  val clk, rst = in Bool()\n  val a = in Bool()\n  val b = out Bool()\n}\nClockDomainTag(this.clockDomain)(io)\n\nval io = new Bundle {\n  val clk, rst = in Bool()\n  val a = in Bool()\n  val b = out Bool()\n}\nsetIoCd()\n```\n\n----------------------------------------\n\nTITLE: Overlapping Assignment Example - Scala\nDESCRIPTION: This example demonstrates a scenario where SpinalHDL detects an assignment overlap.  The second assignment to signal 'a' overwrites the first one without any conditional logic. This triggers an error during elaboration. It showcases the default behavior where SpinalHDL prevents such overwrites to avoid unintended data loss.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/assignment_overlap.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val a = UInt(8 bits)\n  a := 42\n  a := 66 // Erase the a := 42 assignment\n}\n```\n\n----------------------------------------\n\nTITLE: Default Argument Values in Scala Function\nDESCRIPTION: This example demonstrates how to specify default values for function arguments in Scala. If the caller does not provide a value for `b`, it defaults to `0.0f`. The `sumBiggerThanZero` function adds `a` and `b` and checks if the result is greater than zero.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ndef sumBiggerThanZero(a: Float, b: Float = 0.0f) = {\n  (a + b) > 0\n}\n```\n\n----------------------------------------\n\nTITLE: RGB to Gray Conversion using SpinalHDL and Scala functions\nDESCRIPTION: This snippet demonstrates how to convert an RGB color to grayscale using Scala functions within SpinalHDL. It defines a `coef` function to multiply a UInt by a Float value. The inputs are UInt (8 bits) for r, g, and b, and the output is the grayscale value as a UInt.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/miscelenea/core/core_components.rst#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n// Input RGB color\n   val r,g,b = UInt(8 bits)\n\n   // Define a function to multiply a UInt by a scala Float value.\n   def coef(value : UInt,by : Float) : UInt = (value * U((255*by).toInt,8 bits) >> 8)\n\n   // Calculate the gray level\n   val gray = coef(r,0.3f) +\n              coef(g,0.4f) +\n              coef(b,0.3f)\n```\n\n----------------------------------------\n\nTITLE: Type Casting with Bits in SpinalHDL (Scala)\nDESCRIPTION: This code snippet demonstrates how to cast between Bits, SInt, UInt, and Bool types in SpinalHDL using the asSInt, asBools, and B() methods. It also shows how to resize the Bits during casting.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bits.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// cast a Bits to SInt\nval mySInt = myBits.asSInt\n\n// create a Vector of bool\nval myVec = myBits.asBools\n\n// Cast a SInt to Bits\nval myBits = B(mySInt)\n\n// Cast the same SInt to Bits but resize to 3 bits\n//  (will expand/truncate as necessary, retaining LSB)\nval myBits = B(mySInt, 3 bits)\n```\n\n----------------------------------------\n\nTITLE: Corrected IO Bundle Definition - Scala\nDESCRIPTION: This code demonstrates the correct way to define an IO bundle in SpinalHDL by explicitly specifying the direction of the signal 'a' as 'in'. This satisfies SpinalHDL's requirement for explicit direction declarations within IO bundles and resolves the error.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/iobundle.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass TopLevel extends Component {\n  val io = new Bundle {\n    val a = in UInt(8 bits)  // provide 'in' direction declaration\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Composite in Bundle's Function (Scala)\nDESCRIPTION: Demonstrates the use of Composite in a Bundle's function, specifically within the spinal.lib.Stream class. This example showcases how Composites help preserve names when implementing Bundle utilities. The example includes Stream.queue and Stream.m2sPipe functions.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nclass Stream[T <: Data](val payloadType :  HardType[T]) extends Bundle {\n  val valid   = Bool()\n  val ready   = Bool()\n  val payload = payloadType()\n\n  def queue(size: Int): Stream[T] = new Composite(this) {\n    val fifo = new StreamFifo(payloadType, size)\n    fifo.io.push << self    // 'self' refers to the Composite construction argument ('this' in\n                            //  the example). It avoids having to do a boring 'Stream.this'\n  }.fifo.io.pop\n\n  def m2sPipe(): Stream[T] = new Composite(this) {\n    val m2sPipe = Stream(payloadType)\n\n    val rValid = RegInit(False)\n    val rData = Reg(payloadType)\n\n    self.ready := (!m2sPipe.valid) || m2sPipe.ready\n\n    when(self.ready) {\n      rValid := self.valid\n      rData := self.payload\n    }\n\n    m2sPipe.valid := rValid\n    m2sPipe.payload := rData\n  }.m2sPipe\n}\n```\n\n----------------------------------------\n\nTITLE: Internal Clock with PLL Example in Scala\nDESCRIPTION: This code demonstrates how to create an internal clock domain and assign its clock and reset signals from a PLL.  It instantiates a PLL and connects its output to the clock domain's clock signal. It illustrates how to integrate a custom clock source with SpinalHDL's clock domain management.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nclass InternalClockWithPllExample extends Component {\n  val io = new Bundle {\n    val clk100M = in Bool()\n    val aReset  = in Bool()\n    val result  = out UInt (4 bits)\n  }\n  // myClockDomain.clock will be named myClockName_clk\n  // myClockDomain.reset will be named myClockName_reset\n  val myClockDomain = ClockDomain.internal(\"myClockName\")\n\n  // Instantiate a PLL (probably a BlackBox)\n  val pll = new Pll()\n  pll.io.clkIn := io.clk100M\n\n  // Assign myClockDomain signals with something\n  myClockDomain.clock := pll.io.clockOut\n  myClockDomain.reset := io.aReset || !pll.io.\n\n  // Do whatever you want with myClockDomain\n  val myArea = new ClockingArea(myClockDomain) {\n    val myReg = Reg(UInt(4 bits)) init(7)\n    myReg := myReg + 1\n\n    io.result := myReg\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Type Factory Function in SpinalHDL (Scala)\nDESCRIPTION: This code snippet defines a type factory function `myRgbTypeDef` that returns an Rgb instance with fixed width parameters. It then uses this function to create an Rgb signal, `myRgbFromTypeDef`. This showcases a method of creating reusable type definitions in SpinalHDL using Scala functions.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/interaction.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n// Define a type factory function\ndef myRgbTypeDef = Rgb(5, 6, 5)\n\n// Use that type factory to create an Rgb signal\nval myRgbFromTypeDef = myRgbTypeDef\n```\n\n----------------------------------------\n\nTITLE: Import SpinalHDL core and lib - Scala\nDESCRIPTION: These imports are essential at the beginning of any SpinalHDL Scala file. They provide access to the core functionalities and library components necessary for hardware description using SpinalHDL.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/index.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core._\nimport spinal.lib._\n```\n\n----------------------------------------\n\nTITLE: Bundle Definition (RGB/VGA) in Scala\nDESCRIPTION: This code defines Bundles (data structures) for RGB and VGA signals in SpinalHDL.  It includes defining internal functions (isBlack, isWhite) within the RGB bundle. The VGA bundle demonstrates nesting bundles.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/types.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ncase class RGB(channelWidth : Int) extends Bundle {\n     val red   = UInt(channelWidth bits)\n     val green = UInt(channelWidth bits)\n     val blue  = UInt(channelWidth bits)\n\n     def isBlack : Bool = red === 0 && green === 0 && blue === 0\n     def isWhite : Bool = {\n       val max = U((channelWidth-1 downto 0) -> true)\n       return red === max && green === max && blue === max\n     }\n   }\n\n   case class VGA(channelWidth : Int) extends Bundle {\n     val hsync = Bool()\n     val vsync = Bool()\n     val color = RGB(channelWidth)\n   }\n```\n\n----------------------------------------\n\nTITLE: BusSlaveFactory Primitive Functions - Scala\nDESCRIPTION: This code block defines the primitive abstract functions of the BusSlaveFactory trait in Scala. These functions provide the basic building blocks for interacting with a bus slave, including reading and writing data, and executing actions on read or write events.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/bus_slave_factory_impl.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait BusSlaveFactory  extends Area {\n\n     def busDataWidth : Int\n\n     def read(that : Data,\n              address : BigInt,\n              bitOffset : Int = 0) : Unit\n\n     def write(that : Data,\n               address : BigInt,\n               bitOffset : Int = 0) : Unit\n\n     def onWrite(address : BigInt)(doThat : => Unit) : Unit\n     def onRead (address : BigInt)(doThat : => Unit) : Unit\n\n     def nonStopWrite( that : Data,\n                       bitOffset : Int = 0) : Unit\n\n     // ...\n   }\n```\n\n----------------------------------------\n\nTITLE: Generic Class Definition in Scala\nDESCRIPTION: This demonstrates how to define a generic class in Scala using type parameters. The `Queue` class is parameterized with type `T`, allowing it to hold elements of any type. The type parameter `T` is used in the `push` and `pop` methods.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nclass  Queue[T]() {\n  def push(that: T) : Unit = ...\n  def pop(): T = ...\n}\n```\n\n----------------------------------------\n\nTITLE: Init Statement on Past - Scala\nDESCRIPTION: Demonstrates how to initialize the past value of a signal using the `init` statement within the `past` function. This provides a default value for the signal in the initial cycles.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Formal verification/index.rst#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nwhen(past(enable) init(False)) { ... }\n```\n\n----------------------------------------\n\nTITLE: Installing Formal Verification Tools in MSYS2\nDESCRIPTION: This snippet installs formal verification tools like z3, yices, autotools, and python3-pip using pacman. It also installs the `click` python package with pip.  This is intended for use within an MSYS2 environment on Windows.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Install and setup.rst#_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\npacman -S mingw-w64-x86_64-z3 mingw-w64-x86_64-yices mingw-w64-x86_64-autotools mingw-w64-x86_64-python3-pip\npython3 -m pip install click\n```\n\n----------------------------------------\n\nTITLE: Extending BusIfVisitor in SpinalHDL\nDESCRIPTION: This Scala code snippet defines the `BusIfVisitor` trait, allowing users to extend its functionality to customize register interface documentation generation. It provides callback methods (`begin`, `visit` for different register/FIFO types, and `end`) that are invoked during the register interface traversal. Developers can implement custom logic within these methods to generate documentation in various formats.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\n    // lib/src/main/scala/spinal/lib/bus/regif/BusIfBase.scala\n\n    trait BusIfVisitor {\n      def begin(busDataWidth : Int) : Unit\n      def visit(descr : FifoDescr)  : Unit  \n      def visit(descr : RegDescr)   : Unit\n      def end()                     : Unit\n    }\n```\n\n----------------------------------------\n\nTITLE: Detecting Unassigned Register - Scala\nDESCRIPTION: This code defines a SpinalHDL component with an unassigned register 'a'. When compiled, SpinalHDL will throw an error because 'a' is not assigned a value. 'result' is an output that depends on 'a'.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/unassigned_register.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass TopLevel extends Component {\n  val result = out(UInt(8 bits))\n  val a = Reg(UInt(8 bits))\n  result := a\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UART Configuration Enums in Scala\nDESCRIPTION: This code snippet defines the ParityType and StopBitCount enumerations, which are used to configure the parity and stop bits of the UART communication. ParityType includes NONE, EVEN, and ODD options. StopBitCount includes ONE and TWO options. These enums are used within the UartCtrlFrameConfig to specify the desired UART frame format.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/uart.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject ParityType extends SpinalEnum(binarySequential) {\n  val NONE, EVEN, ODD = newElement()\n}\n\nobject StopBitCount extends SpinalEnum(binarySequential) {\n  val ONE, TWO = newElement()\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning SpinalHDL Git Repository (Unreleased Version)\nDESCRIPTION: This command clones the SpinalHDL repository from GitHub, specifically targeting the 'dev' branch (or another specified branch) with a shallow clone (depth 1) to avoid downloading the entire history. The cloned repository can then be used for local publishing.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Introduction/faq.rst#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit clone --depth 1 -b dev https://github.com/SpinalHDL/SpinalHDL.git\ncd SpinalHDL\n```\n\n----------------------------------------\n\nTITLE: Int/Long/BigInt to String Conversion in Scala\nDESCRIPTION: Illustrates how to convert Int, Long, and BigInt values to their corresponding hexadecimal, octal, and binary string representations using hexString(), octString(), and binString() methods respectively. This functionality relies on the `spinal.core.lib._` import. It provides example usages for clarity.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/binarySystem.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core.lib._\n\n   $: \"32FF190\".asHex.hexString()\n   \"32FF190\"\n   $: \"123456777777700\".asOct.octString() \n   \"123456777777700\"\n   $: \"10100011100111111\".asBin.binString() \n   \"10100011100111111\"\n   $: 32323239988L.hexString()\n   7869d8034\n   $: 3239988L.octString()\n   14270064\n   $: 34.binString()\n   100010\n```\n\n----------------------------------------\n\nTITLE: Conditional Bit Setting - Scala\nDESCRIPTION: This code demonstrates setting all bits of a SInt signal to true based on a condition involving the bitwise AND reduction of a UInt signal. It leverages SpinalHDL's when statement and the setAll() method.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Int.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// Set all bits of b to True when all bits of a are True\nwhen(a.andR) { b.setAll() }\n```\n\n----------------------------------------\n\nTITLE: Verilog Output of Chained Composites\nDESCRIPTION: Shows the Verilog generated from the chained Composites example. The signals are named value_comparator and value_comparator_inverter, demonstrating the nested namespace created by chaining Composites. This provides a clear example of complex name generation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_12\n\nLANGUAGE: verilog\nCODE:\n```\nmodule MyComponent (\n  input      [7:0]    value,\n  output              result\n);\n  wire                value_comparator;\n  wire                value_comparator_inverter;\n\n  assign value_comparator = (value == 8'h0);\n  assign value_comparator_inverter = (! value_comparator);\n  assign result = value_comparator_inverter;\n\nendmodule\n```\n\n----------------------------------------\n\nTITLE: PLL BlackBox VHDL Component\nDESCRIPTION: Defines the VHDL component corresponding to the PLL BlackBox. This VHDL code describes the interface of the PLL component, including the clock input, clock output, and lock status signals. It serves as a representation of the PLL's hardware interface for integration into larger VHDL designs.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Simple ones/pll_resetctrl.rst#_snippet_2\n\nLANGUAGE: VHDL\nCODE:\n```\ncomponent PLL is\n  port(\n    clkIn    : in std_logic;\n    clkOut   : out std_logic;\n    isLocked : out std_logic\n  );\nend component;\n```\n\n----------------------------------------\n\nTITLE: Removing IO Prefix in SpinalHDL BlackBox (Scala)\nDESCRIPTION: This code shows how to use the `noIoPrefix()` function within a SpinalHDL BlackBox to prevent the automatic addition of the \"io_\" prefix to the names of the IO signals. This helps to maintain cleaner signal names in the generated HDL code.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/blackbox.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n// Define the Ram as a BlackBox\nclass Ram_1w_1r(wordWidth: Int, wordCount: Int) extends BlackBox {\n\n  val generic = new Generic {\n    val wordCount = Ram_1w_1r.this.wordCount\n    val wordWidth = Ram_1w_1r.this.wordWidth\n  }\n\n  val io = new Bundle {\n    val clk = in Bool()\n\n    val wr = new Bundle {\n      val en   = in Bool()\n      val addr = in UInt (log2Up(_wordCount) bits)\n      val data = in Bits (_wordWidth bits)\n    }\n    val rd = new Bundle {\n      val en   = in Bool()\n      val addr = in UInt (log2Up(_wordCount) bits)\n      val data = out Bits (_wordWidth bits)\n    }\n  }\n\n  noIoPrefix()\n\n  mapCurrentClockDomain(clock=io.clk)\n}\n```\n\n----------------------------------------\n\nTITLE: Using fixTo Function for Fixpoint Conversion in SpinalHDL\nDESCRIPTION: This code snippet shows how to use the fixTo function for fixpoint conversion in SpinalHDL. It allows for specifying the section of bits to keep, the rounding type, and whether to apply symmetry.  The function automates carry bit alignment and bit width calculation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Int.rst#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval A  = SInt(16 bits)\nval B  = A.fixTo(10 downto 3) // default RoundType.ROUNDTOINF, sym = false\nval B  = A.fixTo( 8 downto 0, RoundType.ROUNDUP)\nval B  = A.fixTo( 9 downto 3, RoundType.CEIL,       sym = false)\nval B  = A.fixTo(16 downto 1, RoundType.ROUNDTOINF, sym = true )\nval B  = A.fixTo(10 downto 3, RoundType.FLOOR) // floor 3 bit, sat 5 bit @ highest\nval B  = A.fixTo(20 downto 3, RoundType.FLOOR) // floor 3 bit, expand 2 bit @ highest\n```\n\n----------------------------------------\n\nTITLE: RegFileIntr Example\nDESCRIPTION: An incomplete example showing the creation of a `RegFileIntrExample` component.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nclass RegFileIntrExample extends Component {\n   val io = new Bundle {\n     val apb = slave(Apb3(Apb3Config(16,32)))\n     val int_pulse0, int_pulse1, int_pulse2, int_pulse3 = in Bool()\n```\n\n----------------------------------------\n\nTITLE: HTML Meta Refresh Redirection\nDESCRIPTION: This HTML snippet implements a meta refresh redirection. It instructs the browser to automatically redirect the user to the specified URL after a specified delay (0 seconds in this case). The target URL is the SpinalHDL SpinalDoc library cheatsheet PDF.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Cheatsheets/lib.rst#_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n<head>\n  <!-- HTML meta refresh URL redirection -->\n  <meta http-equiv=\"refresh\"\n  content=\"0; url=http://cdn.rawgit.com/SpinalHDL/SpinalDoc/9bab57d16ecd3fce53cb1de9f12b63fdae97f188/cheatsheet/cheatSheet_lib_oo.pdf\">\n</head>\n```\n\n----------------------------------------\n\nTITLE: Functional Programming Techniques in SpinalHDL (Scala)\nDESCRIPTION: This code illustrates the use of functional programming techniques with SpinalHDL types.  It creates a `Vec` of `Bits` signals, then uses `map` to create a `Vec` of `Bool` signals indicating whether each value is equal to 42.  It then uses `reduce` to create a single `Bool` signal that is true if all values are equal to 42. Finally, it uses zipWithIndex and map to check if the values are equal to their index.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/interaction.rst#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nval values = Vec(Bits(8 bits), 4)\n\nval valuesAre42    = values.map(_ === 42)\nval valuesAreAll42 = valuesAre42.reduce(_ && _)\n\nval valuesAreEqualToTheirIndex = values.zipWithIndex.map{ case (value, i) => value === i }\n```\n\n----------------------------------------\n\nTITLE: StagePipeline Usage Scala\nDESCRIPTION: This snippet illustrates how to use the StagePipeline class to create a simple pipeline with Node -> StageLink -> Node structure. It shows how to insert data at different stages and retrieve results.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\n  // Let's define a few inputs/outputs\n    val a,b = in UInt(8 bits)\n    val result = out(UInt(16 bits))\n\n    // Let's create the pipelining tool.\n    val pip = new StagePipeline\n\n    // Let's insert a and b into the pipeline at stage 0\n    val A = pip(0).insert(a)\n    val B = pip(0).insert(b)\n\n    // Lets insert the sum of A and B into the stage 1 of our pipeline\n    val SUM = pip(1).insert(pip(1)(A) + pip(1)(B))\n    \n    // Clearly, i don't want to say pip(x)(y) on every pipelined thing.\n    // So instead we can create a pip.Area(x) which will provide a scope which work in stage \"x\"\n    val onSquare = new pip.Area(2){\n      val VALUE = insert(SUM * SUM)\n    }\n\n    // Lets assign our output result from stage 3\n    result := pip(3)(onSquare.VALUE)\n\n    // Now that everything is specified, we can build the pipeline\n    pip.build()\n```\n\n----------------------------------------\n\nTITLE: Running All Test Suites with Mill\nDESCRIPTION: This snippet executes all test suites within the SpinalHDL project using Mill. An equivalent SBT command is also provided. This will execute every test case in the project to verify its correctness.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/mill support.rst#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nmill __.test\nsbt test # equivalent alternatives\n```\n\n----------------------------------------\n\nTITLE: Generated Verilog with Area Naming\nDESCRIPTION: Shows the Verilog output from the Area-based namespacing example. The toggle register is named logicA_toggle, demonstrating how the Area prefix is applied to the signal name. This reinforces the impact of Area on naming conventions.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_6\n\nLANGUAGE: verilog\nCODE:\n```\nmodule MyComponent (\n  input               clk,\n  input               reset\n);\n  reg                 logicA_toggle;\n  always @ (posedge clk) begin\n    logicA_toggle <= (! logicA_toggle);\n  end\nendmodule\n```\n\n----------------------------------------\n\nTITLE: Class Definition in Scala\nDESCRIPTION: This code defines a class named `Color` in Scala.  It takes three `Float` values (`r`, `g`, `b`) as constructor parameters, representing red, green, and blue color components. It also defines a method `getGrayLevel` that calculates the gray level of the color.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nclass Color(r: Float, g: Float, b: Float) {\n  def getGrayLevel(): Float = r * 0.3f + g * 0.4f + b * 0.4f\n}\n```\n\n----------------------------------------\n\nTITLE: Stream Join Usage in SpinalHDL (Scala)\nDESCRIPTION: Demonstrates the use of StreamJoin to synchronize multiple input streams.  The output stream only becomes valid when all input streams are valid.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/stream.rst#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval cmdJoin = Stream(Cmd())\ncmdJoin.arbitrationFrom(StreamJoin.arg(cmdABuffer, cmdBBuffer))\n```\n\n----------------------------------------\n\nTITLE: Installing Icarus Verilog on Debian/Ubuntu\nDESCRIPTION: This command installs Icarus Verilog (iverilog), the build-essential package, and the libboost-dev package (containing boost-interprocess) using the apt-get package manager. build-essential provides essential tools for compiling software, libboost-dev is required for shared memory communication, and iverilog is the Icarus Verilog simulator itself.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/install/Icarus Verilog.rst#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nsudo apt-get install build-essential libboost-dev iverilog\n```\n\n----------------------------------------\n\nTITLE: Conditional Assignments (When/Switch) in SpinalHDL\nDESCRIPTION: This snippet illustrates the use of 'when' and 'switch' statements in SpinalHDL for conditional assignments. It shows how to execute different blocks of code based on conditions and how to define new signals within these blocks. Variables `cond`, `value1`, `value2` and `x` are assumed to be previously defined.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/miscelenea/core/core_components.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nwhen(cond1) {\n  // execute when      cond1 is true\n}.elsewhen(cond2) {\n  // execute when (not cond1) and cond2\n}.otherwise {\n  // execute when (not cond1) and (not cond2)\n}\n\nswitch(x) {\n  is(value1) {\n    // execute when x === value1\n  }\n  is(value2) {\n    // execute when x === value2\n  }\n  default {\n    // execute if none of precedent condition meet\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval toto,titi = UInt(4 bits)\nval a,b = UInt(4 bits)\n\nwhen(cond) {\n  val tmp = a + b\n  toto := tmp\n  titi := tmp + 1\n} otherwise {\n  toto := 0\n  titi := 0\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Clock Domains for Sub-systems Scala\nDESCRIPTION: This code defines the clock domains for the different sub-systems of the Pinsec SoC, including the AXI, core, VGA, and JTAG domains. Each clock domain is associated with a clock source, reset signal, and optionally a frequency. This separation allows for independent clocking and reset control for each sub-system.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval axiClockDomain = ClockDomain(\n  clock     = io.axiClk,\n  reset     = resetCtrl.axiReset,\n  frequency = FixedFrequency(50 MHz) // The frequency information is used by the SDRAM controller\n)\n\nval coreClockDomain = ClockDomain(\n  clock = io.axiClk,\n  reset = resetCtrl.coreReset\n)\n\nval vgaClockDomain = ClockDomain(\n  clock = io.vgaClk,\n  reset = resetCtrl.vgaReset\n)\n\nval jtagClockDomain = ClockDomain(\n  clock = io.jtag.tck\n)\n```\n\n----------------------------------------\n\nTITLE: CtrlLink without Node Arguments Scala\nDESCRIPTION: This snippet shows how to create CtrlLinks without explicit Node arguments, which automatically creates the required internal Nodes. It also shows how to connect such CtrlLinks with a StageLink.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nval decode = CtrlLink()\n    val execute = CtrlLink()\n\n    val d2e = StageLink(decode.down, execute.up)\n```\n\n----------------------------------------\n\nTITLE: Conditional Counter Assignment Using a Function (Scala)\nDESCRIPTION: This example demonstrates a function, `setCounterWhen`, that conditionally assigns a value to the 'counter' register based on a boolean condition.  It integrates the conditional check inside the function for better code organization and reusability. It's equivalent to the previous examples in terms of generated hardware.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/rules.rst#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval inc, clear = Bool()\nval counter = Reg(UInt(8 bits))\n\ndef setCounterWhen(cond : Bool,value : UInt): Unit = {\n  when(cond) {\n    counter := value\n  }\n}\n\nsetCounterWhen(cond = inc,   value = counter + 1)\nsetCounterWhen(cond = clear, value = 0)\n```\n\n----------------------------------------\n\nTITLE: Return Type Inference in Scala Function\nDESCRIPTION: This snippet illustrates how Scala can automatically infer the return type of a function.  The return type of `sumBiggerThanZero` is inferred to be `Boolean` based on the result of the expression `(a + b) > 0`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef sumBiggerThanZero(a: Float, b: Float) = {\n  (a + b) > 0\n}\n```\n\n----------------------------------------\n\nTITLE: Vec Initialization and Assignment in Scala\nDESCRIPTION: This code snippet demonstrates how to create and assign values to Vec (vectors) of SInt (signed integers) and mixed UInt (unsigned integers) widths in SpinalHDL. It also shows how to iterate through a Vec to assign values.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/types.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval myVecOfSInt = Vec(SInt(8 bits),2)\n   myVecOfSInt(0) := 2\n   myVecOfSInt(1) := myVecOfSInt(0) + 3\n\n   val myVecOfMixedUInt = Vec(UInt(3 bits), UInt(5 bits), UInt(8 bits))\n\n   val x,y,z = UInt(8 bits)\n   val myVecOf_xyz_ref = Vec(x,y,z)\n   for(element <- myVecOf_xyz_ref) {\n     element := 0   // Assign x,y,z with the value 0\n   }\n   myVecOf_xyz_ref(1) := 3    // Assign y with the value 3\n```\n\n----------------------------------------\n\nTITLE: Object Definition in Scala (Static Context)\nDESCRIPTION: This snippet shows how to define an `object` in Scala, which serves as a singleton instance and provides a static context. The `pow2` function is defined inside the `MathUtils` object, making it a static method accessible through `MathUtils.pow2()`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nobject MathUtils {\n  def pow2(value: Float): Float = value * value\n}\n```\n\n----------------------------------------\n\nTITLE: Shift and Rotate Operators - Scala\nDESCRIPTION: This snippet showcases the shift and rotate operators for UInt signals in SpinalHDL. It highlights the difference between arithmetic and logical shifts, and demonstrates left bit rotation.  getWidth() verifies resulting signal bit widths.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Int.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// Shift\nval arithShift = UInt(8 bits) << 2      // shift left (resulting in 10 bits)\nval logicShift = UInt(8 bits) |<< 2     // shift left (resulting in 8 bits)\nassert(arithShift.getWidth == 10)\nassert(logicShift.getWidth == 8)\n\n// Rotation\nval rotated = UInt(8 bits) rotateLeft 3 // left bit rotation\nassert(rotated.getWidth == 8)\n```\n\n----------------------------------------\n\nTITLE: Compiling Scala code with SBT\nDESCRIPTION: This code snippet shows how to compile the Scala code in an SBT project using the `compile` command. This command fetches dependencies and compiles the project's source files. While compilation is often triggered automatically, this command can be used to force a recompile.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/SBT.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncompile\n```\n\n----------------------------------------\n\nTITLE: VHDL Definition of Asynchronous Dual Port RAM Blackbox\nDESCRIPTION: This code shows the VHDL definition of a standard asynchronous dual-port RAM blackbox used in SpinalHDL. It includes generic parameters for specifying memory characteristics such as word count, word width, and read-under-write policy, and defines the input/output ports for write and read operations.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Sequential logic/memory.rst#_snippet_4\n\nLANGUAGE: ada\nCODE:\n```\n-- Simple asynchronous dual port (1 write port, 1 read port)\ncomponent Ram_1w_1ra is\n  generic(\n    wordCount : integer;\n    wordWidth : integer;\n    technology : string;\n    readUnderWrite : string;\n    wrAddressWidth : integer;\n    wrDataWidth : integer;\n    wrMaskWidth : integer;\n    wrMaskEnable : boolean;\n    rdAddressWidth : integer;\n    rdDataWidth : integer\n  );\n  port(\n    clk : in std_logic;\n    wr_en : in std_logic;\n    wr_mask : in std_logic_vector;\n    wr_addr : in unsigned;\n    wr_data : in std_logic_vector;\n    rd_addr : in unsigned;\n    rd_data : out std_logic_vector\n  );\nend component;\n```\n\n----------------------------------------\n\nTITLE: Bitwise Operators on Bits in SpinalHDL (Scala)\nDESCRIPTION: This code demonstrates bitwise operators (AND, OR, NOT) on Bits signals in SpinalHDL. It also shows logical shift operations and rotation, along with methods to set or clear all bits in a Bits signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bits.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// Bitwise operator\nval a, b, c = Bits(32 bits)\nc := ~(a & b) // Inverse(a AND b)\n\nval all_1 = a.andR // Check that all bits are equal to 1\n\n// Logical shift\nval bits_10bits = bits_8bits << 2  // shift left (results in 10 bits)\nval shift_8bits = bits_8bits |<< 2 // shift left (results in 8 bits)\n\n// Logical rotation\nval myBits = bits_8bits.rotateLeft(3) // left bit rotation\n\n// Set/clear\nval a = B\"8'x42\"\nwhen(cond) {\n  a.setAll() // set all bits to True when cond is True\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Vec Bit Width - Scala\nDESCRIPTION: This code shows how to get the total bit width of a Vec. It calls the widthOf method to calculate the total number of bits required to represent the Vec.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Vec.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n// Create a vector of 2 signed integers\nval vec1 = Vec.fill(2)(SInt(8 bits))\n\nprintln(widthOf(vec1)) // 16\n```\n\n----------------------------------------\n\nTITLE: Concatenation and Resizing in SpinalHDL (Scala)\nDESCRIPTION: This snippet illustrates concatenation and resizing operations in SpinalHDL. It demonstrates how to concatenate signals using `##` and `@@` and resize signals using `resized` and `resize`, which allows to truncate a signal or extend it with zero (for UInt) or with sign (for SInt).\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Int.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nmyBool := mySInt.lsb  // equivalent to mySInt(0)\n\n   // Concatenation\n   val mySInt = mySInt_1 @@ mySInt_1 @@ myBool   \n   val myBits = mySInt_1 ## mySInt_1 ## myBool\n\n   // Resize\n   myUInt_32bits := U\"32'x112233344\"\n   myUInt_8bits  := myUInt_32bits.resized      // automatic resize (myUInt_8bits = 0x44)\n   val lowest_8bits = myUInt_32bits.resize(8)  // resize to 8 bits (myUInt_8bits = 0x44)\n```\n\n----------------------------------------\n\nTITLE: VHDL Process Example\nDESCRIPTION: This VHDL code demonstrates the use of processes for implementing combinatorial and sequential logic, including a register with reset. It showcases the need to explicitly manage clock and reset signals within each process.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_0\n\nLANGUAGE: ada\nCODE:\n```\n     signal mySignal : std_logic;\n     signal myRegister : std_logic_vector(3 downto 0);\n     signal myRegisterWithReset : std_logic_vector(3 downto 0);\n   begin\n     process(cond)\n     begin\n       mySignal <= '0';\n       if cond = '1' then\n         mySignal <= '1';\n       end if;\n     end process;\n\n     process(clk)\n     begin\n       if rising_edge(clk) then\n         if cond = '1' then\n           myRegister <= myRegister + 1;\n         end if;\n       end if;\n     end process;\n\n     process(clk,reset)\n     begin\n       if reset = '1' then\n         myRegisterWithReset <= (others => '0');\n       elsif rising_edge(clk) then\n         if cond = '1' then\n           myRegisterWithReset <= myRegisterWithReset + 1;\n         end if;\n       end if;\n     end process;\n```\n\n----------------------------------------\n\nTITLE: USB OHCI Parameter Definition and Generation in SpinalHDL\nDESCRIPTION: This Scala code snippet demonstrates how to define the parameters for the `UsbOhci` controller and generate the corresponding Verilog code using SpinalHDL. It showcases the configuration of various OHCI parameters such as power switching options, data width, and port configurations. The `SpinalVerilog` function is used to generate the hardware description.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Com/usb_ohci.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject UsbHostGen extends App {\n  val p = UsbOhciParameter(\n    noPowerSwitching = true,\n    powerSwitchingMode = true,\n    noOverCurrentProtection = true,\n    powerOnToPowerGoodTime = 10,\n    dataWidth = 64, // DMA data width, up to 128\n    portsConfig = List.fill(4)(OhciPortParameter()) // 4 Ports\n  )\n\n  SpinalVerilog(new UsbOhciTop(p))\n}\n```\n\n----------------------------------------\n\nTITLE: Assuming Memory Content - Scala\nDESCRIPTION: This example demonstrates how to assume initial memory content and constrain write operations. It assumes that the memory initially doesn't contain the value 1 and that the write operation doesn't write the value 1 to memory.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Formal verification/index.rst#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass DutWithRam extends Component {\n  val ram = Mem.fill(4)(UInt(8 bits))\n  val write = slave(ram.writePort)\n  val read = slave(ram.readAsyncPort)\n}\n\nobject FormalRam extends App {\n  import spinal.core.formal._\n\n  FormalConfig.withBMC(15).doVerify(new Component {\n    val dut = FormalDut(new DutWithRam())\n    assumeInitial(ClockDomain.current.isResetActive)\n\n    // assume that no word in the ram has the value 1\n    for(i <- 0 until dut.ram.wordCount) {\n      assumeInitial(dut.ram(i) =/= 1)\n    }\n\n    // Allow the write anything but value 1 in the ram\n    anyseq(dut.write)\n    clockDomain.withoutReset() { // As the memory write can occur during reset, we need to ensure the assume apply there too\n      assume(dut.write.data =/= 1)\n    }\n\n    // Check that no word in the ram is set to 1\n    anyseq(dut.read.address)\n    assert(dut.read.data =/= 1)\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Main Function Definition in Scala\nDESCRIPTION: This example demonstrates how to define the entry point of a Scala program using an `object` with a `main` function. The `main` function takes an array of strings (`args`) as input and is the starting point of execution. Here, it prints \"Hello world\" to the console.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nobject MyTopLevelMain {\n  def main(args: Array[String]) {\n    println(\"Hello world\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Case Class Definition in Scala\nDESCRIPTION: This code defines a `case class` named `Rectangle` in Scala.  Case classes are a concise way to define data-holding classes and provide several default implementations, like `equals`, `hashCode`, and `toString`.  They are often used for representing immutable data structures.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\ncase class Rectangle(width: Float, height: Float) extends Shape {\n  override def getArea() = width * height\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting Top-Level IO in Scala\nDESCRIPTION: This code snippet shows how top-level IO signals are connected to internal components. These connections are essential for the external world to interact with the internal modules.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nio.gpioA <> axi.gpioACtrl.io.gpio\nio.gpioB <> axi.gpioBCtrl.io.gpio\nio.jtag  <> axi.jtagCtrl.io.jtag\nio.uart  <> axi.uartCtrl.io.uart\nio.sdram <> axi.sdramCtrl.io.sdram\nio.vga   <> axi.vgaCtrl.io.vga\n```\n\n----------------------------------------\n\nTITLE: Incorrect IO Bundle Definition - Scala\nDESCRIPTION: This code demonstrates an incorrect IO bundle definition in SpinalHDL where a signal 'a' within the 'io' bundle is defined without specifying its direction (in/out/inout).  SpinalHDL expects explicit direction declarations for IO signals. This will result in an error during compilation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/iobundle.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass TopLevel extends Component {\n  val io = new Bundle {\n    val a = UInt(8 bits)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Suppressing Unreachable Default Statement Error in Scala\nDESCRIPTION: This code demonstrates how to suppress the \"UNREACHABLE DEFAULT STATEMENT\" error in a 'switch' statement by setting 'coverUnreachable = true'.  This is useful when you want to include a 'default' statement even if all possible values are covered by 'is' statements. It is used when `my2Bits` covers all values from 0 to 3.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/when_switch.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nswitch(my2Bits, coverUnreachable = true) {\n    is(0) { ... }\n    is(1) { ... }\n    is(2) { ... }\n    is(3) { ... }\n    default { ... } // This will parse and validate without error now\n}\n```\n\n----------------------------------------\n\nTITLE: Activate virtual environment and install dependencies\nDESCRIPTION: Activates the Python virtual environment and installs the required dependencies from the 'requirements.txt' file.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/README.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nsource .venv/bin/activate\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Limited Counter Embedded Assertions - Scala\nDESCRIPTION: This example demonstrates how to embed formal assertions directly within the DUT using `GenerationFlags.formal`. These assertions will only be included during formal verification. The testbench is similar to the external assertion example.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Formal verification/index.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass LimitedCounterEmbedded extends Component {\n  val value = Reg(UInt(4 bits)) init(2)\n  when(value < 10) {\n    value := value + 1\n  }\n\n  // That code block will not be in the SpinalVerilog netlist by default. (would need to enable SpinalConfig().includeFormal. ...\n  GenerationFlags.formal {\n    assert(value >= 2)\n    assert(value <= 10)\n  }\n}\n\nobject LimitedCounterEmbeddedFormal extends App {\n  import spinal.core.formal._\n\n  FormalConfig.withBMC(15).doVerify(new Component {\n    val dut = FormalDut(new LimitedCounterEmbedded())\n    assumeInitial(ClockDomain.current.isResetActive)\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Timer Component Definition in SpinalHDL Scala\nDESCRIPTION: Defines a Timer component with a configurable width. The timer counts up to a limit based on a tick signal and can be cleared. The component has input/output signals for tick, clear, limit, full (when the timer reaches the limit), and the current value.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Advanced ones/timer.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Timer(width : Int) extends Component {\n  val io = new Bundle {\n    val tick  = in Bool()\n    val clear = in Bool()\n    val limit = in UInt(width bits)\n    val full  = out Bool()\n    val value = out UInt(width bits)\n  }\n\n  val counter = Reg(UInt(width bits)) init(0)\n  val fullReg = Reg(Bool()) init(False)\n\n  fullReg := False\n  when(io.tick){\n    when(! fullReg){\n      when(io.clear){\n        counter := 0\n      } otherwise {\n        counter := counter + 1\n        when(counter === io.limit - 1){\n          fullReg := True\n        }\n      }\n    }\n  }\n\n  io.value := counter\n  io.full  := fullReg\n```\n\n----------------------------------------\n\nTITLE: Configuring Mill to use Local SpinalHDL\nDESCRIPTION: Configures the mill build file to use a local SpinalHDL clone as a dependency. It imports the necessary modules from the local SpinalHDL build file using Ammonite REPL magic to locate the SpinalHDL build definition, and defines module dependencies accordingly.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/howotuselocalspinalclone.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport mill._\nimport scalalib._\n\nimport $file.^.SpinalHDL.build\nimport ^.SpinalHDL.build.{core => spinalCore}\nimport ^.SpinalHDL.build.{lib => spinalLib}\nimport ^.SpinalHDL.build.{idslplugin => spinalIdslplugin}\n\nval spinalVers = \"1.10.2a\"\nval scalaVers = \"2.12.18\"\n\nobject projectname extends RootModule with SbtModule {\n   def scalaVersion = scalaVers\n   def sources = T.sources(\n      this.millSourcePath / \"hw\" / \"spinal\"\n   )\n\n   def idslplugin = spinalIdslplugin(scalaVers)\n   def moduleDeps = Seq(\n      spinalCore(scalaVers),\n      spinalLib(scalaVers),\n      idslplugin\n   )\n   def scalacOptions = super.scalacOptions() ++ idslplugin.pluginOptions()\n}\n```\n\n----------------------------------------\n\nTITLE: APB Interface Bundle Definition in Scala\nDESCRIPTION: This code defines an APB (Advanced Peripheral Bus) interface as a Bundle in SpinalHDL. It includes signals for address, select, enable, ready, write, data, and slave error.  It shows a simple usage instantiation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/types.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nclass APB(addressWidth: Int,\n             dataWidth: Int,\n             selWidth : Int,\n             useSlaveError : Boolean) extends Bundle {\n\n     val PADDR      = UInt(addressWidth bits)\n     val PSEL       = Bits(selWidth bits)\n     val PENABLE    = Bool()\n     val PREADY     = Bool()\n     val PWRITE     = Bool()\n     val PWDATA     = Bits(dataWidth bits)\n     val PRDATA     = Bits(dataWidth bits)\n     val PSLVERROR  = if(useSlaveError) Bool() else null   // This signal is created only when useSlaveError is true\n   }\n\n   // Example of usage :\n   val bus = APB(addressWidth = 8,\n                 dataWidth = 32,\n                 selWidth = 4,\n                 useSlaveError = false)\n```\n\n----------------------------------------\n\nTITLE: Clock Domain Configuration in SpinalHDL\nDESCRIPTION: This code shows how to configure a clock domain using the ClockDomainConfig class in SpinalHDL. It demonstrates setting properties like clockEdge, resetKind, and resetActiveLevel. A custom clock domain 'myClockDomain' is created with the specified configuration and used within a ClockingArea.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/miscelenea/core/core_components.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass CustomClockExample extends Component {\n  val io = new Bundle {\n    val clk = in Bool()\n    val resetn = in Bool()\n    val result = out UInt (4 bits)\n  }\n  val myClockDomainConfig = ClockDomainConfig(\n    clockEdge = RISING,\n    resetKind = ASYNC,\n    resetActiveLevel = LOW\n  )\n  val myClockDomain = ClockDomain(io.clk,io.resetn,config = myClockDomainConfig)\n  val myArea = new ClockingArea(myClockDomain) {\n    val myReg = Reg(UInt(4 bits)) init(7)\n    myReg := myReg + 1\n\n    io.result := myReg\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Bits to Bundle Conversion - Scala\nDESCRIPTION: Demonstrates converting a `Bits` type back to a `CommonDataBus` bundle using the `assignFromBits` operator. This shows how to reconstruct a composite data structure from its flattened representation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bundle.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ncase class TestBundle () extends Component {\n  val io = new Bundle {\n    val we      = in     Bool()\n    val addrWr  = in     UInt (7 bits)\n    val dataIn  = slave  (CommonDataBus())\n\n    val addrRd  = in     UInt (7 bits)\n    val dataOut = master (CommonDataBus())\n  }\n\n  val mm = Ram3rdParty_1w_1rs (G_DATA_WIDTH = io.dataIn.getBitsWidth, \n                               G_ADDR_WIDTH = io.addrWr.getBitsWidth, \n                               G_VENDOR     = \"Intel_Arria10_M20K\")\n\n  mm.io.clk_in    := clockDomain.readClockWire\n  mm.io.clk_out   := clockDomain.readClockWire\n\n  mm.io.we        := io.we\n  mm.io.addr_wr   := io.addrWr.asBits\n  mm.io.d         := io.dataIn.asBits\n\n  mm.io.addr_rd   := io.addrRd.asBits\n  io.dataOut.assignFromBits(mm.io.q)\n}\n```\n\n----------------------------------------\n\nTITLE: Preserving Signal Names with Area in SpinalHDL (Scala)\nDESCRIPTION: This code shows how to use `Area` to preserve signal names defined inside a function during RTL generation in SpinalHDL. By defining `myFunction` as an Area, the `temp` signal will be accessible and named `myFunctionCall_temp` in the generated RTL. It is crucial for debugging and tracing signals within the generated hardware.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/interaction.rst#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef myFunction(arg: UInt) new Area {\n  val temp = arg + 1  // You will not retrieve the temp signal in the generated RTL\n}\n\nval myFunctionCall = myFunction(U\"000001\")  // Will generate `temp` with `myFunctionCall_temp` as the name\nval value = myFunctionCall.temp  + 42\n```\n\n----------------------------------------\n\nTITLE: Synchronous Adder Component Definition in SpinalHDL\nDESCRIPTION: Defines a SpinalHDL Component named 'Dut' that implements a synchronous adder. It has three 8-bit unsigned input ports (a, b, c) and one 8-bit unsigned output port (result). The 'result' output is assigned the value of 'a + b - c' after a register delay, with an initial value of 0. This uses sequential logic.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/examples/synchronous.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport spinal.core._\nimport spinal.core.sim._\n\nimport scala.util.Random\n\n\nobject SimSynchronousExample {\n  class Dut extends Component {\n    val io = new Bundle {\n      val a, b, c = in UInt (8 bits)\n      val result = out UInt (8 bits)\n    }\n    io.result := RegNext(io.a + io.b - io.c) init(0)\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining BusSlaveFactoryDelayed trait in Scala\nDESCRIPTION: This code defines the BusSlaveFactoryDelayed trait, which provides a delayed implementation of the BusSlaveFactory. It includes mechanisms for managing elements, grouping them by address, and defining read/write/onWrite/onRead operations. The build() method needs to be implemented by extending classes.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/bus_slave_factory_impl.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait BusSlaveFactoryDelayed extends BusSlaveFactory {\n  // elements is an array of all BusSlaveFactoryElement requested\n  val elements = ArrayBuffer[BusSlaveFactoryElement]()\n\n\n  // elementsPerAddress is more structured than elements, it group all BusSlaveFactoryElement per requested addresses\n  val elementsPerAddress = collection.mutable.HashMap[BigInt,ArrayBuffer[BusSlaveFactoryElement]]()\n\n  private def addAddressableElement(e : BusSlaveFactoryElement,address : BigInt) = {\n    elements += e\n    elementsPerAddress.getOrElseUpdate(address, ArrayBuffer[BusSlaveFactoryElement]()) += e\n  }\n\n  override def read(that : Data,\n           address : BigInt,\n           bitOffset : Int = 0) : Unit  = {\n    assert(bitOffset + that.getBitsWidth <= busDataWidth)\n    addAddressableElement(BusSlaveFactoryRead(that,address,bitOffset),address)\n  }\n\n  override def write(that : Data,\n            address : BigInt,\n            bitOffset : Int = 0) : Unit  = {\n    assert(bitOffset + that.getBitsWidth <= busDataWidth)\n    addAddressableElement(BusSlaveFactoryWrite(that,address,bitOffset),address)\n  }\n\n  def onWrite(address : BigInt)(doThat : => Unit) : Unit = {\n    addAddressableElement(BusSlaveFactoryOnWrite(address,() => doThat),address)\n  }\n  def onRead (address : BigInt)(doThat : => Unit) : Unit = {\n    addAddressableElement(BusSlaveFactoryOnRead(address,() => doThat),address)\n  }\n\n  def nonStopWrite( that : Data,\n                      bitOffset : Int = 0) : Unit = {\n    assert(bitOffset + that.getBitsWidth <= busDataWidth)\n    elements += BusSlaveFactoryNonStopWrite(that,bitOffset)\n  }\n\n  // This is the only thing that should be implement by class that extends BusSlaveFactoryDelayed\n  def build() : Unit\n\n  component.addPrePopTask(() => build())\n}\n```\n\n----------------------------------------\n\nTITLE: UART Decoder Simulation in Scala (SpinalHDL)\nDESCRIPTION: This Scala code snippet, designed for use with SpinalHDL, simulates a UART decoder.  It forks a process that monitors the `uartPin`, waits for start and stop bits, samples data bits based on the `baudPeriod`, and prints the received character to the simulation terminal. The process relies on SpinalHDL simulation constructs like `waitUntil` and `sleep`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/examples/uart_decoder.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n// Fork a simulation process which will analyze the uartPin and print transmitted bytes into the simulation terminal.\n   fork {\n     // Wait until the design sets the uartPin to true (wait for the reset effect).\n     waitUntil(uartPin.toBoolean == true)\n\n     while(true) {\n       waitUntil(uartPin.toBoolean == false)\n       sleep(baudPeriod/2)\n\n       assert(uartPin.toBoolean == false)\n       sleep(baudPeriod)\n\n       var buffer = 0\n       for(bitId <- 0 to 7) {\n         if(uartPin.toBoolean)\n           buffer |= 1 << bitId\n         sleep(baudPeriod)\n       }\n\n       assert(uartPin.toBoolean == true)\n       print(buffer.toChar)\n     }\n   }\n```\n\n----------------------------------------\n\nTITLE: Simulation Ending with Main Thread Completion\nDESCRIPTION: This snippet demonstrates a simulation that ends when the main simulation thread completes. It forks a clock stimulus and waits for the counter to reach a specific value before printing \"done\".\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/bootstraps.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nSimConfig.compile(new TopLevel).doSim { dut =>\n  SimTimeout(1000)\n  dut.clockDomain.forkStimulus(10)\n  dut.clockDomain.waitSamplingWhere(dut.counter.toInt == 20)\n  println(\"done\")\n}\n```\n\n----------------------------------------\n\nTITLE: RGB Bundle Definition (Fix)\nDESCRIPTION: This code demonstrates the fix for the previous error by using a `case class` instead of a regular `class` for the RGB Bundle.  Case classes automatically provide mechanisms for copying and cloning, resolving the issue of missing constructor parameters.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/spinal_cant_clone.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class RGB(width : Int) extends Bundle {\n  val r, g, b = UInt(width bits)\n}\n\nclass TopLevel extends Component {\n  val tmp = Stream(RGB(8))\n}\n```\n\n----------------------------------------\n\nTITLE: Build documentation versions with Sphinx-Multiversion\nDESCRIPTION: Builds documentation for multiple versions (branches and tags) using the sphinx-multiversion tool.  It outputs to the docs/html directory.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/README.rst#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nsphinx-multiversion source docs/html\n```\n\n----------------------------------------\n\nTITLE: Top Level Component Stubbing - Scala\nDESCRIPTION: This example shows how to stub the top-level SpinalHDL component. The `SpinalVerilog` generator is called on a new Pinsec instance, which is immediately stubbed. This creates a minimal Verilog file for the entire design.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/stub.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nSpinalVerilog(new Pinsec(500 MHz).stub)\n```\n\n----------------------------------------\n\nTITLE: Define Base Class for JTAG Instructions\nDESCRIPTION: Defines a base class `JtagInstruction` for JTAG instructions that provides callback methods (doCapture, doShift, doUpdate, doReset) triggered by specific JTAG TAP states. The Component.current.addPrePopTask ensures the callbacks are registered after all children class constructions.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Advanced ones/jtag.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core.Component\n\nclass JtagInstruction(owner: JtagTapAccess, instructionId: Bits) extends Area {\n  val instructionIdValue = instructionId\n\n  Component.current.addPrePopTask(() => {\n    val fsm = owner.getFsmState()\n\n    val whenInstructionActive = when(fsm === JtagState.UPDATE_IR && owner.getTdi() === False) {\n      owner.getFsmState().parentEnum.meta.elements.drop(1).foreach(e => println(e))\n    }\n\n    when(owner.getFsmState() === JtagState.CAPTURE_IR) {\n    }\n\n    when(owner.getFsmState() === JtagState.SHIFT_IR) {\n    }\n\n    when(owner.getFsmState() === JtagState.UPDATE_IR) {\n    }\n\n    when(owner.getFsmState() === JtagState.TEST_LOGIC_RESET) {\n    }\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: ScopeProperty Example in Scala\nDESCRIPTION: Demonstrates the usage of ScopeProperty in Scala to store and modify an integer value within different scopes. The example showcases setting, getting, and applying modifications to the value using a stack-like behavior. Xlen is defined as a ScopeProperty[Int] and its value is changed within nested blocks.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/scope_property.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject Xlen extends ScopeProperty[Int]\n\n  object ScopePropertyMiaou extends App {\n    Xlen.set(1)\n    println(Xlen.get) // 1\n    Xlen(2) {\n      println(Xlen.get) // 2\n      Xlen(3) {\n        println(Xlen.get) // 3\n        Xlen.set(4)\n        println(Xlen.get) // 4\n      }\n      println(Xlen.get) // 2\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Downloading CSS file with wget\nDESCRIPTION: This command downloads the gh-fork-ribbon.css file from the specified GitHub URL using the wget utility. This CSS provides a visual ribbon effect to indicate that a project is a fork on GitHub. The downloaded file can then be used to customize the appearance of the forked project.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/_static/gh-fork-ribbon.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwget https://raw.githubusercontent.com/simonwhitaker/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.css\n```\n\n----------------------------------------\n\nTITLE: StreamCCByToggle Shorter Syntax - Scala\nDESCRIPTION: Demonstrates a shorter syntax for instantiating a StreamCCByToggle component. This syntax directly returns the cross-clocked stream, simplifying the instantiation and connection process.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/stream.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval clockA = ClockDomain(???)\nval clockB = ClockDomain(???)\nval streamA = Stream(Bits(8 bits))\nval streamB = StreamCCByToggle(\n  input       = streamA,\n  inputClock  = clockA,\n  outputClock = clockB\n)\n```\n\n----------------------------------------\n\nTITLE: NullPointerException stack trace\nDESCRIPTION: This shows the stack trace of a NullPointerException that occurs from attempting to access an uninitialized variable in SpinalHDL.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/nullpointerexception.rst#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nException in thread \"main\" java.lang.NullPointerException\n  ***\n  Source file location of the a := 42 assignment via the stack trace\n  ***\n```\n\n----------------------------------------\n\nTITLE: Literals in SpinalHDL (Scala)\nDESCRIPTION: This snippet illustrates the use of different types of literals in SpinalHDL assignments. It includes boolean literals (True, False), string literals for binary and hexadecimal values, integer literals, and advanced literal constructs with ranges and defaults.  It also demonstrates using literals within a conditional statement.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_perspective.rst#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval myBool = Bool()\nmyBool := False\nmyBool := True\nmyBool := Bool(4 > 7)\n\nval myUInt = UInt(8 bits)\nmyUInt := \"0001_1100\"\nmyUInt := \"xEE\"\nmyUInt := 42\nmyUInt := U(54,8 bits)\nmyUInt := ((3 downto 0) -> myBool, default -> true)\nwhen(myUInt === U(myUInt.range -> true)) {\n  myUInt(3) := False\n}\n```\n\n----------------------------------------\n\nTITLE: Generating std_logic_vector only in VHDL BlackBox (Scala)\nDESCRIPTION: This code demonstrates how to add the `noNumericType` tag to a SpinalHDL BlackBox to force the generation of only `std_logic_vector` types in the VHDL output, instead of using numeric types for UInt and SInt. This is useful when the underlying VHDL component expects `std_logic_vector`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/blackbox.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nclass MyBlackBox() extends BlackBox {\n  val io = new Bundle {\n    val clk       = in  Bool()\n    val increment = in  Bool()\n    val initValue = in  UInt(8 bits)\n    val counter   = out UInt(8 bits)\n  }\n\n  mapCurrentClockDomain(io.clk)\n\n  noIoPrefix()\n\n  addTag(noNumericType)  // Only std_logic_vector\n}\n```\n\n----------------------------------------\n\nTITLE: RamFiber Implementation - Scala\nDESCRIPTION: This snippet shows the integration layer of a regular Tilelink Ram component using SpinalHDL. It defines an upward-facing node and a fiber to specify parameters.  The supported parameters are determined by the master's desired parameters, restricted to get/put requests. The code infers the RAM size based on memory mapping and generates the hardware.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/tilelink/tilelink_fabric.rst#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport spinal.lib.bus.tilelink\nimport spinal.core.fiber.Fiber\nclass RamFiber() extends Area {\n  val up = tilelink.fabric.Node.up()\n\n  val thread = Fiber build new Area {\n    // Here the supported parameters are function of what the master would like us to ideally support.\n    // The tilelink.Ram support all addressWidth / dataWidth / burst length / get / put accesses\n    // but doesn't support atomic / coherency. So we take what is proposed to use and restrict it to \n    // all sorts of get / put request\n    up.m2s.supported load up.m2s.proposed.intersect(M2sTransfers.allGetPut)\n    up.s2m.none()\n\n    // Here we infer how many bytes our ram need to be, by looking at the memory mapping of the connected masters\n    val bytes = up.ups.map(e => e.mapping.value.highestBound - e.mapping.value.lowerBound + 1).max.toInt\n    \n    // Then we finally generate the regular hardware\n    val logic = new tilelink.Ram(up.bus.p.node, bytes)\n    logic.io.up << up.bus\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Apply Function in Scala Class\nDESCRIPTION: This example shows the `apply` function in a Scala class. When an instance of the `Array` class is called like a function (e.g., `array(4)`), the `apply` method is implicitly invoked. This allows treating objects as functions.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nclass Array() {\n  def apply(index: Int): Int = index + 3\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval array = new Array()\nval value = array(4)   // array(4) is interpreted as array.apply(4) and will return 7\n```\n\n----------------------------------------\n\nTITLE: Run documentation build in Docker container\nDESCRIPTION: Runs a Docker container based on the 'spinaldoc-rtd' image, mounting the current directory as '/docs'.  The command then executes the default behavior defined in the Docker image, which likely involves building the documentation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/README.rst#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ndocker run -it --rm -v $PWD:/docs spinaldoc-rtd\n```\n\n----------------------------------------\n\nTITLE: Mux Latch Example - Scala\nDESCRIPTION: This SpinalHDL code snippet demonstrates a latch being created due to a non-exhaustive mux. The 'u1' signal is used in a mux statement, but a case for the input value of 1 is missing, resulting in a latch if 'u1' is 1.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/latch_detected.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval u1 = UInt(1 bit)\nu1.mux(\n  0 -> False,\n  // case for 1 is missing\n)\n```\n\n----------------------------------------\n\nTITLE: Verilog Implementation of Conditional Assignment\nDESCRIPTION: This Verilog code is the result of compiling the Scala code with a conditional assignment. A wire 'when_Test_l117' is generated to represent the condition, and 'always' blocks are used to implement the conditional logic for the isZero and counter signals.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_22\n\nLANGUAGE: verilog\nCODE:\n```\n    module MyComponent (\n      input      [7:0]    value,\n      output reg          isZero,\n      output reg [7:0]    counter,\n      input               clk,\n      input               reset\n    );\n      wire                when_Test_l117;\n\n      always @ (*) begin\n        isZero = 1'b0;\n        if(when_Test_l117)begin\n          isZero = 1'b1;\n        end\n      end\n\n      assign when_Test_l117 = (value == 8'h0);\n      always @ (posedge clk) begin\n        if(when_Test_l117)begin\n          counter <= (counter + 8'h01);\n        end\n      end\n    endmodule\n```\n\n----------------------------------------\n\nTITLE: Starting SBT Interactive Mode\nDESCRIPTION: This code snippet demonstrates how to start SBT in interactive mode.  Entering 'sbt' without any arguments launches the SBT console, providing a prompt for executing commands directly within the SBT environment. This is recommended for iterative development due to reduced startup time compared to running commands individually from the command line.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/SBT.rst#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nsbt\n```\n\n----------------------------------------\n\nTITLE: Generated Verilog with Area in Function\nDESCRIPTION: Displays the resulting Verilog from the Area-in-function example. The comparator signal is named someLogic_comparator, showing how the Area created inside the function impacts the signal's name in the generated hardware.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_8\n\nLANGUAGE: verilog\nCODE:\n```\nmodule MyComponent (\n  input      [7:0]    value,\n  output              result\n);\n  wire                someLogic_comparator;\n\n  assign someLogic_comparator = (value == 8'h0);\n  assign result = someLogic_comparator;\n\nendmodule\n```\n\n----------------------------------------\n\nTITLE: Suppressing Duplicated Elements in Switch Statement Error in Scala\nDESCRIPTION: This code demonstrates how to suppress the \"DUPLICATED ELEMENTS IN SWITCH IS(...) STATEMENT\" error in a 'switch' statement by setting 'strict = false'.  When strict mode is disabled, SpinalHDL will remove duplicated values in the 'is' statement.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/when_switch.rst#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nswitch(value, strict = false) {\n    is(0) { ... }\n    is(1,1,1,1,1) { ... } // This will be okay\n    is(2) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Ready Payload Bus Definition in SpinalHDL\nDESCRIPTION: This snippet defines a simple Valid Ready Payload bus in SpinalHDL. It includes methods for connecting buses and creating a FIFO queue. The input is the payload width (Int), and the output of the queue method is a MyBus object.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/miscelenea/core/core_components.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nclass MyBus(payloadWidth:  Int) extends Bundle {\n     val valid = Bool()\n     val ready = Bool()\n     val payload = Bits(payloadWidth bits)\n\n     // connect that to this\n     def <<(that: MyBus) : Unit = {\n       this.valid := that.valid\n       that.ready := this.ready\n       this.payload := that.payload\n     }\n\n     // Connect this to the FIFO input, return the fifo output\n     def queue(size: Int): MyBus = {\n       val fifo = new Fifo(payloadWidth, size)\n       fifo.io.push << this\n       return fifo.io.pop\n     }\n   }\n```\n\n----------------------------------------\n\nTITLE: Creating APB3 Decoder in Scala\nDESCRIPTION: This code shows the creation of an APB3 decoder using `Apb3Decoder` in SpinalHDL. It connects the APB3 master (from the AXI4-to-APB3 bridge) to a list of APB3 slaves, with specified base addresses and sizes.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nval apbDecoder = Apb3Decoder(\n  master = apbBridge.io.apb,\n  slaves = List(\n    gpioACtrl.io.apb -> (0x00000, 4 KiB),\n    gpioBCtrl.io.apb -> (0x01000, 4 KiB),\n    uartCtrl.io.apb  -> (0x10000, 4 KiB),\n    timerCtrl.io.apb -> (0x20000, 4 KiB),\n    vgaCtrl.io.apb   -> (0x30000, 4 KiB),\n    core.io.debugBus -> (0xF0000, 4 KiB)\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Continuous Assignment with Literals in SpinalHDL (Scala)\nDESCRIPTION: This code snippet demonstrates how to use continuous assignment with literals to define a wire, maintain the result of an equality operation, and set up inferred type (Bool). `value` is a Bool signal that becomes True when blue is equal to U\"0001\". When `value` becomes true, `done` is set to `True`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/types.rst#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nval done = Bool(False)\nval blue = in UInt(4 bits)\n...\nval value = blue === U\"0001\"  // inferred type is Bool due to use of === operator\nwhen(value) {\n  done := True\n}\n```\n\n----------------------------------------\n\nTITLE: HSRW/RWHS Register Logic Example in Verilog\nDESCRIPTION: Shows the Verilog implementation of HSRW and RWHS register access types.  HSRW prioritizes hardware writes ('io.xxx_set'), while RWHS prioritizes software writes ('hit_0x0004'). The example highlights how hardware and software writes interact with each other.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_6\n\nLANGUAGE: verilog\nCODE:\n```\nalways @(posedge clk or negedge rstn)\n     if(!rstn) begin\n        reg0  <= '0;\n        reg0  <= '0;\n     end else begin\n        if(hit_0x0000) begin\n           reg0 <= wdata ;\n        end\n        if(io.xxx_set) begin      // HW have High priority than SW\n           reg0 <= io.xxx_set_val ;\n        end\n\n        if(io.xxx_set) begin\n           reg1 <= io.xxx_set_val ;\n        end \n        if(hit_0x0004) begin      // SW have High priority than HW\n           reg1 <= wdata ;\n        end\n     end\n```\n\n----------------------------------------\n\nTITLE: Combinatorial Logic in SpinalHDL (Scala)\nDESCRIPTION: This example shows how to assign values to both combinatorial signals and registers within a conditional block in SpinalHDL. In SpinalHDL, assignments can be made anywhere, unlike languages that require separate process blocks for combinatorial and sequential logic. It demonstrates conditional updates for both Bool and UInt signals.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_perspective.rst#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval cond = Bool()\nval myCombinatorial = Bool()\nval myRegister = UInt(8 bits)\n\nmyCombinatorial := False\nwhen(cond) {\n  myCombinatorial := True\n  myRegister = myRegister + 1\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a New ClockDomain in a Testbench - Scala\nDESCRIPTION: This code snippet demonstrates how to define a new ClockDomain in a SpinalHDL testbench when the clock and reset signals are not directly integrated into an existing ClockDomain.  It creates a new ClockDomain instance using the specified clock and reset signals from the Device Under Test (DUT) and then forks a stimulus for it.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/clock.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// In the testbench\nClockDomain(dut.io.coreClk, dut.io.coreReset).forkStimulus(10)\n```\n\n----------------------------------------\n\nTITLE: PLL BlackBox Definition in SpinalHDL\nDESCRIPTION: Defines a PLL BlackBox in SpinalHDL. This BlackBox encapsulates the functionality of a Phase-Locked Loop (PLL) and exposes clock input, clock output, and lock status signals. It is used to create the corresponding VHDL component for integration into hardware designs.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Simple ones/pll_resetctrl.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class PLL(\n  div : Int\n) extends BlackBox {\n  // Clock in input, clock out output and a lock signal\n  val clkIn   = in  Bool()\n  val clkOut  = out Bool()\n  val isLocked = out Bool()\n\n  //Specifying the Verilog/VHDL parameters\n  addGeneric(\"DIV\", div)\n\n  //Specifying the Verilog/VHDL port names\n  mapCurrentClockDomain(clkIn, clkOut)\n  noIoPrefix()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating Verilog and QSys TCL Script\nDESCRIPTION: This main function generates the Verilog code and QSys TCL script for the AvalonMMUartCtrl component. It adds a ClockDomainTag to the AvalonMM bus to specify its clock domain, which is required by QSysify.  QSysify(toplevel) then generates the QSys IP.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/EDA/altera/qsysify.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject AvalonMMUartCtrl {\n  def main(args: Array[String]) {\n    // Generate the Verilog\n    val toplevel = SpinalVerilog(AvalonMMUartCtrl(UartCtrlMemoryMappedConfig(...))).toplevel\n\n    // Add some tags to the avalon bus to specify it's clock domain (information used by QSysify)\n    toplevel.io.bus addTag(ClockDomainTag(toplevel.clockDomain))\n\n    // Generate the QSys IP (tcl script)\n    QSysify(toplevel)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Illegal Assignment: Output signal X can't be assigned by Y (Scala)\nDESCRIPTION: This code snippet shows a hierarchy violation. Output signals should only be assigned inside the component which declares them. In this example, 'ComponentY' tries to assign to the output of 'ComponentX', which is not allowed. This is often caused by mixing up signal direction declarations.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/miscelenea/frequent_errors.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass ComponentX extends Component {\n  val io = new Bundle {\n    val X = out Bool()\n  }\n  ...\n}\n\nclass ComponentY extends Component {\n  ...\n  val componentX = new ComponentX\n  val Y = Bool()\n  componentX.X := Y // This assignment is not legal\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an External Clock Domain in SpinalHDL\nDESCRIPTION: This snippet demonstrates how to define an external clock domain in SpinalHDL using ClockDomain.external(). This automatically adds clock and reset signals from the top-level inputs to all synchronous elements within the domain. The code creates an external clock domain named 'myClockName' and uses it in a ClockingArea.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/miscelenea/core/core_components.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass ExternalClockExample extends Component {\n  val io = new Bundle {\n    val result = out UInt (4 bits)\n  }\n  val myClockDomain = ClockDomain.external(\"myClockName\")\n  val myArea = new ClockingArea(myClockDomain) {\n    val myReg = Reg(UInt(4 bits)) init(7)\n    myReg := myReg + 1\n\n    io.result := myReg\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Constant Value Declaration with val in Scala\nDESCRIPTION: This snippet showcases the declaration of constant values using the `val` keyword in Scala.  `val` creates immutable bindings, meaning the values assigned to `two`, `three`, and `six` cannot be changed after initialization.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval two   = 2\nval three = 3\nval six   = two * three\n```\n\n----------------------------------------\n\nTITLE: HTML Meta Refresh Redirection\nDESCRIPTION: This HTML snippet uses the `<meta>` tag with `http-equiv=\"refresh\"` to redirect the user to a new URL. The `content` attribute specifies the delay (in seconds) before redirection and the target URL. In this case, it redirects immediately to \"http://spinalhdl.github.io/SpinalDoc/\".\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/miscelenea/chisel.rst#_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n<head>\n   <!-- HTML meta refresh URL redirection -->\n   <meta http-equiv=\"refresh\"\n   content=\"0; url=http://spinalhdl.github.io/SpinalDoc/\">\n</head>\n```\n\n----------------------------------------\n\nTITLE: Assignments in SpinalHDL\nDESCRIPTION: This example shows the difference between the assignment operators `:=` and `\\=` in SpinalHDL. `:=` is a standard assignment where the last assignment wins, while `\\=` updates the value instantly. It also demonstrates that hardware concurrency means a signal is read with its current value within the same delta cycle.  It uses UInt signals of 4 bits.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/miscelenea/core/core_components.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// Because of hardware concurrency is always read with the value '1' by b and c\nval a,b,c = UInt(4 bits)\na := 0\nb := a\na := 1  // a := 1 win\nc := a  \n\nvar x = UInt(4 bits)\nval y,z = UInt(4 bits)\nx := 0\ny := x      // y read x with the value 0\nx \\= x + 1\nz := x      // z read x with the value 1\n```\n\n----------------------------------------\n\nTITLE: Defining Analog Signal in SpinalHDL\nDESCRIPTION: This code snippet demonstrates how to define an Analog signal within a SpinalHDL Bundle.  Analog signals can represent digital values of 0, 1, or Z (high-impedance). This is used for bidirectional data bus representation. The SdramLayout case class defines the width of the data signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/analog_inout.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class SdramInterface(g : SdramLayout) extends Bundle {\n  val DQ    = Analog(Bits(g.dataWidth bits)) // Bidirectional data bus\n  val DQM   = Bits(g.bytePerWord bits)\n  val ADDR  = Bits(g.chipAddressWidth bits)\n  val BA    = Bits(g.bankWidth bits)\n  val CKE, CSn, CASn, RASn, WEn  = Bool()\n}\n```\n\n----------------------------------------\n\nTITLE: PixelTask and PixelResult Bundle Definitions (Scala)\nDESCRIPTION: Defines the `PixelTask` and `PixelResult` bundles, which represent the input and output data structures for the fractal calculator. `PixelTask` contains the X and Y coordinates, and `PixelResult` contains the iteration count.  These bundles are used for streaming data into and out of the PixelSolver component.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/fractal.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// begin bundles\ncase class PixelTask(g : PixelSolverGenerics) extends Bundle {\n  val x = g.fixType()\n  val y = g.fixType()\n}\n\ncase class PixelResult(g : PixelSolverGenerics) extends Bundle {\n  val iteration = g.iterationType()\n}\n// end bundles\n```\n\n----------------------------------------\n\nTITLE: Setting Reserved Address Read Value in SpinalHDL\nDESCRIPTION: This Scala code snippet shows how to set a default read value for reserved memory addresses within a bus interface in SpinalHDL. This allows a specified value to be returned when software attempts to read from reserved locations, aiding in debugging. The `busif.setReservedAddressReadValue` method is used for this purpose, taking the desired read value as an argument.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\n   busif.setReservedAddressReadValue(0x0000EF00)\n```\n\n----------------------------------------\n\nTITLE: Defining APB3 Bundle in Scala\nDESCRIPTION: This Scala code defines the `Apb3` Bundle representing the APB3 bus interface. It includes signals for address, select, enable, write, write data, ready, read data, and slave error.  It relies on the `Apb3Config` case class for configuration.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Simple ones/apb3.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class Apb3(config : Apb3Config) extends Bundle {\n  import config._\n  val PADDR   = out UInt(addressWidth bits)\n  val PSEL    = out Bits(selWidth bits)\n  val PENABLE = out Bool()\n  val PWRITE  = out Bool()\n  val PWDATA  = out Bits(dataWidth bits)\n  val PREADY  = in Bool()\n  val PRDATA  = in Bits(dataWidth bits)\n  val PSLVERROR = in Bool()\n}\n```\n\n----------------------------------------\n\nTITLE: Losing Signal Names Defined Inside Functions in SpinalHDL (Scala)\nDESCRIPTION: This code illustrates how signal names defined inside a regular Scala function are lost during RTL generation in SpinalHDL. The `temp` signal, which is local to `myFunction`, will not be present in the generated RTL netlist. This highlights the need to use Areas to preserve signal names.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/interaction.rst#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef myFunction(arg: UInt) {\n  val temp = arg + 1  // You will not retrieve the `temp` signal in the generated RTL\n  return temp\n}\n\nval value = myFunction(U\"000001\") + 42\n```\n\n----------------------------------------\n\nTITLE: Illegal Assignment: Input signal X can't be assigned by Y (Scala)\nDESCRIPTION: This snippet demonstrates a hierarchy violation where an input signal 'X' within 'ComponentXY' is incorrectly assigned from within the same component. Input signals can only be driven by the parent component, not from within the component itself. This is likely due to mixing up signal direction declarations.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/miscelenea/frequent_errors.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass ComponentXY extends Component {\n  val io = new Bundle {\n    val X = in Bool()\n  }\n  ...\n  val Y = Bool()\n  io.X := Y // This assignment is not legal\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: SpinalHDL Clock Domain Definition\nDESCRIPTION: This SpinalHDL code demonstrates how to define a clock domain with specific clock and reset signals, along with their configurations (edge, kind, and active level). It also shows how to create a ClockingArea to apply the clock domain to a specific region of the hardware.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n   val coreClockDomain = ClockDomain(\n     clock = io.coreClk,\n     reset = io.coreReset,\n     config = ClockDomainConfig(\n       clockEdge = RISING,\n       resetKind = ASYNC,\n       resetActiveLevel = HIGH\n     )\n   )\n   val coreArea = new ClockingArea(coreClockDomain) {\n     val myCoreClockedRegister = Reg(UInt(4 bits))\n     // ...\n     // coreClockDomain will also be applied to all sub components instantiated in the Area\n     // ... \n   }\n```\n\n----------------------------------------\n\nTITLE: Chaining Composites for Nested Namespaces (Scala)\nDESCRIPTION: Demonstrates how Composites can be chained together to create nested namespaces. The example shows two Composites, isZero and inverted, being chained, resulting in a deeply nested signal name. This exemplifies advanced Composite usage.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nclass MyComponent extends Component {\n  def isZero(value: UInt) = new Composite(value) {\n    val comparator = value === 0\n  }.comparator\n\n\n  def inverted(value: Bool) = new Composite(value) {\n    val inverter = !value\n  }.inverter\n\n  val value = in UInt(8 bits)\n  val result = out Bool()\n  result := inverted(isZero(value))\n}\n```\n\n----------------------------------------\n\nTITLE: Intermediate Nodes in Interconnect - Scala\nDESCRIPTION: This snippet illustrates how to define intermediate nodes in a Tilelink interconnect using SpinalHDL. It creates a peripherals namespace with an intermediate node (access) and connects GPIO fibers to it, demonstrating address mapping within the namespace.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/tilelink/tilelink_fabric.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval cpu = new CpuFiber()\n\nval ram = new RamFiber()\nram.up at(0x10000, 0x200) of cpu.down\n        \n// Create a peripherals namespace to keep things clean\nval peripherals = new Area {\n  // Create a intermediate node in the interconnect\n  val access = tilelink.fabric.Node()\n  access at 0x20000 of cpu.down\n\n  val gpioA = new GpioFiber()\n  gpioA.up at 0x0000 of access\n\n  val gpioB = new GpioFiber()\n  gpioB.up at 0x1000 of access\n}\n```\n\n----------------------------------------\n\nTITLE: AvalonMMSlaveFactory Companion Object in Scala\nDESCRIPTION: This code defines the companion object for the AvalonMMSlaveFactory, which provides a method to retrieve a suitable AvalonMMConfig object. The getAvalonConfig method creates a pipelined Avalon bus configuration with specified address and data widths and disables byte enable and wait request signals.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/bus_slave_factory_impl.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject AvalonMMSlaveFactory {\n  def getAvalonConfig( addressWidth : Int,\n                       dataWidth : Int) = {\n    AvalonMMConfig.pipelined(   // Create a simple pipelined configuration of the Avalon Bus\n      addressWidth = addressWidth,\n      dataWidth = dataWidth\n    ).copy(                     // Change some parameters of the configuration\n      useByteEnable = false,\n      useWaitRequestn = false\n    )\n  }\n\n  def apply(bus : AvalonMM) = new AvalonMMSlaveFactory(bus)\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating GPIO Controllers Scala\nDESCRIPTION: This code instantiates two APB3 GPIO controllers, gpioACtrl and gpioBCtrl, each with a width of 32 bits. These controllers allow the CPU to control and monitor general-purpose input/output pins.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval gpioACtrl = Apb3Gpio(\n  gpioWidth = 32\n)\n\nval gpioBCtrl = Apb3Gpio(\n  gpioWidth = 32\n)\n```\n\n----------------------------------------\n\nTITLE: Running OpenOCD\nDESCRIPTION: This code snippet shows an example of arguments used to run the OpenOCD tool for debugging RISC-V on SpinalHDL. It specifies configuration files for the FTDI interface and the RISC-V Spinal target, along with a debug level of 3.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/software.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nopenocd -f ../tcl/interface/ftdi/ft2232h_breakout.cfg -f ../tcl/target/riscv_spinal.cfg -d 3\n```\n\n----------------------------------------\n\nTITLE: Fork Simulation Thread - Scala\nDESCRIPTION: Creates a new simulation thread in SpinalSim. The `fork` function allows defining a block of code that will execute concurrently with the main simulation thread. The example shows how to create a thread and defines an empty body.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/threadFull.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n// Create a new thread\nval myNewThread = fork {\n  // New simulation thread body\n}\n```\n\n----------------------------------------\n\nTITLE: Bits Width Inference in SpinalHDL (Scala)\nDESCRIPTION: This snippet illustrates how the width of a Bits signal is inferred from the widest assignment in SpinalHDL. It highlights the need for resizing constants to match the inferred width to avoid width mismatch errors, especially when using conditional assignments.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bits.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// Declaration\nval myBits = Bits()     // the size is inferred from the widest assignment\n// ....\n// .resized needed to prevent WIDTH MISMATCH error as the constants\n// width does not match size that is inferred from assignment below\nmyBits := B(\"1010\").resized  // auto-widen Bits(4 bits) to Bits(6 bits)\nwhen(condxMaybe) {\n  // Bits(6 bits) is inferred for myBits, this is the widest assignment\n  myBits := B(\"110000\")\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect UInt Assignment in SpinalHDL (Scala)\nDESCRIPTION: This code demonstrates an incorrect UInt assignment in SpinalHDL that results in a width mismatch error. The code assigns an 8-bit UInt signal 'a' to a 4-bit UInt signal 'b' directly, which is not allowed without explicit resizing. This snippet requires the SpinalHDL library to be included in the project.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/width_mismatch.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val a = UInt(8 bits)\n  val b = UInt(4 bits)\n  b := a\n}\n```\n\n----------------------------------------\n\nTITLE: Scope Violation Example in SpinalHDL Scala\nDESCRIPTION: This SpinalHDL code snippet demonstrates a scope violation error.  The UInt signal 'tmp' is declared within the 'when' scope, and then assigned outside of it. This will cause a compile-time error in SpinalHDL. The error occurs because the signal 'tmp' is only defined conditionally within the 'when' block but is then assigned unconditionally.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/scope_violation.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass TopLevel extends Component {\n  val cond = Bool()\n\n  var tmp : UInt = null\n  when(cond) {\n    tmp = UInt(8 bits)\n  }\n  tmp := U\"x42\"\n}\n```\n\n----------------------------------------\n\nTITLE: Verilog Implementation of Addition Component\nDESCRIPTION: This Verilog code is generated from the Scala component above, demonstrating how the addition operation is split into multiple assignments using intermediate signals (_zz_result, _zz_result_1) for proper behavior.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_18\n\nLANGUAGE: verilog\nCODE:\n```\n    module MyComponent (\n      input      [7:0]    a,\n      input      [7:0]    b,\n      input      [7:0]    c,\n      input      [7:0]    d\n    );\n      wire       [7:0]    _zz_result;\n      wire       [7:0]    _zz_result_1;\n      wire       [7:0]    result;\n\n      assign _zz_result = (_zz_result_1 + c);\n      assign _zz_result_1 = (a + b);\n      assign result = (_zz_result + d);\n\n    endmodule\n```\n\n----------------------------------------\n\nTITLE: Wait Until Condition - Scala\nDESCRIPTION: Pauses the execution of the current simulation thread until a specified condition is met. The `waitUntil()` function takes a boolean expression as input and blocks the thread until the expression evaluates to true. Requires a Dut object `dut` with a signal `io.a` of a comparable type. This enables synchronization based on specific events or signal values within the design under test.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/threadFull.rst#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n// waitUntil the dut.io.a value is bigger than 42 before continuing\nwaitUntil(dut.io.a > 42)\n```\n\n----------------------------------------\n\nTITLE: VHDL Component Instantiation\nDESCRIPTION: This VHDL code demonstrates the verbose process of instantiating a component, requiring explicit redefinition of all signals and a port map.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_13\n\nLANGUAGE: VHDL\nCODE:\n```\n   divider_cmd_valid : in std_logic;\n   divider_cmd_ready : out std_logic;\n   divider_cmd_numerator : in unsigned(31 downto 0);\n   divider_cmd_denominator : in unsigned(31 downto 0);\n   divider_rsp_valid : out std_logic;\n   divider_rsp_ready : in std_logic;\n   divider_rsp_quotient : out unsigned(31 downto 0);\n   divider_rsp_remainder : out unsigned(31 downto 0);\n\n   divider : entity work.UnsignedDivider\n     port map (\n       clk             => clk,\n       reset           => reset,\n       cmd_valid       => divider_cmd_valid,\n       cmd_ready       => divider_cmd_ready,\n       cmd_numerator   => divider_cmd_numerator,\n       cmd_denominator => divider_cmd_denominator,\n       rsp_valid       => divider_rsp_valid,\n       rsp_ready       => divider_rsp_ready,\n       rsp_quotient    => divider_rsp_quotient,\n       rsp_remainder   => divider_rsp_remainder\n     );\n```\n\n----------------------------------------\n\nTITLE: Generate Verilog for RGB Pipeline - Scala\nDESCRIPTION: This snippet shows how to generate Verilog code for the `RgbToSomething` component using `SpinalVerilog`. It configures the component with specific stage assignments for the addition, inversion, multiplication, and result stages, allowing control over the pipeline's timing and resource utilization.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\nSpinalVerilog(\n  new RgbToSomething(\n    addAt    = 0,\n    invAt    = 1,\n    mulAt    = 2,\n    resultAt = 3\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Verilog Output of Interlocking Plugins Example\nDESCRIPTION: This Verilog code is the output generated from the interlocking plugins example, showcasing how multiple SetupPlugins increment the register.  The final increment value (2) reflects the contributions from both SetupPlugin instances.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Misc/service_plugin.rst#_snippet_4\n\nLANGUAGE: verilog\nCODE:\n```\nmodule TopLevel (\n  input  wire          clk,\n  input  wire          reset\n);\n\n\n  SubComponent sub (\n    .clk   (clk  ), // i\n    .reset (reset)  // i\n  );\n\nendmodule\n\nmodule SubComponent (\n  input  wire          clk,\n  input  wire          reset\n);\n\n  reg        [31:0]   StatePlugin_logic_signal;\n\n  always @(posedge clk) begin\n    StatePlugin_logic_signal <= (StatePlugin_logic_signal + 32'h00000002); // + 2 as we have two SetupPlugin\n  end\nendmodule\n```\n\n----------------------------------------\n\nTITLE: PixelSolverGenerics Case Class Definition (Scala)\nDESCRIPTION: Defines the `PixelSolverGenerics` case class, which provides the construction parameters for the fractal calculator system. These parameters define the types for iterations and fixed-point numbers used in the calculations.  It also allows you to configure parameters of the pixel solver.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/fractal.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class PixelSolverGenerics(\n  fixWidth      : Int,             // Define the width of the fixed point numbers\n  iterationMax  : Int              // Define the maximal number of iteration\n) {\n  def fixType()     = SFix(0 exp, -fixWidth exp) // type of the fix point numbers\n  def iterationType() = UInt(log2Up(iterationMax) bits) // type of the iteration counter\n}\n// end case class PixelSolverGenerics\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Adder Component Definition - SpinalHDL Scala\nDESCRIPTION: This snippet defines a SpinalHDL component named 'Dut' that performs asynchronous addition and subtraction. It takes three 8-bit unsigned integer inputs (a, b, c) and produces an 8-bit unsigned integer output (result), calculated as a + b - c. The output is assigned combinatorially based on the input values.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/examples/asynchronous.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport spinal.core._\nimport spinal.core.sim._\n\nimport scala.util.Random\n\n\nobject SimAsynchronousExample {\n  class Dut extends Component {\n    val io = new Bundle {\n      val a, b, c = in UInt (8 bits)\n      val result = out UInt (8 bits)\n    }\n    io.result := io.a + io.b - io.c\n  }\n\n  def main(args: Array[String]): Unit = {\n    SimConfig.withWave.compile(new Dut).doSim{ dut =>\n      var idx = 0\n      while(idx < 100) {\n        val a, b, c = Random.nextInt(256)\n        dut.io.a #= a\n        dut.io.b #= b\n        dut.io.c #= c\n        sleep(1) // Sleep 1 simulation timestep\n        assert(dut.io.result.toInt == ((a + b - c) & 0xFF))\n        idx += 1\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Local Signal Declaration within When Statement in Scala\nDESCRIPTION: This code demonstrates how to declare local signals within a 'when' statement.  These signals are only accessible within the scope of the 'when' statement. SpinalHDL checks that signals defined inside a scope are only assigned inside that scope.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/when_switch.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval x, y = UInt(4 bits)\nval a, b = UInt(4 bits)\n\nwhen(cond) {\n  val tmp = a + b\n  x := tmp\n  y := tmp + 1\n} otherwise {\n  x := 0\n  y := 0\n}\n```\n\n----------------------------------------\n\nTITLE: Register Initialization with init() in SpinalHDL\nDESCRIPTION: This snippet shows how to initialize a register using the init() function after its declaration. It demonstrates initializing a UInt register and also initializing individual elements within a Bundle register.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Sequential logic/registers.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// UInt register of 4 bits initialized with 0 when the reset occurs\nval reg1 = Reg(UInt(4 bits)) init(0)\n\ncase class ValidRGB() extends Bundle {\n  val valid   = Bool()\n  val r, g, b = UInt(8 bits)\n}\n\nval reg = Reg(ValidRGB())\nreg.valid init(False)  // Only the valid if that register bundle will have a reset value.\n```\n\n----------------------------------------\n\nTITLE: MemoryAddress Bundle with Implicit Parameter (Fix)\nDESCRIPTION: This code shows how to fix the cloning error when using implicit parameters in a Bundle by overriding the `clone` method.  The overridden clone method explicitly calls the constructor with the implicit parameter, ensuring that it's available during the cloning process.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/spinal_cant_clone.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ncase class MemoryAddress()(implicit xlenConfig: Xlen) extends Bundle {\n  val address = UInt(xlenConfig.xlen bits)\n\n  override def clone = MemoryAddress()\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Signal to Fix No Driver Error (Scala)\nDESCRIPTION: This Scala code snippet provides a solution to the \"No Driver On\" error in SpinalHDL by assigning a value to the signal 'a'. By assigning the value 42 to 'a', the error is resolved because all combinational signals that affect the design are now driven. The snippet uses the SpinalHDL Component and UInt classes.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/no_driver_on.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val result = out(UInt(8 bits))\n  val a = UInt(8 bits)\n  a := 42\n  result := a\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing a Combinatorial Loop\nDESCRIPTION: This code snippet shows a possible fix for the combinatorial loop. By assigning a constant value to `d` instead of making it depend on `a`, the circular dependency is broken. The `UInt` signals are all 8 bits wide.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/combinatorial_loop.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass TopLevel extends Component {\n  val a = UInt(8 bits) // PlayDev.scala line 831\n  val b = UInt(8 bits) // PlayDev.scala line 832\n  val c = UInt(8 bits)\n  val d = UInt(8 bits)\n\n  a := b\n  b := c | d\n  d := 42\n  c := 0\n}\n```\n\n----------------------------------------\n\nTITLE: VGA Bus Bundle Definition in Scala\nDESCRIPTION: Defines the VGA bus interface as a SpinalHDL Bundle, including signals for vertical synchronization (vSync), horizontal synchronization (hSync), color enable (colorEn), and color data. It uses the IMasterSlave trait to allow creation of master/slave interfaces.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/vga.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core._\n\ncase class Vga(rgbConfig: RgbConfig) extends Bundle with IMasterSlave {\n  val vSync = Bool()\n  val hSync = Bool()\n  val colorEn = Bool()\n  val color = Bits(rgbConfig.colorWidth bits)\n\n  override def asMaster(): Unit = {\n    out(vSync, hSync, colorEn, color)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: ReadableOpenDrain Bundle Usage Example - Scala\nDESCRIPTION: Illustrates how to use the ReadableOpenDrain bundle as a master interface for a 32-bit data bus.  The example shows assigning a value to the 'write' signal and reading from the 'read' signal with a conditional statement. This example requires SpinalHDL and a hardware description context to execute.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/IO/readableOpenDrain.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval io = new Bundle {\n  val dataBus = master(ReadableOpenDrain(Bits(32 bits)))\n}\n\nio.dataBus.write := 0x12345678\nwhen(io.dataBus.read === 42) {\n\n}\n```\n\n----------------------------------------\n\nTITLE: SpinalHDL Internal Logic in Scala\nDESCRIPTION: This code snippet shows how to implement internal logic within a SpinalHDL component using Scala. It includes register declaration with an initial value, conditional assignment using `when`, and unconditional assignments to output ports. The register `counter` stores an 8-bit unsigned integer.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Introduction/A simple example.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval counter = Reg(UInt(8 bits)) init(0)\n\nwhen(io.cond0) {\n  counter := counter + 1\n}\n\nio.state := counter\nio.flag := (counter === 0) | io.cond1\n```\n\n----------------------------------------\n\nTITLE: External Clock Example in Scala\nDESCRIPTION: This code provides an example of using an external clock domain. It shows how the `ClockDomain.external` function creates `myClockName_clk` and `myClockName_reset` signals at the top level of the design and uses an area with the external clock domain.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nclass ExternalClockExample extends Component {\n  val io = new Bundle {\n    val result = out UInt (4 bits)\n  }\n\n  // On the top level you have two signals  :\n  //     myClockName_clk and myClockName_reset\n  val myClockDomain = ClockDomain.external(\"myClockName\")\n\n  val myArea = new ClockingArea(myClockDomain) {\n    val myReg = Reg(UInt(4 bits)) init(7)\n    myReg := myReg + 1\n\n    io.result := myReg\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: VHDL Bus Definition (Wire-by-Wire)\nDESCRIPTION: This VHDL code demonstrates defining a bus interface by declaring each signal individually. This approach is verbose and requires repeating the definitions for each instance of the bus.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_7\n\nLANGUAGE: ada\nCODE:\n```\n   PADDR   : in unsigned(addressWidth-1 downto 0);\n   PSEL    : in std_logic\n   PENABLE : in std_logic;\n   PREADY  : out std_logic;\n   PWRITE  : in std_logic;\n   PWDATA  : in std_logic_vector(dataWidth-1 downto 0);\n   PRDATA  : out std_logic_vector(dataWidth-1 downto 0);\n```\n\n----------------------------------------\n\nTITLE: Enabling Forking in build.sbt for SpinalSim (Scala)\nDESCRIPTION: This code snippet enables forking in the SBT build file. Forking allows the simulation process to run in a separate JVM, which can be necessary for SpinalSim to function correctly.  This setting is crucial for simulation stability and resource management. No specific inputs or outputs are directly involved in this snippet.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/install/index.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nfork := true\n```\n\n----------------------------------------\n\nTITLE: Factorized Is Clauses in Switch Statement in Scala\nDESCRIPTION: Demonstrates factorizing `is` clauses in a `switch` statement by separating values with a comma, which is equivalent to a logical OR. It simplifies code when multiple values should execute the same block.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/when_switch.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nswitch(aluop) {\n  is(ALUOp.add, ALUOp.slt, ALUOp.sltu) {\n      immediate := instruction.immI.signExtend\n  }\n  is(ALUOp.sll, ALUOp.sra) {\n      immediate := instruction.shamt\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Verilog Implementation with Unnamed Register Naming\nDESCRIPTION: This Verilog code demonstrates how SpinalHDL names the unnamed register from the previous Scala example.  It uses the name of the signal driven by the register ('value') as a postfix, creating the signal '_zz_value'.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_24\n\nLANGUAGE: verilog\nCODE:\n```\n    module MyComponent (\n      input               enable,\n      output     [7:0]    value,\n      input               clk,\n      input               reset\n    );\n      // Name given to the register in last resort by looking what was driven by it\n      reg        [7:0]    _zz_value;\n\n      assign value = _zz_value;\n      always @ (posedge clk) begin\n        if(enable)begin\n          _zz_value <= (_zz_value + 8'h01);\n        end\n      end\n    endmodule\n```\n\n----------------------------------------\n\nTITLE: Boot and Sync Reset Configuration in Scala\nDESCRIPTION: This example shows how to specify the register's reset kind using `withBootReset()` and `withSyncReset()` on a clock domain, resulting in either BOOT or SYNC (synchronous) reset behavior.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nclass  Top extends Component {\n    val io = new Bundle {\n      val data = in Bits(8 bit)\n      val a, b, c, d = out Bits(8 bit)\n    }\n    io.a  :=  RegNext(io.data) init 0\n    io.b  :=  clockDomain.withBootReset()  on RegNext(io.data) init 0\n    io.c  :=  clockDomain.withSyncReset()  on RegNext(io.data) init 0\n    io.d  :=  clockDomain.withAsyncReset() on RegNext(io.data) init 0\n}\nSpinalVerilog(new Top)\n```\n\n----------------------------------------\n\nTITLE: Importing SpinalHDL core and sim libraries in Scala\nDESCRIPTION: This snippet demonstrates the necessary imports in a Scala testbench for using SpinalHDL, specifically for core functionalities and simulation utilities. These imports are crucial for defining hardware components and running simulations.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/install/Verilator.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core._\nimport spinal.core.sim._\n```\n\n----------------------------------------\n\nTITLE: Using the Rgb Bundle in SpinalHDL (Scala)\nDESCRIPTION: This code demonstrates how to define and clone Rgb signals using the Rgb bundle class defined earlier. `myRgbSignal` is defined directly with width parameters, while `myRgbCloned` is created as a clone of `myRgbSignal`, ensuring that it has the same data type. This illustrates how to instantiate and reuse custom data types in SpinalHDL.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/interaction.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n// Define an Rgb signal\nval myRgbSignal = Rgb(5, 6, 5)               \n\n// Define another Rgb signal of the same data type as the preceding one\nval myRgbCloned = cloneOf(myRgbSignal)\n```\n\n----------------------------------------\n\nTITLE: Compiling SpinalHDL Library with Mill\nDESCRIPTION: This snippet compiles the SpinalHDL library using Mill. It provides an equivalent command using SBT for comparison. The command will compile the source code of the SpinalHDL project.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/mill support.rst#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmill __.compile\nsbt compile # equivalent alternatives\n```\n\n----------------------------------------\n\nTITLE: Adding AXI4 Master-Slave Connections in Scala\nDESCRIPTION: This code demonstrates how to define the visibility matrix between AXI4 masters and slaves using the `addConnections` function. This specifies which slaves are accessible by each master in the system.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\n//         Master -> List of slaves which are accessible\n\naxiCrossbar.addConnections(\n  core.io.i       -> List(ram.io.axi, sdramCtrl.io.axi),\n  core.io.d       -> List(ram.io.axi, sdramCtrl.io.axi, apbBridge.io.axi),\n  jtagCtrl.io.axi -> List(ram.io.axi, sdramCtrl.io.axi, apbBridge.io.axi),\n  vgaCtrl.io.axi  -> List(            sdramCtrl.io.axi)\n)\n```\n\n----------------------------------------\n\nTITLE: SpinalHDL Stream Queue Function\nDESCRIPTION: This SpinalHDL code showcases a function within a Stream Bundle that instantiates a FIFO component. The 'queue' function creates a 'StreamFifo' and connects it to the Stream Bundle's input and output, demonstrating component instantiation within a function.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n   class Stream[T <: Data](dataType:  T) extends Bundle with IMasterSlave with DataCarrier[T] {\n     val valid = Bool()\n     val ready = Bool()\n     val payload = cloneOf(dataType)\n\n     def queue(size: Int): Stream[T] = {\n       val fifo = new StreamFifo(dataType, size)\n       fifo.io.push <> this\n       fifo.io.pop\n     }\n   }\n```\n\n----------------------------------------\n\nTITLE: RGB Bundle Definition - Scala\nDESCRIPTION: Defines a case class RGB as a Bundle in SpinalHDL, representing a color with red, green, and blue channels. It also includes a method isBlack to check if the color is black.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/stream.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase class RGB(channelWidth : Int) extends Bundle {\n  val red   = UInt(channelWidth bits)\n  val green = UInt(channelWidth bits)\n  val blue  = UInt(channelWidth bits)\n\n  def isBlack : Bool = red === 0 && green === 0 && blue === 0\n}\n```\n\n----------------------------------------\n\nTITLE: Register without Reset VHDL Implementation\nDESCRIPTION: This VHDL code snippet presents a register implementation without an explicit reset. The `regWithoutReset` register is assigned the value of `io_value` when the condition `io_cond` is true, and is otherwise assigned to \"0000\" every clock cycle. Requires `pkg_unsigned`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/vhdl_generation.rst#_snippet_8\n\nLANGUAGE: VHDL\nCODE:\n```\n   process(clk)\n   begin\n     if rising_edge(clk) then\n       regWithoutReset <= pkg_unsigned(\"0000\");\n       if io_cond = '1' then\n         regWithoutReset <= io_value;\n       end if;\n     end if;\n   end process;\n```\n\n----------------------------------------\n\nTITLE: Iterating and Mapping Vec Elements - Scala\nDESCRIPTION: This code demonstrates how to iterate through the elements of a Vec using a for loop and how to use the map function to apply an operation to each element. It showcases common methods for processing Vec elements.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Vec.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// Iterate on a vector\nfor(element <- myVecOf_xyz_ref) {\n  element := 0   // Assign x, y, z with the value 0\n}\n\n// Map on vector\nmyVecOfMixedUInt.map(_ := 0) // Assign all elements with value 0\n\n// Assign 3 to the first element of the vector\nmyVecOf_xyz_ref(1) := 3\n```\n\n----------------------------------------\n\nTITLE: Parameterized Component in SpinalHDL\nDESCRIPTION: This snippet defines a parameterized component `Arbiter` in SpinalHDL. It takes a payload type `T` (constrained to be a subtype of Data) and a port count as parameters. It demonstrates how to create a generic component with flexible input and output types.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nclass Arbiter[T <: Data](payloadType: T, portCount: Int) extends Component {\n  val io = new Bundle {\n    val sources = Vec(slave(Stream(payloadType)), portCount)\n    val sink = master(Stream(payloadType))\n  }\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: HDL Attributes Example\nDESCRIPTION: This Verilog code shows an example of HDL attributes that can be added to RAM implementations. These attributes specify characteristics like `ram_style` (distributed) and `ramsyle` (no_rw_check). SpinalHDL can insert these attributes based on the configured device vendor, or they can be added manually using `addAttribute()`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Sequential logic/memory.rst#_snippet_9\n\nLANGUAGE: Verilog\nCODE:\n```\n   (* ram_style = \"distributed\" *)\n   (* ramsyle = \"no_rw_check\" *)\n```\n\n----------------------------------------\n\nTITLE: Component Instantiation in SpinalHDL (Scala)\nDESCRIPTION: This snippet demonstrates how to instantiate a SpinalHDL component. It shows how to connect signals to the sub-component's IO bundle. The example illustrates setting values for input signals a, b, and c, and reads the result from mySubComponent.io.result.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_perspective.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ncase class TopLevel extends Component {\n  ...\n  val mySubComponent = MyComponent(offset = 5)\n\n  ...\n\n  mySubComponent.io.a := 1\n  mySubComponent.io.b := 2\n  mySubComponent.io.c := 3\n  ??? := mySubComponent.io.result\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Node API in Area Scala\nDESCRIPTION: This snippet illustrates how to create a new Area that provides the entire API of a given node instance, including implicit conversions, without requiring explicit imports.  It shows insertion and implicit payload conversion within the Area.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval n1 = Node()\n    val VALUE = Payload(UInt(16 bits))\n\n    val n1Stuff = new n1.Area {\n        val PLUS_ONE = insert(VALUE) + 1 // Equivalent to n1.insert(n1(VALUE)) + 1\n    }\n```\n\n----------------------------------------\n\nTITLE: SpinalHDL Process Equivalent\nDESCRIPTION: This SpinalHDL code provides an equivalent implementation of the VHDL process example, showcasing SpinalHDL's more concise syntax and implicit clock domain management. It uses the 'when' construct to conditionally update registers and signals.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n   val mySignal = Bool()\n   val myRegister = Reg(UInt(4 bits))\n   val myRegisterWithReset = Reg(UInt(4 bits)) init(0)\n\n   mySignal := False\n   when(cond) {\n     mySignal := True\n     myRegister := myRegister + 1\n     myRegisterWithReset := myRegisterWithReset + 1\n   }\n```\n\n----------------------------------------\n\nTITLE: Instantiating On-Chip RAM Scala\nDESCRIPTION: This code instantiates the AXI4 on-chip RAM. It configures parameters such as data width, byte count, and ID width. It uses Axi4Shared instead of full AXI4 to save area while maintaining interoperability.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval ram = Axi4SharedOnChipRam(\n  dataWidth = 32,\n  byteCount = 4 KiB,\n  idWidth = 4     // Specify the AXI4 ID width.\n)\n```\n\n----------------------------------------\n\nTITLE: Hierarchy Violation Example - Assigning to Input Signal - Scala\nDESCRIPTION: This example demonstrates a hierarchy violation in SpinalHDL by attempting to assign a value to an input signal of the current component. The `TopLevel` component defines an input signal `io.a` and then tries to assign the value of `tmp` to it, causing the error.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/hierarchy_violation.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val io = new Bundle {\n    // This is an 'in' signal of the current component 'Toplevel'\n    val a = in UInt(8 bits)\n  }\n  val tmp = U\"x42\"\n  io.a := tmp  // ERROR: attempting to assign to an input of current component\n}\n```\n\n----------------------------------------\n\nTITLE: Scala workaround for SpinalHDL Area instantiation\nDESCRIPTION: This code snippet illustrates a workaround in Scala for instantiating SpinalHDL Areas when direct instantiation is not allowed. It defines a class extending a NodeMirror and uses this class to create the Area, potentially improving code maintainability and readability in larger projects.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nclass NodeArea(at : Int) extends NodeMirror(nodes(at))\nval adder = new NodeArea(addAt) {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: SpinalHDL Function with Register\nDESCRIPTION: This SpinalHDL code demonstrates defining a function that combines combinational logic and a register.  The function 'simpleAluPipeline' calculates a result based on the 'op' input and then registers the result using 'RegNext'.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n   def simpleAluPipeline(op: Bits, a: UInt, b: UInt): UInt = {\n     val result = UInt(8 bits)\n\n     switch(op) {\n       is(0){ result := a + b }\n       is(1){ result := a - b }\n       is(2){ result := a * b }\n     }\n\n     return RegNext(result)\n   }\n```\n\n----------------------------------------\n\nTITLE: Unsigned to Integer Casting in SpinalHDL\nDESCRIPTION: This snippet shows how SpinalHDL simplifies array indexing by allowing UInt types to be used directly as indices, eliminating the need for casting between unsigned and integer types. The `arraySel` is assigned the value at the index `sel` in the `array`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nval array = Vec(UInt(4 bits),8)\nval sel = UInt(3 bits)\nval arraySel = array(sel) // Arrays are indexed directly by using UInt\n```\n\n----------------------------------------\n\nTITLE: Allowing Out-of-Range Literals for Comparison (Scala)\nDESCRIPTION: This snippet shows how to whitelist a specific instance of a comparison with an out-of-range constant in SpinalHDL.  By calling `.allowOutOfRangeLiterals` on the comparison, the error is suppressed, and the comparison is allowed. This is useful when the comparison result is statically known due to design parametrization.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/out_of_range_constant.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval value = in UInt(2 bits)\nval result = out((value < 42).allowOutOfRangeLiterals)\n```\n\n----------------------------------------\n\nTITLE: Nested Calls with Name Preservation (Scala)\nDESCRIPTION: Presents a component using the Stream class with nested calls to queue and m2sPipe. This demonstrates how Composites allow for nested calls while preserving signal names, creating understandable and maintainable hardware designs.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nclass MyComponent extends Component {\n  val source = slave(Stream(UInt(8 bits)))\n  val sink = master(Stream(UInt(8 bits)))\n  sink << source.queue(size = 16).m2sPipe()\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Java 17 on macOS with Homebrew\nDESCRIPTION: This snippet shows how to install Java JDK 17 on macOS using Homebrew. It uses the `brew install` command to install the `openjdk@17` package. Requires Homebrew to be installed.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Install and setup.rst#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nbrew install openjdk@17\n```\n\n----------------------------------------\n\nTITLE: Declaring a True Dual Port RAM Component in VHDL\nDESCRIPTION: This VHDL code declares a true dual-port RAM component with two independent read-write ports (A and B). Each port has its own clock, enable, write enable, mask, address, write data, and read data signals.  Generics include word count, word width, clock crossing flag, technology, and specific parameters for each port (read-under-write, address width, data width, mask width, mask enable). This allows simultaneous read and write operations on both ports.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Sequential logic/memory.rst#_snippet_8\n\nLANGUAGE: VHDL\nCODE:\n```\n   component Ram_2wrs is\n     generic(\n       wordCount : integer;\n       wordWidth : integer;\n       clockCrossing : boolean;\n       technology : string;\n       portA_readUnderWrite : string;\n       portA_addressWidth : integer;\n       portA_dataWidth : integer;\n       portA_maskWidth : integer;\n       portA_maskEnable : boolean;\n       portB_readUnderWrite : string;\n       portB_addressWidth : integer;\n       portB_dataWidth : integer;\n       portB_maskWidth : integer;\n       portB_maskEnable : boolean\n     );\n     port(\n       portA_clk : in std_logic;\n       portA_en : in std_logic;\n       portA_wr : in std_logic;\n       portA_mask : in std_logic_vector;\n       portA_addr : in unsigned;\n       portA_wrData : in std_logic_vector;\n       portA_rdData : out std_logic_vector;\n       portB_clk : in std_logic;\n       portB_en : in std_logic;\n       portB_wr : in std_logic;\n       portB_mask : in std_logic_vector;\n       portB_addr : in unsigned;\n       portB_wrData : in std_logic_vector;\n       portB_rdData : out std_logic_vector\n     );\n   end component;\n```\n\n----------------------------------------\n\nTITLE: Using CombInit in SpinalHDL\nDESCRIPTION: Illustrates the use of CombInit to create a copy of a signal and its current combinatorial assignments. This allows the copied signal to be overwritten later without affecting the original signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/assignments.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval a = UInt(8 bits)\na := 1\n\nval b = a\nwhen(sel) {\n    b := 2\n    // At this point, a and b are evaluated to 2: they reference the same signal\n}\n\nval c = UInt(8 bits)\nc := 1\n\nval d = CombInit(c)\n// Here c and d are evaluated to 1\nwhen(sel) {\n    d := 2\n    // At this point c === 1 and d === 2.\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Verilog for USB Device Top\nDESCRIPTION: This code snippet generates Verilog code from the `UsbDeviceTop` component defined above. It uses the `SpinalVerilog` function from SpinalHDL to perform the hardware description language (HDL) generation. This allows you to simulate or synthesize the defined USB device design.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Com/usb_device.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject UsbDeviceGen extends App {\n  SpinalVerilog(new UsbDeviceTop())\n}\n\n```\n\n----------------------------------------\n\nTITLE: Function Definition in Scala\nDESCRIPTION: This code defines a function named `sumBiggerThanZero` in Scala. It takes two `Float` arguments, `a` and `b`, and returns a `Boolean` indicating whether their sum is greater than zero. The `return` keyword is explicitly used here.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef sumBiggerThanZero(a: Float, b: Float): Boolean = {\n  return (a + b) > 0\n}\n```\n\n----------------------------------------\n\nTITLE: Re-time RGB Pipeline - Scala\nDESCRIPTION: This snippet re-times the RGB pipeline by performing both the addition and inversion operations in the same stage (stage 0). This can be useful for reducing the overall latency of the pipeline or for optimizing resource utilization.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\nSpinalVerilog(\n  new RgbToSomething(\n    addAt    = 0,\n    invAt    = 0,\n    mulAt    = 1,\n    resultAt = 2\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Memory Transfers - Scala\nDESCRIPTION: This snippet demonstrates how to use the `spinal.lib.system.tag.MemoryConnection.getMemoryTransfers` tool to identify memory access permissions for a master in a Tilelink system. It retrieves the memory mappings and transfers, printing them to stdout.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/tilelink/tilelink_fabric.rst#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval mappings = spinal.lib.system.tag.MemoryConnection.getMemoryTransfers(down)\n// Here we just print the values out in stdout, but instead you can generate some hardware from it.\nfor(mapping <- mappings) {\n  println(s\"- ${mapping.where} -> ${mapping.transfers}\")\n}\n```\n\n----------------------------------------\n\nTITLE: VGA Timings Functions Definition in Scala\nDESCRIPTION: Provides functions to set the timings for specific resolutions and frame rates using the VgaTimingsHV data structure. The included code snippet presents the structure itself.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Intermediates ones/vga.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ncase class VgaTimingsHV(timingsWidth: Int) extends Bundle {\n  case class HV() extends Bundle {\n    val syncStart = UInt(timingsWidth bits)\n    val syncEnd = UInt(timingsWidth bits)\n    val colorStart = UInt(timingsWidth bits)\n    val colorEnd = UInt(timingsWidth bits)\n  }\n\n  val h = HV()\n  val v = HV()\n```\n\n----------------------------------------\n\nTITLE: CtrlLink Usage Scala\nDESCRIPTION: This snippet demonstrates how to use CtrlLink to connect two nodes with optional flow control and bypass logic. It showcases the `haltWhen` and `haltIt` methods for flow control.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval c01 = CtrlLink(n0, n1)\n\n    c01.haltWhen(something) // Explicit halt request\n\n    when(somethingElse) {\n        // Conditional scope sensitive halt request, same as c01.haltWhen(somethingElse)\n        c01.haltIt() \n    }\n```\n\n----------------------------------------\n\nTITLE: Valid Input Definition in SpinalHDL (Scala)\nDESCRIPTION: This code snippet shows the correct way to define an input signal in SpinalHDL.  The input 'a' is defined as a standard UInt, without the Reg wrapper. If registration is desired, it must be done inside the component.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/register_defined_as_component_input.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val io = new Bundle {\n    val a = in UInt(8 bits)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Identity Component in SpinalHDL\nDESCRIPTION: This code defines a simple identity component in SpinalHDL. The component takes 'n' bits as input 'a' and outputs the same bits as 'z'. This example showcases a basic hardware definition in SpinalHDL.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/bootstraps.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core._\n\n// Identity takes n bits in a and gives them back in z\nclass Identity(n: Int) extends Component {\n  val io = new Bundle {\n    val a = in Bits(n bits)\n    val z = out Bits(n bits)\n  }\n\n  io.z := io.a\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing with Masked Literals\nDESCRIPTION: Shows how to compare a bit vector with a masked literal in SpinalHDL using Scala. Masked literals use '-' to represent don't care bits.  The example demonstrates comparing `myBits` with different masked literals.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bits.rst#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval myBits = B\"1101\"\n\nval test1 = myBits === M\"1-01\" // True\nval test2 = myBits === M\"0---\" // False\nval test3 = myBits === M\"1--1\" // True\n```\n\n----------------------------------------\n\nTITLE: Register with Only Init - Scala\nDESCRIPTION: This code defines a SpinalHDL component where the register 'a' is initialized but not assigned to anywhere else except conditionally.  SpinalHDL will throw an UNASSIGNED REGISTER error if \"something\" is never true.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/unassigned_register.rst#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass TopLevel extends Component {\n  val result = out(UInt(8 bits))\n  val a = Reg(UInt(8 bits)) init(42)\n\n  if(something)\n    a := somethingElse\n  result := a\n}\n```\n\n----------------------------------------\n\nTITLE: Globally Allowing Out-of-Range Literals in SpinalHDL (Scala)\nDESCRIPTION: This snippet demonstrates how to globally allow comparisons to out-of-range constants for the entire design in SpinalHDL. This is achieved by setting the `allowOutOfRangeLiterals` property of the `SpinalConfig` to `true`.  This disables the out-of-range constant checks for all comparisons.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/out_of_range_constant.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nSpinalConfig(allowOutOfRangeLiterals = true)\n```\n\n----------------------------------------\n\nTITLE: Registering Input Signal Inside Component (Scala)\nDESCRIPTION: This code demonstrates how to register an input signal within the SpinalHDL component. The input 'a' is first defined as a standard UInt in the 'io' bundle, and then it is registered using 'RegNext' inside the component logic.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/register_defined_as_component_input.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val io = new Bundle {\n    val a = in UInt(8 bits)\n  }\n  val a = RegNext(io.a)\n}\n```\n\n----------------------------------------\n\nTITLE: Implicit Payload Conversion in Node Scala\nDESCRIPTION: This snippet showcases implicit conversions between Payload and its data representation within a Node's context. It demonstrates how to insert a payload's value plus one into a new payload.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval VALUE = Payload(UInt(16 bits))\n    val n1 = new Node {\n        // VALUE is implicitly converted into its n1(VALUE) representation\n        val PLUS_ONE = insert(VALUE + 1) \n    }\n```\n\n----------------------------------------\n\nTITLE: Generated Verilog Module - Verilog\nDESCRIPTION: This is the generated Verilog code for the `RgbToSomething` module. It shows the input and output signals, internal wires and registers, and the logic for each stage of the pipeline. The module includes pipeline registers to separate the stages and implements the RGB processing operations. The code includes valid and ready signals for flow control.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_25\n\nLANGUAGE: Verilog\nCODE:\n```\n// Generator : SpinalHDL dev    git head : 1259510dd72697a4f2c388ad22b269d4d2600df7\n// Component : RgbToSomething\n// Git hash  : 63da021a1cd082d22124888dd6c1e5017d4a37b2\n\n`timescale 1ns/1ps\n\nmodule RgbToSomething (\n  input  wire          io_up_valid,\n  output wire          io_up_ready,\n  input  wire [7:0]    io_up_payload_r,\n  input  wire [7:0]    io_up_payload_g,\n  input  wire [7:0]    io_up_payload_b,\n  output wire          io_down_valid,\n  input  wire          io_down_ready,\n  output wire [15:0]   io_down_payload,\n  input  wire          clk,\n  input  wire          reset\n);\n\n  wire       [7:0]    _zz_nodes_0_adder_SUM;\n  reg        [15:0]   nodes_3_multiplier_MUL;\n  wire       [15:0]   nodes_2_multiplier_MUL;\n  reg        [7:0]    nodes_2_inverter_INV;\n  wire       [7:0]    nodes_1_inverter_INV;\n  reg        [7:0]    nodes_1_adder_SUM;\n  wire       [7:0]    nodes_0_adder_SUM;\n  wire       [7:0]    nodes_0_inserter_RGB_r;\n  wire       [7:0]    nodes_0_inserter_RGB_g;\n  wire       [7:0]    nodes_0_inserter_RGB_b;\n  wire                nodes_0_valid;\n  reg                 nodes_0_ready;\n  reg                 nodes_1_valid;\n  reg                 nodes_1_ready;\n  reg                 nodes_2_valid;\n  reg                 nodes_2_ready;\n  reg                 nodes_3_valid;\n  wire                nodes_3_ready;\n  wire                when_StageLink_l56;\n  wire                when_StageLink_l56_1;\n  wire                when_StageLink_l56_2;\n\n  assign _zz_nodes_0_adder_SUM = (nodes_0_inserter_RGB_r + nodes_0_inserter_RGB_g);\n  assign nodes_0_valid = io_up_valid;\n  assign io_up_ready = nodes_0_ready;\n  assign nodes_0_inserter_RGB_r = io_up_payload_r;\n  assign nodes_0_inserter_RGB_g = io_up_payload_g;\n  assign nodes_0_inserter_RGB_b = io_up_payload_b;\n  assign nodes_0_adder_SUM = (_zz_nodes_0_adder_SUM + nodes_0_inserter_RGB_b);\n  assign nodes_1_inverter_INV = (~ nodes_1_adder_SUM);\n  assign nodes_2_multiplier_MUL = (nodes_2_inverter_INV * 8'hee);\n  assign io_down_valid = nodes_3_valid;\n  assign nodes_3_ready = io_down_ready;\n  assign io_down_payload = nodes_3_multiplier_MUL;\n  always @(*) begin\n    nodes_0_ready = nodes_1_ready;\n    if(when_StageLink_l56) begin\n      nodes_0_ready = 1'b1;\n    end\n  end\n\n  assign when_StageLink_l56 = (! nodes_1_valid);\n  always @(*) begin\n    nodes_1_ready = nodes_2_ready;\n    if(when_StageLink_l56_1) begin\n      nodes_1_ready = 1'b1;\n    end\n  end\n\n  assign when_StageLink_l56_1 = (! nodes_2_valid);\n  always @(*) begin\n    nodes_2_ready = nodes_3_ready;\n    if(when_StageLink_l56_2) begin\n      nodes_2_ready = 1'b1;\n    end\n  end\n\n  assign when_StageLink_l56_2 = (! nodes_3_valid);\n  always @(posedge clk or posedge reset) begin\n    if(reset) begin\n      nodes_1_valid <= 1'b0;\n      nodes_2_valid <= 1'b0;\n      nodes_3_valid <= 1'b0;\n    end else begin\n      if(nodes_0_ready) begin\n        nodes_1_valid <= nodes_0_valid;\n      end\n      if(nodes_1_ready) begin\n        nodes_2_valid <= nodes_1_valid;\n      end\n      if(nodes_2_ready) begin\n        nodes_3_valid <= nodes_2_valid;\n      end\n    end\n  end\n\n  always @(posedge clk) begin\n    if(nodes_0_ready) begin\n      nodes_1_adder_SUM <= nodes_0_adder_SUM;\n    end\n    if(nodes_1_ready) begin\n      nodes_2_inverter_INV <= nodes_1_inverter_INV;\n    end\n    if(nodes_2_ready) begin\n      nodes_3_multiplier_MUL <= nodes_2_multiplier_MUL;\n    end\n  end\n\n\nendmodule\n```\n\n----------------------------------------\n\nTITLE: Int/Long/BigInt to Binary-List Conversion in Scala\nDESCRIPTION: Shows how to convert Int, Long and BigInt values to binary lists using the `toBinInts` method. It demonstrates usage with different number types and bases, requiring the `spinal.core.lib._` import. The example outputs are provided to illustrate the functionality.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/binarySystem.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core.lib._\n\n   $: 32.toBinInts\n   List(0, 0, 0, 0, 0, 1)\n   $: 1302309988L.toBinInts\n   List(0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1)\n   $: BigInt(\"100101110\", 2).toBinInts\n   List(0, 1, 1, 1, 0, 1, 0, 0, 1)\n   $: BigInt(\"123456789abcdef0\", 16).toBinInts\n   List(0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1)\n   $: BigInt(\"1234567\", 8).toBinInts\n   List(1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1)\n   $: BigInt(\"123451118\", 10).toBinInts\n   List(0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1)\n```\n\n----------------------------------------\n\nTITLE: Running Multiple Tests on the Same Hardware\nDESCRIPTION: This code demonstrates how to run multiple simulation tests on the same compiled hardware. It compiles the DUT once and then runs different simulation scenarios using doSim with different test names.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Simulation/bootstraps.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval compiled = SimConfig.withWave.compile(new Dut)\n\ncompiled.doSim(\"testA\") { dut =>\n   // Simulation code here\n}\n\ncompiled.doSim(\"testB\") { dut =>\n   // Simulation code here\n}\n```\n\n----------------------------------------\n\nTITLE: ReadableOpenDrain Bundle Definition - Scala\nDESCRIPTION: Defines the ReadableOpenDrain bundle with a parameterized data type. The bundle includes 'write' and 'read' signals of the specified data type. The 'asMaster' function sets 'write' as an output and 'read' as an input, implementing a master-slave interface.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/IO/readableOpenDrain.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class ReadableOpenDrain[T<: Data](dataType : HardType[T]) extends Bundle with IMasterSlave {\n  val write,read : T = dataType()\n\n  override def asMaster(): Unit = {\n    out(write)\n    in(read)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Hierarchy Violation - Changing Signal to Output - Scala\nDESCRIPTION: This example shows how to fix the hierarchy violation by changing the signal `io.a` from an input to an output. This allows the assignment `io.a := tmp` to be valid within the `TopLevel` component.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/hierarchy_violation.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val io = new Bundle {\n    val a = out UInt(8 bits) // changed from in to out\n  }\n  val tmp = U\"x42\"\n  io.a := tmp  // now we are assigning to an output\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New SpinalHDL Project from SpinalTemplateSbt\nDESCRIPTION: These commands clone the SpinalTemplateSbt repository into a new directory, initialize a fresh git repository, and make an initial commit. This provides a starting point for a new SpinalHDL project with a pre-configured directory structure and build setup.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Install and setup.rst#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\ngit clone --depth 1 https://github.com/SpinalHDL/SpinalTemplateSbt.git MySpinalProject\ncd MySpinalProject\nrm -rf .git\ngit init\ngit add .\ngit commit -m \"Initial commit from template\"\n```\n\n----------------------------------------\n\nTITLE: Scala Component with Unnamed Register\nDESCRIPTION: This Scala code creates a component with an intentionally unnamed register within a function. It demonstrates how SpinalHDL attempts to name unnamed signals by looking at the signal driven by it.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\n  class MyComponent extends Component {\n    val enable = in Bool()\n    val value = out UInt(8 bits)\n\n    def count(cond : Bool): UInt = {\n      val ret = Reg(UInt(8 bits)) // This register is not named (on purpose for the example)\n      when(cond) {\n        ret := ret + 1\n      }\n      return ret\n    }\n\n    value := count(enable)\n  }\n```\n\n----------------------------------------\n\nTITLE: Hierarchy Violation Error Message - Text\nDESCRIPTION: This snippet shows the error message generated when attempting to assign to an input signal, which causes the HIERARCHY VIOLATION. It is displayed by SpinalHDL to indicate the violation and the signals involved.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/hierarchy_violation.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nHIERARCHY VIOLATION : (toplevel/io_a : in UInt[8 bits]) is driven by (toplevel/tmp :  UInt[8 bits]), but isn't accessible in the toplevel component.\n  ***\n  Source file location of the `io.a := tmp` via the stack trace\n  ***\n```\n\n----------------------------------------\n\nTITLE: Allowing Directionless IO Signals - Scala\nDESCRIPTION: This code demonstrates how to explicitly allow a directionless signal 'a' within the IO bundle when needed for meta-hardware description reasons. The `allowDirectionLessIo` method is called on the signal 'a' to suppress the direction check.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/iobundle.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass TopLevel extends Component {\n  val io = new Bundle {\n    val a = UInt(8 bits)\n  }\n  a.allowDirectionLessIo\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Meta Refresh Redirection\nDESCRIPTION: This HTML snippet uses the meta refresh tag to redirect the user to a specified URL. The content attribute defines the delay (in seconds) before redirection, and the url attribute specifies the destination URL.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Cheatsheets/symbolic.rst#_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n<head>\n  <!-- HTML meta refresh URL redirection -->\n  <meta http-equiv=\"refresh\"\n  content=\"0; url=https://cdn.jsdelivr.net/gh/SpinalHDL/SpinalDoc@master/cheatsheet/cheatSheet_symbolic.pdf\">\n</head>\n```\n\n----------------------------------------\n\nTITLE: Accessing Class Construction Parameters in Scala\nDESCRIPTION: This demonstrates how to make class construction parameters accessible from outside the class by declaring them as `val`.  Without `val`, the constructor parameters are private to the class.  By declaring them as `val`, accessor methods are automatically generated.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nclass Color(val r: Float, val g: Float, val b: Float) { ... }\n...\nval blue = new Color(0, 0, 1)\nval redLevelOfBlue = blue.r\n```\n\n----------------------------------------\n\nTITLE: Color Bundle Definition - Scala\nDESCRIPTION: Defines a `Color` bundle in SpinalHDL with red, green, and blue channels. Each channel is a `UInt` with a specified width (channelWidth). This example demonstrates a practical use case of a bundle to represent a color with RGB components.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bundle.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class Color(channelWidth: Int) extends Bundle {\n  val r, g, b = UInt(channelWidth bits)\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Specified App with Mill\nDESCRIPTION: This snippet runs a specific application (spinal.xxxxx.xxxxx) within the SpinalHDL project using Mill. An equivalent SBT command is also included. Replace spinal.xxxxx.xxxxx with the fully qualified name of the application to run.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/mill support.rst#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nmill tester.runMain spinal.xxxxx.xxxxx\nsbt \"tester/runMain spinal.xxxxx.xxxxx\" # equivalent alternatives\n```\n\n----------------------------------------\n\nTITLE: Random Boot Value for Simulation in SpinalHDL\nDESCRIPTION: This code shows how to initialize a register with a random value for simulation purposes using the randBoot() function. This is useful to avoid x-propagation during simulation when a reset value is not needed in RTL.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Sequential logic/registers.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// UInt register of 4 bits initialized with a random value\nval reg1 = Reg(UInt(4 bits)) randBoot()\n```\n\n----------------------------------------\n\nTITLE: Cloning SpinalHDL Repository with Git\nDESCRIPTION: Clones the SpinalHDL repository from GitHub into a local directory. The `--depth 1` flag prevents downloading the full repository history, and `-b dev` specifies the branch to checkout.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/howotuselocalspinalclone.rst#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd /somewhere\ngit clone --depth 1 -b dev https://github.com/SpinalHDL/SpinalHDL.git\n```\n\n----------------------------------------\n\nTITLE: Adding Clock Domain Tag to AvalonMM/APB3\nDESCRIPTION: Adds a ClockDomainTag to an AvalonMM or APB3 bus interface.  This tag specifies the clock domain associated with the bus, which is required by QSys to properly configure the interface. The tag is added using the `addTag` method.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/EDA/altera/qsysify.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nio.bus addTag(ClockDomainTag(busClockDomain))\n```\n\n----------------------------------------\n\nTITLE: Building AXI4 Crossbar Factory in Scala\nDESCRIPTION: This code demonstrates the creation and building of an AXI4 crossbar using the Axi4CrossbarFactory in SpinalHDL. The factory is instantiated, configured with connections, and then built to generate the hardware.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nval axiCrossbar = Axi4CrossbarFactory()\n// Where you will have to call function the the axiCrossbar factory to populate its configuration\naxiCrossbar.build()\n```\n\n----------------------------------------\n\nTITLE: Scala Component with Conditional Assignment\nDESCRIPTION: This Scala code demonstrates a component with a conditional assignment using the 'when' statement.  The example illustrates how conditional logic is translated into Verilog.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\n  // In file Test.scala\n  class MyComponent extends Component {\n    val value = in UInt(8 bits)\n    val isZero = out(Bool())\n    val counter = out(Reg(UInt(8 bits)))\n\n    isZero := False\n    when(value === 0) { // At line 117\n      isZero := True\n      counter := counter + 1\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Case Class Definition in SpinalHDL (Scala)\nDESCRIPTION: Defines a case class `Color` in SpinalHDL, extending `Bundle`.  Case classes provide a `clone` function and avoid the need for the `new` keyword.  Construction parameters are directly visible from outside.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/coding_conventions.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class Color extends Bundle {\n\n   }\n```\n\n----------------------------------------\n\nTITLE: Generated Verilog Code for ClockEnableArea\nDESCRIPTION: This code shows the generated Verilog HDL code for a `ClockEnableArea`, illustrating the priority between clock enable and reset signals. The reset is only effective when clockEnable is asserted.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_10\n\nLANGUAGE: verilog\nCODE:\n```\nalways @(posedge clk) begin\n  if(clockedArea_newClockEnable) begin\n    if(!resetn) begin\n      clockedArea_reg <= 1'b0;\n    end else begin\n      clockedArea_reg <= io_input;\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: APB3 Usage Example in Scala\nDESCRIPTION: This Scala code demonstrates how to use the defined `Apb3` Bundle to create an APB3 bus interface with a specific configuration. It shows how to instantiate the `Apb3` Bundle with a given `Apb3Config`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Simple ones/apb3.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval apb3Config = Apb3Config(addressWidth = 32,dataWidth = 32,selWidth = 1)\nval apb3 = Apb3(apb3Config)\n```\n\n----------------------------------------\n\nTITLE: No Driver Error Output (Text)\nDESCRIPTION: This text snippet shows the error message generated by SpinalHDL when a signal has no driver. It indicates the signal's name, type, and location in the source code.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/no_driver_on.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nNO DRIVER ON (toplevel/a :  UInt[8 bits]), defined at\n  ***\n  Source file location of the toplevel/a definition via the stack trace\n  ***\n```\n\n----------------------------------------\n\nTITLE: VHDL Attribute Declaration Example\nDESCRIPTION: This VHDL code illustrates how the `addAttribute` function in SpinalHDL translates to a VHDL attribute declaration. The `keep` attribute is defined as a boolean and assigned the value `true` for the signal `pcPlus4`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/vhdl_generation.rst#_snippet_10\n\nLANGUAGE: VHDL\nCODE:\n```\n   attribute keep : boolean;\n   signal pcPlus4 : unsigned(31 downto 0);\n   attribute keep of pcPlus4: signal is true;\n```\n\n----------------------------------------\n\nTITLE: Conditional Hardware Generation with Scala if in SpinalHDL (Scala)\nDESCRIPTION: This code shows how a Scala `if` statement can be used to conditionally generate hardware in SpinalHDL.  The `generateAClearWhenHit42` Scala variable controls whether the logic to clear the counter when it hits 42 is generated. This allows for compile-time hardware customization based on Scala conditions. The `when` statement inside the if block is a hardware test.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/interaction.rst#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval counter = Reg(UInt(8 bits))\ncounter := counter + 1\nif(generateAClearWhenHit42) {  // Elaboration test, like an if generate in vhdl\n  when(counter === 42) {       // Hardware test\n    counter := 0\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise Operators - Scala\nDESCRIPTION: This snippet illustrates the use of bitwise operators on SInt values in SpinalHDL. It demonstrates how to perform bitwise AND, invert the result, and check the width of the resulting signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Int.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval a, b, c = SInt(32 bits)\na := S(5)\nb := S(10)\n\n// Bitwise operators\nc := ~(a & b)     // Inverse(a AND b)\nassert(c.getWidth == 32)\n```\n\n----------------------------------------\n\nTITLE: Companion Object Definition in SpinalHDL (Scala)\nDESCRIPTION: Defines companion objects `Fifo` and `MajorityVote` with `apply` methods.  Companion objects often contain factory methods or other utility functions. This example shows a common use case where companion object names start with an uppercase letter.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/coding_conventions.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject Fifo {\n     def apply(that: Stream[Bits]): Stream[Bits] = {...}\n   }\n\n   object MajorityVote {\n     def apply(that: Bits): UInt = {...}\n   }\n```\n\n----------------------------------------\n\nTITLE: Adding a Clock Enable Area in Scala\nDESCRIPTION: This example shows how to create a `ClockEnableArea` to add an additional clock enable signal to the current clock domain, effectively gating the clock for a specific region of the design.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n\n  val clockEnable = Bool()\n\n  // Add a clock enable for this area \n  val area_1 = new ClockEnableArea(clockEnable) {\n    val counter = out(CounterFreeRun(16).value)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Locally with Mill\nDESCRIPTION: This snippet publishes the SpinalHDL library to the local ivy2 repository as a 'dev' version using Mill. An equivalent SBT command is included for comparison. This allows the library to be used as a dependency in other local projects.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/mill support.rst#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nmill __.publishLocal\nsbt publishLocal # equivalent alternatives\n```\n\n----------------------------------------\n\nTITLE: Bitwise Selection with subDivideIn in Scala\nDESCRIPTION: Demonstrates a shorter way to divide a wide Bits type into smaller chunks using `subdivideIn`, with `sel` as the select signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/when_switch.rst#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval dataWord = data.subdivideIn(32 bits)(sel)\n```\n\n----------------------------------------\n\nTITLE: Bundle Definition in SpinalHDL (Scala)\nDESCRIPTION: This snippet defines a SpinalHDL Bundle, which is similar to a VHDL record. It includes a construction parameter (channelWidth) similar to VHDL generics. The Bundle contains three UInt signals representing RGB color channels.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_perspective.rst#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ncase class RGB(channelWidth: Int) extends Bundle {\n  val r, g, b = UInt(channelWidth bits)\n}\n```\n\n----------------------------------------\n\nTITLE: Verilog Code for CombInit example\nDESCRIPTION: Shows the Verilog code generated from the CombInit example.  Demonstrates how CombInit creates a new wire while a simple assignment by reference does not.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/assignments.rst#_snippet_5\n\nLANGUAGE: verilog\nCODE:\n```\nalways @(*) begin\n  a = 8'h01;\n  if(sel) begin\n    a = 8'h02;\n  end\nend\n\nassign c = 8'h01;\nalways @(*) begin\n  d = c;\n  if(sel) begin\n    d = 8'h02;\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Boolean Casting in SpinalHDL\nDESCRIPTION: This example demonstrates how SpinalHDL unifies boolean and std_logic types, eliminating the need for explicit casting. The result of a comparison (value > 2) is directly assigned to a Bool signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nval value = UInt(8 bits)\nval valueBiggerThanTwo = Bool()\nvalueBiggerThanTwo := value > 2  // value > 2 return a Bool\n```\n\n----------------------------------------\n\nTITLE: Bool Declaration and Assignment in SpinalHDL (Scala)\nDESCRIPTION: This snippet demonstrates how to declare and assign values to a Bool type in SpinalHDL using Scala syntax. It showcases different ways to assign boolean values, including using Scala booleans.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/types.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval myBool = Bool()\nmyBool := False         // := is the assignment operator\nmyBool := Bool(false)   // Use a Scala Boolean to create a literal\n```\n\n----------------------------------------\n\nTITLE: Companion Object as Function (Scala)\nDESCRIPTION: Defines a companion object `log2` used as a function. This object's name starts with a lowercase letter, as its `apply` function doesn't generate hardware. It's used simply as a mathematical utility.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/coding_conventions.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject log2 {\n     def apply(value: Int): Int = {...}\n   }\n```\n\n----------------------------------------\n\nTITLE: FIFO Class Definition (Scala)\nDESCRIPTION: Defines a generic FIFO class in SpinalHDL with type parameter `T`. Shows the syntax for defining a class with type parameters and constructor arguments. Differentiates between data type and depth parameters.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/coding_conventions.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nclass Fifo[T <: Data](dataType: T, depth: Int) extends Component {\n\n   }\n```\n\n----------------------------------------\n\nTITLE: Invalid Register Input Definition in SpinalHDL (Scala)\nDESCRIPTION: This code snippet demonstrates an invalid attempt to define a register directly as an input to a SpinalHDL component. This will result in a compilation error due to SpinalHDL's restriction on registered inputs.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/register_defined_as_component_input.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val io = new Bundle {\n    val a = in(Reg(UInt(8 bits)))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding InterruptReceiverTag to Interrupt Input\nDESCRIPTION: Adds an InterruptReceiverTag to an interrupt input signal.  This tag specifies the related memory interface and clock domain associated with the interrupt. This information is used by QSys to configure the interrupt correctly.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/EDA/altera/qsysify.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nio.interrupt addTag(InterruptReceiverTag(relatedMemoryInterfacei, interruptClockDomain))\n```\n\n----------------------------------------\n\nTITLE: Variable Declaration and Assignment in Scala\nDESCRIPTION: This code demonstrates how to declare and assign values to variables in Scala using the `var` keyword. It shows how to assign a value at declaration, reassign a value later, and perform an addition assignment.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nvar number : Int = 0\nnumber = 6\nnumber += 4\nprintln(number) // 10\n```\n\n----------------------------------------\n\nTITLE: Comparison Operators on Bits in SpinalHDL (Scala)\nDESCRIPTION: This example shows how to use equality (===) and inequality (=/=) comparison operators on Bits signals within SpinalHDL's when statements for conditional logic.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/bits.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nwhen(myBits === 3) {\n  // ...\n}\n\nval notMySpecialValue = myBits_32 =/= B\"32'x44332211\"\n```\n\n----------------------------------------\n\nTITLE: Function Definition Without Curly Braces in Scala\nDESCRIPTION: This example shows how to define a Scala function without curly braces when the function body consists of a single expression. The `sumBiggerThanZero` function directly returns the result of the expression `(a + b) > 0`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndef sumBiggerThanZero(a: Float, b: Float) = (a + b) > 0\n```\n\n----------------------------------------\n\nTITLE: Scala: Defining Scala Version in build.sbt\nDESCRIPTION: This snippet shows how to define the Scala version in a build.sbt file. The `scalaVersion` setting is used to specify the Scala version for the project. This is needed to match your project's scala version for local publishing.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Introduction/faq.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nThisBuild / scalaVersion := \"2.12.16\" // in build.sbt\n```\n\n----------------------------------------\n\nTITLE: Scope Violation Error Message\nDESCRIPTION: This text snippet is an example of the error message that is thrown in SpinalHDL when a scope violation occurs. It indicates the signal, type, bitsize and source location of the violating assignment.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/scope_violation.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nSCOPE VIOLATION : (toplevel/tmp :  UInt[8 bits]) is assigned outside its declaration scope at\n  ***\n  Source file location of the tmp := U\"x42\" via the stack trace\n  ***\n```\n\n----------------------------------------\n\nTITLE: Remove Output Register Stage - Scala\nDESCRIPTION: This snippet removes the output register stage from the RGB pipeline by setting `resultAt` to 1.  This reduces the pipeline depth and latency, but it may also affect the maximum operating frequency.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_27\n\nLANGUAGE: Scala\nCODE:\n```\nSpinalVerilog(\n  new RgbToSomething(\n    addAt    = 0,\n    invAt    = 0,\n    mulAt    = 1,\n    resultAt = 1\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Binary-List to Hex/Oct String Conversion in Scala\nDESCRIPTION: Shows how to convert a binary list to Hex or Oct string, aligning to times of 4 (Hex) or 3 (Oct) if needed. The functions `binIntsToHex`, `binIntsToHexAlignHigh`, `binIntsToOct` and `binIntsToHexAlignHigh` are used for the conversion. This does not require any specific imports within the given context.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/binarySystem.rst#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n$: List(1, 1, 1, 0, 0, 1).binIntsToHex\n   27\n   $: List(1, 1, 1, 0, 0, 1).binIntsToHexAlignHigh\n   9c\n   $: List(1, 1, 1, 0, 0, 1).binIntsToOct\n   47\n   $: List(1, 1, 1, 0, 0, 1).binIntsToHexAlignHigh\n   47\n```\n\n----------------------------------------\n\nTITLE: Type Inference in Scala Variable Declaration\nDESCRIPTION: This example illustrates how Scala can automatically infer the type of a variable based on the assigned value.  The `number` variable is inferred to be of type `Int` because it's initialized with an integer value.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nvar number = 0   // The type of 'number' is inferred as an Int during compilation.\n```\n\n----------------------------------------\n\nTITLE: Applying the IO Modification - SpinalHDL Scala\nDESCRIPTION: This snippet shows how to apply the ffIo function to a SpinalHDL Component using SpinalVerilog to generate Verilog code with the modified IO signals.  It is called with a Component instance.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/spinalhdl_datamodel.rst#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nSpinalVerilog(ffIo(new MyToplevel))\n```\n\n----------------------------------------\n\nTITLE: Divider Numerator Assignment\nDESCRIPTION: This snippet shows a direct assignment to a `numerator` signal within a `divider.io.cmd` structure. The value 42 is assigned to the signal.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ndivider.io.cmd.numerator := 42\n```\n\n----------------------------------------\n\nTITLE: Register with Reset VHDL Implementation\nDESCRIPTION: This VHDL code snippet shows a register implementation with a reset value. The register `regWithReset` is updated with the value of `io_value` on the rising edge of the clock signal `clk`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/vhdl_generation.rst#_snippet_7\n\nLANGUAGE: VHDL\nCODE:\n```\n     elsif rising_edge(clk) then\n       regWithReset <= io_value;\n     end if;\n   end process;\n```\n\n----------------------------------------\n\nTITLE: SpinalHDL Report with String Interpolation\nDESCRIPTION: This snippet shows the alternative syntax for the 'report' function in SpinalHDL using string interpolation, which allows embedding signal values directly into the string.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/report.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nreport(L\"miaou $a $b $c $d\")\n```\n\n----------------------------------------\n\nTITLE: Setting Java 17 PATH on macOS\nDESCRIPTION: This snippet shows how to configure the PATH environment variable to use the installed Java 17 on macOS after installation with Homebrew. It assumes Java 17 is installed in the default Homebrew location.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Install and setup.rst#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nexport PATH=\"/opt/homebrew/opt/openjdk@17/bin:$PATH\"\n```\n\n----------------------------------------\n\nTITLE: SpinalHDL Function Assigning Signal\nDESCRIPTION: This SpinalHDL code demonstrates a function modifying a signal that is defined outside of the function's scope.  The 'clear' function resets the 'counter' register to 0.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n   val counter = Reg(UInt(8 bits)) init(0)\n   counter := counter + 1\n\n   def clear() : Unit = {\n     counter := 0\n   }\n\n   when(counter > 42) {\n     clear()\n   }\n```\n\n----------------------------------------\n\nTITLE: If/When Statements (Scala)\nDESCRIPTION: Demonstrates the standard formatting for `if` and `when` statements in Scala and SpinalHDL, including `else if`/`elsewhen` and `else`/`otherwise` blocks.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/coding_conventions.rst#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nif(cond) {\n     ...\n   } else if(cond) {\n     ...\n   } else {\n     ...\n   }\n\n   when(cond) {\n     ...\n   } elsewhen(cond) {\n     ...\n   } otherwise {\n     ...\n   }\n```\n\n----------------------------------------\n\nTITLE: VHDL Bus Definition (Record)\nDESCRIPTION: This VHDL code illustrates defining a bus interface using records.  While it groups signals, it lacks parameterization and requires separate record definitions for different directions.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_8\n\nLANGUAGE: ada\nCODE:\n```\n   P_m : in APB_M;\n   P_s : out APB_S;\n```\n\n----------------------------------------\n\nTITLE: Instantiating VGA Controller Scala\nDESCRIPTION: This code instantiates the AXI4 VGA controller using the previously defined configuration. The vgaCtrlConfig object provides the necessary parameters for setting up the VGA.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nval vgaCtrl = Axi4VgaCtrl(vgaCtrlConfig)\n```\n\n----------------------------------------\n\nTITLE: Instantiating UART Controller Scala\nDESCRIPTION: This code instantiates the APB3 UART controller using the previously defined configuration. The uartCtrlConfig object provides the necessary parameters for setting up the UART.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval uartCtrl = Apb3UartCtrl(uartCtrlConfig)\n```\n\n----------------------------------------\n\nTITLE: SpinalHDL Bus Definition\nDESCRIPTION: This SpinalHDL code demonstrates how to define a bus interface using SpinalHDL's bus definition capabilities, allowing for parameterization and flexibility. The example utilizes the Apb3 interface.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\n   val P = slave(Apb3(addressWidth, dataWidth))\n```\n\n----------------------------------------\n\nTITLE: Adding ResetEmitterTag to Reset Output\nDESCRIPTION: Adds a ResetEmitterTag to a reset output signal. This tag specifies the clock domain associated with the reset output. This information is used by QSys to configure the reset signal correctly.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/EDA/altera/qsysify.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nio.resetOutput addTag(ResetEmitterTag(resetOutputClockDomain))\n```\n\n----------------------------------------\n\nTITLE: Run custom command in Docker container\nDESCRIPTION: Runs a Docker container with a custom command, such as 'make clean', which is executed within the mounted volume. The command is used to cleanup the documentation build directory.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/README.rst#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ndocker run -it --rm -v $PWD:/docs spinaldoc-rtd make clean\n```\n\n----------------------------------------\n\nTITLE: Resizing Signal in SpinalHDL (Traditional Way)\nDESCRIPTION: This shows the traditional way of resizing a signal in SpinalHDL. The `resize` method is called on `my4BitsSignal` to explicitly change its bit width to 8 bits.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\n// The traditional way\nmy8BitsSignal := my4BitsSignal.resize(8)\n```\n\n----------------------------------------\n\nTITLE: Resizing Signal in Ada\nDESCRIPTION: This Ada code demonstrates how to resize a signal. The `resize` function is used to change the bit width of `my4BitsSignal` to 8 bits before assigning it to `my8BitsSignal`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_18\n\nLANGUAGE: ada\nCODE:\n```\nmy8BitsSignal <= resize(my4BitsSignal, 8);\n```\n\n----------------------------------------\n\nTITLE: SpinalHDL Width Mismatch Error Message (Text)\nDESCRIPTION: This text snippet shows the error message produced by SpinalHDL when a width mismatch occurs during an assignment. It indicates the signals involved ('b' and 'a') and their respective widths (4 bits and 8 bits). This is output from compiling the above Scala code.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/width_mismatch.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nWIDTH MISMATCH on (toplevel/b :  UInt[4 bits]) := (toplevel/a :  UInt[8 bits]) at\n  ***\n  Source file location of the OR operator via the stack trace\n  ***\n```\n\n----------------------------------------\n\nTITLE: Defining Reset Controller Clock Domain Scala\nDESCRIPTION: This code defines the clock domain for the reset controller. It specifies the clock source (io.axiClk) and the reset kind (BOOT), indicating that the flip-flops in this domain are initialized by the FPGA bitstream. This setup is crucial for ensuring a clean reset sequence during system startup.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval resetCtrlClockDomain = ClockDomain(\n  clock = io.axiClk,\n  config = ClockDomainConfig(\n    resetKind = BOOT\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Verilog Display Message with Time\nDESCRIPTION: This Verilog snippet is the result of the SpinalHDL report function and demonstrates how to display the current simulation time.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/report.rst#_snippet_4\n\nLANGUAGE: verilog\nCODE:\n```\n$display(\"NOTE miaou %t\", $time);\n```\n\n----------------------------------------\n\nTITLE: APB Interface with IMasterSlave Implementation in Scala\nDESCRIPTION: This code shows a full implementation of an APB interface that extends the `IMasterSlave` trait in SpinalHDL.  It overrides the `asMaster()` function to define the output and input signals for the master interface. `spinal.lib` is imported.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/types.rst#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\n// You need to import spinal.lib._ to use IMasterSlave\n   import spinal.core._\n   import spinal.lib._\n\n   case class APBConfig(addressWidth: Int,\n                        dataWidth: Int,\n                        selWidth : Int,\n                        useSlaveError : Boolean)\n\n   class APB(val config: APBConfig) extends Bundle with IMasterSlave {\n     val PADDR      = UInt(addressWidth bits)\n     val PSEL       = Bits(selWidth bits)\n     val PENABLE    = Bool()\n     val PREADY     = Bool()\n     val PWRITE     = Bool()\n     val PWDATA     = Bits(dataWidth bits)\n     val PRDATA     = Bits(dataWidth bits)\n     val PSLVERROR  = if(useSlaveError) Bool() else null   // This signal is created only when useSlaveError is true\n\n     override def asMaster() : Unit = {\n       out(PADDR,PSEL,PENABLE,PWRITE,PWDATA)\n       in(PREADY,PRDATA)\n       if(useSlaveError) in(PSLVERROR)\n     }\n     // The asSlave is by default the flipped version of asMaster.\n   }\n```\n\n----------------------------------------\n\nTITLE: Specifying Initial Assumption - Scala\nDESCRIPTION: This snippet uses `assumeInitial` to specify an initial assumption about the state of the system. In this case, it assumes that the clock domain is in reset at the beginning of the verification.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Formal verification/index.rst#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nassumeInitial(clockDomain.isResetActive)\n```\n\n----------------------------------------\n\nTITLE: Build custom Docker image\nDESCRIPTION: Builds a custom Docker image named 'spinaldoc-rtd' using the Dockerfile in the current directory. This image will contain python and dependencies necessary to build the documentation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/README.rst#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ndocker build -t spinaldoc-rtd .\n```\n\n----------------------------------------\n\nTITLE: Configuring jenv in .bash_profile\nDESCRIPTION: These lines add jenv to the PATH and initialize jenv. These lines are meant to be added to your shell configuration file, such as `.bash_profile`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Install and setup.rst#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nexport PATH=\"$HOME/.jenv/bin:$PATH\"\neval \"$(jenv init -)\"\n```\n\n----------------------------------------\n\nTITLE: Instantiating Timer Controller Scala\nDESCRIPTION: This code instantiates the Pinsec timer controller. The PinsecTimerCtrl component includes a prescaler, a 32-bit timer, and three 16-bit timers.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/hardware_toplevel.rst#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval timerCtrl = PinsecTimerCtrl()\n```\n\n----------------------------------------\n\nTITLE: DirectLink Usage Scala\nDESCRIPTION: This snippet shows a basic example of using the DirectLink to connect two Nodes together. DirectLink provides a simple connection with only signals.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval c01 = DirectLink(n0, n1)\n```\n\n----------------------------------------\n\nTITLE: GDB Run Command\nDESCRIPTION: This code snippet is the GDB command to continue program execution.  After the target is initialized and the program is loaded, this command starts the application.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Legacy/pinsec/software.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\ncontinue\n```\n\n----------------------------------------\n\nTITLE: VHDL Signal Declaration\nDESCRIPTION: This VHDL code illustrates the requirement to declare all signals at the top of the architecture, separating declaration from usage.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_11\n\nLANGUAGE: VHDL\nCODE:\n```\n     ..\n     .. (many signal declarations)\n     ..\n     signal a : std_logic;\n     ..\n     .. (many signal declarations)\n     ..\n   begin\n     ..\n     .. (many logic definitions)\n     ..\n     a <= x & y\n     ..\n     .. (many logic definitions)\n     ..\n```\n\n----------------------------------------\n\nTITLE: Default ClockDomainConfig in Scala\nDESCRIPTION: This snippet shows the default ClockDomainConfig settings, which are rising clock edge, asynchronous reset, and active high reset.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/clock_domain.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval defaultCC = ClockDomainConfig(\n  clockEdge        = RISING,\n  resetKind        = ASYNC,\n  resetActiveLevel = HIGH\n)\n```\n\n----------------------------------------\n\nTITLE: Installing SBT on macOS with Homebrew\nDESCRIPTION: This snippet installs the Scala Build Tool (SBT) on macOS using Homebrew. It simplifies project builds.  Requires Homebrew.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Install and setup.rst#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nbrew install sbt\n```\n\n----------------------------------------\n\nTITLE: AvalonMM instantiation\nDESCRIPTION: This code snippet demonstrates how to create a write-only AvalonMM configuration with burst capabilities and byte enable using the AvalonMMConfig.bursted method, along with chained copy calls to configure burst and byte enable features. It also shows how to create an instance of the AvalonMM bus using the configured parameters.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/Bus/avalon/avalonmm.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// Create a write only AvalonMM configuration with burst capabilities and byte enable\n   val myAvalonConfig =  AvalonMMConfig.bursted(\n                           addressWidth = addressWidth,\n                           dataWidth = memDataWidth,\n                           burstCountWidth = log2Up(burstSize + 1)\n                         ).copy(\n                           useByteEnable = true,\n                           constantBurstBehavior = true,\n                           burstOnBurstBoundariesOnly = true\n                         ).getWriteOnlyConfig\n\n   // Create an instance of the AvalonMM bus by using this configuration\n   val bus = AvalonMM(myAvalonConfig)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Selection with muxList in Scala\nDESCRIPTION: This code demonstrates using `muxList` to divide a wide Bits type into smaller chunks based on a select signal. `muxList` requires full coverage of all possible values.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Semantic/when_switch.rst#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval sel  = UInt(2 bits)\nval data = Bits(128 bits)\n\n// Dividing a wide Bits type into smaller chunks, using a mux:\nval dataWord = sel.muxList(for (index <- 0 until 4)\n                           yield (index, data(index*32+32-1 downto index*32)))\n```\n\n----------------------------------------\n\nTITLE: Switch Statement (Scala)\nDESCRIPTION: Demonstrates the standard formatting for `switch` statements in SpinalHDL, including `is` and `default` blocks.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/coding_conventions.rst#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nswitch(value) {\n     is(key) {\n\n     }\n     is(key) {\n\n     }\n     default {\n\n     }\n   }\n```\n\n----------------------------------------\n\nTITLE: Signal Assignment in SpinalHDL (Scala)\nDESCRIPTION: This snippet shows how to assign a value to a signal in SpinalHDL using the := operator. This operator is equivalent to the VHDL signal assignment operator (<=).\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_perspective.rst#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval myUInt = UInt(8 bits)\nmyUInt := 6\n```\n\n----------------------------------------\n\nTITLE: SpinalUsage Interrupt Factory\nDESCRIPTION: Illustrates the basic usage of interruptFactory. Dependencies include a BusInterface and boolean signals.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nbusif.interruptFactory(\"T\", io.a, io.b, io.c, io.d, io.e)\n```\n\n----------------------------------------\n\nTITLE: Apply Function in Scala Object\nDESCRIPTION: This example illustrates the use of the `apply` function in a Scala object.  Similar to classes, when an object is called like a function (e.g., `MajorityVote(4)`), the `apply` method is invoked. This is commonly used for factory methods or to provide a concise syntax for certain operations.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nobject MajorityVote {\n  def apply(value: Int): Int = ...\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval value = MajorityVote(4) // Will call MajorityVote.apply(4)\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies on Debian/Ubuntu for oss-cad-suite\nDESCRIPTION: This snippet shows how to install essential dependencies like make, gcc, g++, and zlib for building and using oss-cad-suite on Debian or Ubuntu.  It also demonstrates downloading and extracting the oss-cad-suite archive. Requires superuser privileges to install packages.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Install and setup.rst#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nsudo apt-get install make gcc g++ zlib1g-dev\ncurl -fLO <download link>\ntar xzf <file that you downloaded>\n```\n\n----------------------------------------\n\nTITLE: Build PDF Docker image\nDESCRIPTION: Builds a custom Docker image for creating PDF documentation, using a specific Dockerfile named 'pdf.Dockerfile'.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/README.rst#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ndocker build -f pdf.Dockerfile -t spinaldoc-pdf .\n```\n\n----------------------------------------\n\nTITLE: SpinalHDL Report with Simulation Time\nDESCRIPTION: This snippet illustrates how to include the current simulation time in a SpinalHDL report using the REPORT_TIME object.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Other language features/report.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nreport(L\"miaou $REPORT_TIME\")\n```\n\n----------------------------------------\n\nTITLE: Directory structure example\nDESCRIPTION: Example of required directory structure when using local SpinalHDL with mill.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/howotuselocalspinalclone.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n/somewhere\n|-SpinalHDL   # <-- cloned spinal git\n| |-build.sc\n|-projectname\n| |-build.sc  # <-- your project, mill is ran from here\n```\n\n----------------------------------------\n\nTITLE: Binary-List Alignment with Fixed Width in Scala\nDESCRIPTION: Demonstrates how to align a binary list to a specified width by padding with zeros at the most significant bit (MSB). The `toBinInts(bitSize)` method is used for this purpose. This requires the `spinal.core.lib._` import.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/binarySystem.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.core.lib._\n\n   $: 39.toBinInts()\n   List(1, 1, 1, 0, 0, 1)\n   $: 39.toBinInts(8)    // align to 8 bit zero filled at MSB\n   List(1, 1, 1, 0, 0, 1, 0, 0)\n```\n\n----------------------------------------\n\nTITLE: Create Python virtual environment\nDESCRIPTION: Creates a Python 3 virtual environment named '.venv'. This isolates the project's dependencies.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/README.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npython3 -m venv .venv\n```\n\n----------------------------------------\n\nTITLE: Executing SBT commands from CLI\nDESCRIPTION: This code snippet shows how to execute SBT commands directly from the terminal command line.  It demonstrates running multiple commands sequentially within a single SBT invocation. This approach is useful for non-interactive tasks but may incur a performance penalty due to SBT's boot time.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/SBT.rst#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nsbt \"firstCommand with arguments\" \"secondCommand with more arguments\"\n```\n\n----------------------------------------\n\nTITLE: Memory Content Access and Assumptions - Scala\nDESCRIPTION: This snippet showcases how to access memory content for formal verification using both manual access and the `formalContains` and `formalCount` methods. It sets initial assumptions about the memory content.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Formal verification/index.rst#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\n// Manual access\nfor(i <- 0 until dut.ram.wordCount) {\n  assumeInitial(dut.ram(i) =/= X) // No occurrence of the word X\n}\n\nassumeInitial(!dut.ram.formalContains(X)) // No occurrence of the word X\n\nassumeInitial(dut.ram.formalCount(X) === 1) // only one occurrence of the word X\n```\n\n----------------------------------------\n\nTITLE: Downloading and Installing Dependencies with curl and pacman\nDESCRIPTION: These commands download and install necessary dependencies (yosys and python-sby) for SpinalHDL development using curl and pacman package manager.  The first two lines download the required packages from the specified URLs. The subsequent lines install the downloaded packages using pacman.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Install and setup.rst#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\ncurl -OL https://github.com/Readon/MINGW-SpinalHDL/releases/download/v0.4.9/mingw-w64-x86_64-yosys-0.31-1-any.pkg.tar.zst\ncurl -OL https://github.com/Readon/MINGW-SpinalHDL/releases/download/v0.4.9/mingw-w64-x86_64-python-sby-0.31-1-any.pkg.tar.zst\npacman -U *-yosys-*.pkg.tar.*\npacman -U *-python-sby-*.pkg.tar*\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables in MSYS2\nDESCRIPTION: This snippet shows how to set environment variables in MSYS2 to make Java and SBT accessible. It defines VERILATOR_ROOT and adds the Java and Coursier binaries to the PATH. These settings are suitable for the MSYS2 environment on Windows.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Install and setup.rst#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nexport VERILATOR_ROOT=/mingw64/share/verilator/\nexport PATH=/c/Program\\ Files/Eclipse\\ Adoptium/jdk-17.0.8.101-hotspot/bin:$PATH\nexport PATH=/c/Users/User/AppData/Local/Coursier/data/bin:$PATH\n```\n\n----------------------------------------\n\nTITLE: SpinalHDL Signal Declaration\nDESCRIPTION: This SpinalHDL code shows the flexibility in declaring signals, allowing them to be defined and assigned in the same line or separately.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Help for VHDL people/vhdl_comp.rst#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\n   val a = Bool()\n   a := x & y\n```\n\nLANGUAGE: scala\nCODE:\n```\n   val a = x & y\n```\n\n----------------------------------------\n\nTITLE: Error Message for Invalid Register Input (Text)\nDESCRIPTION: This text shows the error message that SpinalHDL throws when a register is defined directly as a component input. The message indicates the specific signal causing the issue and provides guidance on resolving it.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/register_defined_as_component_input.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nREGISTER DEFINED AS COMPONENT INPUT : (toplevel/io_a : in UInt[8 bits]) is defined as a registered input of the toplevel component, but isn't allowed.\n  ***\n  Source file location of the toplevel/io_a definition via the stack trace\n  ***\n```\n\n----------------------------------------\n\nTITLE: Conflict Detection Example with RegIf in Scala\nDESCRIPTION: Demonstrates conflict detection when defining overlapping fields within a register using RegIf in SpinalHDL. The code attempts to define two fields, r1fd0 and r1fd2, that overlap, causing an exception. The second example defines r1fd2 at a specific position to cause an overlap.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Libraries/regIf.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval M_REG1  = busif.newReg(doc=\"REG1\")\n  val r1fd0 = M_REG1.field(Bits(16 bits), RW, doc=\"fields 1\")\n  val r1fd2 = M_REG1.field(Bits(18 bits), RW, doc=\"fields 1\")\n    ...\n  cause Exception\n  val M_REG1  = busif.newReg(doc=\"REG1\")\n  val r1fd0 = M_REG1.field(Bits(16 bits), RW, doc=\"fields 1\")\n  val r1fd2 = M_REG1.fieldAt(pos=10, Bits(2 bits), RW, doc=\"fields 1\")\n    ...\n  cause Exception\n```\n\n----------------------------------------\n\nTITLE: Generated VHDL Component with std_logic_vector\nDESCRIPTION: This code is the output VHDL code generated as a result of adding the `noNumericType` tag to the SpinalHDL BlackBox, as described in previous snippet. All the ports that were of `UInt` type are now of `std_logic_vector` type.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/blackbox.rst#_snippet_10\n\nLANGUAGE: vhdl\nCODE:\n```\ncomponent MyBlackBox is\n  port( \n    clk       : in  std_logic;\n    increment : in  std_logic;\n    initValue : in  std_logic_vector(7 downto 0);\n    counter   : out std_logic_vector(7 downto 0)    \n  );\nend component;\n```\n\n----------------------------------------\n\nTITLE: Generic Function Definition in Scala\nDESCRIPTION: This example defines a generic function `doSomething` in Scala that takes a parameter `shape` of type `T`, where `T` is restricted to be a subclass of `Shape`.  The function can then call methods defined in the `Shape` class (e.g., `getArea()`) on the `shape` parameter.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\ndef doSomething[T <: Shape](shape: T): Something = { shape.getArea() }\n```\n\n----------------------------------------\n\nTITLE: Import Floating-Point Library in SpinalHDL\nDESCRIPTION: This code snippet imports the necessary library for using floating-point types in SpinalHDL. It's a prerequisite for using the Floating and RecFloating types.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Data types/Floating.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport spinal.lib.experimental.math._\n```\n\n----------------------------------------\n\nTITLE: Combinatorial Loop Example in SpinalHDL\nDESCRIPTION: This code snippet demonstrates a combinatorial loop in SpinalHDL. The signals `a`, `b`, and `d` are assigned in a circular dependency, causing a combinatorial loop.  SpinalHDL's compiler will detect this and throw an error. The `UInt` signals are all 8 bits wide.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/combinatorial_loop.rst#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass TopLevel extends Component {\n  val a = UInt(8 bits) // PlayDev.scala line 831\n  val b = UInt(8 bits) // PlayDev.scala line 832\n  val c = UInt(8 bits)\n  val d = UInt(8 bits)\n\n  a := b\n  b := c | d\n  d := a\n  c := 0\n}\n```\n\n----------------------------------------\n\nTITLE: Calling a Function in Scala\nDESCRIPTION: This example shows how to call the `sumBiggerThanZero` function with two float arguments.  The function will execute and return a Boolean value based on the sum of the arguments.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nsumBiggerThanZero(2.3f, 5.4f)\n```\n\n----------------------------------------\n\nTITLE: Class Instantiation and Method Call in Scala\nDESCRIPTION: This example shows how to instantiate the `Color` class and call its `getGrayLevel` method.  A new `Color` object is created with red=0, green=0, and blue=1. The `getGrayLevel` method is then called on the instance, and the returned value is stored in `grayLevelOfBlue`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nval blue = new Color(0, 0, 1)\nval grayLevelOfBlue = blue.getGrayLevel()\n```\n\n----------------------------------------\n\nTITLE: Class Inheritance in Scala\nDESCRIPTION: This example demonstrates class inheritance in Scala. The `Square` and `Rectangle` classes extend the `Shape` class and override the `getArea` method to provide their specific implementations for calculating the area.  The `override` keyword is mandatory when overriding a method.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nclass Shape {\n  def getArea(): Float\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Square(sideLength: Float) extends Shape {\n  override def getArea() = sideLength * sideLength\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Rectangle(width: Float, height: Float) extends Shape {\n  override def getArea() = width * height\n}\n```\n\n----------------------------------------\n\nTITLE: Type Parameter Restriction in Scala\nDESCRIPTION: This example shows how to restrict the type parameter of a generic class or function to be a subclass of a given type.  The `Queue` class is parameterized with `T <: Shape`, which means that `T` must be a subclass of `Shape`. This allows the `Queue` to only hold elements that are subtypes of `Shape`.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nclass Shape() {   \n   def getArea(): Float\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Rectangle() extends Shape { ... }\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass  Queue[T <: Shape]() {\n  def push(that: T): Unit = ...\n  def pop(): T = ...\n}\n```\n\n----------------------------------------\n\nTITLE: Latch Fix Example - Scala\nDESCRIPTION: This SpinalHDL code snippet demonstrates how to fix the latch issue by providing a default assignment to the signal 'a'. The signal 'a' is now initialized to 0 before the conditional assignment, ensuring that it always has a value.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/latch_detected.rst#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass TopLevel extends Component {\n  val cond = in(Bool())\n  val a = UInt(8 bits)\n\n  a := 0\n  when(cond) {\n    a := 42\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Function Returning Unit (void) in Scala\nDESCRIPTION: This demonstrates how to define a function that returns nothing (equivalent to `void` in C/C++) in Scala. The return type is specified as `Unit`. The `printer` function prints two lines to the console.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/basics.rst#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef printer(): Unit = {\n  println(\"1234\")\n  println(\"5678\")\n}\n```\n\n----------------------------------------\n\nTITLE: Build documentation with Make\nDESCRIPTION: Uses the 'make' command to build the documentation in various formats.  It utilizes the Makefile defined in the project.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/README.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nmake html     # for html\nmake latex    # for latex\nmake latexpdf # for latex (will require latexpdf installed)\nmake          # list all the available output format\n```\n\n----------------------------------------\n\nTITLE: Running a Specified Test Suite with Mill\nDESCRIPTION: This snippet runs a specific test suite (spinal.xxxxx.xxxxx) within the SpinalHDL project using Mill. An equivalent SBT command is included. Replace spinal.xxxxx.xxxxx with the desired test suite's fully qualified name.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/mill support.rst#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nmill tester.test.testOnly spinal.xxxxx.xxxxx\nsbt \"tester/testOnly spinal.xxxxx.xxxxx\" # equivalent alternatives\n```\n\n----------------------------------------\n\nTITLE: Build Chinese documentation with Make\nDESCRIPTION: Builds the HTML documentation in Chinese by setting the 'language' variable in Sphinx options.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/README.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nmake -e SPHINXOPTS=\"-D language='zh_CN'\" html # for html in Chinese\n```\n\n----------------------------------------\n\nTITLE: Find Adders Using WalkExpression - SpinalHDL Scala\nDESCRIPTION: This snippet demonstrates a more concise way to find adder operations within the SpinalHDL netlist using the walkExpression function.  It replaces the manual recursive traversal with a single call to pc.walkExpression, simplifying the code and achieving the same result as the previous example. It requires an active PhaseContext.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Developers area/spinalhdl_datamodel.rst#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\noverride def impl(pc: PhaseContext) = {\n      println(message)\n      pc.walkExpression {\n        case op: Operator.BitVector.Add => println(s\"Found ${op.left} + ${op.right}\")\n        case _ =>\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: Run PDF build in Docker container\nDESCRIPTION: Runs a Docker container based on the 'spinaldoc-pdf' image to generate PDF documentation.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/README.rst#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\ndocker run -it --rm -v $PWD:/docs spinaldoc-pdf\n```\n\n----------------------------------------\n\nTITLE: Define JTAG Bus Bundle in SpinalHDL\nDESCRIPTION: Defines the JTAG bus bundle including TMS, TDI, and TDO signals. The TCK signal is intentionally excluded as it is intended to be provided by the clock domain. This bus definition facilitates interaction with JTAG-compliant devices.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Examples/Advanced ones/jtag.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Jtag(\n  tms: Bool,\n  tdi: Bool,\n  tdo: TriState[Bool]\n) extends Bundle\n```\n\n----------------------------------------\n\nTITLE: Combinatorial Loop Error Message\nDESCRIPTION: This is the error message that SpinalHDL will throw when a combinatorial loop is detected in the design. It shows the partial and full chains of the loop, indicating the signals involved and the order of their dependencies. This allows the designer to pinpoint the source of the problem.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Design errors/combinatorial_loop.rst#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nCOMBINATORIAL LOOP :\n  Partial chain :\n    >>> (toplevel/a :  UInt[8 bits]) at ***(PlayDev.scala:831) >>>\n    >>> (toplevel/d :  UInt[8 bits]) at ***(PlayDev.scala:834) >>>\n    >>> (toplevel/b :  UInt[8 bits]) at ***(PlayDev.scala:832) >>>\n    >>> (toplevel/a :  UInt[8 bits]) at ***(PlayDev.scala:831) >>>\n\n  Full chain :\n    (toplevel/a :  UInt[8 bits])\n    (toplevel/d :  UInt[8 bits])\n    (UInt | UInt)[8 bits]\n    (toplevel/b :  UInt[8 bits])\n    (toplevel/a :  UInt[8 bits])\n```\n\n----------------------------------------\n\nTITLE: Scala: Defining Scala Version in build.sc\nDESCRIPTION: This snippet shows how to define the Scala version in a build.sc file. This is an alternative way to specify the Scala version for the project, and is again necessary to ensure local publishing works correctly.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Introduction/faq.rst#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef scalaVersion = \"2.12.16\" // in build.sc\n```\n\n----------------------------------------\n\nTITLE: Scala Compiler Plugin Callback Example\nDESCRIPTION: Illustrates how SpinalHDL uses a Scala compiler plugin to get callbacks when vals are defined. The example shows a custom Component class overriding the valCallback method to print the name and reference of newly defined vals. This provides insight into SpinalHDL's internal naming mechanisms.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Structuring/naming.rst#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// spinal.idslplugin.ValCallback is the Scala compiler plugin feature which will provide the callbacks\nclass Component extends spinal.idslplugin.ValCallback {\n  override def valCallback[T](ref: T, name: String) : T = {\n    println(s\"Got $ref named $name\") // Here we just print what we got as a demo.\n    ref\n  }\n}\n\nclass UInt\nclass Bits\nclass MyComponent extends Component {\n  val two = 2\n  val wuff = \"miaou\"\n  val toto = new UInt\n  val rawrr = new Bits\n}\n\nobject Debug3 extends App {\n  new MyComponent()\n  // ^ This will print :\n  // Got 2 named two\n  // Got miaou named wuff\n  // Got spinal.tester.code.sandbox.UInt@691a7f8f named toto\n  // Got spinal.tester.code.sandbox.Bits@161b062a named rawrr\n}\n```\n\n----------------------------------------\n\nTITLE: Class Definition in SpinalHDL (Scala)\nDESCRIPTION: Defines classes `Fifo` and `Counter` in SpinalHDL, extending `Component` and `Area` respectively.  Demonstrates the basic syntax for class definition in SpinalHDL.  Note that these are regular classes, not case classes.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Scala Guide/coding_conventions.rst#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Fifo extends Component {\n\n   }\n\n   class Counter extends Area {\n\n   }\n```\n\n----------------------------------------\n\nTITLE: HTML Meta Refresh Redirection\nDESCRIPTION: This HTML snippet uses the meta refresh tag to redirect the user to a specified URL. The content attribute specifies the delay in seconds before redirection and the URL to redirect to.\nSOURCE: https://github.com/spinalhdl/spinaldoc-rtd/blob/master/source/SpinalHDL/Getting Started/Cheatsheets/core.rst#_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<head>\n   <!-- HTML meta refresh URL redirection -->\n   <meta http-equiv=\"refresh\"\n   content=\"0; url=https://cdn.jsdelivr.net/gh/SpinalHDL/SpinalDoc@master/cheatsheet/cheatSheet_core_oo.pdf\">\n</head>\n```"
  }
]