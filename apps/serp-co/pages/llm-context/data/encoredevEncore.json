[
  {
    "owner": "encoredev",
    "repo": "encore",
    "content": "TITLE: Defining a Service Struct and API Endpoint in Go\nDESCRIPTION: This snippet demonstrates how to define a service struct with the //encore:service directive, create an initialization function, and define an API endpoint as a method on the struct.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/service-structs.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n//encore:service\ntype Service struct {\n\t// Add your dependencies here\n}\n\nfunc initService() (*Service, error) {\n\t// Write your service initialization code here.\n}\n\n//encore:api public\nfunc (s *Service) MyAPI(ctx context.Context) error {\n\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Encore App\nDESCRIPTION: This snippet demonstrates how to create a new Encore application using the Encore CLI. The command `encore app create` initializes a new project, typically based on a chosen template (like 'Hello World' in this case).\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/deploy-to-railway.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n\"encore app create\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Incident Management Service in Go\nDESCRIPTION: Go code for the incidents service, including structs, database connection, and HTTP endpoints for listing, acknowledging, creating, and assigning incidents.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/incident-management-tool.md#2025-04-21_snippet_9\n\nLANGUAGE: go\nCODE:\n```\n// Service incidents reports, assigns and acknowledges incidents.\npackage incidents\n\nimport (\n\t\"context\"\n\t\"encore.app/schedules\"\n\t\"encore.app/slack\"\n\t\"encore.app/users\"\n\t\"encore.dev/beta/errs\"\n\t\"encore.dev/storage/sqldb\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// Define a database named 'incidents', using the database migrations\n// in the \"./migrations\" folder. Encore automatically provisions,\n// migrates, and connects to the database.\nvar db = sqldb.NewDatabase(\"incidents\", sqldb.DatabaseConfig{\n\tMigrations: \"./migrations\",\n})\n\n// This struct holds multiple Incidents structs\ntype Incidents struct {\n\tItems []Incident\n}\n\n// This is a Go struct representing our PostgreSQL schema for `incidents`\ntype Incident struct {\n\tId             int32\n\tBody           string\n\tCreatedAt      time.Time\n\tAcknowledged   bool\n\tAcknowledgedAt *time.Time\n\tAssignee       *users.User\n}\n\n//encore:api public method=GET path=/incidents\nfunc List(ctx context.Context) (*Incidents, error) {\n\trows, err := db.Query(ctx, `\n\t\tSELECT id, assigned_user_id, body, created_at, acknowledged_at\n\t\tFROM incidents\n\t\tWHERE acknowledged_at IS NULL\n\t`)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn RowsToIncidents(ctx, rows)\n}\n\n//encore:api public method=PUT path=/incidents/:id/acknowledge\nfunc Acknowledge(ctx context.Context, id int32) (*Incident, error) {\n\teb := errs.B().Meta(\"incidentId\", id)\n\trows, err := db.Query(ctx, `\n\t\tUPDATE incidents\n\t\tSET acknowledged_at = NOW()\n\t\tWHERE acknowledged_at IS NULL\n\t\t  AND id = $1\n\t\tRETURNING id, assigned_user_id, body, created_at, acknowledged_at\n\t`, id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tincidents, err := RowsToIncidents(ctx, rows)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif incidents.Items == nil {\n\t\treturn nil, eb.Code(errs.NotFound).Msg(\"no incident found\").Err()\n\t}\n\n\tincident := &incidents.Items[0]\n\t_ = slack.Notify(ctx, &slack.NotifyParams{\n\t\tText: fmt.Sprintf(\"Incident #%d assigned to %s %s <@%s> has been acknowledged:\\n%s\", incident.Id, incident.Assignee.FirstName, incident.Assignee.LastName, incident.Assignee.SlackHandle, incident.Body),\n\t})\n\n\treturn incident, err\n}\n\n//encore:api public method=POST path=/incidents\nfunc Create(ctx context.Context, params *CreateParams) (*Incident, error) {\n\t// check who is on-call\n\tschedule, err := schedules.ScheduledNow(ctx)\n\n\tincident := Incident{}\n\tif schedule != nil {\n\t\tincident.Assignee = &schedule.User\n\t}\n\n\tvar row *db.Row\n\tif schedule != nil {\n\t\t// Someone is on-call\n\t\trow = db.QueryRow(ctx, `\n\t\t\tINSERT INTO incidents (assigned_user_id, body)\n\t\t\tVALUES ($1, $2)\n\t\t\tRETURNING id, body, created_at\n\t\t`, &schedule.User.Id, params.Body)\n\t} else {\n\t\t// Nobody is on-call\n\t\trow = db.QueryRow(ctx, `\n\t\t\tINSERT INTO incidents (body)\n\t\t\tVALUES ($1)\n\t\t\tRETURNING id, body, created_at\n\t\t`, params.Body)\n\t}\n\n\tif err = row.Scan(&incident.Id, &incident.Body, &incident.CreatedAt); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar text string\n\tif incident.Assignee != nil {\n\t\ttext = fmt.Sprintf(\"Incident #%d created and assigned to %s %s <@%s>\\n%s\", incident.Id, incident.Assignee.FirstName, incident.Assignee.LastName, incident.Assignee.SlackHandle, incident.Body)\n\t} else {\n\t\ttext = fmt.Sprintf(\"Incident #%d created and unassigned\\n%s\", incident.Id, incident.Body)\n\t}\n\t_ = slack.Notify(ctx, &slack.NotifyParams{Text: text})\n\n\treturn &incident, nil\n}\n\ntype CreateParams struct {\n\tBody string\n}\n\n// Helper to take a db.Rows instance and convert it into a list of Incidents\nfunc RowsToIncidents(ctx context.Context, rows *db.Rows) (*Incidents, error) {\n\teb := errs.B()\n\n\tdefer rows.Close()\n\n\tvar incidents []Incident\n\tfor rows.Next() {\n\t\tvar incident = Incident{}\n\t\tvar assignedUserId *int32\n\t\tif err := rows.Scan(&incident.Id, &assignedUserId, &incident.Body, &incident.CreatedAt, &incident.AcknowledgedAt); err != nil {\n\t\t\treturn nil, eb.Code(errs.Unknown).Msgf(\"could not scan: %v\", err).Err()\n\t\t}\n\t\tif assignedUserId != nil {\n\t\t\tuser, err := users.Get(ctx, *assignedUserId)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, eb.Code(errs.NotFound).Msgf(\"could not retrieve user for incident %v\", assignedUserId).Err()\n\t\t\t}\n\t\t\tincident.Assignee = user\n\t\t}\n\t\tincident.Acknowledged = incident.AcknowledgedAt != nil\n\t\tincidents = append(incidents, incident)\n\t}\n\n\treturn &Incidents{Items: incidents}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Docker Image - Go\nDESCRIPTION: This snippet illustrates how to build a Docker image for your Encore application, necessary for deployment on DigitalOcean's App Platform.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/deploy-to-digital-ocean-wip.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nencore build docker myapp\n```\n\n----------------------------------------\n\nTITLE: Installing Encore CLI\nDESCRIPTION: Command-line instructions for installing Encore and creating a new application using the CLI\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/quick-start.mdx#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nencore app create\n```\n\n----------------------------------------\n\nTITLE: Using Secrets in Go HTTP Request\nDESCRIPTION: This example demonstrates how to use a stored secret (GitHubAPIToken) in a Go HTTP request to authenticate with the GitHub API. The secret is accessed like a regular variable.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/secrets.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc callGitHub(ctx context.Context) {\n    req, _ := http.NewRequestWithContext(ctx, \"GET\", \"https:///api.github.com/user\", nil)\n    req.Header.Add(\"Authorization\", \"token \" + secrets.GitHubAPIToken)\n    resp, err := http.DefaultClient.Do(req)\n    // ... handle err and resp\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Encore Backend Locally\nDESCRIPTION: Commands to navigate to the app directory and start the Encore backend locally.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/meeting-notes.mdx#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ cd you-app-name # replace with the app name you picked\n$ encore run\n```\n\n----------------------------------------\n\nTITLE: Defining Basic API Endpoint in Encore.ts\nDESCRIPTION: Creates a basic POST API endpoint that accepts a name parameter and returns a greeting message. Demonstrates the standard pattern for API definition in Encore.ts with request and response interfaces.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\ninterface PingParams {\nname: string;\n}\ninterface PingResponse {\nmessage: string;\n}\nexport const ping = api(\n{ method: \"POST\" },\nasync (p: PingParams): Promise<PingResponse> => {\nreturn { message: Hello ${p.name}! };\n}\n);\n```\n\n----------------------------------------\n\nTITLE: Authentication Handler in Encore\nDESCRIPTION: Basic implementation of an authentication handler for validating tokens and returning user identification, supporting different access levels\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_23\n\nLANGUAGE: Go\nCODE:\n```\nimport \"encore.dev/beta/auth\"\n\n//encore:authhandler\nfunc AuthHandler(ctx context.Context, token string) (auth.UID, error) {\n    // Validate token and return user ID\n}\n```\n\n----------------------------------------\n\nTITLE: Using Secrets in Encore Applications\nDESCRIPTION: Example of accessing and using secrets in an Encore application. The secret value is accessed directly through the secrets struct field and used in an HTTP request header.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/code-snippets.md#2025-04-21_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nfunc callGitHub(ctx context.Context) {\n    req, _ := http.NewRequestWithContext(ctx, \"GET\", \"https:///api.github.com/user\", nil)\n    req.Header.Add(\"Authorization\", \"token \" + secrets.GitHubAPIToken)\n    resp, err := http.DefaultClient.Do(req)\n    // ... handle err and resp\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an API Endpoint in Go with Encore\nDESCRIPTION: This snippet defines an API endpoint `MyAPI` using the `//encore:api` annotation. The function takes a `context.Context` as input and returns an error. This annotation makes it an Encore deployable API.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/generic_top_level_type.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Todo Item Table in SQL Database\nDESCRIPTION: This SQL migration creates the initial todo_item table with id, title, and done columns. It uses BIGSERIAL for auto-incrementing IDs, TEXT for the title field, and BOOLEAN for tracking completion status.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/change-db-schema.md#2025-04-21_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE todo_item (\n    id BIGSERIAL PRIMARY KEY,\n    title TEXT NOT NULL,\n    done BOOLEAN NOT NULL\n);\n```\n\n----------------------------------------\n\nTITLE: Inserting data using SQL with TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to insert data into the `todo_item` table using `db.exec`. It inserts a new row with the provided `title` and sets the `done` column to `false`.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/databases.md#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n\"await db.exec`\n  INSERT INTO todo_item (title, done)\n  VALUES (${title}, false)\n`;\"\n```\n\n----------------------------------------\n\nTITLE: Complete API Example with Multiple Parameters\nDESCRIPTION: Comprehensive example showing various parameter types including headers, query params, and sensitive data handling.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/api-schemas.md#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\npackage blog\n\ntype Updates struct {\n\tAuthor      string `json:\"author,omitempty\"`\n\tPublishTime time.Time `json:\"publish_time,omitempty\"`\n}\n\ntype BatchUpdateParams struct {\n\tRequester     string    `header:\"X-Requester\"`\n\tRequestTime   time.Time `header:\"X-Request-Time\"`\n\tCurrentAuthor string    `query:\"author\"`\n\tUpdates       *Updates  `json:\"updates\"`\n\tMySecretKey   string    `encore:\"sensitive\"`\n}\n\ntype BatchUpdateResponse struct {\n\tServedBy   string       `header:\"X-Served-By\"`\n\tUpdatedIDs []uuid.UUID  `json:\"updated_ids\"`\n}\n\n//encore:api public method=POST path=/section/:sectionID/posts\nfunc BatchUpdate(ctx context.Context, sectionID string, params *BatchUpdateParams) (*BatchUpdateResponse, error) {\n\treturn &BatchUpdateResponse{ServedBy: hostname, UpdatedIDs: ids}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining API Endpoint with Request Validation in Encore\nDESCRIPTION: This code defines an API endpoint using Encore with request validation using TypeScript types. It defines an interface `Request` with various properties including optional query parameters, required headers, and an enum in the request body. This enables both runtime and compile-time type safety.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Header, Query, api } from \"encore.dev/api\";\n\ninterface Request {\n  limit?: Query<number>;               // Optional query parameter\n  myHeader: Header<\"X-My-Header\">;     // Required header\n  type: \"sprocket\" | \"widget\";         // Required enum in body\n}\n\nexport const myEndpoint = api<Request, Response>(\n  { expose: true, method: \"POST\", path: \"/api\" },\n  async ({ limit, myHeader, type }) => {\n    // Implementation\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Updating Book Endpoint to Check Availability\nDESCRIPTION: Updated Book endpoint that checks availability before creating a booking, ensuring the slot is available and not already booked. Uses transaction to maintain data consistency.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_17\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public method=POST path=/booking\nfunc Book(ctx context.Context, p *BookParams) error {\n\teb := errs.B()\n\n\tnow := time.Now()\n\tif p.Start.Before(now) {\n\t\treturn eb.Code(errs.InvalidArgument).Msg(\"start time must be in the future\").Err()\n\t}\n\n\ttx, err := pgxdb.Begin(ctx)\n\tif err != nil {\n\t\treturn eb.Cause(err).Code(errs.Unavailable).Msg(\"failed to start transaction\").Err()\n\t}\n\tdefer tx.Rollback(context.Background()) // committed explicitly on success\n\n\t// Get the bookings for this day.\n\tstartOfDay := time.Date(p.Start.Year(), p.Start.Month(), p.Start.Day(), 0, 0, 0, 0, p.Start.Location())\n\tbookings, err := listBookingsBetween(ctx, startOfDay, startOfDay.AddDate(0, 0, 1))\n\tif err != nil {\n\t\treturn eb.Cause(err).Code(errs.Unavailable).Msg(\"failed to list bookings\").Err()\n\t}\n\n\t// Is this slot bookable?\n\tslot := BookableSlot{Start: p.Start, End: p.Start.Add(DefaultBookingDuration)}\n\tif len(filterBookableSlots([]BookableSlot{slot}, now, bookings)) == 0 {\n\t\treturn eb.Code(errs.InvalidArgument).Msg(\"slot is unavailable\").Err()\n\t}\n\n\t_, err = query.InsertBooking(ctx, db.InsertBookingParams{\n\t\tStartTime: pgtype.Timestamp{Time: p.Start, Valid: true},\n\t\tEndTime:   pgtype.Timestamp{Time: p.Start.Add(DefaultBookingDuration), Valid: true},\n\t\tEmail:     p.Email,\n\t})\n\tif err != nil {\n\t\treturn eb.Cause(err).Code(errs.Unavailable).Msg(\"failed to insert booking\").Err()\n\t}\n\n\tif err := tx.Commit(ctx); err != nil {\n\t\treturn eb.Cause(err).Code(errs.Unavailable).Msg(\"failed to commit transaction\").Err()\n\t}\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the database schema with SQL\nDESCRIPTION: This SQL snippet demonstrates how to define the initial table structure for the database. It creates a `todo_item` table with columns `id`, `title`, and `done` with appropriate data types and constraints.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/databases.md#2025-04-21_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\n\"CREATE TABLE todo_item (\n    id BIGSERIAL PRIMARY KEY,\n    title TEXT NOT NULL,\n    done BOOLEAN NOT NULL DEFAULT false\n);\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Public API Endpoint in Go with Encore\nDESCRIPTION: This snippet demonstrates how to create a public API endpoint named 'Ping' using Encore.go. It shows the use of the '//encore:api public' annotation and defines request/response types.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/defining-apis.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage hello // service name\n\n//encore:api public\nfunc Ping(ctx context.Context, params *PingParams) (*PingResponse, error) {\n    msg := fmt.Sprintf(\"Hello, %s!\", params.Name)\n    return &PingResponse{Message: msg}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Secrets Structure in Encore\nDESCRIPTION: Implementation of a secrets struct for securely storing sensitive configuration values like API tokens and private keys, following Encore's secret management guidelines\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_19\n\nLANGUAGE: Go\nCODE:\n```\nvar secrets struct {\n    SSHPrivateKey string\n    GitHubAPIToken string\n}\n```\n\nLANGUAGE: Go\nCODE:\n```\nfunc callGitHub(ctx context.Context) {\n    req.Header.Add(\"Authorization\", \"token \" + secrets.GitHubAPIToken)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Secrets Struct in Go\nDESCRIPTION: This snippet shows how to define a secrets struct in Go to declare the secret values your application needs. The struct should be unexported and contain string fields for each secret.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/secrets.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nvar secrets struct {\n    SSHPrivateKey string    // ed25519 private key for SSH server\n    GitHubAPIToken string   // personal access token for deployments\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Running Encore Application Locally\nDESCRIPTION: Command to start the local development environment and run the Encore application\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/quick-start.mdx#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncd your-app-name\nencore run\n```\n\n----------------------------------------\n\nTITLE: Managing Users Service in Go\nDESCRIPTION: A Go service 'users' to manage user creation and retrieval. It includes a database-backed implementation using Encore's storage package to interface with SQL for managing user data. The service provides HTTP endpoints for creating and retrieving users by ID, with parameter validation and error handling.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/incident-management-tool.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n// Service users manages users and assigns incidents.\npackage users\n\nimport (\n\t\"context\"\n\t\"encore.dev/storage/sqldb\"\n)\n\n// This is a Go struct representing our PostgreSQL schema for `users`\ntype User struct {\n\tId          int32\n\tFirstName   string\n\tLastName    string\n\tSlackHandle string\n}\n\n// Define a database named 'users', using the database migrations\n// in the \"./migrations\" folder. Encore automatically provisions,\n// migrates, and connects to the database.\nvar db = sqldb.NewDatabase(\"users\", sqldb.DatabaseConfig{\n\tMigrations: \"./migrations\",\n})\n\n//encore:api public method=POST path=/users\nfunc Create(ctx context.Context, params CreateParams) (*User, error) {\n\tuser := User{}\n\terr := db.QueryRow(ctx, `\n\t\tINSERT INTO users (first_name, last_name, slack_handle)\n\t\tVALUES ($1, $2, $3)\n\t\tRETURNING id, first_name, last_name, slack_handle\n\t`, params.FirstName, params.LastName, params.SlackHandle).Scan(&user.Id, &user.FirstName, &user.LastName, &user.SlackHandle)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &user, nil\n}\n\n// This is what JSON params our POST /users endpoint will accept\ntype CreateParams struct {\n\tFirstName   string\n\tLastName    string\n\tSlackHandle string\n}\n\n//encore:api public method=GET path=/users/:id\nfunc Get(ctx context.Context, id int32) (*User, error) {\n\tuser := User{}\n\terr := db.QueryRow(ctx, `\n\t  SELECT id, first_name, last_name, slack_handle\n\t\tFROM users\n\t\tWHERE id = $1\n\t`, id).Scan(&user.Id, &user.FirstName, &user.LastName, &user.SlackHandle)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &user, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a StreamInOut API Endpoint in Encore\nDESCRIPTION: This code defines a StreamInOut API endpoint using Encore's `api.streamInOut` method. It demonstrates how to specify incoming and outgoing message types and handle bidirectional communication. The example iterates over incoming messages from the client and sends a response back to the client for each message received.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/streaming-apis.mdx#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\n\ninterface InMessage {\n  // ...\n}\n\ninterface OutMessage {\n  // ...\n}\n\nexport const ChatStream = api.streamInOut<InMessage, OutMessage>(\n  { path: \"/chat\", expose: true },\n  async (stream) => {\n    for await (const chatMessage of stream) {\n      // Respond to the message by sending something back\n      await stream.send({ /* ... */ })\n    }\n  }\n);\n\n```\n\n----------------------------------------\n\nTITLE: Defining Subscription Handler Method in Go\nDESCRIPTION: This Go code snippet demonstrates how to define a subscription handler as a method on a service struct in Encore. It uses `pubsub.MethodHandler` to access the injected dependencies via service structs. The snippet also involves setting up a subscription with configuration options using `pubsub.SubscriptionConfig`. The key dependency includes the `pubsub` package from the Encore framework, while the handler specifically references methods on the struct type.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/pubsub.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n//encore:service\ntype Service struct { /* ... */ }\n\nfunc (s *Service) SendWelcomeEmail(ctx context.Context, event *SignupEvent) error {\n\t// ...\n}\n\nvar _ = pubsub.NewSubscription(\n  user.Signups, \"send-welcome-email\",\n  pubsub.SubscriptionConfig[*SignupEvent]{\n    Handler: pubsub.MethodHandler((*Service).SendWelcomeEmail),\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Encore Secrets\nDESCRIPTION: Sets a secret value for specified environment types in Encore.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_21\n\nLANGUAGE: shell\nCODE:\n```\n$ encore secret set --type <types> <secret-name>\n```\n\n----------------------------------------\n\nTITLE: Initializing SQLDatabase with Prisma in Encore.ts\nDESCRIPTION: Configures a PostgreSQL database using Encore's SQLDatabase with Prisma migrations and sets up a Prisma client with the database connection string\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/orms/prisma.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SQLDatabase } from \"encore.dev/storage/sqldb\";\nimport { PrismaClient } from \"@prisma/client\";\n\n// Define a database named 'encore_prisma_test', using the database migrations\n// in the \"./prisma/migrations\" folder (where prisma will generate their migrations).\n// Set `source` to `prisma` to let Encore know that the migrations are generated by Prisma.\nconst DB = new SQLDatabase('encore_prisma_test', {\n  migrations: {\n    path: './prisma/migrations',\n    source: 'prisma',\n  },\n});\n\n// Setup prisma client with connection string\nconst prisma = new PrismaClient({\n  datasources: {\n    db: {\n      url: DB.connectionString,\n    },\n  },\n});\n\n// Select all users\nconst allUsers = prisma.user.findMany();\n```\n\n----------------------------------------\n\nTITLE: Defining SQL Database for File Storage in Encore.ts\nDESCRIPTION: This code snippet defines a PostgreSQL database named 'files' using Encore's SQLDatabase primitive, configured with database migrations from the \"./migrations\" folder. It exports the database instance 'DB' for use in other parts of the application.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/how-to/file-uploads.md#2025-04-21_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { SQLDatabase } from \"encore.dev/storage/sqldb\";\n\n// Define a database named 'files', using the database migrations\n// in the \"./migrations\" folder. Encore automatically provisions,\n// migrates, and connects to the database.\nexport const DB = new SQLDatabase(\"files\", {\n  migrations: \"./migrations\",\n});\n```\n\n----------------------------------------\n\nTITLE: Running Encore Application\nDESCRIPTION: Runs the Encore application with optional flags for debugging, watching for changes, and specifying the port.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ encore run [--debug] [--watch=true] [--port NUMBER] [flags]\n```\n\n----------------------------------------\n\nTITLE: Calling APIs Between Services in Encore\nDESCRIPTION: Demonstrates how to call APIs from other services within an Encore application. Services are imported as Go packages and their APIs can be called as regular Go functions.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/code-snippets.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nimport \"encore.app/hello\" // import service\n\n//encore:api public\nfunc MyOtherAPI(ctx context.Context) error {\n    resp, err := hello.Ping(ctx, &hello.PingParams{Name: \"World\"})\n    if err == nil {\n        log.Println(resp.Message) // \"Hello, World!\"\n    }\n    return err\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SearchPhoto Endpoint in Go\nDESCRIPTION: Go function implementing the SearchPhoto endpoint, which proxies requests to the Pexels API for photo search.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/meeting-notes.mdx#2025-04-21_snippet_7\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public method=GET path=/images/:query\nfunc SearchPhoto(ctx context.Context, query string) (*SearchResponse, error) {\n\t// Create a new http client to proxy the request to the Pexels API.\n\tURL := \"https://api.pexels.com/v1/search?query=\" + query\n\tclient := &http.Client{}\n\treq, _ := http.NewRequest(\"GET\", URL, nil)\n\n\t// Add authorization header to the req with the API key.\n\treq.Header.Set(\"Authorization\", secrets.PexelsApiKey)\n\n\t// Make the request, and close the response body when we're done.\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode >= 400 {\n\t\treturn nil, fmt.Errorf(\"Pexels API error: %s\", res.Status)\n\t}\n\n\t// Decode the data into the searchResponse struct.\n\tvar searchResponse *SearchResponse\n\terr = json.NewDecoder(res.Body).Decode(&searchResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn searchResponse, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Making Service-to-Service API Calls in Encore.go\nDESCRIPTION: This snippet demonstrates how to import another service and call its API endpoint like a regular function. It imports the 'hello' service and calls its 'Ping' endpoint, showing Encore's type-safe API call mechanism.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/api-calls.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport \"encore.app/hello\" // import service\n\n//encore:api public\nfunc MyOtherAPI(ctx context.Context) error {\n    resp, err := hello.Ping(ctx, &hello.PingParams{Name: \"World\"})\n    if err == nil {\n        log.Println(resp.Message) // \"Hello, World!\"\n    }\n    return err\n}\n```\n\n----------------------------------------\n\nTITLE: Querying data using SQL with TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to query data from the database using `db.query`. It retrieves all rows from the `todo_item` table and iterates through the results.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/databases.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n\"const allTodos = await db.query`SELECT * FROM todo_item`;\nfor await (const todo of allTodos) {\n  // Process each todo\n}\"\n```\n\n----------------------------------------\n\nTITLE: Overriding Local Secrets in CUE\nDESCRIPTION: This snippet shows how to override secret values for local development by creating a .secrets.local.cue file in the root of the Encore application. It contains key-value pairs of secret names and their local override values.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/secrets.md#2025-04-21_snippet_2\n\nLANGUAGE: cue\nCODE:\n```\nGitHubAPIToken: \"my-local-override-token\"\nSSHPrivateKey: \"custom-ssh-private-key\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Auth Handler with Custom User Data in Go\nDESCRIPTION: Implementation of an authentication handler that validates tokens and returns both a user ID and custom user data. This pattern is useful when additional user information needs to be easily accessible throughout the application.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/auth.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport \"encore.dev/beta/auth\"\n\n// Data can be named whatever you prefer (but must be exported).\ntype Data struct {\n    Username string\n    // ...\n}\n\n// AuthHandler can be named whatever you prefer (but must be exported).\n//encore:authhandler\nfunc AuthHandler(ctx context.Context, token string) (auth.UID, *Data, error) {\n    // Validate the token and look up the user id and user data,\n    // for example by calling Firebase Auth.\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Resource Reference Outside Service in Go\nDESCRIPTION: This Go snippet demonstrates the improper use of an infrastructure resource reference 'svc.Moo.Query' outside its designated service. This violates constraints in the Encore framework where resources must only be used within their service contexts. It highlights the necessary dependency on the 'svc' package and shows misuse within the 'Foo' function.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_outside_ref.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage pkg\n\nimport (\n    \"context\"\n    \"test/svc\"\n)\n\nfunc Foo() {\n    _ = svc.Moo.Query\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Hello World API in Go with Encore\nDESCRIPTION: This snippet shows how to create a simple REST API endpoint using Encore. It demonstrates the use of the '//encore:api' annotation to define a public API endpoint.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/quick-start.mdx#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// Service hello implements a simple hello world REST API.\npackage hello\n\nimport (\n\t\"context\"\n)\n\n// This is a simple REST API that responds with a personalized greeting.\n//\n//encore:api public path=/hello/:name\nfunc World(ctx context.Context, name string) (*Response, error) {\n\tmsg := \"Hello, \" + name + \"!\"\n\treturn &Response{Message: msg}, nil\n}\n\ntype Response struct {\n\tMessage string\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Request Schema with Encore.ts\nDESCRIPTION: This snippet shows how to define a request schema using Encore.ts for a POST endpoint. It demonstrates the use of TypeScript types for parsing optional query parameters, custom headers, and required fields.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Header, Query, api } from \"encore.dev/api\";\n\ninterface Request {\n  // Optional query parameter. Parsed from the request URL.\n  limit?: Query<number>;\n\n  // Custom header that must be set. Parsed from the HTTP headers.\n  myHeader: Header<\"X-My-Header\">;\n\n  // Required enum. Parsed from the request body.\n  type: \"sprocket\" | \"widget\";\n}\n\nexport const myEndpoint = api<Request, Response>(\n  { expose: true, method: \"POST\", path: \"/api\" },\n  async ({ limit, myHeader, type }) => {\n    // ...\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Header Fields in Encore Request/Response Structs\nDESCRIPTION: This snippet shows how to define header fields in Encore request/response structs using the 'header' tag. It demonstrates mapping a struct field to an HTTP header.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/defining-apis.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\ntype ListBlogPost struct {\n    Language string `header:\"Accept-Language\"`\n    Author      string // Not a header\n}\n```\n\n----------------------------------------\n\nTITLE: Database Query Operation Example\nDESCRIPTION: Shows how to query data from an Encore SQL database with struct scanning\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nvar item struct {\n    ID int64\n    Title string\n    Done bool\n}\nerr := tododb.QueryRow(ctx, `\n    SELECT id, title, done\n    FROM todo_item\n    LIMIT 1\n`).Scan(&item.ID, &item.Title, &item.Done)\n```\n\n----------------------------------------\n\nTITLE: Defining Public API Endpoints in Encore\nDESCRIPTION: Example of how to define a public API endpoint in Encore using the //encore:api public annotation. The function accepts a context and request parameters and returns a response structure and error.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/code-snippets.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage hello // service name\n\n//encore:api public\nfunc Ping(ctx context.Context, params *PingParams) (*PingResponse, error) {\n    msg := fmt.Sprintf(\"Hello, %s!\", params.Name)\n    return &PingResponse{Message: msg}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a PubSub Topic in Encore\nDESCRIPTION: Demonstrates how to create a PubSub topic for asynchronous messaging in Encore. The topic is defined with a message type and delivery guarantee configuration.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/code-snippets.md#2025-04-21_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nimport \"encore.dev/pubsub\"\n\ntype SignupEvent struct { UserID int }\nvar Signups = pubsub.NewTopic[*SignupEvent](\"signups\", pubsub.TopicConfig {\n    DeliveryGuarantee: pubsub.AtLeastOnce,\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Service with Dependency Injection in Encore\nDESCRIPTION: Demonstrates the creation of a service with dependency injection by defining dependencies as struct fields. This example shows an email service with a Sendgrid client dependency.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_42\n\nLANGUAGE: go\nCODE:\n```\npackage email\n\n//encore:service\ntype Service struct {\n    sendgridClient *sendgrid.Client\n}\n\nfunc initService() (*Service, error) {\n    client, err := sendgrid.NewClient()\n    if err != nil {\n        return nil, err\n    }\n    return &Service{sendgridClient: client}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Original URL from Short ID in Go\nDESCRIPTION: This Go snippet provides the 'Get' function, which retrieves the original URL from the database given a short ID. It utilizes an SQL query to fetch the corresponding URL from the 'url' table and is annotated for a GET request URL endpoint.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/rest-api.mdx#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n// Get retrieves the original URL for the id.\n//encore:api public method=GET path=/url/:id\nfunc Get(ctx context.Context, id string) (*URL, error) {\n\tu := &URL{ID: id}\n\terr := db.QueryRow(ctx, `\n        SELECT original_url FROM url\n        WHERE id = $1\n    `, id).Scan(&u.URL)\n\treturn u, err\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Website Ping Endpoint\nDESCRIPTION: TypeScript implementation of an API endpoint that checks if a website is up by making an HTTP request and analyzing the response.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Service monitor checks if a website is up or down.\nimport { api } from \"encore.dev/api\";\n\nexport interface PingParams {\n  url: string;\n}\n\nexport interface PingResponse {\n  up: boolean;\n}\n\n// Ping pings a specific site and determines whether it's up or down right now.\nexport const ping = api<PingParams, PingResponse>(\n  { expose: true, path: \"/ping/:url\", method: \"GET\" },\n  async ({ url }) => {\n    // If the url does not start with \"http:\" or \"https:\", default to \"https:\".\n    if (!url.startsWith(\"http:\") && !url.startsWith(\"https:\")) {\n      url = \"https://\" + url;\n    }\n\n    try {\n      // Make an HTTP request to check if it's up.\n      const resp = await fetch(url, { method: \"GET\" });\n      // 2xx and 3xx status codes are considered up\n      const up = resp.status >= 200 && resp.status < 300;\n      return { up };\n    } catch (err) {\n      return { up: false };\n    }\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Mocking Auth Data in TypeScript Tests with Vitest\nDESCRIPTION: This snippet demonstrates how to mock the `getAuthData` function using Vitest for testing purposes. It includes a sample test case that verifies authentication data is correctly applied in a function call to the API.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/auth.md#2025-04-21_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { describe, expect, test, vi } from \"vitest\";\nimport * as auth from \"~encore/auth\"; \nimport { get } from \"./hello\";\n\ndescribe(\"get\", () => {\n  test(\"should combine string with parameter value\", async () => {\n    const spy = vi.spyOn(auth, 'getAuthData');\n    spy.mockImplementation(() => ({ userEmail: \"user@email.com\" }))\n\n    const resp = await get({ name: \"world\" });\n    expect(resp.message).toBe(\"Hello world! You are authenticated with user@email.com\");\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Service-to-Service Stream Communication in TypeScript with Encore\nDESCRIPTION: Example showing how to use a streaming endpoint from another service using ~encore/clients import. Demonstrates stream initialization, sending messages, and handling incoming stream data in an API endpoint.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/streaming-apis.mdx#2025-04-21_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { chat } from \"~encore/clients\"; // import 'chat' service\n\nexport const myOtherAPI = api({}, async (): Promise<void> => {\n  const stream = await chat.myStreamingEndpoint();\n\n  // send a message to the chat service over the stream\n  await stream.send({ msg: \"data\" });\n\n  for await (const msg of stream) {\n    // handle incoming message\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Pub/Sub Topic in Go with Encore\nDESCRIPTION: Demonstrates how to create a Pub/Sub topic for user signup events using Encore's pubsub package. The topic is configured with at-least-once delivery guarantee.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/pubsub.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage user\n\nimport \"encore.dev/pubsub\"\n\ntype SignupEvent struct{ UserID int }\n\nvar Signups = pubsub.NewTopic[*SignupEvent](\"signups\", pubsub.TopicConfig{\n    DeliveryGuarantee: pubsub.AtLeastOnce,\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a table in PostgreSQL using SQL migration\nDESCRIPTION: This SQL snippet demonstrates how to create a table named `todo_item` with columns for `id`, `title`, and `done`. It defines the primary key and sets a default value for the `done` column.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/databases.md#2025-04-21_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\n\"CREATE TABLE todo_item (\n  id BIGSERIAL PRIMARY KEY,\n  title TEXT NOT NULL,\n  done BOOLEAN NOT NULL DEFAULT false\n  -- etc...\n);\"\n```\n\n----------------------------------------\n\nTITLE: Defining Secrets with Encore's Config in Typescript\nDESCRIPTION: This snippet demonstrates how to define a secret in your TypeScript code using the `secret` function from the `encore.dev/config` package. The defined secret is then accessed as a function to retrieve its value. The Encore compiler checks that secrets are set before running or deploying the application.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/secrets.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { secret } from \"encore.dev/config\";\n\n// Personal access token for deployments\nconst githubToken = secret(\"GitHubAPIToken\");\n\n// Then, resolve the secret value by calling `githubToken()`.\n```\n\n----------------------------------------\n\nTITLE: Implementing Validation Middleware in Go with Encore\nDESCRIPTION: This snippet demonstrates how to create a global validation middleware that checks if the request payload has a Validate method and executes it. It uses the encore:middleware directive and targets all API endpoints.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/middleware.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport (\n    \"encore.dev/beta/errs\"\n    \"encore.dev/middleware\"\n)\n\n//encore:middleware global target=all\nfunc ValidationMiddleware(req middleware.Request, next middleware.Next) middleware.Response {\n    // If the payload has a Validate method, use it to validate the request.\n    payload := req.Data().Payload\n    if validator, ok := payload.(interface { Validate() error }); ok {\n        if err := validator.Validate(); err != nil {\n            // If the validation fails, return an InvalidArgument error.\n            err = errs.WrapCode(err, errs.InvalidArgument, \"validation failed\")\n            return middleware.Response{Err: err}\n        }\n    }\n    return next(req)\n}\n```\n\n----------------------------------------\n\nTITLE: Querying a single row using SQL with TypeScript\nDESCRIPTION: This TypeScript function `getTodoTitle` demonstrates how to query a single row from the `todo_item` table using `db.queryRow`. It retrieves the `title` column based on the provided `id`.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/databases.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n\"async function getTodoTitle(id: number): string | undefined {\n  const row = await db.queryRow`SELECT title FROM todo_item WHERE id = ${id}`;\n  return row?.title;\n}\"\n```\n\n----------------------------------------\n\nTITLE: Running the Encore Application\nDESCRIPTION: This shell command shows how to run the Encore application locally using the `encore run` command. This starts the local development environment, including both Encore and NestJS, allowing developers to test their application.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/how-to/nestjs.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ encore run\n```\n\n----------------------------------------\n\nTITLE: Microservices Communication in TypeScript\nDESCRIPTION: Compares service-to-service communication approaches in Express.js using fetch and Encore.ts with type-safe function calls, demonstrating Encore's simplified distributed system interactions\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/migration/express-migration.md#2025-04-21_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport express, {Request, Response} from \"express\";\n\nconst app: Express = express();\n\napp.get(\"/save-post\", async (req: Request, res: Response) => {\n  try {\n    // Calling another service using fetch\n    const resp = await fetch(\"https://another-service/posts\", {\n      method: \"POST\",\n      headers: {\"Content-Type\": \"application/json\"},\n      body: JSON.stringify({\n        title: req.query.title,\n        content: req.query.content,\n      }),\n    });\n    res.json(await resp.json());\n  } catch (e) {\n    res.status(500).json({error: \"Could not save post\"});\n  }\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport {api} from \"encore.dev/api\";\nimport {anotherService} from \"~encore/clients\";\n\nexport const microserviceCommunication = api(\n  {expose: true, method: \"GET\", path: \"/call\"},\n  async (): Promise<{ message: string }> => {\n    // Calling the foo endpoint in anotherService\n    const fooResponse = await anotherService.foo();\n\n    const msg = `Data from another service ${fooResponse.data}!`;\n    return {message: msg};\n  },\n```\n\n----------------------------------------\n\nTITLE: Generating Signed Download URL using Go\nDESCRIPTION: This snippet illustrates the creation of a signed download URL for securely downloading files from a storage bucket, allowing access without additional authentication. It uses a document identifier and defines a TTL for expiration.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/object-storage.md#2025-04-21_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nurl, err := Documents.SignedDownloadURL(ctx, \"letter-1234\", objects.WithTTL(time.Duration(7200)*time.Second))\\n// Pass url to client\n```\n\n----------------------------------------\n\nTITLE: Creating SQL Database with Encore.ts\nDESCRIPTION: Demonstrates how to create a new SQLDatabase using Encore.ts, with configuration for migrations and table creation\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SQLDatabase } from \"encore.dev/storage/sqldb\";\n\nconst db = new SQLDatabase(\"todo\", {\n  migrations: \"./migrations\",\n});\n\n-- todo/migrations/1_create_table.up.sql --\nCREATE TABLE todo_item (\n  id BIGSERIAL PRIMARY KEY,\n  title TEXT NOT NULL,\n  done BOOLEAN NOT NULL DEFAULT false\n);\n```\n\n----------------------------------------\n\nTITLE: Setting Cookies in Encore API Response\nDESCRIPTION: This snippet demonstrates how to set cookies in an Encore API response by using the 'header' tag with the 'Set-Cookie' header name in the response struct.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/defining-apis.md#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\ntype LoginResponse struct {\n    SessionID string `header:\"Set-Cookie\"`\n}\n\n//encore:api public method=POST path=/login\nfunc Login(ctx context.Context) (*LoginResponse, error) {\n    return &LoginResponse{SessionID: \"session=123\"}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting data with raw SQL using TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to insert data into the `todo_item` table using `db.rawExec` and raw SQL with parameters. It inserts a new row with the provided `title` and sets the `done` column to `false`.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/databases.md#2025-04-21_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n\"await db.rawExec(\n  \\\"INSERT INTO todo_item (title, done) VALUES ($1, $2)\\\",\n  title,\n  false\n);\"\n```\n\n----------------------------------------\n\nTITLE: Defining Temporal Workflow in Go\nDESCRIPTION: Implements a Temporal Workflow for composing a greeting. Includes both the workflow definition and an activity for creating the greeting string.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/temporal.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage workflow\n\nimport (\n\t\"time\"\n\n\t\"go.temporal.io/sdk/workflow\"\n)\n\nfunc Greeting(ctx workflow.Context, name string) (string, error) {\n    options := workflow.ActivityOptions{\n        StartToCloseTimeout: time.Second * 5,\n    }\n\n    ctx = workflow.WithActivityOptions(ctx, options)\n\n    var result string\n    err := workflow.ExecuteActivity(ctx, ComposeGreeting, name).Get(ctx, &result)\n\n    return result, err\n}\n```\n\nLANGUAGE: go\nCODE:\n```\npackage workflow\n\nimport (\n\t\"context\"\n\t\"fmt\"\n)\n\nfunc ComposeGreeting(ctx context.Context, name string) (string, error) {\n    greeting := fmt.Sprintf(\"Hello %s!\", name)\n    return greeting, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Data Sources in Request Schema in Encore.ts\nDESCRIPTION: This snippet shows how to create a request schema that combines data from URL paths, query parameters, HTTP headers, and request bodies using Encore.ts. The snippet specifies different sources for each field in the Request interface.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Header, Query, api } from \"encore.dev/api\";\n\ninterface Request {\n  // Required path parameter. Parsed from the request URL.\n  id: number;\n\n  // Optional query parameter. Parsed from the request URL.\n  limit?: Query<number>;\n\n  // Custom header that must be set. Parsed from the HTTP headers.\n  myHeader: Header<\"X-My-Header\">;\n\n  // Required enum. Parsed from the request body.\n  type: \"sprocket\" | \"widget\";\n}\n\nexport const myEndpoint = api(\n  { expose: true, method: \"POST\", path: \"/user/:id\" },\n  async ({ id, limit, myHeader, type }: Request) => {\n    // ...\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Serving Static Assets Using Encore.ts - TypeScript\nDESCRIPTION: This snippet demonstrates how to configure a static file-serving endpoint using Encore.ts. It uses the `api.static` function to expose files within the `./assets` directory under a URL prefix `/frontend`. The `expose` option ensures the files are publicly accessible. The snippet requires the Node.js environment and Encore.ts library.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/static-assets.mdx#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\n\nexport const assets = api.static(\n  { expose: true, path: \"/frontend/*path\", dir: \"./assets\" },\n);\n```\n\n----------------------------------------\n\nTITLE: Querying PostgreSQL Database with Go and Encore\nDESCRIPTION: Demonstrates how to query a PostgreSQL database using Encore's sqldb package. The example shows how to read a single todo item from the todo_item table using QueryRow.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/databases.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nvar item struct {\n    ID int64\n    Title string\n    Done bool\n}\nerr := tododb.QueryRow(ctx, `\n    SELECT id, title, done\n    FROM todo_item\n    LIMIT 1\n`).Scan(&item.ID, &item.Title, &item.Done)\n```\n\n----------------------------------------\n\nTITLE: Publishing Events to a PubSub Topic in Encore\nDESCRIPTION: Shows how to publish events to a PubSub topic in Encore. The example publishes a SignupEvent and commits a transaction after successful publishing.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/code-snippets.md#2025-04-21_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nif _, err := Signups.Publish(ctx, &SignupEvent{UserID: id}); err != nil {\n    return err\n}\n\nif err := tx.Commit(); err != nil {\n    return err\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing API Endpoint in Encore with Go\nDESCRIPTION: Initializes an API endpoint for a service using Encore in Go. This snippet includes request and response structs, handling functions, and registration logic, relying on Encore's `appruntime` package. It manages query string encoding/decoding and error handling for HTTP requests.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/request_query.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\npackage code\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\t__etype \"encore.dev/appruntime/shared/etype\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n}\n\ntype EncoreInternal_FooReq struct {\n\tPayload *Params\n}\n\ntype EncoreInternal_FooResp = __api.Void\n\nvar EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{\n\tAccess: __api.Public,\n\tAppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {\n\t\terr := Foo(ctx, reqData.Payload)\n\t\tif err != nil {\n\t\t\treturn __api.Void{}, err\n\t\t}\n\t\treturn __api.Void{}, nil\n\t},\n\tCloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {\n\t\tvar clone *EncoreInternal_FooReq\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tCloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {\n\t\tvar clone EncoreInternal_FooResp\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tDecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {\n\t\treturn __api.Void{}, nil\n\t},\n\tDecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {\n\t\treqData = new(EncoreInternal_FooReq)\n\t\tdec := new(__etype.Unmarshaller)\n\t\tparams := new(Params)\n\t\treqData.Payload = params\n\t\tswitch m := httpReq.Method; m {\n\t\tcase \"POST\":\n\t\t\t// Decode query string\n\t\t\tqs := httpReq.URL.Query()\n\t\t\tparams.Foo = __etype.UnmarshalOne(dec, __etype.UnmarshalString, \"foo\", qs.Get(\"foo\"), false)\n\t\t\tparams.Ints = __etype.UnmarshalList(dec, __etype.UnmarshalInt, \"ints\", qs[\"ints\"], false)\n\n\t\tdefault:\n\t\t\tpanic(\"HTTP method is not supported\")\n\t\t}\n\t\tif err := dec.Error; err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\treturn reqData, ps, nil\n\t},\n\tDefLoc: uint32(0x0),\n\tEncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {\n\t\tparams := reqData.Payload\n\t\tif params == nil {\n\t\t\t// If the payload is nil, we need to return an empty request body.\n\t\t\treturn httpHeader, queryString, err\n\t\t}\n\n\t\t// Encode query string\n\t\tqueryString = make(url.Values, 2)\n\t\tqueryString.Set(\"foo\", __etype.MarshalOne(__etype.MarshalString, params.Foo))\n\t\tqueryString[\"ints\"] = __etype.MarshalList(__etype.MarshalInt, params.Ints)\n\n\t\treturn httpHeader, queryString, err\n\t},\n\tEncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {\n\t\treturn nil\n\t},\n\tEndpoint:            \"Foo\",\n\tFallback:            false,\n\tGlobalMiddlewareIDs: []string{},\n\tMethods:             []string{\"POST\"},\n\tPath:                \"/code.Foo\",\n\tPathParamNames:      nil,\n\tRaw:                 false,\n\tRawHandler:          nil,\n\tRawPath:             \"/code.Foo\",\n\tReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {\n\t\treturn \"/code.Foo\", nil, nil\n\t},\n\tReqUserPayload: func(reqData *EncoreInternal_FooReq) any {\n\t\treturn reqData.Payload\n\t},\n\tService:           \"code\",\n\tServiceMiddleware: []*__api.Middleware{},\n\tSvcNum:            1,\n\tTags:              nil,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GetBookableSlots API Endpoint in Go\nDESCRIPTION: Go code implementing the GetBookableSlots API endpoint. This function retrieves bookable slots for a given date range, handling date parsing and slot generation.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n// Service booking keeps track of bookable slots in the calendar.\npackage booking\n\nimport (\n\t\"context\"\n\t\"github.com/jackc/pgx/v5/pgtype\"\n\t\"time\"\n)\n\nconst DefaultBookingDuration = 1 * time.Hour\n\ntype BookableSlot struct {\n\tStart time.Time `json:\"start\"`\n\tEnd   time.Time `json:\"end\"`\n}\n\ntype SlotsParams struct{}\n\ntype SlotsResponse struct{ Slots []BookableSlot }\n\n//encore:api public method=GET path=/slots/:from\nfunc GetBookableSlots(ctx context.Context, from string) (*SlotsResponse, error) {\n\tfromDate, err := time.Parse(\"2006-01-02\", from)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tconst numDays = 7\n\n\tvar slots []BookableSlot\n\tfor i := 0; i < numDays; i++ {\n\t\tdate := fromDate.AddDate(0, 0, i)\n\t\tdaySlots, err := bookableSlotsForDay(date)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tslots = append(slots, daySlots...)\n\t}\n\n\treturn &SlotsResponse{Slots: slots}, nil\n}\n\nfunc bookableSlotsForDay(date time.Time) ([]BookableSlot, error) {\n\t// 09:00\n\tavailStartTime := pgtype.Time{\n\t\tValid:        true,\n\t\tMicroseconds: int64(9*3600) * 1e6,\n\t}\n\t// 17:00\n\tavailEndTime := pgtype.Time{\n\t\tValid:        true,\n\t\tMicroseconds: int64(17*3600) * 1e6,\n\t}\n\n\tavailStart := date.Add(time.Duration(availStartTime.Microseconds) * time.Microsecond)\n\tavailEnd := date.Add(time.Duration(availEndTime.Microseconds) * time.Microsecond)\n\n\t// Compute the bookable slots in this day, based on availability.\n\tvar slots []BookableSlot\n\tstart := availStart\n\tfor {\n\t\tend := start.Add(DefaultBookingDuration)\n\t\tif end.After(availEnd) {\n\t\t\tbreak\n\t\t}\n\t\tslots = append(slots, BookableSlot{\n\t\t\tStart: start,\n\t\t\tEnd:   end,\n\t\t})\n\t\tstart = end\n\t}\n\n\treturn slots, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Auth Error Handling in Go\nDESCRIPTION: Example of handling authentication errors using Encore's built-in error package, demonstrating how to return appropriate error responses for authentication failures.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/auth.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nimport \"encore.dev/beta/errs\"\n\n//encore:authhandler\nfunc AuthHandler(ctx context.Context, token string) (auth.UID, error) {\n    return \"\", &errs.Error{\n        Code: errs.Unauthenticated,\n        Message: \"invalid token\",\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Path Parameters with Body Payloads in Encore (Go)\nDESCRIPTION: This snippet shows how to define a PUT endpoint in Encore that combines path parameters with body payloads. It specifies how to use function parameters for the path and JSON objects for the body content.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/defining-apis.md#2025-04-21_snippet_12\n\nLANGUAGE: Go\nCODE:\n```\n// UpdateBlogPost updates an existing blog post by id.\n//encore:api public method=PUT path=/blog/:id\nfunc UpdateBlogPost(ctx context.Context, id int, post *BlogPost) error {\n    // Use `post` to update the blog post with the given id.\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Request and Response Schemas in Encore\nDESCRIPTION: Shows how to define structured request and response types for API endpoints in Encore. These types define the contract for data exchange between clients and the API.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/code-snippets.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// PingParams is the request data for the Ping endpoint.\ntype PingParams struct {\n    Name string\n}\n\n// PingResponse is the response data for the Ping endpoint.\ntype PingResponse struct {\n    Message string\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GORM Service with Database Connection\nDESCRIPTION: This Go code defines a service struct with a GORM database connection, initializes the database using Encore's sqldb package, and establishes a connection to the Postgres database. It depends on the `encore.dev/storage/sqldb`, `gorm.io/driver/postgres`, and `gorm.io/gorm` packages.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/atlas-gorm.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n\"package blog\n\nimport (\n\t\\\"encore.dev/storage/sqldb\\\"\n\t\\\"gorm.io/driver/postgres\\\"\n\t\\\"gorm.io/gorm\\\"\n)\n\n\n//encore:service\ntype Service struct {\n\tdb *gorm.DB\n}\n\nvar blogDB = sqldb.NewDatabase(\\\"blog\\\", sqldb.DatabaseConfig{\n\tMigrations: \\\"./migrations\\\",\n})\n\n// initService initializes the site service.\n// It is automatically called by Encore on service startup.\nfunc initService() (*Service, error) {\n\tdb, err := gorm.Open(postgres.New(postgres.Config{\n\t\tConn: blogDB.Stdlib(),\n\t}))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Service{db: db}, nil\n}\"\n```\n\n----------------------------------------\n\nTITLE: Database Schema Migration in Encore\nDESCRIPTION: Example of creating and modifying database schema using sequential migration files, demonstrating initial table creation and schema modification\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_20\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE TABLE todo_item (\n    id BIGSERIAL PRIMARY KEY,\n    title TEXT NOT NULL,\n    done BOOLEAN NOT NULL\n);\n```\n\nLANGUAGE: SQL\nCODE:\n```\nALTER TABLE todo_item ADD created TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW();\n```\n\n----------------------------------------\n\nTITLE: Integrating Encore with SQL Database in TypeScript\nDESCRIPTION: Enhances the Encore URL shortening service to integrate with a SQL database. The `SQLDatabase` class is used to define a database, and the `shorten` function is modified to insert URL data into the database, providing persistent storage for shortened URLs.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/rest-api.mdx#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n-- url/url.ts --\nimport { api } from \"encore.dev/api\";\nimport { SQLDatabase } from \"encore.dev/storage/sqldb\";\nimport { randomBytes } from \"node:crypto\";\n\n// 'url' database is used to store the URLs that are being shortened.\nconst db = new SQLDatabase(\"url\", { migrations: \"./migrations\" });\n\ninterface URL {\n    id: string; // short-form URL id\n    url: string; // complete URL, in long form\n}\n\ninterface ShortenParams {\n    url: string; // the URL to shorten\n}\n\n// Shortens a URL.\nexport const shorten = api(\n    { method: \"POST\", path: \"/url\", expose: true },\n    async ({ url }: ShortenParams): Promise<URL> => {\n      const id = randomBytes(6).toString(\"base64url\");\n      await db.exec`\n        INSERT INTO url (id, original_url)\n        VALUES (${id}, ${url})\n      `;\n      return { id, url };\n    },\n  );\n```\n\n----------------------------------------\n\nTITLE: Generating Signed Upload URLs in TypeScript\nDESCRIPTION: This snippet demonstrates generating signed upload URLs with Encore.ts, enabling clients to upload files directly to a bucket with temporary URLs. The method generates URLs restricted to a single filename for a specified duration, enhancing the security and efficiency of client-side uploads by bypassing APIs for content transfers.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/object-storage.md#2025-04-21_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst uploadUrl = await profilePictures.signedUploadUrl(\"my-user-id\", {ttl: 7200})\n// Pass url to client\n```\n\n----------------------------------------\n\nTITLE: Middleware Ordering Configuration in Encore.ts\nDESCRIPTION: This snippet demonstrates how middleware execution order is determined in Encore.ts. Middleware functions are executed in the same order as they are defined within the `middlewares` array of the `Service` configuration. This allows developers to control the sequence in which middleware is applied to API requests.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/middleware.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport default new Service(\"myService\", {\n    middlewares: [\n        first,\n        second,\n        third\n    ],\n});\n\n```\n\n----------------------------------------\n\nTITLE: Signup Process with Environment-Specific Email Verification in Encore Go\nDESCRIPTION: This Go function, part of the Encore API, manages user signups by conditionally skipping email verification in testing and development environments. It uses the `encore.Meta()` method to determine the environment type and either sends a verification email or marks the user as verified. This requires the Encore package and a defined SignupParams structure. It takes a context and parameters for signup, returning a signup response or an error if verification fails.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/metadata.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage user\n\nimport \"encore.dev\"\n\n//encore:api public\nfunc Signup(ctx context.Context, params *SignupParams) (*SignupResponse, error) {\n    // ...\n\n    // If this is a testing environment, skip sending the verification email\n    switch encore.Meta().Environment.Type {\n    case encore.EnvTest, encore.EnvDevelopment:\n        if err := MarkEmailVerified(ctx, userID); err != nil {\n            return nil, err\n        }\n    default:\n        if err := SendVerificationEmail(ctx, userID); err != nil {\n            return nil, err\n        }\n    }\n\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Database in Go with Encore\nDESCRIPTION: Demonstrates how to create a PostgreSQL database using Encore's sqldb package. The example shows creating a 'todo' database with a migration file to create a todo_item table.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/databases.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage todo\n\n// Create the todo database and assign it to the \"tododb\" variable\nvar tododb = sqldb.NewDatabase(\"todo\", sqldb.DatabaseConfig{\n\tMigrations: \"./migrations\",\n})\n\n// Then, query the database using db.QueryRow, db.Exec, etc.\n```\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE todo_item (\n  id BIGSERIAL PRIMARY KEY,\n  title TEXT NOT NULL,\n  done BOOLEAN NOT NULL DEFAULT false\n  -- etc...\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Hello World API Endpoint in TypeScript\nDESCRIPTION: Example showing how to create a simple HTTP GET endpoint that takes a name parameter and returns a greeting message using Encore.ts framework.\nSOURCE: https://github.com/encoredev/encore/blob/main/README.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\n\nexport const get = api(\n  { expose: true, method: \"GET\", path: \"/hello/:name\" },\n  async ({ name }: { name: string }): Promise<Response> => {\n    const msg = `Hello ${name}!`;\n    return { message: msg };\n  }\n);\n\ninterface Response {\n  message: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Tracking Schema Migrations - SQL\nDESCRIPTION: This SQL snippet displays the structure of the `schema_migrations` table, which Encore uses to track applied migrations. It shows the columns, types, and the primary key index for the migration version.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/databases.md#2025-04-21_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ndatabase=# \\d schema_migrations\n          Table \"public.schema_migrations\"\n Column  |  Type   | Collation | Nullable | Default\n---------+---------+-----------+----------+---------\n version | bigint  |           | not null |\n dirty   | boolean |           | not null |\nIndexes:\n    \"schema_migrations_pkey\" PRIMARY KEY, btree (version)\n```\n\n----------------------------------------\n\nTITLE: Header Parameters in API Struct\nDESCRIPTION: Example of defining HTTP header parameters in request structs using the header tag.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/api-schemas.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ntype ListBlogPost struct {\n    Language string `header:\"Accept-Language\"`\n    Author      string // Not a header\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Request and Response Schemas with Encore.ts\nDESCRIPTION: This snippet demonstrates defining request and response schemas for API endpoints using Encore.ts. It shows how to create interfaces for request (PingParams) and response (PingResponse) data types. This structure is used in conjunction with the Encore.ts 'api' function to ensure type safety and proper mapping of request and response data.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/defining-apis.mdx#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n-- hello.ts --\nimport { api } from \"encore.dev/api\";\n\n// PingParams is the request data for the Ping endpoint.\ninterface PingParams {\n  name: string;\n}\n\n// PingResponse is the response data for the Ping endpoint.\ninterface PingResponse {\n  message: string;\n}\n\n// hello is an API endpoint that responds with a simple response.\nexport const hello = api(\n  { method: \"POST\", path: \"/hello\" },\n  async (p: PingParams): Promise<PingResponse> => {\n    return { message: `Hello ${p.name}!` };\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Uploading Profile Picture API Endpoint in Go\nDESCRIPTION: Implements an authenticated API endpoint for uploading profile pictures using Object Storage with error handling and context management\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/object-storage.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:api auth raw method=POST path=/upload-profile-picture\nfunc UploadProfilePicture(w http.ResponseWriter, req *http.Request) {\n\tuserID, _ := auth.UserID()\n\tkey := string(userID)\n\n\twriter := ProfilePictures.Upload(req.Context(), key)\n\t_, err := io.Copy(writer, req.Body)\n\tif err != nil {\n\t\twriter.Abort()\n\t\terrs.HTTPError(w, err)\n\t\treturn\n\t}\n\n\tif err := writer.Close(); err != nil {\n\t\terrs.HTTPError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n}\n```\n\n----------------------------------------\n\nTITLE: Prisma Schema Configuration for Encore.ts\nDESCRIPTION: Defines Prisma client generator with specific binary targets and configures PostgreSQL datasource for the User model\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/orms/prisma.md#2025-04-21_snippet_1\n\nLANGUAGE: prisma\nCODE:\n```\ngenerator client {\n  provider = \"prisma-client-js\"\n  binaryTargets = [\"native\", \"debian-openssl-3.0.x\"]\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = \"<paste connection uri to encore shadow db here>\"\n}\n\nmodel User {\n  id      Int      @id @default(autoincrement())\n  name    String\n  surname String\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Apollo Server with Encore Raw API\nDESCRIPTION: Implements the GraphQL endpoint using Apollo Server and Encore's Raw API. This creates a server that reads the GraphQL schema, uses the defined resolvers, and handles HTTP requests through a Raw API endpoint.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/graphql.mdx#2025-04-21_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\nimport { ApolloServer, HeaderMap } from \"@apollo/server\";\nimport { readFileSync } from \"node:fs\";\nimport resolvers from \"./resolvers\";\nimport { json } from \"node:stream/consumers\";\n\nconst typeDefs = readFileSync(\"./schema.graphql\", { encoding: \"utf-8\" });\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n});\n\nawait server.start();\n\nexport const graphqlAPI = api.raw(\n  { expose: true, path: \"/graphql\", method: \"*\" },\n  async (req, res) => {\n    server.assertStarted(\"/graphql\");\n\n    const headers = new HeaderMap();\n    for (const [key, value] of Object.entries(req.headers)) {\n      if (value !== undefined) {\n        headers.set(key, Array.isArray(value) ? value.join(\", \") : value);\n      }\n    }\n\n    // More on how to use executeHTTPGraphQLRequest: https://www.apollographql.com/docs/apollo-server/integrations/building-integrations/\n    const httpGraphQLResponse = await server.executeHTTPGraphQLRequest({\n      httpGraphQLRequest: {\n        headers,\n        method: req.method!.toUpperCase(),\n        body: await json(req),\n        search: new URLSearchParams(req.url ?? \"\").toString(),\n      },\n      context: async () => {\n        return { req, res };\n      },\n    });\n\n    for (const [key, value] of httpGraphQLResponse.headers) {\n      res.setHeader(key, value);\n    }\n    res.statusCode = httpGraphQLResponse.status || 200;\n\n    if (httpGraphQLResponse.body.kind === \"complete\") {\n      res.end(httpGraphQLResponse.body.string);\n      return;\n    }\n\n    for await (const chunk of httpGraphQLResponse.body.asyncIterator) {\n      res.write(chunk);\n    }\n    res.end();\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Mapping Body Parameters Using JSON Tags in Encore (Go)\nDESCRIPTION: This code outlines defining body parameters via struct tags in Encore. For requests other than GET, HEAD, or DELETE, request parameters are typically read from the body as JSON. The json tag can override default field names.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/defining-apis.md#2025-04-21_snippet_9\n\nLANGUAGE: Go\nCODE:\n```\ntype CreateBlogPost struct {\n    Subject    string `json:\"limit\"` // query if GET, HEAD or DELETE, otherwise body parameter\n    Author     string                // query if GET, HEAD or DELETE, otherwise body parameter\n}\n\n```\n\n----------------------------------------\n\nTITLE: Installing Encore on macOS using Homebrew\nDESCRIPTION: Command to install Encore on macOS using the Homebrew package manager.\nSOURCE: https://github.com/encoredev/encore/blob/main/README.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nbrew install encoredev/tap/encore\n```\n\n----------------------------------------\n\nTITLE: Implementing Schedules Service in Go\nDESCRIPTION: This Go code implements a schedules service providing HTTP endpoints to manage schedules. It defines a PostgreSQL schema and includes endpoint handlers for creating, retrieving, listing, and deleting schedules. Dependencies include the Encore framework and PostgreSQL database.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/incident-management-tool.md#2025-04-21_snippet_6\n\nLANGUAGE: Go\nCODE:\n```\n// Service schedules implements schedules to answer who should be assigned to an incident.\npackage schedules\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"time\"\n\n\t\"encore.app/users\"\n\t\"encore.dev/beta/errs\"\n\t\"encore.dev/storage/sqldb\"\n)\n\n// Define a database named 'schedules', using the database migrations\n// in the \"./migrations\" folder. Encore automatically provisions,\n// migrates, and connects to the database.\nvar db = sqldb.NewDatabase(\"schedules\", sqldb.DatabaseConfig{\n\tMigrations: \"./migrations\",\n})\n\n// This struct holds multiple Schedule structs\ntype Schedules struct {\n\tItems []Schedule\n}\n\n// This is a Go struct representing our PostgreSQL schema for `schedules`\ntype Schedule struct {\n\tId   int32\n\tUser users.User\n\tTime TimeRange\n}\n\n// As we use time ranges in our schedule, we created a generic TimeRange struct\ntype TimeRange struct {\n\tStart time.Time\n\tEnd   time.Time\n}\n\n//encore:api public method=POST path=/users/:userId/schedules\nfunc Create(ctx context.Context, userId int32, timeRange TimeRange) (*Schedule, error) {\n\teb := errs.B().Meta(\"userId\", userId, \"timeRange\", timeRange)\n\t// check for existing overlapping schedules\n\tif schedule, err := ScheduledAt(ctx, timeRange.Start.String()); schedule != nil && err == nil {\n\t\treturn nil, eb.Code(errs.InvalidArgument).Cause(err).Msg(\"schedule already exists within this start timestamp\").Err()\n\t}\n\tif schedule, err := ScheduledAt(ctx, timeRange.End.String()); schedule != nil && err == nil {\n\t\treturn nil, eb.Code(errs.InvalidArgument).Cause(err).Msg(\"schedule already exists within this end timestamp\").Err()\n\t}\n\n\t// check user exists\n\tuser, err := users.Get(ctx, userId)\n\tif err != nil {\n\t\treturn nil, eb.Code(errs.Unavailable).Cause(err).Msg(\"failed to get user\").Err()\n\t}\n\n\tschedule := Schedule{User: *user, Time: TimeRange{}}\n\terr = db.QueryRow(\n\t\tctx,\n\t\t`INSERT INTO schedules (user_id, start_time, end_time) VALUES ($1, $2, $3) RETURNING id, start_time, end_time`,\n\t\tuserId, timeRange.Start, timeRange.End,\n\t).Scan(&schedule.Id, &schedule.Time.Start, &schedule.Time.End)\n\tif err != nil {\n\t\treturn nil, eb.Code(errs.Unavailable).Cause(err).Msg(\"failed to insert schedule\").Err()\n\t}\n\n\treturn &schedule, nil\n}\n\n//encore:api public method=GET path=/scheduled\nfunc ScheduledNow(ctx context.Context) (*Schedule, error) {\n\treturn scheduled(ctx, time.Now())\n}\n\n//encore:api public method=GET path=/scheduled/:timestamp\nfunc ScheduledAt(ctx context.Context, timestamp string) (*Schedule, error) {\n\teb := errs.B().Meta(\"timestamp\", timestamp)\n\tparsedtime, err := time.Parse(time.RFC3339, timestamp)\n\tif err != nil {\n\t\treturn nil, eb.Code(errs.InvalidArgument).Msg(\"timestamp is not in a valid format\").Err()\n\t}\n\n\treturn scheduled(ctx, parsedtime)\n}\n\nfunc scheduled(ctx context.Context, timestamp time.Time) (*Schedule, error) {\n\teb := errs.B().Meta(\"timestamp\", timestamp)\n\tschedule, err := RowToSchedule(ctx, db.QueryRow(ctx, `\n\t\tSELECT id, user_id, start_time, end_time\n\t\tFROM schedules\n\t\tWHERE start_time <= $1\n\t\t  AND end_time >= $1\n\t`, timestamp.UTC()))\n\tif errors.Is(err, db.ErrNoRows) {\n\t\treturn nil, eb.Code(errs.NotFound).Msg(\"no schedule found\").Err()\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn schedule, nil\n}\n\n//encore:api public method=GET path=/schedules\nfunc ListByTimeRange(ctx context.Context, timeRange TimeRange) (*Schedules, error) {\n\trows, err := db.Query(ctx, `\n\t\tSELECT id, user_id, start_time, end_time\n\t\tFROM schedules\n\t\tWHERE start_time >= $1\n\t\tAND end_time <= $2\n\t\tORDER BY start_time ASC\n\t`, timeRange.Start, timeRange.End)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer rows.Close()\n\n\tvar schedules []Schedule\n\tfor rows.Next() {\n\t\tschedule, err := RowToSchedule(ctx, rows)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tschedules = append(schedules, *schedule)\n\t}\n\n\treturn &Schedules{Items: schedules}, nil\n}\n\n//encore:api public method=DELETE path=/schedules\nfunc DeleteByTimeRange(ctx context.Context, timeRange TimeRange) (*Schedules, error) {\n\tschedules, err := ListByTimeRange(ctx, timeRange)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t_, err = db.Exec(ctx, `DELETE FROM schedules WHERE start_time >= $1 AND end_time <= $2`, timeRange.Start, timeRange.End)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn schedules, err\n}\n\n// Helper function to convert a Row object to to Schedule\nfunc RowToSchedule(ctx context.Context, row interface {\n\tScan(dest ...interface{}) error\n}) (*Schedule, error) {\n\tvar schedule = &Schedule{Time: TimeRange{}}\n\tvar userId int32\n\n\terr := row.Scan(&schedule.Id, &userId, &schedule.Time.Start, &schedule.Time.End)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tuser, err := users.Get(ctx, userId)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tschedule.User = *user\n\treturn schedule, nil\n}\n```\n\n----------------------------------------\n\nTITLE: GraphQL Resolver calling REST API (TS)\nDESCRIPTION: This TypeScript snippet demonstrates a GraphQL resolver that calls a REST API endpoint to fetch data. It imports the generated `book` client and the `QueryResolvers` type. The `books` resolver calls the `book.list()` function to retrieve a list of books and returns the result.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/graphql.mdx#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n-- resolver.ts --\n// Import the book service from the generated service clients\nimport { book } from \"~encore/clients\";\nimport { QueryResolvers } from \"../__generated__/resolvers-types\";\n\nconst queries: QueryResolvers = {\n  books: async () => {\n    // Call book.list to get the list of books\n    const { books } = await book.list();\n    return books;\n  },\n};\n\nexport default queries;\n```\n\n----------------------------------------\n\nTITLE: Handling Sensitive Data in Encore Structures (Go)\nDESCRIPTION: This snippet specifies how to mark certain fields in request and response structures as sensitive using the encore tag in Encore. It ensures that fields tagged as such are redacted in logs and traces.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/defining-apis.md#2025-04-21_snippet_10\n\nLANGUAGE: Go\nCODE:\n```\ntype Updates struct {\n\tAuthor      string `json:\"author,omitempty\"`\n\tPublishTime time.Time `json:\"publish_time,omitempty\"`\n}\n\n// BatchUpdateParams is the request data for the BatchUpdate endpoint.\ntype BatchUpdateParams struct {\n\tRequester     string    `header:\"X-Requester\"`\n\tRequestTime   time.Time `header:\"X-Request-Time\"`\n\tCurrentAuthor string    `query:\"author\"`\n\tUpdates       *Updates  `json:\"updates\"`\n\tMySecretKey   string    `encore:\"sensitive\"`\n}\n\n// BatchUpdateResponse is the response data for the BatchUpdate endpoint.\ntype BatchUpdateResponse struct {\n\tServedBy   string       `header:\"X-Served-By\"`\n\tUpdatedIDs []uuid.UUID  `json:\"updated_ids\"`\n}\n\n//encore:api public method=POST path=/section/:sectionID/posts\nfunc BatchUpdate(ctx context.Context, sectionID string, params *BatchUpdateParams) (*BatchUpdateResponse, error) {\n\t// Update blog posts for section\n\treturn &BatchUpdateResponse{ServedBy: hostname, UpdatedIDs: ids}, nil\n}\n\n```\n\n----------------------------------------\n\nTITLE: Deleting Objects from a Bucket using TypeScript\nDESCRIPTION: This snippet illustrates how to remove a file from an object storage bucket using the `remove` method in Encore.ts. It involves specifying the file name to delete, making it an efficient operation for managing the lifecycle of stored data. The simplicity of the method allows for straightforward implementation in object management workflows.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/object-storage.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nawait profilePictures.remove(\"my-image.jpeg\");\n```\n\n----------------------------------------\n\nTITLE: Authentication Error Handling\nDESCRIPTION: Shows recommended error handling pattern for authentication failures using Encore's error system\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_26\n\nLANGUAGE: go\nCODE:\n```\nreturn \"\", &errs.Error{\n    Code: errs.Unauthenticated,\n    Message: \"invalid token\",\n}\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for Basic Encore Application\nDESCRIPTION: Shows the folder structure for a basic Encore application with two services: hello and world. The hello service includes database migrations and tests.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/app-structure.md#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n/my-app\n encore.app                       // ... and other top-level project files\n\n hello                            // hello service (a Go package)\n    migrations                   // hello service db migration (directory)\n       1_create_table.up.sql    // hello service db migration\n    hello.go                     // hello service code\n    hello_test.go                // tests for hello service\n\n world                            // world service (a Go package)\n     world.go                     // world service code\n```\n\n----------------------------------------\n\nTITLE: Structured Authentication Handler with Parameters\nDESCRIPTION: Implements an authentication handler that processes structured parameters including session cookie, client ID, and authorization header\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_25\n\nLANGUAGE: go\nCODE:\n```\ntype MyAuthParams struct {\n    SessionCookie *http.Cookie `cookie:\"session\"`\n    ClientID string `query:\"client_id\"`\n    Authorization string `header:\"Authorization\"`\n}\n\n//encore:authhandler\nfunc AuthHandler(ctx context.Context, p *MyAuthParams) (auth.UID, error) {\n    // Process structured auth params\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Cron Job with Custom Schedule Expression in Go\nDESCRIPTION: Example showing how to create a Cron Job using a custom cron expression for more precise scheduling. This example runs a monthly accounting sync at 4am UTC on the 15th of each month.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/cron-jobs.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// Run the monthly accounting sync job at 4am (UTC) on the 15th day of each month.\nvar _ = cron.NewJob(\"accounting-sync\", cron.JobConfig{\n\tTitle:    \"Cron Job Example\",\n\tSchedule: \"0 4 15 * *\",\n\tEndpoint: AccountingSync,\n})\n```\n\n----------------------------------------\n\nTITLE: Optional Fields in Request Schema\nDESCRIPTION: This snippet shows how to define optional fields in a request schema. If optional fields are missing, the value will be undefined in the handler.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Request {\n  name?: string;\n}\n\nexport const myEndpoint = api(\n  { expose: true, method: \"POST\", path: \"/body\" },\n  async (req: Request) => {\n    // req.name is a string or undefined\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Handling API Errors in Encore.ts\nDESCRIPTION: Demonstrates how to throw properly formatted API errors in Encore.ts. Shows both the standard error creation and shorthand methods, which automatically set the appropriate HTTP status code based on the error type.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { APIError, ErrCode } from \"encore.dev/api\";\nthrow new APIError(ErrCode.NotFound, \"sprocket not found\");\n// shorthand version:\nthrow APIError.notFound(\"sprocket not found\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Site Service CRUD Operations\nDESCRIPTION: TypeScript implementation of the site service including CRUD operations using Knex.js\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\nimport { SQLDatabase } from \"encore.dev/storage/sqldb\";\nimport knex from \"knex\";\n\nexport interface Site {\n  id: number;\n  url: string;\n}\n\nexport interface AddParams {\n  url: string;\n}\n\nexport const add = api(\n  { expose: true, method: \"POST\", path: \"/site\" },\n  async (params: AddParams): Promise<Site> => {\n    const site = (await Sites().insert({ url: params.url }, \"*\"))[0];\n    return site;\n  },\n);\n\nexport const get = api(\n  { expose: true, method: \"GET\", path: \"/site/:id\", auth: false },\n  async ({ id }: { id: number }): Promise<Site> => {\n    const site = await Sites().where(\"id\", id).first();\n    return site ?? Promise.reject(new Error(\"site not found\"));\n  },\n);\n\nexport const del = api(\n  { expose: true, method: \"DELETE\", path: \"/site/:id\" },\n  async ({ id }: { id: number }): Promise<void> => {\n    await Sites().where(\"id\", id).delete();\n  },\n);\n\nexport interface ListResponse {\n  sites: Site[];\n}\n\nexport const list = api(\n  { expose: true, method: \"GET\", path: \"/site\" },\n  async (): Promise<ListResponse> => {\n    const sites = await Sites().select();\n    return { sites };\n  },\n);\n\nconst SiteDB = new SQLDatabase(\"site\", {\n  migrations: \"./migrations\",\n});\n\nconst orm = knex({\n  client: \"pg\",\n  connection: SiteDB.connectionString,\n});\n\nconst Sites = () => orm<Site>(\"site\");\n```\n\n----------------------------------------\n\nTITLE: Defining Parameters for API Calls in Go\nDESCRIPTION: This snippet defines the Params structure which includes fields for parameters expected in the API request headers. It uses struct tags to specify header names for the fields. This structure is essential for handling input parameters in the Foo function.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/request_headers.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport \"context\"\n\ntype Params struct {\n    Foo   string `header:\"X-Foo\"`  \n    Ignore string `header:\"-\"`  \n    Strings []string `header:\"X-Strings\"`  \n}\n\n//encore:api public\nfunc Foo(ctx context.Context, p *Params) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Creating SQL Migration File for User Table\nDESCRIPTION: This snippet provides an example SQL script to create a 'user' table for the Encore application. It defines the structure of the table, including columns and constraints, to facilitate user data management within the database.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/orms/sequelize.md#2025-04-21_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\n-- migrations/1_create_user.up.sql --\nCREATE TABLE \"user\" (\n  id SERIAL PRIMARY KEY,\n  name TEXT NOT NULL,\n  surname TEXT NOT NULL\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing SaveNote Endpoint in Go\nDESCRIPTION: Go function implementing the SaveNote endpoint, which stores or updates a meeting note in the database.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/meeting-notes.mdx#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public method=POST path=/note\nfunc SaveNote(ctx context.Context, note *Note) (*Note, error) {\n\t// Save the note to the database.\n\t// If the note already exists (i.e. CONFLICT), we update the notes text and the cover URL.\n\t_, err := sqldb.Exec(ctx, `\n\t\tINSERT INTO note (id, text, cover_url) VALUES ($1, $2, $3)\n\t\tON CONFLICT (id) DO UPDATE SET text=$2, cover_url=$3\n\t`, note.ID, note.Text, note.CoverURL)\n\n\t// If there was an error saving to the database, then we return that error.\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Otherwise, we return the note to indicate that the save was successful.\n\treturn note, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Email Service with SendGrid Client Injection\nDESCRIPTION: Demonstrates setting up a basic email service struct with dependency injection for a SendGrid client. Uses the encore:service directive to define a service struct with an injected SendGrid client dependency.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/dependency-injection.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage email\n\n//encore:service\ntype Service struct {\n\tsendgridClient *sendgrid.Client\n}\n\nfunc initService() (*Service, error) {\n    client, err := sendgrid.NewClient()\n    if err != nil {\n        return nil, err\n    }\n    return &Service{sendgridClient: client}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Test Data on Startup Using go:embed in Go with Encore\nDESCRIPTION: This snippet demonstrates how to conditionally insert test data on startup using go:embed and Encore's metadata API. It checks if the environment is local before executing the SQL fixtures.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/insert-test-data-db.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport (\n    _ \"embed\"\n    \"log\"\n\n    \"encore.dev\"\n)\n\n//go:embed fixtures.sql\nvar fixtures string\n\nfunc init() {\n    if encore.Meta().Environment.Cloud == encore.CloudLocal {\n        if _, err := sqldb.Exec(context.Background(), fixtures); err != nil {\n            log.Fatalln(\"unable to add fixtures:\", err)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Receiving Webhooks in Encore\nDESCRIPTION: Shows how to create an API endpoint for receiving raw HTTP webhooks using the //encore:api public raw annotation. This exposes an endpoint that accepts standard HTTP requests and responses.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/code-snippets.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nimport \"net/http\"\n\n// Webhook receives incoming webhooks from Some Service That Sends Webhooks.\n//encore:api public raw\nfunc Webhook(w http.ResponseWriter, req *http.Request) {\n    // ... operate on the raw HTTP request ...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Database Connection with Sequelize in Encore.ts\nDESCRIPTION: This snippet demonstrates how to initialize a Sequelize instance with a SQLDatabase connection in the Encore framework. It sets up the database connection using a specified connection string and defines a User model for PostgreSQL interactions.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/orms/sequelize.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// database.ts\nimport {\n  Model,\n  InferAttributes,\n  InferCreationAttributes,\n  CreationOptional,\n  DataTypes,\n  Sequelize,\n} from \"sequelize\";\nimport { SQLDatabase } from \"encore.dev/storage/sqldb\";\n\n// Create SQLDatabase instance with migrations configuration\nconst DB = new SQLDatabase(\"encore_sequelize_test\", {\n  migrations: \"./migrations\",\n});\n\n// Initialize Sequelize with the connection string\nconst sequelize = new Sequelize(DB.connectionString);\n\n// Define the User model\nclass User extends Model<InferAttributes<User>, InferCreationAttributes<User>> {\n  declare id: CreationOptional<number>;\n  declare name: string;\n  declare surname: string;\n}\n\n// Example usage: Count all users\nconst count = await User.count();\n```\n\n----------------------------------------\n\nTITLE: Implementing GET Endpoint in Encore (Go)\nDESCRIPTION: This snippet demonstrates creating a public API endpoint in Encore that fetches a list of blog posts using query parameters. The `ListBlogPosts` function extracts the parameters from the URL for GET-type requests and uses them to query the database.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/defining-apis.md#2025-04-21_snippet_8\n\nLANGUAGE: Go\nCODE:\n```\ntype ListParams struct {\n    Limit uint // number of blog posts to return\n    Offset uint // number of blog posts to skip, for pagination\n}\n\ntype ListResponse struct {\n    Posts []*BlogPost\n}\n\n//encore:api public method=GET path=/blog\nfunc ListBlogPosts(ctx context.Context, opts *ListParams) (*ListResponse, error) {\n    // Use limit and offset to query database...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Pub/Sub Events in Go with Encore\nDESCRIPTION: Shows how to create a subscription to a Pub/Sub topic, including specifying the topic, subscription name, and handler function for processing events.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/pubsub.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage email\n\nimport (\n    \"encore.dev/pubsub\"\n    \"user\"\n)\n\nvar _ = pubsub.NewSubscription(\n    user.Signups, \"send-welcome-email\",\n    pubsub.SubscriptionConfig[*SignupEvent]{\n        Handler: SendWelcomeEmail,\n    },\n)\nfunc SendWelcomeEmail(ctx context.Context, event *SignupEvent) error {\n    // send email...\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Request/Response Structure in Go\nDESCRIPTION: Example of a nested struct showing header, query, and body parameter handling in Encore APIs.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/api-schemas.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype NestedRequestResponse struct {\n\tHeader string `header:\"X-Header\"`\n\tQuery  string `query:\"query\"`\n\tBody1  string `json:\"body1\"`\n\tNested struct {\n\t    Header2 string `header:\"X-Header2\"`\n\t\tQuery2  string `query:\"query2\"`\n\t\tBody2   string `json:\"body2\"`\n    } `json:\"nested\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing to Pub/Sub Topic in Go with Encore\nDESCRIPTION: This snippet demonstrates how to publish a message to the defined pub/sub topic. It includes an API endpoint that takes a MessageType and publishes it to the BasicTopic.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_subscriber_creates_service.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"test/shared\"\n)\n\n// encore:api\nfunc DoStuff(ctx context.Context, msg *shared.MessageType) error {\n    shared.BasicTopic.Publish(ctx, msg)\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Request Schema with Multiple Field Types\nDESCRIPTION: This snippet demonstrates a complex request schema that integrates multiple field types, including optional, nullable, and union types.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Schema {\n  str: string; // String\n  int: number; // Number\n  list: number[]; // Array of numbers\n  listOfTypes: (number | string )[]; // Array multiple types\n  nullable: number | null; // Nullable\n  maybe?: string; // Optional\n  multiple: boolean | number | string | { name: string }; // Union\n  enum: \"John\" | \"Foo\"; // Enum\n}\n```\n\n----------------------------------------\n\nTITLE: Auth Context Override in Go\nDESCRIPTION: Example showing how to override authentication context for testing purposes using auth.WithContext function.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/auth.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nctx := auth.WithContext(context.Background(), auth.UID(\"my-user-id\"), &MyAuthData{Email: \"hello@example.com\"})\n// ... Make an API call using `ctx` to override the auth information for that API call.\n```\n\n----------------------------------------\n\nTITLE: Inserting Data into PostgreSQL Database with Go and Encore\nDESCRIPTION: Shows how to insert data into a PostgreSQL database using Encore's sqldb package. The example includes a helper function to insert a todo item into the todo_item table.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/databases.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// insert inserts a todo item into the database.\nfunc insert(ctx context.Context, id, title string, done bool) error {\n\t_, err := tododb.Exec(ctx, `\n\t\tINSERT INTO todo_item (id, title, done)\n\t\tVALUES ($1, $2, $3)\n\t`, id, title, done)\n\treturn err\n}\n```\n\nLANGUAGE: go\nCODE:\n```\npackage todo\n\n// Create the todo database and assign it to the \"tododb\" variable\nvar tododb = sqldb.NewDatabase(\"todo\", sqldb.DatabaseConfig{\n  Migrations: \"./migrations\",\n})\n\n// Then, query the database using db.QueryRow, db.Exec, etc.\n```\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE todo_item (\n  id BIGSERIAL PRIMARY KEY,\n  title TEXT NOT NULL,\n  done BOOLEAN NOT NULL DEFAULT false\n  -- etc...\n);\n```\n\n----------------------------------------\n\nTITLE: Defining a StreamOut API Endpoint in Encore\nDESCRIPTION: This code defines a StreamOut API endpoint using Encore's `api.streamOut` method. It demonstrates how to specify handshake and outgoing message types, and how to send messages to the client through the stream. The mockedLogs function simulates streaming logs to the client with a delay between each log entry and closes the stream when all logs are sent.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/streaming-apis.mdx#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api, StreamOut } from \"encore.dev/api\";\nimport log from \"encore.dev/log\";\n\n// Used to pass initial data, optional.\ninterface Handshake {\n  rows: number;\n}\n\n// What the server sends over the stream.\ninterface Message {\n  row: string;\n}\n\nexport const logStream = api.streamOut<Handshake, Message>(\n  { path: \"/logs\", expose: true },\n  async (handshake, stream) => {\n    try {\n      for await (const row of mockedLogs(handshake.rows, stream)) {\n        // Send the message to the client\n        await stream.send({ row });\n      }\n    } catch (err) {\n      log.error(\"Upload error:\", err);\n    }\n  },\n);\n\n// This function generates an async iterator that yields mocked log rows\nasync function* mockedLogs(rows: number, stream: StreamOut<Message>) {\n  for (let i = 0; i < rows; i++) {\n    yield new Promise<string>((resolve) => {\n      setTimeout(() => {\n        resolve(`Log row ${i + 1}`);\n      }, 500);\n    });\n  }\n\n  // Close the stream when all logs have been sent\n  await stream.close();\n}\n\n```\n\n----------------------------------------\n\nTITLE: GraphQL Schema Definition (GraphQL)\nDESCRIPTION: This snippet defines a GraphQL schema using GraphQL's Schema Definition Language (SDL). It defines a `Query` type with a `books` field that returns a list of `Book` types.  It also defines the `Book` type with `title` and `author` fields.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/graphql.mdx#2025-04-21_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\n-- schema.graphql --\ntype Query {\n  books: [Book]\n}\n\ntype Book {\n  title: String!\n  author: String!\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Auth Handler Implementation in Go\nDESCRIPTION: Simple authentication handler implementation that only returns a user ID without custom data. Suitable for cases where only user identification is needed.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/auth.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nimport \"encore.dev/beta/auth\"\n\n// AuthHandler can be named whatever you prefer (but must be exported).\n//encore:authhandler\nfunc AuthHandler(ctx context.Context, token string) (auth.UID, error) {\n    // Validate the token and look up the user id,\n    // for example by calling Firebase Auth.\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Incidents Table in PostgreSQL\nDESCRIPTION: SQL migration to create the 'incidents' table with fields for id, assigned user, body, creation time, and acknowledgment time.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/incident-management-tool.md#2025-04-21_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE incidents\n(\n    id               BIGSERIAL PRIMARY KEY,\n    assigned_user_id INTEGER,\n    body             TEXT      NOT NULL,\n    created_at       TIMESTAMP NOT NULL DEFAULT NOW(),\n    acknowledged_at  TIMESTAMP\n);\n```\n\n----------------------------------------\n\nTITLE: Generating API Access Token with OAuth Client - Go\nDESCRIPTION: This Go code snippet demonstrates how to create an OAuth client object using the client ID and client secret, and then use it to generate an API access token for the Encore Cloud API. It illustrates how to configure the client credentials and make API requests with the generated client.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/integrations/oauth-clients.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n\"package main\\n\\nimport (\\n    \\\"context\\\"\\n    \\\"os\\\"\\n\\n    \\\"golang.org/x/oauth2/clientcredentials\\\"\\n)\\n\\nfunc main() {\\n    oauthConfig := &clientcredentials.Config{\\n        ClientID:     os.Getenv(\\\"OAUTH_CLIENT_ID\\\"),\\n        ClientSecret: os.Getenv(\\\"OAUTH_CLIENT_SECRET\\\"),\\n        TokenURL:     \\\"https://api.encore.cloud/api/oauth/token\\\",\\n    }\\n\\n    client := oauthConfig.Client(context.Background())\\n\\n    // Make API calls using `client.Get` etc.\\n    resp, err := client.Get(\\\"https://api.encore.cloud.com/api/...\\\")\\n    // ...\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Computing Expected Signature in Go\nDESCRIPTION: This snippet shows how to compute the expected HMAC signature using SHA256 for verifying webhook requests. It uses the webhook secret to generate the HMAC of the payload and then encodes the result using base64 URL encoding, removing any trailing '=' characters.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/integrations/webhooks.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n```go\nh := hmac.New(sha256.New, []byte(webhookSecret))\nh.Write([]byte(payloadToSign))\ndigest := h.Sum(nil)\nexpectedSignature := base64.RawURLEncoding.EncodeToString(digest)\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Up Testing Script in Package.json\nDESCRIPTION: This JSON configuration guides the update of `package.json` to incorporate Vitest as the test running script. By adding `\"test\": \"vitest\"` under scripts, it configures Encore applications to use Vitest for executing tests, simplifying the initiation of test commands.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/testing.md#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"scripts\\\": {\\n    \\\"test\\\": \\\"vitest\\\"\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuration Type Definition and Loading\nDESCRIPTION: Shows how to define and load configuration types using Encore's config package\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_28\n\nLANGUAGE: go\nCODE:\n```\npackage mysvc\n\nimport \"encore.dev/config\"\n\ntype SomeConfigType struct {\n    ReadOnly config.Bool\n    Example  config.String\n}\n\nvar cfg *SomeConfigType = config.Load[*SomeConfigType]()\n```\n\n----------------------------------------\n\nTITLE: Setting Auth0 Client Secret as Encore Secret\nDESCRIPTION: This shell command sets the Auth0 client secret as an Encore secret for both production and development environments. This approach ensures the sensitive client secret is securely stored, thereby preventing its exposure in the codebase.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/auth0-auth.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ encore secret set --prod Auth0ClientSecret\n$ encore secret set --dev Auth0ClientSecret\n```\n\n----------------------------------------\n\nTITLE: Defining Public API and Interacting with Databases in Go\nDESCRIPTION: This snippet defines a public API endpoint `Foo` using the `//encore:api public` annotation. The `Foo` function interacts with the database connections `Moo` and `Bar` using `sqldb.QueryRow`, `Moo.Exec`, and `Bar.Stdlib`. It showcases how to perform database queries and operations within an Encore API endpoint.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/svc_migration_db.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n//encore:api public\nfunc Foo(ctx context.Context) error {\n    sqldb.QueryRow(ctx, \"\")\n    Moo.Exec(ctx, \"\")\n    Bar.Stdlib()\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Encore Request Client\nDESCRIPTION: Command to generate a TypeScript or JavaScript request client for an Encore application, which keeps request/response types in sync and assists in calling APIs.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/integrate-frontend.mdx#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ encore gen client <ENCORE-APP-ID> --output=./src/client.ts --env=<ENV_NAME>\n```\n\n----------------------------------------\n\nTITLE: Creating an Ordered Pub/Sub Topic in Go with Encore\nDESCRIPTION: Shows how to create an ordered Pub/Sub topic for cart events, ensuring messages for the same cart ID are delivered in order. The topic uses the 'cart_id' field as the ordering attribute.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/pubsub.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage example\n\nimport (\n\t\"context\"\n\t\"encore.dev/pubsub\"\n)\n\ntype CartEvent struct {\n\tShoppingCartID int `pubsub-attr:\"cart_id\"`\n\tEvent          string\n}\n\nvar CartEvents = pubsub.NewTopic[*CartEvent](\"cart-events\", pubsub.TopicConfig{\n\tDeliveryGuarantee: pubsub.AtLeastOnce,\n\tOrderingAttribute: \"cart_id\",\n})\n\nfunc Example(ctx context.Context) error {\n\t// These are delivered in order as they all have the same shopping cart ID\n\tCartEvents.Publish(ctx, &CartEvent{ShoppingCartID: 1, Event: \"item_added\"})\n\tCartEvents.Publish(ctx, &CartEvent{ShoppingCartID: 1, Event: \"checkout_started\"})\n\tCartEvents.Publish(ctx, &CartEvent{ShoppingCartID: 1, Event: \"checkout_completed\"})\n\n\t// This event may be delivered at any point as it has a different shopping cart ID\n\tCartEvents.Publish(ctx, &CartEvent{ShoppingCartID: 2, Event: \"item_added\"})\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a SQL Database in Encore\nDESCRIPTION: Shows how to create and configure a SQL database using Encore's sqldb package. The database is defined as a package-level variable with migration files to define the schema.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/code-snippets.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n-- todo/db.go --\npackage todo\n\n// Create the todo database and assign it to the \"tododb\" variable\nvar tododb = sqldb.NewDatabase(\"todo\", sqldb.DatabaseConfig{\n\tMigrations: \"./migrations\",\n})\n\n// Then, query the database using db.QueryRow, db.Exec, etc.\n-- todo/migrations/1_create_table.up.sql --\nCREATE TABLE todo_item (\n  id BIGSERIAL PRIMARY KEY,\n  title TEXT NOT NULL,\n  done BOOLEAN NOT NULL DEFAULT false\n  -- etc...\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Booking Utility Functions in Go\nDESCRIPTION: Helper functions for listing bookings within a time range and filtering bookable slots based on existing bookings and current time, preventing double bookings and past slots from being selected.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_16\n\nLANGUAGE: go\nCODE:\n```\nfunc listBookingsBetween(\n\tctx context.Context,\n\tstart, end time.Time,\n) ([]*Booking, error) {\n\trows, err := query.ListBookingsBetween(ctx, db.ListBookingsBetweenParams{\n\t\tStartTime: pgtype.Timestamp{Time: start, Valid: true},\n\t\tEndTime:   pgtype.Timestamp{Time: end, Valid: true},\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar bookings []*Booking\n\tfor _, row := range rows {\n\t\tbookings = append(bookings, &Booking{\n\t\t\tID:    row.ID,\n\t\t\tStart: row.StartTime.Time,\n\t\t\tEnd:   row.EndTime.Time,\n\t\t\tEmail: row.Email,\n\t\t})\n\t}\n\treturn bookings, nil\n}\n\nfunc filterBookableSlots(\n\tslots []BookableSlot,\n\tnow time.Time,\n\tbookings []*Booking,\n) []BookableSlot {\n\t// Remove slots for which the start time has already passed.\n\tslots = slices.DeleteFunc(slots, func(s BookableSlot) bool {\n\t\t// Has the slot already passed?\n\t\tif s.Start.Before(now) {\n\t\t\treturn true\n\t\t}\n\n\t\t// Is there a booking that overlaps with this slot?\n\t\tfor _, b := range bookings {\n\t\t\tif b.Start.Before(s.End) && b.End.After(s.Start) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t})\n\treturn slots\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Token Validation with Firebase in Go\nDESCRIPTION: Complete implementation of the ValidateToken function to verify Firebase ID tokens and extract user data.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/firebase-auth.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc ValidateToken(ctx context.Context, token string) (auth.UID, *Data, error) {\n    if err := setupFB(); err != nil {\n\t\treturn \"\", nil, err\n\t}\n\ttok, err := fbAuth.VerifyIDToken(ctx, token)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\temail, _ := tok.Claims[\"email\"].(string)\n\tname, _ := tok.Claims[\"name\"].(string)\n\tpicture, _ := tok.Claims[\"picture\"].(string)\n\tuid := auth.UID(tok.UID)\n\n\tusr := &Data{\n\t\tEmail:   email,\n\t\tName:    name,\n\t\tPicture: picture,\n\t}\n\treturn uid, usr, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Mounting Connect Service in Encore\nDESCRIPTION: Go code to create an Encore service struct that initializes the Connect service and a raw endpoint to forward requests.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/grpc-connect.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage greet\n\nimport (\n\t\"net/http\"\n\n\t\"encore.app/gen/greet/v1/greetv1connect\"\n\t\"golang.org/x/net/http2\"\n\t\"golang.org/x/net/http2/h2c\"\n)\n\n//encore:service\ntype Service struct {\n\troutes http.Handler\n}\n\n//encore:api public raw path=/greet.v1.GreetService/*endpoint\nfunc (s *Service) GreetService(w http.ResponseWriter, req *http.Request) {\n\ts.routes.ServeHTTP(w, req)\n}\n\nfunc initService() (*Service, error) {\n\tgreeter := &GreetServer{}\n\tmux := http.NewServeMux()\n\tpath, handler := greetv1connect.NewGreetServiceHandler(greeter)\n\tmux.Handle(path, handler)\n\treturn &Service{routes: mux}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Connection String Format for PostgreSQL Database\nDESCRIPTION: Example PostgreSQL connection string format for connecting to an external database hosted on DigitalOcean.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/connect-existing-db.md#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npostgresql://user:password@externaldb-do-user-1234567-0.db.ondigitalocean.com:25010/externaldb?sslmode=require\n```\n\n----------------------------------------\n\nTITLE: Implementing URL Shortener API with Encore in TypeScript\nDESCRIPTION: Complete implementation of a URL shortener service with endpoints to shorten URLs and retrieve original URLs by their short IDs. Uses PostgreSQL database for storage and Encore's API framework for creating endpoints.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/rest-api.mdx#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api, APIError } from \"encore.dev/api\";\nimport { SQLDatabase } from \"encore.dev/storage/sqldb\";\nimport { randomBytes } from \"node:crypto\";\n\n// 'url' database is used to store the URLs that are being shortened.\nconst db = new SQLDatabase(\"url\", { migrations: \"./migrations\" });\n\ninterface URL {\n    id: string; // short-form URL id\n    url: string; // complete URL, in long form\n}\n\ninterface ShortenParams {\n    url: string; // the URL to shorten\n}\n\n// Shortens a URL.\nexport const shorten = api(\n    { method: \"POST\", path: \"/url\", expose: true },\n    async ({ url }: ShortenParams): Promise<URL> => {\n      const id = randomBytes(6).toString(\"base64url\");\n      await db.exec`\n        INSERT INTO url (id, original_url)\n        VALUES (${id}, ${url})\n      `;\n      return { id, url };\n    },\n  );\n\n  // Get retrieves the original URL for the id.\nexport const get = api(\n    { expose: true, auth: false, method: \"GET\", path: \"/url/:id\" },\n    async ({ id }: { id: string }): Promise<URL> => {\n      const row = await db.queryRow`\n          SELECT original_url FROM url WHERE id = ${id}\n      `;\n      if (!row) throw APIError.notFound(\"url not found\");\n      return { id, url: row.original_url };\n    }\n  );\n```\n\n----------------------------------------\n\nTITLE: Pub/Sub Topic Definition in Encore\nDESCRIPTION: Creating a type-safe pub/sub topic for signup events with at-least-once delivery guarantee\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_16\n\nLANGUAGE: go\nCODE:\n```\ntype SignupEvent struct{ UserID int }\n\nvar Signups = pubsub.NewTopic[*SignupEvent](\"signups\", pubsub.TopicConfig{\n    DeliveryGuarantee: pubsub.AtLeastOnce,\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Logto Authentication Handler in Go\nDESCRIPTION: Create an auth handler to validate Logto JWT tokens and extract user IDs. This implementation uses Encore's auth handler interface and includes configuration loading, JWT parsing, and claim validation.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/logto-auth.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage auth\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"encore.dev/beta/auth\"\n\t\"encore.dev/beta/errs\"\n\t\"encore.dev/config\"\n\t\"github.com/MicahParks/keyfunc/v3\"\n\t\"github.com/golang-jwt/jwt/v5\"\n)\n\n// Configuration variables for authentication\ntype LogtoAuthConfig struct {\n\t// The issuer URL\n\tIssuer config.String\n\t// URL to fetch JSON Web Key Set (JWKS)\n\tJwksUri config.String\n\t// Expected audience for the JWT\n\tApiResourceIndicator config.String\n\t// Expected client ID in the token claims\n\tClientId config.String\n}\n\nvar authConfig *LogtoAuthConfig = config.Load[*LogtoAuthConfig]()\n\n// RequiredClaims defines the expected structure of JWT claims\n// Extends the standard JWT claims with a custom ClientID field\ntype RequiredClaims struct {\n\tClientID string `json:\"client_id\"`\n\tjwt.RegisteredClaims\n}\n\n// AuthHandler validates JWT tokens and extracts the user ID\n// Implements Encore's authentication handler interface\n//\n//encore:authhandler\nfunc AuthHandler(ctx context.Context, token string) (auth.UID, error) {\n\t// Fetch and parse the JWKS (JSON Web Key Set) from the identity provider\n\tjwks, err := keyfunc.NewDefaultCtx(ctx, []string{authConfig.JwksUri()})\n\tif err != nil {\n\t\treturn \"\", &errs.Error{\n\t\t\tCode:    errs.Internal,\n\t\t\tMessage: \"failed to fetch JWKS\",\n\t\t}\n\t}\n\n\t// Parse and validate the JWT token with required claims and validation options\n\tparsedToken, err := jwt.ParseWithClaims(\n\t\ttoken,\n\t\t&RequiredClaims{},\n\t\tjwks.Keyfunc,\n\t\t// Expect the token to be intended for this API resource\n\t\tjwt.WithAudience(authConfig.ApiResourceIndicator()),\n\t\t// Expect the token to be issued by this issuer\n\t\tjwt.WithIssuer(authConfig.Issuer()),\n\t\t// Allow some leeway for clock skew\n\t\tjwt.WithLeeway(time.Minute*10),\n\t)\n\n\t// Check if there were any errors during token parsing\n\tif err != nil {\n\t\treturn \"\", &errs.Error{\n\t\t\tCode:    errs.Unauthenticated,\n\t\t\tMessage: \"invalid token\",\n\t\t}\n\t}\n\n\t// Verify that the client ID in the token matches the expected client ID\n\tif parsedToken.Claims.(*RequiredClaims).ClientID != authConfig.ClientId() {\n\t\treturn \"\", &errs.Error{\n\t\t\tCode:    errs.Unauthenticated,\n\t\t\tMessage: \"invalid token\",\n\t\t}\n\t}\n\n\t// Extract the user ID (subject) from the token claims\n\tuserId, err := parsedToken.Claims.GetSubject()\n\tif err != nil {\n\t\treturn \"\", &errs.Error{\n\t\t\tCode:    errs.Unauthenticated,\n\t\t\tMessage: \"invalid token\",\n\t\t}\n\t}\n\n\t// Return the user ID as an Encore auth.UID\n\treturn auth.UID(userId), nil\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing SQLDatabase in Encore.ts\nDESCRIPTION: This snippet demonstrates how to initialize a named database using the SQLDatabase class in Encore. It shows setting up the database with a specified migration directory and retrieving the connection string for use with ORMs. Encore's SQLDatabase class serves as the interface for establishing database connections through the connection string, supporting ORMs like Sequelize. Ensure that your environment has `encore.dev` package installed.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/orms/overview.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SQLDatabase } from \"encore.dev/storage/sqldb\";\n\n// Initialize a named database with migration directory\nconst SiteDB = new SQLDatabase(\"siteDB\", {\n  migrations: \"./migrations\",\n});\n\n// Retrieve the connection string for ORM use\nconst connStr = SiteDB.connectionString;\n```\n\n----------------------------------------\n\nTITLE: Installing Connect Protocol Tools for Go\nDESCRIPTION: Commands to install necessary tools for working with Connect protocol and gRPC in Go.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/grpc-connect.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ go install github.com/bufbuild/buf/cmd/buf@latest\n$ go install github.com/fullstorydev/grpcurl/cmd/grpcurl@latest\n$ go install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n$ go install connectrpc.com/connect/cmd/protoc-gen-connect-go@latest\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Cron Job with Periodic Interval in Go\nDESCRIPTION: Example of creating a Cron Job that sends welcome emails every 2 hours using Encore's cron package. The job demonstrates basic setup with periodic interval scheduling.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/cron-jobs.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport \"encore.dev/cron\"\n\n// Send a welcome email to everyone who signed up in the last two hours.\nvar _ = cron.NewJob(\"welcome-email\", cron.JobConfig{\n\tTitle:    \"Send welcome emails\",\n\tEvery:    2 * cron.Hour,\n\tEndpoint: SendWelcomeEmail,\n})\n\n// SendWelcomeEmail emails everyone who signed up recently.\n// It's idempotent: it only sends a welcome email to each person once.\n//encore:api private\nfunc SendWelcomeEmail(ctx context.Context) error {\n\t// ...\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Encore Auth Handler for Clerk\nDESCRIPTION: Shows how to implement an authentication handler using the //encore:authhandler annotation. This function verifies tokens and extracts user data from Clerk for authentication.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_40\n\nLANGUAGE: go\nCODE:\n```\n//encore:authhandler\nfunc (s *Service) AuthHandler(ctx context.Context, token string) (auth.UID, *UserData, error) {\n    // Token verification and user data retrieval\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking Entire Services in Encore Tests\nDESCRIPTION: Shows how to mock a complete service for testing purposes. This approach uses et.MockService to provide a mock implementation of the entire service.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_35\n\nLANGUAGE: go\nCODE:\n```\nfunc Test_Something(t *testing.T) {\n    t.Parallel()\n    \n    et.MockService(\"products\", &products.Service{\n        SomeField: \"a testing value\",\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom S3 Provider in Encore\nDESCRIPTION: This snippet illustrates the configuration for a custom S3-compatible storage provider in an Encore application. It includes endpoint, access key, and secret access key configurations, useful for services like Cloudflare R2.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_19\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"object_storage\": [\n    {\n      \"type\": \"s3\",\n      \"region\": \"auto\",\n      \"endpoint\": \"https://...\",\n      \"access_key_id\": \"...\",\n      \"secret_access_key\": {\n          \"$env\": \"BUCKET_SECRET_ACCESS_KEY\"\n      },\n      \"buckets\": {\n        \"my-s3-bucket\": {\n          \"name\": \"my-s3-bucket\",\n          \"key_prefix\": \"my-optional-prefix/\",\n          \"public_base_url\": \"https://my-gcs-bucket-cdn.example.com/my-optional-prefix\"          \n        }\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PubSub Components in Encore (Go)\nDESCRIPTION: This snippet defines the basic components for a publish-subscribe system using Encore's pubsub package. It includes a message type, a topic, a subscription, and functions for publishing and subscribing.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_subscriber_in_same_service.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/pubsub\"\n)\n\ntype MessageType struct {\n    Name string\n}\n\nvar (\n    BasicTopic = pubsub.NewTopic[*MessageType](\"basic-topic\", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })\n    _ = pubsub.NewSubscription(BasicTopic, \"basic-subscription\", pubsub.SusbcriptionConfig { Handler: Subscriber })\n)\n\n// encore:api\nfunc DoStuff(ctx context.Context) error {\n    return BasicTopic.Publish(ctx, &MessageType{Name: \"foo\"})\n}\n\nfunc Subscriber(ctx context.Context, msg *MessageType) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Query Parameters in Encore (Go)\nDESCRIPTION: This snippet illustrates the use of struct tags to parse query parameters from the URL in Encore applications. For HTTP GET, HEAD, or DELETE methods, parameters default to query string parsing. The code also shows how to override parameter names using the query tag.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/defining-apis.md#2025-04-21_snippet_7\n\nLANGUAGE: Go\nCODE:\n```\ntype ListBlogPost struct {\n    PageLimit  int `query:\"limit\"` // always a query parameter\n    Author     string              // query if GET, HEAD or DELETE, otherwise body parameter\n}\n\n```\n\n----------------------------------------\n\nTITLE: Query Parameter Definition\nDESCRIPTION: Shows how to define and customize query parameters in API request structs.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/api-schemas.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\ntype ListBlogPost struct {\n    PageLimit  int `query:\"limit\"` // always a query parameter\n    Author     string              // query if GET, HEAD or DELETE, otherwise body parameter\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cron Job for Site Monitoring in Go\nDESCRIPTION: Sets up an hourly cron job to automatically check all tracked sites using the CheckAll endpoint.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/uptime.md#2025-04-21_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nimport \"encore.dev/cron\"\n\n// Check all tracked sites every 1 hour.\nvar _ = cron.NewJob(\"check-all\", cron.JobConfig{\n\tTitle:    \"Check all sites\",\n\tEndpoint: CheckAll,\n\tEvery:    1 * cron.Hour,\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle with Encore.ts\nDESCRIPTION: This code snippet demonstrates how to initialize Drizzle ORM with Encore.ts using the SQLDatabase instance. It creates a SQLDatabase instance with migrations configuration, initializes Drizzle ORM with the connection string, and queries all users from the 'users' table.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/orms/drizzle.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// database.ts\nimport { api } from \"encore.dev/api\";\nimport { SQLDatabase } from \"encore.dev/storage/sqldb\";\nimport { drizzle } from \"drizzle-orm/node-postgres\";\nimport { users } from \"./schema\";\n\n// Create SQLDatabase instance with migrations configuration\nconst db = new SQLDatabase(\"test\", {\n  migrations: {\n    path: \"migrations\",\n    source: \"drizzle\",\n  },\n});\n\n// Initialize Drizzle ORM with the connection string\nconst orm = drizzle(db.connectionString);\n\n// Query all users\nawait orm.select().from(users);\n```\n\n----------------------------------------\n\nTITLE: REST API endpoint for books (TS)\nDESCRIPTION: This TypeScript snippet defines a REST API endpoint using Encore.js. It imports the `api` function from `encore.dev/api` and the `Book` type from the generated resolvers types.  The `list` function is defined as an API endpoint that returns a list of books from an in-memory database.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/graphql.mdx#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n-- book.ts --\nimport { api } from \"encore.dev/api\";\n// Import Book type the generated schema types\nimport { Book } from \"../__generated__/resolvers-types\";\n\nconst db: Book[] = [\n  {\n    title: \"To Kill a Mockingbird\",\n    author: \"Harper Lee\",\n  },\n  // ...\n];\n\n// REST endpoint to get the list of books\nexport const list = api(\n  { expose: true, method: \"GET\", path: \"/books\" },\n  async (): Promise<{ books: Book[] }> => {\n    return { books: db };\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Advanced Cron Scheduling with Cron Expressions\nDESCRIPTION: Configuring a cron job with a specific schedule using standard cron expression syntax\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nvar _ = cron.NewJob(\"accounting-sync\", cron.JobConfig{\n    Title:    \"Cron Job Example\",\n    Schedule: \"0 4 15 * *\", // 4am UTC on 15th of each month\n    Endpoint: AccountingSync,\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing PubSub Subscription with Named Handler\nDESCRIPTION: Creates a subscription to the basic topic with a named handler function Subscriber1.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_duplicate_subscription_names.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"encore.dev/pubsub\"\n    \"test/shared\"\n)\n\nvar (\n    _ = pubsub.NewSubscription(shared.BasicTopic, \"same-name\", pubsub.SusbcriptionConfig { Handler: Subscriber1 })\n)\n\n// encore:api\nfunc Subscriber1(ctx context.Context, msg *shared.MessageType) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Encore Internal Pub/Sub Handlers\nDESCRIPTION: These functions serve as internal handlers for pub/sub events within the Encore framework.  They retrieve the service instance using `__service.Get[*Service](\"svc\")` and then call either the `PointerMethod` or `NonPointerMethod` on the service instance with the context and event. These handlers are generated by Encore to facilitate routing of pub/sub events to the correct service methods.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/pubsubgen/testdata/method_handler.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\t__service \"encore.dev/appruntime/apisdk/service\"\n)\n\nfunc EncoreInternal_pubsub_handler_pointer(ctx context.Context, msg *Event) error {\n\tsvc, err := __service.Get[*Service](\"svc\")\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn svc.PointerMethod(ctx, msg)\n}\n\nfunc EncoreInternal_pubsub_handler_non_pointer(ctx context.Context, msg *Event) error {\n\tsvc, err := __service.Get[*Service](\"svc\")\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn svc.NonPointerMethod(ctx, msg)\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking an API Endpoint in a Go Test\nDESCRIPTION: This snippet demonstrates how to mock an API endpoint using Encore's et.MockEndpoint function within a Go test. It creates a mock implementation of the GetPrice API that returns a fixed price.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/mocking.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage shoppingcart\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\n\t\"encore.dev/et\" // Encore's test support package\n\t\n\t\"your_app/products\"\n)\n\n\nfunc Test_Something(t *testing.T) {\n\tt.Parallel() // Run this test in parallel with other tests without the mock implementation interfering\n\t\n\t// Create a mock implementation of pricing API which will only impact this test and any sub-tests\n\tet.MockEndpoint(products.GetPrice, func(ctx context.Context, p *products.PriceParams) (*products.PriceResponse, error) {\n\t\treturn &products.PriceResponse{Price: 100}, nil\n\t})\n\t\n\t// ... the rest of your test code here ...\n}\n```\n\n----------------------------------------\n\nTITLE: Monitor Service Check Endpoint\nDESCRIPTION: Go implementation of Check endpoint to verify site availability and record results in database\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/uptime.md#2025-04-21_snippet_10\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public method=POST path=/check/:siteID\nfunc Check(ctx context.Context, siteID int) error {\n\tsite, err := site.Get(ctx, siteID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tresult, err := Ping(ctx, site.URL)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = db.Exec(ctx, `\n\t\tINSERT INTO checks (site_id, up, checked_at)\n\t\tVALUES ($1, $2, NOW())\n\t`, site.ID, result.Up)\n\treturn err\n}\n\nvar db = sqldb.NewDatabase(\"monitor\", sqldb.DatabaseConfig{\n\tMigrations: \"./migrations\",\n})\n```\n\n----------------------------------------\n\nTITLE: Union Fields in Request Schema\nDESCRIPTION: This snippet defines a request schema that accepts a union of multiple types using Encore.ts.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Request {\n  value: string | number | boolean;\n}\n\nexport const myEndpoint = api(\n  { expose: true, method: \"POST\", path: \"/body\" },\n  async (req: Request) => {\n    // req.value is a string, number, or boolean\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Defining SQL Queries for Booking - SQL\nDESCRIPTION: These SQL queries define the operations for inserting a booking, listing bookings, and deleting a booking from the database. They are annotated with names for use in type-safe query generation.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\n-- name: InsertBooking :one\nINSERT INTO booking (start_time, end_time, email)\nVALUES ($1, $2, $3)\nRETURNING *;\n\n-- name: ListBookingsBetween :many\nSELECT * FROM booking\nWHERE start_time >= $1 AND end_time <= $2;\n\n-- name: ListBookings :many\nSELECT * FROM booking;\n\n-- name: DeleteBooking :exec\nDELETE FROM booking WHERE id = $1;\n\n```\n\n----------------------------------------\n\nTITLE: Defining an Encore Service with TypeScript\nDESCRIPTION: This code snippet defines a new Encore service in TypeScript, by creating a default export for a new `Service` instance. The `Service` name is specified as `url`, and this setup allows Encore to recognize it as part of the application services.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/rest-api.mdx#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n-- url/encore.service.ts --\nimport { Service } from \"encore.dev/service\";\n\nexport default new Service(\"url\");\n```\n\n----------------------------------------\n\nTITLE: Managing Bookings Endpoints in Go\nDESCRIPTION: This Go code defines endpoints to list and delete bookings using the Encore framework. It fetches bookings from a database and supports deletion by booking ID. Dependencies include context.Context for handling requests.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_20\n\nLANGUAGE: go\nCODE:\n```\ntype ListBookingsResponse struct {\n\tBooking []*Booking `json:\"bookings\"`\n}\n\n//encore:api auth method=GET path=/booking\nfunc ListBookings(ctx context.Context) (*ListBookingsResponse, error) {\n\trows, err := query.ListBookings(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar bookings []*Booking\n\tfor _, row := range rows {\n\t\tbookings = append(bookings, &Booking{\n\t\t\tID:    row.ID,\n\t\t\tStart: row.StartTime.Time,\n\t\t\tEnd:   row.EndTime.Time,\n\t\t\tEmail: row.Email,\n\t\t})\n\t}\n\treturn &ListBookingsResponse{Booking: bookings}, nil\n}\n\n//encore:api auth method=DELETE path=/booking/:id\nfunc DeleteBooking(ctx context.Context, id int64) error {\n\treturn query.DeleteBooking(ctx, id)\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking an Entire Service in a Go Test\nDESCRIPTION: This snippet demonstrates how to mock an entire service using Encore's et.MockService function within a Go test. It creates a mock instance of the products service with custom field values.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/mocking.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage shoppingcart\n\nimport (\n    \"context\"\n    \"testing\"\n    \n    \"encore.dev/et\" // Encore's test support package\n    \n    \"your_app/products\"\n)\n\nfunc Test_Something(t *testing.T) {\n    t.Parallel() // Run this test in parallel with other tests without the mock implementation interfering\n    \n    // Create a instance of the products service which will only impact this test and any sub-tests\n    et.MockService(\"products\", &products.Service{\n\t\tSomeField: \"a testing value\",\n\t})\n    \n    // ... the rest of your test code here ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Request/Response Structs with Encore Tags\nDESCRIPTION: This snippet demonstrates how to define a nested struct for request/response in Encore, including various field tags for header, query, and JSON body parameters.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/defining-apis.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype NestedRequestResponse struct {\n\tHeader string `header:\"X-Header\"`// this field will be read from the http header\n\tQuery  string `query:\"query\"`// this field will be read from the query string\n\tBody1  string `json:\"body1\"`\n\tNested struct {\n\t    Header2 string `header:\"X-Header2\"`// this field will be read from the body\n\t\tQuery2  string `query:\"query2\"`// this field will be read from the body\n\t\tBody2   string `json:\"body2\"`\n    } `json:\"nested\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Downloading Files from Encore Bucket\nDESCRIPTION: This code shows how to download a file from an Encore storage bucket using the `download` method. It retrieves the data associated with the specified file name. The downloaded data can then be processed as needed.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst data = await profilePictures.download(\"my-image.jpeg\");\n```\n\n----------------------------------------\n\nTITLE: Service-Level Middleware Implementation in Go\nDESCRIPTION: Implementation of service-level middleware functions with tag-specific and global targeting.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/middleware_err_no_matches.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:middleware target=tag:foo\nfunc TaggedInSvc(req middleware.Request, next middleware.Next) middleware.Response {\n    return next(req)\n}\n\n//encore:middleware target=all\nfunc AllInSvc(req middleware.Request, next middleware.Next) middleware.Response {\n    return next(req)\n}\n```\n\n----------------------------------------\n\nTITLE: CUE Configuration File Examples\nDESCRIPTION: Shows examples of CUE configuration files, including the generated encore.gen.cue file and a custom myconfig.cue file. Demonstrates how to set default values and override them based on environment conditions.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/config.md#2025-04-21_snippet_1\n\nLANGUAGE: cue\nCODE:\n```\n-- mysvc/encore.gen.cue --\n// Code generated by encore. DO NOT EDIT.\npackage mysvc\n\n#Meta: {\n\tAPIBaseURL: string\n\tEnvironment: {\n\t\tName:  string\n\t\tType:  \"production\" | \"development\" | \"ephemeral\" | \"test\"\n\t\tCloud: \"aws\" | \"gcp\" | \"encore\" | \"local\"\n\t}\n}\n\n#Config: {\n\tReadOnly: bool   // Put the system into read-only mode\n    Example:  string\n}\n#Config\n-- mysvc/myconfig.cue --\n// Set example to \"hello world\"\nExample: \"hello world\"\n\n// By default we're not in read only mode\nReadOnly: bool | *false\n\n// But on the old production environment, we're in read only mode\nif #Meta.Environment.Name == \"old-prod\" {\n    ReadOnly: true\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a CheckAll API Endpoint (TypeScript)\nDESCRIPTION: This code defines a new API endpoint `checkAll` that iterates through all tracked sites and checks their status using the `doCheck` function. It retrieves the list of sites using `site.list()` and then uses `Promise.all` to execute `doCheck` concurrently for each site, improving performance.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// CheckAll checks all sites.\nexport const checkAll = api(\n  { expose: true, method: \"POST\", path: \"/check-all\" },\n  async (): Promise<void> => {\n    const sites = await site.list();\n    await Promise.all(sites.sites.map(doCheck));\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Encore Service with RPC Method\nDESCRIPTION: This code defines an Encore service with an RPC method using the Encore framework in Go. It includes a Service struct and a method Str that is exposed as a public API. The Str method takes a context and Params type as inputs and returns an error. Encore annotations are used to simplify service and API declarations, and there are no external dependencies apart from the Encore framework.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_method.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\t\"encore.dev/types/uuid\"\n)\n\n//encore:service\ntype Service struct {}\n\ntype Params struct{}\n\n//encore:api public\nfunc (s *Service) Str(ctx context.Context, p *Params) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Defining API Path Parameters in Go\nDESCRIPTION: Example of defining API endpoint with path parameters and wildcards using Encore.go annotations\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public method=GET path=/blog/:id/*path\nfunc GetBlogPost(ctx context.Context, id int, path string)\n```\n\n----------------------------------------\n\nTITLE: Defining Query Parameters in Go\nDESCRIPTION: Example of defining query parameters using struct tags in Encore.go\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nstruct {\n    PageLimit int `query:\"limit\"`\n    Author string // query for GET/HEAD/DELETE, body otherwise\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Shopping Cart Service in Go with Encore\nDESCRIPTION: Defines a shopping cart service with Encore framework annotations that maintains a list of cart items and provides APIs for calculating the total price and emptying the cart. It depends on the products service for price calculations.\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/et_mocking.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage shoppingcart\n\nimport (\n    \"context\"\n\n    \"test/products\"\n)\n\ntype CartItem struct {\n    ProductID int\n    Quantity int\n}\n\n//encore:service\ntype Service struct {\n    Items []CartItem\n}\n\nfunc initService() (*Service, error) {\n    return &Service{\n        Items: []CartItem{\n            { ProductID: 1, Quantity: 2 },\n            { ProductID: 2, Quantity: 1 },\n        },\n    }, nil\n}\n\ntype TotalResult struct {\n    Total float64\n}\n\n//encore:api public method=GET path=/cart/total\nfunc (s *Service) Total(ctx context.Context) (*TotalResult, error) {\n    var total float64\n\n    for _, item := range s.Items {\n        price, err := products.GetPrice(ctx, item.ProductID, &products.PriceParams{ Quantity: item.Quantity })\n        if err != nil {\n            return nil, err\n        }\n\n        total += price.Total\n    }\n\n    return &TotalResult{ Total: total }, nil\n}\n\n//encore:api private\nfunc (s *Service) Empty(ctx context.Context) error {\n    s.Items = []CartItem{}\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Objects in a Bucket with TypeScript\nDESCRIPTION: This code snippet uses Encore's `list` method to enumerate objects in a storage bucket. It employs an async iterator of `ListEntry` objects, facilitating iterations with a `for await` loop to handle each entry. The method also supports filtering options to refine object retrieval based on key prefixes, optimizing the management of stored data.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/object-storage.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfor await (const entry of profilePictures.list({})) {\n  // Do something with entry\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Database Schema with Drizzle\nDESCRIPTION: This code snippet defines a database schema using Drizzle's `pg-core` module. It creates a 'users' table with columns for 'id' (primary key), 'name', and 'email' (unique).\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/orms/drizzle.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// schema.ts\nimport * as p from \"drizzle-orm/pg-core\";\n\nexport const users = p.pgTable(\"users\", {\n  id: p.serial().primaryKey(),\n  name: p.text(),\n  email: p.text().unique(),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Cron Job in Encore\nDESCRIPTION: Shows how to create a scheduled cron job in Encore. The cron job is defined with a unique ID, title, schedule frequency, and the API endpoint function to call when triggered.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/code-snippets.md#2025-04-21_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nimport \"encore.dev/cron\"\n\nvar _ = cron.NewJob(\"welcome-email\", cron.JobConfig{\n\tTitle:    \"Send welcome emails\",\n\tEvery:    2 * cron.Hour,\n\tEndpoint: SendWelcomeEmail,\n})\n\n//encore:api private\nfunc SendWelcomeEmail(ctx context.Context) error {\n\t// ...\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Encore Request Client (TypeScript)\nDESCRIPTION: This TypeScript code demonstrates how to use the generated Encore request client in your frontend.  It imports the client and related types, instantiates the client with either a local or deployed environment configuration, and then calls the `GetNote` endpoint on the `note` service to retrieve a note by its ID. The retrieved note's properties are then logged to the console.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/frontend/request-client.mdx#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n\"import Client, { Environment, Local } from \\\"src/client.ts\\\";\n\n// Making request to locally running backend...\nconst client = new Client(Local);\n// or to a specific deployed environment\n// const client = new Client(Environment(\\\"staging\\\"));\n\n// Calling APIs as typesafe functions \nconst response = await client.note.GetNote(\\\"note-uuid\\\");\nconsole.log(response.id);\nconsole.log(response.cover_url);\nconsole.log(response.text);\"\n```\n\n----------------------------------------\n\nTITLE: Service-to-Service Streaming with Encore\nDESCRIPTION: This code illustrates how Encore services can stream data between each other using the `~encore/clients` import. It obtains a stream from another service and establishes a connection.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nimport { service } from \"~encore/clients\";\nconst stream = await service.streamEndpoint();\n```\n\n----------------------------------------\n\nTITLE: Initializing PubSub Topic and Subscription - Go\nDESCRIPTION: This snippet creates a new PubSub topic and its corresponding subscription within the Encore framework. The topic is configured with a delivery guarantee of 'AtLeastOnce', and the subscription defines a handler that processes incoming events of type 'Event'. The necessary imports are context and the Encore pubsub package.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/subscription.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage code\n\nimport \"context\"\nimport \"encore.dev/pubsub\"\n\ntype Event struct {}\n\nvar Topic = pubsub.NewTopic[*Event](\"topic\", pubsub.TopicConfig{\n    DeliveryGuarantee: pubsub.AtLeastOnce,\n})\n\nvar _ = pubsub.NewSubscription(Topic, \"subscription\",\n    pubsub.SubscriptionConfig[*Event]{\n        Handler: func(ctx context.Context, event *Event) error {\n            return nil\n        },\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Logging in Encore.ts Applications\nDESCRIPTION: Demonstrates basic and context-based logging in Encore.ts. Shows how to log messages with different severity levels and include structured data in log entries.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nlog.info(\"log message\", {is_subscriber: true})\nlog.error(err, \"something went terribly wrong!\")\n\nconst logger = log.with({is_subscriber: true})\nlogger.info(\"user logged in\", {login_method: \"oauth\"}) // includes is_subscriber=true\n```\n\n----------------------------------------\n\nTITLE: Defining Database Resource with Encore\nDESCRIPTION: This snippet sets up a database resource named 'Moo' using the Encore SQLDB library, allowing access to the 'myservice' database contextually. It requires the Encore storage package and provides a reference for database operations in the service.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_success.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nvar Moo = sqldb.Named(\"myservice\")\n```\n\n----------------------------------------\n\nTITLE: Service API Call Wrapper in Go\nDESCRIPTION: This function implements an internal call to the `Foo` API endpoint using Encore's service-to-service communication. It utilizes Encore's API description to perform the call, handling potential errors appropriately.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/api_call_servicestruct.txt#2025-04-21_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\npackage svca\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n)\n\nfunc EncoreInternal_apicalls_Foo(ctx context.Context) error {\n\t_, err := EncoreInternal_api_APIDesc_Foo.Call(__api.NewCallContext(ctx), &EncoreInternal_FooReq{})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Authenticator for Auth0 in Go\nDESCRIPTION: This Go snippet implements an Authenticator struct for managing OAuth2 operations and verifying ID tokens using the OpenID Connect protocol. It sets up the OpenID provider, uses oauth2.Config for configuration, and provides methods for token verification and generating random state for OAuth flows.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/auth0-auth.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage auth\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"encore.dev/config\"\n\t\"errors\"\n\t\"github.com/coreos/go-oidc/v3/oidc\"\n\t\"golang.org/x/oauth2\"\n)\n\ntype Auth0Config struct {\n\tClientID    config.String\n\tDomain      config.String\n\tCallbackURL config.String\n\tLogoutURL   config.String\n}\n\nvar cfg = config.Load[*Auth0Config]()\n\nvar secrets struct {\n\tAuth0ClientSecret string\n}\n\n// Authenticator is used to authenticate our users.\ntype Authenticator struct {\n\t*oidc.Provider\n\toauth2.Config\n}\n\n// New instantiates the *Authenticator.\nfunc New() (*Authenticator, error) {\n\tprovider, err := oidc.NewProvider(\n\t\tcontext.Background(),\n\t\t\"https://\"+cfg.Domain()+\"/\",\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tconf := oauth2.Config{\n\t\tClientID:     cfg.ClientID(),\n\t\tClientSecret: secrets.Auth0ClientSecret,\n\t\tRedirectURL:  cfg.CallbackURL(),\n\t\tEndpoint:     provider.Endpoint(),\n\t\tScopes:       []string{oidc.ScopeOpenID, \"profile\", \"email\"},\n\t}\n\n\treturn &Authenticator{\n\t\tProvider: provider,\n\t\tConfig:   conf,\n\t}, nil\n}\n\n// VerifyIDToken verifies that an *oauth2.Token is a valid *oidc.IDToken.\nfunc (a *Authenticator) VerifyIDToken(ctx context.Context, token *oauth2.Token) (*oidc.IDToken, error) {\n\trawIDToken, ok := token.Extra(\"id_token\").(string)\n\tif !ok {\n\t\treturn nil, errors.New(\"no id_token field in oauth2 token\")\n\t}\n\n\toidcConfig := &oidc.Config{\n\t\tClientID: a.ClientID,\n\t}\n\n\treturn a.Verifier(oidcConfig).Verify(ctx, rawIDToken)\n}\n\nfunc generateRandomState() (string, error) {\n\tb := make([]byte, 32)\n\t_, err := rand.Read(b)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tstate := base64.StdEncoding.EncodeToString(b)\n\n\treturn state, nil\n}\n\n```\n\n----------------------------------------\n\nTITLE: Parsing Request Body as JSON\nDESCRIPTION: This snippet demonstrates the default behavior of Encore.ts where the request body is expected to be parsed as JSON.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Request {\n  name: string; // Parsed from the JSON body\n}\n\nexport const myEndpoint = api<Request, Response>(\n  { expose: true, method: \"POST\", path: \"/body\" },\n  async (req) => {\n    // req.name is a string\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Using Cloud Specific Services in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to use the `appMeta()` function from the `encore.dev` package to determine the cloud environment and execute different functions based on the cloud provider (AWS, GCP, or local). It allows for using cloud-specific services within an Encore application, such as writing audit logs to Redshift on AWS, BigQuery on GCP, or a local file.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/metadata.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { appMeta } from \"encore.dev\";\n\n// Emit an audit event.\nasync function audit(userID: string, event: Record<string, any>) {\n  const cloud = appMeta().environment.cloud;\n  switch (cloud) {\n    case \"aws\":\n      return writeIntoRedshift(userID, event);\n    case \"gcp\":\n      return writeIntoBigQuery(userID, event);\n    case \"local\":\n      return writeIntoFile(userID, event);\n    default:\n      throw new Error(`unknown cloud: ${cloud}`);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Error Handling Example\nDESCRIPTION: Demonstrates error building pattern using errs.Builder for complex business logic with metadata and error codes.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/api-errors.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc getBoard(ctx context.Context, boardID int64) (*Board, error) {\n    // Construct a new error builder with errs.B()\n\teb := errs.B().Meta(\"board_id\", params.ID)\n\n\tb := &Board{ID: params.ID}\n\terr := sqldb.QueryRow(ctx, `\n\t\tSELECT name, created\n\t\tFROM board\n\t\tWHERE id = $1\n\t`, params.ID).Scan(&b.Name, &b.Created)\n\tif errors.Is(err, sqldb.ErrNoRows) {\n        // Return a \"board not found\" error with code == NotFound\n\t\treturn nil, eb.Code(errs.NotFound).Msg(\"board not found\").Err()\n\t} else if err != nil {\n        // Return a general error\n\t\treturn nil, eb.Cause(err).Msg(\"could not get board\").Err()\n\t}\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Schema for Array Fields\nDESCRIPTION: This snippet shows how to define fields with array values of various types in the request schema using Encore.ts.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Schema {\n  strings:  string[];\n  numbers:  number[];\n  booleans:  boolean[];\n  nulls: null[];\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Cache Cluster in Encore\nDESCRIPTION: Initializing a Redis-based cache cluster with a least recently used (LRU) eviction policy\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nimport \"encore.dev/storage/cache\"\n\nvar MyCacheCluster = cache.NewCluster(\"my-cache-cluster\", cache.ClusterConfig{\n    EvictionPolicy: cache.AllKeysLRU,\n})\n```\n\n----------------------------------------\n\nTITLE: Cache Keyspace Configuration for Rate Limiting\nDESCRIPTION: Creating a type-safe cache keyspace for tracking requests per user with an expiration policy\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nvar RequestsPerUser = cache.NewIntKeyspace[auth.UID](cluster, cache.KeyspaceConfig{\n    KeyPattern:    \"requests/:key\",\n    DefaultExpiry: cache.ExpireIn(10 * time.Second),\n})\n```\n\n----------------------------------------\n\nTITLE: Testing with Configuration in Go\nDESCRIPTION: Shows how to use configuration in tests, including setting config values for specific tests using et.SetCfg. The example demonstrates testing a signup function with different email sending configurations.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/config.md#2025-04-21_snippet_4\n\nLANGUAGE: cue\nCODE:\n```\n-- config.cue --\n// By default we want to send emails\nSendEmails: bool | *true\n\n// But in all tests we want to disable emails\nif #Meta.Environment.Type == \"test\" {\n    SendEmails: false\n}\n```\n\nLANGUAGE: go\nCODE:\n```\n-- signup.go --\nimport (\n    \"context\"\n\n    \"encore.dev/config\"\n)\n\ntype Config struct {\n    SendEmails config.Bool\n}\n\nvar cfg = config.Load[Config]()\n\n//encore:api public\nfunc Signup(ctx context.Context, p *SignupParams) error {\n    user := createUser(p)\n\n    if cfg.SendEmails() {\n        SendWelcomeEmail(user)\n    }\n\n    return nil\n}\n```\n\nLANGUAGE: go\nCODE:\n```\n-- signup_test.go --\nimport (\n    \"errors\"\n    \"testing\"\n\n    \"encore.dev/et\"\n)\n\nfunc TestSignup(t *testing.T) {\n    err := Signup(context.Background(), &SignupParams { ... })\n    if err != nil {\n        // We don't expect an error here\n        t.Fatal(err)\n    }\n\n    if emailWasSent() {\n        // We don't expect an email to be sent\n        // as it's disabled for all tests\n        t.Fatal(\"email was sent\")\n    }\n}\n\nfunc TestSignup_TestEmails(t *testing.T) {\n    // For this test, we want to enable the welcome\n    // emails so we can test that they are sent\n    et.SetCfg(cfg.SendEmails, true)\n\n    err := Signup(context.Background(), &SignupParams { ... })\n    if err != nil {\n        // We don't expect an error here\n        t.Fatal(err)\n    }\n\n    // Check the email was sent\n    if !emailWasSent() {\n        t.Fatal(\"email was not sent\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Encore GraphQL Service in Go\nDESCRIPTION: This Go code defines an Encore service that exposes GraphQL endpoints. It initializes the GraphQL server and playground, and provides handlers for GraphQL queries and the playground interface.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/graphql.mdx#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// Service graphql exposes a GraphQL API.\npackage graphql\n\nimport (\n    \"net/http\"\n\n    \"encore.app/graphql/generated\"\n    \"encore.dev\"\n    \"github.com/99designs/gqlgen/graphql/handler\"\n    \"github.com/99designs/gqlgen/graphql/playground\"\n)\n\n//go:generate go run github.com/99designs/gqlgen generate\n\n//encore:service\ntype Service struct {\n    srv        *handler.Server\n    playground http.Handler\n}\n\nfunc initService() (*Service, error) {\n    srv := handler.NewDefaultServer(generated.NewExecutableSchema(generated.Config{Resolvers: &Resolver{}}))\n    pg := playground.Handler(\"GraphQL Playground\", \"/graphql\")\n    return &Service{srv: srv, playground: pg}, nil\n}\n\n//encore:api public raw path=/graphql\nfunc (s *Service) Query(w http.ResponseWriter, req *http.Request) {\n    s.srv.ServeHTTP(w, req)\n}\n\n//encore:api public raw path=/graphql/playground\nfunc (s *Service) Playground(w http.ResponseWriter, req *http.Request) {\n\t// Disable playground in production\n\tif encore.Meta().Environment.Type == encore.EnvProduction {\n        http.Error(w, \"Playground disabled\", http.StatusNotFound)\n\t\treturn\n    }\n\n    s.playground.ServeHTTP(w, req)\n}\n```\n\n----------------------------------------\n\nTITLE: Prometheus Metrics Configuration in JSON\nDESCRIPTION: Configuration for Prometheus metrics, specifying collection interval and remote write URL.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"metrics\": {\n    \"type\": \"prometheus\",\n    \"collection_interval\": 15,\n    \"remote_write_url\": {\n      \"$env\": \"PROMETHEUS_REMOTE_WRITE_URL\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Topic in TypeScript using Pub/Sub\nDESCRIPTION: This snippet demonstrates how to create a Pub/Sub topic to handle user signup events. The topic is defined with a delivery guarantee.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/pubsub.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Topic } from \"encore.dev/pubsub\"\n\nexport interface SignupEvent {\n    userID: string;\n}\n\nexport const signups = new Topic<SignupEvent>(\"signups\", {\n    deliveryGuarantee: \"at-least-once\",\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating Clerk with React Frontend for Encore Applications\nDESCRIPTION: Shows how to use the Clerk React SDK to manage authentication in a frontend application that communicates with an Encore backend. Demonstrates token retrieval for API calls.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_41\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAuth } from '@clerk/clerk-react';\n\nexport default function ExternalDataPage() {\n    const { getToken, isLoaded, isSignedIn } = useAuth();\n    \n    // Implementation using token for backend communication\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Service Instance Isolation in Go Tests\nDESCRIPTION: Method to create an isolated instance of a service struct for a specific test to prevent state interference\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/testing.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\net.EnableServiceInstanceIsolation()\n```\n\n----------------------------------------\n\nTITLE: External Endpoint Cron Job\nDESCRIPTION: Defines a cron job that calls an external endpoint every minute, demonstrating integration with external services.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cron_job_definition.txt#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nvar _ = cron.NewJob(\"cron-external\", cron.JobConfig{\n\tEvery:    cron.Minute,\n\tEndpoint: external.Endpoint,\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing Cache Cluster with Valid Configuration\nDESCRIPTION: Creates a cache cluster named 'foo' with an All Keys Least Recently Used (LRU) eviction policy using Encore's cache package\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/parser/infra/caches/testdata/cluster.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nvar a = cache.NewCluster(\n    \"foo\", cache.ClusterConfig{\n        EvictionPolicy: cache.AllKeysLRU,\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Defining PubSub Topics in Go with Encore.dev\nDESCRIPTION: Defines two PubSub topics with different delivery guarantees using Encore.dev's pubsub package. Sets up topics for message type MessageType with AtLeastOnce and ExactlyOnce delivery guarantees.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage shared\n\nimport (\n    \"encore.dev/pubsub\"\n)\n\ntype MessageType struct {\n    Name string\n}\n\nvar (\n    BasicTopic = pubsub.NewTopic[*MessageType](\"basic-topic\", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })\n    AnotherTopic = pubsub.NewTopic[*MessageType](\"another-topic\", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.ExactlyOnce })\n)\n```\n\n----------------------------------------\n\nTITLE: Registering API Endpoint and Handling Requests in Go\nDESCRIPTION: This snippet registers the 'Foo' API endpoint, along with handling methods for validation and response management. It uses JSON serialization for request and response cloning and defines how to decode and encode HTTP requests and responses.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/service_struct.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n-- want:encore_internal__api.go --\npackage basic\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n}\n\ntype EncoreInternal_FooReq struct{}\n\ntype EncoreInternal_FooResp = __api.Void\n\nvar EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{\n\tAccess: __api.Public,\n\tAppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {\n\t\tsvc, initErr := EncoreInternal_svcstruct_Service.Get()\n\t\tif initErr != nil {\n\t\t\treturn __api.Void{}, initErr\n\t\t}\n\t\terr := svc.Foo(ctx)\n\t\tif err != nil {\n\t\t\treturn __api.Void{}, err\n\t\t}\n\t\treturn __api.Void{}, nil\n\t},\n\tCloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {\n\t\tvar clone *EncoreInternal_FooReq\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tCloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {\n\t\tvar clone EncoreInternal_FooResp\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tDecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {\n\t\treturn __api.Void{}, nil\n\t},\n\tDecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {\n\t\treqData = new(EncoreInternal_FooReq)\n\t\treturn reqData, nil, nil\n\t},\n\tDefLoc: uint32(0x0),\n\tEncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {\n\t\treturn nil, nil, nil\n\t},\n\tEncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {\n\t\treturn nil\n\t},\n\tEndpoint:            \"Foo\",\n\tFallback:            false,\n\tGlobalMiddlewareIDs: []string{},\n\tMethods:             []string{\"GET\", \"POST\"},\n\tPath:                \"/basic.Foo\",\n\tPathParamNames:      nil,\n\tRaw:                 false,\n\tRawHandler:          nil,\n\tRawPath:             \"/basic.Foo\",\n\tReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {\n\t\treturn \"/basic.Foo\", nil, nil\n\t},\n\tReqUserPayload: func(reqData *EncoreInternal_FooReq) any {\n\t\treturn nil\n\t},\n\tService:           \"basic\",\n\tServiceMiddleware: []*__api.Middleware{},\n\tSvcNum:            1,\n\tTags:              nil,\n}\n```\n\n----------------------------------------\n\nTITLE: Streaming Application Logs\nDESCRIPTION: The `encore logs` command streams logs from your Encore application. It allows specifying the environment and outputting logs in JSON format.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\n$ encore logs [--env=prod] [--json]\n```\n\n----------------------------------------\n\nTITLE: Structured Auth Parameters Handler in Go\nDESCRIPTION: Advanced authentication handler that accepts structured authentication parameters from various sources including cookies, query parameters, and headers.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/auth.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype MyAuthParams struct {\n\t// SessionCookie is set to the value of the \"session\" cookie.\n\t// If the cookie is not set it's nil.\n\tSessionCookie *http.Cookie `cookie:\"session\"`\n\t\n\t// ClientID is the unique id of the client, sourced from the URL query string.\n\tClientID string `query:\"client_id\"`\n\t\n\t// Authorization is the raw value of the \"Authorization\" header\n\t// without any parsing.\n\tAuthorization string `header:\"Authorization\"`\n}\n\n//encore:authhandler\nfunc AuthHandler(ctx context.Context, p *MyAuthParams) (auth.UID, error) {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to Streaming APIs with the Encore Client\nDESCRIPTION: These code snippets demonstrate how to connect to a streaming API endpoint using the generated Encore client. It shows how to iterate over the stream to receive messages and how to send messages to the service using the `send` method.  Event listeners can be attached to the underlying socket to handle network errors or cleanup after the connection is closed.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/streaming-apis.mdx#2025-04-21_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst stream = client.serviceName.endpointName();\nfor await (const msg of stream) {\n  // Do something with each message\n}\n\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst stream = client.serviceName.endpointName();\nawait stream.send({ ... });\n\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst stream = client.serviceName.endpointName();\n\nstream.socket.on(\"error\", (event) => {\n  // An error occurred\n});\n\nstream.socket.on(\"close\", (event) => {\n  // Connection was closed\n});\n\n```\n\n----------------------------------------\n\nTITLE: Setting Firebase Secret for Development Environments\nDESCRIPTION: Command to set the Firebase private key as a secret for development, local, and PR environments using Encore CLI.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/firebase-auth.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ encore secret set --type dev,local,pr FirebasePrivateKey < /path/to/firebase-private-key.json\nSuccessfully updated development secret FirebasePrivateKey\n```\n\n----------------------------------------\n\nTITLE: Declaring a Database in Encore App - TypeScript\nDESCRIPTION: This snippet details how to declare the PostgreSQL database within the Encore application, allowing interaction with the 'users' table and exposing an API endpoint.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/deploy-to-digital-ocean-wip.md#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst mydb = new SQLDatabase(\"mydb\", {\n   migrations: \"./migrations\",\n});\n\nexport const getUser = api(\n  { expose: true, method: \"GET\", path: \"/names/:id\" },\n  async ({id}: {id:number}): Promise<{ id: number; name: string }> => {\n    return await mydb.queryRow`SELECT * FROM users WHERE id = ${id}` as { id: number; name: string };\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing Cache Cluster and Keyspace in Go with Encore\nDESCRIPTION: Sets up a cache cluster and configures a string keyspace with a specific key pattern and expiration time. The keyspace is configured to handle string values with a 'foo/:key' pattern and 10-second expiry.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cache_definition.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/storage/cache\"\n)\n\nvar cluster = cache.NewCluster(\"cluster\", cache.ClusterConfig{})\n\nvar keyspace = cache.NewStringKeyspace[string](cluster, cache.KeyspaceConfig{\n    KeyPattern: \"foo/:key\",\n    DefaultExpiry: cache.ExpireIn(10 * time.Second),\n})\n\n//encore:api public\nfunc Foo(context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Raw HTTP Endpoint for Webhooks in Encore\nDESCRIPTION: Demonstrates how to create a raw HTTP endpoint in Encore to handle incoming webhooks. Raw endpoints give you direct access to the underlying HTTP request and response objects, allowing for full control over the HTTP layer.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/http-requests.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage service\n\nimport \"net/http\"\n\n// Webhook receives incoming webhooks from Some Service That Sends Webhooks.\n//encore:api public raw method=POST path=/webhook\nfunc Webhook(w http.ResponseWriter, req *http.Request) {\n    // ... operate on the raw HTTP request ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Encore Auth Handler with Clerk\nDESCRIPTION: Complete implementation of the auth handler service that integrates with Clerk, including user verification and data retrieval\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/clerk-auth.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage auth\n\nimport (\n\t\"context\"\n\t\"encore.dev/beta/auth\"\n\t\"encore.dev/beta/errs\"\n\t\"github.com/clerkinc/clerk-sdk-go/clerk\"\n)\n\nvar secrets struct {\n\tClientSecretKey string\n}\n\n//encore:service\ntype Service struct {\n\tclient clerk.Client\n}\n\nfunc initService() (*Service, error) {\n\tclient, err := clerk.NewClient(secrets.ClientSecretKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Service{client: client}, nil\n}\n\ntype UserData struct {\n\tID                    string               `json:\"id\"`\n\tUsername              *string              `json:\"username\"`\n\tFirstName             *string              `json:\"first_name\"`\n\tLastName              *string              `json:\"last_name\"`\n\tProfileImageURL       string               `json:\"profile_image_url\"`\n\tPrimaryEmailAddressID *string              `json:\"primary_email_address_id\"`\n\tEmailAddresses        []clerk.EmailAddress `json:\"email_addresses\"`\n}\n\n//encore:authhandler\nfunc (s *Service) AuthHandler(ctx context.Context, token string) (auth.UID, *UserData, error) {\n\tsessClaims, err := s.client.VerifyToken(token)\n\tif err != nil {\n\t\treturn \"\", nil, &errs.Error{\n\t\t\tCode:    errs.Unauthenticated,\n\t\t\tMessage: \"invalid token\",\n\t\t}\n\t}\n\n\tuser, err := s.client.Users().Read(sessClaims.Claims.Subject)\n\tif err != nil {\n\t\treturn \"\", nil, &errs.Error{\n\t\t\tCode:    errs.Internal,\n\t\t\tMessage: err.Error(),\n\t\t}\n\t}\n\n\tuserData := &UserData{\n\t\tID:                    user.ID,\n\t\tUsername:              user.Username,\n\t\tFirstName:             user.FirstName,\n\t\tLastName:              user.LastName,\n\t\tProfileImageURL:       user.ProfileImageURL,\n\t\tPrimaryEmailAddressID: user.PrimaryEmailAddressID,\n\t\tEmailAddresses:        user.EmailAddresses,\n\t}\n\n\treturn auth.UID(user.ID), userData, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Signed Download URLs in TypeScript\nDESCRIPTION: This snippet enables the generation of signed URLs for file downloads in private storage buckets via Encore.ts. It provides temporary public access to private files, ensuring controlled, authenticated sharing. This method creates URLs linked to specific files with set expiration dates, offering flexibility in content distribution.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/object-storage.md#2025-04-21_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst url = await documents.signedDownloadUrl(\"letter-1234\", {ttl: 7200})\n// Pass url to client\n```\n\n----------------------------------------\n\nTITLE: Uploading Files to Encore Bucket\nDESCRIPTION: This code snippet illustrates how to upload files to an Encore storage bucket using the `upload` method.  It creates a buffer with image data and then uploads it to the bucket. The contentType is set to \"image/jpeg\".\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst data = Buffer.from(...); // image data\nconst attributes = await profilePictures.upload(\"my-image.jpeg\", data, {\n  contentType: \"image/jpeg\",\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a simple API endpoint with Encore\nDESCRIPTION: This code defines a simple API endpoint using `encore.dev`. It defines the `MyAPI` function, annotated with `//encore:api`, making it accessible as an API endpoint. The function takes a `context.Context` as input and returns an error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_wrappers.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to PubSub Events in Encore\nDESCRIPTION: Example of subscribing to PubSub events in Encore. The subscription is defined with a topic, subscription ID, and handler function that processes each received event.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/code-snippets.md#2025-04-21_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nvar _ = pubsub.NewSubscription(\n    user.Signups, \"send-welcome-email\",\n    pubsub.SubscriptionConfig[*SignupEvent] {\n        Handler: SendWelcomeEmail,\n    },\n)\nfunc SendWelcomeEmail(ctx context.Context, event *SignupEvent) error {\n    ... send email ...\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PubSub Event Handling with Encore in Go\nDESCRIPTION: This code defines a service with both pointer and non-pointer receiver methods for handling PubSub events. It creates two topics with corresponding subscriptions, demonstrating how to properly configure handlers for different method receiver types.\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/pubsub_method_handler.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"encore.dev/rlog\"\n    \"encore.dev/pubsub\"\n)\n\n//encore:service\ntype Service struct{}\n\nfunc (s *Service) PointerMethod(ctx context.Context, event *Event) error {\n    rlog.Info(\"pointer method\", \"event\", event)\n    return nil\n}\n\nfunc (s Service) NonPointerMethod(ctx context.Context, event *Event) error {\n    rlog.Info(\"non-pointer method\", \"event\", event)\n    return nil\n}\n\ntype Event struct {\n    Data string\n}\n\nvar Pointer = pubsub.NewTopic[*Event](\"pointer\", pubsub.TopicConfig{\n    DeliveryGuarantee: pubsub.AtLeastOnce,\n})\n\nvar NonPointer = pubsub.NewTopic[*Event](\"non-pointer\", pubsub.TopicConfig{\n    DeliveryGuarantee: pubsub.AtLeastOnce,\n})\n\nvar _ = pubsub.NewSubscription(Pointer, \"pointer\",\n    pubsub.SubscriptionConfig[*Event]{\n        Handler: pubsub.MethodHandler((*Service).PointerMethod),\n    },\n)\n\nvar _ = pubsub.NewSubscription(NonPointer, \"non-pointer\",\n    pubsub.SubscriptionConfig[*Event]{\n        Handler: pubsub.MethodHandler(Service.NonPointerMethod),\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Cron Job for Automated Site Checks (TypeScript)\nDESCRIPTION: This code defines a cron job named \"check-all\" that automatically calls the `checkAll` endpoint every 1 hour.  It utilizes the `CronJob` class from the `encore.dev/cron` module.  The cron job is configured with a title and specifies the `checkAll` endpoint to be executed on the defined schedule.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CronJob } from \"encore.dev/cron\";\n\n// Check all tracked sites every 1 hour.\nconst cronJob = new CronJob(\"check-all\", {\n  title: \"Check all sites\",\n  every: \"1h\",\n  endpoint: checkAll,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a URL Shortening Endpoint with TypeScript\nDESCRIPTION: The snippet sets up a URL shortening API endpoint using the Encore framework. It defines interfaces for URL data and parameters, uses `randomBytes` for generating URL IDs, and sets up a POST endpoint using `api` that returns shortened URL data.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/rest-api.mdx#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n-- url/url.ts --\nimport { api } from \"encore.dev/api\";\nimport { randomBytes } from \"node:crypto\";\n\ninterface URL {\n  id: string; // short-form URL id\n  url: string; // complete URL, in long form\n}\n\ninterface ShortenParams {\n  url: string; // the URL to shorten\n}\n\n// Shortens a URL.\nexport const shorten = api(\n  { method: \"POST\", path: \"/url\", expose: true },\n  async ({ url }: ShortenParams): Promise<URL> => {\n    const id = randomBytes(6).toString(\"base64url\");\n    return { id, url };\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Accessing Public Object URLs in TypeScript\nDESCRIPTION: This snippet shows how to obtain the public URL of a stored object using the `publicUrl` method, making the object directly accessible over the internet. It's a vital function for sharing files located in public buckets, allowing seamless integration with external services and public content delivery strategies.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/object-storage.md#2025-04-21_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst url = publicProfilePictures.publicUrl(\"my-image.jpeg\");\nconsole.log(`Public URL: ${url}`);\n```\n\n----------------------------------------\n\nTITLE: Running Encore Local Development Dashboard\nDESCRIPTION: This Bash command initiates the Encore application, automatically opening the local development dashboard that includes real-time updates for API documentation and tracing tools. It does not require prior setup beyond having Encore installed.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/observability/dev-dash.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ encore run\nAPI Base URL:      http://localhost:4000\nDev Dashboard URL: http://localhost:9400/hello-world-cgu2\n```\n\n----------------------------------------\n\nTITLE: Defining Middleware Function in Encore - Go\nDESCRIPTION: This snippet defines a middleware function, 'Middleware', that processes a request and invokes the next middleware in the chain. It requires the 'context' and 'encore.dev/middleware' packages and outputs a middleware response. It encapsulates the basic middleware behavior for Encore applications.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/middlewaregen/testdata/basic.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage basic\n\nimport (\"context\"; \"encore.dev/middleware\")\n\n//encore:middleware target=all\nfunc Middleware(req middleware.Request, next middleware.Next) middleware.Response {\n    return next(req)\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Events to a Pub/Sub Topic in Go with Encore\nDESCRIPTION: Illustrates how to publish events to a Pub/Sub topic using the Publish method. It also shows how to handle the returned message ID and potential errors.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/pubsub.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nmessageID, err := Signups.Publish(ctx, &SignupEvent{UserID: id})\nif err != nil {\n    return err\n}\n\n// If we get here the event has been successfully published,\n// and all registered subscribers will receive the event.\n\n// The messageID variable contains the unique id of the message,\n// which is also provided to the subscribers when processing the event.\n```\n\n----------------------------------------\n\nTITLE: Defining Product Price API in Go with Encore\nDESCRIPTION: Implements a public API endpoint for retrieving product prices based on product ID and quantity. The endpoint uses Encore framework annotations for API routing configuration.\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/et_mocking.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage products\n\nimport (\n    \"context\"\n)\n\ntype PriceParams struct {\n    Quantity int\n}\n\ntype PriceResult struct {\n    Total float64\n}\n\n//encore:api public method=GET path=/products/:productID/price\nfunc GetPrice(ctx context.Context, productID int, p *PriceParams) (*PriceResult, error) {\n    return &PriceResult{ Total: 99.99 * float64(p.Quantity) }, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking an API Endpoint for All Tests in Go\nDESCRIPTION: This snippet shows how to mock an API endpoint for all tests in a package using Encore's et.MockEndpoint function within the TestMain function in Go.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/mocking.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage shoppingcart\n\nimport (\n\t\"context\"\n\t\"os\"\n    \"testing\"\n    \n    \"encore.dev/et\"\n\t\n\t\"your_app/products\"\n)\n\nfunc TestMain(m *testing.M) {\n    // Create a mock implementation of pricing API which will impact all tests within this package\n    et.MockEndpoint(products.GetPrice, func(ctx context.Context, p *products.PriceParams) (*products.PriceResponse, error) {\n        return &products.PriceResponse{Price: 100}, nil\n    })\n    \n    // Now run the tests\n    os.Exit(m.Run())\n}\n```\n\n----------------------------------------\n\nTITLE: Path Parameter Handling in Encore API\nDESCRIPTION: Demonstrates path parameter specification using :name syntax and wildcard parameters in Encore API endpoints.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/api-schemas.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public method=GET path=/blog/:id/*path\nfunc GetBlogPost(ctx context.Context, id int, path string) (*BlogPost, error) {\n    // Use id to query database...\n}\n```\n\n----------------------------------------\n\nTITLE: Using Sub-packages within an Encore Service\nDESCRIPTION: Demonstrates how to structure a service using sub-packages, where the hello service calls a function from a foo sub-package. Shows the API definition and implementation split across files.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/app-structure.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage hello\n\nimport (\n\t\"context\"\n\t\n\t\"encore.app/hello/foo\"\n)\n\n//encore:api public path=/hello/:name\nfunc World(ctx context.Context, name string) (*Response, error) {\n\tmsg := foo.GenerateMessage(name)\n\treturn &Response{Message: msg}, nil\n}\n\ntype Response struct {\n    Message string\n}\n```\n\nLANGUAGE: go\nCODE:\n```\npackage foo\n\nimport (\n\t\"fmt\"\n)\n\nfunc GenerateMessage(name string) string {\n\treturn fmt.Sprintf(\"Hello %s!\", name)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Protecting API Endpoints with Logto Authentication in Go\nDESCRIPTION: Implement an API endpoint that uses the Logto authentication handler to protect access. This example demonstrates how to retrieve the authenticated user ID and return a personalized response.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/logto-auth.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage api\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"encore.dev/beta/auth\"\n\t\"encore.dev/beta/errs\"\n)\n\n//encore:api auth path=/api/hello\nfunc Api(ctx context.Context) (*Response, error) {\n\tuserId, hasUserId := auth.UserID()\n\n\tif !hasUserId {\n\t\treturn nil, &errs.Error{\n\t\t\tCode:    errs.Internal,\n\t\t\tMessage: \"User ID not found\",\n\t\t}\n\t}\n\n\tmsg := fmt.Sprintf(\"Hello, %s!\", userId)\n\n\treturn &Response{Message: msg}, nil\n}\n\ntype Response struct {\n\tMessage string\n}\n```\n\n----------------------------------------\n\nTITLE: Encore API Implementation of Cats Controller\nDESCRIPTION: This TypeScript snippet demonstrates how to implement Encore APIs to replace the NestJS controller.  It uses the `api` function from `encore.dev` to define the API endpoints. It retrieves services from the `applicationContext` and interacts with them.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/how-to/nestjs.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport const findAll = api(\n  {expose: true, method: 'GET', path: '/cats'},\n  async (): Promise<{ cats: Cat[] }> => {\n    const {catsService} = await applicationContext;\n    return {cats: await catsService.findAll()};\n  },\n);\n\nexport const get = api(\n  {expose: true, method: 'GET', path: '/cats/:id'},\n  async ({id}: { id: number }): Promise<{ cat: Cat }> => {\n    const {catsService} = await applicationContext;\n    return {cat: await catsService.get(id)};\n  },\n);\n\nexport const create = api(\n  {expose: true, auth: true, method: 'POST', path: '/cats'},\n  async (dto: CreateCatDto): Promise<void> => {\n    const {catsService} = await applicationContext;\n    catsService.create(dto);\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Installing Go Modules for Auth0 Integration\nDESCRIPTION: This shell snippet installs the go-oidc and oauth2 modules needed for Auth0 integration. These modules are essential as they facilitate OAuth2 and OpenID Connect protocols necessary for authentication operations.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/auth0-auth.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ go get github.com/coreos/go-oidc/v3/oidc golang.org/x/oauth2\n```\n\n----------------------------------------\n\nTITLE: Using Number Type for Path Parameters in Encore.ts\nDESCRIPTION: This TypeScript interface demonstrates how to define a path parameter expecting a number. Encore.ts will parse the parameter as a number, and if it fails, a 400 Bad Request is returned.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Request {\n  id: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Example: Running a Database Seed Script\nDESCRIPTION: This example demonstrates how to use `encore exec` to run a TypeScript script for seeding a database. It utilizes `npx tsx` to execute the script.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ encore exec -- npx tsx ./seed.ts\n```\n\n----------------------------------------\n\nTITLE: Initializing TypeScript API Endpoint with Encore\nDESCRIPTION: Define a simple GET API endpoint using Encore's api decorator, handling dynamic path parameter and returning a response\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/quick-start.mdx#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\n\nexport const world = api(\n  { method: \"GET\", path: \"/hello/:name\", expose: true },\n  async ({ name }: { name: string }): Promise<Response> => {\n    return { message: `Hello ${name}!` };\n  }\n);\n\ninterface Response {\n  message: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Signed Upload URL using Go\nDESCRIPTION: This snippet demonstrates how to create a signed upload URL for uploading files to a storage bucket, allowing clients to upload without authentication. It utilizes a user ID and sets a time-to-live (TTL) for URL expiration.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/object-storage.md#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nurl, err := ProfilePictures.SignedUploadURL(ctx, \"my-user-id\", objects.WithTTL(time.Duration(7200)*time.Second))\\n// Pass url to client\n```\n\n----------------------------------------\n\nTITLE: Database Not Found Error Message - Encore Go\nDESCRIPTION: This snippet provides an error message indicating that the specified SQL database 'unknown-db' was not found. It advises the user to create the database using the sqldb.NewDatabase method, highlighting the importance of proper setup for effective database interaction in Encore.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_err_unknown_db_stdlib.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n Unknown sqldb database [E9999]\n\nNo database named \"unknown-db\" was found in the application. Ensure it is created somewhere using\nsqldb.NewDatabase to be able to reference it.\n\nFor more information about how to use databases in Encore, see\nhttps://encore.dev/docs/primitives/databases\n```\n\n----------------------------------------\n\nTITLE: Generated Encore API Registration and Handling\nDESCRIPTION: This snippet shows generated Go code for registering the `Foo` API endpoint with the Encore runtime and handling requests and responses. It includes request and response types (`EncoreInternal_FooReq`, `EncoreInternal_FooResp`), serialization and deserialization logic using `jsoniter`, and the integration with the Encore API framework. The generated code handles cloning requests/responses and encoding/decoding payloads for different HTTP methods.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/recursive.txt#2025-04-21_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\npackage basic\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\t__etype \"encore.dev/appruntime/shared/etype\"\n\t__serde \"encore.dev/appruntime/shared/serde\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n}\n\ntype EncoreInternal_FooReq struct {\n\tPayload *Recursive\n}\n\ntype EncoreInternal_FooResp = *Recursive\n\nvar EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{\n\tAccess: __api.Public,\n\tAppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {\n\t\tresp, err := Foo(ctx, reqData.Payload)\n\t\tif err != nil {\n\t\t\treturn (*Recursive)(nil), err\n\t\t}\n\t\treturn resp, nil\n\t},\n\tCloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {\n\t\tvar clone *EncoreInternal_FooReq\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tCloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {\n\t\tvar clone EncoreInternal_FooResp\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tDecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {\n\t\tresp = new(Recursive)\n\t\tdec := new(__etype.Unmarshaller)\n\t\t// Decode request body\n\t\tpayload := dec.ReadBody(httpResp.Body)\n\t\titer := jsoniter.ParseBytes(json, payload)\n\n\t\tfor iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {\n\t\t\tswitch strings.ToLower(key) {\n\t\t\tcase \"basic\":\n\t\t\t\tdec.ParseJSON(\"Basic\", iter, &resp.Basic)\n\t\t\tcase \"pointer\":\n\t\t\t\tdec.ParseJSON(\"Pointer\", iter, &resp.Pointer)\n\t\t\tcase \"mutual\":\n\t\t\t\tdec.ParseJSON(\"Mutual\", iter, &resp.Mutual)\n\t\t\tdefault:\n\t\t\t\t_ = iter.SkipAndReturnBytes()\n\t\t\t}\n\t\t\treturn true\n\t\t}) {\n\t\t}\n\n\t\tif err := dec.Error; err != nil {\n\t\t\treturn (*Recursive)(nil), err\n\t\t}\n\t\treturn resp, nil\n\t},\n\tDecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {\n\t\treqData = new(EncoreInternal_FooReq)\n\t\tdec := new(__etype.Unmarshaller)\n\t\tparams := new(Recursive)\n\t\treqData.Payload = params\n\t\tswitch m := httpReq.Method; m {\n\t\tcase \"POST\":\n\t\t\t// Decode request body\n\t\t\tpayload := dec.ReadBody(httpReq.Body)\n\t\t\titer := jsoniter.ParseBytes(json, payload)\n\n\t\t\tfor iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {\n\t\t\t\tswitch strings.ToLower(key) {\n\t\t\t\tcase \"basic\":\n\t\t\t\t\tdec.ParseJSON(\"Basic\", iter, &params.Basic)\n\t\t\t\tcase \"pointer\":\n\t\t\t\t\tdec.ParseJSON(\"Pointer\", iter, &params.Pointer)\n\t\t\t\tcase \"mutual\":\n\t\t\t\t\tdec.ParseJSON(\"Mutual\", iter, &params.Mutual)\n\t\t\t\tdefault:\n\t\t\t\t\t_ = iter.SkipAndReturnBytes()\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}) {\n\t\t\t}\n\n\t\tdefault:\n\t\t\tpanic(\"HTTP method is not supported\")\n\t\t}\n\t\tif err := dec.Error; err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\treturn reqData, ps, nil\n\t},\n\tDefLoc: uint32(0x0),\n\tEncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {\n\t\tparams := reqData.Payload\n\t\tif params == nil {\n\t\t\t// If the payload is nil, we need to return an empty request body.\n\t\t\treturn httpHeader, queryString, err\n\t\t}\n\n\t\t// Encode request body\n\t\tstream.WriteObjectStart()\n\t\tstream.WriteObjectField(\"Basic\")\n\t\tstream.WriteVal(params.Basic)\n\t\tstream.WriteMore()\n\t\tstream.WriteObjectField(\"Pointer\")\n\t\tstream.WriteVal(params.Pointer)\n\t\tstream.WriteMore()\n\t\tstream.WriteObjectField(\"Mutual\")\n\t\tstream.WriteVal(params.Mutual)\n\t\tstream.WriteObjectEnd()\n\n\t\treturn httpHeader, queryString, err\n\t},\n\tEncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {\n\t\trespData := []byte(\"null\\n\")\n\t\tif resp != nil {\n\t\t\t// Encode JSON body\n\t\t\trespData, err = __serde.SerializeJSONFunc(json, func(ser *__serde.JSONSerializer) {\n\t\t\t\tser.WriteField(\"Basic\", resp.Basic, false)\n\t\t\t\tser.WriteField(\"Pointer\", resp.Pointer, false)\n\t\t\t\tser.WriteField(\"Mutual\", resp.Mutual, false)\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\trespData = append(respData, '\\n')\n\t\t}\n\n\t\t// Write response\n\t\tw.Write(respData)\n\t\treturn nil\n\t},\n\tEndpoint:            \"Foo\",\n\tFallback:            false,\n\tGlobalMiddlewareIDs: []string{},\n\tMethods:             []string{\"POST\"},\n\tPath:                \"/basic.Foo\",\n\tPathParamNames:      nil,\n\tRaw:                 false,\n\tRawHandler:          nil,\n\tRawPath:             \"/basic.Foo\",\n\tReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {\n\t\treturn \"/basic.Foo\", nil, nil\n\t},\n\tReqUserPayload: func(reqData *EncoreInternal_FooReq) any {\n\t\treturn reqData.Payload\n\t},\n\tService:           \"basic\",\n\tServiceMiddleware: []*__api.Middleware{},\n\tSvcNum:            1,\n\tTags:              nil,\n}\n```\n\n----------------------------------------\n\nTITLE: Structured Logging with Encore.ts in TypeScript\nDESCRIPTION: This snippet illustrates how to implement structured logging in Encore.ts applications using the built-in logging system. This system integrates with distributed tracing for enhanced observability. There are no additional dependencies apart from Encore.ts, and the function logs error messages as well as informational logs with key-value pairs.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/migration/express-migration.md#2025-04-21_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport log from \\\"encore.dev/log\\\";\\n\\nlog.error(err, \\\"something went terribly wrong!\\\");\\nlog.info(\\\"log message\\\", {is_subscriber: true});\n```\n\n----------------------------------------\n\nTITLE: Nested Query Fields in Request Schema\nDESCRIPTION: This snippet illustrates the handling of nested query parameters in a request schema with Encore.ts, showcasing how they are sent as part of the JSON body.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api, Query } from \"encore.dev/api\";\n\ninterface Data {\n  query: Query<string>; // this will be parsed from the '?query=...' parameter in the request url\n  nested: {\n    query2: Query<string>; // Query has no effect inside nested fields\n  };\n}\n\nexport const echo = api(\n  { method: \"POST\", path: \"/nested\" },\n  async (params: Data) => {\n    // ...\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Caching Middleware in Go with Encore\nDESCRIPTION: This snippet shows how to create a caching middleware that checks for cached responses before forwarding the request to the handler. It uses the encore:middleware directive and targets APIs tagged with 'cache'.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/middleware.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:middleware target=tag:cache\nfunc CachingMiddleware(req middleware.Request, next middleware.Next) middleware.Response {\n    data := req.Data()\n    // Check if we have the response cached. Use the request path as the cache key.\n    cacheKey := data.Path\n\tif cached, err := loadFromCache(cacheKey, data.API.ResponseType); err == nil && cached != nil {\n\t    return middleware.Response{Payload: cached}\n    }\n\t// Otherwise forward the request to the handler\n\treturn next(req)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Availability Table SQL Migration\nDESCRIPTION: SQL migration script that creates an availability table to store customizable booking hours for each weekday, with initial placeholder values.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_11\n\nLANGUAGE: sql\nCODE:\n```\n-- booking/db/migrations/2_add_availability.up.sql --\nCREATE TABLE availability (\n    weekday SMALLINT NOT NULL PRIMARY KEY, -- Sunday=0, Monday=1, etc.\n    start_time TIME NULL, -- null indicates not available\n    end_time TIME NULL -- null indicates not available\n);\n\n-- Add some placeholder availability to get started\nINSERT INTO availability (weekday, start_time, end_time) VALUES\n    (0, '09:30', '17:00'),\n    (1, '09:00', '17:00'),\n    (2, '09:00', '18:00'),\n    (3, '08:30', '18:00'),\n    (4, '09:00', '17:00'),\n    (5, '09:00', '17:00'),\n    (6, '09:30', '16:30');\n```\n\n----------------------------------------\n\nTITLE: Defining API Request Headers in Go\nDESCRIPTION: Example of defining HTTP request headers using struct tags in Encore.go\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nstruct {\n    Language string `header:\"Accept-Language\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Testing URL Shortener with Vitest in TypeScript\nDESCRIPTION: Unit test for the URL shortener service that verifies the full cycle of shortening a URL and then retrieving it works correctly. Uses Vitest as the testing framework.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/rest-api.mdx#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { describe, expect, test } from \"vitest\";\nimport { get, shorten } from \"./url\";\n\ndescribe(\"shorten\", () => {\n  test(\"getting a shortened url should give back the original\", async () => {\n    const resp = await shorten({ url: \"https://example.com\" });\n    const url = await get({ id: resp.id });\n    expect(url.url).toBe(\"https://example.com\");\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Database Connections in Go with Encore sqldb\nDESCRIPTION: This snippet defines database connections using Encore's `sqldb.Named` function. It creates two named database connections, `Moo` and `Bar`, which can be used for database operations within the Encore application. These connections are initialized at the package level and are available for use in other functions.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/svc_migration_db.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage foo\n\nimport (\n    \"context\"\n\n    \"encore.dev/storage/sqldb\"\n)\n\nvar Moo = sqldb.Named(\"moo\")\nvar Bar = sqldb.Named(\"bar\")\n```\n\n----------------------------------------\n\nTITLE: Defining Fallback Routes with Encore.ts\nDESCRIPTION: This snippet demonstrates how to define a fallback route using Encore.ts in TypeScript. It covers the syntax 'path: \"/!fallback\"', which is useful for rerouting unmatched requests to a specified endpoint, allowing for gradual migration of endpoints to Encore while maintaining compatibility with existing backend services.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/defining-apis.mdx#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Route all requests to the existing HTTP router if no other endpoint matches.\nexport const fallback = api.raw(\n    { expose: true, method: \"*\", path: \"/!path\" },\n    async (req, resp) {\n        // Call old router\n    }\n)\n```\n\n----------------------------------------\n\nTITLE: Fallback Route Implementation in Encore\nDESCRIPTION: Shows how to implement fallback routes for handling unmatched requests in Encore using the /!fallback path syntax.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/api-schemas.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n//encore:service\ntype Service struct {\n\toldRouter *gin.Engine\n}\n\n//encore:api public raw path=/!fallback\nfunc (s *Service) Fallback(w http.ResponseWriter, req *http.Request) {\n    s.oldRouter.ServeHTTP(w, req)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Pub/Sub Topic (TypeScript)\nDESCRIPTION: This code defines a Pub/Sub topic named \"uptime-transition\" using Encore's Pub/Sub module. The topic is used to publish `TransitionEvent` messages whenever a monitored site transitions between up and down states. The `deliveryGuarantee` is set to \"at-least-once\" to ensure that messages are delivered reliably.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Subscription, Topic } from \"encore.dev/pubsub\";\n\n// TransitionEvent describes a transition of a monitored site\n// from up->down or from down->up.\nexport interface TransitionEvent {\n  site: Site; // Site is the monitored site in question.\n  up: boolean; // Up specifies whether the site is now up or down (the new value).\n}\n\n// TransitionTopic is a pubsub topic with transition events for when a monitored site\n// transitions from up->down or from down->up.\nexport const TransitionTopic = new Topic<TransitionEvent>(\"uptime-transition\", {\n  deliveryGuarantee: \"at-least-once\",\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a NestJS Application Context for Encore\nDESCRIPTION: This TypeScript snippet demonstrates how to create a NestJS application context to be used within Encore services. It uses `NestFactory.createApplicationContext` to bootstrap the Nest application and then retrieves specific modules or services from the context, making them accessible to Encore APIs.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/how-to/nestjs.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst applicationContext: Promise<{ catsService: CatsService }> =\n  NestFactory.createApplicationContext(AppModule).then((app) => {\n    return {\n      catsService: app.select(CatsModule).get(CatsService, {strict: true}),\n      // other services...\n    };\n  });\n\nexport default applicationContext;\n```\n\n----------------------------------------\n\nTITLE: Defining Encore Service Structure in Go\nDESCRIPTION: This snippet defines a basic structure for an Encore service. It serves as the foundational representation of the service, with the 'Foo' method declared for external API use.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/service_struct.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n-- basic.go --\npackage basic\n\nimport \"context\"\n\n//encore:service\ntype Service struct{}\n\n//encore:api public\nfunc (s *Service) Foo(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Defining Authentication Handler in Go with Encore\nDESCRIPTION: Defines an authentication handler MyAuth in the svc package that processes authentication tokens and returns user data. Uses encore:authhandler directive to mark the function as an authentication handler.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/auth_handler_call.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"encore.dev/beta/auth\"\n)\n\ntype MyData struct {\n    Name string\n}\n\n//encore:authhandler\nfunc MyAuth(ctx context.Context, token string) (auth.UID, *MyData, error) { return \"\", nil, nil }\n```\n\n----------------------------------------\n\nTITLE: Checking Environment Type in TypeScript\nDESCRIPTION: This TypeScript code shows how to use `appMeta()` to check the environment type (test, development, or other) and conditionally skip email verification during user signup. Depending on the environment, the code either marks the email as verified directly or sends a verification email, allowing for different behavior in testing and production environments.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/metadata.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { appMeta } from \"encore.dev\";\n\nexport const signup = api(\n  { expose: true },\n  async (params: SignupParams): Promise<SignupResponse> => {\n    // more code...\n\n    // If this is a testing environment, skip sending the verification email.\n    switch (appMeta().environment.type) {\n      case \"test\":\n      case \"development\":\n        await markEmailVerified(userID);\n        break;\n      default:\n        await sendVerificationEmail(userID);\n        break;\n    }\n\n    // more code...\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Structured Error Handling in Encore\nDESCRIPTION: Implementation of structured errors using Encore's errs package, demonstrating error creation, wrapping, and metadata management\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_22\n\nLANGUAGE: Go\nCODE:\n```\nreturn &errs.Error{\n    Code: errs.NotFound,\n    Message: \"sprocket not found\",\n}\n```\n\nLANGUAGE: Go\nCODE:\n```\neb := errs.B().Meta(\"board_id\", params.ID)\nreturn eb.Code(errs.NotFound).Msg(\"board not found\").Err()\n```\n\n----------------------------------------\n\nTITLE: Executing Scripts with Encore Exec in Bash\nDESCRIPTION: This snippet demonstrates using the `encore exec` command to run a TypeScript script for database seeding. It requires the Encore runtime to be configured and initialized, providing an environment suitable for running infrastructure-dependent scripts.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/running-scripts.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nencore exec -- npx tsx ./seed.ts\n```\n\n----------------------------------------\n\nTITLE: Initializing Pub/Sub Outbox Relay in Go\nDESCRIPTION: This Go code snippet shows how to initialize a Pub/Sub outbox relay, register topics for polling, and start the polling process. It's typically done during service initialization.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/pubsub-outbox.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage user\n\nimport (\n\t\"context\"\n\t\n    \"encore.dev/pubsub\"\n    \"encore.dev/storage/sqldb\"\n    \"x.encore.dev/infra/pubsub/outbox\"\n)\n\ntype Service struct {\n\tsignupsRef pubsub.Publisher[*SignupEvent]\n}\n\n// db is the database the outbox table is stored in\nvar db = sqldb.NewDatabase(...)\n\n// Create the SignupsTopic somehow.\nvar SignupsTopic = pubsub.NewTopic[*SignupEvent](/* ... */)\n\nfunc initService() (*Service, error) {\n    // Initialize the relay to poll from our database.\n\trelay := outbox.NewRelay(outbox.SQLDBStore(db))\n\t\n\t// Register the SignupsTopic to be polled.\n    signupsRef := pubsub.TopicRef[pubsub.Publisher[*SignupEvent]](SignupsTopic)\n\toutbox.RegisterTopic(relay, signupsRef)\n\t\n\t// Start polling.\n\tgo relay.PollForMessage(context.Background(), -1)\n\t\n\treturn &Service{signupsRef: signupsRef}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Service with Configuration in Encore\nDESCRIPTION: Defines a service with a typed configuration loaded via config.Load. The configuration includes a boolean flag that controls feature enablement.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/config_err_use_from_other_service.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/config\"\n)\n\ntype Config struct {\n    FooEnabled bool\n}\n\nvar Cfg = config.Load[Config]()\n\n\n//encore:api\nfunc Subscriber1(ctx context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an API Endpoint with Path Parameters in Encore\nDESCRIPTION: This snippet shows how to define an API endpoint with path parameters using Encore. It demonstrates the use of the 'path' field in the '//encore:api' annotation and how to handle path variables in the function signature.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/defining-apis.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n// GetBlogPost retrieves a blog post by id.\n//encore:api public method=GET path=/blog/:id/*path\nfunc GetBlogPost(ctx context.Context, id int, path string) (*BlogPost, error) {\n    // Use id to query database...\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration for DsConfig in Encore (Go)\nDESCRIPTION: This snippet defines the DsConfig structure and handles its configuration loading within the Encore framework. It features a field 'Foo' of type config.String, similar to the other configuration structures specified in the service.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/merge_identical_comments.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n)\n\ntype DsConfig struct{\n    Foo config.String // Some extra comment\n}\n\nvar _ = config.Load[DsConfig]()\n```\n\n----------------------------------------\n\nTITLE: Serving Static Frontend Assets in Encore\nDESCRIPTION: Configure a static file serving endpoint that exposes files from a specified directory, with optional fallback handling for missing files\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/frontend/hosting.mdx#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\n\n// Using fallback route to serve all files in the ./assets directory under the root path.\nexport const rootAssets = api.static({\n  expose: true,\n  path: \"/!path\",\n  dir: \"./assets\",\n  // When a file matching the request isn't found, Encore automatically serves a 404 Not Found response.\n  // You can customize the response by setting the notFound option to specify a file that should be served instead:\n  notFound: \"./assets/not_found.html\",\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Database Connection - Encore Go\nDESCRIPTION: This snippet initializes a connection to a SQL database named 'unknown-db' using the Encore sqldb package. It also demonstrates how to define a public API method called 'Foo' returning an error type. It's crucial that the database is created using sqldb.NewDatabase before use.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_err_unknown_db_stdlib.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"encore.dev/storage/sqldb\"\n)\n\nvar Moo = sqldb.Named(\"unknown-db\").Stdlib()\n\n//encore:api public\nfunc Foo(ctx context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Middleware as a Method on a Service Struct in Go with Encore\nDESCRIPTION: This snippet demonstrates how to define middleware as a method on a Dependency Injection struct declared with //encore:service. It shows the structure for creating service-specific middleware.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/middleware.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n//encore:service\ntype Service struct{}\n\n//encore:middleware target=all\nfunc (s *Service) MyMiddleware(req middleware.Request, next middleware.Next) middleware.Response {\n\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Google Cloud Storage in Encore\nDESCRIPTION: Configuration for Google Cloud Storage buckets including optional prefix and public access URL settings.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_17\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"object_storage\": [\n    {\n      \"type\": \"gcs\",\n      \"buckets\": {\n        \"my-gcs-bucket\": {\n          \"name\": \"my-gcs-bucket\",\n          \"key_prefix\": \"my-optional-prefix/\",\n          \"public_base_url\": \"https://my-gcs-bucket-cdn.example.com/my-optional-prefix\"\n        }\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating APIs with Path and Query Parameters in TypeScript\nDESCRIPTION: Demonstrates API route handling with dynamic path parameters and query string parameters in Express.js and Encore.ts, highlighting type-safe API definition in Encore.ts\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/migration/express-migration.md#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport express, {Request, Response} from \"express\";\n\nconst app: Express = express();\n\n// GET request with dynamic path parameter\napp.get(\"/hello/:name\", (req: Request, res: Response) => {\n  const msg = `Hello ${req.params.name}!`;\n  res.json({message: msg});\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport {api, Query} from \"encore.dev/api\";\n\n// Dynamic path parameter :name\nexport const dynamicPathParamExample = api(\n  {expose: true, method: \"GET\", path: \"/hello/:name\"},\n  async ({name}: { name: string }): Promise<{ message: string }> => {\n    const msg = `Hello ${name}!`;\n    return {message: msg};\n  },\n```\n\n----------------------------------------\n\nTITLE: Inserting URLs into the Database in Go\nDESCRIPTION: This Go function 'insert' defines how to insert URLs into the database by executing an SQL command to insert the id and the original URL into the 'url' table. It relies on the 'sqldb' package from 'encore.dev' to handle database interactions.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/rest-api.mdx#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// insert inserts a URL into the database.\nfunc insert(ctx context.Context, id, url string) error {\n\t_, err := db.Exec(ctx, `\n        INSERT INTO url (id, original_url)\n        VALUES ($1, $2)\n    `, id, url)\n\treturn err\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Auth Handler and API Endpoints in Go\nDESCRIPTION: This Go snippet defines an auth handler with API endpoints for login, callback, and logout processes. It utilizes the Authenticator to manage OAuth flows and token verifications, and handles user profile retrieval upon successful authentication.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/auth0-auth.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage auth\n\nimport (\n\t\"context\"\n\t\"net/url\"\n\n\t\"encore.dev/beta/auth\"\n\t\"encore.dev/beta/errs\"\n\t\"github.com/coreos/go-oidc/v3/oidc\"\n)\n\n// Service struct definition.\n// Learn more: encore.dev/docs/primitives/services-and-apis/service-structs\n//\n//encore:service\ntype Service struct {\n\tauth *Authenticator\n}\n\n// initService is automatically called by Encore when the service starts up.\nfunc initService() (*Service, error) {\n\tauthenticator, err := New()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Service{auth: authenticator}, nil\n}\n\ntype LoginResponse struct {\n\tState       string `json:\"state\"`\n\tAuthCodeURL string `json:\"auth_code_url\"`\n}\n\n//encore:api public method=POST path=/auth/login\nfunc (s *Service) Login(ctx context.Context) (*LoginResponse, error) {\n\tstate, err := generateRandomState()\n\tif err != nil {\n\t\treturn nil, &errs.Error{\n\t\t\tCode:    errs.Internal,\n\t\t\tMessage: err.Error(),\n\t\t}\n\t}\n\n\treturn &LoginResponse{\n\t\tState: state,\n\t\t// add the audience to the auth code url\n\t\tAuthCodeURL: s.auth.AuthCodeURL(state),\n\t}, nil\n}\n\ntype CallbackRequest struct {\n\tCode string `json:\"code\"`\n}\n\ntype CallbackResponse struct {\n\tToken string `json:\"token\"`\n}\n\n//encore:api public method=POST path=/auth/callback\nfunc (s *Service) Callback(\n\tctx context.Context,\n\treq *CallbackRequest,\n) (*CallbackResponse, error) {\n\n\t// Exchange an authorization code for a token.\n\ttoken, err := s.auth.Exchange(ctx, req.Code)\n\tif err != nil {\n\t\treturn nil, &errs.Error{\n\t\t\tCode:    errs.PermissionDenied,\n\t\t\tMessage: \"Failed to convert an authorization code into a token.\",\n\t\t}\n\t}\n\n\tidToken, err := s.auth.VerifyIDToken(ctx, token)\n\tif err != nil {\n\t\treturn nil, &errs.Error{\n\t\t\tCode:    errs.Internal,\n\t\t\tMessage: \"Failed to verify ID Token.\",\n\t\t}\n\t}\n\n\tvar profile map[string]interface{}\n\tif err := idToken.Claims(&profile); err != nil {\n\t\treturn nil, &errs.Error{\n\t\t\tCode:    errs.Internal,\n\t\t\tMessage: err.Error(),\n\t\t}\n\t}\n\n\treturn &CallbackResponse{\n\t\tToken: token.Extra(\"id_token\").(string),\n\t}, nil\n}\n\ntype LogoutResponse struct {\n\tRedirectURL string `json:\"redirect_url\"`\n}\n\n//encore:api public method=GET path=/auth/logout\nfunc (s *Service) Logout(ctx context.Context) (*LogoutResponse, error) {\n\tlogoutUrl, err := url.Parse(\"https://\" + cfg.Domain() + \"/v2/logout\")\n\tif err != nil {\n\t\treturn nil, &errs.Error{\n\t\t\tCode:    errs.Internal,\n\t\t\tMessage: err.Error(),\n\t\t}\n\t}\n\n\treturnTo, err := url.Parse(cfg.LogoutURL())\n\tif err != nil {\n\t\treturn nil, &errs.Error{\n\t\t\tCode:    errs.Internal,\n\t\t\tMessage: err.Error(),\n\t\t}\n\t}\n\n\tparameters := url.Values{}\n\tparameters.Add(\"returnTo\", returnTo.String())\n\tparameters.Add(\"client_id\", cfg.ClientID())\n\tlogoutUrl.RawQuery = parameters.Encode()\n\n\treturn &LogoutResponse{\n\t\tRedirectURL: logoutUrl.String(),\n\t}, nil\n}\n\n...\n```\n\n----------------------------------------\n\nTITLE: GraphQL API with Apollo Server and Encore Raw Endpoint (TS)\nDESCRIPTION: This snippet demonstrates how to create a GraphQL API using Apollo Server within an Encore.ts application using a Raw endpoint.  It initializes Apollo Server, defines a GraphQL endpoint using `api.raw`, extracts headers from the request, and passes the request to Apollo Server.  The response from Apollo Server is then used to set headers, status code, and write the response back to the client.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/graphql.mdx#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HeaderMap } from \"@apollo/server\";\nimport { api } from \"encore.dev/api\";\nconst { ApolloServer, gql } = require(\"apollo-server\");\nimport { json } from \"node:stream/consumers\";\n\n// Type definition schema\nconst typeDefs = gql`\n  ...\n`;\n\n// Resolver functions\nconst resolvers = {\n  // ...\n};\n\nconst server = new ApolloServer({ typeDefs, resolvers });\n\nawait server.start();\n\nexport const graphqlAPI = api.raw(\n  { expose: true, path: \"/graphql\", method: \"*\" },\n  async (req, res) => {\n    // Make sure the Apollo server is started\n    server.assertStarted(\"/graphql\");\n\n    // Extract headers in a format that Apollo understands\n    const headers = new HeaderMap();\n    for (const [key, value] of Object.entries(req.headers)) {\n      if (value !== undefined) {\n        headers.set(key, Array.isArray(value) ? value.join(\", \") : value);\n      }\n    }\n\n    // Get response from Apollo server\n    const httpGraphQLResponse = await server.executeHTTPGraphQLRequest({\n      httpGraphQLRequest: {\n        headers,\n        method: req.method!.toUpperCase(),\n        body: await json(req),\n        search: new URLSearchParams(req.url ?? \"\").toString(),\n      },\n      context: async () => {\n        return { req, res };\n      },\n    });\n\n    // Set headers\n    for (const [key, value] of httpGraphQLResponse.headers) {\n      res.setHeader(key, value);\n    }\n\n    // Set status code\n    res.statusCode = httpGraphQLResponse.status || 200;\n\n    // Write response if it's complete\n    if (httpGraphQLResponse.body.kind === \"complete\") {\n      res.end(httpGraphQLResponse.body.string);\n      return;\n    }\n\n    // Write response in chunks if it's async\n    for await (const chunk of httpGraphQLResponse.body.asyncIterator) {\n      res.write(chunk);\n    }\n    res.end();\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Global All-Endpoints Middleware Implementation\nDESCRIPTION: Implements global middleware targeting all endpoints, passing through requests unmodified\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/middleware.txt#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n//encore:middleware global target=all\nfunc AllInSvc(req middleware.Request, next middleware.Next) middleware.Response {\n    return next(req)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Availability Management in Go\nDESCRIPTION: Go implementation of endpoints to get and set availability, with validation and database interaction. Includes functionality to retrieve, validate, and update availability records for each day of the week.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_14\n\nLANGUAGE: go\nCODE:\n```\n-- booking/availability.go --\npackage booking\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"encore.app/booking/db\"\n\t\"github.com/jackc/pgx/v5/pgtype\"\n\n\t\"encore.dev/beta/errs\"\n\t\"encore.dev/rlog\"\n)\n\ntype Availability struct {\n\tStart *string `json:\"start\" encore:\"optional\"`\n\tEnd   *string `json:\"end\" encore:\"optional\"`\n}\n\ntype GetAvailabilityResponse struct {\n\tAvailability []Availability\n}\n\n//encore:api public method=GET path=/availability\nfunc GetAvailability(ctx context.Context) (*GetAvailabilityResponse, error) {\n\trows, err := query.GetAvailability(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tavailability := make([]Availability, 7)\n\tfor _, row := range rows {\n\t\tday := row.Weekday\n\t\tif day < 0 || day > 6 {\n\t\t\trlog.Error(\"invalid week day in availability table\", \"row\", row)\n\t\t\tcontinue\n\t\t}\n\n\t\t// These never fail\n\t\tstart, _ := row.StartTime.TimeValue()\n\t\tend, _ := row.EndTime.TimeValue()\n\t\tavailability[day] = Availability{\n\t\t\tStart: timeToStr(start),\n\t\t\tEnd:   timeToStr(end),\n\t\t}\n\t}\n\n\treturn &GetAvailabilityResponse{Availability: availability}, nil\n}\n\ntype SetAvailabilityParams struct {\n\tAvailability []Availability\n}\n\n//encore:api auth method=POST path=/availability\nfunc SetAvailability(ctx context.Context, params SetAvailabilityParams) error {\n\teb := errs.B()\n\ttx, err := pgxdb.Begin(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer tx.Rollback(context.Background()) // committed explicitly on success\n\n\tqry := query.WithTx(tx)\n\tfor weekday, a := range params.Availability {\n\t\tif weekday > 6 {\n\t\t\treturn eb.Code(errs.InvalidArgument).Msgf(\"invalid weekday %d\", weekday).Err()\n\t\t}\n\n\t\tstart, err1 := strToTime(a.Start)\n\t\tend, err2 := strToTime(a.End)\n\t\tif err := errors.Join(err1, err2); err != nil {\n\t\t\treturn eb.Cause(err).Code(errs.InvalidArgument).Msg(\"invalid start/end time\").Err()\n\t\t} else if start.Valid != end.Valid {\n\t\t\treturn eb.Code(errs.InvalidArgument).Msg(\"both start/stop must be set, or both null\").Err()\n\t\t} else if start.Valid && start.Microseconds > end.Microseconds {\n\t\t\treturn eb.Code(errs.InvalidArgument).Msg(\"start must be before end\").Err()\n\t\t}\n\n\t\terr = qry.UpdateAvailability(ctx, db.UpdateAvailabilityParams{\n\t\t\tWeekday:   int16(weekday),\n\t\t\tStartTime: start,\n\t\t\tEndTime:   end,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn eb.Cause(err).Code(errs.Unavailable).Msg(\"failed to update availability\").Err()\n\t\t}\n\t}\n\n\terr = tx.Commit(ctx)\n\treturn errs.WrapCode(err, errs.Unavailable, \"failed to commit transaction\")\n}\n```\n\n----------------------------------------\n\nTITLE: Database Setup and Operations Using Encore.ts in TypeScript\nDESCRIPTION: This snippet demonstrates setting up a SQL database with Encore.ts, defining migrations, and performing database operations such as querying and inserting data. It requires Encore.ts and provides a structured way to handle database schemas and queries with automatic provisioning. Inputs include parameters for user id and name, while outputs involve user objects or direct acknowledgment of operations.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/migration/express-migration.md#2025-04-21_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n-- db.ts --\\nimport {api} from \\\"encore.dev/api\\\";\\nimport {SQLDatabase} from \\\"encore.dev/storage/sqldb\\\";\\n\\n// Define a database named 'users', using the database migrations in the \\\"./migrations\\\" folder.\\n// Encore automatically provisions, migrates, and connects to the database.\\nexport const DB = new SQLDatabase(\\\"users\\\", {\\n  migrations: \\\"./migrations\\\",\\n});\\n\\ninterface User {\\n  name: string;\\n  id: number;\\n}\\n\\n// Get one User from DB\\nexport const getUser = api(\\n  {expose: true, method: \\\"GET\\\", path: \\\"/user/:id\\\"},\\n  async ({id}: { id: number }): Promise<{ user: User | null }> => {\\n    const user = await DB.queryRow<User>`\\n        SELECT name\\n        FROM users\\n        WHERE id = ${id}\\n    `;\\n\\n    return {user};\\n  },\\n);\\n\\n// Add User from DB\\nexport const addUser = api(\\n  { expose: true, method: \\\"POST\\\", path: \\\"/user\\\" },\\n  async ({ name }: { name: string }): Promise<void> => {\\n    await DB.exec`\\n        INSERT INTO users (name)\\n        VALUES (${name})\\n    `;\\n    return;\\n  },\\n);\n```\n\nLANGUAGE: sql\nCODE:\n```\n-- migrations/1_create_tables.up.sql --\\nCREATE TABLE users (\\n    id SERIAL PRIMARY KEY,\\n    name TEXT NOT NULL UNIQUE\\n);\n```\n\n----------------------------------------\n\nTITLE: Setting up PostgreSQL Database Schema with SQL\nDESCRIPTION: Defines a database schema for storing shortened URLs in a PostgreSQL database. This SQL migration file creates a `url` table with columns for URL IDs and original URLs, to support persistent URL storage.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/rest-api.mdx#2025-04-21_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\n-- url/migrations/001_create_tables.up.sql --\nCREATE TABLE url (\n\tid TEXT PRIMARY KEY,\n\toriginal_url TEXT NOT NULL\n);\n```\n\n----------------------------------------\n\nTITLE: Additional Encore Configuration with Boolean Type\nDESCRIPTION: Shows a third configuration type using config.String and config.Bool, highlighting flexibility of Encore's configuration system\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/multiple_configs_in_service.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ntype ThisConfig struct{\n    Foo config.String // And even better in ThisConfig\n    Baz config.Bool\n}\n\nvar _ = config.Load[ThisConfig]()\n```\n\n----------------------------------------\n\nTITLE: Initializing Temporal Service in Go\nDESCRIPTION: Sets up a Temporal service with a client and worker, using environment-specific task queues. Includes service initialization and shutdown methods.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/temporal.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage greeting\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"go.temporal.io/sdk/client\"\n\t\"go.temporal.io/sdk/worker\"\n\t\"encore.dev\"\n)\n\n// Use an environment-specific task queue so we can use the same\n// Temporal Cluster for all cloud environments.\nvar (\n    envName = encore.Meta().Environment.Name\n    greetingTaskQueue = envName + \"-greeting\"\n)\n\n//encore:service\ntype Service struct {\n\tclient client.Client\n\tworker worker.Worker\n}\n\nfunc initService() (*Service, error) {\n\tc, err := client.Dial(client.Options{})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create temporal client: %v\", err)\n\t}\n\n\tw := worker.New(c, greetingTaskQueue, worker.Options{})\n\n\terr = w.Start()\n\tif err != nil {\n\t\tc.Close()\n\t\treturn nil, fmt.Errorf(\"start temporal worker: %v\", err)\n\t}\n\treturn &Service{client: c, worker: w}, nil\n}\n\nfunc (s *Service) Shutdown(force context.Context) {\n\ts.client.Close()\n\ts.worker.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Ordered Topics Example in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a Pub/Sub topic that maintains order for messages, with delivery guarantees based on a specified ordering attribute.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/pubsub.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Topic, Attribute } from \"encore.dev/pubsub\";\n\nexport interface CartEvent {\n\tshoppingCartID: Attribute<number>;\n\tevent: string;\n}\n\nexport const cartEvents = new Topic<CartEvent>(\"cart-events\", {\n\tdeliveryGuarantee: \"at-least-once\",\n\torderingAttribute: \"shoppingCartID\",\n})\n\nasync function example() {\n\t// These are delivered in order as they all have the same shopping cart ID\n\tawait cartEvents.publish({shoppingCartID: 1, event: \"item_added\"});\n\tawait cartEvents.publish({shoppingCartID: 1, event: \"checkout_started\"});\n\tawait cartEvents.publish({shoppingCartID: 1, event: \"checkout_completed\"});\n\n\t// This may be delivered at any point as it has a different shopping cart ID.\n\tawait cartEvents.publish({shoppingCartID: 2, event: \"item_added\"});\n}\n```\n\n----------------------------------------\n\nTITLE: Downloading Profile Picture API Endpoint in Go\nDESCRIPTION: Implements a public API endpoint for serving user profile pictures using Object Storage download functionality\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/object-storage.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public raw method=GET path=/profile-picture/:userID\nfunc ServeProfilePicture(w http.ResponseWriter, req *http.Request) {\n\tuserID := encore.CurrentRequest().PathParams.Get(\"userID\")\n\treader := ProfilePictures.Download(req.Context(), userID)\n\n\tif err := reader.Err(); err != nil {\n\t\terrs.HTTPError(w, err)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"image/jpeg\")\n\tio.Copy(w, reader)\n}\n```\n\n----------------------------------------\n\nTITLE: Organizing Monorepo Structure - TypeScript\nDESCRIPTION: This code snippet illustrates how to structure a TypeScript application with backend and frontend folders within a monorepo. The organization allows for separation of dependencies for both the frontend and backend, enabling a streamlined development process. Each part of the application can have its own `package.json` to handle dependencies explicitly.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/frontend/mono-vs-multi-repo.mdx#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n\"/my-app\\n backend\\n    encore.app\\n    package.json // Backend dependencies\\n    ...\\n frontend\\n     package.json // Frontend dependencies\\n     ...\"\n```\n\n----------------------------------------\n\nTITLE: Creating Raw HTTP Endpoints in Encore.ts\nDESCRIPTION: Implements a raw HTTP endpoint with lower-level access to the request and response objects. This pattern is useful for webhook implementations and custom HTTP handling that requires direct control over the HTTP response.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\nexport const myRawEndpoint = api.raw(\n{ expose: true, path: \"/raw\", method: \"GET\" },\nasync (req, resp) => {\nresp.writeHead(200, { \"Content-Type\": \"text/plain\" });\nresp.end(\"Hello, raw world!\");\n}\n);\n```\n\n----------------------------------------\n\nTITLE: Rejecting Authentication in TypeScript with Encore\nDESCRIPTION: This snippet illustrates how to reject an authentication request by throwing an APIError when credentials are invalid. The auth handler is set up to throw an unauthenticated error, ensuring that unauthorized requests are correctly handled.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/auth.md#2025-04-21_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { APIError } from \"encore.dev/api\";\n\nexport const auth = authHandler<AuthParams, AuthData>(\n    async (params) => {\n        throw APIError.unauthenticated(\"bad credentials\");\n    }\n)\n```\n\n----------------------------------------\n\nTITLE: Registering Temporal Workflow and Activity in Go\nDESCRIPTION: Updates the greeting service to register the Temporal Workflow and Activity with the worker.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/temporal.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// Import the package at the top:\nimport \"encore.app/greeting/workflow\"\n\n// Add these lines to `initService`, below the call to `worker.New`:\nw.RegisterWorkflow(workflow.Greeting)\nw.RegisterActivity(workflow.ComposeGreeting)\n```\n\n----------------------------------------\n\nTITLE: Creating a PubSub Topic in Go with Encore\nDESCRIPTION: This code snippet demonstrates defining a message type `MyMessage` and creating a new PubSub topic using Encore's `pubsub.NewTopic` function in Go. It underscores the correct instantiation method for a topic, avoiding invalid references. Dependencies include the `context` package and Encore's `pubsub`. The snippet requires specifying the topic name as a string and outputs a topic instance. The correct usage pattern necessitates calling the function directly to create a new topic instance to avoid errors.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_new_topic_func_aliased.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/pubsub\"\n)\n\ntype MyMessage struct {}\n\nvar creator = pubsub.NewTopic[MyMessage]\n\nvar topic = creator(\"my-topic\")\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Local Secrets with CUE\nDESCRIPTION: This snippet demonstrates how to override secrets for your local machine by creating a `.secrets.local.cue` file in the root of your Encore application. This file contains key-value pairs of secret names to secret values and allows developers to customize secret values for their local development environment without affecting other developers.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/secrets.md#2025-04-21_snippet_2\n\nLANGUAGE: cue\nCODE:\n```\nGitHubAPIToken: \"my-local-override-token\"\nSSHPrivateKey: \"custom-ssh-private-key\"\n```\n\n----------------------------------------\n\nTITLE: Database Insert Operation Example\nDESCRIPTION: Demonstrates how to perform an insert operation in an Encore SQL database\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc insert(ctx context.Context, id, title string, done bool) error {\n    _, err := tododb.Exec(ctx, `\n        INSERT INTO todo_item (id, title, done)\n        VALUES ($1, $2, $3)\n    `, id, title, done)\n    return err\n}\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image\nDESCRIPTION: The `encore build docker` command creates a portable Docker image of your Encore application. It supports flags for specifying the base image and pushing the image to a remote repository.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_31\n\nLANGUAGE: shell\nCODE:\n```\n$ encore build docker\n```\n\n----------------------------------------\n\nTITLE: Using transactions with SQL in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to use transactions to group multiple database operations. It starts a transaction using `db.begin`, performs two insert operations, and then commits the transaction using `tx.commit`. The `using` statement ensures the transaction is rolled back if not explicitly committed.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/databases.md#2025-04-21_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n\"await using tx = await db.begin();\n\nawait db.exec`\n  INSERT INTO todo_item (title, done)\n  VALUES (${title1}, false)\n`;\n\nawait db.exec`\n  INSERT INTO todo_item (title, done)\n  VALUES (${title2}, false)\n`;\n\nawait tx.commit();\"\n```\n\n----------------------------------------\n\nTITLE: Using a Secret in Encore\nDESCRIPTION: This code illustrates how to use a secret defined in Encore. The secret is accessed as a function that returns the secret value. It demonstrates fetching user information from GitHub using a token obtained from a secret.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nasync function callGitHub() {\n  const resp = await fetch(\"https:///api.github.com/user\", {\n    credentials: \"include\",\n    headers: {\n      Authorization: `token ${githubToken()}`,\n    },\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Service-to-Service API Call in Encore.ts\nDESCRIPTION: Demonstrates how to make service-to-service API calls in Encore.ts. Services are imported from the ~encore/clients module and called using regular async function syntax with full type safety.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { hello } from \"~encore/clients\";\nexport const myOtherAPI = api({}, async (): Promise<void> => {\nconst resp = await hello.ping({ name: \"World\" });\nconsole.log(resp.message); // \"Hello World!\"\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Configuration Unmarshaling with jsoniter in Go\nDESCRIPTION: This snippet uses the `jsoniter` package to define custom unmarshaling logic for configuration loading within Encore. These functions convert JSON data to predefined Go types related to server options. The configuration unmarshaling handles HTTP, TCP, and GRPC server options specifically.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_named_struct_multiple_uses.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport jsoniter \"github.com/json-iterator/go\"\n\n/*\nThese functions are automatically generated and maintained by Encore to allow config values\nto be unmarshalled into the correct types. They are not intended to be used directly. They\nare automatically updated by Encore whenever you change the data types used within your\ncalls to config.Load[T]().\n*/\n\n// Concrete unmarshalers for all config.Load calls, including those using generic types.\n// These instances are used directly by calls to `config.Load[T]()`.\nvar (\n\tencoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {\n\t\treturn func() *Config {\n\t\t\t// If the value is null, we return nil\n\t\t\tif itr.ReadNil() {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Otherwise we unmarshal the value and return a pointer to it\n\t\t\tobj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))\n\t\t\treturn &obj\n\t\t}()\n\t}\n)\n\n// encoreInternalTypeConfigUnmarshaler_svc_Config will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"HTTP\":\n\t\t\tobj.HTTP = encoreInternalTypeConfigUnmarshaler_svc_ServerOptions(itr, append(path, \"HTTP\"))\n\t\tcase \"TCP\":\n\t\t\tobj.TCP = encoreInternalTypeConfigUnmarshaler_svc_ServerOptions(itr, append(path, \"TCP\"))\n\t\tcase \"GRPC\":\n\t\t\tobj.GRPC = encoreInternalTypeConfigUnmarshaler_svc_ServerOptions(itr, append(path, \"GRPC\"))\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n\n// encoreInternalTypeConfigUnmarshaler_svc_ServerOptions will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_svc_ServerOptions(itr *jsoniter.Iterator, path []string) (obj ServerOptions) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"Enabled\":\n\t\t\tobj.Enabled = itr.ReadBool()\n\t\tcase \"Port\":\n\t\t\tobj.Port = itr.ReadUint32()\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Concurrent Site Checking in Go\nDESCRIPTION: Creates a CheckAll endpoint that concurrently checks multiple sites using errgroup for parallel execution with a limit of 8 concurrent checks.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/uptime.md#2025-04-21_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nimport \"golang.org/x/sync/errgroup\"\n\n// CheckAll checks all sites.\n//\n//encore:api public method=POST path=/checkall\nfunc CheckAll(ctx context.Context) error {\n\t// Get all the tracked sites.\n\tresp, err := site.List(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check up to 8 sites concurrently.\n\tg, ctx := errgroup.WithContext(ctx)\n\tg.SetLimit(8)\n\tfor _, site := range resp.Sites {\n\t\tsite := site // capture for closure\n\t\tg.Go(func() error {\n\t\t\treturn check(ctx, site)\n\t\t})\n\t}\n\treturn g.Wait()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PubSub Topic and Message Type in Go\nDESCRIPTION: This snippet defines a MessageType struct and creates a PubSub topic using Encore's pubsub package. The topic is configured with 'AtLeastOnce' delivery guarantee. Note that the topic name is incorrectly formatted and should be in kebab-case.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_topic_name_invalid.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/pubsub\"\n)\n\ntype MessageType struct {\n    Name string\n}\n\nvar (\n    BasicTopic = pubsub.NewTopic[*MessageType](\"basic topic\", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })\n)\n```\n\n----------------------------------------\n\nTITLE: Declaring a Database in Encore\nDESCRIPTION: This TypeScript code snippet demonstrates how to declare a database in an Encore application using the `SQLDatabase` primitive. It also defines an API endpoint to retrieve user data from the database.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/deploy-to-railway.md#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n\"      const mydb = new SQLDatabase(\\\"mydb\\\", {\\n         migrations: \\\"./migrations\\\",\\n      });\\n\\n      export const getUser = api(\\n        { expose: true, method: \\\"GET\\\", path: \\\"/names/:id\\\" },\\n        async ({id}: {id:number}): Promise<{ id: number; name: string }> => {\\n          return await mydb.queryRow`SELECT * FROM users WHERE id = ${id}` as { id: number; name: string };\\n        }\\n      );\"\n```\n\n----------------------------------------\n\nTITLE: Defining Complex API Parameters in TypeScript\nDESCRIPTION: Interface defining multiple query and header parameters with different type specifications using Encore's API decorators\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/tests/testdata/query_header.txt#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Params {\n    q1: Query;\n    q2: Query<boolean>;\n    q3: Query<\"my-query\">;\n    q4: Query<boolean, \"my-query\">;\n\n    h1: Header;\n    h2: Header<boolean>;\n    h3: Header<\"my-header\">;\n    h4: Header<boolean, \"my-header\">;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining utils config package in Go\nDESCRIPTION: This snippet defines the `utils` package which contains the `ExtraConfig` struct.  The `ExtraConfig` struct defines a `Foo` string and `Bar` integer config. These are loaded using the `encore.dev/config` package.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/types_from_multiple_packages.txt#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage utils\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n)\n\ntype ExtraConfig struct{\n    Foo config.String\n    Bar config.Int\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration with Encore in Go\nDESCRIPTION: This code snippet defines a `Config` struct and loads configurations using the Encore framework. It includes a map for ages, keyed by strings. The configuration utilizes the framework's `config.Load` function to handle configuration data dynamically.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_maps.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n    \"time\"\n\n\t\"encore.dev/config\"\n\t\"encore.dev/types/uuid\"\n)\n\ntype Config struct {\n    Ages map[string]int\n}\n\nvar _ = config.Load[*Config]()\n```\n\n----------------------------------------\n\nTITLE: StreamOut API signature variations\nDESCRIPTION: These code snippets show different type signatures for the `api.streamOut` function, demonstrating how to define the handshake and outgoing message types with optional handshake type.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/streaming-apis.mdx#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\napi.streamOut<Handshake, Outgoing>(\n  {...}, async (handshake, stream) => {...})\n```\n\nLANGUAGE: typescript\nCODE:\n```\napi.streamOut<Outgoing>(\n  {...}, async (stream) => {...})\n```\n\n----------------------------------------\n\nTITLE: Creating Encore API for Temporal Workflow in Go\nDESCRIPTION: Implements an Encore API endpoint that triggers the Temporal Workflow and returns the greeting response.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/temporal.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage greeting\n\nimport (\n\t\"context\"\n\n\t\"encore.app/greeting/workflow\"\n\t\"encore.dev/rlog\"\n\t\"go.temporal.io/sdk/client\"\n)\n\ntype GreetResponse struct {\n    Greeting string\n}\n\n//encore:api public path=/greet/:name\nfunc (s *Service) Greet(ctx context.Context, name string) (*GreetResponse, error) {\n    options := client.StartWorkflowOptions{\n        ID:        \"greeting-workflow\",\n        TaskQueue: greetingTaskQueue,\n    }\n    we, err := s.client.ExecuteWorkflow(ctx, options, workflow.Greeting, name)\n    if err != nil {\n        return nil, err\n    }\n    rlog.Info(\"started workflow\", \"id\", we.GetID(), \"run_id\", we.GetRunID())\n\n    // Get the results\n    var greeting string\n    err = we.Get(ctx, &greeting)\n    if err != nil {\n        return nil, err\n    }\n    return &GreetResponse{Greeting: greeting}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple File Uploads with Raw Endpoint in Encore.ts\nDESCRIPTION: This raw endpoint handles multiple file uploads by using 'busboy' to parse the request. The code iterates through uploaded files and stores each file's data (converted to a Buffer) into a PostgreSQL database.  Error handling is included, and a redirect to the root page happens upon successful upload.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/how-to/file-uploads.md#2025-04-21_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nexport const saveMultiple = api.raw(\n  { expose: true, method: \"POST\", path: \"/upload-multiple\", bodyLimit: null },\n  async (req, res) => {\n    const bb = busboy({ headers: req.headers });\n    const entries: FileEntry[] = [];\n\n    bb.on(\"file\", (_, file, info) => {\n      const entry: FileEntry = { filename: info.filename, data: [] };\n\n      file\n        .on(\"data\", (data) => {\n          entry.data.push(data);\n        })\n        .on(\"close\", () => {\n          entries.push(entry);\n        })\n        .on(\"error\", (err) => {\n          bb.emit(\"error\", err);\n        });\n    });\n\n    bb.on(\"close\", async () => {\n      try {\n        for (const entry of entries) {\n          const buf = Buffer.concat(entry.data);\n          await DB.exec`\n              INSERT INTO files (name, data)\n              VALUES (${entry.filename}, ${buf})\n              ON CONFLICT (name) DO UPDATE\n                  SET data = ${buf}\n          `;\n          log.info(`File ${entry.filename} saved`);\n        }\n\n        // Redirect to the root page\n        res.writeHead(303, { Connection: \"close\", Location: \"/\" });\n        res.end();\n      } catch (err) {\n        bb.emit(\"error\", err);\n      }\n    });\n\n    bb.on(\"error\", async (err) => {\n      res.writeHead(500, { Connection: \"close\" });\n      res.end(`Error: ${(err as Error).message}`);\n    });\n\n    req.pipe(bb);\n    return;\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Authenticated Encore API Endpoint in Go\nDESCRIPTION: This snippet defines an authenticated API endpoint for Encore using the //encore:api auth directive. It takes a context as input and returns an error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_auth.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n//encore:api auth\nfunc API(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Initializing SQLDatabase and Connection String in Encore.ts\nDESCRIPTION: Shows how to set up a named database using the SQLDatabase class from Encore.ts. This example creates a database named 'siteDB' with migrations located in the './migrations' directory and demonstrates how to access the connection string.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SQLDatabase } from \"encore.dev/storage/sqldb\";\n\nconst SiteDB = new SQLDatabase(\"siteDB\", {\n  migrations: \"./migrations\",\n});\n\nconst connStr = SiteDB.connectionString;\n```\n\n----------------------------------------\n\nTITLE: Testing Pubsub Topic Publishing in Go with Encore\nDESCRIPTION: Tests the functionality of publishing messages to a pubsub Topic and verifies the published message content and Topic metadata. Uses Encore's testing package (et) to access published messages and verify Topic configuration.\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/pubsub_ref.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"testing\"\n    \"encore.dev/et\"\n    \"encore.dev/pubsub\"\n)\n\nfunc TestRefPublish(t *testing.T) {\n    ref := pubsub.TopicRef[pubsub.Publisher[Msg]](Topic)\n    ref.Publish(context.Background(), Msg{Message: \"test\"})\n\n    msgs := et.Topic(Topic).PublishedMessages()\n    if len(msgs) != 1 || msgs[0].Message != \"test\" {\n        t.Fatalf(\"got %v, want %v\", msgs, []Msg{{Message: \"test\"}})\n    }\n\n    meta := ref.Meta()\n    want := pubsub.TopicMeta{\n        Name: \"topic\",\n        Config: pubsub.TopicConfig{\n            DeliveryGuarantee: pubsub.AtLeastOnce,\n        },\n    }\n    if meta != want {\n        t.Fatalf(\"got meta %v, want %v\", meta, want)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test for Ping Endpoint in Go\nDESCRIPTION: Go code for testing the Ping endpoint with various URLs and expected outcomes.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/uptime.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage monitor\n\nimport (\n\t\"context\"\n\t\"testing\"\n)\n\nfunc TestPing(t *testing.T) {\n\tctx := context.Background()\n\ttests := []struct {\n\t\tURL string\n\t\tUp  bool\n\t}{\n\t\t{\"encore.dev\", true},\n\t\t{\"google.com\", true},\n        // Test both with and without \"https://\"\n\t\t{\"httpbin.org/status/200\", true},\n\t\t{\"https://httpbin.org/status/200\", true},\n\n        // 4xx and 5xx should considered down.\n\t\t{\"httpbin.org/status/400\", false},\n\t\t{\"https://httpbin.org/status/500\", false},\n        // Invalid URLs should be considered down.\n\t\t{\"invalid://scheme\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tresp, err := Ping(ctx, test.URL)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"url %s: unexpected error: %v\", test.URL, err)\n\t\t} else if resp.Up != test.Up {\n\t\t\tt.Errorf(\"url %s: got up=%v, want %v\", test.URL, resp.Up, test.Up)\n\t\t}\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Cron Job in Go with Encore\nDESCRIPTION: Defines a cron job that runs on the 5th minute of every hour with a specific title and endpoint. Demonstrates package-level cron job declaration.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cron_job_definition_init.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nvar _ = cron.NewJob(\"cronfoo\", cron.JobConfig{\n    Title:    \"Cron Foo Bar\",\n    Schedule: \"* * * * 5\",\n    Endpoint: Cron,\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing PubSub Message Handler with Anonymous Function\nDESCRIPTION: Configures a PubSub subscription with an anonymous handler function and custom retry policy. Includes a function to publish messages to the topic.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nvar _ = pubsub.NewSubscription(\n    shared.BasicTopic,\n    \"a-third-subscription\",\n    pubsub.SubscriptionConfig {\n        Handler: func(ctx context.Context, msg *shared.MessageType) error {\n          return nil\n      },\n      AckDeadline: 1 * time.Second,\n      MessageRetention: 2 * time.Minute + -1 * time.Microsecond,\n      RetryPolicy: &pubsub.RetryPolicy{\n          MaxRetries: -3 + 10 * 5,\n          MinBackoff: 4 * time.Hour + -2 * time.Microsecond,\n          MaxBackoff: 5 * time.Hour + -3 * time.Microsecond,\n      },\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Using Bucket References in Go\nDESCRIPTION: Demonstrates how to create bucket references with specific permission interfaces for static analysis compatibility\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/object-storage.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nref := objects.BucketRef[objects.Downloader](ProfilePictures)\n\n// Combining multiple permissions\ntype myPerms interface {\n  objects.Downloader\n  objects.Uploader\n}\nref := objects.BucketRef[myPerms](ProfilePictures)\n```\n\n----------------------------------------\n\nTITLE: CORS Configuration in encore.app\nDESCRIPTION: This CUE code snippet shows the structure of the `global_cors` configuration in the `encore.app` file. It allows you to configure debug logging, allowed headers, exposed headers, and allowed origins for requests with and without credentials, enabling fine-grained control over CORS behavior.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/cors.md#2025-04-21_snippet_0\n\nLANGUAGE: cue\nCODE:\n```\n{\n    // debug enables CORS debug logging.\n    \"debug\": true | false,\n\n    // allow_headers allows an app to specify additional headers that should be\n    // accepted by the app.\n    //\n    // If the list contains \"*\", then all headers are allowed.\n    \"allow_headers\": [...string],\n\n    // expose_headers allows an app to specify additional headers that should be\n    // exposed from the app, beyond the default set always recognized by Encore.\n    //\n    // If the list contains \"*\", then all headers are exposed.\n    \"expose_headers\": [...string],\n\n    // allow_origins_without_credentials specifies the allowed origins for requests\n    // that don't include credentials. If nil it defaults to allowing all domains\n    // (equivalent to [\"*\"]).\n    \"allow_origins_without_credentials\": [...string],\n\n    // allow_origins_with_credentials specifies the allowed origins for requests\n    // that include credentials. If a request is made from an Origin in this list\n    // Encore responds with Access-Control-Allow-Origin: <Origin>.\n    //\n    // The URLs in this list may include wildcards (e.g. \"https://*.example.com\"\n    // or \"https://*-myapp.example.com\").\n    \"allow_origins_with_credentials\": [...string],\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Encore Service with Service Class\nDESCRIPTION: Creates a service definition using the Service class from Encore.ts. This is required in each service directory to define the service boundaries and name within the application.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Service } from \"encore.dev/service\";\nexport default new Service(\"my-service\");\n```\n\n----------------------------------------\n\nTITLE: Running Encore Application and Accessing Local Development Dashboard\nDESCRIPTION: This command starts an Encore application locally and provides URLs for the API and Development Dashboard. The dashboard opens automatically and can also be accessed via the provided link.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/observability/dev-dash.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ encore run\nAPI Base URL:      http://localhost:4000\nDev Dashboard URL: http://localhost:9400/hello-world-cgu2\n```\n\n----------------------------------------\n\nTITLE: Initializing Named SQL Database Resource in Encore\nDESCRIPTION: Defines a named database resource 'Moo' using Encore's sqldb package, enabling database connectivity and management\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_helper.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nvar Moo = sqldb.Named(\"svc\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Encore Authentication Handler in Go\nDESCRIPTION: This code defines an authentication handler function for Encore applications using the encore:authhandler directive. The MyAuth function accepts a context and token parameter, returning a user ID, custom data, and error. The MyData struct is used to pass additional authentication information.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/auth_handler_data.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"encore.dev/beta/auth\"\n)\n\ntype MyData struct {\n    Name string\n}\n\n//encore:authhandler\nfunc MyAuth(ctx context.Context, token string) (auth.UID, *MyData, error) { return \"\", nil, nil }\n```\n\n----------------------------------------\n\nTITLE: Connecting to Encore Database via Shell\nDESCRIPTION: Connects to the specified Encore database using a psql shell, with options for different environments and permission levels.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\n$ encore db shell <database-name> [--env=<name>]\n```\n\n----------------------------------------\n\nTITLE: Directory Structure with Sub-packages in Encore\nDESCRIPTION: Shows the folder structure for an Encore application that uses sub-packages within services. The hello service contains a sub-package called foo that provides helper functions.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/app-structure.md#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n/my-app\n encore.app                       // ... and other top-level project files\n\n hello                            // hello service (a Go package)\n    migrations                   // hello service db migrations (directory)\n       1_create_table.up.sql    // hello service db migration\n    foo                          // sub-package foo (directory)\n       foo.go                   // foo code (cannot define APIs)\n    hello.go                     // hello service code\n    hello_test.go                // tests for hello service\n\n world                            // world service (a Go package)\n     world.go                     // world service code\n```\n\n----------------------------------------\n\nTITLE: Defining a Secret in Encore\nDESCRIPTION: This code snippet demonstrates how to define a secret in Encore using the `secret` function. Secrets are used for securely storing sensitive information like API keys. This creates a secret named `GitHubAPIToken`.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { secret } from \"encore.dev/config\";\n\nconst githubToken = secret(\"GitHubAPIToken\");\n```\n\n----------------------------------------\n\nTITLE: Defining REST API Endpoints in Encore (Go)\nDESCRIPTION: This code demonstrates creating a REST API endpoint using Encore. It describes how to define path variables in the endpoint URL and access them as function parameters, ensuring type compatibility for successful request processing.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/defining-apis.md#2025-04-21_snippet_11\n\nLANGUAGE: Go\nCODE:\n```\n// GetBlogPost retrieves a blog post by id.\n//encore:api public method=GET path=/blog/:id\nfunc GetBlogPost(ctx context.Context, id int) (*BlogPost, error) {\n    // Use id to query database...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining API Request Parameters in Go with Encore\nDESCRIPTION: This snippet defines structs for API request parameters, including a nested struct and a main Params struct with tags. It demonstrates the use of UUID and custom types in API parameters.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_invalid_header_type.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\ntype Nested struct {\n    Baz string\n}\n\ntype Params struct {\n    Foo uuid.UUID\n    Bar *Nested `header:\"X-Bar\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Defining API endpoint in Go\nDESCRIPTION: This snippet defines an API endpoint named `MyAPI` using the `//encore:api` annotation. The function takes a `context.Context` as input and returns an error.  Currently, it simply returns `nil`.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/types_from_multiple_packages.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Public API Endpoint in Go using Encore\nDESCRIPTION: This snippet defines a public API endpoint 'CallFoo' in the 'bar' package using Encore's API annotation. It imports and calls the Log function from the 'foo' package, demonstrating how to create a public API that utilizes functionality from another package.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rlog_call_outside_svc.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage bar\n\nimport (\n    \"context\"\n\n    \"test/foo\"\n)\n\n//encore:api public\nfunc CallFoo(ctx context.Context) error {\n    foo.Log()\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Raw Endpoint with Encore.ts\nDESCRIPTION: This code snippet demonstrates how to define a raw API endpoint using Encore.ts's `api.raw` function. It takes an options object specifying the endpoint's path, method, and exposure, along with an asynchronous function that receives the request and response objects. The function sets the response headers and writes a simple text message to the response.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/raw-endpoints.mdx#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\n\nexport const myRawEndpoint = api.raw(\n  { expose: true, path: \"/raw\", method: \"GET\" },\n  async (req, resp) => {\n    resp.writeHead(200, { \"Content-Type\": \"text/plain\" });\n    resp.end(\"Hello, raw world!\");\n  },\n);\n\n```\n\n----------------------------------------\n\nTITLE: Defining Private API with Dependency Injection in Encore\nDESCRIPTION: Shows how to define a private API endpoint as a method on a service struct. This pattern leverages the injected dependencies from the service initialization.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_43\n\nLANGUAGE: go\nCODE:\n```\n//encore:api private\nfunc (s *Service) Send(ctx context.Context, p *SendParams) error {\n    // Use s.sendgridClient to send emails\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Configuration Struct in Go\nDESCRIPTION: This snippet defines a configuration struct 'Config' which contains a 'SomeTime' field of type 'time.Time'. It also includes a line that loads this configuration type using Encore's config loading features.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_with_cue_imports.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n    \"time\"\n\n\t\"encore.dev/config\"\n)\n\ntype Config struct {\n    SomeTime time.Time\n}\n\nvar _ = config.Load[*Config]()\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS SNS/SQS in Encore\nDESCRIPTION: This snippet shows the configuration for AWS Simple Notification Service (SNS) and Simple Queue Service (SQS) in an Encore application. It defines a topic 'user-notifications' with a subscription to an SQS queue 'user-queue'.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"pubsub\": [\n    {\n      \"type\": \"aws_sns_sqs\",\n      \"topics\": {\n        \"user-notifications\": {\n          \"arn\": \"arn:aws:sns:us-east-1:123456789012:user-notifications\",\n          \"subscriptions\": {\n            \"user-queue\": {\n              \"arn\": \"arn:aws:sqs:us-east-1:123456789012:user-queue\"\n            }\n          }\n        }\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Booking Table Schema - SQL\nDESCRIPTION: This SQL snippet creates the 'booking' table schema required for storing appointment bookings in the database. It defines fields for the booking ID, start time, end time, email, and creation timestamp.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\n-- booking/db/migrations/1_create_tables.up.sql --\nCREATE TABLE booking (\n    id BIGSERIAL PRIMARY KEY,\n    start_time TIMESTAMP NOT NULL,\n    end_time TIMESTAMP NOT NULL,\n    email TEXT NOT NULL,\n    created_at TIMESTAMP NOT NULL DEFAULT NOW()\n);\n\n```\n\n----------------------------------------\n\nTITLE: User Authentication Handler - Go\nDESCRIPTION: This Go code defines a simple authentication handler for the user service in the booking system. It validates incoming authorization data and can be extended for real authentication logic.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_10\n\nLANGUAGE: go\nCODE:\n```\n-- user/auth.go --\n// Service user authenticates users.\npackage user\n\nimport (\n\t\"context\"\n\t\"encore.dev/beta/auth\"\n\t\"encore.dev/beta/errs\"\n)\n\ntype Data struct {\n\tEmail string\n}\n\ntype AuthParams struct {\n\tAuthorization string `header:\"Authorization\"`\n}\n\n//encore:authhandler\nfunc AuthHandler(ctx context.Context, p *AuthParams) (auth.UID, *Data, error) {\n\tif p.Authorization != \"\" {\n\t\treturn \"test\", &Data{}, nil\n\t}\n\treturn \"\", nil, errs.B().Code(errs.Unauthenticated).Msg(\"no auth header\").Err()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Listing Objects in a Bucket with Go\nDESCRIPTION: Demonstrates how to list objects in a bucket using an iterator with optional query filtering\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/object-storage.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfor err, entry := range ProfilePictures.List(ctx, &objects.Query{}) {\n\tif err != nil {\n\t\t// Handle error\n\t}\n\t// Do something with entry\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Site Check Functionality in Go\nDESCRIPTION: Defines two functions for checking website availability - a public API endpoint for checking a single site and a helper function for performing the actual check and storing results in the database.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/uptime.md#2025-04-21_snippet_11\n\nLANGUAGE: go\nCODE:\n```\n// Check checks a single site.\n//\n//encore:api public method=POST path=/check/:siteID\nfunc Check(ctx context.Context, siteID int) error {\n\tsite, err := site.Get(ctx, siteID)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn check(ctx, site)\n}\n\nfunc check(ctx context.Context, site *site.Site) error {\n\tresult, err := Ping(ctx, site.URL)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = db.Exec(ctx, `\n\t\tINSERT INTO checks (site_id, up, checked_at)\n\t\tVALUES ($1, $2, NOW())\n\t`, site.ID, result.Up)\n\treturn err\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Object Attributes in TypeScript\nDESCRIPTION: This snippet retrieves metadata about a stored object using Encore's `attrs` method, allowing access to properties like size, content type, and ETag. It supports management decisions by providing detailed object insights and includes error detection for non-existent files through the `exists` method, fostering comprehensive storage operations.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/object-storage.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst attrs = await profilePictures.attrs(\"my-image.jpeg\");\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst exists = await profilePictures.exists(\"my-image.jpeg\");\n```\n\n----------------------------------------\n\nTITLE: Defining API Parameters and Endpoint Using Encore in Go\nDESCRIPTION: Defines a parameter structure and a basic API endpoint for the Encore framework in Go. The `Params` struct specifies query parameters, while the `Foo` function is a public API endpoint. This requires the Encore framework as a dependency. Inputs include a context and a Params struct, and it returns an error if something goes wrong.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/request_query.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage code\n\nimport \"context\"\n\ntype Params struct {\n    Foo   string `query:\"foo\"`\n    Ignore string `query:\"-\"`\n    Ints []int `query:\"ints\"`\n}\n\n//encore:api public\nfunc Foo(ctx context.Context, p *Params) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Defining API endpoints with UUID parameters in Encore\nDESCRIPTION: This code defines an Encore API endpoint `/uuid/:p` that accepts a UUID parameter `p`. The `encore:api public path=/uuid/:p` annotation exposes the function as a public HTTP endpoint. The function `UUID` takes a context and the UUID parameter as input and returns an error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_path_params.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\t\"encore.dev/types/uuid\"\n)\n\n//encore:api public path=/uuid/:p\nfunc UUID(ctx context.Context, p uuid.UUID) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: SQL Migration Script for Creating Files Table\nDESCRIPTION: This SQL script creates a table named 'files' in the PostgreSQL database with two columns: 'name' (TEXT, PRIMARY KEY) to store the file name and 'data' (BYTEA, NOT NULL) to store the file data as a byte array.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/how-to/file-uploads.md#2025-04-21_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE files (\n    name TEXT PRIMARY KEY,\n    data BYTEA NOT NULL\n);\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration for AsConfig in Encore (Go)\nDESCRIPTION: This snippet defines the AsConfig structure and loads its configuration using the Encore framework. The structure includes a field 'Foo' of type config.String. The approach ensures configuration loading complies with the specific requirements of the Encore application.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/merge_identical_comments.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n\t\"encore.dev/types/uuid\"\n)\n\ntype AsConfig struct {\n    // Multiline test\n    // comment to deduplicate.\n    Foo config.String\n}\n\nvar _ = config.Load[*AsConfig]()\n\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing SQL Database Table in Encore\nDESCRIPTION: SQL schema for creating a todo item table with primary key, title, and completion status\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE todo_item (\n    id BIGSERIAL PRIMARY KEY,\n    title TEXT NOT NULL,\n    done BOOLEAN NOT NULL DEFAULT FALSE\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing Site Service with GORM and Dependency Injection\nDESCRIPTION: Go service initialization using Encore's dependency injection and GORM for database interaction with PostgreSQL driver\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/uptime.md#2025-04-21_snippet_7\n\nLANGUAGE: go\nCODE:\n```\npackage site\n\nimport (\n\t\"encore.dev/storage/sqldb\"\n\t\"gorm.io/driver/postgres\"\n\t\"gorm.io/gorm\"\n)\n\n//encore:service\ntype Service struct {\n\tdb *gorm.DB\n}\n\nvar db = sqldb.NewDatabase(\"site\", sqldb.DatabaseConfig{\n\tMigrations: \"./migrations\",\n})\n\nfunc initService() (*Service, error) {\n\tdb, err := gorm.Open(postgres.New(postgres.Config{\n\t\tConn: db.Stdlib(),\n\t}))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Service{db: db}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Slack Notification Function in TypeScript\nDESCRIPTION: This code snippet implements a function to send Slack notifications via an incoming webhook using the Encore API. It requires the 'api', 'config', and 'log' modules from Encore. It takes a 'text' parameter to be sent as a notification and handles potential errors during the HTTP POST request.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_25\n\nLANGUAGE: ts\nCODE:\n```\nimport { api } from \"encore.dev/api\";\nimport { secret } from \"encore.dev/config\";\nimport log from \"encore.dev/log\";\n\nexport interface NotifyParams {\n  text: string; // the slack message to send\n}\n\nexport const notify = api<NotifyParams>({}, async ({ text }) => {\n  const url = webhookURL();\n  if (!url) {\n    log.info(\"no slack webhook url defined, skipping slack notification\");\n    return;\n  }\n\n  const resp = await fetch(url, {\n    method: \"POST\",\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({ content: text }),\n  });\n  if (resp.status >= 400) {\n    const body = await resp.text();\n    throw new Error(`slack notification failed: ${resp.status}: ${body}`);\n  }\n});\n\nconst webhookURL = secret(\"SlackWebhookURL\");\n```\n\n----------------------------------------\n\nTITLE: Define an Encore.ts Service\nDESCRIPTION: This code snippet demonstrates the creation of a basic service in Encore.ts. It imports the `Service` class from the Encore library and exports a new service instance.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/migration/express-migration.md#2025-04-21_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport {Service} from \"encore.dev/service\";\n\nexport default new Service(\"my-service\");\n```\n\n----------------------------------------\n\nTITLE: Creating User Table in PostgreSQL\nDESCRIPTION: SQL script to create a 'users' table with fields for user ID, first and last names, and their Slack handle. This migration script is used to define the schema for storing user information in the Incident Management Tool.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/incident-management-tool.md#2025-04-21_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE users (\n    id           BIGSERIAL PRIMARY KEY,\n    first_name   VARCHAR(255) NOT NULL,\n    last_name    VARCHAR(255) NOT NULL,\n    slack_handle VARCHAR(255) NOT NULL\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Database Schema with PostgreSQL\nDESCRIPTION: This SQL snippet creates a PostgreSQL database table called 'url' with 'id' as the primary key and 'original_url' as a required field. This schema is necessary to store URL mappings for the URL shortener.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/rest-api.mdx#2025-04-21_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\n-- url/migrations/1_create_tables.up.sql --\nCREATE TABLE url (\n\tid TEXT PRIMARY KEY,\n\toriginal_url TEXT NOT NULL\n);\n```\n\n----------------------------------------\n\nTITLE: Encore Configuration Unmarshaling Implementation in Golang\nDESCRIPTION: Implements configuration unmarshaling functions generated by Encore for the 'svc' package. These functions use the jsoniter library to convert JSON data into configuration structures for dynamic management, ensuring compatibility with Encore's config.Load method.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/name_conflicts.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t__etype \"encore.dev/appruntime/shared/etype\"\n\tconfig \"encore.dev/config\"\n\thelpers \"example.com/svc/helpers\"\n\tutils \"example.com/svc/utils\"\n\t\"fmt\"\n\tjsoniter \"github.com/json-iterator/go\"\n)\n\n/*\nThese functions are automatically generated and maintained by Encore to allow config values\nto be unmarshalled into the correct types. They are not intended to be used directly. They\nare automatically updated by Encore whenever you change the data types used within your\ncalls to config.Load[T]().\n*/\n\n// Concrete unmarshalers for all config.Load calls, including those using generic types.\n// These instances are used directly by calls to `config.Load[T]()`.\nvar (\n\tencoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {\n\t\treturn func() *Config {\n\t\t\t// If the value is null, we return nil\n\t\t\tif itr.ReadNil() {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Otherwise we unmarshal the value and return a pointer to it\n\t\t\tobj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))\n\t\t\treturn &obj\n\t\t}()\n\t}\n)\n\n// encoreInternalTypeConfigUnmarshaler_svc_Config will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"A\":\n\t\t\tobj.A = encoreInternalTypeConfigUnmarshaler_helpers_ExtraConfig(itr, append(path, \"A\"))\n\t\tcase \"B\":\n\t\t\tobj.B = encoreInternalTypeConfigUnmarshaler_utils_ExtraConfig(itr, append(path, \"B\"))\n\t\tcase \"C\":\n\t\t\tobj.C = encoreInternalTypeConfigUnmarshaler_helpers_ExtraConfig(itr, append(path, \"C\"))\n\t\tcase \"D\":\n\t\t\tobj.D = encoreInternalTypeConfigUnmarshaler_utils_ExtraConfig(itr, append(path, \"D\"))\n\t\tcase \"E\":\n\t\t\tobj.E = encoreInternalTypeConfigUnmarshaler_helpers_SingleUse(itr, append(path, \"E\"))\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n\n// encoreInternalTypeConfigUnmarshaler_helpers_ExtraConfig will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_helpers_ExtraConfig(itr *jsoniter.Iterator, path []string) (obj helpers.ExtraConfig) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"Foo\":\n\t\t\tobj.Foo = config.CreateValue[string](itr.ReadString(), append(path, \"Foo\"))\n\t\tcase \"Baz\":\n\t\t\tobj.Baz = config.CreateValue[[]byte](func() (rtn []byte) {\n\t\t\t\tdecoder := new(__etype.Unmarshaller)\n\t\t\t\trtn = __etype.UnmarshalOne(decoder, __etype.UnmarshalBytes, \"value\", itr.ReadString(), true)\n\t\t\t\tif err := decoder.Error; err != nil {\n\t\t\t\t\tpanic(fmt.Sprintf(\"unable to decode the config: %v\", err))\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}(), append(path, \"Baz\"))\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n\n// encoreInternalTypeConfigUnmarshaler_helpers_SingleUse will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_helpers_SingleUse(itr *jsoniter.Iterator, path []string) (obj helpers.SingleUse) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"Lock\":\n\t\t\tobj.Lock = itr.ReadBool()\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n\n// encoreInternalTypeConfigUnmarshaler_utils_ExtraConfig will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_utils_ExtraConfig(itr *jsoniter.Iterator, path []string) (obj utils.ExtraConfig) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"Foo\":\n\t\t\tobj.Foo = config.CreateValue[string](itr.ReadString(), append(path, \"Foo\"))\n\t\tcase \"Bar\":\n\t\t\tobj.Bar = config.CreateValue[int](itr.ReadInt(), append(path, \"Bar\"))\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining API Function in Encore Service (Go)\nDESCRIPTION: This snippet defines an API function for an Encore service, which currently does not implement any logic but sets up the function structure. It accepts a context parameter which is standard for managing request scope in Go applications.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_legacy_syntax.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// encore:api\nfunc API(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Generating API Endpoint for Foo Method in Go\nDESCRIPTION: This generated code snippet provides a wrapper for the 'Foo' method of the Encore service for easier external calling. It error checks service retrieval and ensures that the service method is invoked properly.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/service_struct.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n-- want:encore.gen.go --\n// Code generated by encore. DO NOT EDIT.\n\npackage basic\n\nimport \"context\"\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\n\nfunc Foo(ctx context.Context) error {\n\tsvc, err := EncoreInternal_svcstruct_Service.Get()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn svc.Foo(ctx)\n}\n\n// Interface defines the service's API surface area, primarily for mocking purposes.\n//\n// Raw endpoints are currently excluded from this interface, as Encore does not yet\n// support service-to-service API calls to raw endpoints.\ntype Interface interface {\n\tFoo(ctx context.Context) error\n}\n```\n\n----------------------------------------\n\nTITLE: Building Docker Images with Encore CLI\nDESCRIPTION: This snippet showcases how to use the `encore build docker` command to build Docker images for specified services and gateways while allowing customization of the base image. The command accepts options to specify services, gateways, and base images, with the default Docker image running on port 8080, which can be altered using the PORT environment variable.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/ci-cd.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Build specific services and gateways\nencore build docker --services=service1,service2 --gateways=api-gateway MY-IMAGE:TAG\n\n# Customize the base image\nencore build docker --base=node:18-alpine MY-IMAGE:TAG\n\ndocker run -e PORT=8081 -p 8081:8081 MY-IMAGE:TAG\n```\n\n----------------------------------------\n\nTITLE: Checking Encore Application for Errors\nDESCRIPTION: Checks the Encore application for compile-time errors using Encore's compiler.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ encore check\n```\n\n----------------------------------------\n\nTITLE: Defining Interface for Mockable Dependencies\nDESCRIPTION: Shows how to define an interface for the SendGrid client to enable mocking in tests. Demonstrates restructuring the service to use an interface instead of a concrete type.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/dependency-injection.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype sendgridClient interface {\n\tSendEmail(...) // a hypothetical signature, for illustration purposes\n}\n\n//encore:service\ntype Service struct {\n    sendgridClient sendgridClient\n}\n```\n\n----------------------------------------\n\nTITLE: Authentication Service Implementation in Go\nDESCRIPTION: Core authentication service implementation including user data retrieval endpoint and authentication handler\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/et_override_user_authdata.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype Response struct {\n    UserID auth.UID\n    Data *AuthData\n}\n\n//encore:api public\nfunc GetUser(ctx context.Context) (*Response, error) {\n    uid, _ := auth.UserID()\n    data, _ := auth.Data().(*AuthData)\n    return &Response{UserID: uid, Data: data}, nil\n}\n\ntype AuthData struct {\n    Email string\n}\n\n//encore:authhandler\nfunc AuthHandler(ctx context.Context, token string) (auth.UID, *AuthData, error) {\n    return \"hello\", &AuthData{Email: \"hello@example.org\"}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Encore Client with TanStack Query\nDESCRIPTION: Example of using an Encore request client together with TanStack Query for efficient state management, including querying and mutating data with automatic refetching.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/integrate-frontend.mdx#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  useQuery,\n  useMutation,\n  useQueryClient,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\nimport Client, { todo } from '../encore-client'\n\n// Create a Encore client\nconst encoreClient = new Client(window.location.origin);\n\n// Create a react-query client\nconst queryClient = new QueryClient()\n\nfunction App() {\n  return (\n    // Provide the client to your App\n    <QueryClientProvider client={queryClient}>\n      <Todos />\n    </QueryClientProvider>\n  )\n}\n\nfunction Todos() {\n  // Access the client\n  const queryClient = useQueryClient()\n\n  // Queries\n  const query = useQuery({\n    queryKey: ['todos'],\n    queryFn: () => encoreClient.todo.List()\n  })\n\n  // Mutations\n  const mutation = useMutation({\n    mutationFn: (params: todo.AddParams) => encoreClient.todo.Add(params),\n    onSuccess: () => {\n      // Invalidate and refetch\n      queryClient.invalidateQueries({ queryKey: ['todos'] })\n    },\n  })\n\n  return (\n    <div>\n      <ul>\n        {query.data?.map((todo) => (\n          <li key={todo.id}>{todo.title}</li>\n        ))}\n      </ul>\n\n      <button\n        onClick={() => {\n          mutation.mutate({\n            id: Date.now(),\n            title: 'Do Laundry',\n          })\n        }}\n      >\n        Add Todo\n      </button>\n    </div>\n  )\n}\n\nrender(<App />, document.getElementById('root'))\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Encore CLI\nDESCRIPTION: Command for running tests in an Encore application, supporting standard Go test flags and directory scoping\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/testing.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nencore test ./...\n```\n\nLANGUAGE: bash\nCODE:\n```\nencore test\n```\n\n----------------------------------------\n\nTITLE: Computing Bookable Slots in Go\nDESCRIPTION: This code snippet computes available bookable slots for a given day by incrementing start times until the end of availability is reached. It relies on the Go programming language and utilizes date and time libraries to achieve this.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_19\n\nLANGUAGE: go\nCODE:\n```\n\tavailEnd := date.Add(time.Duration(availEndTime.Microseconds) * time.Microsecond)\n\n\t// Compute the bookable slots in this day, based on availability.\n\tvar slots []BookableSlot\n\tstart := availStart\n\tfor {\n\t\tend := start.Add(DefaultBookingDuration)\n\t\tif end.After(availEnd) {\n\t\t\tbreak\n\t\t}\n\t\tslots = append(slots, BookableSlot{\n\t\t\tStart: start,\n\t\t\tEnd:   end,\n\t\t})\n\t\tstart = end\n\t}\n\n\treturn slots, nil\n```\n\n----------------------------------------\n\nTITLE: Loading Config with Unmarshaler in Go\nDESCRIPTION: This snippet defines the `Config` struct and `ServerOptions` struct, which are used to configure the service. It also shows how to load the configuration using `config.Load[*Config]()` and uses an unmarshaler.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_named_struct_single_use.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n)\n\ntype ServerOptions struct {\n    Enabled bool // Is this option enabled?\n    Port    uint32 // What port should we run on?\n}\n\ntype Config struct {\n    HTTP ServerOptions // The options for the HTTP server\n}\n\nvar _ = config.Load[*Config](\"svc\", encoreInternalConfigUnmarshaler_ptr_svc_Config/*line :18:30*/)\n\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Client-side Usage of Encore Streaming APIs\nDESCRIPTION: This code snippet shows how a client can interact with Encore streaming API endpoints. It obtains a stream object and then sends and receives messages over the stream.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nconst stream = client.serviceName.endpointName();\nawait stream.send({ /* message */ });\nfor await (const msg of stream) {\n  // Handle incoming messages\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Encore Service in Go\nDESCRIPTION: Defines a basic Encore service API with a Foo function that takes a context and returns an error. This snippet is designed for use within the Encore framework and requires the 'context' package for operation. The function currently implements a stub that returns nil.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_outside_svc_test.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport \"context\"\n\n//encore:api\nfunc Foo(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Configuring Client Generation in package.json\nDESCRIPTION: Example of adding a script to generate an API client for a TypeScript frontend project, targeting the staging environment.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/client-generation.md#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"gen\": \"encore gen client hello-a8bc --output=./client.ts --env=staging\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SQL Queries for Availability Management\nDESCRIPTION: SQL queries for retrieving all availability records ordered by weekday and for inserting or updating availability records using ON CONFLICT to handle existing entries.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_12\n\nLANGUAGE: sql\nCODE:\n```\n-- booking/db/query.sql --\n-- name: GetAvailability :many\nSELECT * FROM availability\nORDER BY weekday;\n\n-- name: UpdateAvailability :exec\nINSERT INTO availability (weekday, start_time, end_time)\nVALUES (@weekday, @start_time, @end_time)\nON CONFLICT (weekday) DO UPDATE\nSET start_time = @start_time, end_time = @end_time;\n```\n\n----------------------------------------\n\nTITLE: Defining Simple API Endpoint\nDESCRIPTION: Sample API method with context support, marked for Encore API registration\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_named_struct_single_use.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StreamIn API Endpoint with Encore\nDESCRIPTION: This code defines a `streamIn` API endpoint using Encore.  It receives a stream of messages from the client, processes the data, and breaks when a `done` signal is received. This is a server-side implementation.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\n\ninterface Message {\n  data: string;\n  done: boolean;\n}\n\nexport const uploadStream = api.streamIn<Message>(\n  { path: \"/upload\", expose: true },\n  async (stream) => {\n    for await (const data of stream) {\n      // Process incoming data\n      if (data.done) break;\n    }\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Serving Static Frontend Assets with Encore\nDESCRIPTION: Example of creating a raw endpoint in Encore to serve static frontend assets for development purposes, using Go's embed package to include compiled frontend assets.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/integrate-frontend.mdx#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\npackage frontend\n\nimport (\n\t\"embed\"\n\t\"io/fs\"\n\t\"net/http\"\n)\n\nvar (\n\t//go:embed dist\n\tdist embed.FS\n\n\tassets, _ = fs.Sub(dist, \"dist\")\n\thandler   = http.StripPrefix(\"/frontend/\", http.FileServer(http.FS(assets)))\n)\n\n //encore:api public raw path=/frontend/*path\n func Serve(w http.ResponseWriter, req *http.Request) {\n\t handler.ServeHTTP(w, req)\n }\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS S3 in Encore\nDESCRIPTION: This snippet shows the configuration for Amazon S3 in an Encore application. It defines a bucket 'my-s3-bucket' in the 'us-east-1' region, with optional key prefix and public base URL.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_18\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"object_storage\": [\n    {\n      \"type\": \"s3\",\n      \"region\": \"us-east-1\",\n      \"buckets\": {\n        \"my-s3-bucket\": {\n          \"name\": \"my-s3-bucket\",\n          \"key_prefix\": \"my-optional-prefix/\",\n          \"public_base_url\": \"https://my-gcs-bucket-cdn.example.com/my-optional-prefix\"\n        }\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Registering API Endpoint with Encore in Go\nDESCRIPTION: This snippet handles the registration of the 'Foo' API endpoint using Encore. It defines request and response types, and implements multiple functions for encoding/decoding requests and responses, handling middleware, and setting endpoint properties. It integrates with third-party packages for JSON processing and URL manipulation.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/fallback_path.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\npackage code\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\t__etype \"encore.dev/appruntime/shared/etype\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n}\n\ntype EncoreInternal_FooReq struct {\n\tP0 string\n}\n\ntype EncoreInternal_FooResp = __api.Void\n\nvar EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{\n\tAccess: __api.Public,\n\tAppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {\n\t\terr := Foo(ctx, reqData.P0)\n\t\tif err != nil {\n\t\t\treturn __api.Void{}, err\n\t\t}\n\t\treturn __api.Void{}, nil\n\t},\n\tCloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {\n\t\tvar clone *EncoreInternal_FooReq\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tCloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {\n\t\tvar clone EncoreInternal_FooResp\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tDecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {\n\t\treturn __api.Void{}, nil\n\t},\n\tDecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {\n\t\treqData = new(EncoreInternal_FooReq)\n\t\tdec = new(__etype.Unmarshaller)\n\t\t// Trim the leading slash from wildcard parameter, as Encore's semantics excludes it,\n\t\t// while the httprouter implementation includes it.\n\t\tps[0] = strings.TrimPrefix(ps[0], \"/\")\n\n\t\tif value, err := url.PathUnescape(ps[0]); err == nil {\n\t\t\tps[0] = value\n\t\t}\n\t\treqData.P0 = __etype.UnmarshalOne(dec, __etype.UnmarshalString, \"fallback\", ps[0], true)\n\t\tif err := dec.Error; err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\treturn reqData, ps, nil\n\t},\n\tDefLoc: uint32(0x0),\n\tEncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {\n\t\treturn nil, nil, nil\n\t},\n\tEncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {\n\t\treturn nil\n\t},\n\tEndpoint:            \"Foo\",\n\tFallback:            true,\n\tGlobalMiddlewareIDs: []string{},\n\tMethods:             []string{\"GET\", \"POST\"},\n\tPath:                \"/!fallback\",\n\tPathParamNames:      []string{\"fallback\"},\n\tRaw:                 false,\n\tRawHandler:          nil,\n\tRawPath:             \"/*0\",\n\tReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {\n\t\tparams = __api.UnnamedParams{__etype.MarshalOne(__etype.MarshalString, reqData.P0)}\n\t\treturn \"/\" + url.PathEscape(params[0]), params, nil\n\t},\n\tReqUserPayload: func(reqData *EncoreInternal_FooReq) any {\n\t\treturn nil\n\t},\n\tService:           \"code\",\n\tServiceMiddleware: []*__api.Middleware{},\n\tSvcNum:            1,\n\tTags:              nil,\n}\n\n```\n\n----------------------------------------\n\nTITLE: Database Initialization and Usage in Go\nDESCRIPTION: This code snippet shows how to initialize a named SQL database using `encore.dev/storage/sqldb` and access its fields and methods. It demonstrates how to declare a database connection and use it within a Go service.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/parser/resource/usage/testdata/sqldb_usage.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n\"package svc\\n\\nimport \\\"context\\\"\\nimport \\\"encore.dev/storage/sqldb\\\"\\n\\nvar DB = sqldb.Named(\\\"svc\\\")\\n\\nfunc init() {\\n    DB.Foo() // use svc.DB call Foo\\n    DB.Foo // use svc.DB field Foo\\n    DB // use svc.DB other\\n\\n    1 + DB // use svc.DB other\\n    x = DB // use svc.DB other\\n}\\n\\n//encore:api public\\nfunc Dummy(context.Context) error { return nil }\"\n```\n\n----------------------------------------\n\nTITLE: Serving Static Files with Encore.js\nDESCRIPTION: This snippet demonstrates how to serve static files using the api.static function from the Encore.js framework. The files located in the './assets' directory will be exposed under the path '/frontend/*path'. This functionality is essential for serving assets in web applications.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\nexport const assets = api.static(\n  { expose: true, path: \"/frontend/*path\", dir: \"./assets\" },\n);\n\n```\n\n----------------------------------------\n\nTITLE: Integrating Slack Webhooks in Go\nDESCRIPTION: This Go code snippet implements a service in the 'slack' package that posts notifications to Slack through a webhook. It uses native HTTP and JSON libraries and requires setting the 'SlackWebhookURL' as a secret via the Encore CLI. The Notify function is a private API endpoint that takes context and notification text as parameters, sending a POST request to Slack.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/incident-management-tool.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// Service slack calls a webhook to post notifications to Slack.\npackage slack\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"encore.dev/beta/errs\"\n\t\"io\"\n\t\"net/http\"\n)\n\ntype NotifyParams struct {\n\tText string `json:\"text\"`\n}\n\n//encore:api private\nfunc Notify(ctx context.Context, p *NotifyParams) error {\n\teb := errs.B()\n\treqBody, err := json.Marshal(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq, err := http.NewRequestWithContext(ctx, \"POST\", secrets.SlackWebhookURL, bytes.NewReader(reqBody))\n\tif err != nil {\n\t\treturn err\n\t}\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode >= 400 {\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\treturn eb.Code(errs.Unavailable).Msgf(\"notify slack: %s: %s\", resp.Status, body).Err()\n\t}\n\treturn nil\n}\n\nvar secrets struct {\n\tSlackWebhookURL string\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Authentication Handler Structure in Go\nDESCRIPTION: Initial skeleton code for the authentication handler in Go, including the Data struct and ValidateToken function declaration.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/firebase-auth.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage user\n\nimport (\n\t\"context\"\n\t\"strings\"\n\n\t\"encore.dev/beta/auth\"\n\tfirebase \"firebase.google.com/go/v4\"\n\tfbauth \"firebase.google.com/go/v4/auth\"\n\t\"go4.org/syncutil\"\n\t\"google.golang.org/api/option\"\n)\n\n// Data represents the user's data stored in Firebase Auth.\ntype Data struct {\n\t// Email is the user's email.\n\tEmail string\n\t// Name is the user's name.\n\tName string\n\t// Picture is the user's picture URL.\n\tPicture string\n}\n\n// ValidateToken validates an auth token against Firebase Auth.\n//encore:authhandler\nfunc ValidateToken(ctx context.Context, token string) (auth.UID, *Data, error) {\n    panic(\"Not Yet Implemented\")\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Secret Values in Typescript\nDESCRIPTION: This snippet shows how to use a secret value in your application. You define the secret as shown above. Once you've provided values for all secrets, call the secret as a function to get the value. This example shows how to inject a token into a GitHub API call.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/secrets.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nasync function callGitHub() {\n  const resp = await fetch(\"https:///api.github.com/user\", {\n    credentials: \"include\",\n    headers: {\n      Authorization: `token ${githubToken()}`,\n    },\n  });\n  // ... handle resp\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Encore Database and Integrating ent Client in Go\nDESCRIPTION: Code snippet showing how to create an Encore database and set up an ent client connected to it using a Service Struct.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/entgo-orm.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage user\n\nimport (\n    \"encore.dev/storage/sqldb\"\n\t\"entgo.io/ent/dialect\"\n\tentsql \"entgo.io/ent/dialect/sql\"\n\t\n\t\"encore.app/user/ent\"\n)\n\nvar userDB = sqldb.NewDatabase(\"user\", sqldb.DatabaseConfig{\n\tMigrations: \"./migrations\",\n})\n\n//encore:service\ntype Service struct{\n    ent *ent.Client\n}\n\nfunc initService() (*Service, error) {\n    driver := entsql.OpenDB(dialect.Postgres, userDB.Stdlib())\n    entClient := ent.NewClient(ent.Driver(driver))\n    return &Service{ent: entClient}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Google Cloud Storage in Encore\nDESCRIPTION: This snippet demonstrates the configuration for Google Cloud Storage (GCS) in an Encore application. It defines a bucket 'my-gcs-bucket' with optional key prefix and public base URL.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_17\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"object_storage\": [\n    {\n      \"type\": \"gcs\",\n      \"buckets\": {\n        \"my-gcs-bucket\": {\n          \"name\": \"my-gcs-bucket\",\n          \"key_prefix\": \"my-optional-prefix/\",\n          \"public_base_url\": \"https://my-gcs-bucket-cdn.example.com/my-optional-prefix\"\n        }\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL database with SQLDatabase in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a PostgreSQL database in an Encore application using the `SQLDatabase` class. It imports the necessary module, instantiates the database with a name and migration directory, and comments on how to use the created database instance for querying.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/databases.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n\"import { SQLDatabase } from \\\"encore.dev/storage/sqldb\\\";\n\n// Create the todo database and assign it to the \\\"db\\\" variable\nconst db = new SQLDatabase(\\\"todo\\\", {\n  migrations: \\\"./migrations\\\",\n});\n\n// Then, query the database using db.query, db.exec, etc.\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Database in Encore Application using TypeScript\nDESCRIPTION: This TypeScript snippet illustrates how to integrate a database into an Encore application's codebase using Encore's primitives. It involves creating a SQLDatabase object with migration paths and defining an API endpoint to query user data by ID. Dependencies include the Encore API framework, and inputs are database configuration and SQL queries.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/deploy-to-digital-ocean.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst mydb = new SQLDatabase(\"mydb\", {\n   migrations: \"./migrations\",\n});\n\nexport const getUser = api(\n  { expose: true, method: \"GET\", path: \"/names/:id\" },\n  async ({id}: {id:number}): Promise<{ id: number; name: string }> => {\n    return await mydb.queryRow`SELECT * FROM users WHERE id = ${id}` as { id: number; name: string };\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Defining an Authentication Handler in TypeScript with Encore\nDESCRIPTION: This snippet shows how to create an authentication handler that processes requests containing an `Authorization` header. It demonstrates the structure of request parameters and the returned authentication data, enabling the API Gateway to authenticate users based on incoming requests.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/auth.md#2025-04-21_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { Header, Gateway } from \"encore.dev/api\";\nimport { authHandler } from \"encore.dev/auth\";\n\n// AuthParams specifies the incoming request information\n// the auth handler is interested in. In this case it only\n// cares about requests that contain the `Authorization` header.\ninterface AuthParams {\n    authorization: Header<\"Authorization\">;\n}\n\n// The AuthData specifies the information about the authenticated user\n// that the auth handler makes available.\ninterface AuthData {\n    userID: string;\n}\n\n// The auth handler itself.\nexport const auth = authHandler<AuthParams, AuthData>(\n    async (params) => {\n        // TODO: Look up information about the user based on the authorization header.\n        return {userID: \"my-user-id\"};\n    }\n)\n\n// Define the API Gateway that will execute the auth handler:\nexport const gateway = new Gateway({\n    authHandler: auth,\n})\n```\n\n----------------------------------------\n\nTITLE: Handling Nested Header Fields in Request Schema\nDESCRIPTION: This snippet shows how to handle nested header fields in a request schema with Encore.ts, illustrating the limitation of Header type within nested fields.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api, Header } from \"encore.dev/api\";\n\ninterface Data {\n  header: Header<\"X-Header\">; // this field will be read from the http header\n  nested: {\n    header2: Header<\"X-Other-Header\">; // Header has no effect inside nested fields\n  };\n}\n\n// A simple API endpoint that echoes the data back.\nexport const echo = api(\n  { method: \"POST\", path: \"/nested\" },\n  async (params: Data) => {\n    // ...\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Basic Authentication Handler Implementation in Go\nDESCRIPTION: Defines a basic authentication handler function that processes a token and returns a user ID and custom data\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_24\n\nLANGUAGE: go\nCODE:\n```\n//encore:authhandler\nfunc AuthHandler(ctx context.Context, token string) (auth.UID, *Data, error) {\n    // Return user ID and custom data\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Drizzle ORM in Encore.ts Project\nDESCRIPTION: Shows the configuration file setup for Drizzle ORM in an Encore.ts project. This configuration specifies the output directory for migrations, schema location, and database dialect.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nimport 'dotenv/config';\nimport { defineConfig } from 'drizzle-kit';\n\nexport default defineConfig({\n  out: 'migrations',\n  schema: 'schema.ts',\n  dialect: 'postgresql',\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom S3 Provider in Encore\nDESCRIPTION: Configuration for custom S3-compatible storage providers with endpoint and authentication settings.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_19\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"object_storage\": [\n    {\n      \"type\": \"s3\",\n      \"region\": \"auto\",\n      \"endpoint\": \"https://...\",\n      \"access_key_id\": \"...\",\n      \"secret_access_key\": {\n          \"$env\": \"BUCKET_SECRET_ACCESS_KEY\"\n      },\n      \"buckets\": {\n        \"my-custom-bucket\": {\n          \"name\": \"my-custom-bucket\",\n          \"key_prefix\": \"my-optional-prefix/\",\n          \"public_base_url\": \"https://my-gcs-bucket-cdn.example.com/my-optional-prefix\"          \n        }\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Loading Service Configuration in Go\nDESCRIPTION: This snippet defines a configuration struct for a service, including fields for the user's name, operational port, read-only mode, and other attributes. It then loads this configuration using the `config.Load` function from the `encore.dev/config` package. The struct requires the uuid package for UUID handling.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_config.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n    \"time\"\n\n\t\"encore.dev/config\"\n\t\"encore.dev/types/uuid\"\n)\n\ntype Config struct {\n    Name        string    // The users name\n    Port        uint16\n    ReadOnly    bool      // true if we're in read only mode\n\n    // MagicNumber is complicated and requires\n    // a multi-line comment to explain it.\n    MagicNumber int\n\n    ID          uuid.UUID // An ID\n\n    PublicKey []byte\n}\n\nvar _ = config.Load[*Config]()\n```\n\n----------------------------------------\n\nTITLE: Declaring Infrastructure Semantics with Encore.ts\nDESCRIPTION: This snippet shows how to use Encore.ts to declare the infrastructure semantics directly in your application code. Encore then automatically provisions the necessary infrastructure in your cloud.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/other/vs-heroku.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n\"[Encore.ts](/docs/ts)\"\n```\n\n----------------------------------------\n\nTITLE: Integrating Drizzle ORM with Encore.ts Database\nDESCRIPTION: Demonstrates how to set up a SQLDatabase, configure Drizzle ORM connection, and perform a sample query. This setup includes migration configuration for Drizzle.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\nimport { SQLDatabase } from \"encore.dev/storage/sqldb\";\nimport { drizzle } from \"drizzle-orm/node-postgres\";\nimport { users } from \"./schema\";\n\nconst db = new SQLDatabase(\"test\", {\n  migrations: {\n    path: \"migrations\",\n    source: \"drizzle\",\n  },\n});\n\nconst orm = drizzle(db.connectionString);\nawait orm.select().from(users);\n```\n\n----------------------------------------\n\nTITLE: Mocking Encore Client for Testing (TypeScript)\nDESCRIPTION: This TypeScript code demonstrates how to mock the Encore request client in unit tests using Jest. It spies on the `List` method of the `site.ServiceClient.prototype` to return mocked data and spies on the `Add` method to verify that it's called with the correct parameters.  This allows testing components that interact with the Encore API without making actual network requests, and allows for type-safe mocking based on the client's API definition.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/frontend/request-client.mdx#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n\"import { render, waitForElementToBeRemoved } from \\\"@testing-library/react\\\";\nimport App from \\\"./App\\\";\nimport { site } from \\\"./client\\\";\nimport { userEvent } from \\\"@testing-library/user-event\\\";\n\ndescribe(\\\"App\\\", () => {\n  beforeEach(() => {\n    // Return mocked data from the List (GET) endpoint\n    jest\n      .spyOn(site.ServiceClient.prototype, \\\"List\\\")\n      .mockReturnValue(Promise.resolve({\n        sites: [{\n          id: 1,\n          url: \\\"test.dev\\\"\n        }]\n      }));\n\n    // Spy on the Add (POST) endpoint\n    jest.spyOn(site.ServiceClient.prototype, \\\"Add\\\");\n  });\n\n  it(\\\"render sites\\\", async () => {\n    render(<App />);\n    await waitForElementToBeRemoved(() => screen.queryByText(\\\"Loading...\\\"));\n\n    // Verify that the List endpoint has been called\n    expect(site.ServiceClient.prototype.List).toBeCalledTimes(1);\n\n    // Verify that the sites are rendered with our mocked data\n    screen.getAllByText(\\\"test.dev\\\");\n  });\n\n  it(\\\"add site\\\", async () => {\n    render(<App />);\n    await waitForElementToBeRemoved(() => screen.queryByText(\\\"Loading...\\\"));\n\n    // Interact with the page and add 'another.com'\n    await userEvent.click(screen.getByText(\\\"Add website\\\"));\n    await userEvent.type(\n      screen.getByPlaceholderText(\\\"google.com\\\"),\n      \\\"another.com\\\",\n    );\n    await userEvent.click(screen.getByText(\\\"Save\\\"));\n\n    // Verify that the Add endpoint has been called with the correct parameters\n    expect(site.ServiceClient.prototype.Add).toHaveBeenCalledWith({\n      url: \\\"another.com\\\",\n    });\n  });\n})\"\n```\n\n----------------------------------------\n\nTITLE: Creating GraphQL Schema for Book Management - TypeScript\nDESCRIPTION: A GraphQL schema definition used to specify the structure and types for the API, including queries and mutations related to books. This schema allows clients to interact with book data via specified operations.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/graphql.mdx#2025-04-21_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\ntype Query {\n  books: [Book]\n}\n\ntype Book {\n  title: String!\n  author: String!\n}\n\ntype AddBookMutationResponse {\n  code: String!\n  success: Boolean!\n  message: String!\n  book: Book\n}\n\ntype Mutation {\n  addBook(title: String!, author: String!): AddBookMutationResponse\n}\n```\n\n----------------------------------------\n\nTITLE: Defining OAuth Token Structure in TypeScript\nDESCRIPTION: This TypeScript snippet defines the structure of the 'Token' object that is returned after successfully creating an API access token. It includes properties like access_token, expires_in, actor, and token_type which facilitate the use of the token in subsequent API calls.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/integrations/api-reference.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Token = {\n  // The access token itself.\n  \"access_token\": string;\n\n  // The access token expires after 1 hour (3600 seconds).\n  \"expires_in\": 3600;\n\n  // The actor the token belongs to, in this case the OAuth2 client id.\n  actor: string;\n\n  // Indicates the access token should be passed as a \"Bearer\" token in the Authorization header.\n  \"token_type\": \"Bearer\";\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing API Endpoint for Todo Count in Go\nDESCRIPTION: Go function to query and return the count of completed todo items using Encore's sqldb package\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_10\n\nLANGUAGE: go\nCODE:\n```\npackage report\n\nimport (\n    \"context\"\n    \"encore.dev/storage/sqldb\"\n)\n\nvar todoDB = sqldb.Named(\"todo\")\n\ntype ReportResponse struct {\n    Total int\n}\n\n//encore:api method=GET path=/report/todo\nfunc CountCompletedTodos(ctx context.Context) (*ReportResponse, error) {\n    var report ReportResponse\n    err := todoDB.QueryRow(ctx,`\n        SELECT COUNT(*)\n        FROM todo_item\n        WHERE completed = TRUE\n    `).Scan(&report.Total)\n    return &report, err\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration for BsConfig in Go with Encore\nDESCRIPTION: This snippet defines the BsConfig type, which includes a Foo field of type config.String and utilizes Encore's loading mechanism to handle the configuration. This allows structured configuration loading for the BsConfig type, ensuring type safety and organization within the Encore application.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/merge_identical_comments.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"encore.dev/config\"\n)\n\ntype BsConfig struct{\n\tFoo config.String // Some extra comment\n}\n\nvar _ = config.Load[BsConfig]()\n```\n\n----------------------------------------\n\nTITLE: Implementing Ping Endpoint in TypeScript with Encore\nDESCRIPTION: Defines a simple ping endpoint using Encore's API framework. Sets up a basic API endpoint with empty parameters and void return type.\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/tests/testdata/builtins.txt#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\n\ntype Params = Record<string, string>;\n\nexport const ping = api<Params, void>({}, () => {});\n```\n\n----------------------------------------\n\nTITLE: Launching Main Application - Go\nDESCRIPTION: This snippet is the entry point for the Encore application. It imports the appinit package from Encore and calls AppMain to start the application. The underscore import prevents unused import errors.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/subscription.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\tappinit \"encore.dev/appruntime/apisdk/app/appinit\"\n\t_ \"example.com\"\n)\n\nfunc main() {\n\tappinit.AppMain()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Object Storage Bucket in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a new bucket for storing objects using Encore's Object Storage API. It includes configuring the bucket properties such as whether the stored objects should be versioned. No external dependencies are required aside from Encore's Object Storage module. The method initializes a bucket using a specified name and configuration options, supporting cloud-agnostic implementations.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/object-storage.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Bucket } from \"encore.dev/storage/objects\";\n\nexport const profilePictures = new Bucket(\"profile-pictures\", {\n  versioned: false\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Encore Service and Middleware in Go\nDESCRIPTION: This code defines an Encore service named `Service` and its associated middleware. The `Middleware` function is annotated with `//encore:middleware target=all` indicating that it should be applied to all API endpoints of the service. An API endpoint `API` is defined to allow the definition of service-specific middleware.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/middlewaregen/testdata/service_struct.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport (\"context\"; \"encore.dev/middleware\")\n\n//encore:service\ntype Service struct{}\n\n//encore:middleware target=all\nfunc (s *Service) Middleware(req middleware.Request, next middleware.Next) middleware.Response {\n    return next(req)\n}\n\n// Note: we need an API endpoint to be able to define service-specific middleware\n//encore:api\nfunc (s *Service) API(context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Authentication Handler Implementation in Go using Encore\nDESCRIPTION: Implements an authentication handler that processes Authorization header. Defines Params struct for header parsing and MyAuth function that returns auth.UID.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/auth_handler_struct.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype Params struct {\n    Authorization string `header:\"Authorization\"`\n}\n\n//encore:authhandler\nfunc MyAuth(ctx context.Context, p *Params) (auth.UID, error) { return \"\", nil }\n```\n\n----------------------------------------\n\nTITLE: Automatically Unmarshalling JSON Configurations in Go\nDESCRIPTION: Utilizes the `json-iterator` package to automatically unmarshal JSON configurations to Go structs. The code provides concrete unmarshalers compatible with Encore's configuration system, handling `ServerOption` and `Config` types. It reads JSON objects and populates struct fields by matching JSON fields with struct fields.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/cue_optional_tag.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport jsoniter \"github.com/json-iterator/go\"\n\n/*\nThese functions are automatically generated and maintained by Encore to allow config values\nto be unmarshalled into the correct types. They are not intended to be used directly. They\nare automatically updated by Encore whenever you change the data types used within your\ncalls to config.Load[T]().\n*/\n\n// Concrete unmarshalers for all config.Load calls, including those using generic types.\n// These instances are used directly by calls to `config.Load[T]()`.\nvar (\n\tencoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {\n\t\treturn func() *Config {\n\t\t\t// If the value is null, we return nil\n\t\t\tif itr.ReadNil() {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Otherwise we unmarshal the value and return a pointer to it\n\t\t\tobj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))\n\t\t\treturn &obj\n\t\t}()\n\t}\n)\n\n// encoreInternalTypeConfigUnmarshaler_svc_Config will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"HTTP\":\n\t\t\tobj.HTTP = encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr, append(path, \"HTTP\"))\n\t\tcase \"Another\":\n\t\t\tobj.Another = encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr, append(path, \"Another\"))\n\t\tcase \"TCP\":\n\t\t\tobj.TCP = encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr, append(path, \"TCP\"))\n\t\tcase \"GRPC\":\n\t\t\tobj.GRPC = encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr, append(path, \"GRPC\"))\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n\n// encoreInternalTypeConfigUnmarshaler_svc_ServerOption will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr *jsoniter.Iterator, path []string) (obj ServerOption) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"Option\":\n\t\t\tobj.Option = itr.ReadInt64()\n\t\tcase \"Disabled\":\n\t\t\tobj.Disabled = itr.ReadBool()\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StreamOut API Endpoint with Encore\nDESCRIPTION: This code implements a `streamOut` API endpoint using Encore. It sends a stream of messages from the server to the client.  It sends a single message and closes the stream.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nexport const dataStream = api.streamOut<Message>(\n  { path: \"/stream\", expose: true },\n  async (stream) => {\n    // Send messages to client\n    await stream.send({ data: \"message\" });\n    await stream.close();\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing Authentication Service in Go\nDESCRIPTION: Defines a service structure with a custom AuthHandler method for token-based authentication using Encore's auth framework\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/authhandlergen/testdata/servicestruct.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport (\"context\"; \"encore.dev/beta/auth\")\n\n//encore:service\ntype Service struct{}\n\n//encore:authhandler\nfunc (*Service) AuthHandler(ctx context.Context, token string) (auth.UID, error) {\n    return \"\", nil\n}\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image for Encore Application\nDESCRIPTION: Command to build a Docker image of the Encore application. This allows for deployment to any environment that supports Docker containers.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/quick-start.mdx#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ encore build docker MY-IMAGE:TAG\n```\n\n----------------------------------------\n\nTITLE: Triggering Incidents via cURL in Bash\nDESCRIPTION: These Bash cURL commands permit interaction with the Encore app to manage users, schedules, and incidents. Required endpoints include `/users` for user creation, `/users/{id}/schedules` for adding schedules, and `/incidents` for triggering incidents. The cURL calls enable simulation of real-world action scenarios on the local server, assuming the app is running on localhost:4000.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/incident-management-tool.md#2025-04-21_snippet_13\n\nLANGUAGE: Bash\nCODE:\n```\ncurl -d '{\n  \"Body\":\"An unexpected error happened on example-website.com on line 38. It needs addressing now!\"\n}' http://localhost:4000/incidents\n\n```\n\nLANGUAGE: Bash\nCODE:\n```\ncurl -d '{\n  \"FirstName\":\"Katy\",\n  \"LastName\":\"Smith\",\n  \"SlackHandle\":\"katy\"\n}' http://localhost:4000/users\n\n```\n\nLANGUAGE: Bash\nCODE:\n```\ncurl -d '{\n  \"Start\":\"2022-09-28T10:00:00Z\",\n  \"End\":\"2022-09-29T10:00:00Z\"\n}' \"http://localhost:4000/users/1/schedules\"\n\n```\n\nLANGUAGE: Bash\nCODE:\n```\ncurl -d '{\n  \"Body\":\"An unexpected error happened on example-website.com on line 38. It needs addressing now!\"\n}' http://localhost:4000/incidents\n\n```\n\nLANGUAGE: Bash\nCODE:\n```\ncurl -X PUT \"http://localhost:4000/incidents/1/acknowledge\"\n\n```\n\n----------------------------------------\n\nTITLE: Binding Pub/Sub Topic to Transactional Outbox in Go\nDESCRIPTION: This snippet demonstrates how to create a Pub/Sub topic, bind it to a transactional outbox, and prepare it for publishing messages within a database transaction.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/pubsub-outbox.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// Create a SignupsTopic somehow.\nvar SignupsTopic = pubsub.NewTopic[*SignupEvent](/* ... */)\n\n// Create a topic ref with publisher permissions.\nref := pubsub.TopicRef[pubsub.Publisher[*SignupEvent]](SignupsTopic)\n\n// Bind it to the transactional outbox\nimport \"x.encore.dev/infra/pubsub/outbox\"\nvar tx *sqldb.Tx // somehow get a transaction\nref = outbox.Bind(ref, outbox.TxPersister(tx))\n\n// Calls to ref.Publish() will now insert a row in the outbox table.\n```\n\n----------------------------------------\n\nTITLE: Defining API endpoint in Go\nDESCRIPTION: This code defines an API endpoint named `MyAPI` using the `encore.dev` framework. The `//encore:api` comment indicates that this function should be exposed as an API endpoint by Encore.  It takes a `context.Context` as input and returns an error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_inline_struct.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Authentication Parameters and Handler in Go\nDESCRIPTION: This snippet defines the structure for authentication parameters (`MyAuthParams`) using struct tags to specify how they are extracted from HTTP headers and query parameters. It also defines a handler function `AuthHandler` that receives these parameters and returns a user ID, authentication data, and an error. This is the user-defined part.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/authhandlergen/testdata/authdata.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport (\"context\"; \"encore.dev/beta/auth\")\n\ntype MyAuthParams struct {\n\tClientID string `header:\"X-Client-ID\"`\n\tAPIKey   string `query:\"key\"`\n}\n\ntype MyAuthData struct {\n    Username string\n}\n\n//encore:authhandler\nfunc AuthHandler(ctx context.Context, p *MyAuthParams) (auth.UID, *MyAuthData, error) {\n    return \"\", nil, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Throwing APIError in TypeScript\nDESCRIPTION: This snippet shows how to throw an `APIError` in TypeScript, utilizing the `ErrCode` enum for specifying error types. It also shows the shorthand version to throw a specific error like `notFound`. It requires importing `APIError` and `ErrCode` from the `encore.dev/api` module.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/errors.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { APIError, ErrCode } from \"encore.dev/api\";\n\nthrow new APIError(ErrCode.NotFound, \"sprocket not found\");\n\n// or as a shorthand you can also write:\nthrow APIError.notFound(\"sprocket not found\");\n```\n\n----------------------------------------\n\nTITLE: Creating Atlas GORM Loader Script\nDESCRIPTION: This Go program uses the `atlas-provider-gorm` library to load GORM models and output the corresponding SQL schema. It imports the necessary packages and defines the GORM models to be included in the schema.  It depends on the `ariga.io/atlas-go-sdk/recordriver` and `ariga.io/atlas-provider-gorm/gormschema` packages.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/atlas-gorm.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n\"package main\n\nimport (\n    \\\"fmt\\\"\n    \\\"io\\\"\n    \\\"os\\\"\n\n    _ \\\"ariga.io/atlas-go-sdk/recordriver\\\"\n    \\\"ariga.io/atlas-provider-gorm/gormschema\\\"\n    \\\"encore.app/blog\\\"\n)\n\n// Define the models to generate migrations for.\nvar models = []any{\n    &blog.Post{},\n    &blog.Comment{},\n}\n\nfunc main() {\n    stmts, err := gormschema.New(\\\"postgres\\\").Load(models...)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \\\"failed to load gorm schema: %v\\\\n\\\", err)\n        os.Exit(1)\n    }\n    io.WriteString(os.Stdout, stmts)\n}\"\n```\n\n----------------------------------------\n\nTITLE: Defining Encore Service with Authentication Handler in Go\nDESCRIPTION: This code defines an Encore service with both a standalone public API endpoint and a service struct with an authentication handler. It demonstrates the use of Encore's API annotations and auth framework.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/auth_handler_svc_struct.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"encore.dev/beta/auth\"\n)\n\ntype FooParams struct{}\n\n//encore:api public\nfunc Foo(ctx context.Context, p *FooParams) error { return nil }\n\ntype Params struct {\n    Authorization string `header:\"Authorization\"`\n}\n\n//encore:service\ntype Service struct{}\n\n//encore:authhandler\nfunc (s *Service) MyAuth(ctx context.Context, p *Params) (auth.UID, error) { return \"\", nil }\n```\n\n----------------------------------------\n\nTITLE: Login Status Component with Profile Fetching\nDESCRIPTION: Renders dynamic login/logout UI based on authentication state, fetches user profile, and provides context-aware authentication actions\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/auth0-auth.md#2025-04-21_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nfunction LoginStatus() {\n  const client = getRequestClient();\n  const [profile, setProfile] = useState<auth.ProfileData>();\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const getProfile = async () => {\n      setProfile(await client.auth.GetProfile());\n      setLoading(false);\n    };\n    if (Auth0Provider.isAuthenticated()) getProfile();\n    else setLoading(false);\n  }, []);\n\n  // Rendering logic for login/logout state\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Encore Service and API Functions in Go\nDESCRIPTION: Defines the `Service` type and its method `Foo`, used for service interactions. Dependencies include the `context` package and Encore's framework-specific tags. The method returns an error, serving as a stub for actual implementation.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/service_struct.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage code\n\nimport \"context\"\n\n//encore:service\ntype Service struct{}\n\n//encore:api\nfunc (s *Service) Foo(ctx context.Context) error { return nil }\n\nfunc initService() (*Service, error) { return nil, nil }\n```\n\n----------------------------------------\n\nTITLE: Configuring Public Buckets in TypeScript\nDESCRIPTION: This segment shows how to set a bucket to public accessibility within Encore.ts, allowing objects to be accessed via public URLs. By setting the `public` property to `true`, files within the bucket gain public access permissions, streamlining content sharing across different environments, and ensuring optimal content delivery through Encore's infrastructure.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/object-storage.md#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const publicProfilePictures = new Bucket(\"public-profile-pictures\", {\n  public: true,\n  versioned: false\n});\n```\n\n----------------------------------------\n\nTITLE: Defining PubSub Topic and Subscription in Go with Encore\nDESCRIPTION: This snippet sets up a PubSub topic and subscription using Encore's pubsub package. It defines a MessageType struct, creates a topic with at-least-once delivery guarantee, and sets up a subscription with a handler function.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_subscription_name_invalid.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/pubsub\"\n)\n\ntype MessageType struct {\n    Name string\n}\n\nvar (\n    BasicTopic = pubsub.NewTopic[*MessageType](\"basic-topic\", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })\n    _ = pubsub.NewSubscription(BasicTopic, \"basic subscription\", pubsub.SusbcriptionConfig { Handler: Subscriber })\n)\n\n// encore:api\nfunc DoStuff(ctx context.Context) error {\n    return BasicTopic.Publish(ctx, &MessageType{Name: \"foo\"})\n}\n\nfunc Subscriber(ctx context.Context, msg *MessageType) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Global Validation Middleware Implementation\nDESCRIPTION: Implements a global middleware for request payload validation\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_31\n\nLANGUAGE: go\nCODE:\n```\n//encore:middleware global target=all\nfunc ValidationMiddleware(req middleware.Request, next middleware.Next) middleware.Response {\n    payload := req.Data().Payload\n    if validator, ok := payload.(interface { Validate() error }); ok {\n        if err := validator.Validate(); err != nil {\n            err = errs.WrapCode(err, errs.InvalidArgument, \"validation failed\")\n            return middleware.Response{Err: err}\n        }\n    }\n    return next(req)\n}\n```\n\n----------------------------------------\n\nTITLE: Site Get Endpoint Implementation\nDESCRIPTION: Go implementation of GET endpoint to retrieve a site by its unique identifier using GORM\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/uptime.md#2025-04-21_snippet_8\n\nLANGUAGE: go\nCODE:\n```\ntype Site struct {\n\tID int `json:\"id\"`\n\tURL string `json:\"url\"`\n}\n\n//encore:api public method=GET path=/site/:siteID\nfunc (s *Service) Get(ctx context.Context, siteID int) (*Site, error) {\n\tvar site Site\n\tif err := s.db.Where(\"id = $1\", siteID).First(&site).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn &site, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Pub/Sub Topic in Go with Encore\nDESCRIPTION: This snippet defines a new pub/sub topic named \"topic\" using the Encore framework. The topic is configured to use at-least-once delivery guarantee, ensuring that messages are delivered at least once, but possibly more than once.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/pubsubgen/testdata/basic.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\t\"encore.dev/pubsub\"\n)\n\ntype Event struct {}\n\nvar Topic = pubsub.NewTopic[*Event](\"topic\", pubsub.TopicConfig{\n    DeliveryGuarantee: pubsub.AtLeastOnce,\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Encore Authentication Handler in Go\nDESCRIPTION: This snippet defines an authentication handler for Encore using the //encore:authhandler directive. It takes a context and token as input and returns an auth.UID and error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_auth.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\n//encore:authhandler\nfunc MyAuthHandler(ctx context.Context, token string) (auth.UID, error) {\n    return \"\", nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Service Configuration Structure in Go\nDESCRIPTION: Defines a comprehensive configuration struct with multiple typed configuration fields using Encore's config package. Includes fields for name, port, read-only mode, magic number, start time, ID, public key, and admin users.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_wrappers.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\ntype Config struct {\n    Name        config.String    // The users name\n    Port        config.Uint16\n    ReadOnly    config.Bool      // true if we're in read only mode\n\n    // MagicNumber is complicated and requires\n    // a multi-line comment to explain it.\n    MagicNumber config.Int\n\n    Start       config.Time // The time at which the service was first started\n    ID          config.UUID // An ID\n\n    PublicKey config.Value[[]byte]\n\n    AdminUsers config.Values[string]\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration for DsConfig in Go with Encore\nDESCRIPTION: Similar to other config types, DsConfig includes a Foo field of type config.String and uses Encore's configuration load function. This structure ensures that the configuration is correctly managed within the application framework, promoting good organizational practices.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/merge_identical_comments.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"encore.dev/config\"\n)\n\ntype DsConfig struct{\n\tFoo config.String // Some extra comment\n}\n\nvar _ = config.Load[DsConfig]()\n```\n\n----------------------------------------\n\nTITLE: Implementing a Fallback Route in Encore\nDESCRIPTION: This snippet demonstrates how to implement a fallback route in Encore using the '//encore:api' annotation with 'path=/!fallback'. It's useful for gradual migration of existing services to Encore.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/defining-apis.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n//encore:service\ntype Service struct {\n\toldRouter *gin.Engine // existing HTTP router\n}\n\n// Route all requests to the existing HTTP router if no other endpoint matches.\n//encore:api public raw path=/!fallback\nfunc (s *Service) Fallback(w http.ResponseWriter, req *http.Request) {\n    s.oldRouter.ServeHTTP(w, req)\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Encore Service Struct in Go\nDESCRIPTION: This Go snippet declares a Service struct within the foobar package, using the Encore directive to ensure a service is created. It requires the Go programming language setup and the Encore framework. The struct itself does not define any APIs, showcasing that the mere presence of the struct annotated with `encore:service` is sufficient for service creation. There are no parameters needed, and it has no explicit outputs.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/servicestruct_creates_service.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage foobar\n\nimport (\n\t\"context\"\n)\n\n//encore:service\ntype Service struct {}\n```\n\n----------------------------------------\n\nTITLE: Implementing Site Status Monitoring in Go\nDESCRIPTION: Creates a Status endpoint that retrieves and returns the current status of all monitored sites, including their up/down state and last check time.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/uptime.md#2025-04-21_snippet_14\n\nLANGUAGE: go\nCODE:\n```\npackage monitor\n\nimport (\n\t\"context\"\n\t\"time\"\n)\n\n// SiteStatus describes the current status of a site\n// and when it was last checked.\ntype SiteStatus struct {\n\tUp        bool      `json:\"up\"`\n\tCheckedAt time.Time `json:\"checked_at\"`\n}\n\n// StatusResponse is the response type from the Status endpoint.\ntype StatusResponse struct {\n\t// Sites contains the current status of all sites,\n\t// keyed by the site ID.\n\tSites map[int]SiteStatus `json:\"sites\"`\n}\n\n// Status checks the current up/down status of all monitored sites.\n//\n//encore:api public method=GET path=/status\nfunc Status(ctx context.Context) (*StatusResponse, error) {\n\trows, err := db.Query(ctx, `\n\t\tSELECT DISTINCT ON (site_id) site_id, up, checked_at\n\t\tFROM checks\n\t\tORDER BY site_id, checked_at DESC\n\t`)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tresult := make(map[int]SiteStatus)\n\tfor rows.Next() {\n\t\tvar siteID int\n\t\tvar status SiteStatus\n\t\tif err := rows.Scan(&siteID, &status.Up, &status.CheckedAt); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresult[siteID] = status\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &StatusResponse{Sites: result}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Registering an API Endpoint in Go\nDESCRIPTION: In this snippet, the API endpoint 'Foo' is registered within the Encore framework. It defines the request and response structures as well as the logic for handling the API calls, including request parameter extraction and response encoding.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/request_headers.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\t__etype \"encore.dev/appruntime/shared/etype\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"net/http\"\n\t\"net/textproto\"\n\t\"net/url\"\n)\n\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n}\n\ntype EncoreInternal_FooReq struct {\n\tPayload *Params\n}\n\ntype EncoreInternal_FooResp = __api.Void\n\nvar EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{\n\tAccess: __api.Public,\n\tAppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {\n\t\terr := Foo(ctx, reqData.Payload)\n\t\tif err != nil {\n\t\t\treturn __api.Void{}, err\n\t\t}\n\t\treturn __api.Void{}, nil\n\t},\n\t// Additional methods omitted for brevity...\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Pubsub Topic Declaration in Encore API Function (Go)\nDESCRIPTION: This snippet shows an API function that attempts to create a pubsub topic inside the function, which is not allowed in Encore. Topics must be declared at the package level.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_topic_declared_in_func.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/pubsub\"\n)\n\ntype MyMessage struct {}\n\n//encore:api\nfunc SomeAPI(ctx context.Context) error {\n    topic := pubsub.NewTopic[MyMessage](\"basic-topic\")\n    topic.Publish(ctx, &MyMessage{})\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Message to PubSub Topic in Go\nDESCRIPTION: This function, marked as an Encore API endpoint, publishes a message to the previously defined BasicTopic. It creates a new MessageType instance and sends it to the topic.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_topic_name_invalid.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n// encore:api\nfunc DoStuff(ctx context.Context) error {\n    return BasicTopic.Publish(ctx, &MessageType{Name: \"foo\"})\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Option Type in Go\nDESCRIPTION: This code defines a generic option type called DisablableOption that can hold a value of any type and a boolean indicating if it is disabled. It is useful for managing options that may not be applicable in certain contexts.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/generic_named_types.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype DisablableOption[T any] struct {\n    Option   T\n    Disabled bool // True if this is disabled\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Auth Handler in Encore Go\nDESCRIPTION: Defines a basic authentication handler that validates and processes authentication tokens, returning a user identifier\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/authhandlergen/testdata/basic.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc AuthHandler(ctx context.Context, token string) (auth.UID, error) {\n    return \"\", nil\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Calling Service Endpoint in TypeScript\nDESCRIPTION: Demonstrates importing a service client and making a type-safe API call to another service's endpoint with parameter passing and response handling\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/api-calls.mdx#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { hello } from \"~encore/clients\"; // import 'hello' service\n\nexport const myOtherAPI = api({}, async (): Promise<void> => {\n  const resp = await hello.ping({ name: \"World\" });\n  console.log(resp.message); // \"Hello World!\"\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Encore CLI\nDESCRIPTION: Command to install the Encore CLI, which is necessary for developing with Encore. The specific installation command varies by system.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/quick-start.mdx#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ encore app create\n```\n\n----------------------------------------\n\nTITLE: External Database Integration Setup\nDESCRIPTION: Demonstrates pattern for integrating external databases with Encore using connection pooling\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_8\n\nLANGUAGE: go\nCODE:\n```\npackage externaldb\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"github.com/jackc/pgx/v4/pgxpool\"\n    \"go4.org/syncutil\"\n)\n\nfunc Get(ctx context.Context) (*pgxpool.Pool, error) {\n    err := once.Do(func() error {\n        var err error\n        pool, err = setup(ctx)\n        return err\n    })\n    return pool, err\n}\n\nvar (\n    once syncutil.Once\n    pool *pgxpool.Pool\n)\n\nvar secrets struct {\n    ExternalDBPassword string\n}\n\nfunc setup(ctx context.Context) (*pgxpool.Pool, error) {\n    connString := fmt.Sprintf(\"postgresql://%s:%s@hostname:port/dbname?sslmode=require\",\n        \"user\", secrets.ExternalDBPassword)\n    return pgxpool.Connect(ctx, connString)\n}\n```\n\n----------------------------------------\n\nTITLE: React Component for Fetching Protected Resources Using Logto\nDESCRIPTION: This React component, 'ProtectedResource', showcases how to fetch a protected resource from Encore API using Logto for authentication. It manages the fetch state, handles errors, and renders the response. The component demonstrates the usage of 'getAccessToken' to secure API calls.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/logto-auth.md#2025-04-21_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useLogto } from \"@logto/react\";\nimport { useState } from \"react\";\nimport { Navigate } from \"react-router-dom\";\nimport { appConfig, encoreApiEndpoint } from \"../config/logto\";\n\nexport function ProtectedResource() {\n  const { isAuthenticated, getAccessToken } = useLogto();\n  const [message, setMessage] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n\n  const fetchProtectedResource = async () => {\n    setIsLoading(true);\n    setError(\"\");\n    try {\n      const accessToken = await getAccessToken(appConfig.apiResourceIndicator);\n      const response = await fetch(`${encoreApiEndpoint}/api/hello`, {\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n        },\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      setMessage(JSON.stringify(data));\n    } catch (error) {\n      console.error(\"Error fetching protected resource:\", error);\n      setError(\"Failed to fetch protected resource. Please try again.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  if (!isAuthenticated) {\n    return <Navigate to=\"/\" replace />;\n  }\n\n  return (\n    <div>\n      <h2>Protected Resource</h2>\n\n      {message && !error && (\n        <div>\n          <h3>Response from Protected API</h3>\n          <pre>{message}</pre>\n        </div>\n      )}\n\n      <button\n        onClick={fetchProtectedResource}\n        disabled={isLoading}\n      >\n        {isLoading ? \"Loading...\" : \"Fetch protected resource\"}\n      </button>\n\n      {error && <div>{error}</div>}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Encore Service Struct in Go\nDESCRIPTION: Defines a single Encore service struct named Service to represent the primary service in the module. This struct is annotated with the //encore:service directive, which Encore requires to identify service entry points. Only one such struct per package is allowed, as multiple service structs lead to compile-time errors.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/servicestruct_duplicate.txt#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\t\"encore.dev/types/uuid\"\n)\n\n//encore:service\ntype Service struct {}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a PubSub Topic in Go\nDESCRIPTION: This snippet defines a PubSub topic using the Encore 'pubsub' package. It sets a delivery guarantee of 'AtLeastOnce' which ensures that messages are delivered at least once to subscribers. The topic is initialized with a specific name 'foo'.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/parser/resource/usage/testdata/pubsub_usage.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport \"encore.dev/pubsub\"\n\ntype Message struct{}\n\nvar Topic = pubsub.NewTopic[*Message](\"foo\", pubsub.TopicConfig{\n    DeliveryGuarantee: pubsub.AtLeastOnce,\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Global Middleware in Go\nDESCRIPTION: This code snippet defines a global middleware function in Go using the Encore framework. The middleware intercepts all requests and responses. It uses the `encore.dev/middleware` package for request handling.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/middlewaregen/testdata/global.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage global\n\nimport \"encore.dev/middleware\"\n\n//encore:middleware global target=all\nfunc Middleware(req middleware.Request, next middleware.Next) middleware.Response {\n    return next(req)\n}\n```\n\n----------------------------------------\n\nTITLE: Serving a Specific Template File with EJS in Encore.ts\nDESCRIPTION: This snippet demonstrates how to use EJS to serve a specific HTML template file. It imports the necessary modules, defines a raw endpoint, reads and renders the template, sets the content type, and sends the generated HTML in the response. It uses `ejs.renderFile` to render a template with provided data.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/frontend/template-engine.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\nimport ejs, { Options } from \"ejs\";\n\nconst BASE_PATH = \"./template/views\";\nconst ejsOptions: Options = { views: [BASE_PATH] };\n\nexport const serveSpecificTemplate = api.raw(\n  { expose: true, path: \"/person\", method: \"GET\" },\n  async (req, resp) => {\n    const viewPath = `${BASE_PATH}/person.html`;\n    const html = await ejs.renderFile(\n      viewPath,\n      // Supplying data to the view\n      { name: \"Simon\" },\n      ejsOptions,\n    );\n    resp.setHeader(\"content-type\", \"text/html\");\n    resp.end(html);\n  },\n);\n\n```\n\nLANGUAGE: typescript\nCODE:\n```\n<h1>Person Page</h1>\n<p>Name: <%= name %></p>\n\n```\n\n----------------------------------------\n\nTITLE: Defining Schema for Boolean Fields\nDESCRIPTION: This snippet defines a TypeScript interface for validating boolean fields using Encore.ts within the request schema.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Schema {\n  isHuman:  boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PubSub Topic in Go with Encore\nDESCRIPTION: Creates a PubSub topic with a shared message type and at-least-once delivery guarantee\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_subscription_func_not_in_service.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nvar BasicTopic = pubsub.NewTopic[*shared.MessageType](\"basic-topic\", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })\n```\n\n----------------------------------------\n\nTITLE: Public API Endpoint Declaration in Go using Encore\nDESCRIPTION: Defines a public API endpoint 'Foo' with Encore framework annotation. Takes a context and FooParams struct as input, returns an error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/auth_handler_struct.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype FooParams struct{}\n\n//encore:api public\nfunc Foo(ctx context.Context, p *FooParams) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Defining Schema for String Fields\nDESCRIPTION: This snippet defines a TypeScript interface for validating string fields in the request schema using Encore.ts.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Schema {\n  name:  string;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Status API Endpoint (TypeScript)\nDESCRIPTION: This code creates an API endpoint `/status` that retrieves the current status of all monitored sites.  It queries the `checks` table in the `MonitorDB` database to find the most recent check for each site and returns a list of `SiteStatus` objects, each containing the site ID, up/down status, and the timestamp of the last check.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\nimport { MonitorDB } from \"./check\";\n\ninterface SiteStatus {\n  id: number;\n  up: boolean;\n  checkedAt: string;\n}\n\n// StatusResponse is the response type from the Status endpoint.\ninterface StatusResponse {\n  // Sites contains the current status of all sites,\n  // keyed by the site ID.\n  sites: SiteStatus[];\n}\n\n// status checks the current up/down status of all monitored sites.\nexport const status = api(\n  { expose: true, path: \"/status\", method: \"GET\" },\n  async (): Promise<StatusResponse> => {\n    const rows = await MonitorDB.query`\n      SELECT DISTINCT ON (site_id) site_id, up, checked_at\n      FROM checks\n      ORDER BY site_id, checked_at DESC\n    `;\n    const results: SiteStatus[] = [];\n    for await (const row of rows) {\n      results.push({\n        id: row.site_id,\n        up: row.up,\n        checkedAt: row.checked_at,\n      });\n    }\n    return { sites: results };\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing Knex.js with Encore SQLDatabase\nDESCRIPTION: This snippet demonstrates how to initialize Knex.js with an Encore SQLDatabase instance. It imports necessary modules, creates an SQLDatabase instance with migrations configuration, and initializes Knex.js with the database connection string provided by Encore.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/orms/knex.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// site.ts\nimport { SQLDatabase } from \"encore.dev/storage/sqldb\";\nimport knex from \"knex\";\n\n// Create SQLDatabase instance with migrations configuration\nconst SiteDB = new SQLDatabase(\"siteDB\", {\n  migrations: \"./migrations\",\n});\n\n// Initialize Knex with the database connection string\nconst orm = knex({\n  client: \"pg\",\n  connection: SiteDB.connectionString,\n});\n\n// Define the Site interface\nexport interface Site {\n  id: number;\n  url: string;\n}\n\n// Query builder for the \"site\" table\nconst Sites = () => orm<Site>(\"site\");\n\n// Example queries\n\n// Query all sites\nawait Sites().select();\n\n// Query a site by id\nawait Sites().where(\"id\", id).first();\n\n// Insert a new site\nawait Sites().insert({ url: params.url });\n```\n\n----------------------------------------\n\nTITLE: Example package.json script for Encore client generation\nDESCRIPTION: This JSON snippet demonstrates how to integrate the Encore client generation command into a TypeScript project's `package.json` file. Running `npm run gen` updates the client to match the code running in the staging environment.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/client-generation.md#2025-04-21_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    // ...\n    \"gen\": \"encore gen client hello-a8bc --output=./client.ts --env=staging\"\n    // ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Pub/Sub Topic Creation in Encore.ts\nDESCRIPTION: Shows how to create a typed Topic for event publishing in Encore.ts\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Topic } from \"encore.dev/pubsub\"\n\nexport interface SignupEvent {\n    userID: string;\n}\n\nexport const signups = new Topic<SignupEvent>(\"signups\", {\n    deliveryGuarantee: \"at-least-once\",\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Build Settings in encore.app\nDESCRIPTION: This CUE code snippet demonstrates how to configure custom build settings in the encore.app file. It includes options for enabling Cgo, specifying Docker base image, bundling source code, and setting the working directory.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/deploy/deploying.md#2025-04-21_snippet_3\n\nLANGUAGE: cue\nCODE:\n```\n{\n    \"build\": {\n        // Enables cgo when building the application and running tests\n        // in Encore's CI/CD system.\n        \"cgo_enabled\": false,\n\n        // Docker-related configuration\n        \"docker\": {\n        \t// The Docker base image to use when deploying the application.\n        \t// It must be a publicly accessible image, and defaults to \"scratch\".\n            \"base_image\": \"scratch\",\n\n            // Whether to bundle the source code in the docker image.\n            // The source code will be copied into /workspace as part\n            // of the build process. This is primarily useful for tools like\n            // Sentry that need access to the source code to generate stack traces.\n            \"bundle_source\": false,\n\n            // The working directory to start the docker image in.\n            // If empty it defaults to \"/workspace\" if the source code is bundled, and to \"/\" otherwise.\n            \"working_dir\": \"\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Database in PostgreSQL - SQL\nDESCRIPTION: This snippet shows how to create a new database within PostgreSQL and sets up a simple 'users' table for storing user data.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/deploy-to-digital-ocean-wip.md#2025-04-21_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nCREATE DATABASE mydb;\n```\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE users (\n   id SERIAL PRIMARY KEY,\n   name VARCHAR(50)\n);\n```\n\nLANGUAGE: sql\nCODE:\n```\nINSERT INTO users (name) VALUES ('Alice');\n```\n\n----------------------------------------\n\nTITLE: Creating New Encore Application\nDESCRIPTION: Creates a new Encore application with the specified name.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ encore app create [name]\n```\n\n----------------------------------------\n\nTITLE: Creating a Bucket Reference with Encore\nDESCRIPTION: This code shows how to create a typed reference to a bucket with a specific permission in Encore. This provides controlled access to the bucket's resources based on defined permissions, such as Uploader.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Uploader } from \"encore.dev/storage/objects\";\nconst ref = profilePictures.ref<Uploader>();\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Mode with Encore CLI\nDESCRIPTION: Commands to start an Encore application in debug mode, with options to pause on startup or run continuously\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/debug.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nencore run --debug=break\n```\n\nLANGUAGE: shell\nCODE:\n```\nencore run --debug\n```\n\n----------------------------------------\n\nTITLE: Defining Public API Endpoint with Encore in Go\nDESCRIPTION: This snippet defines a public API endpoint using the Encore framework in Go. It specifies the endpoint path and implements a simple function 'Foo' that takes a context and a fallback string as input, returning an error. Encore automatically manages the interface and service registration.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/fallback_path.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage code\n\nimport \"context\"\n\n//encore:api public path=/!fallback\nfunc Foo(ctx context.Context, fallback string) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Registering API Endpoint and Request/Response Handling - Go\nDESCRIPTION: This snippet initializes the API endpoint 'Foo', defining request and response handling functions. It includes methods for cloning requests and responses, decoding external requests, and encoding external requests. The implementation uses the json-iterator package for JSON processing.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/request_params.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n-- want:encore_internal__api.go --\npackage basic\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\t__etype \"encore.dev/appruntime/shared/etype\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n}\n\ntype EncoreInternal_FooReq struct {\n\tPayload *Params\n}\n\ntype EncoreInternal_FooResp = __api.Void\n\nvar EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{\n\tAccess: __api.Public,\n\tAppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {\n\t\terr := Foo(ctx, reqData.Payload)\n\t\tif err != nil {\n\t\t\treturn __api.Void{}, err\n\t\t}\n\t\treturn __api.Void{}, nil\n\t},\n\tCloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {\n\t\tvar clone *EncoreInternal_FooReq\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tCloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {\n\t\tvar clone EncoreInternal_FooResp\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tDecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {\n\t\treturn __api.Void{}, nil\n\t},\n\tDecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {\n\t\treqData = new(EncoreInternal_FooReq)\n\t\tdec := new(__etype.Unmarshaller)\n\t\tparams := new(Params)\n\t\treqData.Payload = params\n\t\tswitch m := httpReq.Method; m {\n\t\tcase \"POST\":\n\t\t\t// Decode request body\n\t\t\tpayload := dec.ReadBody(httpReq.Body)\n\t\t\titer := jsoniter.ParseBytes(json, payload)\n\n\t\t\tfor iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {\n\t\t\t\tswitch strings.ToLower(key) {\n\t\t\t\tcase \"string\":\n\t\t\t\t\tdec.ParseJSON(\"String\", iter, &params.String)\n\t\t\t\tcase \"array\":\n\t\t\t\t\tdec.ParseJSON(\"Array\", iter, &params.Array)\n\t\t\t\tcase \"int\":\n\t\t\t\t\tdec.ParseJSON(\"Int\", iter, &params.Int)\n\t\t\t\tdefault:\n\t\t\t\t\t_ = iter.SkipAndReturnBytes()\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}) {\n\t\t\t}\n\n\t\tdefault:\n\t\t\tpanic(\"HTTP method is not supported\")\n\t\t}\n\t\tif err := dec.Error; err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\treturn reqData, ps, nil\n\t},\n\tDefLoc: uint32(0x0),\n\tEncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {\n\t\tparams := reqData.Payload\n\t\tif params == nil {\n\t\t\t// If the payload is nil, we need to return an empty request body.\n\t\t\treturn httpHeader, queryString, err\n\t\t}\n\n\t\t// Encode request body\n\t\tstream.WriteObjectStart()\n\t\tif params.String != \"\" {\n\t\t\t// String is set to omitempty, so we need to check if it's empty before writing it\n\t\t\tstream.WriteObjectField(\"String\")\n\t\t\tstream.WriteVal(params.String)\n\t\t\tstream.WriteMore()\n\t\t}\n\t\tif true {\n\t\t\t// Array is set to omitempty, so we need to check if it's empty before writing it\n\t\t\tstream.WriteObjectField(\"Array\")\n\t\t\tstream.WriteVal(params.Array)\n\t\t\tstream.WriteMore()\n\t\t}\n\t\tstream.WriteObjectField(\"Int\")\n\t\tstream.WriteVal(params.Int)\n\t\tstream.WriteObjectEnd()\n\n\t\treturn httpHeader, queryString, err\n\t},\n\tEncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {\n\t\treturn nil\n\t},\n\tEndpoint:            \"Foo\",\n\tFallback:            false,\n\tGlobalMiddlewareIDs: []string{},\n\tMethods:             []string{\"POST\"},\n\tPath:                \"/basic.Foo\",\n\tPathParamNames:      nil,\n\tRaw:                 false,\n\tRawHandler:          nil,\n\tRawPath:             \"/basic.Foo\",\n\tReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {\n\t\treturn \"/basic.Foo\", nil, nil\n\t},\n\tReqUserPayload: func(reqData *EncoreInternal_FooReq) any {\n\t\treturn reqData.Payload\n\t},\n\tService:           \"basic\",\n\tServiceMiddleware: []*__api.Middleware{},\n\tSvcNum:            1,\n\tTags:              nil,\n}\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Shared Database in Go with Encore\nDESCRIPTION: This Go code demonstrates how to access a shared 'todo' database from a 'report' service using Encore. It includes a function to count completed todo items using SQL queries on the shared database.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/share-db-between-services.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage report\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/storage/sqldb\"\n)\n\n// todoDB connects to the \"todo\" service's database.\nvar todoDB = sqldb.Named(\"todo\")\n\ntype ReportResponse struct {\n    Total int\n}\n\n// CountCompletedTodos generates a report with the number of completed todo items.\n//encore:api method=GET path=/report/todo\nfunc CountCompletedTodos(ctx context.Context) (*ReportResponse, error) {\n    var report ReportResponse\n    err := todoDB.QueryRow(ctx,`\n        SELECT COUNT(*)\n        FROM todo_item\n        WHERE completed = TRUE\n    `).Scan(&report.Total)\n    return &report, err\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Union and Enum Fields in Schema\nDESCRIPTION: This snippet illustrates how to use string enums in the request schema to validate that a field is one of a predefined set of values.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Schema {\n  type:  \"BLOG_POST\" | \"COMMENT\"\n}\n\nenum PostType {\n  BlogPost = \"BLOG_POST\",\n  Comment = \"COMMENT\"\n}\n\ninterface Schema {\n  type: PostType,\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Service with Encore Internal Mechanism (Go)\nDESCRIPTION: This snippet demonstrates how to register a service using Encore's internal mechanisms. The 'init' function registers a service representation 'EncoreInternal_svcstruct_Service' with the special '__service' package from 'encore.dev'. It constructs a declaration with attributes like service name and location setup, using generic metadata from the framework. There are no specific inputs; the process relies on the correct import and usage of Encore's internal packages.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/servicestructgen/testdata/basic.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage basic\\n\\nimport __service \\\"encore.dev/appruntime/apisdk/service\\\"\\n\\nfunc init() {\\n\\t__service.Register(EncoreInternal_svcstruct_Service)\\n}\\n\\nvar EncoreInternal_svcstruct_Service = &__service.Decl[Service]{\\n\\tName:        \\\"Service\\\",\\n\\tService:     \\\"basic\\\",\\n\\tSetup:       nil,\\n\\tSetupDefLoc: uint32(0x0),\\n}\n```\n\n----------------------------------------\n\nTITLE: Generating an OpenAPI Client with Encore CLI\nDESCRIPTION: This command generates an OpenAPI client for the `hello-a8bc` application based on the primary environment. The OpenAPI specification is saved to the `openapi.json` file and is language-agnostic.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/client-generation.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n\"encore gen client hello-a8bc --lang=openapi --output=./openapi.json\"\n```\n\n----------------------------------------\n\nTITLE: Example Infrastructure Configuration in JSON\nDESCRIPTION: A comprehensive example of an infrastructure configuration file for an Encore application, including metadata, SQL servers, service discovery, Redis, metrics, authentication, and more.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"$schema\": \"https://encore.dev/schemas/infra.schema.json\",\n  \"metadata\": {\n    \"app_id\": \"my-app\",\n    \"env_name\": \"my-env\",\n    \"env_type\": \"production\",\n    \"cloud\": \"gcp\",\n    \"base_url\": \"https://my-app.com\"\n  },\n  \"sql_servers\": [\n    {\n      \"host\": \"my-db-host:5432\",\n      \"databases\": {\n        \"my-db\": {\n          \"username\": \"my-db-owner\",\n          \"password\": {\"$env\": \"DB_PASSWORD\"}\n        }\n      }\n    }\n  ],\n  \"service_discovery\": {\n    \"myservice\": {\n      \"base_url\": \"https://myservice:8044\"\n    }\n  },\n  \"redis\": {\n    \"my-redis\": {\n      \"database_index\": 0,\n      \"auth\": {\n        \"type\": \"acl\",\n        \"username\": \"encoreredis\",\n        \"password\": {\"$env\": \"REDIS_PASSWORD\"}\n      },\n      \"host\": \"my-redis-host\"\n    }\n  },\n  \"metrics\": {\n    \"type\": \"prometheus\",\n    \"remote_write_url\": \"https://my-remote-write-url\"\n  },\n  \"graceful_shutdown\": {\n    \"total\": 30\n  },\n  \"auth\": [\n    {\n      \"type\": \"key\",\n      \"id\": 1,\n      \"key\": {\"$env\": \"SVC_TO_SVC_KEY\"}\n    }\n  ],\n  \"secrets\": {\n    \"AppSecret\": {\"$env\": \"APP_SECRET\"}\n  },\n  \"pubsub\": [\n    {\n      \"type\": \"gcp_pubsub\",\n      \"project_id\": \"my-project\",\n      \"topics\": {\n        \"my-topic\": {\n          \"name\": \"gcp-topic-name\",\n          \"subscriptions\": {\n            \"encore-subscription\": {\n              \"name\": \"gcp-subscription-name\"\n            }\n          }\n        }\n      }\n    }\n  ],\n  \"object_storage\": [\n    {\n      \"type\": \"gcs\",\n      \"buckets\": {\n          \"my-gcs-bucket\": {\n            \"name\": \"my-gcs-bucket\"\n          }\n        }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration in Go\nDESCRIPTION: Demonstrates how to load configuration in an Encore service using the config.Load function. It defines a struct for the config and loads it at the package level.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/config.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage mysvc\n\nimport (\n    \"encore.dev/config\"\n)\n\ntype SomeConfigType struct {\n    ReadOnly config.Bool    // Put the system into read-only mode\n    Example  config.String\n}\n\nvar cfg *SomeConfigType = config.Load[*SomeConfigType]()\n```\n\n----------------------------------------\n\nTITLE: Creating a New Service with Encore\nDESCRIPTION: This snippet demonstrates how to create a new service instance using Encore. It imports the Service class from the Encore library and exports a new instance of it, which is essential for defining the service in a cloud backend application. The main dependency is the 'encore.dev/service' package.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/services.mdx#2025-04-21_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { Service } from \"encore.dev/service\";\n\nexport default new Service(\"my-service\");\n```\n\n----------------------------------------\n\nTITLE: Initializing gqlgen Tools in Go\nDESCRIPTION: This code snippet creates a tools.go file to import gqlgen and its introspection package, which are used as build tools for the GraphQL API.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/graphql.mdx#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n//go:build tools\n\npackage tools\n\nimport (\n    _ \"github.com/99designs/gqlgen\"\n    _ \"github.com/99designs/gqlgen/graphql/introspection\"\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Error Response\nDESCRIPTION: Example of creating and returning a basic error response with NotFound code and custom message.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/api-errors.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nreturn &errs.Error{\n\tCode: errs.NotFound,\n\tMessage: \"sprocket not found\",\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Todo Item Table in SQL\nDESCRIPTION: This SQL migration creates a 'todo_item' table with columns for id, title, and done status. It's part of the 'todo' service database setup.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/share-db-between-services.md#2025-04-21_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE todo_item (\n    id BIGSERIAL PRIMARY KEY,\n    title TEXT NOT NULL,\n    done BOOLEAN NOT NULL DEFAULT FALSE\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Connect Service in Go\nDESCRIPTION: Go implementation of the GreetService defined in the Protobuf, using connect-go library.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/grpc-connect.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage greet\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"connectrpc.com/connect\"\n\n\tgreetv1 \"encore.app/gen/greet/v1\" // generated by protoc-gen-go\n)\n\ntype GreetServer struct{}\n\nfunc (s *GreetServer) Greet(\n\tctx context.Context,\n\treq *connect.Request[greetv1.GreetRequest],\n) (*connect.Response[greetv1.GreetResponse], error) {\n\tlog.Println(\"Request headers: \", req.Header())\n\tres := connect.NewResponse(&greetv1.GreetResponse{\n\t\tGreeting: fmt.Sprintf(\"Hello, %s!\", req.Msg.Name),\n\t})\n\tres.Header().Set(\"Greet-Version\", \"v1\")\n\treturn res, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Using Config Wrappers in Go\nDESCRIPTION: Demonstrates the use of config wrappers in Go, which allow for overriding default values in tests and future-proofing for real-time config updates. The example shows a service configuration using these wrappers.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/config.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n-- svc/svc.go --\ntype mysvc\n\nimport (\n    \"encore.dev/config\"\n)\n\ntype Server struct {\n    // The config wrappers do not have to be in the top level struct\n    Enabled config.Bool\n    Port    config.Int\n}\n\ntype SvcConfig struct {\n    GameServerPorts config.Values[Server]\n}\n\nvar cfg = config.Load[*SvcConfig]()\n\nfunc startServers() {\n    for _, server := range cfg.GameServerPorts() {\n        if server.Enabled() {\n            go startServer(server.Port())\n        }\n    }\n}\n\nfunc startServer(port int) {\n  // ...\n}\n```\n\nLANGUAGE: cue\nCODE:\n```\n-- svc/servers.cue --\nGameServerPorts: [\n    {\n        Enabled: false\n        Port:    12345\n    },\n    {\n        Enabled: true\n        Port:    1337\n    },\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing Public Endpoint Foo with Input Struct\nDESCRIPTION: Public API method taking a custom struct and context, returning an error. Uses Encore's public API annotation for endpoint definition\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/struct_duplicate_json_ignore.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public\nfunc Foo(ctx context.Context, p *SomeStruct) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Encore Service in Go\nDESCRIPTION: Defines a basic service structure with a struct and initialization function using Encore framework annotations\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/servicestructgen/testdata/init_svc.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage basic\n\nimport \"context\"\n\n//encore:service\ntype Service struct {\n}\n\nfunc initService() (*Service, error) {\n    return nil, nil\n}\n\n//encore:api\nfunc API(context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration for Main Service - Go\nDESCRIPTION: This snippet defines the main configuration structure for the service with fields for the user's name, port, and read-only mode. It uses the Encore framework's config.Load function to load the configuration based on the specified structure.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/multiple_configs_in_service.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n)\n\ntype Config struct {\n    Name        string    // The users name\n    Port        uint16\n    ReadOnly    bool      // true if we're in read only mode\n}\n\nvar _ = config.Load[*Config]()\n\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Metrics and Service in Go using Encore\nDESCRIPTION: This snippet defines two metrics (a simple gauge and a gauge with labels) using Encore's metrics package. It also includes a basic service function marked as a public API endpoint.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/metrics_gauge.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/metrics\"\n)\n\nvar Gauge = metrics.NewGauge[float64](\"gauge\", metrics.CounterConfig{})\n\ntype Labels struct {\n\tLabel string // Label doc string.\n}\n\nvar GaugeWithLabels = metrics.NewGaugeGroup[Labels, float64](\"gauge_with_labels\", metrics.CounterConfig{})\n\n//encore:api public\nfunc Foo(context.Context) error {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Objects from Encore Bucket\nDESCRIPTION: This code demonstrates deleting an object from an Encore storage bucket using the `remove` method. It takes the file name as input and removes the corresponding object from the bucket.  \nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nawait profilePictures.remove(\"my-image.jpeg\");\n```\n\n----------------------------------------\n\nTITLE: Defining gRPC Service with Protobuf\nDESCRIPTION: Protobuf definition for a simple greeting service using the Connect protocol.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/grpc-connect.md#2025-04-21_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\n\npackage greet.v1;\n\noption go_package = \"encore.app/gen/greet/v1;greetv1\";\n\nmessage GreetRequest {\n  string name = 1;\n}\n\nmessage GreetResponse {\n  string greeting = 1;\n}\n\nservice GreetService {\n  rpc Greet(GreetRequest) returns (GreetResponse) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Authentication Handler Registration in Go\nDESCRIPTION: This snippet illustrates the registration of an authentication handler within Encore. It defines the `AuthHandlerDesc` which describes the authentication process.  It includes decoding the authentication parameters from the HTTP request, calling the `AuthHandler` function, and registering the authentication data type.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/auth_handler.txt#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\t__model \"encore.dev/appruntime/exported/model\"\n\terrs \"encore.dev/beta/errs\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nvar EncoreInternal_authhandler_AuthDesc_AuthHandler = &__api.AuthHandlerDesc[string]{\n\tAuthHandler: func(ctx context.Context, params string) (info __model.AuthInfo, err error) {\n\t\tinfo.UID, info.UserData, err = AuthHandler(ctx, params)\n\t\treturn info, err\n\t},\n\tDecodeAuth: func(httpReq *http.Request) (params string, err error) {\n\t\tif auth := httpReq.Header.Get(\"Authorization\"); auth != \"\" {\n\t\t\tfor _, prefix := range [...]string{\"Bearer \", \"Token \"} {\n\t\t\t\tif strings.HasPrefix(auth, prefix) {\n\t\t\t\t\tif params = auth[len(prefix):]; params != \"\" {\n\t\t\t\t\t\treturn params, nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"\", errs.B().Code(errs.Unauthenticated).Msg(\"invalid auth param\").Err()\n\t},\n\tDefLoc:      uint32(0x0),\n\tEndpoint:    \"AuthHandler\",\n\tHasAuthData: true,\n\tService:     \"code\",\n\tSvcNum:      1,\n}\n\nfunc init() {\n\t__api.RegisterAuthHandler(EncoreInternal_authhandler_AuthDesc_AuthHandler)\n}\n\nfunc init() {\n\t__api.RegisterAuthDataType[*MyAuthData]()\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Site Check Functionality (TypeScript)\nDESCRIPTION: This code snippet extracts the core site checking logic from the existing `check` endpoint into a separate `doCheck` function. This promotes reusability and allows the function to be called from other endpoints like `checkAll`. It depends on `Site` and `ping` and inserts a record into the `checks` table in the `MonitorDB` database.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport {Site} from \"../site/site\";\n\n// Check checks a single site.\nexport const check = api(\n  { expose: true, method: \"POST\", path: \"/check/:siteID\" },\n  async (p: { siteID: number }): Promise<{ up: boolean }> => {\n    const s = await site.get({ id: p.siteID });\n    return doCheck(s);\n  },\n);\n\nasync function doCheck(site: Site): Promise<{ up: boolean }> {\n  const { up } = await ping({ url: site.url });\n  await MonitorDB.exec`\n      INSERT INTO checks (site_id, up, checked_at)\n      VALUES (${site.id}, ${up}, NOW())\n  `;\n  return { up };\n}\n```\n\n----------------------------------------\n\nTITLE: Infrastructure Configuration for Self-Hosting in JSON\nDESCRIPTION: Defines infrastructure configuration for self-hosting the application, including database connection settings.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/uptime.md#2025-04-21_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"$schema\": \"https://encore.dev/schemas/infra.schema.json\",\n   \"sql_servers\": [\n      {\n         \"host\": \"my-db-host:5432\",\n         \"databases\": {\n            \"monitor\": {\n               \"username\": \"my-db-owner\",\n                \"password\": {\"$env\": \"DB_PASSWORD\"}\n            },\n            \"site\": {\n               \"username\": \"my-db-owner\",\n                \"password\": {\"$env\": \"DB_PASSWORD\"}\n            }\n         }\n      }\n   ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining API Function for Middleware in Encore - Go\nDESCRIPTION: This snippet defines an API function, 'API', which serves as a placeholder for defining service-specific middleware in Encore applications. It imports 'context' and does not currently implement functionality, returning nil, indicating successful execution. It identifies the necessary structuring for API endpoints.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/middlewaregen/testdata/basic.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n// Note: we need an API endpoint to be able to define service-specific middleware\n//encore:api\nfunc API(context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Defining a Configuration Struct with Generics in Go\nDESCRIPTION: This snippet defines a configuration struct `Config` that uses generics. The `Value` field has a type `T` specified at the struct level. It also shows how to load a configuration with `config.Load`.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/generic_top_level_type.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n    \"time\"\n\n\t\"encore.dev/config\"\n\t\"encore.dev/types/uuid\"\n)\n\ntype Config[T int] struct {\n    Value T `json:\"value,omitempty\"` // Some config\n}\n\nvar _ = config.Load[*Config[uint]]()\n```\n\n----------------------------------------\n\nTITLE: Implementing PubSub Subscription with Anonymous Handler and Publisher\nDESCRIPTION: Creates a subscription with an anonymous handler function and implements a publisher function DoStuff.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_duplicate_subscription_names.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage foo\n\nimport (\n    \"context\"\n    \"encore.dev/pubsub\"\n    \"test/shared\"\n)\n\nvar _ = pubsub.NewSubscription(\n    shared.BasicTopic,\n    \"same-name\",\n    pubsub.SusbcriptionConfig { Handler: func(ctx context.Context, msg *shared.MessageType) error {\n        return nil\n    }},\n)\n\n// encore:api\nfunc DoStuff(ctx context.Context) error {\n    shared.BasicTopic.Publish(ctx, &shared.MessageType{Name: \"foo\"})\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Encore Docker Image Builds\nDESCRIPTION: These bash commands illustrate how to use the 'encore build docker' command to customize Docker image builds. It shows options for specifying services and gateways, as well as customizing the base image.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/ci-cd.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Build specific services and gateways\nencore build docker --services=service1,service2 --gateways=api-gateway MY-IMAGE:TAG\n\n# Customize the base image\nencore build docker --base=node:18-alpine MY-IMAGE:TAG\n```\n\n----------------------------------------\n\nTITLE: Defining an API Endpoint with Encore in Go\nDESCRIPTION: This snippet defines a simple API function, \"MyAPI\", using the Encore framework in Go. The function accepts a context parameter and returns an error. It doesn't perform any operations, simply returning nil, serving as a placeholder for further development. Key dependencies include the context package, and the function is intended to be used within Encore applications.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/cue_tags.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Request Validation Implementation - Express.js vs Encore.ts\nDESCRIPTION: Demonstrates request validation using Zod in Express.js compared to built-in validation in Encore.ts. Shows validation for headers, query params, and request body with error handling.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/migration/express-migration.md#2025-04-21_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport express, {NextFunction, Request, Response} from \"express\";\nimport {z, ZodError} from \"zod\";\n\nconst app: Express = express();\n\n// Request validation middleware\nfunction validateData(schemas: {\n  body: z.ZodObject<any, any>;\n  query: z.ZodObject<any, any>;\n  headers: z.ZodObject<any, any>;\n}) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    try {\n      // Validate headers\n      schemas.headers.parse(req.headers);\n\n      // Validate request body\n      schemas.body.parse(req.body);\n\n      // Validate query params\n      schemas.query.parse(req.query);\n\n      next();\n    } catch (error) {\n      if (error instanceof ZodError) {\n        const errorMessages = error.errors.map((issue: any) => ({\n          message: `${issue.path.join(\".\")} is ${issue.message}`,\n        }));\n        res.status(400).json({error: \"Invalid data\", details: errorMessages});\n      } else {\n        res.status(500).json({error: \"Internal Server Error\"});\n      }\n    }\n  };\n}\n\n// Request body validation schemas\nconst bodySchema = z.object({\n  someKey: z.string().optional(),\n  someOtherKey: z.number().optional(),\n  requiredKey: z.array(z.number()),\n  nullableKey: z.number().nullable().optional(),\n  multipleTypesKey: z.union([z.boolean(), z.number()]).optional(),\n  enumKey: z.enum([\"John\", \"Foo\"]).optional(),\n});\n\n// Query string validation schemas\nconst queryStringSchema = z.object({\n  name: z.string().optional(),\n});\n\n// Headers validation schemas\nconst headersSchema = z.object({\n  \"x-foo\": z.string().optional(),\n});\n\n// Request validation example using Zod\napp.post(\n  \"/validate\",\n  validateData({\n    headers: headersSchema,\n    body: bodySchema,\n    query: queryStringSchema,\n  }),\n  (_: Request, res: Response) => {\n    res.json({message: \"Validation succeeded\"});\n  },\n);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport {api, Header, Query} from \"encore.dev/api\";\n\nenum EnumType {\n  FOO = \"foo\",\n  BAR = \"bar\",\n}\n\n// Encore.ts automatically validates the request schema and returns and error\n// if the request does not match the schema.\ninterface RequestSchema {\n  foo: Header<\"x-foo\">;\n  name?: Query<string>;\n\n  someKey?: string;\n  someOtherKey?: number;\n  requiredKey: number[];\n  nullableKey?: number | null;\n  multipleTypesKey?: boolean | number;\n  enumKey?: EnumType;\n}\n\n// Validate a request\nexport const schema = api(\n  {expose: true, method: \"POST\", path: \"/validate\"},\n  (data: RequestSchema): { message: string } => {\n    console.log(data);\n    return {message: \"Validation succeeded\"};\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Downloading Files from Object Storage in TypeScript\nDESCRIPTION: This snippet retrieves a file from an object storage bucket using Encore's `download` method. It illustrates how to access stored files with options for specifying versioning. The primary input is the file name, and the output is the file data, which can be processed further as needed. The method provides flexible download management of stored objects in a bucket.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/object-storage.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst data = await profilePictures.download(\"my-image.jpeg\");\n```\n\n----------------------------------------\n\nTITLE: Publishing Events to a Topic in TypeScript\nDESCRIPTION: This snippet shows how to publish events to a predefined Pub/Sub topic. It illustrates capturing the message ID for tracking the published event.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/pubsub.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst messageID = await signups.publish({userID: id});\n\n// If we get here the event has been successfully published,\n// and all registered subscribers will receive the event.\n// The messageID variable contains the unique id of the message,\n// which is also provided to the subscribers when processing the event.\n```\n\n----------------------------------------\n\nTITLE: Passing Data from Middleware to API Handler in Encore.ts\nDESCRIPTION: This code snippet illustrates how to pass data from a middleware function to an API handler using `req.data`. The middleware assigns a value to `req.data`, which can then be accessed in the API handler using `currentRequest()` to retrieve the data through `callMeta.middlewareData`. This allows for passing contextual information or computed values from the middleware to the handler.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/middleware.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst mw = middleware(async (req, next) => {\n  // Assign a value to the request\n  req.data.myMiddlewareData = { some: \"data\" };\n\n  return await next(req);\n});\n\nexport const ep = api(\n  { expose: true, method: \"GET\", path: \"/endpoint\" },\n  async () => {\n    const callMeta = currentRequest() as APICallMeta;\n\n    // Access the value in the API handler\n    const myData = callMeta.middlewareData?.myMiddlewareData;\n    // Use the data as needed\n  },\n);\n\n```\n\n----------------------------------------\n\nTITLE: Creating package.json for Encore GraphQL API Setup - TypeScript\nDESCRIPTION: A sample package.json configuration required for setting up a GraphQL API with Encore in TypeScript. It includes project metadata, scripts, and dependencies needed for GraphQL development.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/graphql.mdx#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"encore-graphql\",\n  \"private\": true,\n  \"version\": \"0.0.1\",\n  \"license\": \"MPL-2.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"generate\": \"graphql-codegen --config codegen.yml\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.5.7\",\n    \"typescript\": \"^5.2.2\",\n    \"@graphql-codegen/cli\": \"2.16.5\",\n    \"@graphql-codegen/typescript\": \"2.8.8\",\n    \"@graphql-codegen/typescript-resolvers\": \"2.7.13\"\n  },\n  \"dependencies\": {\n    \"@apollo/server\": \"^4.11.0\",\n    \"encore.dev\": \"^1.35.3\",\n    \"graphql\": \"^16.9.0\",\n    \"graphql-tag\": \"^2.12.6\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Encore Service Implementation\nDESCRIPTION: Go implementation of an Encore service with a regular API endpoint and fallback handler. Includes a Response struct and two HTTP handlers - one for a specific route and another as a catch-all fallback.\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/fallback_routes.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"net/http\"\n)\n\n//encore:api public raw path=/!fallback\nfunc Fallback(w http.ResponseWriter, req *http.Request) {\n    w.Write([]byte(`{\"fallback\": true}`))\n}\n\ntype Response struct {\n    Message string\n}\n\n//encore:api public method=GET path=/v1/regular\nfunc Regular(ctx context.Context) (*Response, error) {\n    return &Response{Message: \"Hello, Encore world!\"}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ent Schema for User Service in Go\nDESCRIPTION: Command to generate a user schema and ent directory structure within an Encore service.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/entgo-orm.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ go run entgo.io/ent/cmd/ent@latest new --target user/ent/schema User\n```\n\n----------------------------------------\n\nTITLE: Defining Library Config Structure in Go\nDESCRIPTION: Defines a LibraryConfig struct in a shared library package that uses various config types including config.String, config.Bool, and config.Value for a slice of integers.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/config.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage shared\n\nimport (\n    \"encore.dev/config\"\n)\n\ntype LibraryConfig struct {\n    Name    config.String\n    Enabled config.Bool\n    ValueList config.Value[[]int]\n    List []int\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Database with sqldb in Go\nDESCRIPTION: Prepares a database query setup using Encores 'sqldb' package in a unit test context. This snippet requires the 'context' and 'encore.dev/storage/sqldb' packages. It defines a variable 'Moo' that names a specific service for SQL operations.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_outside_svc_test.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage pkg\n\nimport (\n    \"context\"\n\n    \"encore.dev/storage/sqldb\"\n)\n\nvar Moo = sqldb.Named(\"svc\")\n```\n\n----------------------------------------\n\nTITLE: Defining PubSub Topic and Message Type in Go\nDESCRIPTION: This snippet defines a MessageType struct and creates a PubSub topic named 'basic' using Encore.dev's pubsub package. The topic is configured with at-least-once delivery guarantee and ordering based on the 'user_id' attribute.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_publish_in_middleware.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/pubsub\"\n)\n\ntype MessageType struct {\n    UserID int64 `pubsub-attr:\"user_id\"`\n    Name string\n}\n\nvar (\n    BasicTopic = pubsub.NewTopic[*MessageType](\"basic\", pubsub.TopicConfig{\n        DeliveryGuarantee: pubsub.AtLeastOnce,\n        OrderingAttribute: \"user_id\",\n    })\n)\n```\n\n----------------------------------------\n\nTITLE: Updating Cowsay Function with Request Verification in Go\nDESCRIPTION: Updated Go function for the Cowsay Slack command, now including request verification and proper form value parsing.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/slack-bot.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public raw path=/cowsay\nfunc Cowsay(w http.ResponseWriter, req *http.Request) {\n\tbody, err := verifyRequest(req)\n\tif err != nil {\n\t\terrs.HTTPError(w, err)\n\t\treturn\n\t}\n\tq, _ := url.ParseQuery(string(body))\n\ttext := q.Get(\"text\")\n\tdata, _ := json.Marshal(map[string]string{\n\t\t\"response_type\": \"in_channel\",\n\t\t\"text\":          fmt.Sprintf(cowart, text),\n\t})\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(200)\n\tw.Write(data)\n}\n```\n\n----------------------------------------\n\nTITLE: Making Script Executable and Running Migration\nDESCRIPTION: This shell command makes the `generate-migration` script executable and then runs it to generate an initial migration.  It changes the current directory to blog before executing the script.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/atlas-gorm.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n\"$ chmod +x blog/scripts/generate-migration\n$ cd blog && ./scripts/generate-migration init\"\n```\n\n----------------------------------------\n\nTITLE: Rejecting Authentication\nDESCRIPTION: This code snippet demonstrates how to reject an authentication attempt by throwing an exception with a specific error message.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nthrow APIError.unauthenticated(\"bad credentials\");\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic API Function in Go\nDESCRIPTION: This snippet implements a basic API function 'MyAPI' which accepts a context and returns an error. Currently, it simply returns 'nil', indicating no error. This function serves as a placeholder for future API logic.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_with_cue_imports.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Simple API Method Definition\nDESCRIPTION: Defines a minimal API method with Encore's API annotation, accepting a context and returning an error\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/cue_tags.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Monitor Check Endpoint\nDESCRIPTION: TypeScript implementation of the monitor service check endpoint using raw SQL queries\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\nimport { SQLDatabase } from \"encore.dev/storage/sqldb\";\nimport { ping } from \"./ping\";\nimport { site } from \"~encore/clients\";\n\nexport const check = api(\n  { expose: true, method: \"POST\", path: \"/check/:siteID\" },\n  async (p: { siteID: number }): Promise<{ up: boolean }> => {\n    const s = await site.get({ id: p.siteID });\n    const { up } = await ping({ url: s.url });\n    await MonitorDB.exec`\n        INSERT INTO checks (site_id, up, checked_at)\n        VALUES (${s.id}, ${up}, NOW())\n    `;\n    return { up };\n  },\n);\n\nexport const MonitorDB = new SQLDatabase(\"monitor\", {\n  migrations: \"./migrations\",\n});\n```\n\n----------------------------------------\n\nTITLE: Defining an API Endpoint with Tags in Go with Encore\nDESCRIPTION: This snippet shows how to define an API endpoint with a tag, which can be used for targeting specific middleware. It uses the //encore:api directive with a 'cache' tag.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/middleware.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public method=GET path=/user/:id tag:cache\nfunc GetUser(ctx context.Context, id string) (*User, error) {\n\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Pub/Sub Subscription in Go with Encore\nDESCRIPTION: This snippet creates a subscription to the previously defined topic \"topic\". It defines a handler function that takes a context and an event as input and returns an error. The current handler function simply returns nil, indicating successful processing.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/pubsubgen/testdata/basic.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nvar _ = pubsub.NewSubscription(Topic, \"subscription\",\n    pubsub.SubscriptionConfig[*Event]{\n        Handler: func(ctx context.Context, event *Event) error {\n            return nil\n        },\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Declaring Infrastructure Semantics with Encore.go\nDESCRIPTION: This snippet shows how to use Encore.go to declare the infrastructure semantics directly in your application code. Encore then automatically provisions the necessary infrastructure in your cloud.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/other/vs-heroku.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n\"[Encore.go](/docs/go)\"\n```\n\n----------------------------------------\n\nTITLE: Defining an Encore API Endpoint\nDESCRIPTION: This snippet defines a public API function named Foo using the Encore framework, accepting a context parameter. It does not perform any operations other than returning nil, serving primarily as a placeholder or a minimal example of an API endpoint in Go with Encore.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/basic.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage basic\n\nimport \"context\"\n\n//encore:api public\nfunc Foo(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Automatic Configuration Unmarshaler\nDESCRIPTION: This Go code defines automatically generated functions for unmarshaling configuration values into specific types, especially dealing with generics using Encore's configuration system. The functions, such as `encoreInternalTypeConfigUnmarshaler_generics_CfgType`, handle JSON decoding and take care of `config.Value` dynamic functions. It uses `jsoniter` for JSON parsing and `encore.dev/config` for Encore's configuration primitives.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/generics.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage generics\n\nimport (\n\t__etype \"encore.dev/appruntime/shared/etype\"\n\tconfig \"encore.dev/config\"\n\t\"fmt\"\n\tjsoniter \"github.com/json-iterator/go\"\n)\n\n/*\nThese functions are automatically generated and maintained by Encore to allow config values\nto be unmarshalled into the correct types. They are not intended to be used directly. They\nare automatically updated by Encore whenever you change the data types used within your\ncalls to config.Load[T]().\n*/\n\n// Concrete unmarshalers for all config.Load calls, including those using generic types.\n// These instances are used directly by calls to `config.Load[T]()`.\nvar (\n\tencoreInternalConfigUnmarshaler_ptr_examplecom_CfgType_uint_ = func(itr *jsoniter.Iterator, path []string) *CfgType[uint] {\n\t\treturn func() *CfgType[uint] {\n\t\t\t// If the value is null, we return nil\n\t\t\tif itr.ReadNil() {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Otherwise we unmarshal the value and return a pointer to it\n\t\t\tobj := encoreInternalTypeConfigUnmarshaler_generics_CfgType[uint](func(itr *jsoniter.Iterator, path []string) uint {\n\t\t\t\treturn itr.ReadUint()\n\t\t\t})(itr, append(path))\n\t\t\treturn &obj\n\t\t}()\n\t}\n)\n\n// encoreInternalTypeConfigUnmarshaler_generics_CfgType will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_generics_CfgType[T any](_T_unmarshaler config.Unmarshaler[T]) (concreteUnmarshaler config.Unmarshaler[CfgType[T]]) {\n\treturn func(itr *jsoniter.Iterator, path []string) (obj CfgType[T]) {\n\t\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\t\tswitch field {\n\t\t\tcase \"ReadOnlyMode\":\n\t\t\t\tobj.ReadOnlyMode = config.CreateValue[bool](itr.ReadBool(), append(path, \"ReadOnlyMode\"))\n\t\t\tcase \"PublicKey\":\n\t\t\t\tobj.PublicKey = config.CreateValue[[]byte](func() (rtn []byte) {\n\t\t\t\t\tdecoder := new(__etype.Unmarshaller)\n\t\t\t\t\trtn = __etype.UnmarshalOne(decoder, __etype.UnmarshalBytes, \"value\", itr.ReadString(), true)\n\t\t\t\t\tif err := decoder.Error; err != nil {\n\t\t\t\t\t\tpanic(fmt.Sprintf(\"unable to decode the config: %v\", err))\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}(), append(path, \"PublicKey\"))\n\t\t\tcase \"AdminUsers\":\n\t\t\t\tobj.AdminUsers = config.CreateValueList(config.ReadArray[string](itr, func(itr *jsoniter.Iterator, idx int) string {\n\t\t\t\t\treturn itr.ReadString()\n\t\t\t\t}), append(path, \"AdminUsers\"))\n\t\t\tcase \"SubConfig\":\n\t\t\t\tobj.SubConfig = config.CreateValue[struct {\n\t\t\t\t\tSubKey *SubCfgType[T]\n\t\t\t\t}](func() (obj struct {\n\t\t\t\t\tSubKey *SubCfgType[T]\n\t\t\t\t}) {\n\t\t\t\t\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\t\t\t\t\tswitch field {\n\t\t\t\t\t\tcase \"SubKey\":\n\t\t\t\t\t\t\tobj.SubKey = func() *SubCfgType[T] {\n\t\t\t\t\t\t\t\t// If the value is null, we return nil\n\t\t\t\t\t\t\t\tif itr.ReadNil() {\n\t\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Otherwise we unmarshal the value and return a pointer to it\n\t\t\t\t\t\t\t\tobj := encoreInternalTypeConfigUnmarshaler_generics_SubCfgType[T](func(itr *jsoniter.Iterator, path []string) T {\n\t\t\t\t\t\t\t\t\treturn _T_unmarshaler(itr, append(path))\n\t\t\t\t\t\t\t\t})(itr, append(path, \"SubKey\"))\n\t\t\t\t\t\t\t\treturn &obj\n\t\t\t\t\t\t\t}()\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\titr.Skip()\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}(), append(path, \"SubConfig\"))\n\t\t\tcase \"Currencies\":\n\t\t\t\tobj.Currencies = config.ReadMap[string, struct {\n\t\t\t\t\tName    config.Value[string]\n\t\t\t\t\tCode    config.Value[string]\n\t\t\t\t\tAliases config.Values[string]\n\t\t\t\t}](itr, func(itr *jsoniter.Iterator, keyAsString string) (string, struct {\n\t\t\t\t\tName    config.Value[string]\n\t\t\t\t\tCode    config.Value[string]\n\t\t\t\t\tAliases config.Values[string]\n\t\t\t\t}) {\n\t\t\t\t\t// Decode the map key from the JSON string to the underlying type it needs to be\n\t\t\t\t\tkeyDecoder := new(__etype.Unmarshaller)\n\t\t\t\t\tkey := __etype.UnmarshalOne(keyDecoder, __etype.UnmarshalString, \"keyAsString\", keyAsString, true)\n\t\t\t\t\tif err := keyDecoder.Error; err != nil {\n\t\t\t\t\t\tpanic(fmt.Sprintf(\"unable to decode the config: %v\", err))\n\t\t\t\t\t}\n\t\t\t\t\treturn key, func() (obj struct {\n\t\t\t\t\t\tName    config.Value[string]\n\t\t\t\t\t\tCode    config.Value[string]\n\t\t\t\t\t\tAliases config.Values[string]\n\t\t\t\t\t}) {\n\t\t\t\t\t\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\t\t\t\t\t\tswitch field {\n\t\t\t\t\t\t\tcase \"Name\":\n\t\t\t\t\t\t\t\tobj.Name = config.CreateValue[string](itr.ReadString(), append(path, \"Name\"))\n\t\t\t\t\t\t\tcase \"Code\":\n\t\t\t\t\t\t\t\tobj.Code = config.CreateValue[string](itr.ReadString(), append(path, \"Code\"))\n\t\t\t\t\t\t\tcase \"Aliases\":\n\t\t\t\t\t\t\t\tobj.Aliases = config.CreateValueList(config.ReadArray[string](itr, func(itr *jsoniter.Iterator, idx int) string {\n\t\t\t\t\t\t\t\t\treturn itr.ReadString()\n\t\t\t\t\t\t\t\t}), append(path, \"Aliases\"))\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\titr.Skip()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t})\n\t\t\t\t\t\treturn\n\t\t\t\t\t}()\n\t\t\t\t})\n\t\t\tcase \"AnotherList\":\n\t\t\t\tobj.AnotherList = config.CreateValueList(config.ReadArray[struct {\n\t\t\t\t\tName config.Value[string]\n\t\t\t\t}](itr, func(itr *jsoniter.Iterator, idx int) struct {\n\t\t\t\t\tName config.Value[string]\n\t\t\t\t} {\n\t\t\t\t\treturn func() (obj struct {\n\t\t\t\t\t\tName config.Value[string]\n\t\t\t\t\t}) {\n\t\t\t\t\t\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\t\t\t\t\t\tswitch field {\n\t\t\t\t\t\t\tcase \"Name\":\n\t\t\t\t\t\t\t\tobj.Name = config.CreateValue[string](itr.ReadString(), append(path, \"Name\"))\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\titr.Skip()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t})\n\t\t\t\t\t\treturn\n\t\t\t\t\t}()\n\t\t\t\t}), append(path, \"AnotherList\"))\n\t\t\tdefault:\n\t\t\t\titr.Skip()\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\t\treturn\n\t}\n}\n\n// encoreInternalTypeConfigUnmarshaler_generics_SubCfgType will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_generics_SubCfgType[T any](_T_unmarshaler config.Unmarshaler[T]) (concreteUnmarshaler config.Unmarshaler[SubCfgType[T]]) {\n\treturn func(itr *jsoniter.Iterator, path []string) (obj SubCfgType[T]) {\n\t\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\t\tswitch field {\n\t\t\tcase \"MaxCount\":\n\t\t\t\tobj.MaxCount = _T_unmarshaler(itr, append(path, \"MaxCount\"))\n\t\t\tdefault:\n\t\t\t\titr.Skip()\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\t\treturn\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Request Data Structures in Go\nDESCRIPTION: Defines data structures for handling request data and events in the service. Includes MyData for general data, Event for pubsub messages, and RequestData for API responses.\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/encore_currentrequest.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype MyData struct {\n    Name string\n}\n\ntype Event struct {\n    Data string\n}\n\ntype RequestData struct {\n    Path string\n    IdempotencyKey string\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Firebase Secret for Production Environment\nDESCRIPTION: Command to set the Firebase private key as a secret for the production environment using Encore CLI.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/firebase-auth.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ encore secret set --type prod FirebasePrivateKey < /path/to/firebase-private-key.json\nSuccessfully updated production secret FirebasePrivateKey\n```\n\n----------------------------------------\n\nTITLE: Cloud-Specific Service Implementation\nDESCRIPTION: Example of implementing different behaviors based on cloud provider using Encore metadata\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_29\n\nLANGUAGE: go\nCODE:\n```\nfunc Audit(ctx context.Context, action message, user auth.UID) error {\n    switch encore.Meta().Environment.Cloud {\n    case encore.CloudAWS:\n        return writeIntoRedshift(ctx, action, user)\n    case encore.CloudGCP:\n        return writeIntoBigQuery(ctx, action, user)\n    case encore.CloudLocal:\n        return writeIntoFile(ctx, action, user)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Encore GraphQL Service\nDESCRIPTION: Creates a new Encore service definition for the GraphQL API. This sets up the service configuration that Encore uses to understand the service boundaries.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/graphql.mdx#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Service } from \"encore.dev/service\";\n\nexport default new Service(\"graphql\");\n```\n\n----------------------------------------\n\nTITLE: Defining Service Configuration struct in Go\nDESCRIPTION: This snippet defines a `Config` struct to hold the service's configuration parameters.  It includes a nested `HTTP` struct with fields for enabling HTTP and specifying the port. The `encore.dev/config` package is used to load the configuration.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_inline_struct.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n)\n\ntype Config struct {\n    // The options for the HTTP server\n    HTTP struct {\n        Enabled bool // Is this option enabled?\n        Port    uint32 // What port should we run on?\n    }\n}\n\nvar _ = config.Load[*Config]()\n\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Resetting Databases for Services\nDESCRIPTION: The `encore db reset` command resets the databases associated with the specified services.  The `--all` flag resets all databases.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\n$ encore db reset [service-names...] [flags]\n```\n\n----------------------------------------\n\nTITLE: Unarchiving Secrets with Encore CLI\nDESCRIPTION: Command to unarchive a previously archived secret value by its identifier. Unarchiving makes the secret active again.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_46\n\nLANGUAGE: bash\nCODE:\n```\nencore secret unarchive id\n```\n\n----------------------------------------\n\nTITLE: Creating Schedules Table and Index in PostgreSQL\nDESCRIPTION: This SQL script creates a 'schedules' table to store schedule entries for users, including start and end timestamps, and an index to optimize lookups. PostgreSQL must be set up and accessible for executing this migration.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/incident-management-tool.md#2025-04-21_snippet_5\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE TABLE schedules\n(\n    id         BIGSERIAL PRIMARY KEY,\n    user_id    INTEGER   NOT NULL,\n    start_time TIMESTAMP NOT NULL,\n    end_time   TIMESTAMP NOT NULL\n);\n\nCREATE INDEX schedules_range_index ON schedules (start_time, end_time);\n```\n\n----------------------------------------\n\nTITLE: Streaming Encore Application Logs\nDESCRIPTION: Streams logs from the Encore application, with options to specify environment and output format.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\n$ encore logs [--env=prod] [--json]\n```\n\n----------------------------------------\n\nTITLE: Loading Config with Unmarshaler in Go\nDESCRIPTION: Illustrates how `config.Load` is used to load the configuration. The automatically generated unmarshaler `encoreInternalConfigUnmarshaler_ptr_svc_Config` is passed as an argument to convert the loaded configuration data into a `*Config` struct.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_config.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n\t\"encore.dev/types/uuid\"\n)\n\ntype Config struct {\n    Name        string    // The users name\n    Port        uint16\n    ReadOnly    bool      // true if we're in read only mode\n\n    // MagicNumber is complicated and requires\n    // a multi-line comment to explain it.\n    MagicNumber int\n\n    ID          uuid.UUID // An ID\n\n    PublicKey []byte\n}\n\nvar _ = config.Load[*Config](\"svc\", encoreInternalConfigUnmarshaler_ptr_svc_Config/*line :24:30*/)\n\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Encore Service\nDESCRIPTION: This snippet demonstrates how to create an Encore service by importing the Service class and exporting a new instance with a given name. This is foundational for structuring your Encore application.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/app-structure.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Service } from \"encore.dev/service\";\n\nexport default new Service(\"my-service\");\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Schema\nDESCRIPTION: This GraphQL schema defines the structure of the API, including queries for fetching URLs and mutations for shortening URLs.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/graphql.mdx#2025-04-21_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\ntype Query {\n  urls: [URL!]!\n  get(id: ID!): URL!\n}\n\ntype Mutation {\n  shorten(input: String!): URL!\n}\n\ntype URL {\n  id:  ID!     # shortened id\n  url: String! # full URL\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Events from a Topic in TypeScript\nDESCRIPTION: This snippet illustrates how to create a subscription to a Pub/Sub topic, including defining a handler function to process incoming events.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/pubsub.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Subscription } from \"encore.dev/pubsub\";\n\nconst _ = new Subscription(signups, \"send-welcome-email\", {\n    handler: async (event) => {\n        // Send a welcome email using the event.\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Datadog Metrics Configuration\nDESCRIPTION: Configuration for Datadog metrics collection including API key and collection interval\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"metrics\": {\n    \"type\": \"datadog\",\n    \"collection_interval\": 30,\n    \"site\": \"datadoghq.com\",\n    \"api_key\": {\n      \"$env\": \"DATADOG_API_KEY\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running an Application in a Specific Namespace using Encore CLI\nDESCRIPTION: This command runs the application using the context of the specified namespace 'my-ns'. It allows application execution within an isolated environment.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/infra-namespaces.md#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ encore run --namespace my-ns\n```\n\n----------------------------------------\n\nTITLE: Configuring Services with Encore in Go\nDESCRIPTION: This snippet defines a configuration structure in Go using the Encore framework. The \"Config\" struct includes fields A, B, and C, with fields B and C having CUE constraints based on mathematical expressions involving other fields. The configuration loads using Encore's config.Load function. There are no explicit parameters; dependencies include the Encore config package and the CUE expressions, which imply relationships between struct fields.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/cue_tags.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n    \"time\"\n\n\t\"encore.dev/config\"\n\t\"encore.dev/types/uuid\"\n)\n\ntype Config struct {\n    A int\n    B int `cue:\"A+C\"`\n    C int `cue:\"B-A\"`\n}\n\nvar _ = config.Load[*Config]()\n```\n\n----------------------------------------\n\nTITLE: Defining API endpoints with string parameters in Encore\nDESCRIPTION: This code defines an Encore API endpoint `/str/:p` that accepts a string parameter `p`. The `encore:api public path=/str/:p` annotation exposes the function as a public HTTP endpoint. The function `Str` takes a context and the string parameter as input and returns an error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_path_params.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\t\"encore.dev/types/uuid\"\n)\n\n//encore:api public path=/str/:p\nfunc Str(ctx context.Context, p string) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Extracted Microservice Implementation in Go\nDESCRIPTION: Demonstrates how to extract the H2 endpoint into a separate 'yo' service, showing the microservice structure after breaking up the monolith.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/break-up-monolith.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage yo\n\nimport (\n\t\"context\"\n)\n\n//encore:api public path=/yo/:name\nfunc H2(ctx context.Context, name string) (*Response, error) {\n\tmsg := \"Yo, \" + name + \"!\"\n\treturn &Response{Message: msg}, nil\n}\n\ntype Response struct {\n\tMessage string\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Default Values in CUE\nDESCRIPTION: Demonstrates how to set default boolean values and conditionally override them based on environment conditions\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/config.md#2025-04-21_snippet_5\n\nLANGUAGE: cue\nCODE:\n```\nReadOnlyMode: bool | *false\\n\\nif #Meta.Environment.Name == \"old-prod\" {\\n    ReadOnlyMode: true\\n}\n```\n\n----------------------------------------\n\nTITLE: Serving Files at Domain Root\nDESCRIPTION: This snippet illustrates how to serve files at the domain root using fallback routes. The '!path' syntax is used to avoid conflicts with other routes, allowing files in './assets' directory to be served properly.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nexport const assets = api.static(\n  { expose: true, path: \"/!path\", dir: \"./assets\" },\n);\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Temporal Client with Encore Config\nDESCRIPTION: Creates a configuration struct using Encore's config.Value with Temporal client options, supporting dynamic configuration loading\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/multi_package.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype Config struct {\n\tTemporal config.Value[temporal.ClientOptions]\n}\n\nvar cfg = config.Load[Config]()\n```\n\n----------------------------------------\n\nTITLE: Defining a Service with Pub/Sub Handlers in Go\nDESCRIPTION: This code defines an Encore service with two methods: `PointerMethod` and `NonPointerMethod`, which are intended to handle pub/sub events. It also defines an `Event` struct and a pub/sub topic named `Topic` using `encore.dev/pubsub`.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/pubsubgen/testdata/method_handler.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\t\"encore.dev/pubsub\"\n)\n\n//encore:service\ntype Service struct{}\n\nfunc (s *Service) PointerMethod(ctx context.Context, event *Event) error {\n    return nil\n}\n\nfunc (s Service) NonPointerMethod(ctx context.Context, event *Event) error {\n    return nil\n}\n\ntype Event struct {}\n\nvar Topic = pubsub.NewTopic[*Event](\"topic\", pubsub.TopicConfig{\n    DeliveryGuarantee: pubsub.AtLeastOnce,\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Temporal Client Options in Go\nDESCRIPTION: Defines a struct for Temporal client configuration with host port and namespace parameters\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/multi_package.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype ClientOptions struct {\n\tHostPort  string\n\tNamespace string\n}\n```\n\n----------------------------------------\n\nTITLE: Testing User Creation via cURL\nDESCRIPTION: Bash command to test the 'Create user' endpoint of the users service. It sends a POST request to the local server with JSON data to create a new user and expects a JSON response with user details.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/incident-management-tool.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncurl -d '{\n  \"FirstName\":\"Katy\",\n  \"LastName\":\"Smith\",\n  \"SlackHandle\":\"katy\"\n}' http://localhost:4000/users\n\n# Example JSON response\n# {\n#   \"Id\":1,\n#   \"FirstName\":\"Katy\",\n#   \"LastName\":\"Smith\",\n#   \"SlackHandle\":\"katy\"\n# }\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration with Unmarshaler in Go\nDESCRIPTION: This code snippet loads the service configuration using `config.Load` and assigns the custom unmarshaler function.  It connects the configuration struct to the unmarshaling logic, allowing Encore to properly populate the `Config` struct from external sources during service initialization. A custom name is also set using the first parameter.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_inline_struct.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n)\n\ntype Config struct {\n    // The options for the HTTP server\n    HTTP struct {\n        Enabled bool // Is this option enabled?\n        Port    uint32 // What port should we run on?\n    }\n}\n\nvar _ = config.Load[*Config](\"svc\", encoreInternalConfigUnmarshaler_ptr_svc_Config/*line :17:30*/)\n\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Raw HTTP Endpoints in Go\nDESCRIPTION: This snippet defines two raw HTTP endpoints, Foo and Bar, using Encore's `//encore:api` directive. The `Foo` endpoint attempts to define a custom path `/:foo`, while `Bar` relies on the default path generation. The snippet is part of a test case to verify path validation in Encore.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_raw_duplicate_path.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport \"net/http\"\n\n//encore:api public raw path=/:foo\nfunc Foo(w http.ResponseWriter, req *http.Request) { }\n\n//encore:api public raw\nfunc Bar(w http.ResponseWriter, req *http.Request) { }\n```\n\n----------------------------------------\n\nTITLE: Parsing Webhook Events in Go\nDESCRIPTION: This code snippet demonstrates how to parse a webhook event using the `go.encore.dev/webhooks` library. It receives an HTTP request, reads the request body, parses the event, and then handles different event types using a switch statement. The code relies on the `EncoreWebhookSecret` to validate the signature.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/integrations/webhooks.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n```go\npackage service\n\nimport (\n    \"net/http\"\n\n    \"go.encore.dev/webhooks\"\n)\n\nvar secrets struct {\n\tEncoreWebhookSecret string\n}\n\n//encore:api public raw\nfunc Webhook(w http.ResponseWriter, req *http.Request) {\n\tpayload, err := io.ReadAll(req.Body)\n\tif err != nil{\n\t\t// ... handle error\n    }\n    event, err := webhooks.ParseEvent(payload, req.Header.Get(\"X-Encore-Signature\"), secrets.EncoreWebhookSecret)\n    if err != nil {\n        // ... handle error\n    }\n\n    switch data := event.Data.(type) {\n    case *webhooks.RolloutCreatedEvent:\n        // ... handle rollout created event\n    case *webhooks.RolloutCompletedEvent:\n        // ... handle rollout completed event\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Pushing Docker Image to DigitalOcean Registry\nDESCRIPTION: This snippet demonstrates how to tag and push a Docker image to DigitalOcean's container registry. It requires the DigitalOcean CLI for login and the Docker software for tagging and pushing the image. The commands first log into the registry, tag the Docker image with the registry URL, and then push the image to the container registry.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/deploy-to-digital-ocean.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndoctl registry login\n```\n\nLANGUAGE: bash\nCODE:\n```\ndocker tag myapp registry.digitalocean.com/YOUR_REGISTRY_NAME/myapp:latest\n```\n\nLANGUAGE: bash\nCODE:\n```\ndocker push registry.digitalocean.com/YOUR_REGISTRY_NAME/myapp:latest\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic API Service in Go\nDESCRIPTION: Defines a basic service package with a Params struct and a public API endpoint Foo\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/response_params.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage basic\n\nimport \"context\"\n\ntype Params struct {\n    String string\n    Int int\n}\n\n//encore:api public\nfunc Foo(ctx context.Context) (*Params, error) { return nil, nil }\n```\n\n----------------------------------------\n\nTITLE: Authenticating with Auth Key using Encore CLI\nDESCRIPTION: This snippet demonstrates how to authenticate with the Encore CLI using an auth key. Replace `ena_nEQIkfeM43t7oxpleMsIULbhbtLAbYnnLf1D` with your actual auth key.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/integrations/auth-keys.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ encore auth login --auth-key=ena_nEQIkfeM43t7oxpleMsIULbhbtLAbYnnLf1D\n```\n\n----------------------------------------\n\nTITLE: Deploying with Encore Cloud's Managed Git\nDESCRIPTION: These commands demonstrate how to deploy your application using Encore Cloud's managed git repository. It involves adding changes, committing, and pushing to the 'encore' remote.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/deploy/deploying.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ git add -A .\n$ git commit -m 'Commit message'\n$ git push encore\n```\n\n----------------------------------------\n\nTITLE: Adding Client Generation Scripts to package.json\nDESCRIPTION: Example of adding scripts to package.json for generating Encore request clients for different environments, making it easy to update the client when API changes occur.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/integrate-frontend.mdx#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n...\n\"scripts\": {\n    ...\n    \"generate-client:staging\": \"encore gen client <ENCORE-APP-ID> --output=./src/client.ts --env=staging\",\n    \"generate-client:local\": \"encore gen client <ENCORE-APP-ID> --output=./src/client.ts --env=local\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Log Contexts in Go with Encore's rlog Package\nDESCRIPTION: Shows how to use rlog.With() to create a log context with shared key-value pairs, simplifying repeated logging with common attributes.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/observability/logging.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nctx := rlog.With(\"is_subscriber\", true)\nctx.Info(\"user logged in\", \"login_method\", \"oauth\") // includes is_subscriber=true\n```\n\n----------------------------------------\n\nTITLE: Implementing Incident Assignment and Cron Job in Go\nDESCRIPTION: Implementation of an endpoint to assign incidents and a cron job to automatically assign unassigned incidents to on-call users.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/incident-management-tool.md#2025-04-21_snippet_11\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public method=PUT path=/incidents/:id/assign\nfunc Assign(ctx context.Context, id int32, params *AssignParams) (*Incident, error) {\n\teb := errs.B().Meta(\"params\", params)\n\trows, err := db.Query(ctx, `\n\t\tUPDATE incidents\n\t\tSET assigned_user_id = $1\n\t\tWHERE acknowledged_at IS NULL\n\t\t  AND id = $2\n\t\tRETURNING id, assigned_user_id, body, created_at, acknowledged_at\n\t`, params.UserId, id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tincidents, err := RowsToIncidents(ctx, rows)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif incidents.Items == nil {\n\t\treturn nil, eb.Code(errs.NotFound).Msg(\"no incident found\").Err()\n\t}\n\n\tincident := &incidents.Items[0]\n\t_ = slack.Notify(ctx, &slack.NotifyParams{\n\t\tText: fmt.Sprintf(\"Incident #%d is re-assigned to %s %s <@%s>\\n%s\", incident.Id, incident.Assignee.FirstName, incident.Assignee.LastName, incident.Assignee.SlackHandle, incident.Body),\n\t})\n\n\treturn incident, err\n}\n\ntype AssignParams struct {\n\tUserId int32\n}\n\nvar _ = cron.NewJob(\"assign-unassigned-incidents\", cron.JobConfig{\n\tTitle:    \"Assign unassigned incidents to user on-call\",\n\tEvery:    1 * cron.Minute,\n\tEndpoint: AssignUnassignedIncidents,\n})\n\n//encore:api private\nfunc AssignUnassignedIncidents(ctx context.Context) error {\n\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Lazy Database Connection Pool with Encore\nDESCRIPTION: Go implementation for lazily initializing a connection pool to an external PostgreSQL database. The code uses pgx for the connection, syncutil for thread-safe initialization, and Encore's secrets manager for storing sensitive credentials.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/connect-existing-db.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage externaldb\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    \"github.com/jackc/pgx/v4/pgxpool\"\n    \"go4.org/syncutil\"\n)\n\n// Get returns a database connection pool to the external database.\n// It is lazily created on first use.\nfunc Get(ctx context.Context) (*pgxpool.Pool, error) {\n    // Attempt to setup the database connection pool if it hasn't\n    // already been successfully setup.\n    err := once.Do(func() error {\n        var err error\n        pool, err = setup(ctx)\n        return err\n    })\n    return pool, err\n}\n\nvar (\n    // once is like sync.Once except it re-arms itself on failure\n    once syncutil.Once\n    // pool is the successfully created database connection pool,\n    // or nil when no such pool has been setup yet.\n    pool *pgxpool.Pool\n)\n\nvar secrets struct {\n    // ExternalDBPassword is the database password for authenticating\n    // with the external database hosted on DigitalOcean.\n    ExternalDBPassword string\n}\n\n// setup attempts to set up a database connection pool.\nfunc setup(ctx context.Context) (*pgxpool.Pool, error) {\n    connString := fmt.Sprintf(\"postgresql://%s:%s@externaldb-do-user-1234567-0.db.ondigitalocean.com:25010/externaldb?sslmode=require\",\n        \"user\", secrets.ExternalDBPassword)\n    return pgxpool.Connect(ctx, connString)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Config struct in Go\nDESCRIPTION: This code defines a configuration struct named `Config` with nested structs for different options, like HTTP server settings.  It uses `encore.dev/config` to automatically load configurations from environment variables or other sources.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_inline_struct.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n    \"time\"\n\n\t\"encore.dev/config\"\n\t\"encore.dev/types/uuid\"\n)\n\ntype Config struct {\n    // The options for the HTTP server\n    HTTP struct {\n        Enabled bool // Is this option enabled?\n        Port    uint32 // What port should we run on?\n    }\n}\n\nvar _ = config.Load[*Config]()\n```\n\n----------------------------------------\n\nTITLE: Defining Config struct in Go\nDESCRIPTION: Defines a `Config` struct with various fields including string, uint16, bool, int, uuid.UUID and byte array to represent different config parameters. This configuration is loaded using `config.Load`.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_config.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n\t\"encore.dev/types/uuid\"\n)\n\ntype Config struct {\n    Name        string    // The users name\n    Port        uint16\n    ReadOnly    bool      // true if we're in read only mode\n\n    // MagicNumber is complicated and requires\n    // a multi-line comment to explain it.\n    MagicNumber int\n\n    ID          uuid.UUID // An ID\n\n    PublicKey []byte\n}\n\nvar _ = config.Load[*Config]()\n\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Prometheus Metrics Configuration\nDESCRIPTION: Configuration for Prometheus metrics collection and remote write endpoint\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"metrics\": {\n    \"type\": \"prometheus\",\n    \"collection_interval\": 15,\n    \"remote_write_url\": {\n      \"$env\": \"PROMETHEUS_REMOTE_WRITE_URL\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple API Endpoint in Go\nDESCRIPTION: This snippet defines a simple API endpoint named `Foo` using Encore's `//encore:api` annotation. The function takes a context and returns an error, serving as a basic example for defining API endpoints within the Encore framework.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/auth_handler.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport (\"context\"; \"encore.dev/beta/auth\")\n\n//encore:api\nfunc Foo(ctx context.Context) error { return nil }\n\ntype MyAuthData struct { Username string }\n\n//encore:authhandler\nfunc AuthHandler(context.Context, string) (auth.UID, *MyAuthData, error) {\n    return \"\", nil, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration with Encore (Go)\nDESCRIPTION: This snippet defines a Config struct and uses Encore's config.Load function to load configuration values of type Config. It initializes the configuration with default values and dynamically assigns types.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_lists.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\t\n\t\"encore.dev/config\"\n)\n\ntype Config struct {\n    Ages      []int32\n    OtherBits []string\n}\n\nvar _ = config.Load[*Config]()\n\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Testing API Call Authentication Override in Go\nDESCRIPTION: Test cases for verifying authentication data propagation in API calls and context-based auth overrides\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/et_override_user_authdata.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc TestOverrideAuthInfo_PropagatesToAPICalls(t *testing.T) {\n    resp, err := GetUser(context.Background())\n    if err != nil {\n        t.Fatal(err)\n    } else if resp.Data != nil {\n        t.Fatalf(\"got data %+v, want nil\", resp.Data)\n    }\n\n    et.OverrideAuthInfo(\"foo\", &AuthData{\"email\"})\n\n    resp, err = GetUser(context.Background())\n    if err != nil {\n        t.Fatal(err)\n    } else if resp.Data == nil || resp.Data.Email != \"email\" {\n        t.Fatalf(\"got data %+v, want %+v\", resp.Data, &AuthData{\"email\"})\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Database Proxy\nDESCRIPTION: The `encore db proxy` command establishes a local proxy to forward connections to databases within a specified environment. The environment is specified using the `--env` flag.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\n$ encore db proxy [--env=<name>] [flags]\n```\n\n----------------------------------------\n\nTITLE: Service-Level Tagged Middleware Implementation\nDESCRIPTION: Implements service-level middleware targeting endpoints tagged with 'foo', passing through requests unmodified\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/middleware.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:middleware target=tag:foo\nfunc TaggedInSvc(req middleware.Request, next middleware.Next) middleware.Response {\n    return next(req)\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Package-Level API Mocks in Encore\nDESCRIPTION: Demonstrates how to configure API mocks at the package level using TestMain. This approach applies the mock to all tests in the package rather than just a single test.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_34\n\nLANGUAGE: go\nCODE:\n```\nfunc TestMain(m *testing.M) {\n    et.MockEndpoint(products.GetPrice, func(ctx context.Context, p *products.PriceParams) (*products.PriceResponse, error) {\n        return &products.PriceResponse{Price: 100}, nil\n    })\n    os.Exit(m.Run())\n}\n```\n\n----------------------------------------\n\nTITLE: Creating SQL Migration for Note Table\nDESCRIPTION: SQL migration script to create the 'note' table in the database.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/meeting-notes.mdx#2025-04-21_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE note (\n\tid TEXT PRIMARY KEY,\n\ttext TEXT,\n\tcover_url TEXT\n);\n```\n\n----------------------------------------\n\nTITLE: Declaring an Encore API Endpoint in Go\nDESCRIPTION: This snippet defines an Encore API endpoint using a function with the 'encore:api' directive. It specifies a public POST method that takes a context and a pointer to Params as arguments.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_invalid_header_type.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n//encore:api public method=POST\nfunc Str(ctx context.Context, p *Params) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Complete Infrastructure Configuration Example\nDESCRIPTION: Full example of an infrastructure configuration file showing all major components including metadata, SQL servers, service discovery, Redis, metrics, and more\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"$schema\": \"https://encore.dev/schemas/infra.schema.json\",\n  \"metadata\": {\n    \"app_id\": \"my-app\",\n    \"env_name\": \"my-env\",\n    \"env_type\": \"production\",\n    \"cloud\": \"gcp\",\n    \"base_url\": \"https://my-app.com\"\n  },\n  \"sql_servers\": [\n    {\n      \"host\": \"my-db-host:5432\",\n      \"databases\": {\n        \"my-db\": {\n          \"username\": \"my-db-owner\",\n          \"password\": {\"$env\": \"DB_PASSWORD\"}\n        }\n      }\n    }\n  ],\n  \"service_discovery\": {\n    \"myservice\": {\n      \"base_url\": \"https://myservice:8044\"\n    }\n  },\n  \"redis\": {\n    \"encoreredis\": {\n      \"database_index\": 0,\n      \"auth\": {\n        \"type\": \"acl\",\n        \"username\": \"encoreredis\",\n        \"password\": {\"$env\": \"REDIS_PASSWORD\"}\n      },\n      \"host\": \"my-redis-host\"\n    }\n  },\n  \"metrics\": {\n    \"type\": \"prometheus\",\n    \"remote_write_url\": \"https://my-remote-write-url\"\n  },\n  \"graceful_shutdown\": {\n    \"total\": 30\n  },\n  \"auth\": [\n    {\n      \"type\": \"key\",\n      \"id\": 1,\n      \"key\": {\"$env\": \"SVC_TO_SVC_KEY\"}\n    }\n  ],\n  \"secrets\": {\n    \"AppSecret\": {\"$env\": \"APP_SECRET\"}\n  },\n  \"pubsub\": [\n    {\n      \"type\": \"gcp_pubsub\",\n      \"project_id\": \"my-project\",\n      \"topics\": {\n        \"encore-topic\": {\n          \"name\": \"gcp-topic-name\",\n          \"subscriptions\": {\n            \"encore-subscription\": {\n              \"name\": \"gcp-subscription-name\"\n            }\n          }\n        }\n      }\n    }\n  ],\n  \"object_storage\": [\n    {\n      \"type\": \"gcs\",\n      \"buckets\": {\n          \"my-gcs-bucket\": {\n            \"name\": \"my-gcs-bucket\"\n          }\n        }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Pubsub Topic and API Endpoint in Go with Encore\nDESCRIPTION: Creates a pubsub Topic with AtLeastOnce delivery guarantee and a dummy API endpoint. The code defines a Msg struct that will be published to the Topic and exposes a minimal API endpoint.\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/pubsub_ref.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"encore.dev/pubsub\"\n)\n\ntype Msg struct{Message string}\n\nvar Topic = pubsub.NewTopic[Msg](\"topic\", pubsub.TopicConfig{DeliveryGuarantee: pubsub.AtLeastOnce})\n\n//encore:api\nfunc Dummy(context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Pushing Docker Image to the Registry - Bash\nDESCRIPTION: This snippet demonstrates how to push the tagged Docker image to the DigitalOcean container registry for deployment.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/deploy-to-digital-ocean-wip.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndocker push registry.digitalocean.com/YOUR_REGISTRY_NAME/myapp:latest\n```\n\n----------------------------------------\n\nTITLE: Re-enabling Telemetry via CLI Command\nDESCRIPTION: Shell command to re-enable telemetry collection after previously disabling it\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/management/telemetry.md#2025-04-21_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nencore telemetry enable\n```\n\n----------------------------------------\n\nTITLE: Defining Database References in Encore\nDESCRIPTION: Demonstrates two approaches for sharing databases between services in Encore: using exported variables in shared modules or using named database references. Both methods achieve the same result but differ in explicitness.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/databases.md#2025-04-21_snippet_10\n\nLANGUAGE: text\nCODE:\n```\nnew SQLDatabase(\"name\", ...)\nSQLDatabase.named(\"name\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Multi-Field Cache Key with Struct in Go using Encore\nDESCRIPTION: Shows how to define a struct-based cache key to track requests per user and resource path. The cache pattern references multiple struct fields in the key pattern and values expire after 10 seconds of inactivity.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/caching.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype MyKey struct {\n    UserID auth.UID\n    ResourcePath string // the resource being accessed\n}\n\n// ResourceRequestsPerUser tracks the number of requests per user and resource.\n// The cache items expire after 10 seconds without activity.\nvar ResourceRequestsPerUser = cache.NewIntKeyspace[MyKey](cluster, cache.KeyspaceConfig{\n\tKeyPattern:    \"requests/:UserID/:ResourcePath\",\n\tDefaultExpiry: cache.ExpireIn(10 * time.Second),\n})\n\n// ... then:\nkey := MyKey{UserID: \"some-user-id\", ResourcePath: \"/foo\"}\nResourceRequestsPerUser.Increment(ctx, key, 1)\n```\n\n----------------------------------------\n\nTITLE: Deploying to Encore Cloud (Shell)\nDESCRIPTION: This set of shell commands deploys the application to Encore Cloud. It first adds all changes to the Git repository, commits them with a message, and then pushes the changes to the `encore` remote. This triggers Encore's CI/CD pipeline to build, test, provision infrastructure, and deploy the application.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\n$ git add -A .\n$ git commit -m 'Initial commit'\n$ git push encore\n```\n\n----------------------------------------\n\nTITLE: Defining Service with Context and sqlDB in Go\nDESCRIPTION: This Go snippet provides an example of defining a service package using Encore's storage package. It sets up a named database connection using sqlDB and exposes an API through the `Foo` function. Dependencies include the Encore framework, context package, and sqlDB component. The expected output is a setup for managing database interactions with an API endpoint returning no result.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_without_call.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/storage/sqldb\"\n)\n\nvar Moo = sqldb.Named(\"svc\")\n\n//encore:api public\nfunc Foo(ctx context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Authentication Context Override\nDESCRIPTION: Demonstrates how to override authentication context for testing or specific requests\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_27\n\nLANGUAGE: go\nCODE:\n```\nctx := auth.WithContext(context.Background(), auth.UID(\"my-user-id\"), &MyAuthData{})\n```\n\n----------------------------------------\n\nTITLE: Defining a StreamIn API Endpoint in Encore\nDESCRIPTION: This code defines a StreamIn API endpoint using Encore's `api.streamIn` method. It demonstrates how to specify handshake, incoming message, and optional response types, as well as how to handle the incoming stream of messages within the API handler. The handler processes incoming messages, checks for a 'done' signal, and returns a success status.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/streaming-apis.mdx#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\nimport log from \"encore.dev/log\";\n\n// Used to pass initial data, optional.\ninterface Handshake {\n  user: string;\n}\n\n// What the clients sends over the stream.\ninterface Message {\n  data: string;\n  done: boolean;\n}\n\n// Returned when the stream is done, optional.\ninterface Response {\n  success: boolean;\n}\n\nexport const uploadStream = api.streamIn<Handshake, Message, Response>(\n  { path: \"/upload\", expose: true },\n  async (handshake, stream) => {\n    const chunks: string[] = [];\n    try {\n      // The stream object is an AsyncIterator that yields incoming messages.\n      for await (const data of stream) {\n        chunks.push(data.data);\n        // Stop the stream if the client sends a \"done\" message\n        if (data.done) break;\n      }\n    } catch (err) {\n      log.error(`Upload error by ${handshake.user}:`, err);\n      return { success: false };\n    }\n    log.info(`Upload complete by ${handshake.user}`);\n    return { success: true };\n  },\n);\n\n```\n\n----------------------------------------\n\nTITLE: Public API Endpoint with Database Interaction\nDESCRIPTION: Defines a public API function 'Foo' that accepts a context and invokes a database-related function from an external package\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_helper.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public\nfunc Foo(ctx context.Context) error {\n    pkg.Foo(Moo)\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Atlas with External Schema\nDESCRIPTION: This HCL configuration file sets up Atlas to use an external schema source, which is a Go program that loads GORM schema information. It defines an environment named \"local\" that specifies the data source, migration directory, and formatting options. It requires the atlas CLI to be installed.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/atlas-gorm.md#2025-04-21_snippet_2\n\nLANGUAGE: hcl\nCODE:\n```\n\"data \\\"external_schema\\\" \\\"gorm\\\" {\n  program = [\\\"env\\\", \\\"ENCORERUNTIME_NOPANIC=1\\\", \\\"go\\\", \\\"run\\\", \\\"./scripts/atlas-gorm-loader.go\\\"]\n}\n\nenv \\\"local\\\" {\n  src = data.external_schema.gorm.url\n\n  migration {\n    dir = \\\"file://migrations\\\"\n    format = golang-migrate\n  }\n\n  format {\n    migrate {\n      diff = \\\"{{ sql . \\\"  \\\" }}\\\"\n    }\n  }\n}\"\n```\n\n----------------------------------------\n\nTITLE: Testing Encore Client Integration with Jest\nDESCRIPTION: Example of unit testing a component that interacts with an Encore API, demonstrating how to mock and spy on request client methods for both GET and POST requests.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/integrate-frontend.mdx#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { render, waitForElementToBeRemoved } from \"@testing-library/react\";\nimport App from \"./App\";\nimport { site } from \"./client\";\nimport { userEvent } from \"@testing-library/user-event\";\n\ndescribe(\"App\", () => {\n  beforeEach(() => {\n    // Return mocked data from the List (GET) endpoint\n    jest\n      .spyOn(site.ServiceClient.prototype, \"List\")\n      .mockReturnValue(Promise.resolve({\n        sites: [{\n          id: 1,\n          url: \"test.dev\"\n        }]\n      }));\n\n    // Spy on the Add (POST) endpoint\n    jest.spyOn(site.ServiceClient.prototype, \"Add\");\n  });\n\n  it(\"render sites\", async () => {\n    render(<App />);\n    await waitForElementToBeRemoved(() => screen.queryByText(\"Loading...\"));\n\n    // Verify that the List endpoint has been called\n    expect(site.ServiceClient.prototype.List).toBeCalledTimes(1);\n\n    // Verify that the sites are rendered with our mocked data\n    screen.getAllByText(\"test.dev\");\n  });\n\n  it(\"add site\", async () => {\n    render(<App />);\n    await waitForElementToBeRemoved(() => screen.queryByText(\"Loading...\"));\n\n    // Interact with the page and add 'another.com'\n    await userEvent.click(screen.getByText(\"Add website\"));\n    await userEvent.type(\n      screen.getByPlaceholderText(\"google.com\"),\n      \"another.com\",\n    );\n    await userEvent.click(screen.getByText(\"Save\"));\n\n    // Verify that the Add endpoint has been called with the correct parameters\n    expect(site.ServiceClient.prototype.Add).toHaveBeenCalledWith({\n      url: \"another.com\",\n    });\n  });\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring NSQ in Encore\nDESCRIPTION: Configuration for NSQ messaging system with topic and subscription settings.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"pubsub\": [\n    {\n      \"type\": \"nsq\",\n      \"hosts\": \"nsq.myencoreapp.com:4150\",\n      \"topics\": {\n        \"my-topic\": {\n          \"name\": \"my-topic\",\n          \"subscriptions\": {\n            \"my-subscription\": {\n                \"name\": \"my-subscription\"\n            }\n          }\n        }\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing API Endpoint Bar in Encore for Go\nDESCRIPTION: This function defines a public API endpoint called Bar. It takes a context parameter and performs a query operation on the Moo database connection defined in the svca package. The function also currently returns nil. Required dependencies include 'context' and 'test/svca'.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_cross_service.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\npackage svcb\n\nimport (\n    \"context\"\n\n    \"test/svca\"\n)\n\n//encore:api public\nfunc Bar(ctx context.Context) error {\n    _ = svca.Moo.Query()\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Encore Client in TypeScript\nDESCRIPTION: Command to generate a TypeScript client for Encore API endpoints.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/meeting-notes.mdx#2025-04-21_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n$ encore gen client <APP_NAME> --output=./src/client.ts --env=<ENV_NAME>\n```\n\n----------------------------------------\n\nTITLE: Configuring Auth0 Client Details in Cue\nDESCRIPTION: This Cue configuration file specifies the client settings required to interact with Auth0, including the client ID, domain, callback URL, and logout URL. These values are essential for enabling the authentication handler to communicate with Auth0 and manage OAuth flows.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/auth0-auth.md#2025-04-21_snippet_3\n\nLANGUAGE: cue\nCODE:\n```\nClientID: \"<your client_id from above>\"\nDomain: \"<your domain from above>\"\n\n// An application running locally\nif #Meta.Environment.Type == \"development\" && #Meta.Environment.Cloud == \"local\" {\n\tCallbackURL: \"http://localhost:3000/callback\"\n\tLogoutURL: \"http://localhost:3000/\"\n}\n\n```\n\n----------------------------------------\n\nTITLE: Setting Up Encore Database Proxy\nDESCRIPTION: Establishes a local proxy to forward connections to databases in the specified environment.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\n$ encore db proxy [--env=<name>] [flags]\n```\n\n----------------------------------------\n\nTITLE: Combining GraphQL Resolvers\nDESCRIPTION: Sets up the main resolvers index file that combines query and mutation resolvers. This file exports a consolidated resolvers object that Apollo Server will use.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/graphql.mdx#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Resolvers } from \"../__generated__/resolvers-types\";\nimport Query from \"./queries.js\";\nimport Mutation from \"./mutations.js\";\n\nconst resolvers: Resolvers = { Query, Mutation };\n\nexport default resolvers;\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest for Encore in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to set up `vite.config.ts` for changing module resolution with Vitest in an Encore application. The configuration establishes path aliases, enabling cleaner import statements. Ensure the Encore-generated files are appropriately resolved, simplifying test setups.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/testing.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types=\\\"vitest\\\" />\\nimport { defineConfig } from \\\"vite\\\";\\nimport path from \\\"path\\\";\\n\\nexport default defineConfig({\\n  resolve: {\\n    alias: {\\n      \\\"~encore\\\": path.resolve(__dirname, \\\"./encore.gen\\\"),\\n    },\\n  },\\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Client Generation Scripts to package.json\nDESCRIPTION: JSON snippet showing how to add Encore client generation scripts to package.json for easy access.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/meeting-notes.mdx#2025-04-21_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n...\n\"scripts\": {\n    ...\n    \"generate-client:staging\": \"encore gen client <Encore app id here> --output=./src/client.ts --env=staging\",\n    \"generate-client:local\": \"encore gen client <Encore app id here> --output=./src/client.ts --env=local\"\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Cache Cluster in Go with Encore\nDESCRIPTION: Defines a cache cluster named 'cluster' using Encore's cache package. This cluster is exported as a package variable for use in other packages.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cache_cluster_outside_svc.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nvar Cluster = cache.NewCluster(\"cluster\", cache.ClusterConfig{})\n```\n\n----------------------------------------\n\nTITLE: NestJS Cats Controller Example\nDESCRIPTION: This TypeScript snippet showcases a standard NestJS controller with methods for creating, finding all, and finding a cat by ID. It uses decorators like `@Controller`, `@Post`, `@Get`, `@Body`, and `@Param` to define the API endpoints and handle requests. It uses the `CatsService` to interact with the data.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/how-to/nestjs.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n@Controller('cats')\nexport class CatsController {\n  constructor(private readonly catsService: CatsService) {\n  }\n\n  @Post()\n  @Roles(['admin'])\n  async create(@Body() createCatDto: CreateCatDto) {\n    this.catsService.create(createCatDto);\n  }\n\n  @Get()\n  async findAll(): Promise<Cat[]> {\n    return this.catsService.findAll();\n  }\n\n  @Get(':id')\n  findOne(\n    @Param('id', new ParseIntPipe())\n      id: number,\n  ) {\n    return this.catsService.get(id);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining service package and imports in Go\nDESCRIPTION: This snippet defines the main package of the service and imports necessary packages from Encore and other local modules. It imports `context`, `config`, `uuid` from Encore, and `utils` and `helpers` from the local application.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/types_from_multiple_packages.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n\t\"encore.dev/types/uuid\"\n\n\t\"encore.app/svc/utils\"\n\t\"encore.app/svc/helpers\"\n)\n```\n\n----------------------------------------\n\nTITLE: Generating API Interface - Go\nDESCRIPTION: This snippet is auto-generated by Encore and defines an interface for the API service. The interface exposes the 'Foo' method for external services, allowing it to be mocked in tests. The comment structure specifies that raw endpoints are excluded until supported.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/request_params.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n-- want:encore.gen.go --\n// Code generated by encore. DO NOT EDIT.\n\npackage basic\n\nimport \"context\"\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\n\n// Interface defines the service's API surface area, primarily for mocking purposes.\n//\n// Raw endpoints are currently excluded from this interface, as Encore does not yet\n// support service-to-service API calls to raw endpoints.\ntype Interface interface {\n    Foo(ctx context.Context, p *Params) error\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Building Encore App using Encore CLI\nDESCRIPTION: This snippet shows how to create and build an Encore app using the Encore CLI. It involves initializing a new app with a Hello World template and building the app to generate a Docker image. Dependencies include the Encore CLI, and the prerequisite is having Encore installed. The command creates a new application, selects a template, and outputs a Docker image for deployment.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/deploy-to-digital-ocean.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nencore app create myapp\n```\n\nLANGUAGE: bash\nCODE:\n```\nencore build docker myapp\n```\n\n----------------------------------------\n\nTITLE: Implementing Auth Handler with Incorrect Parameter in Go\nDESCRIPTION: This code snippet shows an attempt to implement an Encore auth handler function with an incorrect second parameter type. The function 'MyAuth' uses an integer instead of the required string or pointer to a named struct, which results in a compilation error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/auth_handler_invalid_builtin.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"encore.dev/beta/auth\"\n)\n\n//encore:authhandler\nfunc MyAuth(ctx context.Context, p int) (auth.UID, error) { return \"\", nil }\n```\n\n----------------------------------------\n\nTITLE: Tagging a Docker Image - Bash\nDESCRIPTION: This snippet tags a Docker image to match the URL format required by DigitalOceans container registry, ensuring the image is properly identified for deployment.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/deploy-to-digital-ocean-wip.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker tag myapp registry.digitalocean.com/YOUR_REGISTRY_NAME/myapp:latest\n```\n\n----------------------------------------\n\nTITLE: Using Generated Client in Go CLI Application\nDESCRIPTION: Example of using a generated Go client in a CLI application for a URL shortener service, including error handling for structured errors.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/client-generation.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n    \"time\"\n\n    \"shorten_cli/client\"\n)\n\nfunc main() {\n    // Create a new client with the default BaseURL\n    client, err := client.New(\n        client.Environment(\"production\"),\n        client.WithAuth(os.Getenv(\"SHORTEN_API_KEY\")),\n    )\n    if err != nil {\n        panic(err)\n    }\n\n    // Timeout if the request takes more than 5 seconds\n    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n    defer cancel()\n\n    // Call the Shorten function in the URL service\n    resp, err := client.Url.Shorten(\n        ctx,\n        client.UrlShortenParams{ URL: os.Args[1] },\n    )\n    if err != nil {\n        // Check the error returned\n        if err, ok := err.(*client.APIError); ok {\n            switch err.Code {\n            case client.ErrUnauthenticated:\n                fmt.Println(\"SHORTEN_API_KEY was invalid, please check your environment\")\n                os.Exit(1)\n            case client.ErrAlreadyExists:\n                fmt.Println(\"The URL you provided was already shortened\")\n                os.Exit(0)\n            }\n        }\n        panic(err) // if here then something has gone wrong in an unexpected way\n    }\n    fmt.Printf(\"https://short.encr.app/%s\", resp.ID)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Secrets in Encore\nDESCRIPTION: Demonstrates how to define application secrets in Encore. Secrets are defined as fields in an unexported struct named 'secrets' with string type fields.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/code-snippets.md#2025-04-21_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nvar secrets struct {\n    GitHubAPIToken string   // personal access token for deployments\n    SomeOtherSecret string  // some other secret\n}\n```\n\n----------------------------------------\n\nTITLE: GitHub Actions for Triggering Railway Deployment\nDESCRIPTION: These GitHub Actions steps set up Node.js and execute a JavaScript script to trigger a new deployment on Railway. It passes the Railway API token as an argument to the script.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/deploy-to-railway.md#2025-04-21_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n\"      - name: Set up Node\\n        uses: actions/setup-node@v4\\n        with:\\n          node-version: 22\\n\\n      - name: Trigger Railway deployment\\n        run: node script.js ${{ secrets.RAILWAY_API_TOKEN }}\"\n```\n\n----------------------------------------\n\nTITLE: Generating Service API Interface\nDESCRIPTION: This code defines an interface `Interface` that outlines the service's API surface. It includes the `Foo` method, mirroring the public API endpoint. This interface is intended for mocking and facilitates service-to-service API calls within the Encore framework.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/path_params.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// Code generated by encore. DO NOT EDIT.\n\npackage code\n\nimport \"context\"\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\n\n// Interface defines the service's API surface area, primarily for mocking purposes.\n//\n// Raw endpoints are currently excluded from this interface, as Encore does not yet\n// support service-to-service API calls to raw endpoints.\ntype Interface interface {\n\tFoo(ctx context.Context, id int, baz string, p *Params) error\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Attributes to Events in TypeScript\nDESCRIPTION: This snippet showcases how to define attributes for the event type in order to enhance message payloads with additional key-value pairs.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/pubsub.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Topic, Attribute } from \"encore.dev/pubsub\";\n\nexport interface SignupEvent {\n    userID: string;\n    source: Attribute<string>;\n}\n\nexport const signups = new Topic<SignupEvent>(\"signups\", {\n    deliveryGuarantee: \"at-least-once\",\n});\n```\n\n----------------------------------------\n\nTITLE: Publishing Message to PubSub Topic in Go\nDESCRIPTION: Defines a function to publish a message to the BasicTopic with a sample MessageType containing a name field.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_subscriber_nil_handler.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// encore:api\nfunc DoStuff(ctx context.Context) error {\n    return BasicTopic.Publish(ctx, &MessageType{Name: \"foo\"})\n}\n```\n\n----------------------------------------\n\nTITLE: Triggering a Rollout via API in TypeScript\nDESCRIPTION: This TypeScript snippet illustrates how to define the JSON request body required to trigger a rollout in the Encore Cloud API. The body accepts either a commit SHA or a branch name for deployment, ensuring that one of these parameters is always present.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/integrations/api-reference.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  // The commit hash to trigger a deploy for.\n  \"sha\": string;\n} | {\n  // Name of the branch to trigger a deploy from.\n  \"branch\": string;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing GORM and Postgres Driver\nDESCRIPTION: This shell command installs the GORM package and the Postgres driver for GORM. It is a prerequisite for using GORM to interact with a Postgres database in a Go application.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/atlas-gorm.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n\"go get -u gorm.io/gorm gorm.io/driver/postgres\"\n```\n\n----------------------------------------\n\nTITLE: Encore Generated Authentication Handler Implementation in Go\nDESCRIPTION: This snippet showcases the generated code by Encore for handling the authentication process. It includes defining an `AuthHandlerDesc` struct to store the handler and the decode logic. The `DecodeAuth` function extracts the authentication parameters from the HTTP request, and the `init` functions register the handler and data type with the Encore runtime.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/authhandlergen/testdata/authdata.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\t__model \"encore.dev/appruntime/exported/model\"\n\t__etype \"encore.dev/appruntime/shared/etype\"\n\terrs \"encore.dev/beta/errs\"\n\t\"net/http\"\n)\n\nvar EncoreInternal_authhandler_AuthDesc_AuthHandler = &__api.AuthHandlerDesc[*MyAuthParams]{\n\tAuthHandler: func(ctx context.Context, params *MyAuthParams) (info __model.AuthInfo, err error) {\n\t\tinfo.UID, info.UserData, err = AuthHandler(ctx, params)\n\t\treturn info, err\n\t},\n\tDecodeAuth: func(httpReq *http.Request) (params *MyAuthParams, err error) {\n\t\tparams = new(MyAuthParams)\n\t\tdec := new(__etype.Unmarshaller)\n\t\t// Decode headers\n\t\th := httpReq.Header\n\t\tparams.ClientID = __etype.UnmarshalOne(dec, __etype.UnmarshalString, \"x-client-id\", h.Get(\"x-client-id\"), false)\n\n\t\t// Decode query string\n\t\tqs := httpReq.URL.Query()\n\t\tparams.APIKey = __etype.UnmarshalOne(dec, __etype.UnmarshalString, \"key\", qs.Get(\"key\"), false)\n\n\t\tif dec.NonEmptyValues == 0 {\n\t\t\treturn (*MyAuthParams)(nil), errs.B().Code(errs.Unauthenticated).Msg(\"missing auth param\").Err()\n\t\t} else if err := dec.Error; err != nil {\n\t\t\treturn (*MyAuthParams)(nil), errs.B().Code(errs.InvalidArgument).Msgf(\"invalid auth param: %v\", err).Err()\n\t\t}\n\t\treturn params, nil\n\t},\n\tDefLoc:      uint32(0x0),\n\tEndpoint:    \"AuthHandler\",\n\tHasAuthData: true,\n\tService:     \"code\",\n\tSvcNum:      1,\n}\n\nfunc init() {\n\t__api.RegisterAuthHandler(EncoreInternal_authhandler_AuthDesc_AuthHandler)\n}\n\nfunc init() {\n\t__api.RegisterAuthDataType[*MyAuthData]()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Middleware Metadata for Encore - Go\nDESCRIPTION: This snippet creates a variable holding metadata for the 'Middleware' function. It uses the Encore API SDK and provides necessary information, such as the definition location, whether it's global, the unique identifier, and invocation details. This sets up the middleware for integration within the Encore application runtime.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/middlewaregen/testdata/basic.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\npackage basic\n\nimport __api \"encore.dev/appruntime/apisdk/api\"\n\nvar EncoreInternal_middleware_middleware_Middleware = &__api.Middleware{\n\tDefLoc:  uint32(0x0),\n\tGlobal:  false,\n\tID:      \"example.com.Middleware\",\n\tInvoke:  Middleware,\n\tName:    \"Middleware\",\n\tPkgName: \"basic\",\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Request Client Generation for Environment\nDESCRIPTION: Creates a flexible request client that adapts to local or staging environments and includes authentication token\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/auth0-auth.md#2025-04-21_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst getRequestClient = () => {\n  const token = Cookies.get(\"auth-token\");\n  const env = import.meta.env.DEV ? Local : Environment(\"staging\");\n\n  return new Client(env, {\n    auth: token,\n  });\n};\n```\n\n----------------------------------------\n\nTITLE: Global Tagged Middleware Implementation\nDESCRIPTION: Implements global middleware targeting endpoints tagged with 'foo', passing through requests unmodified\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/middleware.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n//encore:middleware global target=tag:foo\nfunc TaggedInSvc(req middleware.Request, next middleware.Next) middleware.Response {\n    return next(req)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Request Headers with Encore.ts\nDESCRIPTION: This snippet shows how to define request headers in a schema by using the Header type, along with an example that illustrates its usage with Encore.ts.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Header } from \"encore.dev/api\";\n\ninterface Params {\n  language: Header<\"Accept-Language\">; // parsed from header\n  author: string; // not a header\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Service Variable in Go\nDESCRIPTION: This snippet in Go defines a service variable 'Moo' using the 'sqldb.Named()' function from the 'encore.dev/storage/sqldb' package, intended for referencing a named database service. It includes a function 'Foo' that provides a public API endpoint which currently returns no error. Dependencies include the 'context' and 'encore.dev/storage/sqldb' packages. No parameters are required for 'Foo', and it outputs an error type, though it returns nil as of now.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_outside_ref.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/storage/sqldb\"\n)\n\nvar Moo = sqldb.Named(\"svc\")\n\n//encore:api public\nfunc Foo(ctx context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PubSub Topic and Message Type in Go\nDESCRIPTION: Defines a MessageType struct and creates a basic PubSub topic with at-least-once delivery guarantee.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_duplicate_subscription_names.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage shared\n\nimport (\n    \"encore.dev/pubsub\"\n)\n\ntype MessageType struct {\n    Name string\n}\n\nvar (\n    BasicTopic = pubsub.NewTopic[*MessageType](\"basic-topic\", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })\n)\n```\n\n----------------------------------------\n\nTITLE: Defining PubSub Topic in Go with Encore\nDESCRIPTION: Creates a PubSub topic with at-least-once delivery guarantee using Encore's pubsub package. Defines a custom MessageType for message payload.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_subscriber_nil_handler.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nvar (\n    BasicTopic = pubsub.NewTopic[*MessageType](\"basic-topic\", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })\n    _ = pubsub.NewSubscription(BasicTopic, \"basic-subscription\", pubsub.SusbcriptionConfig{ Handler: nil })\n)\n```\n\n----------------------------------------\n\nTITLE: Switching to an Existing Infrastructure Namespace using Encore CLI\nDESCRIPTION: This command switches the current context to the specified infrastructure namespace 'my-ns'. Ensures that all commands will operate within this namespace.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/infra-namespaces.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ encore namespace switch my-ns\n```\n\n----------------------------------------\n\nTITLE: Basic Service Struct Implementation in Go\nDESCRIPTION: Demonstrates the structure of a basic Encore service with initialization and API endpoint definition\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ntype Service struct {\n    // Dependencies here\n}\n\nfunc initService() (*Service, error) {\n    // Initialization code\n}\n\n//encore:api public\nfunc (s *Service) MyAPI(ctx context.Context) error {\n    // API implementation\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Encore App from Example\nDESCRIPTION: Command to create a new Encore application using the meeting-notes example as a template.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/meeting-notes.mdx#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ encore app create my-app --example=meeting-notes\n```\n\n----------------------------------------\n\nTITLE: Configuring Cron Job in Encore\nDESCRIPTION: Example of creating a cron job to send welcome emails at a specified interval using Encore's cron package\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nvar _ = cron.NewJob(\"welcome-email\", cron.JobConfig{\n    Title:    \"Send welcome emails\",\n    Every:    2 * cron.Hour,\n    Endpoint: SendWelcomeEmail,\n})\n\n//encore:api private\nfunc SendWelcomeEmail(ctx context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Generating API Interface for Encore - Go\nDESCRIPTION: This section contains the auto-generated code for the Encore service interface. It outlines the public API surface, which includes the `Tagged` method intended for external service calls. This code is frequently refreshed by Encore in response to changes in endpoint definitions.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/endpoint_tags.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// Code generated by encore. DO NOT EDIT.\n\npackage code\n\nimport \"context\"\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\n\ntype Interface interface {\n\tTagged(ctx context.Context) error\n}\n```\n\n----------------------------------------\n\nTITLE: Object Storage Bucket Creation in Encore\nDESCRIPTION: Creating a bucket for storing profile pictures with versioning disabled\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_15\n\nLANGUAGE: go\nCODE:\n```\nvar ProfilePictures = objects.NewBucket(\"profile-pictures\", objects.BucketConfig{\n    Versioned: false,\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Bucket for Profile Pictures in Go\nDESCRIPTION: Defines a bucket for storing profile pictures with optional versioning configuration using Encore's Object Storage API\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/object-storage.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nvar ProfilePictures = objects.NewBucket(\"profile-pictures\", objects.BucketConfig{\n\tVersioned: false,\n})\n```\n\n----------------------------------------\n\nTITLE: Book Service Implementation for GraphQL API - TypeScript\nDESCRIPTION: Implementation of a book service in Encore, defining two endpoints: one to list books and another to add a new book. The service interacts with a hardcoded array as a database and utilizes the generated Book type for type safety.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/graphql.mdx#2025-04-21_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { Service } from \"encore.dev/service\";\n\nexport default new Service(\"book\");\n```\n\nLANGUAGE: ts\nCODE:\n```\nimport { api, APIError } from \"encore.dev/api\";\nimport { Book } from \"../graphql/__generated__/resolvers-types\";\n\nconst db: Book[] = [\n  {\n    title: \"To Kill a Mockingbird\",\n    author: \"Harper Lee\",\n  },\n  {\n    title: \"1984\",\n    author: \"George Orwell\",\n  },\n  {\n    title: \"The Great Gatsby\",\n    author: \"F. Scott Fitzgerald\",\n  },\n  {\n    title: \"Moby-Dick\",\n    author: \"Herman Melville\",\n  },\n  {\n    title: \"Pride and Prejudice\",\n    author: \"Jane Austen\",\n  },\n];\n\nexport const list = api(\n  { expose: true, method: \"GET\", path: \"/books\" },\n  async (): Promise<{ books: Book[] }> => {\n    return { books: db };\n  },\n);\n\n// Omit the \"__typename\" field from the request\ntype AddRequest = Omit<Required<Book>, \"__typename\">;\n\nexport const add = api(\n  { expose: true, method: \"POST\", path: \"/book\" },\n  async (book: AddRequest): Promise<{ book: Book }> => {\n    if (db.some((b) => b.title === book.title)) {\n      throw APIError.alreadyExists(\n        `Book \"${book.title}\" is already in database`,\n      );\n    }\n    db.push(book);\n    return { book };\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing a Dummy Public API Endpoint in Go\nDESCRIPTION: This snippet defines a public API endpoint named Dummy using the Encore framework. It takes a context and a pointer to the Params struct as arguments, demonstrating how complex types can be used in API parameters.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/recursive_types.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\n//encore:api public\nfunc Dummy(ctx context.Context, p *Params) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Interface for API Endpoints in Go\nDESCRIPTION: This snippet is a generated code segment that outlines the Interface of the service, which provides a method signature for the Foo API endpoint. It is used primarily for mocking during testing and ensures that the API surface area is well defined.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/request_headers.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// Code generated by encore. DO NOT EDIT.\n\npackage code\n\nimport \"context\"\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\ntype Interface interface {\n    Foo(ctx context.Context, p *Params) error\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Error Response Format\nDESCRIPTION: Example JSON response format when an error is returned from an API endpoint.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/api-errors.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"code\": \"not_found\",\n    \"message\": \"sprocket not found\",\n    \"details\": null\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Telemetry via CLI\nDESCRIPTION: This shell command disables telemetry collection in Encore. Executing this command stops the transmission of telemetry data from the local development tools and the Encore Cloud dashboard.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/telemetry.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nencore telemetry disable\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image for Encore Application\nDESCRIPTION: This snippet explains how to use the Encore CLI to build a Docker image of your application, ensuring compatibility with the Encore CI system. It is particularly useful when migrating from the Encore Cloud Platform to a self-hosted solution, allowing you to leverage the same code path used by Encore.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/migration/migrate-away.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n\"encore build docker\"\n```\n\n----------------------------------------\n\nTITLE: Installing Required Go Modules for Firebase Auth\nDESCRIPTION: Command to install the necessary Go modules for Firebase Authentication integration.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/firebase-auth.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ go get firebase.google.com/go/v4 go4.org/syncutil\n```\n\n----------------------------------------\n\nTITLE: Registering Global Middleware with Encore Runtime\nDESCRIPTION: This code snippet registers the global middleware function with the Encore runtime. It uses internal Encore APIs to register the middleware. The registration includes metadata such as the middleware's ID, name, and invocation function.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/middlewaregen/testdata/global.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage global\n\nimport __api \"encore.dev/appruntime/apisdk/api\"\n\nfunc init() {\n\t__api.RegisterGlobalMiddleware(EncoreInternal_middleware_middleware_Middleware)\n}\n\nvar EncoreInternal_middleware_middleware_Middleware = &__api.Middleware{\n\tDefLoc:  uint32(0x0),\n\tGlobal:  true,\n\tID:      \"example.com.Middleware\",\n\tInvoke:  Middleware,\n\tName:    \"Middleware\",\n\tPkgName: \"global\",\n}\n```\n\n----------------------------------------\n\nTITLE: Live-streaming Logs with Encore\nDESCRIPTION: This command allows you to live-stream logs from your Encore application in the production environment. It's a quick way to observe logs as they're generated.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/observability/logging.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ encore logs --env=prod\n```\n\n----------------------------------------\n\nTITLE: Defining Public Raw RPC API in Go\nDESCRIPTION: This snippet defines a simple API function for public and raw RPC access in the Encore framework using Go. The function takes an HTTP response writer and request as parameters, enabling it to handle incoming API requests. Dependencies include the net/http package for HTTP handling, and it leverages Encore's annotations for defining the API's access level.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_raw_public.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public raw\nfunc API(w http.ResponseWriter, req *http.Request) { }\n```\n\n----------------------------------------\n\nTITLE: Configuring Atlas for ent Schema Migrations in HCL\nDESCRIPTION: Atlas configuration file specifying the ent schema source and migration output settings.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/entgo-orm.md#2025-04-21_snippet_3\n\nLANGUAGE: hcl\nCODE:\n```\nenv \"local\" {\n  src = \"ent://ent/schema\"\n\n  migration {\n    dir = \"file://migrations\"\n    format = golang-migrate\n  }\n\n  format {\n    migrate {\n      diff = \"{{ sql . \\\"  \\\" }}\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Opening a Database Shell in a Specific Namespace using Encore CLI\nDESCRIPTION: This command opens a database shell for the specified namespace 'my-ns'. It ensures interaction with the correct database environment.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/infra-namespaces.md#2025-04-21_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ encore db shell DATABASE_NAME --namespace my-ns\n```\n\n----------------------------------------\n\nTITLE: Exposing Service API with Encore Framework\nDESCRIPTION: This Go function defines a public API endpoint using the Encore framework's annotation system. It is accessible at the path '/foo/bar' and takes a context as its parameter, returning an error. The function currently does not perform any operations and returns a nil error. This snippet relies on the Encore framework being set up in the project.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_non_raw_path.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport \"context\"\n\n//encore:api public path=/foo/bar\nfunc API(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Defining API Endpoint with Encore in Go\nDESCRIPTION: This snippet defines a public API endpoint named `Foo` using Encore's `encore:api` directive. It takes a context and a pointer to `FooParams` as input. The function currently returns `nil` indicating success or any error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/type_ref_non_svc.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"encore.dev/beta/auth\"\n)\n\ntype FooParams struct {\n    Name string\n}\n\n//encore:api public\nfunc Foo(ctx context.Context, p *FooParams) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Testing Encore API with Authentication Handler\nDESCRIPTION: Test file for the Foo API endpoint that sets up authentication handling using Encore's testing framework. Demonstrates the use of et.AuthHandler for authentication configuration.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/et.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"testing\"\n\n    \"encore.dev/et\"\n)\n\nfunc TestFoo(t *testing.T) {\n    et.AuthHandler(MyAuth)\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Created Timestamp Column to Existing Table\nDESCRIPTION: This SQL migration adds a 'created' timestamp column to the existing todo_item table. It sets the column as NOT NULL with a default value of the current timestamp (NOW()).\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/change-db-schema.md#2025-04-21_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nALTER TABLE todo_item ADD created TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW();\n```\n\n----------------------------------------\n\nTITLE: Creating a Public Bucket in Go\nDESCRIPTION: Shows how to create a public bucket for serving static assets with direct HTTP/HTTPS access\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/object-storage.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nvar PublicAssets = objects.NewBucket(\"public-assets\", objects.BucketConfig{\n    Public: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Generating API Client\nDESCRIPTION: The `encore gen client` command generates an API client for your Encore application.  It supports specifying the environment, services to include or exclude, and the target language.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\n$ encore gen client [<app-id>] [--env=<name>] [--services=foo,bar] [--excluded-services=baz,qux] [--lang=<lang>] [flags]\n```\n\n----------------------------------------\n\nTITLE: Automatically Generated Encore API Interface Golang\nDESCRIPTION: Generated by Encore, this segment creates an Interface type to define the service's API surface, primarily for mocking purposes. It includes a signature for the 'Foo' function already declared. The code does not handle raw endpoints as current limitations exist in Encore for such calls.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/response_headers.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n// Code generated by encore. DO NOT EDIT.\n\npackage code\n\nimport \"context\"\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\n\n// Interface defines the service's API surface area, primarily for mocking purposes.\n//\n// Raw endpoints are currently excluded from this interface, as Encore does not yet\n// support service-to-service API calls to raw endpoints.\ntype Interface interface {\n\tFoo(ctx context.Context) (*Params, error)\n}\n\n```\n\n----------------------------------------\n\nTITLE: PubSub Outbox Topic Binding Implementation\nDESCRIPTION: Demonstrates how to implement PubSub topic binding with the outbox pattern for ensuring consistency between database operations and message publishing.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_48\n\nLANGUAGE: go\nCODE:\n```\nvar SignupsTopic = pubsub.NewTopic[*SignupEvent](/* ... */)\nref := pubsub.TopicRef[pubsub.Publisher[*SignupEvent]](SignupsTopic)\nref = outbox.Bind(ref, outbox.TxPersister(tx))\n```\n\n----------------------------------------\n\nTITLE: Implementing GraphQL Query Resolvers\nDESCRIPTION: Creates the query resolvers that call the book service's list method. These resolvers translate GraphQL queries into calls to the appropriate Encore API endpoints.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/graphql.mdx#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { book } from \"~encore/clients\";\nimport { QueryResolvers } from \"../__generated__/resolvers-types\";\n\n// Use the generated `QueryResolvers` type to type check our queries!\nconst queries: QueryResolvers = {\n  books: async () => {\n    const { books } = await book.list();\n    return books;\n  },\n};\n\nexport default queries;\n```\n\n----------------------------------------\n\nTITLE: Using Built-in Validation Rules with Encore.ts\nDESCRIPTION: This snippet shows how to import and use built-in validation rules from Encore.ts to define constraints on request fields like minimum and maximum values.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Min, Max, MinLen, MaxLen, IsEmail, IsURL } from \"encore.dev/validate\";\n\ninterface Schema {\n  // Number between 3 and 1000 (inclusive)\n  count: number & (Min<3> & Max<1000>);\n\n  // String between 5 and 20 characters\n  username: string & (MinLen<5> & MaxLen<20>);\n\n  // Must be either a valid URL or email address\n  contact: string & (IsURL | IsEmail);\n\n  // Array of up to 10 email addresses\n  recipients: Array<string & IsEmail> & MaxLen<10>;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring API Endpoints with Different Parameter Signatures\nDESCRIPTION: Creating API endpoints with various parameter type combinations, demonstrating Encore's flexible API definition approach\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/tests/testdata/query_header.txt#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport const t1 = api<Params, void>({}, () => {});\nexport const t2 = api<void, Params>({}, () => {});\nexport const t3 = api<Params, Params>({}, () => {});\n```\n\n----------------------------------------\n\nTITLE: Setting Secret Values in Encore\nDESCRIPTION: Shows the CLI command for setting secret values in Encore. The command specifies which environment types the secret applies to and the secret name to set.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/code-snippets.md#2025-04-21_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n$ encore secret set --type <types...> <secret-name>\n```\n\n----------------------------------------\n\nTITLE: Testing API Call Auth Override in Go\nDESCRIPTION: Verifies that per-request authentication context overrides take precedence over global auth settings.\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/et_override_user.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc TestOverrideAuthInfo_APICallOptsOverride(t *testing.T) {\n    et.OverrideAuthInfo(\"foo\", nil)\n\n    ctx := auth.WithContext(context.Background(), \"bar\", nil)\n    resp, err := GetUser(ctx)\n    if err != nil {\n        t.Fatal(err)\n    } else if resp.UserID != \"bar\" {\n        t.Fatalf(\"got uid %q, want %q\", resp.UserID, \"bar\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Foo Service Endpoint\nDESCRIPTION: Defines a simple Encore API endpoint for the Foo service with a context-based method that returns an error\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/multiple_services.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc Foo(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Using Named Connection in Package with Go\nDESCRIPTION: This snippet demonstrates referencing a named sqlDB connection from a different package. It illustrates the usage of previously defined service components in another Go package. Prerequisites include understanding of Go package management and importing the named connection from the service package for functional operations.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_without_call.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage pkg\n\nimport (\n    \"context\"\n    \"test/svc\"\n)\n\nfunc Foo() {\n    _ = svc.Moo\n    _ = svc.Moo.Query\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Service in Encore - Go\nDESCRIPTION: This snippet defines a service struct within the Encore framework. It uses 'context' for handling requests within APIs. The 'Service' struct does not have any methods or fields at this point, but it's a starting point for building functionality. No additional dependencies are required beyond the Go standard library.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/servicestruct_ref.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n)\n\n//encore:service\ntype Service struct {}\n\n//encore:api public\nfunc (*Service) Foo(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Authentication Middleware and Auth Handling in TypeScript\nDESCRIPTION: Illustrates authentication approaches in Express.js using middleware and Encore.ts with type-safe authentication handlers, showing how each framework manages request authentication\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/migration/express-migration.md#2025-04-21_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport express, {NextFunction, Request, Response} from \"express\";\n\nconst app: Express = express();\n\n// Auth middleware\nfunction authMiddleware(req: Request, res: Response, next: NextFunction) {\n  // TODO: Validate up auth token and verify that this is an authenticated user\n  const isInvalidUser = req.headers[\"authorization\"] === undefined;\n\n  if (isInvalidUser) {\n    res.status(401).json({error: \"invalid request\"});\n  } else {\n    next();\n  }\n}\n\n// Endpoint that requires auth\napp.get(\"/dashboard\", authMiddleware, (_, res: Response) => {\n  res.json({message: \"Secret dashboard message\"});\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api, APIError, Gateway, Header } from \"encore.dev/api\";\nimport { authHandler } from \"encore.dev/auth\";\nimport { getAuthData } from \"~encore/auth\";\n\ninterface AuthParams {\n  authorization: Header<\"Authorization\">;\n}\n\n// The function passed to authHandler will be called for all incoming API call that requires authentication.\nexport const myAuthHandler = authHandler(\n  async (params: AuthParams): Promise<{ userID: string }> => {\n    // TODO: Validate up auth token and verify that this is an authenticated user\n    const isInvalidUser = params.authorization === undefined;\n\n    if (isInvalidUser) {\n      throw APIError.unauthenticated(\"Invalid user ID\");\n    }\n\n    return { userID: \"user123\" };\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Defining User Data Structure for Clerk Authentication\nDESCRIPTION: Defines a UserData structure to store user information retrieved from Clerk. This structure captures essential user details like ID, name, email addresses, and profile image URL.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_39\n\nLANGUAGE: go\nCODE:\n```\ntype UserData struct {\n    ID                    string\n    Username              *string\n    FirstName             *string\n    LastName              *string\n    ProfileImageURL       string\n    PrimaryEmailAddressID *string\n    EmailAddresses        []clerk.EmailAddress\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Middleware Order in Encore.ts Service\nDESCRIPTION: Demonstrates how to define the execution order of middleware in an Encore.ts service. Middleware functions are executed in the order they are listed in the 'middlewares' array.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nexport default new Service(\"myService\", {\n    middlewares: [\n        first,\n        second,\n        third\n    ],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Migrations Directory\nDESCRIPTION: Shell command to create migrations directory for database schema\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ mkdir site/migrations\n```\n\n----------------------------------------\n\nTITLE: Defining PubSub Message Type and Topic in Go\nDESCRIPTION: This snippet defines a MessageType struct with pubsub attributes and initializes a BasicTopic using Encore's pubsub package. It demonstrates the use of pubsub.NewTopic with custom configuration, but contains an error in the OrderingAttribute field.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_ordering_attribute_missing.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage shared\n\nimport (\n    \"encore.dev/pubsub\"\n)\n\ntype MessageType struct {\n    ID   int64  `pubsub-attr:\"msg-id\"`\n    Name string `pubsub-attr:\"name\"`\n}\n\nvar BasicTopic = pubsub.NewTopic[*MessageType](\"same-name\", pubsub.TopicConfig{\n    DeliveryGuarantee: pubsub.AtLeastOnce,\n    OrderingAttribute: \"ID\",\n})\n```\n\n----------------------------------------\n\nTITLE: Retrieving Files from Database using Raw Endpoint in Encore.ts\nDESCRIPTION: This code defines a raw endpoint to retrieve file data from a PostgreSQL database using Encore.ts.  It fetches the file data as a Buffer and sends it as the response.  If the file is not found, a 404 error is returned.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/how-to/file-uploads.md#2025-04-21_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport { api } from \"encore.dev/api\";\nimport { APICallMeta, currentRequest } from \"encore.dev\"; \n\nexport const DB = new SQLDatabase(\"files\", {\n  migrations: \"./migrations\",\n});\n\nexport const get = api.raw(\n  { expose: true, method: \"GET\", path: \"/files/:name\" },\n  async (req, resp) => {\n    try {\n      const { name } = (currentRequest() as APICallMeta).pathParams;\n      const row = await DB.queryRow`\n          SELECT data\n          FROM files\n          WHERE name = ${name}`;\n      if (!row) {\n        resp.writeHead(404);\n        resp.end(\"File not found\");\n        return;\n      }\n\n      const chunk = Buffer.from(row.data);\n      resp.writeHead(200, { Connection: \"close\" });\n      resp.end(chunk);\n    } catch (err) {\n      resp.writeHead(500);\n      resp.end((err as Error).message);\n    }\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Template Rendering Implementation - Express.js vs Encore.ts\nDESCRIPTION: Shows template rendering implementation in both frameworks. Express.js uses built-in view engine support while Encore.ts uses api.raw with Handlebars.js for HTML templates.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/migration/express-migration.md#2025-04-21_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport express, {Request, Response} from \"express\";\n\nconst app: Express = express();\n\napp.set(\"view engine\", \"pug\"); // Set view engine to Pug\n\n// Template engine example. This will render the index.pug file in the views directory\napp.get(\"/html\", (_, res) => {\n  res.render(\"index\", {title: \"Hey\", message: \"Hello there!\"});\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport {api} from \"encore.dev/api\";\nimport Handlebars from \"handlebars\";\n\nconst html = `\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\"/>\n  <link rel=\"stylesheet\" href=\"/assets/styles.css\">\n</head>\n<body>\n<h1>Hello {{name}}!</h1>\n</body>\n</html>\n`;\n\n// Making use of raw endpoints to serve dynamic templates.\n// https://encore.dev/docs/ts/primitives/raw-endpoints\nexport const serveHTML = api.raw(\n  {expose: true, path: \"/html\", method: \"GET\"},\n  async (req, resp) => {\n    const template = Handlebars.compile(html);\n\n    resp.setHeader(\"Content-Type\", \"text/html\");\n    resp.end(template({name: \"Simon\"}));\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Mutation Query\nDESCRIPTION: Sample GraphQL mutation for adding a new book. This mutation adds a book with the specified author and title, and returns information about the success of the operation.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/graphql.mdx#2025-04-21_snippet_9\n\nLANGUAGE: graphql\nCODE:\n```\nmutation AddBook {\n  addBook(author: \"J.R.R. Tolkien\", title: \"The Hobbit\") {\n    success\n    message\n    code\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Global Middleware Implementation in Go\nDESCRIPTION: Implementation of global middleware functions with tag-specific and application-wide targeting.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/middleware_err_no_matches.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n//encore:middleware global target=tag:foo\nfunc TaggedInSvc(req middleware.Request, next middleware.Next) middleware.Response {\n    return next(req)\n}\n\n//encore:middleware global target=all\nfunc AllInSvc(req middleware.Request, next middleware.Next) middleware.Response {\n    return next(req)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Auth Handler Descriptor in Go\nDESCRIPTION: This snippet describes the creation of EncoreInternal_authhandler_AuthDesc_AuthHandler, which leverages the MyAuthParams struct to decode authentication parameters from HTTP requests. It handles various types of authentication parameters including cookies and query strings while returning error messages for missing or invalid values.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/authhandlergen/testdata/struct.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\t__model \"encore.dev/appruntime/exported/model\"\n\t__etype \"encore.dev/appruntime/shared/etype\"\n\terrs \"encore.dev/beta/errs\"\n\t\"net/http\"\n)\n\nvar EncoreInternal_authhandler_AuthDesc_AuthHandler = &__api.AuthHandlerDesc[*MyAuthParams]{\n\tAuthHandler: func(ctx context.Context, params *MyAuthParams) (info __model.AuthInfo, err error) {\n\t\tinfo.UID, err = AuthHandler(ctx, params)\n\t\treturn info, err\n\t},\n\tDecodeAuth: func(httpReq *http.Request) (params *MyAuthParams, err error) {\n\t\tparams = new(MyAuthParams)\n\t\tdec := new(__etype.Unmarshaller)\n\t\t// Decode headers\n\t\th := httpReq.Header\n\t\tparams.ClientID = __etype.UnmarshalOne(dec, __etype.UnmarshalString, \"x-client-id\", h.Get(\"x-client-id\"), false)\n\n\t\t// Decode query string\n\t\tqs := httpReq.URL.Query()\n\t\tparams.APIKey = __etype.UnmarshalOne(dec, __etype.UnmarshalString, \"key\", qs.Get(\"key\"), false)\n\n\t\t// Decode cookies\n\t\tif c, _ := httpReq.Cookie(\"session_token\"); c != nil {\n\t\t\tparams.SessionToken = __etype.UnmarshalOne(dec, __etype.UnmarshalString, \"session_token\", c.Value, false)\n\t\t}\n\t\tif c, _ := httpReq.Cookie(\"other_cookie\"); c != nil {\n\t\t\tparams.OtherCookie = c\n\t\t\tdec.IncNonEmpty()\n\t\t}\n\t\tif c, _ := httpReq.Cookie(\"int_cookie\"); c != nil {\n\t\t\tparams.IntCookie = __etype.UnmarshalOne(dec, __etype.UnmarshalInt, \"int_cookie\", c.Value, false)\n\t\t}\n\n\t\tif dec.NonEmptyValues == 0 {\n\t\t\treturn (*MyAuthParams)(nil), errs.B().Code(errs.Unauthenticated).Msg(\"missing auth param\").Err()\n\t\t} else if err := dec.Error; err != nil {\n\t\t\treturn (*MyAuthParams)(nil), errs.B().Code(errs.InvalidArgument).Msgf(\"invalid auth param: %v\", err).Err()\n\t\t}\n\t\treturn params, nil\n\t},\n\tDefLoc:      uint32(0x0),\n\tEndpoint:    \"AuthHandler\",\n\tHasAuthData: false,\n\tService:     \"code\",\n\tSvcNum:      1,\n}\n\nfunc init() {\n\t__api.RegisterAuthHandler(EncoreInternal_authhandler_AuthDesc_AuthHandler)\n}\n```\n\n----------------------------------------\n\nTITLE: Booking Appointment Logic - Go\nDESCRIPTION: This Go code implements the booking logic for the appointment service, including validation of booking parameters, insertion of bookings into the database, and proper transaction management.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_9\n\nLANGUAGE: go\nCODE:\n```\n-- booking/booking.go --\npackage booking\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"encore.app/booking/db\"\n\t\"github.com/jackc/pgx/v5/pgtype\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\n\t\"encore.dev/beta/errs\"\n\t\"encore.dev/storage/sqldb\"\n)\n\nvar (\n\tbookingDB = sqldb.NewDatabase(\"booking\", sqldb.DatabaseConfig{\n\t\tMigrations: \"./db/migrations\",\n\t})\n\n\tpgxdb = sqldb.Driver[*pgxpool.Pool](bookingDB)\n\tquery = db.New(pgxdb)\n)\n\ntype Booking struct {\n\tID    int64     `json:\"id\"`\n\tStart time.Time `json:\"start\"`\n\tEnd   time.Time `json:\"end\"`\n\tEmail string    `encore:\"sensitive\"`\n}\n\ntype BookParams struct {\n\tStart time.Time `json:\"start\"`\n\tEmail string    `encore:\"sensitive\"`\n}\n\n//encore:api public method=POST path=/booking\nfunc Book(ctx context.Context, p *BookParams) error {\n\teb := errs.B()\n\n\tnow := time.Now()\n\tif p.Start.Before(now) {\n\t\treturn eb.Code(errs.InvalidArgument).Msg(\"start time must be in the future\").Err()\n\t}\n\n\txn, err := pgxdb.Begin(ctx)\n\tif err != nil {\n\t\treturn eb.Cause(err).Code(errs.Unavailable).Msg(\"failed to start transaction\").Err()\n\t}\n\tdefer tx.Rollback(context.Background()) // committed explicitly on success\n\n\t_, err = query.InsertBooking(ctx, db.InsertBookingParams{\n\t\tStartTime: pgtype.Timestamp{Time: p.Start, Valid: true},\n\t\tEndTime:   pgtype.Timestamp{Time: p.Start.Add(DefaultBookingDuration), Valid: true},\n\t\tEmail:     p.Email,\n\t})\n\tif err != nil {\n\t\treturn eb.Cause(err).Code(errs.Unavailable).Msg(\"failed to insert booking\").Err()\n\t}\n\n\tif err := tx.Commit(ctx); err != nil {\n\t\treturn eb.Cause(err).Code(errs.Unavailable).Msg(\"failed to commit transaction\").Err()\n\t}\n\treturn nil\n}\n\n```\n\n----------------------------------------\n\nTITLE: Environment-Based Behavior Modification\nDESCRIPTION: This snippet modifies the application's behavior based on the current environment type. It checks if the environment is 'test' or 'development' and adjusts email verification accordingly.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nswitch (appMeta().environment.type) {\n  case \"test\":\n  case \"development\":\n    await markEmailVerified(userID);\n    break;\n  default:\n    await sendVerificationEmail(userID);\n    break;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generated API Wrapper Function in Go\nDESCRIPTION: This snippet shows an automatically generated wrapper function in the encore.gen.go file, which allows other services to call APIs defined on service structs as package-level functions.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/service-structs.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// Code generated by encore. DO NOT EDIT.\n\npackage email\n\nimport \"context\"\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\n\nfunc Send(ctx context.Context, p *SendParams) error {\n\t// The implementation is elided here, and generated at compile-time by Encore.\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Cache Cluster and Generic Keyspace in Encore\nDESCRIPTION: Creates a cache cluster and keyspace with generic type support in Encore. The implementation defines a Key struct with generic type parameters, initializes a cache cluster, and creates a string keyspace with a custom key pattern. A simple public API endpoint is also defined.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cache_generic_type.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/storage/cache\"\n)\n\nvar cluster = cache.NewCluster(\"cluster\", cache.ClusterConfig{})\n\ntype Key[T any] struct {\n    Foo T\n}\n\nvar keyspace = cache.NewStringKeyspace[Key[string]](cluster, cache.KeyspaceConfig{\n    KeyPattern: \"foo/:Foo\",\n})\n\n//encore:api public\nfunc Foo(context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Serving Static Files at the Root with Encore.ts - TypeScript\nDESCRIPTION: This code snippet illustrates how to define a fallback route for serving static files at the root of the domain using Encore.ts. The `path` parameter uses `!path` syntax to avoid conflicts with other API routes, allowing files in the `./assets` directory to be served efficiently. This requires setting up Encore.ts with the Node.js environment.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/static-assets.mdx#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\n\nexport const assets = api.static(\n  { expose: true, path: \"/!path\", dir: \"./assets\" },\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Public API Endpoint with Encore in Go\nDESCRIPTION: This snippet defines a public API endpoint using Encore's annotation. The function 'Foo' is marked as a public API and takes a context as an argument, returning an error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/metrics_counter.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n//encore:api public\nfunc Foo(context.Context) error {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Unarchiving Encore Secrets\nDESCRIPTION: Unarchives a previously archived secret value in Encore.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_24\n\nLANGUAGE: shell\nCODE:\n```\n$ encore secret unarchive <id>\n```\n\n----------------------------------------\n\nTITLE: Configuring Publicly Accessible Encore Bucket\nDESCRIPTION: This code demonstrates how to configure a bucket for public access in Encore using the `public` option.  By setting `public: true`, objects in this bucket are accessible via a public URL.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport const publicProfilePictures = new Bucket(\"public-profile-pictures\", {\n  public: true,\n  versioned: false\n});\n```\n\n----------------------------------------\n\nTITLE: Deploying URL Shortener to Encore Cloud\nDESCRIPTION: Git commands to commit changes and deploy the URL shortener service to Encore Cloud. This process triggers Encore to build, test, and provision necessary infrastructure for the application.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/rest-api.mdx#2025-04-21_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\n$ git add -A .\n$ git commit -m 'Initial commit'\n$ git push encore\n```\n\n----------------------------------------\n\nTITLE: Defining Authentication Parameters in Go\nDESCRIPTION: This snippet defines a struct MyAuthParams which includes fields for authentication parameters, including a client ID from headers, an API key from query parameters, and cookies for session tokens and others. This structure is essential for handling incoming authentication requests.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/authhandlergen/testdata/struct.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"encore.dev/beta/auth\"\n)\n\ntype MyAuthParams struct {\n\tClientID string `header:\"X-Client-ID\"`\n\tAPIKey string `query:\"key\"`\n\tSessionToken string `cookie:\"session_token\"`\n\tOtherCookie *http.Cookie `cookie:\"other_cookie\"`\n\tIntCookie int `cookie:\"int_cookie\"`\n}\n\n//encore:authhandler\nfunc AuthHandler(ctx context.Context, p *MyAuthParams) (auth.UID, error) {\n    return \"\", nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PubSub Topic in Shared Package (Go)\nDESCRIPTION: This snippet defines a PubSub topic named 'same-name' in the shared package. It creates a new topic with a MessageType struct and configures it for at-least-once delivery.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_topic_must_be_unique.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage shared\n\nimport (\n    \"encore.dev/pubsub\"\n)\n\ntype MessageType struct {\n    Name string\n}\n\nvar BasicTopic = pubsub.NewTopic[*MessageType](\"same-name\", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })\n```\n\n----------------------------------------\n\nTITLE: Creating a Params Struct with Recursive and Generic Types in Go\nDESCRIPTION: This snippet defines a Params struct that uses the previously defined recursive and generic types. It's used to demonstrate how these complex types can be used as parameters in an API endpoint.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/recursive_types.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\ntype Params struct {\n    A *SelfRecursive\n    B *MutuallyRecursive\n    C *Generic[Generic[MutuallyRecursive]]\n}\n```\n\n----------------------------------------\n\nTITLE: API Endpoint for Cron Job in Go\nDESCRIPTION: Defines a public API endpoint for the cron job that returns a simple response message. The endpoint is annotated with Encore's API decorator.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cron_job_definition_init.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public path=/cron\nfunc Cron(ctx context.Context) (*Response, error) {\n    msg := \"Hello, Cron!\"\n    return &Response{Message: msg}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Public API Endpoint in Package one\nDESCRIPTION: Defines a simple public API endpoint function One that returns nil, located in the one package\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_without_calling.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage one\n\nimport (\n    \"context\"\n)\n\n//encore:api public\nfunc One(ctx context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Using CUE Tags in Go Structs\nDESCRIPTION: Illustrates how to use CUE tags in Go structs to specify additional constraints on configuration. The example shows how these tags translate to CUE type definitions.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/config.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype FooBar {\n    A int `cue:\">100\"`\n    B int `cue:\"A-50\"` // If A is set, B can be inferred by CUE\n    C int `cue:\"A+B\"`  // Which then allows CUE to infer this too\n}\n\nvar _ = config.Load[*FooBar]()\n```\n\nLANGUAGE: cue\nCODE:\n```\n#Config: {\n    A: int & >100\n    B: int & A-50 // If A is set, B can be inferred by CUE\n    C: int & A+B  // Which then allows CUE to infer this too\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Shopping Cart Functionality with Encore Testing Framework\nDESCRIPTION: Demonstrates comprehensive testing of the shopping cart service using various mocking techniques provided by the Encore testing framework (et). Tests include no mocking, endpoint mocking, service mocking, and service isolation scenarios.\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/et_mocking.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage shoppingcart\n\nimport (\n    \"context\"\n    \"math\"\n    \"testing\"\n\n    \"encore.dev/et\"\n\n    \"test/products\"\n)\n\nfunc callAndExpect(t *testing.T, total float64) {\n    resp, err := Total(context.Background())\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    if math.Abs(resp.Total - total) > 0.001 {\n        t.Fatalf(\"expected total to be %f, got %f\", total, resp.Total)\n    }\n}\n\nfunc TestTotal_NoMocking(t *testing.T) {\n    t.Parallel()\n\n    callAndExpect(t, 299.97)\n}\n\nfunc TestTotal_WithMockingOfProductsEndpoint(t *testing.T) {\n    t.Parallel()\n\n    et.MockEndpoint(products.GetPrice, func(ctx context.Context, productID int, p *products.PriceParams) (*products.PriceResult, error) {\n       return &products.PriceResult{ Total: 20 * float64(p.Quantity) }, nil\n    })\n\n    callAndExpect(t, 60.0)\n}\n\nfunc TestTotal_WithMockingOfServiceMethod(t *testing.T) {\n    t.Parallel()\n\n    et.MockEndpoint(Total, func(ctx context.Context) (*TotalResult, error) {\n        return &TotalResult{ Total: 100.0 }, nil\n    })\n\n    callAndExpect(t, 100.0)\n}\n\nfunc TestTotal_WithMockingOfServiceObjectWithDifferentInstance(t *testing.T) {\n    t.Parallel()\n\n    et.MockService(\"shoppingcart\", &Service{\n        Items: []CartItem{\n            { ProductID: 1, Quantity: 5 },\n        },\n    })\n\n    callAndExpect(t, 499.95)\n}\n\nfunc TestTotal_WithMockingOfServiceWithMockObject(t *testing.T) {\n    t.Parallel()\n\n    et.MockService[products.Interface](\"products\", &mockProducts{})\n\n    callAndExpect(t, 303.0)\n}\n\ntype mockProducts struct{}\n\nfunc (m *mockProducts) GetPrice(ctx context.Context, productID int, p *products.PriceParams) (*products.PriceResult, error) {\n    return &products.PriceResult{ Total: float64(productID) + float64(p.Quantity * 100) }, nil\n}\n\nfunc TestTotal_UsingServiceIsolation(t *testing.T) {\n    t.Parallel()\n\n    callAndExpect(t, 299.97)\n\n    // These don't run with parallel so we can test the isolation\n    t.Run(\"emptied in isolation\", func(t *testing.T) {\n        et.EnableServiceInstanceIsolation()\n        Empty(context.Background())\n        callAndExpect(t, 0.0)\n    })\n\n    t.Run(\"non isolated still has items\", func(t *testing.T) {\n        callAndExpect(t, 299.97)\n    })\n}\n\nfunc TestTotal_RemovingMockServices(t *testing.T) {\n    t.Parallel()\n\n    et.MockService[products.Interface](\"products\", &mockProducts{})\n\n    t.Run(\"remove mock\", func(t *testing.T) {\n        et.MockService[products.Interface](\"products\", nil)\n        callAndExpect(t, 299.97)\n    })\n\n    callAndExpect(t, 303.0)\n}\n\nfunc TestTotal_RemovingMockEndpoints(t *testing.T) {\n    t.Parallel()\n\n    et.MockEndpoint(products.GetPrice, func(ctx context.Context, productID int, p *products.PriceParams) (*products.PriceResult, error) {\n       return &products.PriceResult{ Total: 20 * float64(p.Quantity) }, nil\n    })\n\n    t.Run(\"remove mock\", func(t *testing.T) {\n        et.MockEndpoint(products.GetPrice, nil)\n        callAndExpect(t, 299.97)\n    })\n\n    callAndExpect(t, 60.0)\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Encore Application\nDESCRIPTION: Tests the Encore application, supporting all flags from 'go test'.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ encore test ./... [go test flags]\n```\n\n----------------------------------------\n\nTITLE: Implementing API Tagging for Middleware in Encore\nDESCRIPTION: Demonstrates how to tag an API endpoint using encore:api annotation to apply specific middleware. The example shows a public GET endpoint with cache tag for middleware targeting.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_32\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public method=GET path=/user/:id tag:cache\nfunc GetUser(ctx context.Context, id string) (*User, error) {\n    // Implementation\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Public API Function with Method Call in Go\nDESCRIPTION: This snippet defines a public API function 'Foo' that creates an instance of a custom type and calls its 'Foo' method. It demonstrates the distinction between method calls and function calls with the same name.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_call_selector.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n)\n\n//encore:api public\nfunc Foo(ctx context.Context) error {\n    var t typ\n    t.Foo()\n    return nil\n}\n\ntype typ struct{}\nfunc (typ) Foo() { }\n```\n\n----------------------------------------\n\nTITLE: Implementing GraphQL Mutation Resolvers\nDESCRIPTION: Creates the mutation resolvers that call the book service's add method. These handle adding new books and proper error handling, providing appropriate responses based on success or failure.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/graphql.mdx#2025-04-21_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { book } from \"~encore/clients\";\nimport { MutationResolvers } from \"../__generated__/resolvers-types\";\nimport { APIError } from \"encore.dev/api\";\n\n// Use the generated `MutationResolvers` type to type check our mutations\nconst mutations: MutationResolvers = {\n  addBook: async (_, { title, author }) => {\n    try {\n      const resp = await book.add({ title, author });\n      return {\n        book: resp.book,\n        success: true,\n        code: \"ok\",\n        message: \"New book added\",\n      };\n    } catch (err) {\n      const apiError = err as APIError;\n\n      return {\n        book: null,\n        success: false,\n        code: apiError.code,\n        message: apiError.message,\n      };\n    }\n  },\n};\n\nexport default mutations;\n```\n\n----------------------------------------\n\nTITLE: Using Encore Request Client in TypeScript\nDESCRIPTION: Example of using the generated Encore request client in TypeScript code to make API calls to retrieve a specific meeting note, demonstrating type-safe function calls.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/integrate-frontend.mdx#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport Client, { Environment, Local } from \"src/client.ts\";\n\n// Making request to locally running backend...\nconst client = new Client(Local);\n// or to a specific deployed environment\nconst client = new Client(Environment(\"staging\"));\n\n// Calling APIs as typesafe functions \nconst response = await client.note.GetNote(\"note-uuid\");\nconsole.log(response.id);\nconsole.log(response.cover_url);\nconsole.log(response.text);\n```\n\n----------------------------------------\n\nTITLE: Defining a Service with a Raw HTTP Endpoint\nDESCRIPTION: This code defines an Encore service `Service` with a raw HTTP endpoint `Bar` as a method. The `//encore:service` annotation marks `Service` as an Encore service.  The `Bar` method, similar to `Foo`, handles HTTP requests and responses directly.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/raw_endpoint.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:service\ntype Service struct{}\n\n//encore:api public raw\nfunc (s *Service) Bar(w http.ResponseWriter, req *http.Request) {}\n```\n\n----------------------------------------\n\nTITLE: Defining TypeScript API Endpoint with Custom Types\nDESCRIPTION: Implements an API endpoint using Encore's API framework with custom type definitions for parameters. Includes a type for key-value pairs of booleans/numbers and an interface for request parameters.\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/tests/testdata/mapped_types.txt#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\n\ntype OnlyBoolsAndHorses = {\n  [key: string]: boolean | number;\n};\n\ninterface Params {\n    blah: OnlyBoolsAndHorses;\n};\n\nexport const ping = api<Params, void>({}, () => {});\n```\n\n----------------------------------------\n\nTITLE: Encore Service Shutdown Handler Implementation\nDESCRIPTION: Implementation of a service shutdown handler in Go using Encore's shutdown package. The handler logs a shutdown message using rlog package.\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/graceful_shutdown.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"encore.dev/shutdown\"\n    \"encore.dev/rlog\"\n)\n\n//encore:service\ntype Service struct{}\n\nfunc (s *Service) Shutdown(p shutdown.Progress) error {\n    rlog.Info(\"shutting down\")\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Infrastructure in Encore Using JSON\nDESCRIPTION: This JSON snippet configures infrastructure settings for an Encore application, including the SQL server details needed for connecting to the database. The configuration includes host information, TLS settings with a CA certificate, and database connection credentials. Prerequisites are acquiring connection details from DigitalOcean and setting up environment variables.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/deploy-to-digital-ocean.md#2025-04-21_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"$schema\": \"https://encore.dev/schemas/infra.schema.json\",\n   \"sql_servers\": [\n   {\n      \"host\": \"mydb.db.ondigitalocean.com:25060\",\n      \"tls_config\": {\n         \"ca\": \"-----BEGIN CERTIFICATE-----\\n...\"\n      },\n      \"databases\": {\n         \"mydb\": {\n            \"name\": \"mydb\",\n            \"username\": \"doadmin\",\n            \"password\": {\"$env\": \"DB_PASSWORD\"}\n          }\n      }\n   }]\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Pub/Sub Subscription Messages in Go\nDESCRIPTION: This function serves as a subscriber to handle incoming messages from the pub/sub topic. It takes a context and a MessageType pointer as parameters, but currently has no implementation.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_subscriber_missing_handler.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nfunc Subscriber(ctx context.Context, msg *MessageType) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Client Generation Script to package.json\nDESCRIPTION: This JSON snippet demonstrates how to add client generation commands to your `package.json` file. It sets up scripts to generate clients for different environments (staging and local).  These scripts can be run using `npm run generate-client:staging` or `npm run generate-client:local`.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/frontend/request-client.mdx#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"{\n...\n  \"scripts\": {\n    ...\n    \"generate-client:staging\": \"encore gen client <ENCORE-APP-ID> --output=./src/client.ts --env=staging\",\n    \"generate-client:local\": \"encore gen client <ENCORE-APP-ID> --output=./src/client.ts --env=local\"\n  }\n}\"\n```\n\n----------------------------------------\n\nTITLE: Fetching Access Token and Making API Requests with Logto in TypeScript\nDESCRIPTION: This snippet shows how to obtain an access token using the 'getAccessToken' method from the Logto React SDK and use it to make authorized API requests to the Encore API. The access token is included in the 'Authorization' header when making HTTP requests.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/logto-auth.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst { getAccessToken } = useLogto();\nconst accessToken = await getAccessToken('<your-api-resource-indicator>');\n\nfetch('<your-encore-api-endpoint>/hello', {\n  headers: {\n    Authorization: `Bearer ${accessToken}`,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Testing the Database Connection with curl\nDESCRIPTION: This bash command uses `curl` to test the database connection by calling the API endpoint that retrieves user data. It verifies that the database is correctly connected and accessible.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/deploy-to-railway.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n\"   curl https://myapp.railway.app/names/1\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Telemetry Debug Mode\nDESCRIPTION: This shell command sets an environment variable to enable debug mode for telemetry in Encore. Setting `ENCORE_TELEMETRY_DEBUG` to 1 causes log statements to be printed whenever telemetry data is sent.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/telemetry.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nexport ENCORE_TELEMETRY_DEBUG=1\n```\n\n----------------------------------------\n\nTITLE: Defining Server Configuration Options in Go\nDESCRIPTION: This snippet defines a Go struct called ServerOption for representing server options with integer values and a disabled flag. It also includes a Config struct for organizing different server communication methods such as HTTP, TCP, and GRPC. The fields in Config may include JSON serialization tags to ensure proper marshaling and unmarshaling.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/json_tags.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n    \"time\"\n\n\t\"encore.dev/config\"\n\t\"encore.dev/types/uuid\"\n)\n\ntype ServerOption struct {\n    Option   int64\n    Disabled bool `json:\",omitempty\"` // True if this is disabled\n}\n\ntype Config struct {\n    HTTP    ServerOption\n    Another ServerOption `json:\"a_n_o_t_h_e_r\"`\n    TCP     ServerOption `json:\",omitempty\"`\n    GRPC    ServerOption `json:\",omitempty\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Using Generated Encore Client in TypeScript\nDESCRIPTION: TypeScript example demonstrating how to use the generated Encore client to make API calls.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/meeting-notes.mdx#2025-04-21_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport Client, { Environment, Local } from \"src/client.ts\";\n\n// Making request to locally running backend...\nconst client = new Client(Local);\n// or to a specific deployed environment\nconst client = new Client(Environment(\"staging\"));\n\n// Calling APIs as typesafe functions \nconst response = await client.note.GetNote(\"note-uuid\");\nconsole.log(response.id);\nconsole.log(response.cover_url);\nconsole.log(response.text);\n```\n\n----------------------------------------\n\nTITLE: Managing Infrastructure Namespaces with Encore CLI\nDESCRIPTION: This snippet demonstrates various Encore CLI commands for managing infrastructure namespaces. It includes commands for listing, creating, switching between, and deleting namespaces.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/infra-namespaces.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# List your namespaces (* indicates the current namespace)\n$ encore namespace list\n\n# Create a new namespace\n$ encore namespace create my-ns\n\n# Switch to a namespace\n$ encore namespace switch my-ns\n\n# Switch to a namespace, creating it if it doesn't exist\n$ encore namespace switch --create my-ns\n\n# Switch to the previous namespace\n$ encore namespace switch -\n\n# Delete a namespace (and all associated data)\n$ encore namespace delete my-ns\n```\n\n----------------------------------------\n\nTITLE: Defining an Auth Handler in Encore\nDESCRIPTION: Defines an auth handler using the //encore:authhandler annotation. This function authenticates users based on a token and returns a user ID. Auth handlers in Encore must follow a specific signature pattern and be properly annotated.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/auth_handler_reference.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"encore.dev/beta/auth\"\n)\n\n//encore:authhandler\nfunc MyAuth(ctx context.Context, token string) (auth.UID, error) { return \"\", nil }\n```\n\n----------------------------------------\n\nTITLE: Using Interfaces for Testable Dependency Injection in Encore\nDESCRIPTION: Demonstrates using interfaces for dependencies to improve testability. This approach allows for easier mocking by defining the required interface rather than concrete implementations.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_44\n\nLANGUAGE: go\nCODE:\n```\ntype sendgridClient interface {\n    SendEmail(...) // hypothetical signature\n}\n\n//encore:service\ntype Service struct {\n    sendgridClient sendgridClient\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Validation with CUE List Operations\nDESCRIPTION: Shows how to validate port numbers using CUE's list package and validation constraints\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/config.md#2025-04-21_snippet_6\n\nLANGUAGE: cue\nCODE:\n```\nimport (\\n    \"list\"\\n)\\n\\nportNumbers: [...int] | *[8080]\\nif #Meta.Environment.Type == \"development\" {\\n    portNumbers: [8080, 8443]\\n}\\n\\nportNumbers: [...int & >= 1024]\\n\\n_portsAreValid: list.Contains(portNumbers, 8080)\\n_portsAreValid: true\n```\n\n----------------------------------------\n\nTITLE: Public API Endpoint Definition\nDESCRIPTION: Defines a public API endpoint tagged with 'foo' that takes a context parameter and returns an error\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/middleware.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public tag:foo\nfunc API(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Implementing User Authentication Service in Go with Encore\nDESCRIPTION: Public API endpoint implementation for retrieving authenticated user information using Encore's auth package.\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/et_override_user.txt#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ntype Response struct {\n    UserID auth.UID\n}\n\n//encore:api public\nfunc GetUser(ctx context.Context) (*Response, error) {\n    uid, _ := auth.UserID()\n    return &Response{UserID: uid}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting and Creating Database with SQL on DigitalOcean\nDESCRIPTION: This snippet uses SQL commands to create a new database and a table on DigitalOcean's managed database service. It includes connecting to the database using the `psql` command, creating a database, and initializing a table with some data. Key inputs are connection details, which must be obtained from the DigitalOcean dashboard.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/deploy-to-digital-ocean.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npsql -h mydb.db.ondigitalocean.com -U doadmin -d mydb -p 25060\n```\n\nLANGUAGE: sql\nCODE:\n```\nCREATE DATABASE mydb;\n```\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE users (\n   id SERIAL PRIMARY KEY,\n   name VARCHAR(50)\n);\n```\n\nLANGUAGE: sql\nCODE:\n```\nINSERT INTO users (name) VALUES ('Alice');\n```\n\n----------------------------------------\n\nTITLE: Defining Configuration Structures in Go\nDESCRIPTION: This snippet defines the ServerOption and Config structures for managing server configurations in Encore applications. The structures encapsulate options for different types of servers and handle configuration loading. Dependencies include the Encore framework's config and types packages.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/cue_optional_tag.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"encore.dev/config\"\n\t\"encore.dev/types/uuid\"\n)\n\ntype ServerOption struct {\n\tOption   int64\n\tDisabled bool `cue:\",opt\"` // True if this is disabled\n}\n\ntype Config struct {\n\tHTTP    ServerOption\n\tAnother ServerOption\n\tTCP     ServerOption `cue:\",opt\"`\n\tGRPC    ServerOption `cue:\",opt\"`\n}\n\nvar _ = config.Load[*Config]()\n```\n\n----------------------------------------\n\nTITLE: Switching Back to Previous Namespace using Encore CLI\nDESCRIPTION: This command switches back to the previous infrastructure namespace, preserving your previous context and state. It is useful for quick context switching without needing to remember names.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/infra-namespaces.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ encore namespace switch -\n```\n\n----------------------------------------\n\nTITLE: Defining an Encore Service\nDESCRIPTION: This TypeScript snippet demonstrates how to define an Encore service using the `Service` class from the `encore.dev/service` module. This is necessary for Encore to recognize a directory as a service and provision the required infrastructure. The service is instantiated with a name, which is used to identify the service in Encore.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/how-to/nestjs.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {Service} from \"encore.dev/service\";\n\nexport default new Service(\"my-service\");\n```\n\n----------------------------------------\n\nTITLE: PubSub Outbox Service Initialization\nDESCRIPTION: Shows how to initialize a service with PubSub outbox pattern implementation, including relay setup and topic registration for message handling.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_49\n\nLANGUAGE: go\nCODE:\n```\ntype Service struct {\n    signupsRef pubsub.Publisher[*SignupEvent]\n}\n\nfunc initService() (*Service, error) {\n    relay := outbox.NewRelay(outbox.SQLDBStore(db))\n    signupsRef := pubsub.TopicRef[pubsub.Publisher[*SignupEvent]](SignupsTopic)\n    outbox.RegisterTopic(relay, signupsRef)\n    go relay.PollForMessage(context.Background(), -1)\n    return &Service{signupsRef: signupsRef}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: API Call and Pub/Sub Message Interfaces in TypeScript\nDESCRIPTION: This TypeScript code defines interfaces for describing API calls and Pub/Sub messages being processed within the Encore framework. The APICallMeta interface contains details about the API endpoint, HTTP method, request path, parameters, headers, and parsed payload. The PubSubMessageMeta interface includes information about the service, topic, subscription, message ID, delivery attempt, and parsed payload.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/metadata.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n\"/** Describes an API call being processed. */\nexport interface APICallMeta {\n  /** Specifies that the request is an API call. */\n  type: \\\"api-call\\\";\n\n  /** Describes the API Endpoint being called. */\n  api: APIDesc;\n\n  /** The HTTP method used in the API call. */\n  method: Method;\n\n  /**\n   * The request URL path used in the API call,\n   * excluding any query string parameters.\n   * For example \\\"/path/to/endpoint\\\".\n   */\n  path: string;\n\n  /**\n   * The request URL path used in the API call,\n   * including any query string parameters.\n   * For example \\\"/path/to/endpoint?with=querystring\\\".\n   */\n  pathAndQuery: string;\n\n  /**\n   * The parsed path parameters for the API endpoint.\n   * The keys are the names of the path parameters,\n   * from the API definition.\n   *\n   * For example {id: 5}.\n   */\n  pathParams: Record<string, any>;\n\n  /**\n   * The request headers from the HTTP request.\n   * The values are arrays if the header contains multiple values,\n   * either separated by \\\";\\\" or when the header key appears more than once.\n   */\n  headers: Record<string, string | string[]>;\n\n  /**\n   * The parsed request payload, as expected by the application code.\n   * Not provided for raw endpoints or when the API endpoint expects no\n   * request data.\n   */\n  parsedPayload?: Record<string, any>;\n}\n\n-- Pub/Sub Message --\n/** Describes a Pub/Sub message being processed. */\nexport interface PubSubMessageMeta {\n  /** Specifies that the request is a Pub/Sub message. */\n  type: \\\"pubsub-message\\\";\n\n  /** The service processing the message. */\n  service: string;\n\n  /** The name of the Pub/Sub topic. */\n  topic: string;\n\n  /** The name of the Pub/Sub subscription. */\n  subscription: string;\n\n  /**\n   * The unique id of the Pub/Sub message.\n   * It is the same id returned by `topic.publish()`.\n   * The message id stays the same across delivery attempts.\n   */\n  messageId: string;\n\n  /**\n   * The delivery attempt. The first attempt starts at 1,\n   * and increases by 1 for each retry.\n   */\n  deliveryAttempt: number;\n\n  /**\n   * The parsed request payload, as expected by the application code.\n   */\n  parsedPayload?: Record<string, any>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MyAPI Function using Go\nDESCRIPTION: This snippet defines an API function called MyAPI that accepts a context.Context parameter and returns an error. It serves as a placeholder for functionality that can be expanded upon for API handling.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_no_config.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n)\n\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Service-Level Global Middleware Implementation\nDESCRIPTION: Implements middleware that targets all endpoints within a service scope.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/middleware_err_not_in_service.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n//encore:middleware target=all\nfunc AllInSvc(req middleware.Request, next middleware.Next) middleware.Response {\n    return next(req)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Database Named Connection in Encore for Go\nDESCRIPTION: This code snippet initializes a named database connection using the Encore framework's sqldb package. The Moo variable represents the database connection which is used throughout the application. Required dependencies include 'context' and 'encore.dev/storage/sqldb'.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_cross_service.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svca\n\nimport (\n    \"context\"\n\n    \"encore.dev/storage/sqldb\"\n)\n\nvar Moo = sqldb.Named(\"svca\")\n```\n\n----------------------------------------\n\nTITLE: Customizing Request and Response Encoding with Encore.ts\nDESCRIPTION: This snippet illustrates how to customize request and response encoding for API endpoints in Encore.ts. The example uses the 'Header' type from the 'encore.dev/api' module to parse fields from HTTP headers. Here, 'language' is fetched from the 'Accept-Language' header, demonstrating per-field customization for parsing incoming request data.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/defining-apis.mdx#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Header } from \"encore.dev/api\";\n\ninterface Params {\n  language: Header<\"Accept-Language\">; // parsed from header\n  author: string; // not a header\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Encore VPN Status\nDESCRIPTION: Determines the status of the Encore VPN connection.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_28\n\nLANGUAGE: shell\nCODE:\n```\n$ encore vpn status\n```\n\n----------------------------------------\n\nTITLE: Implementing Rate Limiting with Encore's Cache Keyspace in Go\nDESCRIPTION: Demonstrates creating an integer keyspace for tracking request counts per user and implementing a rate limiting middleware. The cached values expire after 10 seconds of inactivity and limits authenticated users to 10 requests per 10 seconds.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/caching.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nimport (\n    \"encore.dev/beta/auth\"\n    \"encore.dev/beta/errs\"\n    \"encore.dev/middleware\"\n)\n\n// RequestsPerUser tracks the number of requests per user.\n// The cache items expire after 10 seconds without activity.\nvar RequestsPerUser = cache.NewIntKeyspace[auth.UID](cluster, cache.KeyspaceConfig{\n\tKeyPattern:    \"requests/:key\",\n\tDefaultExpiry: cache.ExpireIn(10 * time.Second),\n})\n\n// RateLimitMiddleware is a global middleware that limits the number of authenticated requests\n// to 10 requests per 10 seconds.\n//encore:middleware target=all\nfunc RateLimitMiddleware(req middleware.Request, next middleware.Next) middleware.Response {\n\tif userID, ok := auth.UserID(); ok {\n\t\tval, err := RequestsPerUser.Increment(req.Context(), userID, 1)\n\n\t\t// NOTE: this \"fails open\", meaning if we can't communicate with the cache\n\t\t// we default to allowing the requests.\n\t\t//\n\t\t// Consider whether that's the correct behavior for your application,\n\t\t// or if you want to return an error to the user in that case.\n\t\tif err == nil && val > 10 {\n\t\t\treturn middleware.Response{\n\t\t\t\tErr: &errs.Error{Code: errs.ResourceExhausted, Message: \"rate limit exceeded\"},\n\t\t\t}\n\t\t}\n\t}\n\treturn next(req)\n}\n```\n\n----------------------------------------\n\nTITLE: Visual Studio Code Debug Configuration\nDESCRIPTION: JSON configuration for attaching a Node.js debugger in Visual Studio Code, specifying port and debugger type\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/debug.md#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Attach\",\n      \"port\": 9229,\n      \"request\": \"attach\",\n      \"skipFiles\": [\n        \"<node_internals>/**\"\n      ],\n      \"type\": \"node\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Map Key Value Extraction in CUE\nDESCRIPTION: Illustrates how to dynamically generate server configurations using map keys as values\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/config.md#2025-04-21_snippet_8\n\nLANGUAGE: cue\nCODE:\n```\n#Server: {\\n\\tserver: string\\n\\tport: int & > 1024\\n\\tenabled: bool | *true\\n}\\n\\nservers: [Name=string]: #Server & {\\n\\tserver: Name\\n}\\n\\nservers: {\\n\\t\"Foo\": {\\n        port: 8080\\n    },\\n    \"Bar\": {\\n        port:    8081\\n        enabled: false\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Archiving Secrets with Encore CLI\nDESCRIPTION: Command to archive a secret value by its identifier. Archiving makes the secret inactive but preserves its value.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_45\n\nLANGUAGE: bash\nCODE:\n```\nencore secret archive id\n```\n\n----------------------------------------\n\nTITLE: Streaming Application Logs with Encore CLI\nDESCRIPTION: Command for streaming application logs from Encore environments. The optional --env flag specifies which environment to stream logs from, and the --json flag formats the output as JSON.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_41\n\nLANGUAGE: bash\nCODE:\n```\nencore logs [--env=prod] [--json]\n```\n\n----------------------------------------\n\nTITLE: Custom Configuration Unmarshaler\nDESCRIPTION: Generates a custom JSON unmarshaler for the Config struct to handle complex type decoding\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_maps.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"Ages\":\n\t\t\tobj.Ages = config.ReadMap[string, int](itr, func(itr *jsoniter.Iterator, keyAsString string) (string, int) {\n\t\t\t\tkeyDecoder := new(__etype.Unmarshaller)\n\t\t\t\tkey := __etype.UnmarshalOne(keyDecoder, __etype.UnmarshalString, \"keyAsString\", keyAsString, true)\n\t\t\t\tif err := keyDecoder.Error; err != nil {\n\t\t\t\t\tpanic(fmt.Sprintf(\"unable to decode the config: %v\", err))\n\t\t\t\t}\n\t\t\t\treturn key, itr.ReadInt()\n\t\t\t})\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Installing JWT and Keyfunc Packages for Go\nDESCRIPTION: Install the required Go packages for JWT token handling and key management.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/logto-auth.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ go get github.com/golang-jwt/jwt/v5\n$ go get github.com/MicahParks/keyfunc/v3\n```\n\n----------------------------------------\n\nTITLE: Defining Service Struct in Go\nDESCRIPTION: This snippet defines a service struct used in the Encore framework. The Service struct is marked with the encore:service directive, indicating it is to be treated as a service for the Encore API. The snippet lays the groundwork for enabling API functionality within the service structure.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_receiver_invalid.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n//encore:service\n\t\t\ntype Service struct {}\n```\n\n----------------------------------------\n\nTITLE: Generated Code for Encore API Function Foo in Go\nDESCRIPTION: Automatically generated functions and interface implementations for the `Foo` API endpoint in Encore. Uses Encore internal utilities and provides methods for service interaction. There are no input parameters or complex return types.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/service_struct.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n// Code generated by encore. DO NOT EDIT.\n\npackage code\n\nimport \"context\"\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\n\nfunc Foo(ctx context.Context) error {\n\tsvc, err := EncoreInternal_svcstruct_Service.Get()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn svc.Foo(ctx)\n}\n\n// Interface defines the service's API surface area, primarily for mocking purposes.\n//\n// Raw endpoints are currently excluded from this interface, as Encore does not yet\n// support service-to-service API calls to raw endpoints.\ntype Interface interface {\n\tFoo(ctx context.Context) error\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Service Interface in Go\nDESCRIPTION: This snippet showcases the generated service interface in Go based on the annotated API endpoints. The interface, named `Interface`, defines the API surface area for the service, including the `Foo` endpoint.  This interface is primarily intended for mocking purposes and excludes raw endpoints.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/auth_handler.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// Code generated by encore. DO NOT EDIT.\n\npackage code\n\nimport \"context\"\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\n\n// Interface defines the service's API surface area, primarily for mocking purposes.\n//\n// Raw endpoints are currently excluded from this interface, as Encore does not yet\n// support service-to-service API calls to raw endpoints.\ntype Interface interface {\n\tFoo(ctx context.Context) error\n}\n```\n\n----------------------------------------\n\nTITLE: Testing URL Shortener with Go Tests\nDESCRIPTION: This test function 'TestShortenAndRetrieve' ensures the URL shortener's functionality by checking that a URL can be shortened, stored, and retrieved correctly. It is implemented using the Go testing package and verifies end-to-end behavior of URL processing logic.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/rest-api.mdx#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// TestShortenAndRetrieve - test that the shortened URL is stored and retrieved from database.\nfunc TestShortenAndRetrieve(t *testing.T) {\n\ttestURL := \"https://github.com/encoredev/encore\"\n\tsp := ShortenParams{URL: testURL}\n\tresp, err := Shorten(context.Background(), &sp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twantURL := testURL\n\tif resp.URL != wantURL {\n\t\tt.Errorf(\"got %q, want %q\", resp.URL, wantURL)\n\t}\n\n\tfirstURL := resp\n\tgotURL, err := Get(context.Background(), firstURL.ID)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif *gotURL != *firstURL {\n\t\tt.Errorf(\"got %v, want %v\", *gotURL, *firstURL)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image with Infrastructure Config in Bash\nDESCRIPTION: Command to build a Docker image for an Encore app, specifying a path to the infrastructure configuration file.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nencore build docker --config path/to/infra-config.json MY-IMAGE:TAG\n```\n\n----------------------------------------\n\nTITLE: Live-streaming Logs from Encore Applications\nDESCRIPTION: Demonstrates the command to live-stream logs from any Encore environment directly to the terminal, facilitating real-time monitoring and debugging.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/observability/logging.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ encore logs --env=prod\n```\n\n----------------------------------------\n\nTITLE: Defining Schema for Number Fields\nDESCRIPTION: This snippet defines a TypeScript interface for validating number fields in the request schema, which can accept both integer and float values.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Schema {\n  age:  number;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a TypeScript Client for Specific Services\nDESCRIPTION: This command generates a TypeScript client for the `email` and `users` services and saves it to `client.ts`. It uses the `--services` flag to filter the services.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/client-generation.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n\"encore gen client --services=email,users -o client.ts\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Drizzle with drizzle-kit\nDESCRIPTION: This snippet shows how to configure Drizzle using `drizzle.config.ts`. It defines the output directory for migrations, the schema file, and the database dialect (PostgreSQL).  It uses `dotenv/config` to load environment variables.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/orms/drizzle.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// drizzle.config.ts\nimport 'dotenv/config';\nimport { defineConfig } from 'drizzle-kit';\n\nexport default defineConfig({\n  out: 'migrations',\n  schema: 'schema.ts',\n  dialect: 'postgresql',\n});\n```\n\n----------------------------------------\n\nTITLE: VS Code Debug Configuration for Delve\nDESCRIPTION: JSON configuration for connecting to a remote Delve debugging server in Visual Studio Code\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/debug.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Connect to server\",\n            \"type\": \"go\",\n            \"request\": \"attach\",\n            \"mode\": \"remote\",\n            \"remotePath\": \"${workspaceFolder}\",\n            \"port\": 2345,\n            \"host\": \"127.0.0.1\"\n        }\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Configuration Loading and API Endpoint in Go\nDESCRIPTION: Loads the configuration using Encore's config.Load method and defines a minimal API endpoint with no implementation. The API is annotated with encore:api for framework integration.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_wrappers.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nvar _ = config.Load[*Config]()\n\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Secrets Structure and API Function in Go\nDESCRIPTION: Defines a Go struct for holding secret data and an API function `Foo` as part of the Encore project. The `Foo` function is a placeholder representing an API endpoint that currently returns nil. This is under a specific package `svc` indicating service functionality.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/secrets.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport \"context\"\n\nvar secrets struct {\n    Foo string\n}\n\n//encore:api public\nfunc Foo(ctx context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Main Application Initialization\nDESCRIPTION: Bootstraps the Encore application by importing services and calling the main app initialization method\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/multiple_services.txt#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n\tappinit.AppMain()\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Service Registration in Go\nDESCRIPTION: This snippet handles the registration of the Encore service structure. It sets up the service parameters required for integrating with the Encore framework.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/service_struct.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n-- want:encore_internal__svcstruct.go --\npackage basic\n\nimport __service \"encore.dev/appruntime/apisdk/service\"\n\nfunc init() {\n\t__service.Register(EncoreInternal_svcstruct_Service)\n}\n\nvar EncoreInternal_svcstruct_Service = &__service.Decl[Service]{\n\tName:        \"Service\",\n\tService:     \"basic\",\n\tSetup:       nil,\n\tSetupDefLoc: uint32(0x0),\n}\n```\n\n----------------------------------------\n\nTITLE: Encore Internal API Endpoint Registration\nDESCRIPTION: Automatic registration of API endpoints with internal metadata, request/response handling, and serialization support\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/api_call.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Bar, Bar)\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Response Cookies in Go\nDESCRIPTION: Example of setting cookies in HTTP response using struct tags in Encore.go\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nstruct {\n    SessionID string `header:\"Set-Cookie\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Encore API Interface\nDESCRIPTION: This code section represents an automatically generated interface by Encore for the Go package basic. It defines a single method, Foo, for mocking purposes and does not support raw endpoint service-to-service calls at this time.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/basic.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage basic\n\nimport \"context\"\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\n\n// Interface defines the service's API surface area, primarily for mocking purposes.\n//\n// Raw endpoints are currently excluded from this interface, as Encore does not yet\n// support service-to-service API calls to raw endpoints.\ntype Interface interface {\n\tFoo(ctx context.Context) error\n}\n```\n\n----------------------------------------\n\nTITLE: Encore API Parameter Name Mismatch\nDESCRIPTION: This code defines an Encore API endpoint `/str/:foo` with a path parameter named `foo`. The function `Str` attempts to handle this API call but declares a parameter `bar` instead of `foo`. This causes a validation error in Encore because the parameter names must match.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_invalid_path_param_name.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\t\"encore.dev/types/uuid\"\n)\n\n//encore:api public path=/str/:foo\nfunc Str(ctx context.Context, bar string) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Initializing API Endpoint in Encore Internal Golang\nDESCRIPTION: This code initializes and registers API endpoints within the Encore framework. It handles requests, responses, and error handling for the 'Foo' API. Dependencies include various Encore and third-party Go packages for API handling and JSON marshaling/unmarshaling. Key functions ensure proper endpoint initialization, data encoding/decoding, and HTTP header management.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/response_headers.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\npackage code\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\t__etype \"encore.dev/appruntime/shared/etype\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n}\n\ntype EncoreInternal_FooReq struct{}\n\ntype EncoreInternal_FooResp = *Params\n\nvar EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{\n\tAccess: __api.Public,\n\tAppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {\n\t\tresp, err := Foo(ctx)\n\t\tif err != nil {\n\t\t\treturn (*Params)(nil), err\n\t\t}\n\t\treturn resp, nil\n\t},\n\tCloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {\n\t\tvar clone *EncoreInternal_FooReq\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tCloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {\n\t\tvar clone EncoreInternal_FooResp\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tDecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {\n\t\tresp = new(Params)\n\t\tdec := new(__etype.Unmarshaller)\n\t\t// Decode headers\n\t\th := httpResp.Header\n\t\tresp.Foo = __etype.UnmarshalOne(dec, __etype.UnmarshalString, \"x-foo\", h.Get(\"x-foo\"), false)\n\n\t\tif err := dec.Error; err != nil {\n\t\t\treturn (*Params)(nil), err\n\t\t}\n\t\treturn resp, nil\n\t},\n\tDecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {\n\t\treqData = new(EncoreInternal_FooReq)\n\t\treturn reqData, nil, nil\n\t},\n\tDefLoc: uint32(0x0),\n\tEncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {\n\t\treturn nil, nil, nil\n\t},\n\tEncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {\n\t\trespData := []byte{'\n'}\n\t\tvar headers map[string][]string\n\t\tif resp != nil {\n\n\t\t\t// Encode headers\n\t\t\theaders = map[string][]string{\"x-foo\": []string{__etype.MarshalOne(__etype.MarshalString, resp.Foo)}}\n\t\t}\n\n\t\t// Write response\n\t\tfor k, vs := range headers {\n\t\t\tfor _, v := range vs {\n\t\t\t\tw.Header().Add(k, v)\n\t\t\t}\n\t\t}\n\t\tw.Write(respData)\n\t\treturn nil\n\t},\n\tEndpoint:            \"Foo\",\n\tFallback:            false,\n\tGlobalMiddlewareIDs: []string{},\n\tMethods:             []string{\"GET\", \"POST\"},\n\tPath:                \"/code.Foo\",\n\tPathParamNames:      nil,\n\tRaw:                 false,\n\tRawHandler:          nil,\n\tRawPath:             \"/code.Foo\",\n\tReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {\n\t\treturn \"/code.Foo\", nil, nil\n\t},\n\tReqUserPayload: func(reqData *EncoreInternal_FooReq) any {\n\t\treturn nil\n\t},\n\tService:           \"code\",\n\tServiceMiddleware: []*__api.Middleware{},\n\tSvcNum:            1,\n\tTags:              nil,\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Config Structure with Encore.dev\nDESCRIPTION: Defines a Config struct with a generic type parameter T. The structure includes a nested LibraryConfig, generic config values, and direct slice fields. It also loads the configuration for int type.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/config.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/config\"\n\n    \"test/libraries/shared\"\n)\n\ntype Config[T any] struct {\n    Library    shared.LibraryConfig\n    OtherValue config.Value[T]\n    NameList   config.Values[string]\n    ValueList config.Value[[]T]\n    List []T\n}\n\nvar cfg = config.Load[Config[int]]()\n\n\n// encore:api\nfunc Subscriber1(ctx context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: SQL Database Query with Type Safety\nDESCRIPTION: Example of querying a SQL database with type-safe row specification in Encore.ts\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst rows = await db.query<{ email: string; source_url: string; scraped_at: Date }>`\n    SELECT email, source_url, created_at as scraped_at\n    FROM scraped_emails\n    ORDER BY created_at DESC\n`;\n\n// Fetch all rows and return them as an array\nconst emails = [];\nfor await (const row of rows) {\n    emails.push(row);\n}\n\nreturn { emails };\n```\n\n----------------------------------------\n\nTITLE: Defining API endpoints with integer parameters in Encore\nDESCRIPTION: This code defines an Encore API endpoint `/int/:p` that accepts an integer parameter `p`. The `encore:api public path=/int/:p` annotation exposes the function as a public HTTP endpoint. The function `Int` takes a context and the integer parameter as input and returns an error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_path_params.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\t\"encore.dev/types/uuid\"\n)\n\n//encore:api public path=/int/:p\nfunc Int(ctx context.Context, p int) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Initializing Firebase SDK in Go\nDESCRIPTION: Code to set up the Firebase Auth client using syncutil.Once for lazy initialization.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/firebase-auth.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nvar (\n\tfbAuth    *fbauth.Client\n\tsetupOnce syncutil.Once\n)\n\n// setupFB ensures Firebase Auth is setup.\nfunc setupFB() error {\n    return setupOnce.Do(func() error {\n        opt := option.WithCredentialsJSON([]byte(secrets.FirebasePrivateKey))\n        app, err := firebase.NewApp(context.Background(), nil, opt)\n        if err == nil {\n            fbAuth, err = app.Auth(context.Background())\n        }\n        return err\n    })\n}\n\nvar secrets struct {\n\t// FirebasePrivateKey is the JSON credentials for calling Firebase.\n\tFirebasePrivateKey string\n}\n```\n\n----------------------------------------\n\nTITLE: Direct Secrets Configuration in JSON\nDESCRIPTION: Configuration for secrets, demonstrating how to set secret values directly or using environment variable references.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"secrets\": {\n    \"API_TOKEN\": \"embedded-secret-value\",\n    \"DB_PASSWORD\": {\n      \"$env\": \"DB_PASSWORD\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PubSub Message Publishing Function in Go\nDESCRIPTION: This function, marked as an Encore API endpoint, demonstrates how to publish a message to the previously defined BasicTopic. It creates a new MessageType instance and publishes it to the topic.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_publish_in_middleware.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n// encore:api\nfunc DoStuff(ctx context.Context) error {\n    return BasicTopic.Publish(ctx, &MessageType{UserID: 1, Name: \"foo\"})\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Drizzle Migrations with drizzle-kit\nDESCRIPTION: This command generates database migrations using the `drizzle-kit` CLI tool.  It should be run in the directory containing the `drizzle.config.ts` file.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/orms/drizzle.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndrizzle-kit generate\n```\n\n----------------------------------------\n\nTITLE: Load Config With Custom Unmarshaler\nDESCRIPTION: This Go code demonstrates how to load configuration values using `config.Load` from the `encore.dev/config` package and provides a custom unmarshaler for handling generic types. This allows Encore to correctly load configuration data into the `CfgType` structure, which includes fields with dynamic values and generic parameters.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/generics.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage generics\n\nimport (\n    \"context\"\n    \"encore.dev/config\"\n)\n\ntype CfgType[T any] struct {\n\tReadOnlyMode config.Bool\n\tPublicKey    config.Bytes\n\tAdminUsers   config.Values[string]\n\n\tSubConfig config.Value[struct {\n\t\tSubKey *SubCfgType[T]\n\t}]\n\n\tCurrencies map[string]struct {\n\t\tName    config.String\n\t\tCode    config.String\n\t\tAliases config.Values[string]\n\t}\n\n\tAnotherList config.Values[struct {\n\t\tName config.String\n\t}]\n}\n\ntype SubCfgType[T any] struct {\n\tMaxCount T\n}\n\nvar cfg = config.Load[*CfgType[uint]](\"generics\", encoreInternalConfigUnmarshaler_ptr_examplecom_CfgType_uint_/*line :32:39*/)\n\ntype ConfigResponse struct {\n\tReadOnlyMode bool\n\tPublicKey    []byte\n\tSubKeyCount  uint\n\tAdminUsers   []string\n}\n\n// There must be an API endopint to use config.Load.\n//encore:api public\nfunc Dummy(context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Defining Configuration Struct in Go\nDESCRIPTION: Defines a configuration struct with interdependent integer fields using CUE tags for validation and configuration loading\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/cue_tags.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype Config struct {\n    A int\n    B int `cue:\"A+C\"`\n    C int `cue:\"B-A\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Encore Public API Endpoint in Go\nDESCRIPTION: Defines a public API endpoint named Foo using Encore's annotation system. The function takes a context and returns an error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cache_cluster_outside_svc.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public\nfunc Foo(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Defining API Function in Go with Encore\nDESCRIPTION: This snippet defines an API function named 'Foo' which takes a context and returns an error. It is part of the service package and is built using the Encore framework. The function currently does not implement any functionality beyond returning nil.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_outside_svc.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc Foo(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Encore Application Main Initialization\nDESCRIPTION: Standard main function for Encore applications that uses appinit to bootstrap the application runtime\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/basic.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n\tappinit.AppMain()\n}\n```\n\n----------------------------------------\n\nTITLE: Checking VPN Status with Encore CLI\nDESCRIPTION: Command to check the current status of the VPN connection to Encore environments.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_50\n\nLANGUAGE: bash\nCODE:\n```\nencore vpn status\n```\n\n----------------------------------------\n\nTITLE: Calling an API from Another Package in Go\nDESCRIPTION: This snippet shows an attempt to call a public API defined in another package using Go. The `Foo` function in package `two` tries to call the `One` function from package `one`, passing a context. This operation highlights a constraint in Encore where public APIs cannot be freely called outside of their service context.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_outside_service.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage two\n\nimport (\n    \"context\"\n\n    \"test/one\"\n)\n\nfunc Foo(ctx context.Context) error {\n    return one.One(ctx)\n}\n```\n\n----------------------------------------\n\nTITLE: Service Interface Generation for API Endpoints\nDESCRIPTION: Automatically generated interface to define the service's API surface, supporting mocking and service interactions\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/basic.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype Interface interface {\n\tFoo(ctx context.Context) error\n}\n```\n\n----------------------------------------\n\nTITLE: CORS Configuration Structure in CUE\nDESCRIPTION: This CUE code snippet defines the structure for configuring CORS settings within an Encore application. It includes options for enabling debug logging, specifying allowed and exposed headers, and defining allowed origins for both credentialed and non-credentialed requests.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/frontend/cors.md#2025-04-21_snippet_0\n\nLANGUAGE: cue\nCODE:\n```\n\n{\n    // debug enables CORS debug logging.\n    \"debug\": true | false,\n\n    // allow_headers allows an app to specify additional headers that should be\n    // accepted by the app.\n    //\n    // If the list contains \"*\", then all headers are allowed.\n    \"allow_headers\": [...string],\n\n    // expose_headers allows an app to specify additional headers that should be\n    // exposed from the app, beyond the default set always recognized by Encore.\n    //\n    // If the list contains \"*\", then all headers are exposed.\n    \"expose_headers\": [...string],\n\n    // allow_origins_without_credentials specifies the allowed origins for requests\n    // that don't include credentials. If nil it defaults to allowing all domains\n    // (equivalent to [\"*\"]).\n    \"allow_origins_without_credentials\": [...string],\n\n    // allow_origins_with_credentials specifies the allowed origins for requests\n    // that include credentials. If a request is made from an Origin in this list\n    // Encore responds with Access-Control-Allow-Origin: <Origin>.\n    //\n    // The URLs in this list may include wildcards (e.g. \"https://*.example.com\"\n    // or \"https://*-myapp.example.com\").\n    \"allow_origins_with_credentials\": [...string],\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining API Parameters in Go\nDESCRIPTION: This snippet defines the parameters used by the API function, including custom types and JSON serialization tags. It requires the 'context' package for handling request context. The 'Params' struct contains fields for various parameters passed to the API endpoint, with potentially empty JSON fields.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/complex_omitempty.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage basic\n\nimport \"context\"\n\ntype NotComparable struct{\n    Foo []string\n}\n\ntype NamedNotComparable NotComparable\n\ntype Int int\n\ntype Params struct {\n    X NotComparable `json:\"x,omitempty\"`\n    Integer Int `json:\"int,omitempty\"`\n}\n\n//encore:api public\nfunc Foo(ctx context.Context, p *Params) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Generated Encore API Methods in Go\nDESCRIPTION: This code snippet contains auto-generated API methods for the Encore service, which handle calls to the service's API endpoints. It includes methods for handling input data and error management when interacting with the primary service. The methods allow external services to call these APIs and manage request/response data properly.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/userfacinggen/testdata/service_struct.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// want:encore.gen.go --\n// Code generated by encore. DO NOT EDIT.\n\npackage basic\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n)\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\n\n// Foo is an amazing API which does\n// x, y and z - it's really cool!\nfunc Foo(ctx context.Context) error {\n\tsvc, err := EncoreInternal_svcstruct_Service.Get()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn svc.Foo(ctx)\n}\n\nfunc Raw(ctx context.Context, req *http.Request) (*http.Response, error) {\n\treturn nil, errors.New(\"encore: calling raw endpoints is not yet supported\")\n}\n\nfunc WithReq(ctx context.Context, p *Data) error {\n\tsvc, err := EncoreInternal_svcstruct_Service.Get()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn svc.WithReq(ctx, p)\n}\n\nfunc WithResp(ctx context.Context) (*Data, error) {\n\tsvc, err := EncoreInternal_svcstruct_Service.Get()\n\tif err != nil {\n\t\treturn (*Data)(nil), err\n\t}\n\treturn svc.WithResp(ctx)\n}\n\nfunc WithReqResp(ctx context.Context, p *Data) (*Data, error) {\n\tsvc, err := EncoreInternal_svcstruct_Service.Get()\n\tif err != nil {\n\t\treturn (*Data)(nil), err\n\t}\n\treturn svc.WithReqResp(ctx, p)\n}\n\nfunc WithPathParams(ctx context.Context, name string, age int, other string) error {\n\tsvc, err := EncoreInternal_svcstruct_Service.Get()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn svc.WithPathParams(ctx, name, age, other)\n}\n\nfunc WithFallback(ctx context.Context, url string) error {\n\tsvc, err := EncoreInternal_svcstruct_Service.Get()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn svc.WithFallback(ctx, url)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Environment Reference Secrets Configuration\nDESCRIPTION: Configuration for secrets using environment variable JSON references\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"secrets\": {\n    \"$env\": \"SECRET_JSON\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Stopping VPN Connection\nDESCRIPTION: The `encore vpn stop` command terminates the active VPN connection.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_30\n\nLANGUAGE: shell\nCODE:\n```\n$ encore vpn stop\n```\n\n----------------------------------------\n\nTITLE: Setting Encore Secret for Pexels API Key\nDESCRIPTION: Command to set the Pexels API key as an Encore secret for secure storage and usage.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/meeting-notes.mdx#2025-04-21_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nencore secret set --type dev,prod,local,pr PexelsApiKey\n```\n\n----------------------------------------\n\nTITLE: Generating ent Client Files in Go\nDESCRIPTION: Command to generate ent client files based on the defined schemas.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/entgo-orm.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ go run entgo.io/ent/cmd/ent@latest generate ./user/ent/schema\n```\n\n----------------------------------------\n\nTITLE: Switching to or Creating a Namespace using Encore CLI\nDESCRIPTION: This command switches to the specified namespace 'my-ns', creating it if it does not already exist. This is a convenient way to ensure the namespace is available without prior checks.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/infra-namespaces.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ encore namespace switch --create my-ns\n```\n\n----------------------------------------\n\nTITLE: Emitting Log Messages using Encore's Logging Functions\nDESCRIPTION: This snippet demonstrates how to import the logging module from Encore and use it to log messages with different severity levels. The first parameter is a string message, and the second parameter is an object representing structured data.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/observability/logging.md#2025-04-21_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nlog.info(\"log message\", {is_subscriber: true})\nlog.error(err, \"something went terribly wrong!\")\n```\n\n----------------------------------------\n\nTITLE: Utility Config Definitions in Encore - Golang\nDESCRIPTION: Defines 'ExtraConfig' struct in the 'utils' package for configuration handling in Encore. It utilizes 'encore.dev/config' for defining different config types like 'Foo' as a string and 'Bar' as an int, allowing for structured configuration management.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/name_conflicts.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage utils\n\nimport (\n\t\"encore.dev/config\"\n)\n\ntype ExtraConfig struct{\n    Foo config.String\n    Bar config.Int\n}\n```\n\n----------------------------------------\n\nTITLE: Encore Infrastructure Configuration\nDESCRIPTION: This JSON configuration file specifies the infrastructure configuration for the Encore application, including the connection details for the SQL database. It defines the host, TLS configuration, database name, username, and password.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/deploy-to-railway.md#2025-04-21_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n\"{\\n   \\\"$schema\\\": \\\"https://encore.dev/schemas/infra.schema.json\\\",\\n   \\\"sql_servers\\\": [\\n   {\\n      \\\"host\\\": \\\"<hostname>.rlwy.net:39684\\\",\\n      \\\"tls_config\\\": {\\n         \\\"disable_ca_validation\\\": true\\n      },\\n      \\\"databases\\\": {\\n         \\\"mydb\\\": {\\n            \\\"name\\\": \\\"railway\\\",\\n            \\\"username\\\": \\\"postgres\\\",\\n            \\\"password\\\": {\\\"$env\\\": \\\"DB_PASSWORD\\\"}\\n          }\\n         }\\n      }]   \\n   }\"\n```\n\n----------------------------------------\n\nTITLE: Application Initialization in Go\nDESCRIPTION: This snippet demonstrates the main function for application initialization in Encore. It imports the necessary packages, including `encore.dev/appruntime/apisdk/app/appinit` for application runtime and an example package `example.com`. The `appinit.AppMain()` function is called to perform the main application initialization.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/auth_handler.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\tappinit \"encore.dev/appruntime/apisdk/app/appinit\"\n\t_ \"example.com\"\n)\n\nfunc main() {\n\tappinit.AppMain()\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Simple API Endpoint in Go\nDESCRIPTION: Defines a simple API function Foo with context that returns an error, marked with Encore's API annotation\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/basic.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc Foo(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Unsupported API Parameter Types\nDESCRIPTION: This snippet outlines error messages related to the use of unsupported types in API parameters. It specifically addresses the limitations of using nested structures in GET requests, providing details on the supported types and offering guidance on how to modify requests to either POST or PUT to accommodate complex types.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_invalid_query_type.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n Invalid request type [E9999]\n\nAPI request parameters of type *Nested are not supported in query strings. You can only use\nbuilt-in types, or slices of built-in types such as strings, booleans, int, time.Time.\n\n    [ svc/svc.go:14:9 ]\n    \n 12  type Params struct {\n 13      Foo uuid.UUID\n 14      Bar *Nested\n             \n                 unsupported type\n 15  }\n 16 \n 17  //encore:api public method=GET\n                         \n                              you could change this to a POST or PUT request\n 18  func Str(ctx context.Context, p *Params) error { return nil }\n                                   \n                                        used here\n 19 \n\n\nAPIs which are sent as GET, HEAD or DELETE requests are unable to contain JSON bodies, thus all\nparameters must be sent as query strings or headers. See\nhttps://encore.dev/docs/develop/api-schemas#supported-types for more information.\n```\n\n----------------------------------------\n\nTITLE: Initializing the PubSub Topic in Go\nDESCRIPTION: This snippet contains an initialization function that is called when the package is initialized. It invokes the Foo method on the Topic to set up necessary configurations or state.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/parser/resource/usage/testdata/pubsub_usage.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc init() {\n    Topic.Foo() // use svc.Topic call Foo\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Client Generation\nDESCRIPTION: This command executes Go tests to ensure the correctness of the client generation. It runs the tests located within the `internal/clientgen` directory.  It uses the generated client files and provides a way to verify that the client generation code is working as expected. The command relies on generated files, which should be created beforehand. The command requires the Go tool and is run from the `e2e-tests` directory after client files generation.\nSOURCE: https://github.com/encoredev/encore/blob/main/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\ngo test ./internal/clientgen\n```\n\n----------------------------------------\n\nTITLE: Cron Job Implementation in Encore.ts\nDESCRIPTION: Demonstrates creating a periodic background task using Encore.ts CronJob\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CronJob } from \"encore.dev/cron\";\nimport { api } from \"encore.dev/api\";\n\nconst _ = new CronJob(\"welcome-email\", {\n    title: \"Send welcome emails\",\n    every: \"2h\",\n    endpoint: sendWelcomeEmail,\n})\n\nexport const sendWelcomeEmail = api({}, async () => {\n    // Send welcome emails...\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing Public Objects via URL in Encore\nDESCRIPTION: This code snippet demonstrates how to generate a public URL for accessing objects in a publicly accessible Encore storage bucket. The `publicUrl` method returns the URL that can be used to access the object directly.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst url = publicProfilePictures.publicUrl(\"my-image.jpeg\");\n```\n\n----------------------------------------\n\nTITLE: Audit Logging Based on Cloud Environment\nDESCRIPTION: This code example shows how to implement different behaviors based on the cloud provider environment using the appMeta function from Encore.js. It executes different logging functionalities accordingly.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nimport { appMeta } from \"encore.dev\";\n\nasync function audit(userID: string, event: Record<string, any>) {\n  const cloud = appMeta().environment.cloud;\n  switch (cloud) {\n    case \"aws\": return writeIntoRedshift(userID, event);\n    case \"gcp\": return writeIntoBigQuery(userID, event);\n    case \"local\": return writeIntoFile(userID, event);\n    default: throw new Error(`unknown cloud: ${cloud}`);\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Invalid Cross-Package Auth Handler Access in Go\nDESCRIPTION: Shows an invalid attempt to directly call an authentication handler from another package (svc2), which is not allowed in Encore's architecture.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/auth_handler_call.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc2\n\nimport (\n    \"context\"\n    \"test/svc\"\n)\n\nfunc Foo() {\n    svc.MyAuth(context.Background(), \"foo\")\n}\n```\n\n----------------------------------------\n\nTITLE: Booking Confirmation Emails with SendGrid in Go\nDESCRIPTION: This Go code snippet integrates SendGrid to send booking confirmation emails after successfully booking a slot. It checks slot availability, inserts new bookings, and sends a formatted email. Prerequisites include an Encore app setup with SendGrid library integration.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_22\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public method=POST path=/booking\nfunc Book(ctx context.Context, p *BookParams) error {\n\teb := errs.B()\n\n\tnow := time.Now()\n\tif p.Start.Before(now) {\n\t\treturn eb.Code(errs.InvalidArgument).Msg(\"start time must be in the future\").Err()\n\t}\n\n\ttx, err := pgxdb.Begin(ctx)\n\tif err != nil {\n\t\treturn eb.Cause(err).Code(errs.Unavailable).Msg(\"failed to start transaction\").Err()\n\t}\n\tdefer tx.Rollback(context.Background()) // committed explicitly on success\n\n\t// Get the bookings for this day.\n\tstartOfDay := time.Date(p.Start.Year(), p.Start.Month(), p.Start.Day(), 0, 0, 0, 0, p.Start.Location())\n\tbookings, err := listBookingsBetween(ctx, startOfDay, startOfDay.AddDate(0, 0, 1))\n\tif err != nil {\n\t\treturn eb.Cause(err).Code(errs.Unavailable).Msg(\"failed to list bookings\").Err()\n\t}\n\n\t// Is this slot bookable?\n\tslot := BookableSlot{Start: p.Start, End: p.Start.Add(DefaultBookingDuration)}\n\tif len(filterBookableSlots([]BookableSlot{slot}, now, bookings)) == 0 {\n\t\treturn eb.Code(errs.InvalidArgument).Msg(\"slot is unavailable\").Err()\n\t}\n\n\t_, err = query.InsertBooking(ctx, db.InsertBookingParams{\n\t\tStartTime: pgtype.Timestamp{Time: p.Start, Valid: true},\n\t\tEndTime:   pgtype.Timestamp{Time: p.Start.Add(DefaultBookingDuration), Valid: true},\n\t\tEmail:     p.Email,\n\t})\n\tif err != nil {\n\t\treturn eb.Cause(err).Code(errs.Unavailable).Msg(\"failed to insert booking\").Err()\n\t}\n\n\tif err := tx.Commit(ctx); err != nil {\n\t\treturn eb.Cause(err).Code(errs.Unavailable).Msg(\"failed to commit transaction\").Err()\n\t}\n\n\t// Send confirmation email using SendGrid\n\tformattedTime := pgtype.Timestamp{Time: p.Start, Valid: true}.Time.Format(\"2006-01-02 15:04\")\n\t_, err = sendgrid.Send(ctx, &sendgrid.SendParams{\n\t\tFrom: sendgrid.Address{\n\t\t\tName:  \"<your name>\",\n\t\t\tEmail: \"<your email>\",\n\t\t},\n\t\tTo: sendgrid.Address{\n\t\t\tEmail: p.Email,\n\t\t},\n\t\tSubject: \"Booking Confirmation\",\n\t\tText:    \"Thank you for your booking!\\nWe look forward to seeing you soon at \" + formattedTime,\n\t\tHtml:    \"\",\n\t})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Current Infrastructure Namespaces using Encore CLI\nDESCRIPTION: This command lists all existing infrastructure namespaces, indicating the current one with an asterisk. This is useful for keeping track of different sessions and their respective contexts.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/infra-namespaces.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ encore namespace list\n```\n\n----------------------------------------\n\nTITLE: Creating a Logger Object for Grouped Logging\nDESCRIPTION: This code snippet shows how to create a Logger object using Encore's log.with() method. This allows you to attach common key-value pairs to multiple log events efficiently.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/observability/logging.md#2025-04-21_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst logger = log.with({is_subscriber: true})\nlogger.info(\"user logged in\", {login_method: \"oauth\"}) // includes is_subscriber=true\n```\n\n----------------------------------------\n\nTITLE: Defining an Encore API endpoint with path parameters in Go\nDESCRIPTION: This snippet defines a Go function `Str` and exposes it as a public Encore API endpoint with path parameters `foo` and `bar`. The `//encore:api` directive specifies the API path. However, the function signature `func Str(ctx context.Context) error` does not include parameters to capture the values from the path parameters, which triggers a validation error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_invalid_path_too_few_params.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\t\"encore.dev/types/uuid\"\n)\n\n//encore:api public path=/str/:foo/:bar\nfunc Str(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Defining Cache Cluster in Encore Service\nDESCRIPTION: Creates a cache cluster named 'cluster' within an Encore service package, which is a valid location for cluster definition.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cache_err_keyspace_outside_svc.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/storage/cache\"\n)\n\nvar Cluster = cache.NewCluster(\"cluster\", cache.ClusterConfig{})\n\n//encore:api public\nfunc Foo(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Listing Secrets with Encore CLI\nDESCRIPTION: Command to list secret values. Can optionally filter by providing specific key names as arguments.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_44\n\nLANGUAGE: bash\nCODE:\n```\nencore secret list [keys...]\n```\n\n----------------------------------------\n\nTITLE: Register Encore Service Structure in Go\nDESCRIPTION: Initializes the service structure using Encore's internal `__service` package. The initialization links the `Service` struct to its setup function, making it ready for use. It does not process inputs or generate outputs.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/service_struct.txt#2025-04-21_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\npackage code\n\nimport __service \"encore.dev/appruntime/apisdk/service\"\n\nfunc init() {\n\t__service.Register(EncoreInternal_svcstruct_Service)\n}\n\nvar EncoreInternal_svcstruct_Service = &__service.Decl[Service]{\n\tName:        \"Service\",\n\tService:     \"code\",\n\tSetup:       initService,\n\tSetupDefLoc: uint32(0x0),\n}\n```\n\n----------------------------------------\n\nTITLE: Running Docker Image with Custom Port - Bash\nDESCRIPTION: Demonstrates how to run a Docker image while setting a custom PORT environment variable. This snippet is useful for running the image on a specified port, replacing the default port 8080 with a user-defined port, in this case, 8081. It utilizes Docker's environment variable capabilities to achieve this.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/self-host.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -e PORT=8081 -p 8081:8081 MY-IMAGE:TAG\n```\n\n----------------------------------------\n\nTITLE: Defining Cache Keyspace with Generic Types in Go\nDESCRIPTION: Creates a cache keyspace with a generic Key type and configures it with a specific key pattern. Uses a cluster defined in an external library package.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cache_cluster_outside_svc.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nvar keyspace = cache.NewStringKeyspace[Key[string]](lib.Cluster, cache.KeyspaceConfig{\n    KeyPattern: \"foo/:Foo\",\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Site Database Schema\nDESCRIPTION: SQL migration to create the initial site table structure\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE site (\n    id SERIAL PRIMARY KEY,\n    url TEXT NOT NULL UNIQUE\n);\n```\n\n----------------------------------------\n\nTITLE: Integrating Encore Client with TanStack Query (TypeScript)\nDESCRIPTION: This TypeScript code demonstrates integrating an Encore request client with TanStack Query for asynchronous state management in a React application. It creates a React Query client, defines a component to fetch and display a list of todos, and uses a mutation to add new todos, automatically invalidating and refetching the query on success.  It assumes the existence of a `todo` service with `List` and `Add` endpoints.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/frontend/request-client.mdx#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n\"import {\n  useQuery,\n  useMutation,\n  useQueryClient,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\nimport Client, { todo } from '../encore-client'\n\n// Create a Encore client\nconst encoreClient = new Client(window.location.origin);\n\n// Create a react-query client\nconst queryClient = new QueryClient()\n\nfunction App() {\n  return (\n    // Provide the client to your App\n    <QueryClientProvider client={queryClient}>\n      <Todos />\n    </QueryClientProvider>\n  )\n}\n\nfunction Todos() {\n  // Access the client\n  const queryClient = useQueryClient()\n\n  // Queries\n  const query = useQuery({\n    queryKey: ['todos'],\n    queryFn: () => encoreClient.todo.List()\n  })\n\n  // Mutations\n  const mutation = useMutation({\n    mutationFn: (params: todo.AddParams) => encoreClient.todo.Add(params),\n    onSuccess: () => {\n      // Invalidate and refetch\n      queryClient.invalidateQueries({ queryKey: ['todos'] })\n    },\n  })\n\n  return (\n    <div>\n      <ul>\n        {query.data?.map((todo) => (\n          <li key={todo.id}>{todo.title}</li>\n        ))}\n      </ul>\n\n      <button\n        onClick={() => {\n          mutation.mutate({\n            id: Date.now(),\n            title: 'Do Laundry',\n          })\n        }}\n      >\n        Add Todo\n      </button>\n    </div>\n  )\n}\n\nrender(<App />, document.getElementById('root'))\"\n```\n\n----------------------------------------\n\nTITLE: Defining Service Configuration with Encore\nDESCRIPTION: This code defines the service configuration using the `encore.dev/config` package. It includes various configuration options with different types, such as strings, integers, booleans, times, UUIDs, and byte arrays, and demonstrates the use of `config.String`, `config.Uint16`, `config.Bool`, `config.Int`, `config.Time`, `config.UUID`, `config.Value[[]byte]`, and `config.Values[string]` to represent the configuration fields.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_wrappers.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n    \"time\"\n\n\t\"encore.dev/config\"\n\t\"encore.dev/types/uuid\"\n)\n\ntype Config struct {\n    Name        config.String    // The users name\n    Port        config.Uint16\n    ReadOnly    config.Bool      // true if we're in read only mode\n\n    // MagicNumber is complicated and requires\n    // a multi-line comment to explain it.\n    MagicNumber config.Int\n\n    Start       config.Time // The time at which the service was first started\n    ID          config.UUID // An ID\n\n    PublicKey config.Value[[]byte]\n\n    AdminUsers config.Values[string]\n}\n\nvar _ = config.Load[*Config]()\n```\n\n----------------------------------------\n\nTITLE: Testing Encore Application\nDESCRIPTION: The `encore test` command executes tests within your application. It accepts the same flags as the standard `go test` command.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ encore test ./... [go test flags]\n```\n\n----------------------------------------\n\nTITLE: Registering Tagged API Details - Go\nDESCRIPTION: This snippet initializes the Encore API by registering the `Tagged` function. It defines request and response structures, HTTP request/response handling, and specifies tagging for the endpoint to manage access. The provided example showcases the handling of API requests and responses in a typical middleware structure.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/endpoint_tags.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Tagged, Tagged)\n}\n\ntype EncoreInternal_TaggedReq struct{}\n\ntype EncoreInternal_TaggedResp = __api.Void\n\nvar EncoreInternal_api_APIDesc_Tagged = &__api.Desc[*EncoreInternal_TaggedReq, EncoreInternal_TaggedResp]{\n\tAccess: __api.Public,\n\tAppHandler: func(ctx context.Context, reqData *EncoreInternal_TaggedReq) (EncoreInternal_TaggedResp, error) {\n\t\terr := Tagged(ctx)\n\t\tif err != nil {\n\t\t\treturn __api.Void{}, err\n\t\t}\n\t\treturn __api.Void{}, nil\n\t},\n\tCloneReq: func(r *EncoreInternal_TaggedReq) (*EncoreInternal_TaggedReq, error) {\n\t\tvar clone *EncoreInternal_TaggedReq\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tCloneResp: func(r EncoreInternal_TaggedResp) (EncoreInternal_TaggedResp, error) {\n\t\tvar clone EncoreInternal_TaggedResp\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tDecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_TaggedResp, err error) {\n\t\treturn __api.Void{}, nil\n\t},\n\tDecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_TaggedReq, pathParams __api.UnnamedParams, err error) {\n\t\treqData = new(EncoreInternal_TaggedReq)\n\t\treturn reqData, nil, nil\n\t},\n\tDefLoc: uint32(0x0),\n\tEncodeExternalReq: func(reqData *EncoreInternal_TaggedReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {\n\t\treturn nil, nil, nil\n\t},\n\tEncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_TaggedResp) (err error) {\n\t\treturn nil\n\t},\n\tEndpoint:            \"Tagged\",\n\tFallback:            false,\n\tGlobalMiddlewareIDs: []string{},\n\tMethods:             []string{\"GET\", \"POST\"},\n\tPath:                \"/code.Tagged\",\n\tPathParamNames:      nil,\n\tRaw:                 false,\n\tRawHandler:          nil,\n\tRawPath:             \"/code.Tagged\",\n\tReqPath: func(reqData *EncoreInternal_TaggedReq) (string, __api.UnnamedParams, error) {\n\t\treturn \"/code.Tagged\", nil, nil\n\t},\n\tReqUserPayload: func(reqData *EncoreInternal_TaggedReq) any {\n\t\treturn nil\n\t},\n\tService:           \"code\",\n\tServiceMiddleware: []*__api.Middleware{},\n\tSvcNum:            1,\n\tTags:              []string{\"bar\", \"foo\"},\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Single File Uploads with Raw Endpoint in Encore.ts\nDESCRIPTION: This raw endpoint handles single file uploads by leveraging the 'busboy' library to parse the multipart form data from the request. The file data is converted to a Buffer and stored in a PostgreSQL database using an SQL INSERT statement. It also handles errors and redirects to the root page upon successful upload.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/how-to/file-uploads.md#2025-04-21_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { api } from \"encore.dev/api\";\nimport log from \"encore.dev/log\";\nimport busboy from \"busboy\";\nimport { SQLDatabase } from \"encore.dev/storage/sqldb\";\n\n// Define a database named 'files', using the database migrations\n// in the \"./migrations\" folder. Encore automatically provisions,\n// migrates, and connects to the database.\nexport const DB = new SQLDatabase(\"files\", {\n  migrations: \"./migrations\",\n});\n\ntype FileEntry = { data: any[]; filename: string };\n\n/**\n * Raw endpoint for storing a single file to the database.\n * Setting bodyLimit to null allows for unlimited file size.\n */\nexport const save = api.raw(\n  { expose: true, method: \"POST\", path: \"/upload\", bodyLimit: null },\n  async (req, res) => {\n    const bb = busboy({\n      headers: req.headers,\n      limits: { files: 1 },\n    });\n    const entry: FileEntry = { filename: \"\", data: [] };\n\n    bb.on(\"file\", (_, file, info) => {\n      entry.filename = info.filename;\n      file\n        .on(\"data\", (data) => {\n          entry.data.push(data);\n        })\n        .on(\"close\", () => {\n          log.info(`File ${entry.filename} uploaded`);\n        })\n        .on(\"error\", (err) => {\n          bb.emit(\"error\", err);\n        });\n    });\n\n    bb.on(\"close\", async () => {\n      try {\n        const buf = Buffer.concat(entry.data);\n        await DB.exec`\n            INSERT INTO files (name, data)\n            VALUES (${entry.filename}, ${buf})\n            ON CONFLICT (name) DO UPDATE\n                SET data = ${buf}\n        `;\n        log.info(`File ${entry.filename} saved`);\n\n        // Redirect to the root page\n        res.writeHead(303, { Connection: \"close\", Location: \"/\" });\n        res.end();\n      } catch (err) {\n        bb.emit(\"error\", err);\n      }\n    });\n\n    bb.on(\"error\", async (err) => {\n      res.writeHead(500, { Connection: \"close\" });\n      res.end(`Error: ${(err as Error).message}`);\n    });\n\n    req.pipe(bb);\n    return;\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Building Docker Images with Encore CLI\nDESCRIPTION: Command to build a portable Docker image for an Encore application. Supports specifying a base image with --base and pushing to a remote repository with --push.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_52\n\nLANGUAGE: bash\nCODE:\n```\nencore build docker\n```\n\n----------------------------------------\n\nTITLE: Testing Slack Notification with cURL\nDESCRIPTION: This snippet provides a cURL command to test sending a Slack notification by calling the 'slack.notify' API endpoint. It uses a JSON payload containing the 'text' key to simulate a Slack message. Successful execution should result in the message appearing in the designated Slack channel.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_27\n\nLANGUAGE: shell\nCODE:\n```\n$ curl 'http://localhost:4000/slack.notify' -d '{\"text\": \"Testing Slack webhook\"}'\n```\n\n----------------------------------------\n\nTITLE: API Method Definition in Encore Service\nDESCRIPTION: Defines a simple API method using Encore's API annotation, accepting a context and returning an error\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/multiple_configs_in_service.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Base URL for GitHub Pages Deployment\nDESCRIPTION: This configuration in the 'vite.config.js' file sets the 'base' property to the repository name for correct routing of the site on GitHub Pages. It is essential to ensure paths resolve correctly when the frontend is deployed.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/meeting-notes.mdx#2025-04-21_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\nbase: \"/my-repo-name/\",\n```\n\n----------------------------------------\n\nTITLE: Deploying Frontend to GitHub Pages with Actions\nDESCRIPTION: This YAML configuration specifies a GitHub Actions workflow to build and deploy a frontend on every push. It checks out the code, sets up Node.js, installs dependencies, builds the project, and uses a deployment action to push the built files to the 'gh-pages' branch. Key dependencies are Node.js, npm, and the 'github-pages-deploy-action' GitHub Action.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/meeting-notes.mdx#2025-04-21_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\nname: Build and Deploy\\n\\non: [push]\\n\\npermissions:\\n  contents: write\\n\\njobs:\\n  build-and-deploy:\\n    concurrency: ci-${{ github.ref }}\\n    runs-on: ubuntu-latest\\n    defaults:\\n      run:\\n        working-directory: frontend\\n\\n    steps:\\n      - name: Checkout \\n        uses: actions/checkout@v3\\n\\n      - name: Use Node.js\\n        uses: actions/setup-node@v3\\n        with:\\n          node-version: \"16.15.1\"\\n\\n      - name: Install and Build \\n        run: |\\n          npm install\\n          npm run build\\n\\n      - name: Deploy \\n        uses: JamesIves/github-pages-deploy-action@v4.3.3\\n        with:\\n          branch: gh-pages\\n          folder: frontend/dist\n```\n\n----------------------------------------\n\nTITLE: Defining and Loading Server Configurations in Go\nDESCRIPTION: Defines server options and configurations using Go structs. Utilizes Encore for dynamically loading and managing configuration values. The `ServerOption` struct describes server settings, while `Config` aggregates these options. Includes an API function `MyAPI` implemented with a context parameter and returning no errors.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/cue_optional_tag.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n)\n\ntype ServerOption struct {\n    Option   int64\n    Disabled bool `cue:\",opt\"` // True if this is disabled\n}\n\ntype Config struct {\n    HTTP    ServerOption\n    Another ServerOption\n    TCP     ServerOption `cue:\",opt\"`\n    GRPC    ServerOption `cue:\",opt\"`\n}\n\nvar _ = config.Load[*Config]()\n\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Public API Endpoint with Tag\nDESCRIPTION: Defines a public API endpoint with a 'foo' tag that can be targeted by middleware.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/middleware_err_not_in_service.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public tag:foo\nfunc API(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Environment Reference Secrets Configuration in JSON\nDESCRIPTION: Alternative configuration for secrets using an environment variable reference to set multiple secret values.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"secrets\": {\n    \"$env\": \"SECRET_JSON\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Slack Webhook Secrets with Encore CLI\nDESCRIPTION: Shell commands to set Slack webhook URLs as secrets in different environments (development, local, production) using the Encore CLI. The URLs should be previously acquired from Slack Incoming Webhooks.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/incident-management-tool.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ encore secret set --type dev,local,pr SlackWebhookURL\n$ encore secret set --type prod SlackWebhookURL\n```\n\n----------------------------------------\n\nTITLE: Defining Duplicate PubSub Topic in Service Package (Go)\nDESCRIPTION: This snippet defines another PubSub topic also named 'same-name' in the svc package. It uses the same configuration as the topic in the shared package, which leads to a naming conflict.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_topic_must_be_unique.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/pubsub\"\n)\n\ntype MessageType struct {\n    Name string\n}\n\nvar AnotherTopic = pubsub.NewTopic[*MessageType](\"same-name\", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })\n```\n\n----------------------------------------\n\nTITLE: Defining an Encore API in Go\nDESCRIPTION: This snippet represents a basic API definition in the Encore framework that returns nil. The function `MyAPI` takes a context parameter and is annotated with the `encore:api` directive, enabling its exposure as an API.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_maps.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Public API Invocation in Go\nDESCRIPTION: This adjusted function within the `svcb` package now calls the `EncoreInternal_apicalls_Foo` method, which represents a refactoring from the direct call to an automatically handled internal service call. This showcases the use of Encore's auto-generated API handling in a service-to-service interaction.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/api_call_servicestruct.txt#2025-04-21_snippet_6\n\nLANGUAGE: Go\nCODE:\n```\npackage svcb\n\nimport (\"context\"; \"example.com/svca\")\n\n//encore:api public\nfunc Baz(ctx context.Context) error { return svca.EncoreInternal_apicalls_Foo(ctx) }\n```\n\n----------------------------------------\n\nTITLE: Discord Icon SVG Component\nDESCRIPTION: SVG markup for Discord logo icon used in the community page navigation\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/community/get-involved.md#2025-04-21_snippet_1\n\nLANGUAGE: svg\nCODE:\n```\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 -28.5 256 256\"><path fill=\"#111111\" d=\"M216.856339,16.5966031 C200.285002,8.84328665 182.566144,3.2084988 164.041564,0 C161.766523,4.11318106 159.108624,9.64549908 157.276099,14.0464379 C137.583995,11.0849896 118.072967,11.0849896 98.7430163,14.0464379 C96.9108417,9.64549908 94.1925838,4.11318106 91.8971895,0 C73.3526068,3.2084988 55.6133949,8.86399117 39.0420583,16.6376612 C5.61752293,67.146514 -3.4433191,116.400813 1.08711069,164.955721 C23.2560196,181.510915 44.7403634,191.567697 65.8621325,198.148576 C71.0772151,190.971126 75.7283628,183.341335 79.7352139,175.300261 C72.104019,172.400575 64.7949724,168.822202 57.8887866,164.667963 C59.7209612,163.310589 61.5131304,161.891452 63.2445898,160.431257 C105.36741,180.133187 151.134928,180.133187 192.754523,160.431257 C194.506336,161.891452 196.298154,163.310589 198.110326,164.667963 C191.183787,168.842556 183.854737,172.420929 176.223542,175.320965 C180.230393,183.341335 184.861538,190.991831 190.096624,198.16893 C211.238746,191.588051 232.743023,181.531619 254.911949,164.955721 C260.227747,108.668201 245.831087,59.8662432 216.856339,16.5966031 Z M85.4738752,135.09489 C72.8290281,135.09489 62.4592217,123.290155 62.4592217,108.914901 C62.4592217,94.5396472 72.607595,82.7145587 85.4738752,82.7145587 C98.3405064,82.7145587 108.709962,94.5189427 108.488529,108.914901 C108.508531,123.290155 98.3405064,135.09489 85.4738752,135.09489 Z M170.525237,135.09489 C157.88039,135.09489 147.510584,123.290155 147.510584,108.914901 C147.510584,94.5396472 157.658606,82.7145587 170.525237,82.7145587 C183.391518,82.7145587 193.761324,94.5189427 193.539891,108.914901 C193.539891,123.290155 183.391518,135.09489 170.525237,135.09489 Z\" /></svg>\n```\n\n----------------------------------------\n\nTITLE: Deploying Encore Application to Encore Cloud\nDESCRIPTION: Git commands to commit changes and push the Encore application to Encore Cloud for deployment. This process triggers automatic building, testing, and deployment of the application.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/quick-start.mdx#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ git add -A .\n$ git commit -m 'Initial commit'\n$ git push encore\n```\n\n----------------------------------------\n\nTITLE: Starting VPN Connection with Encore CLI\nDESCRIPTION: Command to set up a secure VPN connection to private Encore environments.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_49\n\nLANGUAGE: bash\nCODE:\n```\nencore vpn start\n```\n\n----------------------------------------\n\nTITLE: Resetting Encore Databases\nDESCRIPTION: Resets the databases for specified services or all databases if --all flag is used.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\n$ encore db reset [service-names...] [flags]\n```\n\n----------------------------------------\n\nTITLE: Connecting to Database using Encore CLI\nDESCRIPTION: This snippet shows how to connect to a database hosted on Encore Cloud using the encore db shell command. It outlines the default read-only permission mode and flags to modify access levels.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/infrastructure/manage-db-users.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nencore db shell\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Service in Encore (Go)\nDESCRIPTION: The code defines a basic service structure using the Encore framework in Go. It sets up a service struct 'Service' and an API function 'API' that returns nil without any functionality. The dependencies for this structure include the 'context' package and the Encore framework for service annotation. The API function takes a 'context.Context' as a parameter but does not utilize it in its current form, leaving room for future enhancements.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/servicestructgen/testdata/basic.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage basic\\n\\nimport \\\"context\\\"\\n\\n//encore:service\\ntype Service struct {\\n}\\n\\n//encore:api\\nfunc API(context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: GitHub Actions YAML for Docker Deployment\nDESCRIPTION: This YAML file configures a GitHub Actions workflow to build, tag, and push a Docker image to GitHub's container registry. It automates the deployment process whenever a change is pushed to the `main` branch.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/deploy-to-railway.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n\"name: Build, Push and Deploy a Docker Image to Railway\\n\\non:\\n  push:\\n    branches: [ main ]\\n\\npermissions:\\n  contents: read\\n  packages: write\\n\\njobs:\\n  build-push-deploy-image:\\n    runs-on: ubuntu-latest\\n    steps:\\n      - name: Checkout repository\\n        uses: actions/checkout@v4\\n\\n      - name: Log in to the Container registry\\n        uses: docker/login-action@v3.3.0\\n        with:\\n          registry: ghcr.io\\n          username: ${{ github.actor }}\\n          password: ${{ secrets.GITHUB_TOKEN }}\\n\\n      - name: Download Encore CLI script\\n        uses: sozo-design/curl@v1.0.2\\n        with:\\n          args: --output install.sh -L https://encore.dev/install.sh\\n\\n      - name: Install Encore CLI\\n        run: bash install.sh\\n\\n      - name: Build Docker image\\n        run: /home/runner/.encore/bin/encore build --config railway-infra.config.json docker myapp\\n\\n      - name: Tag Docker image\\n        run: docker tag myapp ghcr.io/${{ github.repository }}:latest\\n\\n      - name: Push Docker image\\n        run: docker push ghcr.io/${{ github.repository }}:latest\"\n```\n\n----------------------------------------\n\nTITLE: Generating API Clients with Encore CLI\nDESCRIPTION: Encore CLI can generate API clients in various languages like Go, TypeScript, JavaScript, and OpenAPI specification. This allows developers to easily integrate with services built on Encore, enabling type-safe and convenient access to API endpoints.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/introduction.md#2025-04-21_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n\"Encore generates [API docs](/docs/ts/observability/service-catalog) and [API clients](/docs/ts/cli/client-generation) in Go, TypeScript, JavaScript, and OpenAPI specification.\"\n```\n\n----------------------------------------\n\nTITLE: Main Function Initialization with Encore in Go\nDESCRIPTION: The entry point of the Encore application, initializing the app via `appinit.AppMain`. The file imports the necessary package for application runtime setup. It does not handle any user inputs or return outputs.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/service_struct.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\tappinit \"encore.dev/appruntime/apisdk/app/appinit\"\n\t_ \"example.com\"\n)\n\nfunc main() {\n\tappinit.AppMain()\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Service Types in Go Package\nDESCRIPTION: This snippet demonstrates how to reference and use types defined in another package within an Encore application. Specifically, it shows how the `pkg` package instantiates a pointer to `svc.FooParams`, illustrating inter-package dependencies.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/type_ref_non_svc.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage pkg\n\nimport (\n    \"context\"\n    \"test/svc\"\n)\n\nfunc Test() {\n    _ = &svc.FooParams{}\n}\n```\n\n----------------------------------------\n\nTITLE: Automatically Generated API Interface with Encore in Go\nDESCRIPTION: This snippet defines an automatically generated interface for the code package that includes the Foo method. It abstracts the API's implementation to enable mocking and testing.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/unexported.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// Code generated by encore. DO NOT EDIT.\n\npackage code\n\nimport \"context\"\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\ntype Interface interface {\n    Foo(ctx context.Context) (*Response, error)\n}\n```\n\n----------------------------------------\n\nTITLE: Encore Service Registration in Go\nDESCRIPTION: This snippet handles the registration of a service within the Encore framework. It utilizes Encore's internal service declaration structure `__service.Decl` to register the `Service`, thereby initializing the service for API handling and invocation.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/api_call_servicestruct.txt#2025-04-21_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\npackage svca\n\nimport __service \"encore.dev/appruntime/apisdk/service\"\n\nfunc init() {\n\t__service.Register(EncoreInternal_svcstruct_Service)\n}\n\nvar EncoreInternal_svcstruct_Service = &__service.Decl[Service]{\n\tName:        \"Service\",\n\tService:     \"svca\",\n\tSetup:       nil,\n\tSetupDefLoc: uint32(0x0),\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing React Router with Authentication Routes\nDESCRIPTION: Configures application routes with authentication-related paths including login, callback, and logout, with route protection and error handling\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/auth0-auth.md#2025-04-21_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nconst router = createBrowserRouter([{\n  id: \"root\",\n  path: \"/\",\n  Component: Layout,\n  errorElement: <Layout><ErrorBoundary /></Layout>,\n  children: [...]\n}]);\n```\n\n----------------------------------------\n\nTITLE: PubSub Message Subscriber Handler in Go\nDESCRIPTION: Defines a subscriber function to handle incoming messages from the BasicTopic, currently implementing a no-op error handling.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_subscriber_nil_handler.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc Subscriber(ctx context.Context, msg *MessageType) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Creating SQL Migration File\nDESCRIPTION: This snippet shows an example of a SQL migration file for creating a `site` table. The migration file includes the SQL commands to create the table with columns for `id` (SERIAL PRIMARY KEY) and `url` (TEXT NOT NULL UNIQUE). Encore automatically applies these SQL migration files during application startup.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/orms/knex.md#2025-04-21_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\n-- migrations/1_create_table.up.sql --\nCREATE TABLE site (\n    id SERIAL PRIMARY KEY,\n    url TEXT NOT NULL UNIQUE\n);\n\n```\n\n----------------------------------------\n\nTITLE: Managing Incidents with Encore in Go\nDESCRIPTION: This Go snippet is used to check the current on-call schedule, list unassigned incidents, and assign them to available users based on the on-call schedule. It relies on Encore's service methods like `schedules.ScheduledNow`, `List`, and `Assign`. It requires a context (`ctx`) and handles errors at each step to ensure proper incident management.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/incident-management-tool.md#2025-04-21_snippet_12\n\nLANGUAGE: Go\nCODE:\n```\n\t// if this fails, we don't have anyone on call so let's skip this\n\tschedule, err := schedules.ScheduledNow(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tincidents, err := List(ctx) // we never query for acknowledged incidents\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, incident := range incidents.Items {\n\t\tif incident.Assignee != nil {\n\t\t\tcontinue // this incident has already been assigned\n\t\t}\n\n\t\t_, err := Assign(ctx, incident.Id, &AssignParams{UserId: schedule.User.Id})\n\t\tif err == nil {\n\t\t\trlog.Info(\"OK assigned unassigned incident\", \"incident\", incident, \"user\", schedule.User)\n\t\t} else {\n\t\t\trlog.Error(\"FAIL to assign unassigned incident\", \"incident\", incident, \"user\", schedule.User, \"err\", err)\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n```\n\n----------------------------------------\n\nTITLE: Add Encore.ts to Project\nDESCRIPTION: This snippet shows the command to install Encore.ts as a dependency in an existing project using npm, enabling the usage of the Encore framework.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/migration/express-migration.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm i encore.dev\n```\n\n----------------------------------------\n\nTITLE: Implementing Raw HTTP Endpoint in Go\nDESCRIPTION: Demonstrates how to create a raw HTTP endpoint using Encore's api annotation. The endpoint uses the standard Go HTTP handler interface for direct request handling.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_46\n\nLANGUAGE: go\nCODE:\n```\npackage service\n\nimport \"net/http\"\n\n//encore:api public raw method=POST path=/webhook\nfunc Webhook(w http.ResponseWriter, req *http.Request) {\n    // Handle raw HTTP request\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Logging Function in Go using Encore's rlog\nDESCRIPTION: This snippet defines a Log function in the 'foo' package that uses Encore's rlog package to log an info message. It demonstrates how to use Encore's logging functionality in a Go application.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rlog_call_outside_svc.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage foo\n\nimport \"encore.dev/rlog\"\n\nfunc Log() {\n    rlog.Info(\"test\")\n}\n```\n\n----------------------------------------\n\nTITLE: Type-Safe Service Mocking in Go Tests\nDESCRIPTION: This snippet shows how to use Encore's generated Interface for type-safe service mocking in Go tests. It demonstrates creating a mock object that implements all the APIs defined in the products service.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/mocking.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ntype myMockObject struct{}\n\nfunc (m *myMockObject) GetPrice(ctx context.Context, p *products.PriceParams) (*products.PriceResponse, error) {\n    return &products.PriceResponse{Price: 100}, nil\n}\n\nfunc Test_Something(t *testing.T) {\n    t.Parallel() // Run this test in parallel with other tests without the mock implementation interfering\n    \n    // This will cause a compile time error if myMockObject does not implement all the APIs defined in the products service\n    et.MockService[products.Interface](\"products\", &myMockObject{})\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Encore App from Repository\nDESCRIPTION: The `encore app init` command creates a new Encore app from an existing repository. It takes the app name as an argument.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ encore app init [name]\n```\n\n----------------------------------------\n\nTITLE: Disabling Telemetry via Environment Variable\nDESCRIPTION: This shell command sets an environment variable to disable telemetry in Encore. Setting `DISABLE_ENCORE_TELEMETRY` to 1 prevents telemetry data from being sent.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/telemetry.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nexport DISABLE_ENCORE_TELEMETRY=1\n```\n\n----------------------------------------\n\nTITLE: Defining Key Structure for Cache Keyspace\nDESCRIPTION: Defines a custom key type with ID and Bar fields, which will be used in cache key generation\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cache_err_keyspace_invalid.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype Key struct {\n    ID int\n    Bar string\n}\n```\n\n----------------------------------------\n\nTITLE: Concrete Unmarshalers for Configuration (Go)\nDESCRIPTION: This snippet defines concrete unmarshalers for the configuration, which are automatically generated and maintained by Encore. It provides functions to unmarshal JSON data into the specified Config structure, handling specific fields and types safely.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_with_cue_imports.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t__etype \"encore.dev/appruntime/shared/etype\"\n\t\"fmt\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"time\"\n)\n\n/*\nThese functions are automatically generated and maintained by Encore to allow config values\nto be unmarshalled into the correct types. They are not intended to be used directly. They\nare automatically updated by Encore whenever you change the data types used within your\ncalls to config.Load[T]().\n*/\n\n// Concrete unmarshalers for all config.Load calls, including those using generic types.\n// These instances are used directly by calls to `config.Load[T]()`. \nvar (\n\tencoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {\n\t\treturn func() *Config {\n\t\t\t// If the value is null, we return nil\n\t\t\tif itr.ReadNil() {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Otherwise we unmarshal the value and return a pointer to it\n\t\t\tobj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))\n\t\t\treturn &obj\n\t\t}()\n\t}\n)\n\n// encoreInternalTypeConfigUnmarshaler_svc_Config will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"SomeTime\":\n\t\t\tobj.SomeTime = func() (rtn time.Time) {\n\t\t\t\tdecoder := new(__etype.Unmarshaller)\n\t\t\t\trtn = __etype.UnmarshalOne(decoder, __etype.UnmarshalTime, \"value\", itr.ReadString(), true)\n\t\t\t\tif err := decoder.Error; err != nil {\n\t\t\t\t\tpanic(fmt.Sprintf(\"unable to decode the config: %v\", err))\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}()\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Service with API Methods in Go\nDESCRIPTION: This snippet defines a basic Encore service and several API methods, including ones that deal with request and response data. It utilizes the context and net/http packages for handling HTTP requests. Each method outlines its functionality using the Encore framework annotations for API visibility.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/userfacinggen/testdata/service_struct.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// basic.go --\npackage basic\n\nimport (\"context\"; \"net/http\")\n\n//encore:service\ntype Service struct{}\n\n// Foo is an amazing API which does\n// x, y and z - it's really cool!\n//encore:api public\nfunc (s *Service) Foo(ctx context.Context) error { return nil }\n\n//encore:api public raw\nfunc (s *Service) Raw(w http.ResponseWriter, req *http.Request) {}\n\ntype Data struct{}\n\n//encore:api public\nfunc (s *Service) WithReq(context.Context, *Data) error { return nil }\n\n//encore:api public\nfunc (s *Service) WithResp(context.Context) (*Data, error) { return nil, nil }\n\n//encore:api public\nfunc (s *Service) WithReqResp(context.Context, *Data) (*Data, error) { return nil, nil }\n\n//encore:api public path=/pathing/:name/:age/*other\nfunc (s *Service) WithPathParams(ctx context.Context, name string, age int, other string) error { return nil }\n\n//encore:api public path=/fallback/!url\nfunc (s *Service) WithFallback(ctx context.Context, url string) error { return nil }\n\n// This API doesn't\n// exist on the service struct, but should still\n// appear\n//\n// on the service Interface\n//encore:api public\nfunc NoServiceStruct(context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Reporting Encore Version\nDESCRIPTION: The `encore version` command displays the current version of the Encore CLI.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_26\n\nLANGUAGE: shell\nCODE:\n```\n$ encore version\n```\n\n----------------------------------------\n\nTITLE: Creating Hello World API Endpoint in Go\nDESCRIPTION: Example showing how to create a simple HTTP endpoint that takes a name parameter and returns a greeting message using Encore.go framework.\nSOURCE: https://github.com/encoredev/encore/blob/main/README.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage hello\n\n//encore:api public path=/hello/:name\nfunc World(ctx context.Context, name string) (*Response, error) {\n\tmsg := fmt.Sprintf(\"Hello, %s!\", name)\n\treturn &Response{Message: msg}, nil\n}\n\ntype Response struct {\n\tMessage string\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Objects in Encore Bucket\nDESCRIPTION: This snippet demonstrates how to list objects within an Encore storage bucket using an async iterator. It iterates through each entry in the bucket and allows for processing of each entry.  The list method accepts an optional object of parameters.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nfor await (const entry of profilePictures.list({})) {\n  // Process entry\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Raw Endpoint for Webhook Handling in Go with Encore\nDESCRIPTION: This code snippet demonstrates how to create a raw endpoint in Encore.go to handle incoming webhooks. It shows the use of the '//encore:api public raw' annotation and the function signature that accepts http.ResponseWriter and *http.Request parameters.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/raw-endpoints.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage service\n\nimport \"net/http\"\n\n// Webhook receives incoming webhooks from Some Service That Sends Webhooks.\n//encore:api public raw\nfunc Webhook(w http.ResponseWriter, req *http.Request) {\n    // ... operate on the raw HTTP request ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Dummy Public API in Go\nDESCRIPTION: This snippet defines a dummy public API endpoint `Dummy` for the `moo` service using the `//encore:api public` annotation. The `Dummy` function simply returns `nil`, indicating a successful operation without performing any specific logic. This showcases a basic API definition within an Encore service.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/svc_migration_db.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\n//encore:api public\nfunc Dummy(context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Triggering Railway Deployment with JavaScript\nDESCRIPTION: This JavaScript script utilizes the Railway GraphQL API to trigger a new deployment of a service instance. It uses environment and service IDs, along with a Railway API token for authentication.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/deploy-to-railway.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n\"const TOKEN = process.argv.slice(2)[0];\\nconst ENVIRONMENT_ID = \\\"<your environment id>\\\"\\nconst SERVICE_ID = \\\"<your service id>\\\"\\n\\nconst resp = await fetch('https://backboard.railway.com/graphql/v2', {\\n  method: 'POST',\\n  headers: {\\n    'Content-Type': 'application/json',\\n    'authorization': `Bearer ${TOKEN}`,\\n  },\\n  body: JSON.stringify({\\n    query: `\\n      mutation ServiceInstanceRedeploy {\\n          serviceInstanceRedeploy(\\n              environmentId: \\\"${ENVIRONMENT_ID}\\\"\\n              serviceId: \\\"${SERVICE_ID}\\\"\\n          )\\n      }`\\n  }),\\n})\\n\\nconst data = await resp.json()\\n\\nif (data.errors) {\\n  console.error(data.errors)\\n  throw new Error('Failed to redeploy service')\\n}\\n\\nconsole.log(data)\" \n```\n\n----------------------------------------\n\nTITLE: Generating Encore Client in Bash\nDESCRIPTION: This Bash command generates a client for Encore applications, outputting a TypeScript file compatible with React and TanStack Query. It requires installing Encore CLI and configuring package.json scripts for frequent use.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\n$ encore gen client <APP_NAME> --output=./src/client.ts --env=<ENV_NAME>\n```\n\n----------------------------------------\n\nTITLE: Defining PubSub Topic and Invalid Subscription (Go)\nDESCRIPTION: This snippet defines a PubSub topic and attempts to create a subscription with a handler (`shared.Subscriber`) defined in a different package/service. This is an invalid configuration in Encore, as the handler must reside within the same service as the subscription definition.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_subscriber_not_function.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"test/shared\"\n\n    \"encore.dev/pubsub\"\n)\n\ntype MessageType struct {\n    Name string\n}\n\nvar (\n    BasicTopic = pubsub.NewTopic[*MessageType](\"basic-topic\", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })\n    _ = pubsub.NewSubscription(BasicTopic, \"basic-subscription\", pubsub.SusbcriptionConfig { Handler: shared.Subscriber })\n)\n\n// encore:api\nfunc DoStuff(ctx context.Context) error {\n    return BasicTopic.Publish(ctx, &MessageType{Name: \"foo\"})\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Top-Level Service Configuration\nDESCRIPTION: Configuration struct that includes HTTP server options for Encore service deployment\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_named_struct_single_use.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype Config struct {\n    HTTP ServerOptions // The options for the HTTP server\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Encore API Endpoint\nDESCRIPTION: Defines a simple API endpoint `MyAPI` using the `//encore:api` annotation. This annotation tells Encore to expose this function as an API endpoint. The function takes a `context.Context` as input and returns an error.  In this case, the function simply returns `nil`, indicating success.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_lists.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Public API Endpoint in Go for Encore\nDESCRIPTION: This snippet defines a public API endpoint 'Foo' using Encore's API annotation. The function takes a context and returns an error, but its implementation is empty. Note that the import of 'encore.dev/et' is incorrect and should be removed.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/et_err_outside_of_test.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/et\"\n)\n\n//encore:api public\nfunc Foo(context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Outputting Database Connection URI\nDESCRIPTION: The `encore db conn-uri` command prints the connection string for a specified database. Defaults to the local environment and can connect to another specified environment via the `--env` flag.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\n$ encore db conn-uri <database-name> [--env=<name>] [flags]\n```\n\n----------------------------------------\n\nTITLE: Using Txtar to Create and Materialize Archives\nDESCRIPTION: Example demonstrating how to create a txtar archive from a string containing multiple files and comments, then materialize it to a directory on disk. Shows the format's structure including comments, file markers, and content.\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/txtar/README.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet txt = \"\\\ncomment1\ncomment2\n-- file1 --\nFile 1 text.\n-- foo/bar --\nFile 2 text.\n-- empty --\n-- noNL --\nhello world\";\n\nlet archive = txtar::from_str(txt);\narchive.materialize(\"/tmp/somedir/\").unwrap();\n```\n\n----------------------------------------\n\nTITLE: Implementing Ping Service Tests\nDESCRIPTION: Unit tests for the ping service using Vitest, covering various scenarios including valid and invalid URLs.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { describe, expect, test } from \"vitest\";\nimport { ping } from \"./ping\";\n\ndescribe(\"ping\", () => {\n  test.each([\n    // Test both with and without \"https://\"\n    { site: \"google.com\", expected: true },\n    { site: \"https://encore.dev\", expected: true },\n\n    // 4xx and 5xx should considered down.\n    { site: \"https://not-a-real-site.xyz\", expected: false },\n    // Invalid URLs should be considered down.\n    { site: \"invalid://scheme\", expected: false },\n  ])(\n    `should verify that $site is ${\"$expected\" ? \"up\" : \"down\"}`,\n    async ({ site, expected }) => {\n      const resp = await ping({ url: site });\n      expect(resp.up).toBe(expected);\n    },\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Invalid Cron Job Declaration in Encore\nDESCRIPTION: Example of incorrectly implementing a cron job within a function context instead of package level. Shows the incorrect usage of cron.NewJob and API reference in an Encore application.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cron_job_definition_rpc.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/cron\"\n)\n\n//encore:api public path=/cron\nfunc Cron(ctx context.Context) (*Response, error) {\n\tmsg := \"Hello, Cron!\"\n    // A cron job to send out emails to newsletter subscribers.\n    // On two lines.\n    var _ = cron.NewJob(\"cronfoo\", cron.JobConfig{\n        Title:    \"Cron Foo Bar\",\n        Schedule: \"* * * * 5\",\n        Endpoint: Cron,\n    })\n\treturn &Response{Message: msg}, nil\n}\n\ntype Response struct {\n\tMessage string\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Public API with Encore in Go\nDESCRIPTION: This snippet defines a public API function `One` using the Encore framework. The function takes a context parameter and currently returns nil. It is designed to be an entry point for external API calls into the service. No additional dependencies are required, but it must be defined within a service context for proper usage.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_outside_service.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage one\n\nimport (\n    \"context\"\n)\n\n//encore:api public\nfunc One(ctx context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GetNote Endpoint in Go\nDESCRIPTION: Go function implementing the GetNote endpoint, which retrieves a meeting note from the database by its ID.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/meeting-notes.mdx#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public method=GET path=/note/:id\nfunc GetNote(ctx context.Context, id string) (*Note, error) {\n\tnote := &Note{ID: id}\n\n\t// We use the note ID to query the database for the note's text and cover URL.\n\terr := sqldb.QueryRow(ctx, `\n\t\tSELECT text, cover_url FROM note\n\t\tWHERE id = $1\n\t`, id).Scan(&note.Text, &note.CoverURL)\n\n\t// If the note doesn't exist, we return an error.\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Otherwise, we return the note.\n\treturn note, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Generated API Interface with Encore in Go\nDESCRIPTION: This auto-generated snippet by Encore defines an interface representing the service's API surface. The interface, intended for mocking purposes, includes the 'Foo' method, ensuring any updates to API endpoints are reflected.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/fallback_path.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage code\n\nimport \"context\"\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\n\ntype Interface interface {\n\tFoo(ctx context.Context, fallback string) error\n}\n```\n\n----------------------------------------\n\nTITLE: Static Configuration Representation\nDESCRIPTION: Synthetic static configuration file representing application-level settings, including service mapping, testing configurations, and environment details\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/basic.txt#2025-04-21_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n\t\"EncoreCompiler\": \"\",\n\t\"AppCommit\": {\n\t\t\"revision\": \"\",\n\t\t\"uncommitted\": false\n\t},\n\t\"BundledServices\": [\"code\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining API Parameter Structures in Go\nDESCRIPTION: This snippet defines the data structures used for API parameters in an Encore application, specifically a parameter struct containing a UUID and a nested structure. The nested structure is intended to hold a string value, but its usage as a query parameter in GET requests is restricted, as outlined in the error documentation.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_invalid_query_type.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\t\"encore.dev/types/uuid\"\n)\n\ntype Nested struct {\n    Baz string\n}\n\ntype Params struct {\n    Foo uuid.UUID\n    Bar *Nested\n}\n\n//encore:api public method=GET\nfunc Str(ctx context.Context, p *Params) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Re-enabling Telemetry via CLI\nDESCRIPTION: This shell command re-enables telemetry collection in Encore. Executing this command resumes the transmission of telemetry data to help improve the product.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/telemetry.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nencore telemetry enable\n```\n\n----------------------------------------\n\nTITLE: Creating an Encore App - Go\nDESCRIPTION: This snippet shows how to create a new Encore app using the Encore CLI. The command initializes an app with a specified template, in this case, 'Hello World'.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/deploy-to-digital-ocean-wip.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nencore app create myapp\n```\n\n----------------------------------------\n\nTITLE: Nullable Fields in Request Schema\nDESCRIPTION: This snippet defines a schema with nullable fields, allowing a field to hold either a value or null using Encore.ts.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Request {\n  name: string | null;\n}\n\nexport const myEndpoint = api(\n  { expose: true, method: \"POST\", path: \"/body\" },\n  async (req: Request) => {\n    // req.name is a string or null\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: StreamInOut API signature variations\nDESCRIPTION: These code snippets show different type signatures for the `api.streamInOut` function, demonstrating how to define the handshake, incoming, and outgoing message types, and how the handshake can be optional.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/streaming-apis.mdx#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\napi.streamInOut<Handshake, Incoming, Outgoing>(\n  {...}, async (handshake, stream) => {...})\n```\n\nLANGUAGE: typescript\nCODE:\n```\napi.streamInOut<Incoming, Outgoing>(\n  {...}, async (stream) => {...})\n```\n\n----------------------------------------\n\nTITLE: Running Local Dev Environment with Encore CLI\nDESCRIPTION: This snippet demonstrates how to start a local development environment using the Encore CLI. The command `encore run` takes care of setting up local versions of all infrastructure and provides a local development dashboard with built-in observability tools.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/other/vs-heroku.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n\"`encore run`\"\n```\n\n----------------------------------------\n\nTITLE: Building and Deploying Encore Docker Image with GitHub Actions\nDESCRIPTION: This YAML configuration demonstrates how to use GitHub Actions to build an Encore Docker image, push it to DigitalOcean's container registry, and trigger a deployment. It includes steps for installing the Encore CLI, building the Docker image, and pushing it to the registry.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/ci-cd.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nname: Build, Push and Deploy a Encore Docker Image to DigitalOcean\n\non:\n  push:\n    branches: [ main ]\n\npermissions:\n  contents: read\n  packages: write\n\njobs:\n  build-push-deploy-image:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n\n      - name: Download Encore CLI script\n        uses: sozo-design/curl@v1.0.2\n        with:\n          args: --output install.sh -L https://encore.dev/install.sh\n\n      - name: Install Encore CLI\n        run: bash install.sh\n\n      - name: Log in to DigitalOcean container registry\n        run: docker login registry.digitalocean.com -u my-email@gmail.com -p ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}\n\n      - name: Build Docker image\n        run: /home/runner/.encore/bin/encore build docker myapp\n\n      - name: Tag Docker image\n        run: docker tag myapp registry.digitalocean.com/<YOUR_CONTAINER_REGISTRY_NAME>/<YOUR_IMAGE_REPOSITORY_NAME>:latest\n\n      - name: Push Docker image\n        run: docker push registry.digitalocean.com/<YOUR_CONTAINER_REGISTRY_NAME>/<YOUR_IMAGE_REPOSITORY_NAME>:latest\n```\n\n----------------------------------------\n\nTITLE: Installing Clerk SDK for Go\nDESCRIPTION: Command to install the Clerk SDK Go package as a dependency\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/clerk-auth.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ go get github.com/clerkinc/clerk-sdk-go/clerk\n```\n\n----------------------------------------\n\nTITLE: Defining API Endpoint in TypeScript with Encore\nDESCRIPTION: This snippet defines an API endpoint named 'ping' using Encore's API framework. It imports the necessary modules and exports a function with no input or output.\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/tests/testdata/tsconfig.txt#2025-04-21_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\nimport { blah } from \"@bar/bar\";\n\nexport const ping = api<void, void>({}, () => {});\n```\n\n----------------------------------------\n\nTITLE: Connecting to PostgreSQL Database\nDESCRIPTION: This snippet demonstrates connecting to a PostgreSQL database using the `psql` command. It requires the password, hostname, user, port, and database name.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/deploy-to-railway.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n\"PGPASSWORD=<password> psql -h <hostname>.rlwy.net -U postgres -p 39684 -d railway\"\n```\n\n----------------------------------------\n\nTITLE: Encore Internal API Endpoint Registration\nDESCRIPTION: This code registers the `Foo` and `Bar` endpoints with the Encore runtime. It defines request and response types, and includes functions for cloning requests/responses, encoding/decoding, and handling raw requests.  It also defines metadata such as access level, HTTP methods, and path.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/raw_endpoint.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport (\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\terrs \"encore.dev/beta/errs\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Bar, Bar)\n}\n\ntype EncoreInternal_FooReq struct{}\n\ntype EncoreInternal_FooResp = __api.Void\n\nvar EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{\n\tAccess:     __api.Public,\n\tAppHandler: nil,\n\tCloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {\n\t\tvar clone *EncoreInternal_FooReq\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tCloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {\n\t\tvar clone EncoreInternal_FooResp\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tDecodeExternalResp: nil,\n\tDecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {\n\t\treqData = new(EncoreInternal_FooReq)\n\t\treturn reqData, nil, nil\n\t},\n\tDefLoc: uint32(0x0),\n\tEncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {\n\t\treturn nil, nil, nil\n\t},\n\tEncodeResp:          nil,\n\tEndpoint:            \"Foo\",\n\tFallback:            false,\n\tGlobalMiddlewareIDs: []string{},\n\tMethods:             []string{\"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\", \"CONNECT\", \"OPTIONS\", \"TRACE\", \"PATCH\"},\n\tPath:                \"/code.Foo\",\n\tPathParamNames:      nil,\n\tRaw:                 true,\n\tRawHandler: func(w http.ResponseWriter, req *http.Request) {\n\t\tFoo(w, req)\n\t},\n\tRawPath: \"/code.Foo\",\n\tReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {\n\t\treturn \"/code.Foo\", nil, nil\n\t},\n\tReqUserPayload: func(reqData *EncoreInternal_FooReq) any {\n\t\treturn nil\n\t},\n\tService:           \"code\",\n\tServiceMiddleware: []*__api.Middleware{},\n\tSvcNum:            1,\n\tTags:              nil,\n}\n\ntype EncoreInternal_BarReq struct{}\n\ntype EncoreInternal_BarResp = __api.Void\n\nvar EncoreInternal_api_APIDesc_Bar = &__api.Desc[*EncoreInternal_BarReq, EncoreInternal_BarResp]{\n\tAccess:     __api.Public,\n\tAppHandler: nil,\n\tCloneReq: func(r *EncoreInternal_BarReq) (*EncoreInternal_BarReq, error) {\n\t\tvar clone *EncoreInternal_BarReq\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tCloneResp: func(r EncoreInternal_BarResp) (EncoreInternal_BarResp, error) {\n\t\tvar clone EncoreInternal_BarResp\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tDecodeExternalResp: nil,\n\tDecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_BarReq, pathParams __api.UnnamedParams, err error) {\n\t\treqData = new(EncoreInternal_BarReq)\n\t\treturn reqData, nil, nil\n\t},\n\tDefLoc: uint32(0x0),\n\tEncodeExternalReq: func(reqData *EncoreInternal_BarReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {\n\t\treturn nil, nil, nil\n\t},\n\tEncodeResp:          nil,\n\tEndpoint:            \"Bar\",\n\tFallback:            false,\n\tGlobalMiddlewareIDs: []string{},\n\tMethods:             []string{\"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\", \"CONNECT\", \"OPTIONS\", \"TRACE\", \"PATCH\"},\n\tPath:                \"/code.Bar\",\n\tPathParamNames:      nil,\n\tRaw:                 true,\n\tRawHandler: func(w http.ResponseWriter, req *http.Request) {\n\t\tsvc, initErr := EncoreInternal_svcstruct_Service.Get()\n\t\tif initErr != nil {\n\t\t\terrs.HTTPErrorWithCode(w, initErr, 0)\n\t\t\treturn\n\t\t}\n\t\tsvc.Bar(w, req)\n\t},\n\tRawPath: \"/code.Bar\",\n\tReqPath: func(reqData *EncoreInternal_BarReq) (string, __api.UnnamedParams, error) {\n\t\treturn \"/code.Bar\", nil, nil\n\t},\n\tReqUserPayload: func(reqData *EncoreInternal_BarReq) any {\n\t\treturn nil\n\t},\n\tService:           \"code\",\n\tServiceMiddleware: []*__api.Middleware{},\n\tSvcNum:            1,\n\tTags:              nil,\n}\n```\n\n----------------------------------------\n\nTITLE: Generating API Interface in Go\nDESCRIPTION: This snippet defines an interface for the API service in Go, facilitating mocking and service interaction. It provides an entry point for function calls in generated code. The 'Interface' includes the definition of the 'Foo' method, which matches the defined API function signature.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/complex_omitempty.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage basic\n\nimport \"context\"\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\ntype Interface interface {\n    Foo(ctx context.Context, p *Params) error\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Connect Service with gRPC and cURL\nDESCRIPTION: Shell commands to test the implemented Connect service using gRPC and cURL.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/grpc-connect.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n# Install grpcurl if you haven't already\n$ go install github.com/fullstorydev/grpcurl/cmd/grpcurl@latest\n\n# Call the service with grpcurl\ngrpcurl \\\n    -protoset <(buf build -o -) -plaintext \\\n    -d '{\"name\": \"Jane\"}' \\\n    localhost:4000 greet.v1.GreetService/Greet\n\n# Or call the service with curl\n$ curl -H \"Content-Type: application/json\" -d '{\"name\": \"Jane\"}' http://localhost:4000/greet.v1.GreetService/Greet\n```\n\n----------------------------------------\n\nTITLE: Deploying Encore Application to Cloud\nDESCRIPTION: Git-based deployment workflow for pushing application to Encore Cloud\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/quick-start.mdx#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ngit add -A .\ngit commit -m 'Initial commit'\ngit push encore\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration with Encore in Go\nDESCRIPTION: This snippet demonstrates how to load a configuration using the Encore framework for the Config structure, linking it to the custom unmarshaler.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/json_tags.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nvar _ = config.Load[*Config](\"svc\", encoreInternalConfigUnmarshaler_ptr_svc_Config/*line :21:30*/)\n```\n\n----------------------------------------\n\nTITLE: Internal Configuration Unmarshaling for AsConfig in Go with Encore\nDESCRIPTION: This snippet provides the unmarshaling logic for AsConfig, allowing JSON representations of configuration to be converted back into Go struct representations. The code defines a function for the unmarshal process which handles specific fields and creates the appropriate instances based on the loaded data.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/merge_identical_comments.txt#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\tconfig \"encore.dev/config\"\n\tjsoniter \"github.com/json-iterator/go\"\n)\n\n// Concrete unmarshalers for all config.Load calls, including those using generic types.\nvar (\n\tencoreInternalConfigUnmarshaler_ptr_svc_AsConfig = func(itr *jsoniter.Iterator, path []string) *AsConfig {\n\t\treturn func() *AsConfig {\n\t\t\t// If the value is null, we return nil\n\t\t\tif itr.ReadNil() {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Otherwise we unmarshal the value and return a pointer to it\n\t\t\tobj := encoreInternalTypeConfigUnmarshaler_svc_AsConfig(itr, append(path))\n\t\t\treturn &obj\n\t\t\t\n\t\t}()\n\t}\n\tencoreInternalConfigUnmarshaler_svc_BsConfig = encoreInternalTypeConfigUnmarshaler_svc_BsConfig\n\tencoreInternalConfigUnmarshaler_svc_CsConfig = encoreInternalTypeConfigUnmarshaler_svc_CsConfig\n\tencoreInternalConfigUnmarshaler_svc_DsConfig = encoreInternalTypeConfigUnmarshaler_svc_DsConfig\n)\n\n// encoreInternalTypeConfigUnmarshaler_svc_AsConfig will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_svc_AsConfig(itr *jsoniter.Iterator, path []string) (obj AsConfig) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"Foo\":\n\t\t\tobj.Foo = config.CreateValue[string](itr.ReadString(), append(path, \"Foo\"))\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Migration Generation Script in Shell\nDESCRIPTION: Commands to make the migration script executable and generate the initial migration.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/entgo-orm.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ chmod +x user/scripts/generate-migration\n$ cd user && ./scripts/generate-migration init\n```\n\n----------------------------------------\n\nTITLE: Automatic JSON Configuration Unmarshaler\nDESCRIPTION: Generates a custom JSON unmarshaler for the Config struct with field-level parsing and handling\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/cue_tags.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"A\":\n\t\t\tobj.A = itr.ReadInt()\n\t\tcase \"B\":\n\t\t\tobj.B = itr.ReadInt()\n\t\tcase \"C\":\n\t\t\tobj.C = itr.ReadInt()\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Struct with JSON Ignore Tags\nDESCRIPTION: Defines a SomeStruct with fields marked to be ignored during JSON serialization using struct tags\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/struct_duplicate_json_ignore.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype SomeStruct struct {\n    A string `json:\"-\"`\n    B string `json:\"-\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Endpoint with Dynamic Path Parameters in Encore.ts\nDESCRIPTION: This TypeScript snippet shows how to define an API endpoint using Encore.ts with dynamic path parameters. It includes a method to expose and a path to be used in the URL with a request schema that parses the ID as a string.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\n\ninterface Request {\n  // Required path parameter. Parsed from the request URL.\n  id: string;\n}\n\nexport const myEndpoint = api(\n  { expose: true, method: \"POST\", path: \"/user/:id\" },\n  async ({ id }: Request) => {\n    // ...\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: PubSub Topic and Subscription Implementation in Go\nDESCRIPTION: Implementation of a PubSub topic and subscription using Encore.dev framework. Contains an error due to missing DeliveryGuarantee configuration in TopicConfig. Includes message type definition, topic creation, subscription setup, and handler functions.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_missing_delivery_guarantee.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/pubsub\"\n)\n\ntype MessageType struct {\n    Name string\n}\n\nvar (\n    BasicTopic = pubsub.NewTopic[*MessageType](\"basic-topic\", pubsub.TopicConfig{})\n    _ = pubsub.NewSubscription(BasicTopic, \"basic-subscription\", pubsub.SusbcriptionConfig { Handler: Subscriber })\n)\n\n// encore:api\nfunc DoStuff(ctx context.Context) error {\n    return BasicTopic.Publish(ctx, &MessageType{Name: \"foo\"})\n}\n\nfunc Subscriber(ctx context.Context, msg *MessageType) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Worker Pooling in Encore.ts\nDESCRIPTION: This snippet demonstrates how to enable Worker Pooling in an Encore.ts application by adding a configuration setting to the `encore.app` file. Worker Pooling allows Encore.ts to start multiple NodeJS event loops and load-balance incoming requests, improving performance for CPU-intensive tasks.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/multithreading.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n\"build\": {\n  \"worker_pooling\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring buf for Code Generation\nDESCRIPTION: YAML configuration for buf to generate Go code from Protobuf definitions.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/grpc-connect.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nversion: v2\nplugins:\n  - local: protoc-gen-go\n    out: gen\n    opt: paths=source_relative\n  - local: protoc-gen-connect-go\n    out: gen\n    opt: paths=source_relative\n```\n\n----------------------------------------\n\nTITLE: Encore API Endpoint Registration in Go\nDESCRIPTION: This snippet initializes and registers the service's API endpoints using Encore's internal API description structures. It handles request and response cloning, encoding, decoding, and defines the API's methods and paths for the `Foo` endpoint.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/api_call_servicestruct.txt#2025-04-21_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\npackage svca\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n}\n\ntype EncoreInternal_FooReq struct{}\n\ntype EncoreInternal_FooResp = __api.Void\n\nvar EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{\n\tAccess: __api.Public,\n\tAppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {\n\t\tsvc, initErr := EncoreInternal_svcstruct_Service.Get()\n\t\tif initErr != nil {\n\t\t\treturn __api.Void{}, initErr\n\t\t}\n\t\terr := svc.Foo(ctx)\n\t\tif err != nil {\n\t\t\treturn __api.Void{}, err\n\t\t}\n\t\treturn __api.Void{}, nil\n\t},\n\tCloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {\n\t\tvar clone *EncoreInternal_FooReq\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tCloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {\n\t\tvar clone EncoreInternal_FooResp\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tDecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {\n\t\treturn __api.Void{}, nil\n\t},\n\tDecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {\n\t\treqData = new(EncoreInternal_FooReq)\n\t\treturn reqData, nil, nil\n\t},\n\tDefLoc: uint32(0x0),\n\tEncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {\n\t\treturn nil, nil, nil\n\t},\n\tEncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {\n\t\treturn nil\n\t},\n\tEndpoint:            \"Foo\",\n\tFallback:            false,\n\tGlobalMiddlewareIDs: []string{},\n\tMethods:             []string{\"GET\", \"POST\"},\n\tPath:                \"/svca.Foo\",\n\tPathParamNames:      nil,\n\tRaw:                 false,\n\tRawHandler:          nil,\n\tRawPath:             \"/svca.Foo\",\n\tReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {\n\t\treturn \"/svca.Foo\", nil, nil\n\t},\n\tReqUserPayload: func(reqData *EncoreInternal_FooReq) any {\n\t\treturn nil\n\t},\n\tService:           \"svca\",\n\tServiceMiddleware: []*__api.Middleware{},\n\tSvcNum:            1,\n\tTags:              nil,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Recursive and Generic Types in Go\nDESCRIPTION: This snippet defines various recursive and generic types including SelfRecursive, MutuallyRecursive, Other, and Generic. These types demonstrate self-recursion, mutual recursion, and generic type usage.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/recursive_types.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\ntype SelfRecursive struct {\n    A *SelfRecursive\n}\n\ntype MutuallyRecursive struct {\n    Other *Other\n}\n\ntype Other struct {\n    Original *MutuallyRecursive\n}\n\ntype Generic[T any] struct {\n    Val *T\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Authentication Info Override in Go\nDESCRIPTION: Test suite for verifying authentication data override functionality, including reset between tests and propagation to API calls\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/et_override_user_authdata.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc TestOverrideAuthInfo(t *testing.T) {\n    curr, _ := auth.Data().(*AuthData)\n    if curr != nil {\n        t.Fatalf(\"got data %+v, want nil\", curr)\n    }\n\n    et.OverrideAuthInfo(\"foo\", &AuthData{\"email\"})\n\n    curr = auth.Data().(*AuthData)\n    if curr == nil || curr.Email != \"email\" {\n        t.Fatalf(\"got data %+v, want %q\", curr, &AuthData{\"email\"})\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Internal Unmarshaller for ThisConfig - Go\nDESCRIPTION: This snippet features an internal unmarshaller for the ThisConfig type, adept at converting JSON values into the structure using jsoniter, thus supporting dynamic configurations.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/multiple_configs_in_service.txt#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"encore.dev/config\"\n\t\"github.com/json-iterator/go\"\n)\n\n// encoreInternalTypeConfigUnmarshaler_svc_ThisConfig will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_svc_ThisConfig(itr *jsoniter.Iterator, path []string) (obj ThisConfig) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"Foo\":\n\t\t\tobj.Foo = config.CreateValue[string](itr.ReadString(), append(path, \"Foo\"))\n\t\tcase \"Baz\":\n\t\t\tobj.Baz = config.CreateValue[bool](itr.ReadBool(), append(path, \"Baz\"))\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Infrastructure Namespace using Encore CLI\nDESCRIPTION: This command creates a new infrastructure namespace named 'my-ns'. This allows for isolated development environments that do not interfere with each other.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/infra-namespaces.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ encore namespace create my-ns\n```\n\n----------------------------------------\n\nTITLE: Static File Serving Implementation - Express.js vs Encore.ts\nDESCRIPTION: Demonstrates how to serve static files in both frameworks. Express.js uses built-in middleware while Encore.ts uses api.static method with direct file serving from Rust Runtime.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/migration/express-migration.md#2025-04-21_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport express from \"express\";\n\nconst app: Express = express();\n\napp.use(\"/assets\", express.static(\"assets\"));\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\n\nexport const assets = api.static(\n  { expose: true, path: \"/assets/*path\", dir: \"./assets\" },\n);\n```\n\n----------------------------------------\n\nTITLE: Define Configuration Struct with Generics\nDESCRIPTION: Defines a configuration structure `CfgType` that uses generics. It includes various configuration fields such as boolean, bytes, string values, nested structures, and maps, all utilizing Encore's configuration types like `config.Bool`, `config.Bytes`, and `config.Values`. This structure serves as a blueprint for loading configuration values using Encore's configuration system.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/generics.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage generics\n\nimport (\n    \"context\"\n    \"encore.dev/config\"\n)\n\ntype CfgType[T any] struct {\n\tReadOnlyMode config.Bool\n\tPublicKey    config.Bytes\n\tAdminUsers   config.Values[string]\n\n\tSubConfig config.Value[struct {\n\t\tSubKey *SubCfgType[T]\n\t}]\n\n\tCurrencies map[string]struct {\n\t\tName    config.String\n\t\tCode    config.String\n\t\tAliases config.Values[string]\n\t}\n\n\tAnotherList config.Values[struct {\n\t\tName config.String\n\t}]\n}\n\ntype SubCfgType[T any] struct {\n\tMaxCount T\n}\n\nvar cfg = config.Load[*CfgType[uint]]()\n\ntype ConfigResponse struct {\n\tReadOnlyMode bool\n\tPublicKey    []byte\n\tSubKeyCount  uint\n\tAdminUsers   []string\n}\n\n// There must be an API endopint to use config.Load.\n//encore:api public\nfunc Dummy(context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Initializing Site Service Definition\nDESCRIPTION: TypeScript code defining the basic site service using Encore\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Service } from \"encore.dev/service\";\n\nexport default new Service(\"site\");\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration for Service (Go)\nDESCRIPTION: This snippet loads a configuration structure for the service, utilizing the Encore framework's configuration loading capabilities. It defines a type for configurations containing a time value and invokes the loading function with a custom unmarshaler.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_with_cue_imports.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n    \"time\"\n\n\t\"encore.dev/config\"\n)\n\ntype Config struct {\n    SomeTime time.Time\n}\n\nvar _ = config.Load[*Config](\"svc\", encoreInternalConfigUnmarshaler_ptr_svc_Config/*line :14:30*/)\n\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Service-Level Tagged Middleware Implementation\nDESCRIPTION: Implements middleware that targets endpoints tagged with 'foo' within a service scope.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/middleware_err_not_in_service.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:middleware target=tag:foo\nfunc TaggedInSvc(req middleware.Request, next middleware.Next) middleware.Response {\n    return next(req)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Bucket References in TypeScript\nDESCRIPTION: This snippet explains how to create bucket references with specific permissions in Encore's storage system. By using `bucket.ref<DesiredPermissions>()`, users can define and pass these references, which include controlled access methods based on pre-declared permissions. It ensures a secure operation of storage activities while allowing flexibility in passing bucket references.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/object-storage.md#2025-04-21_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Uploader } from \"encore.dev/storage/objects\";\nconst ref = profilePictures.ref<Uploader>();\n\n// You can now freely pass around `ref`, and you can use\n// `ref.upload()` just like you would `profilePictures.upload()`.\n```\n\n----------------------------------------\n\nTITLE: Initial Monolithic Service Implementation in Go\nDESCRIPTION: Example of a monolithic service 'hello' containing two API endpoints H1 and H2 that handle different greeting formats. Shows the initial structure before breaking into microservices.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/break-up-monolith.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage hello\n\nimport (\n\t\"context\"\n)\n\n//encore:api public path=/hello/:name\nfunc H1(ctx context.Context, name string) (*Response, error) {\n\tmsg := \"Hello, \" + name + \"!\"\n\treturn &Response{Message: msg}, nil\n}\n\n//encore:api public path=/yo/:name\nfunc H2(ctx context.Context, name string) (*Response, error) {\n\tmsg := \"Yo, \" + name + \"!\"\n\treturn &Response{Message: msg}, nil\n}\n\ntype Response struct {\n\tMessage string\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Slack Request Verification in Go\nDESCRIPTION: Go function to verify that incoming requests are from Slack. It checks the timestamp and computes an HMAC to validate the request signature.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/slack-bot.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// verifyRequest verifies that a request is coming from Slack.\nfunc verifyRequest(req *http.Request) (body []byte, err error) {\n\teb := errs.B().Code(errs.InvalidArgument)\n\tbody, err = ioutil.ReadAll(req.Body)\n\tif err != nil {\n\t\treturn nil, eb.Cause(err).Err()\n\t}\n\n\t// Compare timestamps to prevent replay attack\n\tts := req.Header.Get(\"X-Slack-Request-Timestamp\")\n\tthreshold := int64(5 * 60)\n\tn, _ := strconv.ParseInt(ts, 10, 64)\n\tif diff := time.Now().Unix() - n; diff > threshold || diff < -threshold {\n\t\treturn body, eb.Msg(\"message not recent\").Err()\n\t}\n\n\t// Compare HMAC signature\n\tsig := req.Header.Get(\"X-Slack-Signature\")\n\tprefix := \"v0=\"\n\tif !strings.HasPrefix(sig, prefix) {\n\t\treturn body, eb.Msg(\"invalid signature\").Err()\n\t}\n\tgotMac, _ := hex.DecodeString(sig[len(prefix):])\n\n\tmac := hmac.New(sha256.New, []byte(secrets.SlackSigningSecret))\n\tfmt.Fprintf(mac, \"v0:%s:\", ts)\n\tmac.Write(body)\n\texpectedMac := mac.Sum(nil)\n\tif !hmac.Equal(gotMac, expectedMac) {\n\t\treturn body, eb.Msg(\"bad mac\").Err()\n\t}\n\treturn body, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Type-Safe Service Mocking with Interfaces in Encore\nDESCRIPTION: Demonstrates type-safe mocking of services using generated interfaces. This approach ensures compile-time verification that the mock properly implements all required methods.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_36\n\nLANGUAGE: go\nCODE:\n```\ntype myMockObject struct{}\n\nfunc (m *myMockObject) GetPrice(ctx context.Context, p *products.PriceParams) (*products.PriceResponse, error) {\n    return &products.PriceResponse{Price: 100}, nil\n}\n\nfunc Test_Something(t *testing.T) {\n    t.Parallel()\n    et.MockService[products.Interface](\"products\", &myMockObject{})\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Config Unmarshaling Functions in Go\nDESCRIPTION: This snippet shows the automatically generated unmarshaling functions that Encore creates to convert a JSON representation of the configuration into the Go `Config` struct. It uses the `jsoniter` library for efficient JSON parsing.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_named_struct_single_use.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport jsoniter \"github.com/json-iterator/go\"\n\n/*\nThese functions are automatically generated and maintained by Encore to allow config values\nto be unmarshalled into the correct types. They are not intended to be used directly. They\nare automatically updated by Encore whenever you change the data types used within your\ncalls to config.Load[T]().\n*/\n\n// Concrete unmarshalers for all config.Load calls, including those using generic types.\n// These instances are used directly by calls to `config.Load[T]()`.\nvar (\n\tencoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {\n\t\treturn func() *Config {\n\t\t\t// If the value is null, we return nil\n\t\t\tif itr.ReadNil() {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Otherwise we unmarshal the value and return a pointer to it\n\t\t\tobj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))\n\t\t\treturn &obj\n\t\t}()\n\t}\n)\n\n// encoreInternalTypeConfigUnmarshaler_svc_Config will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"HTTP\":\n\t\t\tobj.HTTP = encoreInternalTypeConfigUnmarshaler_svc_ServerOptions(itr, append(path, \"HTTP\"))\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n\n// encoreInternalTypeConfigUnmarshaler_svc_ServerOptions will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_svc_ServerOptions(itr *jsoniter.Iterator, path []string) (obj ServerOptions) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"Enabled\":\n\t\t\tobj.Enabled = itr.ReadBool()\n\t\tcase \"Port\":\n\t\t\tobj.Port = itr.ReadUint32()\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Unmarshalling for Config in Encore (Go)\nDESCRIPTION: This snippet provides a function to unmarshal JSON configuration values into the Config struct. It defines a pointer unmarshaler that correctly handles null values and maps JSON fields to struct fields based on their type.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_lists.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\tconfig \"encore.dev/config\"\n\tjsoniter \"github.com/json-iterator/go\"\n)\n\n/*\nThese functions are automatically generated and maintained by Encore to allow config values\nto be unmarshalled into the correct types. They are not intended to be used directly. They\nare automatically updated by Encore whenever you change the data types used within your\ncalls to config.Load[T]().\n*/\n\n// Concrete unmarshalers for all config.Load calls, including those using generic types.\n// These instances are used directly by calls to `config.Load[T]()`. \nvar (\n\tencoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {\n\t\treturn func() *Config {\n\t\t\t// If the value is null, we return nil\n\t\t\tif itr.ReadNil() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\t\n\t\t\t// Otherwise we unmarshal the value and return a pointer to it\n\t\t\tobj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))\n\t\t\treturn &obj\n\t\t}()\n\t}\n)\n\n// encoreInternalTypeConfigUnmarshaler_svc_Config will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"Ages\":\n\t\t\tobj.Ages = config.ReadArray[int32](itr, func(itr *jsoniter.Iterator, idx int) int32 {\n\t\t\t\treturn itr.ReadInt32()\n\t\t\t})\n\t\tcase \"OtherBits\":\n\t\t\tobj.OtherBits = config.ReadArray[string](itr, func(itr *jsoniter.Iterator, idx int) string {\n\t\t\t\treturn itr.ReadString()\n\t\t\t})\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GraphQL Resolvers in Go\nDESCRIPTION: This Go code implements the resolvers for the GraphQL API, mapping GraphQL operations to Encore API calls for URL shortening and retrieval.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/graphql.mdx#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// Shorten is the resolver for the shorten field.\nfunc (r *mutationResolver) Shorten(ctx context.Context, input string) (*url.URL, error) {\n\treturn url.Shorten(ctx, &url.ShortenParams{URL: input})\n}\n\n// Urls is the resolver for the urls field.\nfunc (r *queryResolver) Urls(ctx context.Context) ([]*url.URL, error) {\n\tresp, err := url.List(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn resp.URLs, nil\n}\n\n// Get is the resolver for the get field.\nfunc (r *queryResolver) Get(ctx context.Context, id string) (*url.URL, error) {\n\treturn url.Get(ctx, id)\n}\n```\n\n----------------------------------------\n\nTITLE: Updating GetBookableSlots to Respect Availability Settings\nDESCRIPTION: Updated GetBookableSlots endpoint that uses the configured availability for each day and filters out slots that aren't available or already booked, providing a list of valid booking slots.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_18\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public method=GET path=/slots/:from\nfunc GetBookableSlots(ctx context.Context, from string) (*SlotsResponse, error) {\n\tfromDate, err := time.Parse(\"2006-01-02\", from)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tavailabilityResp, err := GetAvailability(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tavailability := availabilityResp.Availability\n\n\tconst numDays = 7\n\n\tvar slots []BookableSlot\n\tfor i := 0; i < numDays; i++ {\n\t\tdate := fromDate.AddDate(0, 0, i)\n\t\tweekday := int(date.Weekday())\n\t\tif len(availability) <= weekday {\n\t\t\tbreak\n\t\t}\n\t\tdaySlots, err := bookableSlotsForDay(date, &availability[weekday])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tslots = append(slots, daySlots...)\n\t}\n\n\t// Get bookings for the next 7 days.\n\tactiveBookings, err := listBookingsBetween(ctx, fromDate, fromDate.AddDate(0, 0, numDays))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tslots = filterBookableSlots(slots, time.Now(), activeBookings)\n\treturn &SlotsResponse{Slots: slots}, nil\n}\n\nfunc bookableSlotsForDay(date time.Time, avail *Availability) ([]BookableSlot, error) {\n\tif avail.Start == nil || avail.End == nil {\n\t\treturn nil, nil\n\t}\n\tavailStartTime, err1 := strToTime(avail.Start)\n\tavailEndTime, err2 := strToTime(avail.End)\n\tif err := errors.Join(err1, err2); err != nil {\n\t\treturn nil, err\n\t}\n\n\tavailStart := date.Add(time.Duration(availStartTime.Microseconds) * time.Microsecond)\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Messages in a Streaming API with Encore\nDESCRIPTION: This code demonstrates how to broadcast messages to all connected clients using a StreamInOut API endpoint. It uses a Map to store the connected streams and iterates over them to send messages to each client.  Error handling is included to remove disconnected clients from the map.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/streaming-apis.mdx#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api, StreamInOut } from \"encore.dev/api\";\n\n// Map to hold all connected streams\nconst connectedStreams: Map<\n  string,\n  StreamInOut<ChatMessage, ChatMessage>\n> = new Map();\n\n// Object sent from the client to the server when establishing a connection\ninterface HandshakeRequest {\n  id: string;\n}\n\n// Object by both server and client\ninterface ChatMessage {\n  username: string;\n  msg: string;\n}\n\nexport const chat = api.streamInOut<HandshakeRequest, ChatMessage, ChatMessage>(\n  { expose: true, auth: false, path: \"/chat\" },\n  async (handshake, stream) => {\n    connectedStreams.set(handshake.id, stream);\n\n    try {\n      // The stream object is an AsyncIterator that yields incoming messages.\n      // The loop will continue as long as the client keeps the connection open.\n      for await (const chatMessage of stream) {\n        for (const [key, val] of connectedStreams) {\n          try {\n            // Send the users message to all connected clients.\n            await val.send(chatMessage);\n          } catch (err) {\n            // If there is an error sending the message, remove the client from the map.\n            connectedStreams.delete(key);\n          }\n        }\n      }\n    } catch (err) {\n      // If there is an error reading from the stream, remove the client from the map.\n      connectedStreams.delete(handshake.id);\n    }\n\n    // When the client disconnects, remove them from the map.\n    connectedStreams.delete(handshake.id);\n  },\n);\n\n```\n\n----------------------------------------\n\nTITLE: Using Query Parameters with Encore.ts\nDESCRIPTION: This snippet shows how to define and use query parameters in the request schema for an API endpoint with Encore.ts, including cases where the parameters are read from the query string.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api, Query } from \"encore.dev/api\";\n\ninterface Schema {\n  query: Query<string>; // this will be parsed from the '?query=...' parameter in the request url\n}\n// A simple API endpoint that echoes the data back.\nexport const echo = api(\n  { method: \"POST\", path: \"/example\" },\n  async (params: Schema) => {\n    // params.query is a string\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Interface Type Extraction Utility in TypeScript\nDESCRIPTION: Defines a generic type 'Iface' that extracts the type of property X from a given type T using conditional types and the infer keyword. If T doesn't have property X, it returns the 'never' type.\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/src/parser/types/testdata/infer.txt#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Iface<T> = T extends { X: infer A } ? A : never;\n```\n\n----------------------------------------\n\nTITLE: Static Configuration Definition - Go\nDESCRIPTION: This snippet outlines a synthetic file containing configuration settings for the Encore application. It includes information on CORS settings, pubsub topics, and test paths. This data is used internally for application configuration.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/subscription.txt#2025-04-21_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\npackage synthetic\n\n/*\n\nThis is a synthetic file describing the generated static config:\n\n{\n\t\"EncoreCompiler\": \"\",\n\t\"AppCommit\": {\n\t\t\"revision\": \"\",\n\t\t\"uncommitted\": false\n\t},\n\t\"CORSAllowHeaders\": null,\n\t\"CORSExposeHeaders\": null,\n\t\"PubsubTopics\": {\n\t\t\"topic\": {\n\t\t\t\"Subscriptions\": {\n\t\t\t\t\"subscription\": {\n\t\t\t\t\t\"Service\": \"code\",\n\t\t\t\t\t\"SvcNum\": 1,\n\t\t\t\t\t\"TraceIdx\": 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t\"Testing\": false,\n\t\"TestServiceMap\": {\n\t\t\"code\": \"testing_path:code\"\n\t},\n\t\"TestAppRootPath\": \"testing_path:main\",\n\t\"PrettyPrintLogs\": false,\n\t\"BundledServices\": [\n\t\t\"code\"\n\t],\n\t\"EmbeddedEnvs\": {}\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Attempting to Define Cache Keyspace in Library Package\nDESCRIPTION: This code incorrectly attempts to define a cache keyspace in a library package, which is not permitted in Encore. Cache keyspaces must be defined within a service package.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cache_err_keyspace_outside_svc.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage lib\n\nimport (\n    \"context\"\n\n    \"encore.dev/storage/cache\"\n    \"test/svc\"\n)\n\ntype Key[T any] struct {\n    Foo T\n}\n\nvar keyspace = cache.NewStringKeyspace[Key[string]](svc.Cluster, cache.KeyspaceConfig{\n    KeyPattern: \"foo/:Foo\",\n})\n```\n\n----------------------------------------\n\nTITLE: Updating Temporal Client Connection in Go\nDESCRIPTION: Modifies the Temporal client connection to use the configured server address.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/temporal.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nclient.Dial(client.Options{HostPort: cfg.TemporalServer})\n```\n\n----------------------------------------\n\nTITLE: Creating an API Function in a Separate Service - Go\nDESCRIPTION: In this code snippet, an API function 'Bar' is declared within another service, 'svc2'. It imports the 'svc' package to reference the 'Service' struct, thus demonstrating the intent to use service structs across different services. This snippet is significant in demonstrating the limitation enforced on referencing the 'Service' struct declared in 'svc' from 'svc2'.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/servicestruct_ref.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage svc2\n\nimport (\n\t\"context\"\n\n\t\"test/svc\"\n)\n\n//encore:api public\nfunc Bar(ctx context.Context) error { return nil }\n\nfunc Foo(s *svc.Service) {}\n```\n\n----------------------------------------\n\nTITLE: Defining API Function Foo in MyService\nDESCRIPTION: This API function 'Foo' is defined within the 'myservice' package. It is a public API endpoint that takes a context parameter but currently does not perform any operations, returning nil. This sets up the structure for future implementations of functionality within the API.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_success.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public\nfunc Foo(ctx context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StreamInOut API Endpoint with Encore\nDESCRIPTION: This code defines a `streamInOut` API endpoint using Encore, facilitating bidirectional streaming between the client and server. It processes incoming messages from the client, sends a response, and continues this loop.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nexport const chatStream = api.streamInOut<InMessage, OutMessage>(\n  { path: \"/chat\", expose: true },\n  async (stream) => {\n    for await (const msg of stream) {\n      await stream.send(/* response */);\n    }\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Invalid Cache Key Type Implementation in Go\nDESCRIPTION: Demonstrates an invalid cache key implementation where a generic struct type is used as a cache key field, which is not allowed since cache key fields must be basic types.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cache_err_generic_type_nonbasic.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/storage/cache\"\n)\n\nvar cluster = cache.NewCluster(\"cluster\", cache.ClusterConfig{})\n\ntype Key[T any] struct {\n    Foo T\n}\n\nvar keyspace = cache.NewStringKeyspace[Key[Key[string]]](cluster, cache.KeyspaceConfig{\n    KeyPattern: \"foo/:Foo\",\n})\n\n//encore:api public\nfunc Foo(context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Auth Handler Parameters in Encore with Missing Source Tags\nDESCRIPTION: This code snippet shows an incorrect implementation of an auth handler parameter structure in Encore. The struct contains fields for authentication, but two fields ('Foo' and 'Bar') are missing the required tags that specify where the parameter should come from (header, query, or cookie).\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/auth_handler_invalid_field_source.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"encore.dev/beta/auth\"\n)\n\ntype Params struct {\n    Authorization string `header:\"Authorization\"`\n    Foo string\n    ClientID string `query:\"client_id\"`\n    Bar int\n}\n\n//encore:authhandler\nfunc MyAuth(ctx context.Context, p *Params) (auth.UID, error) { return \"\", nil }\n```\n\n----------------------------------------\n\nTITLE: Disabling Telemetry via CLI Command\nDESCRIPTION: Shell command to disable telemetry collection in Encore, providing users with direct control over data sharing preferences\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/management/telemetry.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nencore telemetry disable\n```\n\n----------------------------------------\n\nTITLE: Error Assertion for Invalid Secret Type\nDESCRIPTION: This snippet shows the expected error message when the `secrets` struct contains a non-string field. The error message indicates that the `Foo` field is not of type string and provides a link to the Encore documentation for more information about using secrets.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/secrets_non_string.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n Invalid secrets struct [E9999]\n\nSecrets must be of type string.\n\n   [ svc/svc.go:4:9 ]\n   \n 2 \n 3  var secrets struct {\n 4      Foo int\n            \n              got int\n 5  }\n 6 \n\n\nFor more information about how to use secrets, see https://encore.dev/docs/primitives/secrets\n```\n\n----------------------------------------\n\nTITLE: Cloning Encore Application\nDESCRIPTION: Clones an Encore application to the local machine.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ encore app clone [app-id] [directory]\n```\n\n----------------------------------------\n\nTITLE: Automating Deployment with GitHub Actions and Encore\nDESCRIPTION: This GitHub Actions workflow automates the process of building, pushing, and deploying an Encore Docker image to DigitalOcean. It logs in to DigitalOcean's container registry, downloads and installs the Encore CLI, builds the Docker image, tags it, and pushes it to the registry. Prerequisites include setting up your DigitalOcean credentials and repository details.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/ci-cd.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nname: Build, Push and Deploy a Encore Docker Image to DigitalOcean\n\non:\n  push:\n    branches: [ main ]\n\npermissions:\n  contents: read\n  packages: write\n\njobs:\n  build-push-deploy-image:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n\n      - name: Download Encore CLI script\n        uses: sozo-design/curl@v1.0.2\n        with:\n          args: --output install.sh -L https://encore.dev/install.sh\n\n      - name: Install Encore CLI\n        run: bash install.sh\n\n      - name: Log in to DigitalOcean container registry\n        run: docker login registry.digitalocean.com -u my-email@gmail.com -p ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}\n\n      - name: Build Docker image\n        run: /home/runner/.encore/bin/encore build docker myapp\n\n      - name: Tag Docker image\n        run: docker tag myapp registry.digitalocean.com/<YOUR_CONTAINER_REGISTRY_NAME>/<YOUR_IMAGE_REPOSITORY_NAME>:latest\n\n      - name: Push Docker image\n        run: docker push registry.digitalocean.com/<YOUR_CONTAINER_REGISTRY_NAME>/<YOUR_IMAGE_REPOSITORY_NAME>:latest\n```\n\n----------------------------------------\n\nTITLE: Handling Audit Logs Based on Cloud Environment in Encore Go\nDESCRIPTION: This Go snippet demonstrates how to route audit logging actions to different backend services based on the cloud environment. It utilizes the `encore.Meta()` method to check the current cloud provider and execute the appropriate function for that environment. It requires the Encore package and services specific to the cloud environments (AWS, GCP, or local development). The function expects a context, an action message, and a user UID as inputs, and returns an error if the cloud environment is unrecognized.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/metadata.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage audit\n\nimport (\n    \"encore.dev\"\n    \"encore.dev/beta/auth\"\n)\n\nfunc Audit(ctx context.Context, action message, user auth.UID) error {\n    switch encore.Meta().Environment.Cloud {\n    case encore.CloudAWS:\n        return writeIntoRedshift(ctx, action, user)\n    case encore.CloudGCP:\n        return writeIntoBigQuery(ctx, action, user)\n    case encore.CloudLocal:\n        return writeIntoFile(ctx, action, user)\n    default:\n        return fmt.Errorf(\"unknown cloud: %s\", encore.Meta().Environment.Cloud)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring gqlgen with YAML\nDESCRIPTION: This YAML configuration file for gqlgen specifies schema locations, output directories for generated code, resolver layout, and type mappings for the GraphQL API.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/graphql.mdx#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nschema:\n  - graphql/*.graphqls\n\nexec:\n  filename: graphql/generated/generated.go\n  package: generated\n\nmodel:\n  filename: graphql/model/models_gen.go\n  package: model\n\nresolver:\n  layout: follow-schema\n  dir: graphql\n  package: graphql\n\nautobind:\n - \"encore.app/url\"\n\nmodels:\n  ID:\n    model:\n      - github.com/99designs/gqlgen/graphql.ID\n      - github.com/99designs/gqlgen/graphql.Int\n      - github.com/99designs/gqlgen/graphql.Int64\n      - github.com/99designs/gqlgen/graphql.Int32\n  Int:\n    model:\n      - github.com/99designs/gqlgen/graphql.Int\n      - github.com/99designs/gqlgen/graphql.Int64\n      - github.com/99designs/gqlgen/graphql.Int32\n```\n\n----------------------------------------\n\nTITLE: Setting Secrets with Encore CLI\nDESCRIPTION: Command to set a new secret value. Requires specifying the secret type (production, development, preview, or local) and the secret name.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_43\n\nLANGUAGE: bash\nCODE:\n```\nencore secret set --type types secret-name\n```\n\n----------------------------------------\n\nTITLE: Push Notification Cron Job\nDESCRIPTION: Implements a cron job for sending push notifications to new subscribers, scheduled to run every Thursday.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cron_job_definition.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nvar _ = cron.NewJob(\"cronfoocious\", cron.JobConfig{\n\tTitle:     \"Cron Foo Bar Bazz\",\n\tSchedule: \"* * * * 4\",\n\tEndpoint: CronAPI,\n})\n```\n\n----------------------------------------\n\nTITLE: Automatic Unmarshalling for Encore Config in Go\nDESCRIPTION: This snippet includes automatically generated unmarshalers for converting JSON configuration values into the Config structure, utilizing the json-iterator package for efficient processing.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/json_tags.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport jsoniter \"github.com/json-iterator/go\"\n\n/*\nThese functions are automatically generated and maintained by Encore to allow config values\nto be unmarshalled into the correct types. They are not intended to be used directly. They\nare automatically updated by Encore whenever you change the data types used within your\ncalls to config.Load[T]().\n*/\n\n// Concrete unmarshalers for all config.Load calls, including those using generic types.\n// These instances are used directly by calls to `config.Load[T]()`. \nvar (\n\tencoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {\n\t\treturn func() *Config {\n\t\t\t// If the value is null, we return nil\n\t\t\tif itr.ReadNil() {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Otherwise we unmarshal the value and return a pointer to it\n\t\t\tobj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))\n\t\t\treturn &obj\n\t\t}()\n\t}\n)\n\n// encoreInternalTypeConfigUnmarshaler_svc_Config will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"HTTP\":\n\t\t\tobj.HTTP = encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr, append(path, \"HTTP\"))\n\t\tcase \"a_n_o_t_h_e_r\":\n\t\t\tobj.Another = encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr, append(path, \"a_n_o_t_h_e_r\"))\n\t\tcase \"TCP\":\n\t\t\tobj.TCP = encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr, append(path, \"TCP\"))\n\t\tcase \"GRPC\":\n\t\t\tobj.GRPC = encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr, append(path, \"GRPC\"))\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n\n// encoreInternalTypeConfigUnmarshaler_svc_ServerOption will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr *jsoniter.Iterator, path []string) (obj ServerOption) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"Option\":\n\t\t\tobj.Option = itr.ReadInt64()\n\t\tcase \"Disabled\":\n\t\t\tobj.Disabled = itr.ReadBool()\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Cron API Endpoint Implementation\nDESCRIPTION: Implements a public API endpoint that returns a simple response message. Used as the target endpoint for various cron jobs.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cron_job_definition.txt#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public path=/cron\nfunc CronAPI(ctx context.Context) (*Response, error) {\n\tmsg := \"Hello, Cron!\"\n\treturn &Response{Message: msg}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Service Interface for Foo\nDESCRIPTION: Automatically generated interface for the Foo service to define the API surface and support mocking\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/multiple_services.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ntype Interface interface {\n\tFoo(ctx context.Context) error\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies\nDESCRIPTION: Shell command to install Knex.js and PostgreSQL client dependencies\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n$ npm i knex pg\n```\n\n----------------------------------------\n\nTITLE: Disabling Telemetry via Environment Variable\nDESCRIPTION: Alternative method to disable telemetry by setting an environment variable, offering flexibility in configuration\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/management/telemetry.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nexport DISABLE_ENCORE_TELEMETRY=1\n```\n\n----------------------------------------\n\nTITLE: API Request Test Commands\nDESCRIPTION: Series of test commands to verify API endpoint responses using HTTP GET and POST methods\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/fallback_routes.txt#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrun\ncall GET /v1/regular ''\ncheckresp '{\"Message\":\"Hello, Encore world!\"}'\ncall GET /v1/regular/foo ''\ncheckresp '{\"fallback\": true}'\ncall POST /v1/regular ''\ncheckresp '{\"fallback\": true}'\ncall GET /v2/regular ''\ncheckresp '{\"fallback\": true}'\ncall GET / ''\ncheckresp '{\"fallback\": true}'\n```\n\n----------------------------------------\n\nTITLE: Retrieve Pods from Kubernetes Cluster using kubectl\nDESCRIPTION: This command retrieves a list of pods from the Kubernetes cluster configured via Encore. It is used after configuring kubectl with the `encore kubernetes configure` command to verify the connection and interact with the cluster's resources.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/infrastructure/configure-kubectl.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nkubectl get pods\n```\n\n----------------------------------------\n\nTITLE: Setting Custom 404 Response for Static Assets\nDESCRIPTION: This code configures a custom 404 response by specifying a 'notFound' HTML page that will be returned if the requested static asset is not found.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nexport const assets = api.static(\n  { \n    expose: true, \n    path: \"/!path\", \n    dir: \"./assets\", \n    notFound: \"./not_found.html\" \n  },\n);\n\n```\n\n----------------------------------------\n\nTITLE: Defining Public API Endpoints in Go with Encore\nDESCRIPTION: Defines two public API methods Foo and Bar in the svca service with context support and simple error handling\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/api_call.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\n//encore:api public\nfunc Foo(ctx context.Context) error { return nil }\n\n//encore:api public\nfunc Bar(ctx context.Context) error { return Foo(ctx) }\n```\n\n----------------------------------------\n\nTITLE: Enabling CGO Support in Encore Applications\nDESCRIPTION: Shows how to enable CGO in an Encore application by modifying the encore.app configuration file. This sets up the appropriate build environment for including C libraries.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_37\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"my-app-id\",\n  \"build\": {\n    \"cgo_enabled\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Service Interface Generation for API Endpoints\nDESCRIPTION: Automatically generated interface defining the service's API surface area, used primarily for mocking and service integration\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/api_call.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\ntype Interface interface {\n\tFoo(ctx context.Context) error\n\tBar(ctx context.Context) error\n}\n```\n\n----------------------------------------\n\nTITLE: Service Discovery Configuration in JSON\nDESCRIPTION: Configuration for service discovery, showing how to set up access to other services over the network with authentication.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"service_discovery\": {\n    \"myservice\": {\n      \"base_url\": \"https://myservice.myencoreapp.com\",\n      \"auth\": [\n        {\n          \"type\": \"key\",\n          \"id\": 1,\n          \"key\": {\n            \"$env\": \"MY_SERVICE_API_KEY\"\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Authentication Handler in Encore.js\nDESCRIPTION: This snippet implements an authentication handler for APIs requiring authentication. It utilizes the 'authHandler' function and specifies the parameters and data structure used during authentication.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Header, Gateway } from \"encore.dev/api\";\nimport { authHandler } from \"encore.dev/auth\";\n\ninterface AuthParams {\n    authorization: Header<\"Authorization\">;\n}\n\ninterface AuthData {\n    userID: string;\n}\n\nexport const auth = authHandler<AuthParams, AuthData>(\n    async (params) => {\n        // Authenticate user based on params\n        return {userID: \"my-user-id\"};\n    }\n)\n\nexport const gateway = new Gateway({\n    authHandler: auth,\n})\n\n```\n\n----------------------------------------\n\nTITLE: Updating Encore CLI\nDESCRIPTION: Command to check for available updates to Encore CLI and apply them if found.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_48\n\nLANGUAGE: bash\nCODE:\n```\nencore version update\n```\n\n----------------------------------------\n\nTITLE: Defining Service Configuration in Go\nDESCRIPTION: This snippet defines the `Config` struct and `ServerOptions` struct, which are used to configure the service. It also shows how to load the configuration using `config.Load[*Config]()`.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_named_struct_single_use.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n)\n\ntype ServerOptions struct {\n    Enabled bool // Is this option enabled?\n    Port    uint32 // What port should we run on?\n}\n\ntype Config struct {\n    HTTP ServerOptions // The options for the HTTP server\n}\n\nvar _ = config.Load[*Config]()\n\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Clerk Development Secret in Encore\nDESCRIPTION: Command to set the Clerk secret key for development environment in Encore\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/clerk-auth.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ encore secret set --dev ClientSecretKey\n```\n\n----------------------------------------\n\nTITLE: Telemetry Data Example\nDESCRIPTION: This JSON snippet represents an example of the telemetry data sent by Encore. It includes an event name, an anonymous ID, and properties related to the event, such as language and template used.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/telemetry.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"event\": \"app.create\",\n    \"anonymousId\": \"a-uuid-unique-for-the-installation\",\n    \"properties\": {\n        \"error\": false,\n        \"lang\": \"go\",\n        \"template\": \"graphql\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Monitor Service Directory\nDESCRIPTION: Shell commands to create the monitor service directory structure.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ mkdir monitor\n$ touch monitor/encore.service.ts\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Encore\nDESCRIPTION: Shell command to run tests for the Encore application.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/uptime.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ encore test ./...\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration for AsConfig in Go with Encore\nDESCRIPTION: This snippet defines the AsConfig type and implements the configuration loading functionality using Encore. It specifies a field Foo of type config.String and loads the configuration using the config.Load method. The purpose is to facilitate structured configuration management in an Encore service.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/merge_identical_comments.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n)\n\ntype AsConfig struct {\n\t// Multiline test\n\t// comment to deduplicate.\n\tFoo config.String\n}\n\nvar _ = config.Load[*AsConfig]()\n\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Encore on Windows using PowerShell\nDESCRIPTION: PowerShell command to install Encore on Windows systems by downloading and executing the installation script.\nSOURCE: https://github.com/encoredev/encore/blob/main/README.md#2025-04-21_snippet_6\n\nLANGUAGE: powershell\nCODE:\n```\niwr https://encore.dev/install.ps1 | iex\n```\n\n----------------------------------------\n\nTITLE: Windows Symlink Error Resolution Command\nDESCRIPTION: Command to restart the Encore daemon to resolve node-related errors, particularly after PATH changes with nvm.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/faq.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nencore daemon\n```\n\n----------------------------------------\n\nTITLE: Enabling Telemetry Debug Mode\nDESCRIPTION: Environment variable to activate debug mode for telemetry, allowing users to see detailed log statements about data transmission\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/management/telemetry.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nexport ENCORE_TELEMETRY_DEBUG=1\n```\n\n----------------------------------------\n\nTITLE: Defining Request and Response Schemas for Encore API\nDESCRIPTION: This snippet shows how to define request (PingParams) and response (PingResponse) schemas for an Encore API endpoint. It includes the full implementation of the 'Ping' function.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/defining-apis.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage hello // service name\n\n// PingParams is the request data for the Ping endpoint.\ntype PingParams struct {\n    Name string\n}\n\n// PingResponse is the response data for the Ping endpoint.\ntype PingResponse struct {\n    Message string\n}\n\n// Ping is an API endpoint that responds with a simple response.\n// This is exposed as \"hello.Ping\".\n//encore:api public\nfunc Ping(ctx context.Context, params *PingParams) (*PingResponse, error) {\n    msg := fmt.Sprintf(\"Hello, %s!\", params.Name)\n    return &PingResponse{Message: msg}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Encore API Client\nDESCRIPTION: Generates an API client for the Encore application in various languages, with options to specify environment, services, and language.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\n$ encore gen client [<app-id>] [--env=<name>] [--services=foo,bar] [--excluded-services=baz,qux] [--lang=<lang>] [flags]\n```\n\n----------------------------------------\n\nTITLE: Defining Public API Endpoint in Go\nDESCRIPTION: Implementation of a public API endpoint tagged with 'bar' using Encore's API directive.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/middleware_err_no_matches.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public tag:bar\nfunc API(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Using Encore Terraform Data Sources\nDESCRIPTION: This code snippet demonstrates how to use the `encore_pubsub_topic` data source to retrieve information about an Encore PubSub topic and establish a connection to AWS IoT Core. The required dependencies include having AWS credentials configured, and valid Terraform and Encore setups.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/integrations/terraform.md#2025-04-21_snippet_1\n\nLANGUAGE: HCL\nCODE:\n```\ndata \"encore_pubsub_topic\" \"topic\" {\n  name = \"my-topic\"\n  env  = \"my-env\"\n}\n\nresource \"aws_iot_topic_rule\" \"rule\" {\n  name = \"my-rule\"\n  sql  = \"SELECT * FROM 'my-topic'\"\n  sns {\n    message_format = \"RAW\"\n    role_arn       = aws_iam_role.role.arn\n    target_arn     = data.encore_pubsub_topic.topic.aws_sns.arn\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Establishing Database Connection in Go\nDESCRIPTION: This snippet sets up a variable 'Moo' in the 'pkg' package that holds a named SQL database connection using Encore's sqldb package. It imports the context package along with sqldb to facilitate database operations.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_outside_svc.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nvar Moo = sqldb.Named(\"svc\")\n```\n\n----------------------------------------\n\nTITLE: Adding Pub/Sub Subscriber for Slack Notifications in TypeScript\nDESCRIPTION: The snippet showcases how to set up a Pub/Sub subscriber in Encore that automatically sends Slack notifications when a monitored site's status changes. This setup uses the Subscription class from Encore's pubsub module and listens to changes from the TransitionTopic, sending pertinent updates via the previously defined notify function.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_28\n\nLANGUAGE: ts\nCODE:\n```\nimport { Subscription } from \"encore.dev/pubsub\";\nimport { TransitionTopic } from \"../monitor/check\";\n\nconst _ = new Subscription(TransitionTopic, \"slack-notification\", {\n  handler: async (event) => {\n    const text = `*${event.site.url} is ${event.up ? \"back up.\" : \"down!\"}*`;\n    await notify({ text });\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Module Declaration in Go\nDESCRIPTION: The go.mod file establishes the module path for the Go project as 'example.com'. This is a fundamental aspect of any Go project where modules are used to manage dependencies and project organization.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/compiler/build/testdata/basic.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nmodule example.com\n\n```\n\n----------------------------------------\n\nTITLE: Register and Handle API Endpoints with Encore\nDESCRIPTION: This complex snippet registers the Foo endpoint and handles related operations using Encore's API SDK. It includes encoding/decoding of requests and responses, registering middleware, and setting HTTP methods and paths.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/basic.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\npackage basic\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n}\n\ntype EncoreInternal_FooReq struct{}\n\ntype EncoreInternal_FooResp = __api.Void\n\nvar EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{\n\tAccess: __api.Public,\n\tAppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {\n\t\terr := Foo(ctx)\n\t\tif err != nil {\n\t\t\treturn __api.Void{}, err\n\t\t}\n\t\treturn __api.Void{}, nil\n\t},\n\tCloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {\n\t\tvar clone *EncoreInternal_FooReq\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tCloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {\n\t\tvar clone EncoreInternal_FooResp\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tDecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {\n\t\treturn __api.Void{}, nil\n\t},\n\tDecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {\n\t\treqData = new(EncoreInternal_FooReq)\n\t\treturn reqData, nil, nil\n\t},\n\tDefLoc: uint32(0x0),\n\tEncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {\n\t\treturn nil, nil, nil\n\t},\n\tEncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {\n\t\treturn nil\n\t},\n\tEndpoint:            \"Foo\",\n\tFallback:            false,\n\tGlobalMiddlewareIDs: []string{},\n\tMethods:             []string{\"GET\", \"POST\"},\n\tPath:                \"/basic.Foo\",\n\tPathParamNames:      nil,\n\tRaw:                 false,\n\tRawHandler:          nil,\n\tRawPath:             \"/basic.Foo\",\n\tReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {\n\t\treturn \"/basic.Foo\", nil, nil\n\t},\n\tReqUserPayload: func(reqData *EncoreInternal_FooReq) any {\n\t\treturn nil\n\t},\n\tService:           \"basic\",\n\tServiceMiddleware: []*__api.Middleware{},\n\tSvcNum:            1,\n\tTags:              nil,\n}\n```\n\n----------------------------------------\n\nTITLE: Example Telemetry Data Structure in JSON\nDESCRIPTION: Example of the telemetry data structure that Encore sends, showing the event type, anonymous ID, and associated properties.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/telemetry.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"event\": \"app.create\",\n    \"anonymousId\": \"a-uuid-unique-for-the-installation\",\n    \"properties\": {\n        \"error\": false,\n        \"lang\": \"go\",\n        \"template\": \"graphql\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Encore Interface Definition\nDESCRIPTION: This snippet shows the generated Go code that defines an interface for the Encore service. This interface is used for mocking and defines the `Foo` method, mirroring the API endpoint. This interface is automatically updated by Encore when the API endpoints change.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/recursive.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\n// Code generated by encore. DO NOT EDIT.\n\npackage basic\n\nimport \"context\"\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\n\n// Interface defines the service's API surface area, primarily for mocking purposes.\n//\n// Raw endpoints are currently excluded from this interface, as Encore does not yet\n// support service-to-service API calls to raw endpoints.\ntype Interface interface {\n\tFoo(ctx context.Context, p *Recursive) (*Recursive, error)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Public API with Encore in Go\nDESCRIPTION: This snippet defines a public API method Foo which takes a context and returns a pointer to Response and an error. It serves as the main API endpoint for external services to access functionality.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/unexported.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public\nfunc Foo(ctx context.Context) (*Response, error) { return nil, nil }\n```\n\n----------------------------------------\n\nTITLE: Defining Configuration Structure in Go\nDESCRIPTION: Defines a configuration struct with a map of ages, using Encore's config loading mechanism\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_maps.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype Config struct {\n    Ages map[string]int\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Raw API Endpoint in Go with Encore\nDESCRIPTION: This code snippet defines a public raw API endpoint using the Encore framework in Go. The endpoint is set to use a custom path of '/foo'. The necessary imports include the 'net/http' standard library.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_raw_custom_path.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public raw path=/foo\nfunc API(w http.ResponseWriter, req *http.Request) { }\n```\n\n----------------------------------------\n\nTITLE: Middleware Function Definition in Encore.ts\nDESCRIPTION: This code snippet demonstrates how to define a middleware function in Encore.ts using the `middleware` helper from `encore.dev/api`. It shows how to specify a target (in this case, endpoints that require authentication) and how to use the `next` function to proceed to the next middleware or the API handler.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/middleware.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { middleware } from \"encore.dev/api\";\n\nexport default new Service(\"myService\", {\n    middlewares: [\n        middleware({ target: { auth: true } }, async (req, next) => {\n            // do something before the api handler\n            const resp = await next(req);\n            // do something after the api handler\n            return resp\n        })\n    ]\n});\n\n```\n\n----------------------------------------\n\nTITLE: Automated Configuration Unmarshaller Generation\nDESCRIPTION: Contains automatically generated code for unmarshalling JSON configuration into the Config struct. Handles complex type conversions and provides robust error handling for configuration parsing.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_wrappers.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nvar (\n\tencoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {\n\t\treturn func() *Config {\n\t\t\tif itr.ReadNil() {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tobj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))\n\t\t\treturn &obj\n\t\t}()\n\t}\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Delve CLI Tool\nDESCRIPTION: Command to install the Delve debugger for Go applications using go install\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/debug.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ go install github.com\\/go-delve\\/delve\\/cmd\\/dlv@latest\n```\n\n----------------------------------------\n\nTITLE: Starting Encore VPN\nDESCRIPTION: Sets up a secure connection to private Encore environments.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_27\n\nLANGUAGE: shell\nCODE:\n```\n$ encore vpn start\n```\n\n----------------------------------------\n\nTITLE: Configuring NSQ in Encore\nDESCRIPTION: This snippet illustrates the configuration for NSQ (a distributed messaging platform) in an Encore application. It defines a topic 'order-events' with a subscription 'order-processor'.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"pubsub\": [\n    {\n      \"type\": \"nsq\",\n      \"hosts\": \"nsq.myencoreapp.com:4150\",\n      \"topics\": {\n        \"order-events\": {\n          \"name\": \"order-events-topic\",\n          \"subscriptions\": {\n            \"order-processor\": {\n              \"name\": \"order-processor-subscription\"\n            }\n          }\n        }\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Internal Configuration Unmarshaling for BsConfig in Go with Encore\nDESCRIPTION: This snippet features the unmarshaling function for BsConfig, ensuring that JSON data is accurately transformed into the respective Go struct. This aids in effective configuration management within the Encore application context.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/merge_identical_comments.txt#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc encoreInternalTypeConfigUnmarshaler_svc_BsConfig(itr *jsoniter.Iterator, path []string) (obj BsConfig) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"Foo\":\n\t\t\tobj.Foo = config.CreateValue[string](itr.ReadString(), append(path, \"Foo\"))\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Database Querying in a Separate Package\nDESCRIPTION: This code shows how to access and use a database connection defined in another package. It demonstrates the usage of `svc.DB` to call the `QueryRow()` method, and `DB.Publish()` with `svc.Message`.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/parser/resource/usage/testdata/sqldb_usage.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\n\"package usage\\nimport \\\"example.com/svc\\\"\\n\\nvar x = svc.DB.QueryRow() // use svc.DB call QueryRow\\nvar y = DB.Publish(svc.Message{})\"\n```\n\n----------------------------------------\n\nTITLE: Deploying Backend with Git\nDESCRIPTION: These shell commands are used to add all changes, commit them with a message, and push the code to the 'encore' remote to initiate backend deployment to the cloud. Prerequisites include a configured 'encore' remote repository and necessary permissions.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/meeting-notes.mdx#2025-04-21_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n$ git add -A .\\n$ git commit -m 'Initial commit'\\n$ git push encore\n```\n\n----------------------------------------\n\nTITLE: Overlaying Main Function in Go\nDESCRIPTION: This snippet demonstrates an overlay that replaces the original main function. The overlay's main function calls `OverlayPrint`, effectively injecting new behavior into the program's execution flow. The dependency is on the 'overlay:print.go' file for the `OverlayPrint` function definition.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/compiler/build/testdata/overlay.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage main\nfunc main() {\n    OverlayPrint() // defined in overlay\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Vitest Script to package.json for URL Shortener\nDESCRIPTION: Package.json script configuration to enable running tests with Vitest. This configuration is needed to run tests using the 'npm test' command.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/rest-api.mdx#2025-04-21_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n\"scripts\": {\n  \"test\": \"vitest\"\n},\n```\n\n----------------------------------------\n\nTITLE: Defining Go Module\nDESCRIPTION: This snippet specifies a Go module named 'example.com'. It is essential for organizing Go packages. The snippet doesn't take any parameters or produce outputs; it's a necessary declaration for Go projects.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/compiler/build/testdata/rewrite.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nmodule example.com\n```\n\n----------------------------------------\n\nTITLE: Re-enabling Telemetry via CLI\nDESCRIPTION: Command line instruction for re-enabling Encore telemetry using the CLI tool.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/telemetry.md#2025-04-21_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nencore telemetry enable\n```\n\n----------------------------------------\n\nTITLE: Loading This Configurations - Go\nDESCRIPTION: This snippet defines the ThisConfig structure which includes two fields (Foo and Baz) and utilizes the Encore framework's config.Load function for loading its configuration.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/multiple_configs_in_service.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"encore.dev/config\"\n)\n\ntype ThisConfig struct{\n    Foo config.String // And even better in ThisConfig\n    Baz config.Bool\n}\n\nvar _ = config.Load[ThisConfig]()\n```\n\n----------------------------------------\n\nTITLE: Defining Server Configuration Options in Go\nDESCRIPTION: Struct definition for server configuration with boolean enabled flag and port specification\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_named_struct_single_use.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype ServerOptions struct {\n    Enabled bool // Is this option enabled?\n    Port    uint32 // What port should we run on?\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pub/Sub Topic in Go\nDESCRIPTION: Example showing how to create and use a typed Pub/Sub topic for user signups using Encore.go framework.\nSOURCE: https://github.com/encoredev/encore/blob/main/README.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nimport \"encore.dev/pubsub\"\n\ntype User struct { /* fields... */ }\n\nvar Signup = pubsub.NewTopic[*User](\"signup\", pubsub.TopicConfig{\n  DeliveryGuarantee: pubsub.AtLeastOnce,\n})\n\n// Publish messages by calling a method\nSignup.Publish(ctx, &User{...})\n```\n\n----------------------------------------\n\nTITLE: Checking Encore CLI Version\nDESCRIPTION: Command to report the current installed version of Encore CLI.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_47\n\nLANGUAGE: bash\nCODE:\n```\nencore version\n```\n\n----------------------------------------\n\nTITLE: Configure kubectl for Encore Kubernetes Access\nDESCRIPTION: This command configures `kubectl` to connect and authenticate to an Encore-managed Kubernetes cluster. It uses the Encore CLI to handle authentication and proxy traffic, allowing you to interact with the cluster using standard `kubectl` commands.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/infrastructure/configure-kubectl.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nencore kubernetes configure -e <environment>\n```\n\n----------------------------------------\n\nTITLE: Setting ENCORE_RUNTIMES_PATH\nDESCRIPTION: This command sets the `ENCORE_RUNTIMES_PATH` environment variable. This variable must point to the directory containing the `encore.dev` runtime package, which is located within the `runtimes` directory of the Encore Git repository. This path is crucial for the Encore Daemon to locate runtime implementations during application compilation and execution.  The input is a string representing the path.\nSOURCE: https://github.com/encoredev/encore/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nexport ENCORE_RUNTIMES_PATH=/path/to/encore/runtimes\n```\n\n----------------------------------------\n\nTITLE: Basic Environment Metadata Configuration\nDESCRIPTION: Configuration for basic environment metadata including app ID, environment details, and cloud provider settings\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"metadata\": {\n    \"app_id\": \"my-encore-app\",\n    \"env_name\": \"production\",\n    \"env_type\": \"production\",\n    \"cloud\": \"aws\",\n    \"base_url\": \"https://api.myencoreapp.com\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: SQL Database Configuration\nDESCRIPTION: Configuration for SQL databases including connection settings and TLS configuration\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"sql_servers\": [\n    {\n      \"host\": \"db.myencoreapp.com:5432\",\n      \"tls_config\": {\n        \"disabled\": false,\n        \"ca\": \"---BEGIN CERTIFICATE---\\n...\"\n      },\n      \"databases\": {\n        \"main_db\": {\n          \"max_connections\": 100,\n          \"min_connections\": 10,\n          \"username\": \"db_user\",\n          \"password\": {\n            \"$env\": \"DB_PASSWORD\"\n          }\n        }\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Encore Environment Information\nDESCRIPTION: Outputs information about the Encore environment.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n$ encore daemon env\n```\n\n----------------------------------------\n\nTITLE: Incorrect API Endpoint Reference in Package two\nDESCRIPTION: Demonstrates an invalid API usage where an endpoint is referenced but not immediately called, which triggers a parser error\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_without_calling.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage two\n\nimport (\n    \"context\"\n\n    \"test/one\"\n)\n\n//encore:api public\nfunc Foo(ctx context.Context) error {\n    f := one.One\n    f()\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Initialization Function Stub - Go\nDESCRIPTION: This snippet includes an empty init function within the package. It serves as a placeholder for package-level initialization logic that can be added in the future.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/subscription.txt#2025-04-21_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\npackage code\n\nfunc init() {}\n```\n\n----------------------------------------\n\nTITLE: Loading Config in Go\nDESCRIPTION: This line uses the `config.Load` function to populate the `Config` struct. This is an Encore-specific directive which will initialize the config values at application startup.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/types_from_multiple_packages.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nvar _ = config.Load[*Config]()\n```\n\n----------------------------------------\n\nTITLE: Defining Authentication Handler in Go\nDESCRIPTION: This function MyAuth takes a context and a token as parameters to return a user ID and an error. It integrates with the Encore's authentication features, enabling secure user identification within the application flow. Currently, it has a basic implementation that returns empty values for both UID and error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/auth_handler_simple.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"encore.dev/beta/auth\"\n)\n\n//encore:authhandler\nfunc MyAuth(ctx context.Context, token string) (auth.UID, error) { return \"\", nil }\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration for CsConfig in Go with Encore\nDESCRIPTION: The CsConfig type is defined here with a Foo field of type config.String. This snippet also utilizes the Encore configuration loading method to maintain structured data representation in service configurations. The comments indicate intent for deduplication and clarity.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/merge_identical_comments.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"encore.dev/config\"\n)\n\ntype CsConfig struct{\n\t// Multiline test\n\t// comment to deduplicate.\n\tFoo config.String\n}\n\nvar _ = config.Load[CsConfig]()\n```\n\n----------------------------------------\n\nTITLE: Defining helpers config package in Go\nDESCRIPTION: This snippet defines the `helpers` package and contains the `ExtraConfig` struct. The struct contains a `Foo` string configuration and a `Baz` value that is a byte array. It also defines `SingleUse` struct, which contains a `Lock` boolean value.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/types_from_multiple_packages.txt#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\npackage helpers\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n)\n\ntype ExtraConfig struct{\n    Foo config.String\n    Baz config.Value[[]byte]\n}\n\ntype SingleUse struct {\n    Lock bool\n}\n```\n\n----------------------------------------\n\nTITLE: Service-Level Global Middleware Implementation\nDESCRIPTION: Implements service-level middleware targeting all endpoints, passing through requests unmodified\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/middleware.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n//encore:middleware target=all\nfunc AllInSvc(req middleware.Request, next middleware.Next) middleware.Response {\n    return next(req)\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Vitest for Testing URL Shortener\nDESCRIPTION: Command to install the Vitest testing framework as a development dependency for the URL shortener project. Vitest is used for writing and running tests.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/rest-api.mdx#2025-04-21_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n$ npm i --save-dev vitest\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS S3 in Encore\nDESCRIPTION: Configuration for AWS S3 buckets with region specification and optional prefix settings.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_18\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"object_storage\": [\n    {\n      \"type\": \"s3\",\n      \"region\": \"us-east-1\",\n      \"buckets\": {\n        \"my-s3-bucket\": {\n          \"name\": \"my-s3-bucket\",\n          \"key_prefix\": \"my-optional-prefix/\",\n          \"public_base_url\": \"https://my-gcs-bucket-cdn.example.com/my-optional-prefix\"\n        }\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Availability with JSON Request\nDESCRIPTION: JSON request body example for setting custom availability for each day of the week, specifying start and end times for business hours.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"Availability\": [{\n        \"start\": \"09:30\",\n        \"end\": \"17:00\"\n    },{\n        \"start\": \"09:00\",\n        \"end\": \"17:00\"\n    },{\n        \"start\": \"09:00\",\n        \"end\": \"18:00\"\n    },{\n        \"start\": \"08:30\",\n        \"end\": \"18:00\"\n    },{\n        \"start\": \"09:00\",\n        \"end\": \"17:00\"\n    },{\n        \"start\": \"09:00\",\n        \"end\": \"17:00\"\n    },{\n        \"start\": \"09:30\",\n        \"end\": \"16:30\"\n    }]\n}\n```\n\n----------------------------------------\n\nTITLE: Structuring an Encore.go Project\nDESCRIPTION: This snippet demonstrates the typical directory structure for an Encore.go project with multiple services. It shows how services are organized as Go packages within the project.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/services.md#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n/my-app\n encore.app          // ... and other top-level project files\n\n hello               // hello service (a Go package)\n    hello.go        // hello service code\n    hello_test.go   // tests for hello service\n\n world               // world service (a Go package)\n     world.go        // world service code\n```\n\n----------------------------------------\n\nTITLE: Querying a Database in Encore\nDESCRIPTION: Demonstrates how to query data from a SQL database using Encore's sqldb package. The example uses QueryRow to fetch a single row and scan the results into a struct.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/code-snippets.md#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nimport \"encore.dev/storage/sqldb\"\n\nvar item struct {\n    ID int64\n    Title string\n    Done bool\n}\nerr := tododb.QueryRow(ctx, `\n    SELECT id, title, done\n    FROM todo_item\n    LIMIT 1\n`).Scan(&item.ID, &item.Title, &item.Done)\n```\n\n----------------------------------------\n\nTITLE: Emulating Switch Statements in CUE\nDESCRIPTION: Demonstrates how to create a switch-like conditional using array selection and environment-based conditions\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/config.md#2025-04-21_snippet_7\n\nLANGUAGE: cue\nCODE:\n```\nSendEmailsFrom: [\\n    if #Meta.Environment.Type == \"production\" { \"noreply@example.com\" },\\n    if #Meta.Environment.Name == \"staging\"    { \"staging@example.com\" },\\n    \"dev-system@example.dev\"\\n][0]\n```\n\n----------------------------------------\n\nTITLE: Database Connection and Querying with Express.js in TypeScript\nDESCRIPTION: This snippet demonstrates how to connect an Express.js app to a PostgreSQL database using pg-promise and Docker. It retrieves user data from the database and uses `express` for setting up API routes. Necessary dependencies include Express.js and pg-promise, and the database credentials are configured in a Docker Compose file. The input is a user ID and the output is a user object in JSON format.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/migration/express-migration.md#2025-04-21_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n-- db.ts --\\nimport express, {Request, Response} from \\\"express\\\";\\nimport pgPromise from \\\"pg-promise\\\";\\n\\nconst app: Express = express();\\n\\n// Connect to the DB with the credentials from docker-compose.yml\\nconst db = pgPromise()({\\n  host: \\\"localhost\\\",\\n  port: 5432,\\n  database: \\\"database\\\",\\n  user: \\\"user1\\\",\\n  password: \\\"user1@123\\\",\\n});\\n\\ninterface User {\\n  name: string;\\n  id: number;\\n}\\n\\n// Get one User from DB\\napp.get(\\\"/user/:id\\\", async (req: Request, res: Response) => {\\n  const user = await db.oneOrNone<User>(\\n    `\\n        SELECT *\\n        FROM users\\n        WHERE id = $1\\n    `,\\n    req.params.id,\\n  );\\n\\n  res.json({user});\\n});\n```\n\nLANGUAGE: yaml\nCODE:\n```\n-- docker-compose.yml --\\nversion: '3.8'\\n\\nservices:\\n  db:\\n    build:\\n      context: .\\n      dockerfile: Dockerfile.postgis  # Use custom Dockerfile\\n    restart: always\\n    environment:\\n      POSTGRES_USER: user1\\n      POSTGRES_PASSWORD: user1@123\\n      POSTGRES_DB: database\\n    healthcheck:\\n      # This command checks if the database is ready, right on the source db server\\n      test: [ \\\"CMD-SHELL\\\", \\\"pg_isready\\\" ]\\n      interval: 5s\\n      timeout: 5s\\n      retries: 5\\n    ports:\\n      - \\\"5432:5432\\\"\\n    volumes:\\n      - postgres_data_v:/var/lib/postgresql/data\\nvolumes:\\n  postgres_data_v:\n```\n\nLANGUAGE: dockerfile\nCODE:\n```\n-- Dockerfile.postgis --\\nFROM postgres:latest\\n\\n# Install PostGIS extension\\nRUN apt-get update \\\\\\n    && apt-get install -y postgis postgresql-12-postgis-3 \\\\\\n    && apt-get clean \\\\\\n    && rm -rf /var/lib/apt/lists/*\\n\\n# To execute some initial queries, we can write queries in init.sql\\nCOPY init.sql /docker-entrypoint-initdb.d/\\n\\n# Enable PostGIS extension\\nRUN echo \\\"CREATE EXTENSION IF NOT EXISTS postgis;\\\" >> /docker-entrypoint-initdb.d/init.sql\n```\n\n----------------------------------------\n\nTITLE: Installing Encore on Linux using curl\nDESCRIPTION: Command to install Encore on Linux systems using curl to download and execute the installation script.\nSOURCE: https://github.com/encoredev/encore/blob/main/README.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncurl -L https://encore.dev/install.sh | bash\n```\n\n----------------------------------------\n\nTITLE: Complex Cron Job with Additional Variable\nDESCRIPTION: Defines a cron job with an additional string variable assignment. Demonstrates multiple variable declaration in a single statement.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cron_job_definition.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nvar _, bd = cron.NewJob(\"cronfood\", cron.JobConfig{\n\tTitle:     \"Cron Food Bar\",\n\tSchedule: \"* * * * 5\",\n\tEndpoint: CronAPI,\n}), \"barfoo\"\n```\n\n----------------------------------------\n\nTITLE: Uploading Content using cURL to Signed URL\nDESCRIPTION: This bash snippet shows how to use cURL to upload data to the signed URL generated in the previous snippet. The command sends a binary file as a payload to the specified URL.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/object-storage.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncurl -X PUT --data-binary @/home/me/dog-wizard.jpeg \"https://storage.googleapis.com/profile-pictures/my-user-id/?x-goog-signature=b7a1<...>\"\n```\n\n----------------------------------------\n\nTITLE: Authentication Methods Configuration\nDESCRIPTION: Configuration for service-to-service authentication using API keys\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"auth\": [\n    {\n      \"type\": \"key\",\n      \"id\": 1,\n      \"key\": {\n        \"$env\": \"SERVICE_API_KEY\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining API Parameters in Encore Golang\nDESCRIPTION: Defines a Params struct used for extracting and handling headers in incoming HTTP requests. The 'Foo' function is decorated with Encore's special annotation to expose it as a public API endpoint. No external dependencies are required except those imported, and the function returns a Params pointer and an error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/response_headers.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage code\n\nimport \"context\"\n\ntype Params struct {\n    Foo   string `header:\"X-Foo\"`\n    Ignore string `header:\"-\"`\n}\n\n//encore:api public\nfunc Foo(ctx context.Context) (*Params, error) { return nil, nil }\n\n```\n\n----------------------------------------\n\nTITLE: Service Struct Registration in Encore Framework\nDESCRIPTION: Handles service registration and declaration for the Encore service, setting up necessary metadata and initialization hooks\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/authhandlergen/testdata/servicestruct.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nvar EncoreInternal_svcstruct_Service = &__service.Decl[Service]{\n\tName:        \"Service\",\n\tService:     \"code\",\n\tSetup:       nil,\n\tSetupDefLoc: uint32(0x0),\n}\n```\n\n----------------------------------------\n\nTITLE: AWS CloudWatch Configuration\nDESCRIPTION: Configuration for AWS CloudWatch metrics collection\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"metrics\": {\n    \"type\": \"aws_cloudwatch\",\n    \"collection_interval\": 60,\n    \"namespace\": \"MyAppMetrics\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Restarting Encore CLI Daemon\nDESCRIPTION: Restarts the Encore CLI daemon to resolve unexpected behavior.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\n$ encore daemon\n```\n\n----------------------------------------\n\nTITLE: Creating a TypeScript Encore app\nDESCRIPTION: Command to create a new Encore application using the TypeScript introduction example.\nSOURCE: https://github.com/encoredev/encore/blob/main/README.md#2025-04-21_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nencore app create --example=ts/introduction\n```\n\n----------------------------------------\n\nTITLE: Defining Go Module\nDESCRIPTION: This snippet defines a Go module named \"example.com\". It is used for dependency management and versioning in the Go project.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/compiler/build/testdata/overlay.txt#2025-04-21_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nmodule example.com\n```\n\n----------------------------------------\n\nTITLE: Defining Tagged API Endpoint in Encore - Go\nDESCRIPTION: This snippet defines a simple tagged API endpoint in Go using the Encore framework. The `Tagged` function serves as a public API method, returning nil upon invocation. The context is provided as a parameter for compatibility with other services.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/endpoint_tags.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public tag:foo tag:bar\nfunc Tagged(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Defining Generic List and Map Types in Go\nDESCRIPTION: The code defines a generic List type that can hold elements of any type and a Map type for key-value pairs. These definitions allow for flexible, type-safe collections in Go applications.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/generic_named_types.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype List[T any] []T\n\ntype Map[K any, V any] map[K]V\n```\n\n----------------------------------------\n\nTITLE: Implementing Clerk Authentication Service in Encore\nDESCRIPTION: Shows how to initialize a Clerk authentication service by creating a client with the secret key. This forms the foundation for handling authentication in an Encore application.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_38\n\nLANGUAGE: go\nCODE:\n```\ntype Service struct {\n    client clerk.Client\n}\n\nfunc initService() (*Service, error) {\n    client, err := clerk.NewClient(secrets.ClientSecretKey)\n    if err != nil {\n        return nil, err\n    }\n    return &Service{client: client}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Stopping VPN Connection with Encore CLI\nDESCRIPTION: Command to terminate an active VPN connection to Encore environments.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_51\n\nLANGUAGE: bash\nCODE:\n```\nencore vpn stop\n```\n\n----------------------------------------\n\nTITLE: Generated Encore Service Call Wrappers in Go\nDESCRIPTION: These are automatically generated functions by Encore to facilitate easy calling between services. They wrap service method implementations, ensuring that changes to API endpoints reflect appropriately across services. This snippet contains the `Foo` method's generated call logic.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/api_call_servicestruct.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\n// Code generated by encore. DO NOT EDIT.\n\npackage svca\n\nimport \"context\"\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\n\nfunc Foo(ctx context.Context) error {\n\tsvc, err := EncoreInternal_svcstruct_Service.Get()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn svc.Foo(ctx)\n}\n\n// Interface defines the service\\'s API surface area, primarily for mocking purposes.\n//\n// Raw endpoints are currently excluded from this interface, as Encore does not yet\n// support service-to-service API calls to raw endpoints.\ntype Interface interface {\n\tFoo(ctx context.Context) error\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Public Endpoint Bar Returning Struct\nDESCRIPTION: Public API method returning a custom struct pointer and an error. Uses Encore's public API annotation for endpoint definition\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/struct_duplicate_json_ignore.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public\nfunc Bar(ctx context.Context) (*SomeStruct, error) {\n    return nil, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Telemetry via CLI Command\nDESCRIPTION: Command line instruction for disabling Encore telemetry using the CLI tool.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/telemetry.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nencore telemetry disable\n```\n\n----------------------------------------\n\nTITLE: Package Configuration for Encore Project\nDESCRIPTION: NPM package configuration specifying project name, module type, and Encore framework dependency version requirement.\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/tests/testdata/mapped_types.txt#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"foo\",\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"encore.dev\": \"^1.35.0\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a GraphQL API with Apollo Server\nDESCRIPTION: This snippet sets up a GraphQL API endpoint using Apollo Server integrated with Encore.js. It handles requests and responses, including query execution and response headers management.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HeaderMap } from \"@apollo/server\";\nimport { api } from \"encore.dev/api\";\nconst { ApolloServer, gql } = require(\"apollo-server\");\nimport { json } from \"node:stream/consumers\";\n\nconst server = new ApolloServer({ typeDefs, resolvers });\nawait server.start();\n\nexport const graphqlAPI = api.raw(\n  { expose: true, path: \"/graphql\", method: \"*\" },\n  async (req, res) => {\n    server.assertStarted(\"/graphql\");\n    \n    const headers = new HeaderMap();\n    for (const [key, value] of Object.entries(req.headers)) {\n      if (value !== undefined) {\n        headers.set(key, Array.isArray(value) ? value.join(\", \") : value);\n      }\n    }\n\n    const httpGraphQLResponse = await server.executeHTTPGraphQLRequest({\n      httpGraphQLRequest: {\n        headers,\n        method: req.method!.toUpperCase(),\n        body: await json(req),\n        search: new URLSearchParams(req.url ?? \"\").toString(),\n      },\n      context: async () => ({ req, res }),\n    });\n\n    // Set response headers and status\n    for (const [key, value] of httpGraphQLResponse.headers) {\n      res.setHeader(key, value);\n    }\n    res.statusCode = httpGraphQLResponse.status || 200;\n\n    // Write response\n    if (httpGraphQLResponse.body.kind === \"complete\") {\n      res.end(httpGraphQLResponse.body.string);\n      return;\n    }\n    \n    for await (const chunk of httpGraphQLResponse.body.asyncIterator) {\n      res.write(chunk);\n    }\n    res.end();\n  }\n);\n\n```\n\n----------------------------------------\n\nTITLE: Defining the URL Shortener Service in Go\nDESCRIPTION: This snippet sets up the Go package 'url' for a URL shortener service. It includes a REST API endpoint to shorten URLs, using a POST method with the 'encore:api' annotation. The service provides functionalities to generate a random short ID for a URL, store it in a struct, and manage errors.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/rest-api.mdx#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// Service url takes URLs, generates random short IDs, and stores the URLs in a database.\npackage url\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n)\n\ntype URL struct {\n\tID  string // short-form URL id\n\tURL string // complete URL, in long form\n}\n\ntype ShortenParams struct {\n\tURL string // the URL to shorten\n}\n\n// Shorten shortens a URL.\n//encore:api public method=POST path=/url\nfunc Shorten(ctx context.Context, p *ShortenParams) (*URL, error) {\n\tid, err := generateID()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &URL{ID: id, URL: p.URL}, nil\n}\n\n// generateID generates a random short ID.\nfunc generateID() (string, error) {\n\tvar data [6]byte // 6 bytes of entropy\n\tif _, err := rand.Read(data[:]); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn base64.RawURLEncoding.EncodeToString(data[:]), nil\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Telemetry via Environment Variable\nDESCRIPTION: Shell command for disabling Encore telemetry by setting an environment variable.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/telemetry.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nexport DISABLE_ENCORE_TELEMETRY=1\n```\n\n----------------------------------------\n\nTITLE: Serving Inline HTML with EJS in Encore.ts\nDESCRIPTION: This snippet illustrates how to serve inline HTML rendered with EJS. It defines a string containing the HTML markup with EJS template placeholders. The `ejs.render` function is then used to render this inline HTML with data provided.  The content type header is set to `text/html` before sending the rendered HTML as a response.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/frontend/template-engine.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\nimport ejs, { Options } from \"ejs\";\n\nconst inlineHTML = `\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <link rel=\"stylesheet\" href=\"/public/styles.css\" >\n  </head>\n  <body>\n    <h1>Static Inline HTML Example</h1>\n    <h1>Name: <%= name %>!</h1>\n  </body>\n</html>\n`;\n\nexport const serveInlineHTML = api.raw(\n  { expose: true, path: \"/html\", method: \"GET\" },\n  async (req, resp) => {\n    const html = ejs.render(inlineHTML, { name: \"Simon\" });\n    resp.setHeader(\"Content-Type\", \"text/html\");\n    resp.end(html);\n  },\n);\n\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Key Structure for Cache in Go\nDESCRIPTION: Defines a generic Key struct that can store any type T. This struct is used as the keyspace's value type in the caching system.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cache_cluster_outside_svc.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype Key[T any] struct {\n    Foo T\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Code for Raw Endpoint Call (Unsupported)\nDESCRIPTION: This snippet shows the generated code for calling the `Bar` endpoint from another service.  It currently returns an error indicating that calling raw endpoints is not yet supported. It also defines the `Interface` interface, which excludes raw endpoints, reflecting this limitation.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/raw_endpoint.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// Code generated by encore. DO NOT EDIT.\n\npackage code\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n)\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\n\nfunc Bar(ctx context.Context, req *http.Request) (*http.Response, error) {\n\treturn nil, errors.New(\"encore: calling raw endpoints is not yet supported\")\n}\n\n// Interface defines the service's API surface area, primarily for mocking purposes.\n//\n// Raw endpoints are currently excluded from this interface, as Encore does not yet\n// support service-to-service API calls to raw endpoints.\ntype Interface interface{}\n```\n\n----------------------------------------\n\nTITLE: GCP Cloud Monitoring Configuration\nDESCRIPTION: Configuration for Google Cloud Monitoring metrics including resource types and labels\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"metrics\": {\n    \"type\": \"gcp_cloud_monitoring\",\n    \"collection_interval\": 60,\n    \"project_id\": \"my-gcp-project\",\n    \"monitored_resource_type\": \"gce_instance\",\n    \"monitored_resource_labels\": {\n      \"instance_id\": \"1234567890\",\n      \"zone\": \"us-central1-a\"\n    },\n    \"metric_names\": {\n      \"cpu_usage\": \"compute.googleapis.com/instance/cpu/usage_time\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Duplicate Encore Service Struct in Go (Erroneous)\nDESCRIPTION: Defines a second Encore service struct named Duplicate in the same package, also annotated with //encore:service. This violates Encore's restriction of one service struct per package and causes a build error indicating duplicate encore:service directives. Demonstrates how Encore enforces service struct uniqueness.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/servicestruct_duplicate.txt#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n//encore:service\ntype Duplicate struct {}\n\n```\n\n----------------------------------------\n\nTITLE: Updating Encore CLI\nDESCRIPTION: Checks for an update of Encore and runs the appropriate command to update if available.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_26\n\nLANGUAGE: shell\nCODE:\n```\n$ encore version update\n```\n\n----------------------------------------\n\nTITLE: Installing Txtar Package via Cargo\nDESCRIPTION: Command to add the txtar crate as a dependency to a Rust project using cargo.\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/txtar/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo add txtar\n```\n\n----------------------------------------\n\nTITLE: Initializing Bar Service Endpoint\nDESCRIPTION: Defines a simple Encore API endpoint for the Bar service with a context-based method that returns an error\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/multiple_services.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc Bar(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Incorrect Auth Handler Reference in Another Package\nDESCRIPTION: Demonstrates incorrect usage of an auth handler by directly referencing it from another package. In Encore, auth handlers can only be called but not referenced as values, which causes a compilation error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/auth_handler_reference.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc2\n\nimport (\n    \"context\"\n    \"test/svc\"\n)\n\nfunc Foo() {\n    _ = svc.MyAuth\n}\n```\n\n----------------------------------------\n\nTITLE: Project Directory Structure\nDESCRIPTION: Shows the filesystem layout after splitting the monolith into two services, demonstrating the proper organization of microservices in an Encore project.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/break-up-monolith.md#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n/my-app\n encore.app        // ... and other top-level project files\n\n hello             // hello service (a Go package)\n    hello.go      // hello service code\n\n yo                // yo service (a Go package)\n     yo.go         // yo service code\n```\n\n----------------------------------------\n\nTITLE: SQL Database Definition and API Endpoint\nDESCRIPTION: This snippet defines a database connection named 'unknown-db' using `sqldb.Named` without proper initialization using `sqldb.NewDatabase`. It also defines a public API endpoint `Foo` that currently does nothing. The missing database initialization results in a validation error during Encore's parsing phase.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_err_unknown_db.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/storage/sqldb\"\n)\n\nvar Moo = sqldb.Named(\"unknown-db\")\n\n//encore:api public\nfunc Foo(ctx context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Archiving Encore Secrets\nDESCRIPTION: Archives a secret value in Encore.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_23\n\nLANGUAGE: shell\nCODE:\n```\n$ encore secret archive <id>\n```\n\n----------------------------------------\n\nTITLE: Getting Previous Measurement (TypeScript)\nDESCRIPTION: This code defines a function `getPreviousMeasurement` to retrieve the last known up/down state of a given site from the database. It queries the `checks` table, orders the results by `checked_at` in descending order, and limits the result to 1 row to get the most recent check. It returns the `up` value from the query or defaults to `true` if no previous measurement exists.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n// getPreviousMeasurement reports whether the given site was\n// up or down in the previous measurement.\nasync function getPreviousMeasurement(siteID: number): Promise<boolean> {\n  const row = await MonitorDB.queryRow`\n      SELECT up\n      FROM checks\n      WHERE site_id = ${siteID}\n      ORDER BY checked_at DESC\n      LIMIT 1\n  `;\n  return row?.up ?? true;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Path Parameters in Raw HTTP Endpoints with Encore\nDESCRIPTION: Shows how to access path parameters in raw HTTP endpoints using Encore's CurrentRequest function. This allows you to extract dynamic values from the request URL path for processing in your webhook handler.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/http-requests.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage service  \n  \nimport (  \n   \"net/http\"  \n   \n   \"encore.dev\"\n )\n\n//encore:api public raw method=POST path=/webhook/:id\nfunc Webhook(w http.ResponseWriter, req *http.Request) {  \n    id := encore.CurrentRequest().PathParams.Get(\"id\")\n\t// ... Do something with id\n }\n```\n\n----------------------------------------\n\nTITLE: Creating Temporary Test Database in Go\nDESCRIPTION: Using Encore's et package to create an isolated, freshly migrated database for a specific test, ensuring test independence\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/testing.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\net.NewTestDatabase()\n```\n\n----------------------------------------\n\nTITLE: Defining Secrets Struct in Go\nDESCRIPTION: This snippet defines a struct named `secrets` with a string field `Foo`. This struct is intended to hold sensitive information used by the service.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/parser/resource/usage/testdata/secret_usage.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nvar secrets struct {\n    Foo string\n}\n```\n\n----------------------------------------\n\nTITLE: Encore Internal Service Struct Registration in Go\nDESCRIPTION: This code shows the generated internal service struct registration for the `Service` defined in the `code` package.  It uses the `encore.dev/appruntime/apisdk/service` package to register the service with the Encore runtime. The generated `EncoreInternal_svcstruct_Service` variable holds metadata about the service and includes setup functions.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/middlewaregen/testdata/service_struct.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport __service \"encore.dev/appruntime/apisdk/service\"\n\nfunc init() {\n\t__service.Register(EncoreInternal_svcstruct_Service)\n}\n\nvar EncoreInternal_svcstruct_Service = &__service.Decl[Service]{\n\tName:        \"Service\",\n\tService:     \"code\",\n\tSetup:       nil,\n\tSetupDefLoc: uint32(0x0),\n}\n```\n\n----------------------------------------\n\nTITLE: Generated API Functions Structure - Go\nDESCRIPTION: This snippet indicates that the functions within this package are auto-generated by Encore to facilitate service integration. It includes a note highlighting that these functions should not be manually edited as they'll be updated automatically when API endpoints change.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/subscription.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n// Code generated by encore. DO NOT EDIT.\n\npackage code\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\n```\n\n----------------------------------------\n\nTITLE: Setting Clerk Production Secret in Encore\nDESCRIPTION: Command to set the Clerk secret key for production environment in Encore\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/clerk-auth.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ encore secret set --prod ClientSecretKey\n```\n\n----------------------------------------\n\nTITLE: Calling Database Method from Package\nDESCRIPTION: In this code snippet, a function named 'Foo' within the 'pkg' package is attempting to call a method 'Baz' on the 'Moo' resource from 'myservice'. It showcases the interaction between packages and the use of the Moose resource for database operations, although it does not specify the return or error handling of the call.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_success.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc Foo() {\n    _ = myservice.Moo.Baz()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple API in Go with Encore\nDESCRIPTION: Implements a basic API function named 'MyAPI', marked with the 'encore:api' directive, which returns an error type. This function does not perform any action and always returns 'nil'. It exemplifies the use of Encore's API service structure.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_named_struct_multiple_uses.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n\n```\n\n----------------------------------------\n\nTITLE: Testing PubSub Message Publication\nDESCRIPTION: Helper method for accessing and verifying published messages during testing, supporting test isolation and deterministic message tracking\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_18\n\nLANGUAGE: Go\nCODE:\n```\nmsgs := et.Topic(Signups).PublishedMessages()\nassert.Len(t, msgs, 1)\n```\n\n----------------------------------------\n\nTITLE: Handling API Request and Response in Go\nDESCRIPTION: This code defines a structure and methods to process requests and responses for the Foo endpoint, including initialization, decoding, and encoding logic. This facilitates communication between the server and clients using JSON.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/unexported.txt#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ntype EncoreInternal_FooReq struct{}\n\ntype EncoreInternal_FooResp = *Response\n\nvar EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{\n    Access: __api.Public,\n    AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {\n        resp, err := Foo(ctx)\n        if err != nil {\n            return (*Response)(nil), err\n        }\n        return resp, nil\n    },\n    // Additional methods here...\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Encore API Endpoint\nDESCRIPTION: Defines a minimal API endpoint using Encore's API annotation, returning an error\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_maps.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Encore Service Registration\nDESCRIPTION: This code snippet registers the `Service` with the Encore service registry.  It declares the service's name and setup function (which is nil in this case).  The `EncoreInternal_svcstruct_Service` variable holds metadata about the service.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/raw_endpoint.txt#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport __service \"encore.dev/appruntime/apisdk/service\"\n\nfunc init() {\n\t__service.Register(EncoreInternal_svcstruct_Service)\n}\n\nvar EncoreInternal_svcstruct_Service = &__service.Decl[Service]{\n\tName:        \"Service\",\n\tService:     \"code\",\n\tSetup:       nil,\n\tSetupDefLoc: uint32(0x0),\n}\n```\n\n----------------------------------------\n\nTITLE: Building Encore CLI\nDESCRIPTION: This command builds the `encore` CLI from source code. It compiles the `encore` command located in `cli/cmd/encore` and installs the `git-remote-encore` command.  This is a fundamental step in creating an executable version of the Encore CLI from the project's source code.  The built binaries are then ready for execution. The command does not accept any input.\nSOURCE: https://github.com/encoredev/encore/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\ngo build ./cli/cmd/encore\n```\n\nLANGUAGE: Go\nCODE:\n```\ngo install ./cli/cmd/git-remote-encore\n```\n\n----------------------------------------\n\nTITLE: Defining a GET API Endpoint with Encore.ts\nDESCRIPTION: This snippet defines a GET API endpoint using Encore.ts. It utilizes the `api` function from the `encore.dev/api` module to wrap an asynchronous TypeScript function.  The endpoint is exposed with `expose: true`, uses the GET method, and is accessible at the path `/hello/:name`. The function takes a `name` parameter of type string, constructs a greeting message, and returns a response containing the message.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/concepts/hello-world.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\n\nexport const get = api(\n  { expose: true, method: \"GET\", path: \"/hello/:name\" },\n  async ({ name }: { name: string }): Promise<Response> => {\n    const msg = `Hello ${name}!`;\n    return { message: msg };\n  }\n);\n\ninterface Response {\n  message: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Environment Metadata Configuration in JSON\nDESCRIPTION: Configuration for basic environment metadata including app ID, environment name, type, cloud provider, and base URL.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"metadata\": {\n    \"app_id\": \"my-encore-app\",\n    \"env_name\": \"production\",\n    \"env_type\": \"production\",\n    \"cloud\": \"aws\",\n    \"base_url\": \"https://api.myencoreapp.com\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Redis Connection in Encore\nDESCRIPTION: JSON configuration for Redis connection settings including host, authentication, and connection pool parameters. Defines connection details with environment variable support for authentication.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"redis\": {\n    \"my-redis\": {\n      \"host\": \"redis.myencoreapp.com:6379\",\n      \"database_index\": 0,\n      \"auth\": {\n        \"type\": \"auth\",\n        \"auth_string\": {\n          \"$env\": \"REDIS_AUTH_STRING\"\n        }\n      },\n      \"max_connections\": 50,\n      \"min_connections\": 5\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Service Method with Injected Dependency\nDESCRIPTION: Shows how to implement an API endpoint as a method on the service struct using the injected dependency. Uses the encore:api directive to define a private API endpoint.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/dependency-injection.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:api private\nfunc (s *Service) Send(ctx context.Context, p *SendParams) error {\n\t// ... use s.sendgridClient to send emails ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring GCP Pub/Sub in Encore\nDESCRIPTION: Configuration for Google Cloud Pub/Sub including topic and subscription settings with push configuration support.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"pubsub\": [\n    {\n      \"type\": \"gcp_pubsub\",\n      \"project_id\": \"my-gcp-project\",\n      \"topics\": {\n        \"my-topic\": {\n          \"name\": \"my-topic\",\n          \"project_id\": \"my-gcp-project\",\n          \"subscriptions\": {\n            \"my-subscription\": {\n              \"name\": \"my-subscription\",\n              \"push_config\": {\n                \"id\": \"my-push\",\n                \"service_account\": \"service-account@my-gcp-project.iam.gserviceaccount.com\"\n              }\n            }\n          }\n        }\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Slack Service Directory and File in Shell\nDESCRIPTION: This snippet demonstrates creating a directory and file for the new Slack service, which will house the code for integrating Slack notifications into the Encore application. The directory and file setup is crucial for organizing the Slack service code to follow.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_23\n\nLANGUAGE: shell\nCODE:\n```\n$ mkdir slack # Create a new directory in the application root\n$ touch slack/encore.service.ts\n```\n\n----------------------------------------\n\nTITLE: Serving Static Files with Encore.ts\nDESCRIPTION: This snippet demonstrates how to serve static files using `api.static`. It configures the endpoint to expose files from the `./assets` directory under the `/public` path prefix. This allows serving assets like CSS, JavaScript, and images.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/frontend/template-engine.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Serve all files in the ./assets directory under the /public path prefix.\nexport const assets = api.static({\n  expose: true,\n  path: \"/public/*path\",\n  dir: \"./assets\",\n});\n\n```\n\n----------------------------------------\n\nTITLE: GitHub Icon SVG Component\nDESCRIPTION: SVG markup for GitHub logo icon used in the community page navigation\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/community/get-involved.md#2025-04-21_snippet_0\n\nLANGUAGE: svg\nCODE:\n```\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"#111111\" stroke=\"none\"><path fillRule=\"evenodd\" d=\"M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z\" /></svg>\n```\n\n----------------------------------------\n\nTITLE: Declaring the Encore Terraform Provider\nDESCRIPTION: This snippet shows how to declare the Encore Terraform Provider in the `required_providers` of a Terraform configuration file to facilitate the integration of Encore-provisioned resources with existing infrastructure. Ensure to replace `your-env` and `your-auth-key` with your actual environment name and auth key.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/integrations/terraform.md#2025-04-21_snippet_0\n\nLANGUAGE: HCL\nCODE:\n```\nterraform {\n  required_providers {\n    encore = {\n      source = \"registry.terraform.io/encoredev/encore\"\n    }\n  }\n}\n\n```\n\nLANGUAGE: HCL\nCODE:\n```\nprovider \"encore\" {\n    env = \"your-env\"\n    auth_key = \"your-auth-key\"\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating a TypeScript Client with Encore CLI\nDESCRIPTION: This command generates a TypeScript client for the `hello-a8bc` application based on the primary environment. The client is saved to the `client.ts` file.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/client-generation.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n\"encore gen client hello-a8bc --output=./client.ts\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Bun Runtime Experiment in Encore.ts\nDESCRIPTION: Configuration to enable experimental Bun runtime support in Encore application configuration file\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/faq.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"experiments\": [\"bun-runtime\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Running Docker Image with Custom Port - Bash\nDESCRIPTION: This snippet shows how to run the built Docker image, customizing the port it listens on. The command sets the environment variable PORT to define which port the application should use.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/build.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -e PORT=8081 -p 8081:8081 MY-IMAGE:TAG\n```\n\n----------------------------------------\n\nTITLE: Creating Monitor Service Directory and File\nDESCRIPTION: Shell commands to create a directory for the monitor service and an empty ping.go file.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/uptime.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ mkdir monitor\n$ touch monitor/ping.go\n```\n\n----------------------------------------\n\nTITLE: Implementing Public API Function in Go\nDESCRIPTION: This code snippet demonstrates the implementation of a public API function within the Encore service framework. The Str function is a method of SomeOtherType and takes a context and parameters, returning an error. It highlights a restriction whereby API endpoints must be defined on a service struct.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_receiver_invalid.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public\nfunc (s *SomeOtherType) Str(ctx context.Context, p *Params) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for Large Application with Multiple Systems\nDESCRIPTION: Illustrates how to organize a large Encore application with multiple logical systems. The example shows a Trello clone with three systems: trello, premium, and usr, each containing multiple services.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/app-structure.md#2025-04-21_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n/my-trello-clone\n encore.app                  // ... and other top-level project files\n\n trello                      // trello system (a directory)\n    board                   // board service (a Go package)\n       board.go            // board service code\n    card                    // card service (a Go package)\n        card.go             // card service code\n\n premium                     // premium system (a directory)\n    payment                 // payment service (a Go package)\n       payment.go          // payment service code\n    subscription            // subscription service (a Go package)\n        subscription.go     // subscription service code\n\n usr                         // usr system (a directory)\n     org                     // org service (a Go package)\n        org.go              // org service code\n     user                    // user service (a Go package)\n         user.go             // user service code\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration in Encore Service\nDESCRIPTION: Uses Encore's config.Load generic function to load configuration with a custom unmarshaler\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_maps.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nvar _ = config.Load[*Config](\"svc\", encoreInternalConfigUnmarshaler_ptr_svc_Config)\n```\n\n----------------------------------------\n\nTITLE: Synthetic Static Configuration in Go\nDESCRIPTION: This synthetic Go file describes the generated static configuration for the Encore application. It includes information such as the Encore compiler version, application commit details, CORS settings, Pubsub topics, testing flags, and bundled services.  This configuration is used to define the application's behavior and environment settings.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/auth_handler.txt#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\npackage synthetic\n\n/*\n\nThis is a synthetic file describing the generated static config:\n\n{\n\t\"EncoreCompiler\": \"\",\n\t\"AppCommit\": {\n\t\t\"revision\": \"\",\n\t\t\"uncommitted\": false\n\t},\n\t\"CORSAllowHeaders\": null,\n\t\"CORSExposeHeaders\": null,\n\t\"PubsubTopics\": {},\n\t\"Testing\": false,\n\t\"TestServiceMap\": {\n\t\t\"code\": \"testing_path:code\"\n\t},\n\t\"TestAppRootPath\": \"testing_path:main\",\n\t\"PrettyPrintLogs\": false,\n\t\"BundledServices\": [\n\t\t\"code\"\n\t],\n\t\"EmbeddedEnvs\": {}\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Automating Migration Generation with Bash Script\nDESCRIPTION: This Bash script automates the process of generating database migrations using Atlas. It resets the shadow database, sets the `ENCORERUNTIME_NOPANIC` environment variable, and runs the `atlas migrate diff` command to generate a migration based on the current GORM schema.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/atlas-gorm.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n\"#!/bin/bash\nset -eu\nDB_NAME=blog\nMIGRATION_NAME=${1:-}\n\nSCRIPT_DIR=$( cd -- \\\"$( dirname -- \\\"${BASH_SOURCE[0]}\\\" )\\\" &> /dev/null && pwd )\n\n# Reset the shadow database\nencore db reset --shadow $DB_NAME\n\n# GORM executes Go code without initializing Encore when generating migrations,\n# so configure the Encore runtime to be aware that this is expected.\nexport ENCORERUNTIME_NOPANIC=1\n\n# Generate the migration\natlas migrate diff $MIGRATION_NAME --env local --dev-url \\\"$(encore db conn-uri --shadow $DB_NAME)&search_path=public\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Executing cURL Command to Create Schedules\nDESCRIPTION: This Bash snippet demonstrates how to use cURL to create a new schedule via a POST request. It requires a running local server (Encore) on port 4000, and expects input JSON containing the schedule start and end times.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/incident-management-tool.md#2025-04-21_snippet_7\n\nLANGUAGE: Bash\nCODE:\n```\ncurl -d '{\n  \"Start\":\"2023-11-28T10:00:00Z\",\n  \"End\":\"2023-11-30T10:00:00Z\"\n}' \"http://localhost:4000/users/1/schedules\"\n\n# Example JSON response\n# {\n#   \"Id\":1,\n#   \"User\":{\n#     \"Id\":1,\n#     \"FirstName\":\"Katy\",\n#     \"LastName\":\"Smith\",\n#     \"SlackHandle\":\"katy\"\n#   },\n#   \"Time\":{\n#     \"Start\":\"2023-11-28T10:00:00Z\",\n#     \"End\":\"2023-11-30T10:00:00Z\"\n#   }\n# }\n```\n\n----------------------------------------\n\nTITLE: Interval-Based Cron Job\nDESCRIPTION: Creates a cron job using interval-based scheduling (Every) instead of fixed schedule pattern, running every 3 minutes.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cron_job_definition.txt#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nvar _ = cron.NewJob(\"cron-every\", cron.JobConfig{\n\tTitle:     \"Cron Foo Bar Bazz\",\n\tEvery:    3 * cron.Minute,\n\tEndpoint: CronAPI,\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Package Dependencies for Encore Project\nDESCRIPTION: This package.json file specifies the project type as a module and lists the encore.dev dependency with its version.\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/tests/testdata/tsconfig.txt#2025-04-21_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"encore.dev\": \"^1.35.0\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Raw HTTP Endpoint with Path Parameters in Go\nDESCRIPTION: Shows how to implement a raw HTTP endpoint that extracts path parameters using encore.CurrentRequest(). Demonstrates URL path parameter handling.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_47\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public raw method=POST path=/webhook/:id\nfunc Webhook(w http.ResponseWriter, req *http.Request) {\n    id := encore.CurrentRequest().PathParams.Get(\"id\")\n    // Process with id\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Migration Generation Script for Atlas and Encore in Shell\nDESCRIPTION: Bash script to generate migrations using Atlas, leveraging Encore's shadow database feature.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/entgo-orm.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n#!/bin/bash\nset -eu\nDB_NAME=user\nMIGRATION_NAME=${1:-}\n\n# Reset the shadow database\nencore db reset --shadow $DB_NAME\n\n# ent executes Go code without initializing Encore when generating migrations,\n# so configure the Encore runtime to be aware that this is expected.\nexport ENCORERUNTIME_NOPANIC=1\n\n# Generate the migration\natlas migrate diff $MIGRATION_NAME --env local --dev-url \"$(encore db conn-uri --shadow $DB_NAME)&search_path=public\"\n```\n\n----------------------------------------\n\nTITLE: Defining Slack Service in Encore using TypeScript\nDESCRIPTION: This snippet defines a new Slack service using Encore's service module. The Service class from the Encore framework is used to instantiate a new service named 'slack', laying the foundation for integrating Slack functionality.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_24\n\nLANGUAGE: ts\nCODE:\n```\nimport { Service } from \"encore.dev/service\";\n\nexport default new Service(\"slack\");\n```\n\n----------------------------------------\n\nTITLE: Generating a Go Client with Encore CLI\nDESCRIPTION: This command generates a Go client for the `hello-a8bc` application based on the locally running code. The client is saved to the `client.go` file and uses the `local` environment.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/client-generation.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n\"encore gen client hello-a8bc --output=./client.go --env=local\"\n```\n\n----------------------------------------\n\nTITLE: Updating Encore Version\nDESCRIPTION: The `encore version update` command checks for a new version of Encore and updates it if available.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_27\n\nLANGUAGE: shell\nCODE:\n```\n$ encore version update\n```\n\n----------------------------------------\n\nTITLE: Configuring Logto Authentication in CUE\nDESCRIPTION: Create a configuration file for Logto authentication settings using CUE. This file includes the issuer URL, JWKS URI, API resource indicator, and client ID.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/logto-auth.md#2025-04-21_snippet_2\n\nLANGUAGE: cue\nCODE:\n```\nIssuer: \"<your-logto-issuer-url>\"\nJwksUri: \"<your-logto-issuer-url>/jwks\"\nApiResourceIndicator: \"<your-api-resource-indicator>\"\nClientId: \"<your-client-id>\"\n```\n\n----------------------------------------\n\nTITLE: Defining an API Endpoint with Encore - Go\nDESCRIPTION: This code snippet shows the setup of a public API endpoint using Encore in Go. It includes a 'func Str' function with the incorrect usage of a struct type for the path parameter. The correct types for path parameters should be string, bool, integer, or UUID. The snippet serves as a demonstration of the appropriate usage pattern for function signatures in Encore APIs.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_invalid_path_param_type.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\t\"encore.dev/types/uuid\"\n)\n\ntype Struct struct{}\n\n//encore:api public path=/str/:p\nfunc Str(ctx context.Context, p *Struct) error { return nil }\n\n```\n\n----------------------------------------\n\nTITLE: Defining Cache Cluster in Go\nDESCRIPTION: Creates a new cache cluster using Encore's cache package with default configuration\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cache_err_keyspace_invalid.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nvar cluster = cache.NewCluster(\"cluster\", cache.ClusterConfig{})\n```\n\n----------------------------------------\n\nTITLE: Testing Auth Info Propagation to API Calls in Go\nDESCRIPTION: Tests that authentication information correctly propagates to API calls, verifying both default and overridden auth states.\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/et_override_user.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc TestOverrideAuthInfo_PropagatesToAPICalls(t *testing.T) {\n    resp, err := GetUser(context.Background())\n    if err != nil {\n        t.Fatal(err)\n    } else if resp.UserID != \"\" {\n        t.Fatalf(\"got uid %q, want %q\", resp.UserID, \"\")\n    }\n\n    et.OverrideAuthInfo(\"foo\", nil)\n\n    resp, err = GetUser(context.Background())\n    if err != nil {\n        t.Fatal(err)\n    } else if resp.UserID != \"foo\" {\n        t.Fatalf(\"got uid %q, want %q\", resp.UserID, \"foo\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Installed Encore Version\nDESCRIPTION: This snippet checks the installed version of Encore CLI using the `encore version` command. It outputs the current version, like `v1.28.0`. This is useful for verifying the current state of Encore CLI on your system.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/install.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nencore version\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Public Encore API Endpoint\nDESCRIPTION: This snippet defines a public Encore API endpoint called `Foo` that takes a context and a pointer to a `Recursive` struct as input and returns a pointer to a `Recursive` struct and an error. The `//encore:api public` comment is an Encore directive that exposes this function as a public API.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/recursive.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n//encore:api public\nfunc Foo(ctx context.Context, p *Recursive) (*Recursive, error) { return p, nil }\n```\n\n----------------------------------------\n\nTITLE: Defining Metric Counters in Go\nDESCRIPTION: This snippet defines two metric counters: a basic counter and a counter with labels. It uses Encore's metrics package to create these counters.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/metrics_counter.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\nvar Counter = metrics.NewCounter[uint64](\"counter\", metrics.CounterConfig{})\n\ntype Labels struct {\n\tLabel string // Label doc string.\n}\n\nvar CounterWithLabels = metrics.NewCounterGroup[Labels, uint64](\"counter_with_labels\", metrics.CounterConfig{})\n```\n\n----------------------------------------\n\nTITLE: Publishing Pub/Sub Message on State Change (TypeScript)\nDESCRIPTION: This code modifies the `doCheck` function to publish a message on the `TransitionTopic` if the site's up/down state changes compared to the previous measurement.  It retrieves the previous state using `getPreviousMeasurement`, compares it to the current state, and publishes a `TransitionEvent` message if they differ.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nasync function doCheck(site: Site): Promise<{ up: boolean }> {\n  const { up } = await ping({ url: site.url });\n\n  // Publish a Pub/Sub message if the site transitions\n  // from up->down or from down->up.\n  const wasUp = await getPreviousMeasurement(site.id);\n  if (up !== wasUp) {\n    await TransitionTopic.publish({ site, up });\n  }\n\n  await MonitorDB.exec`\n      INSERT INTO checks (site_id, up, checked_at)\n      VALUES (${site.id}, ${up}, NOW())\n  `;\n  return { up };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Encore Application from Template\nDESCRIPTION: Shell command to create a new Encore application using a template from the example-app-uptime repository.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ encore app create uptime --example=github.com/encoredev/example-app-uptime/tree/starting-point-ts\n```\n\n----------------------------------------\n\nTITLE: Preparing Payload to Sign in Go\nDESCRIPTION: This snippet demonstrates how to prepare the payload to be signed for manual webhook signature verification.  It concatenates the timestamp and the raw request body, separated by a dot (\".\"), creating a string that represents the data used for signature generation.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/integrations/webhooks.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n```go\npayloadToSign := timestamp + \".\" + string(payload)\n```\n```\n\n----------------------------------------\n\nTITLE: Testing Pub/Sub Topics in Go\nDESCRIPTION: This Go test code uses Encore's testing tools to verify the behavior of Pub/Sub topics. It employs the `et.Topic` function to extract and assert published messages during a test run, ensuring isolation between tests and deterministic message IDs. Dependencies include the `encore.dev/et` package and `github.com/stretchr/testify/assert` for assertions.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/pubsub.md#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\npackage user\n\nimport (\n    \"testing\"\n\n    \"encore.dev/et\"\n    \"github.com/stretchr/testify/assert\"\n)\n\nfunc Test_Register(t *testing.T) {\n    t.Parallel()\n\n    ... Call Register() and assert changes to the database ...\n\n    // Get all published messages on the Signups topic from this test.\n    msgs := et.Topic(Signups).PublishedMessages()\n    assert.Len(t, msgs, 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Unacknowledged Incidents Reminder Cron Job in Go\nDESCRIPTION: Cron job implementation to remind about unacknowledged incidents every 10 minutes via Slack notifications.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/incident-management-tool.md#2025-04-21_snippet_10\n\nLANGUAGE: go\nCODE:\n```\n// Track unacknowledged incidents\nvar _ = cron.NewJob(\"unacknowledged-incidents-reminder\", cron.JobConfig{\n\tTitle:    \"Notify on Slack about incidents which are not acknowledged\",\n\tEvery:    10 * cron.Minute,\n\tEndpoint: RemindUnacknowledgedIncidents,\n})\n\n//encore:api private\nfunc RemindUnacknowledgedIncidents(ctx context.Context) error {\n\tincidents, err := List(ctx) // we never query for acknowledged incidents\n\tif err != nil {\n\t\treturn err\n\t}\n\tif incidents == nil {\n\t\treturn nil\n\t}\n\n\tvar items = []string{\"These incidents have not been acknowledged yet. Please acknowledge them otherwise you will be reminded every 10 minutes:\"}\n\tfor _, incident := range incidents.Items {\n\t\tvar assignee string\n\t\tif incident.Assignee != nil {\n\t\t\tassignee = fmt.Sprintf(\"%s %s (<@%s>)\", incident.Assignee.FirstName, incident.Assignee.LastName, incident.Assignee.SlackHandle)\n\t\t} else {\n\t\t\tassignee = \"Unassigned\"\n\t\t}\n\n\t\titems = append(items, fmt.Sprintf(\"[%s] [#%d] %s\", assignee, incident.Id, incident.Body))\n\t}\n\n\tif len(incidents.Items) > 0 {\n\t\t_ = slack.Notify(ctx, &slack.NotifyParams{Text: strings.Join(items, \"\\n\")})\n\t}\n\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a catch-all handler for HTTP router in Go\nDESCRIPTION: This code snippet demonstrates how to create a catch-all handler for an existing HTTP router using Encore's raw endpoints. It defines an Encore API endpoint that captures all requests under a specific path and passes them to the existing router. This allows for a \"forklift\" migration strategy, enabling the entire application to be deployed through Encore with minimal refactoring.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/migration/migrate-to-encore.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public raw path=/api/*path\nfunc MigrationHandler(w http.ResponseWriter, req *http.Request) {\n// pass request to existing router\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Pub/Sub Subscriptions in Go\nDESCRIPTION: This code creates two pub/sub subscriptions using `encore.dev/pubsub`. One subscription, \"pointer\", uses `PointerMethod` (a pointer receiver), and the other, \"non-pointer\", uses `NonPointerMethod` (a value receiver) as handlers for the `Topic` topic. The subscriptions are configured with `EncoreInternal_pubsub_handler_pointer` and `EncoreInternal_pubsub_handler_non_pointer` respectively, and a specific delivery guarantee.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/pubsubgen/testdata/method_handler.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nvar _ = pubsub.NewSubscription(Topic, \"pointer\",\n    pubsub.SubscriptionConfig[*Event]{\n        Handler: EncoreInternal_pubsub_handler_pointer,\n    },\n)\n\nvar _ = pubsub.NewSubscription(Topic, \"non-pointer\",\n    pubsub.SubscriptionConfig[*Event]{\n        Handler: EncoreInternal_pubsub_handler_non_pointer,\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring cgo in Encore Build\nDESCRIPTION: This JSON configuration snippet shows how to enable cgo in an Encore application by modifying the `encore.app` file. By setting `cgo_enabled` to true under the build configuration, developers can compile their application with cgo support. This requires the application to be compiled using an Ubuntu builder image with gcc pre-installed. Proper static linking of cgo libraries is necessary, so they must support static linking.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/cgo.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"my-app-id\",\n  \"build\": {\n    \"cgo_enabled\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing with Mocked Dependencies in Encore Services\nDESCRIPTION: Shows how to test an Encore service by injecting mock implementations of dependencies. This simplifies testing by isolating the service from external services.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_45\n\nLANGUAGE: go\nCODE:\n```\nfunc TestFoo(t *testing.T) {\n    svc := &Service{sendgridClient: &myMockClient{}}\n    // Test implementation\n}\n```\n\n----------------------------------------\n\nTITLE: Catch-all Handler for Existing HTTP Router\nDESCRIPTION: This snippet illustrates how to mount an existing Express.js app within an Encore API endpoint, allowing seamless integration and functioning as a catch-all handler for requests.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/migration/express-migration.md#2025-04-21_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport { api, RawRequest, RawResponse } from \"encore.dev/api\";\nimport express, { request, response } from \"express\";\n\nObject.setPrototypeOf(request, RawRequest.prototype);\nObject.setPrototypeOf(response, RawResponse.prototype);\n\nconst app = express();\n\napp.get('/foo', (req: any, res) => {\n  res.send('Hello World!')\n})\n\nexport const expressApp = api.raw(\n  { expose: true, method: \"*\", path: \"/!rest\" },\n  app,\n);\n```\n\n----------------------------------------\n\nTITLE: Internal Configuration Unmarshaling for CsConfig in Go with Encore\nDESCRIPTION: This snippet provides unmarshaling logic for CsConfig, which processes JSON input and constructs a valid CsConfig object. It is part of the configuration management mechanisms in the Encore framework.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/merge_identical_comments.txt#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc encoreInternalTypeConfigUnmarshaler_svc_CsConfig(itr *jsoniter.Iterator, path []string) (obj CsConfig) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"Foo\":\n\t\t\tobj.Foo = config.CreateValue[string](itr.ReadString(), append(path, \"Foo\"))\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Scripts with Encore Environment\nDESCRIPTION: The `encore exec` command allows running executable scripts within the context of the local Encore application environment. This is useful for tasks like database seeding or other environment-specific operations.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ encore exec -- <command>\n```\n\n----------------------------------------\n\nTITLE: Creating Infrastructure Config for Encore App - JSON\nDESCRIPTION: This snippet provides the structure of the JSON configuration file required for connecting to the database within the Encore app, including CA certificates and connection details.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/deploy-to-digital-ocean-wip.md#2025-04-21_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"$schema\": \"https://encore.dev/schemas/infra.schema.json\",\n   \"sql_servers\": [\n   {\n      \"host\": \"mydb.db.ondigitalocean.com:25060\",\n      \"tls_config\": {\n         \"ca\": \"-----BEGIN CERTIFICATE-----\\n...\"\n      },\n      \"databases\": {\n         \"mydb\": {\n            \"username\": \"doadmin\",\n            \"password\": {\"$env\": \"DB_PASSWORD\"}\n          }\n      }\n   }]   \n}\n```\n\n----------------------------------------\n\nTITLE: Database Query Function in External Package\nDESCRIPTION: Defines a function that accepts a sqldb.Database pointer, demonstrating how database query capabilities can be passed between packages\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_helper.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc Foo(db *sqldb.Database) {\n    _ = db.Query\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Cron Job with Encore's Cron Jobs API in TypeScript\nDESCRIPTION: This snippet demonstrates how to define a new Cron Job using Encore's Cron API, setting it to send welcome emails every 2 hours. It illustrates the use of unique IDs for task identification and the handling of idempotent API calls.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/cron-jobs.md#2025-04-21_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { CronJob } from \"encore.dev/cron\";\nimport { api } from \"encore.dev/api\";\n\n// Send a welcome email to everyone who signed up in the last two hours.\nconst _ = new CronJob(\"welcome-email\", {\n\ttitle: \"Send welcome emails\",\n\tevery: \"2h\",\n\tendpoint: sendWelcomeEmail,\n})\n\n// Emails everyone who signed up recently.\n// It's idempotent: it only sends a welcome email to each person once.\nexport const sendWelcomeEmail = api({}, async () => {\n\t// Send welcome emails...\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Infrastructure Configuration (JSON)\nDESCRIPTION: This JSON file defines the infrastructure configuration for the application, specifically for SQL servers. It specifies the host, databases, usernames, and passwords for accessing the SQL databases used by the monitor and site services.  The password uses an environment variable `DB_PASSWORD` for security.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_17\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"$schema\": \"https://encore.dev/schemas/infra.schema.json\",\n   \"sql_servers\": [\n      {\n         \"host\": \"my-db-host:5432\",\n         \"databases\": {\n            \"monitor\": {\n               \"username\": \"my-db-owner\",\n                \"password\": {\"$env\": \"DB_PASSWORD\"}\n            },\n            \"site\": {\n               \"username\": \"my-db-owner\",\n                \"password\": {\"$env\": \"DB_PASSWORD\"}\n            }\n         }\n      }\n   ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining API Endpoints with Encore.ts TypeScript\nDESCRIPTION: This snippet shows how to define an API endpoint called 'ping' using Encore.ts in TypeScript. The endpoint accepts POST requests and returns a message based on request parameters. It requires importing the 'api' module from 'encore.dev/api'. This example assumes the service name is 'hello' and demonstrates a basic endpoint setup.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/defining-apis.mdx#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// inside the hello.ts file\nimport { api } from \"encore.dev/api\";\n\nexport const ping = api(\n  { method: \"POST\" },\n  async (p: PingParams): Promise<PingResponse> => {\n    return { message: `Hello ${p.name}!` };\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Uploading Files to Object Storage using TypeScript\nDESCRIPTION: This snippet uploads a file to a specified bucket using the `upload` method in Encore.ts. It demonstrates how to handle binary data and configure file attributes like content type. The method requires the bucket instance and file data as input, with optional parameters for defining upload settings. This ensures files are uploaded effectively with specific attributes when necessary.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/object-storage.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst data = Buffer.from(...); // image data\nconst attributes = await profilePictures.upload(\"my-image.jpeg\", data, {\n  contentType: \"image/jpeg\",\n});\n```\n\n----------------------------------------\n\nTITLE: Cookie Handling in Response\nDESCRIPTION: Demonstrates setting cookies in API responses using the Set-Cookie header.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/api-schemas.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ntype LoginResponse struct {\n    SessionID string `header:\"Set-Cookie\"`\n}\n\n//encore:api public method=POST path=/login\nfunc Login(ctx context.Context) (*LoginResponse, error) {\n    return &LoginResponse{SessionID: \"session=123\"}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Constant in TypeScript Module\nDESCRIPTION: This snippet exports a constant named 'blah' with a value of 5 from a TypeScript module.\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/tests/testdata/tsconfig.txt#2025-04-21_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const blah = 5;\n```\n\n----------------------------------------\n\nTITLE: Implementing an Auth Handler with Invalid Parameter Type in Go\nDESCRIPTION: This code demonstrates an invalid auth handler implementation in Encore. The auth handler 'MyAuth' uses an invalid parameter type 'Params' which is defined as an int, but Encore requires the second parameter to be a string or a pointer to a named struct.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/auth_handler_invalid_named_type.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"encore.dev/beta/auth\"\n)\n\ntype Params int\n\n//encore:authhandler\nfunc MyAuth(ctx context.Context, p Params) (auth.UID, error) { return \"\", nil }\n```\n\n----------------------------------------\n\nTITLE: Handling Path Parameters with Encore.ts\nDESCRIPTION: This snippet shows how to handle path parameters in API endpoints using Encore.ts. It includes an example where parameters ':id' and '*path' are extracted from the request path. These parameters are matched with corresponding fields in the request data type, allowing dynamic endpoint routing and type-safe request handling.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/defining-apis.mdx#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Retrieves a blog post by its id.\nexport const getBlogPost = api(\n    { method: \"GET\", path: \"/blog/:id/*path\" },\n    async (params: {id: number; path: string}): Promise<BlogPost> {\n        // Use id and path to query database...\n    }\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Public API Endpoint in Go with Encore\nDESCRIPTION: Defines a public API endpoint 'Foo' using Encore's API directive. The function takes a context parameter and returns an error, implementing a minimal API handler.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/et.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n)\n\n//encore:api public\nfunc Foo(context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Initializing Server Configurations in Go\nDESCRIPTION: Defines server configuration options for HTTP, TCP, and GRPC servers using Encore. The 'Config' struct holds 'ServerOptions' for different server types, each specifying if the server is enabled and the port it runs on. 'config.Load[*Config]()' initializes the configuration utilizing the Encore configuration package.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_named_struct_multiple_uses.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n    \"time\"\n\n\t\"encore.dev/config\"\n\t\"encore.dev/types/uuid\"\n)\n\n// ServerOptions represent options for a server\ntype ServerOptions struct {\n    Enabled bool // Is this option enabled?\n    Port    uint32 // What port should we run on?\n}\n\ntype Config struct {\n    HTTP ServerOptions // The options for the HTTP server\n    TCP  ServerOptions // The options for the TCP server\n    GRPC ServerOptions // The options for the GRPC server\n}\n\nvar _ = config.Load[*Config]()\n\n```\n\n----------------------------------------\n\nTITLE: Updating Encore to Latest Version\nDESCRIPTION: This snippet updates Encore CLI to the latest version using the `encore version update` command. It is essential for ensuring that you have the most recent features and bug fixes.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/install.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nencore version update\n\n```\n\n----------------------------------------\n\nTITLE: Testing Auth Info Reset Between Tests in Go\nDESCRIPTION: Verification that authentication information is properly reset between test cases, ensuring test isolation.\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/et_override_user.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc TestOverrideAuthInfo_ResetBetweenTests(t *testing.T) {\n    curr, _ := auth.UserID()\n    if curr != \"\" {\n        t.Fatalf(\"got uid %q, want %q\", curr, \"\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Encore Database Connection URI\nDESCRIPTION: Outputs a database connection string for the specified database and environment.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\n$ encore db conn-uri <database-name> [--env=<name>] [flags]\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages to Pub/Sub Topic in Go\nDESCRIPTION: This API endpoint demonstrates how to publish a message to the previously defined pub/sub topic using Encore. It creates a new MessageType instance and publishes it to the BasicTopic.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_subscriber_missing_handler.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n// encore:api\nfunc DoStuff(ctx context.Context) error {\n    return BasicTopic.Publish(ctx, &MessageType{Name: \"foo\"})\n}\n```\n\n----------------------------------------\n\nTITLE: Logging Out from Encore\nDESCRIPTION: The `encore auth logout` command terminates the current user's session with the Encore platform.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n$ encore auth logout\n```\n\n----------------------------------------\n\nTITLE: Duplicate Cache Cluster Definition in Go Service\nDESCRIPTION: Example showing incorrect configuration where two cache clusters are created with the same name 'cluster'. This is not allowed as cache cluster names must be unique within a service.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cache_err_duplicate_cluster.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/storage/cache\"\n)\n\nvar cluster1 = cache.NewCluster(\"cluster\", cache.ClusterConfig{})\nvar cluster2 = cache.NewCluster(\"cluster\", cache.ClusterConfig{})\n\n//encore:api public\nfunc Foo(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Datadog Metrics Configuration in JSON\nDESCRIPTION: Configuration for Datadog metrics, specifying collection interval, site, and API key.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"metrics\": {\n    \"type\": \"datadog\",\n    \"collection_interval\": 30,\n    \"site\": \"datadoghq.com\",\n    \"api_key\": {\n      \"$env\": \"DATADOG_API_KEY\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Internal Unmarshaller for OtherConfig - Go\nDESCRIPTION: This snippet provides an internal unmarshaller function for the OtherConfig type to properly parse JSON configuration values into the structure using the jsoniter package. It handles the dynamic nature of Encore's configuration.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/multiple_configs_in_service.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\tconfig \"encore.dev/config\"\n\tjsoniter \"github.com/json-iterator/go\"\n)\n\n// encoreInternalTypeConfigUnmarshaler_svc_OtherConfig will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_svc_OtherConfig(itr *jsoniter.Iterator, path []string) (obj OtherConfig) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"Foo\":\n\t\t\tobj.Foo = config.CreateValue[string](itr.ReadString(), append(path, \"Foo\"))\n\t\tcase \"Bar\":\n\t\t\tobj.Bar = config.CreateValue[int](itr.ReadInt(), append(path, \"Bar\"))\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Configuration Struct in Go\nDESCRIPTION: This struct holds various types of settings for an HTTP server, TCP server, GRPC server, and multiple generic lists and maps. It leverages the DisablableOption type for configurable options which can be enabled or disabled, facilitating dynamic configuration in services.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/generic_named_types.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype Config struct {\n    HTTP    DisablableOption[uint16] // The options for the HTTP server\n    Another DisablableOption[uint64]\n    TCP     DisablableOption[uint16] // The options for the TCP server\n    GRPC    DisablableOption[uint64] // The options for the GRPC server\n    List1   List[string]             // A list of strings\n    List2   List[string]\n    List3   List[int]\n    Map1    Map[string, string]\n    Map2    Map[int, string]\n    Map3    Map[string, string]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Global Middleware with PubSub Publishing in Go\nDESCRIPTION: This snippet defines a global middleware function using Encore.dev's middleware package. The middleware publishes a message to the BasicTopic before proceeding with the request handling.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_publish_in_middleware.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\npackage middleware\n\nimport (\n\t\"time\"\n\n\t\"encore.dev/middleware\"\n\t\"encore.dev/pubsub\"\n\n\t\"test/svc\"\n)\n\n//encore:middleware global target=all\nfunc MiddlewareFunc(req middleware.Request, next middleware.Next) middleware.Response {\n    svc.BasicTopic.Publish(req.Context(), &svc.MessageType{UserID: 1, Name: \"bar\"})\n\n\treturn next(req)\n}\n```\n\n----------------------------------------\n\nTITLE: StreamIn API signature variations\nDESCRIPTION: These code snippets show the different type signatures for the `api.streamIn` function, showcasing how to define the handshake, incoming, and outgoing message types. It demonstrates optional handshake and outgoing message types.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/streaming-apis.mdx#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\napi.streamIn<Handshake, Incoming, Outgoing>(\n  {...}, async (handshake, stream): Promise<Outgoing> => {...})\n```\n\nLANGUAGE: typescript\nCODE:\n```\napi.streamIn<Handshake, Incoming>(\n  {...}, async (handshake, stream) => {...})\n```\n\nLANGUAGE: typescript\nCODE:\n```\napi.streamIn<Incoming, Outgoing>(\n  {...}, async (stream): Promise<Outgoing> => {...})\n```\n\nLANGUAGE: typescript\nCODE:\n```\napi.streamIn<Incoming>(\n  {...}, async (stream) => {...})\n```\n\n----------------------------------------\n\nTITLE: Defining Server Options and API in Go\nDESCRIPTION: This Go code snippet defines server options and introduces an API function within an Encore project. It requires the `context` and `encore.dev/config` packages. It sets up HTTP, TCP, and GRPC server options and includes a sample API endpoint called `MyAPI`.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_named_struct_multiple_uses.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n)\n\n// ServerOptions represent options for a server\ntype ServerOptions struct {\n    Enabled bool // Is this option enabled?\n    Port    uint32 // What port should we run on?\n}\n\ntype Config struct {\n    HTTP ServerOptions // The options for the HTTP server\n    TCP  ServerOptions // The options for the TCP server\n    GRPC ServerOptions // The options for the GRPC server\n}\n\nvar _ = config.Load[*Config]()\n\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Ping Endpoint in Go\nDESCRIPTION: Go code for the monitor service, implementing a Ping endpoint that checks if a given URL is up or down.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/uptime.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// Service monitor checks if a website is up or down.\npackage monitor\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"strings\"\n)\n\n// PingResponse is the response from the Ping endpoint.\ntype PingResponse struct {\n\tUp bool `json:\"up\"`\n}\n\n// Ping pings a specific site and determines whether it's up or down right now.\n//\n//encore:api public path=/ping/*url\nfunc Ping(ctx context.Context, url string) (*PingResponse, error) {\n    // If the url does not start with \"http:\" or \"https:\", default to \"https:\".\n\tif !strings.HasPrefix(url, \"http:\") && !strings.HasPrefix(url, \"https:\") {\n\t\turl = \"https://\" + url\n\t}\n\n    // Make an HTTP request to check if it's up.\n\treq, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn &PingResponse{Up: false}, nil\n\t}\n\tresp.Body.Close()\n\n    // 2xx and 3xx status codes are considered up\n    up := resp.StatusCode < 400\n    return &PingResponse{Up: up}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Global Tagged Middleware Implementation\nDESCRIPTION: Implements globally-scoped middleware that targets endpoints tagged with 'foo' across all services.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/middleware_err_not_in_service.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n//encore:middleware global target=tag:foo\nfunc TaggedInSvc(req middleware.Request, next middleware.Next) middleware.Response {\n    return next(req)\n}\n```\n\n----------------------------------------\n\nTITLE: Graceful Shutdown Configuration in JSON\nDESCRIPTION: Configuration for graceful shutdown, specifying total shutdown time and time allocations for shutdown hooks and handlers.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"graceful_shutdown\": {\n    \"total\": 30,\n    \"shutdown_hooks\": 10,\n    \"handlers\": 20\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining codegen.yml for GraphQL Code Generation - TypeScript\nDESCRIPTION: Configuration file for GraphQL Code Generator, specifying the location of the GraphQL schema and the output path for generated types. Required to automatically create TypeScript types based on the GraphQL schema.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/graphql.mdx#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n# This configuration file tells GraphQL Code Generator how to generate types based on our schema.\nschema: './schema.graphql'\ngenerates:\n  # Specify where our generated types should live.\n  ./graphql/__generated__/resolvers-types.ts:\n    plugins:\n      - 'typescript'\n      - 'typescript-resolvers'\n    config:\n      useIndexSignature: true\n```\n\n----------------------------------------\n\nTITLE: Echo API Endpoint in Encore.ts\nDESCRIPTION: This TypeScript snippet demonstrates an API endpoint using Encore.ts that echoes back the request data. The endpoint extracts data from headers, query parameters, and JSON body, and returns them as part of the response.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api, Header, Query } from \"encore.dev/api\";\n\ninterface Data {\n  header: Header<\"X-Header\">; // this field will be read from the http header\n  query: Query<string>; // this will be parsed from the '?query=...' parameter in the request url\n  body: string; // this will be sent as part of the JSON body\n}\n// A simple API endpoint that echoes the data back.\nexport const echo = api(\n  { method: \"POST\", path: \"/echo\" },\n  async (params: Data): Promise<Data> => {\n    return params; // echo the data back\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Defining a Public Encore API Endpoint\nDESCRIPTION: This code defines a public API endpoint using the `//encore:api public path=/foo/:id/*baz` annotation. The `Foo` function serves as the handler for this endpoint, taking context, an integer ID, a string `baz`, and a pointer to a `Params` struct as input. It returns an error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/path_params.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport \"context\"\n\ntype Params struct {\n    String string\n    Int int\n}\n\n//encore:api public path=/foo/:id/*baz\nfunc Foo(ctx context.Context, id int, baz string, p *Params) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Defining Public API Method on Encore Service Struct in Go\nDESCRIPTION: Defines a public API method Str on the Service struct with the //encore:api public directive, making it externally accessible through Encore's HTTP interface. It accepts a context and a Params struct as input parameters and returns an error. This method currently implements a stub returning nil, serving as a placeholder for real API logic.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/servicestruct_duplicate.txt#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\ntype Params struct{}\n\n//encore:api public\nfunc (s *Service) Str(ctx context.Context, p *Params) error { return nil }\n\n```\n\n----------------------------------------\n\nTITLE: Creating New Encore Account\nDESCRIPTION: Signs up a new user for an Encore account.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n$ encore auth signup\n```\n\n----------------------------------------\n\nTITLE: Error Output for Invalid Cache Key Type\nDESCRIPTION: Error message showing that using a non-basic type (Key[string]) for the Foo field in the cache key structure is invalid according to Encore.dev's caching rules.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cache_err_generic_type_nonbasic.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n Invalid Cache Key Type [E9999]\n\nThe field Foo is invalid: must be a basic type\n\n    [ svc/svc.go:12:5 ]\n    \n 10 \n 11  type Key[T any] struct {\n 12      Foo T\n         \n            found Key[string]\n 13  }\n 14 \n 15  var keyspace = cache.NewStringKeyspace[Key[Key[string]]](cluster, cache.KeyspaceConfig{\n                                            \n                                                    instantiated here\n 16      KeyPattern: \"foo/:Foo\",\n 17  })\n\n\nFor more information see https://encore.dev/docs/primitives/caching\n```\n\n----------------------------------------\n\nTITLE: Generating Internal Authentication Descriptor\nDESCRIPTION: Automatically generated internal authentication descriptor that handles token decoding, authentication processing, and registration with Encore's API runtime\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/authhandlergen/testdata/basic.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nvar EncoreInternal_authhandler_AuthDesc_AuthHandler = &__api.AuthHandlerDesc[string]{\n    AuthHandler: func(ctx context.Context, params string) (info __model.AuthInfo, err error) {\n        info.UID, err = AuthHandler(ctx, params)\n        return info, err\n    },\n    DecodeAuth: func(httpReq *http.Request) (params string, err error) {\n        if auth := httpReq.Header.Get(\"Authorization\"); auth != \"\" {\n            for _, prefix := range [...]string{\"Bearer \", \"Token \"} {\n                if strings.HasPrefix(auth, prefix) {\n                    if params = auth[len(prefix):]; params != \"\" {\n                        return params, nil\n                    }\n                }\n            }\n        }\n        return \"\", errs.B().Code(errs.Unauthenticated).Msg(\"invalid auth param\").Err()\n    },\n    DefLoc:      uint32(0x0),\n    Endpoint:    \"AuthHandler\",\n    HasAuthData: false,\n    Service:     \"basic\",\n    SvcNum:      1,\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Implementation - Express.js vs Encore.ts\nDESCRIPTION: Illustrates testing approaches in both frameworks. Express.js uses Vitest and Supertest for HTTP testing, while Encore.ts allows direct endpoint calling in tests.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/migration/express-migration.md#2025-04-21_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport {describe, expect, test} from \"vitest\";\nimport request from \"supertest\";\nimport express from \"express\";\nimport getRequestExample from \"../get-request-example\";\n\n/**\n * We need to add the supertest library to make fake HTTP requests to the Express.js app without having to\n * start the server. We also use the vitest library to write tests.\n */\ndescribe(\"Express App\", () => {\n  const app = express();\n  app.use(\"/\", getRequestExample);\n\n  test(\"should respond with a greeting message\", async () => {\n    const response = await request(app).get(\"/hello/John\");\n    expect(response.status).to.equal(200);\n    expect(response.body).to.have.property(\"message\");\n    expect(response.body.message).to.equal(\"Hello John!\");\n  });\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport {describe, expect, test} from \"vitest\";\nimport {dynamicPathParamExample} from \"../get-request-example\";\n\n// This test suite demonstrates how to test an Encore route.\n// Run tests using the `encore test` command.\ndescribe(\"Encore app\", () => {\n  test(\"should respond with a greeting message\", async () => {\n    // You can call the Encore.ts endpoint directly in your tests,\n    // just like any other function.\n    const resp = await dynamicPathParamExample({name: \"world\"});\n    expect(resp.message).toBe(\"Hello world!\");\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Error Type Structure in Go\nDESCRIPTION: Definition of the core errs.Error type that represents structured errors, including code, message, details, and metadata fields.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/api-errors.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype Error struct {\n\t// Code is the error code to return.\n\tCode ErrCode `json:\"code\"`\n\t// Message is a descriptive message of the error.\n\tMessage string `json:\"message\"`\n\t// Details are user-defined additional details.\n\tDetails ErrDetails `json:\"details\"`\n\t// Meta are arbitrary key-value pairs for use within\n\t// the Encore application. They are not exposed to external clients.\n\tMeta Metadata `json:\"-\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Configuration Structs and API Endpoint in Golang - Encore\nDESCRIPTION: Defines the 'Config' struct with dependencies on helper and utility modules for configuration loading in Encore. Additionally, it implements a simple API function 'MyAPI' using Encore's annotations. This snippet requires 'encore.dev/config' for configuration management.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/name_conflicts.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n\n\t\"example.com/svc/utils\"\n\t\"example.com/svc/helpers\"\n)\n\ntype Config struct {\n    A helpers.ExtraConfig\n    B utils.ExtraConfig\n    C helpers.ExtraConfig\n    D utils.ExtraConfig\n    E helpers.SingleUse\n}\n\nvar _ = config.Load[*Config]()\n\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: PostGIS Extensions Table\nDESCRIPTION: Table listing PostGIS extensions with their versions and descriptions. Each extension provides specific functionality for spatial data handling, address standardization, geocoding, and raster operations.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/database-extensions.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| postgis                        | 3.4.2   | PostGIS geometry and geography spatial types and functions                                                          |\n| address_standardizer           | 3.4.2   | Used to parse an address into constituent elements. Generally used to support geocoding address normalization step. |\n| postgis_topology               | 3.4.2   | PostGIS topology spatial types and functions                                                                        |\n| postgis_tiger_geocoder         | 3.4.2   | PostGIS tiger geocoder and reverse geocoder                                                                         |\n| address_standardizer_data_us   | 3.4.2   | Address Standardizer US dataset example                                                                             |\n| postgis_sfcgal                 | 3.4.2   | PostGIS SFCGAL functions                                                                                            |\n| postgis_raster                 | 3.4.2   | PostGIS raster types and functions                                                                                  |\n```\n\n----------------------------------------\n\nTITLE: Creating Site Migration for PostgreSQL\nDESCRIPTION: SQL migration script to create sites table with primary key and URL column in PostgreSQL database\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/uptime.md#2025-04-21_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE sites (\n    id BIGSERIAL PRIMARY KEY,\n    url TEXT NOT NULL\n);\n```\n\n----------------------------------------\n\nTITLE: Configuration Loading with Encore Framework\nDESCRIPTION: Loads configuration using Encore's config.Load generic method, with automatic unmarshaling support\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/cue_tags.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nvar _ = config.Load[*Config]()\n```\n\n----------------------------------------\n\nTITLE: Creating Docker Configuration for PostgreSQL\nDESCRIPTION: This snippet demonstrates how to create a JSON configuration file for PostgreSQL connection in a Dockerized Encore application. The configuration includes schema definition and database connection details that need to be replaced with actual values before use.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/rest-api.mdx#2025-04-21_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"$schema\": \"https://encore.dev/schemas/infra.schema.json\",\n   \"sql_servers\": [\n      {\n         \"host\": \"my-db-host:5432\",\n         \"databases\": {\n            \"url\": {\n               \"username\": \"my-db-owner\",\n                \"password\": {\"$env\": \"DB_PASSWORD\"}\n            }\n         }\n      }\n   ]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Cron Job with Custom Schedule in TypeScript\nDESCRIPTION: This snippet shows how to set up a Cron Job using a custom schedule to run monthly at a specific time. It highlights the usage of the 'schedule' field to define more complex execution times compared to the 'every' field.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/cron-jobs.md#2025-04-21_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n// Run the monthly accounting sync job at 4am (UTC) on the 15th day of each month.\nconst _ = new CronJob(\"accounting-sync\", {\n\ttitle: \"Cron Job Example\",\n\tschedule: \"0 4 15 * *\",\n\tendpoint: accountingSync,\n})\n```\n\n----------------------------------------\n\nTITLE: Defining MyAPI Function in Go\nDESCRIPTION: This snippet implements a placeholder API function named MyAPI in Go, which currently returns nil without performing any operations. The function is designed to be an entry point for an Encore-based API. It accepts a context parameter and is intended to return an error type, although no implementation is provided.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/cue_optional_tag.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Slack Webhook URL using Shell\nDESCRIPTION: This snippet outlines the process for setting the SlackWebhookURL as a secret in Encore. This ensures secure storage of sensitive information required for sending notifications. The command allows setting for different environments such as development, local, and PR.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_26\n\nLANGUAGE: shell\nCODE:\n```\n$ encore secret set --type dev,local,pr SlackWebhookURL\nEnter secret value: *****\nSuccessfully updated development secret SlackWebhookURL.\n```\n\n----------------------------------------\n\nTITLE: Generating API Interface for Mocking in Encore Go\nDESCRIPTION: Defines an interface for the service's API using Encore in Go, aimed at mocking during testing. The interface captures API surface areas excluding raw endpoints, with dependencies primarily on Encore's generated code handling.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/request_query.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n// Code generated by encore. DO NOT EDIT.\n\npackage code\n\nimport \"context\"\n\n// These functions are automatically generated and maintained by Encore\n// to simplify calling them from other services, as they were implemented as methods.\n// They are automatically updated by Encore whenever your API endpoints change.\n\n// Interface defines the service's API surface area, primarily for mocking purposes.\n//\n// Raw endpoints are currently excluded from this interface, as Encore does not yet\n// support service-to-service API calls to raw endpoints.\ntype Interface interface {\n    Foo(ctx context.Context, p *Params) error\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Conflicting Cache Keyspaces in Go\nDESCRIPTION: Demonstrates an invalid configuration of two cache keyspaces with conflicting key patterns. The first keyspace uses pattern 'foo/:Foo' while the second uses 'foo/bar/:Foo', which creates a path conflict since 'bar' conflicts with the ':Foo' parameter.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cache_err_duplicate_paths.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/storage/cache\"\n)\n\ntype Key[T any] struct {\n    Foo T\n}\n\nvar cluster = cache.NewCluster(\"cluster\", cache.ClusterConfig{})\n\nvar keyspace1 = cache.NewStringKeyspace[Key[string]](cluster, cache.KeyspaceConfig{\n    KeyPattern: \"foo/:Foo\",\n})\n\nvar keyspace2 = cache.NewStringKeyspace[Key[string]](cluster, cache.KeyspaceConfig{\n    KeyPattern: \"foo/bar/:Foo\",\n})\n\n//encore:api public\nfunc Foo(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Defining Database Schema with Drizzle ORM in Encore.ts\nDESCRIPTION: Illustrates how to define a database schema using Drizzle's pg-core in an Encore.ts project. This example creates a 'users' table with id, name, and email fields.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as p from \"drizzle-orm/pg-core\";\n\nexport const users = p.pgTable(\"users\", {\n  id: p.serial().primaryKey(),\n  name: p.text(),\n  email: p.text().unique(),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Cowsay Slack Command in Go\nDESCRIPTION: Go code for implementing the /cowsay Slack command. It defines a public API endpoint that responds to Slack's slash command requests with a cowsay-formatted message.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/slack-bot.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// Service slack implements a cowsaw Slack bot.\npackage slack\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// cowart is the formatting string for printing the cow art.\nconst cowart = \"Moo! %s\"\n\n//encore:api public raw path=/cowsay\nfunc Cowsay(w http.ResponseWriter, req *http.Request) {\n\ttext := req.FormValue(\"text\")\n\tdata, _ := json.Marshal(map[string]string{\n\t\t\"response_type\": \"in_channel\",\n\t\t\"text\":          fmt.Sprintf(cowart, text),\n\t})\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(200)\n\tw.Write(data)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Message Type and Pub/Sub Topic in Go\nDESCRIPTION: This snippet defines a MessageType struct and creates a new pub/sub topic using Encore's pubsub package. It sets up the topic with at-least-once delivery guarantee.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_subscriber_missing_handler.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\ntype MessageType struct {\n    Name string\n}\n\nvar (\n    BasicTopic = pubsub.NewTopic[*MessageType](\"basic-topic\", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })\n    _ = pubsub.NewSubscription(BasicTopic, \"basic-subscription\", pubsub.SusbcriptionConfig{})\n)\n```\n\n----------------------------------------\n\nTITLE: Error Handling Implementation - Express.js vs Encore.ts\nDESCRIPTION: Shows error handling patterns in both frameworks. Express.js uses status codes and throw statements, while Encore.ts uses APIError class for specific error codes.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/migration/express-migration.md#2025-04-21_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport express, {Request, Response} from \"express\";\n\nconst app: Express = express();\n\n// Default error handler\napp.get(\"/broken\", (req, res) => {\n  throw new Error(\"BROKEN\"); // This will result in a 500 error\n});\n\n// Returning specific error code\napp.get(\"/get-user\", (req: Request, res: Response) => {\n  const id = req.query.id || \"\";\n  if (id.length !== 3) {\n    res.status(400).json({error: \"invalid id format\"});\n  }\n  // TODO: Fetch something from the DB\n  res.json({user: \"Simon\"});\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport {api, APIError} from \"encore.dev/api\"; // Default error handler\n\n// Default error handler\nexport const broken = api(\n  {expose: true, method: \"GET\", path: \"/broken\"},\n  async (): Promise<void> => {\n    throw new Error(\"This is a broken endpoint\"); // This will result in a 500 error\n  },\n);\n\n// Returning specific error code\nexport const brokenWithErrorCode = api(\n  {expose: true, method: \"GET\", path: \"/broken/:id\"},\n  async ({id}: { id: string }): Promise<{ user: string }> => {\n    if (id.length !== 3) {\n      throw APIError.invalidArgument(\"invalid id format\");\n    }\n    // TODO: Fetch something from the DB\n    return {user: \"Simon\"};\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Generating Client Files\nDESCRIPTION: This command executes Go tests with the `-golden-update` flag to generate client files within the `internal/clientgen/client_test.go` file, which uses auto-generated files from the `e2e-tests/testdata` directory. It is used to create client files for all client generation languages that are supported.  It's important to regenerate these files after changes to the client or content of the `testdata` folder. The command requires the `go` tool and assumes you are running it from the `e2e-tests` directory.\nSOURCE: https://github.com/encoredev/encore/blob/main/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\ngo test -golden-update\n```\n\n----------------------------------------\n\nTITLE: Configuring Kubernetes Cluster\nDESCRIPTION: The `encore k8s configure` command updates your kubectl configuration to point to the Kubernetes cluster for a specified environment.  The environment name is passed via the `--env` flag.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_21\n\nLANGUAGE: shell\nCODE:\n```\n$ encore k8s configure --env=ENV_NAME\n```\n\n----------------------------------------\n\nTITLE: Defining Encore Service Configuration\nDESCRIPTION: Defines a configuration structure `Config` with fields for a list of integers (`Ages`) and a list of strings (`OtherBits`).  This structure is intended to be loaded from Encore's configuration system. The `config.Load[*Config]()` call ensures that Encore attempts to load configuration data into this structure during service initialization.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_lists.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n    \"time\"\n\n\t\"encore.dev/config\"\n\t\"encore.dev/types/uuid\"\n)\n\ntype Config struct {\n    Ages      []int32\n    OtherBits []string\n}\n\nvar _ = config.Load[*Config]()\n```\n\n----------------------------------------\n\nTITLE: Service Registration for Encore in Go\nDESCRIPTION: This snippet handles the registration of the Encore service at initialization. Using the Encore SDK, it registers the service definition which encapsulates all available API methods, allowing them to be invoked as part of the service's API surface.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/userfacinggen/testdata/service_struct.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// want:encore_internal__svcstruct.go --\npackage basic\n\nimport __service \"encore.dev/appruntime/apisdk/service\"\n\nfunc init() {\n\t__service.Register(EncoreInternal_svcstruct_Service)\n}\n\nvar EncoreInternal_svcstruct_Service = &__service.Decl[Service]{\n\tName:        \"Service\",\n\tService:     \"basic\",\n\tSetup:       nil,\n\tSetupDefLoc: uint32(0x0),\n}\n```\n\n----------------------------------------\n\nTITLE: Response Struct Definition in Go\nDESCRIPTION: Simple struct to represent the response payload returned by the cron job API endpoint.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cron_job_definition_init.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype Response struct {\n    Message string\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Slack App Manifest in YAML\nDESCRIPTION: YAML configuration for creating a Slack app with a slash command and bot user. It defines the app's display information, features, and OAuth scopes.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/slack-bot.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n_metadata:\n  major_version: 1\ndisplay_information:\n  name: Encore Bot\n  description: Cowsay for the cloud age.\nfeatures:\n  slash_commands:\n    - command: /cowsay\n      # Replace $APP_ID below\n      url: https://staging-$APP_ID.encr.app/cowsay\n      description: Say things with a flair!\n      usage_hint: your message here\n      should_escape: false\n  bot_user:\n    display_name: encore-bot\n    always_online: true\noauth_config:\n  scopes:\n    bot:\n      - commands\n      - chat:write\n      - chat:write.public\nsettings:\n  org_deploy_enabled: false\n  socket_mode_enabled: false\n  token_rotation_enabled: false\n```\n\n----------------------------------------\n\nTITLE: Package.json Prisma Postinstall Script\nDESCRIPTION: Configures a postinstall script to generate Prisma client during package installation, ensuring compatibility with Encore Cloud deployment\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/orms/prisma.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"postinstall\": \"npx prisma generate --schema=users/prisma/schema.prisma\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Logging In to Encore\nDESCRIPTION: The `encore auth login` command authenticates a user with the Encore platform. It typically prompts for credentials.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n$ encore auth login\n```\n\n----------------------------------------\n\nTITLE: Invalid Config Structure Definition in Go\nDESCRIPTION: Demonstrates an error case where a configuration struct contains an unexported field 'subField' which is not allowed in Encore's config.Load context. The code fails because unexported fields cannot be initialized by Encore's configuration system.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/config_err_unexported_field.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/config\"\n)\n\ntype SubType struct {\n    subField string\n}\n\ntype Config struct {\n    FooEnabled bool\n    Sub        SubType\n}\n\nvar Cfg = config.Load[Config]()\n\n//encore:api\nfunc Subscriber1(ctx context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Form for Multiple File Uploads\nDESCRIPTION: This HTML form allows users to select multiple files for upload. The 'multiple' attribute on the file input field enables the selection of multiple files. The form submits to the '/upload-multiple' endpoint using the POST method and multipart/form-data encoding.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/how-to/file-uploads.md#2025-04-21_snippet_5\n\nLANGUAGE: html\nCODE:\n```\n<form method=\"POST\" enctype=\"multipart/form-data\" action=\"/upload-multiple\">\n    <label for=\"filefield\">Multiple files upload:</label><br>\n    <input type=\"file\" name=\"filefield\" multiple>\n    <input type=\"submit\">\n</form>\n```\n\n----------------------------------------\n\nTITLE: React Frontend Integration with Clerk\nDESCRIPTION: Example React component showing how to use Clerk's useAuth hook to handle authentication state and token retrieval\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/clerk-auth.md#2025-04-21_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useAuth } from '@clerk/clerk-react';\n \nexport default function ExternalDataPage() {\n  const { getToken, isLoaded, isSignedIn } = useAuth();\n \n  if (!isLoaded) {\n    // Handle loading state however you like\n    return <div>Loading...</div>;\n  }\n \n  if (!isSignedIn) {\n    // Handle signed out state however you like\n    return <div>Sign in to view this page</div>;\n  }\n \n  const fetchDataFromExternalResource = async () => {\n    const token = await getToken();\n    // Use token to send to Encore backend when fetching data\n    return data;\n  }\n \n  return <div>...</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Overlay Print Function in Go\nDESCRIPTION: This snippet defines the `OverlayPrint` function, which prints \"Hello, overlay world!\" to standard error using the `fmt` and `os` packages. This overlay is called from the `main` function within the overlay, allowing the printing of text to stderr.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/compiler/build/testdata/overlay.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\npackage main\nimport (\"fmt\"; \"os\")\nfunc OverlayPrint() {\n    fmt.Fprintln(os.Stderr, \"Hello, overlay world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Calling a Raw Endpoint with curl\nDESCRIPTION: This shell command demonstrates how to call the raw endpoint defined in the previous code snippet using `curl`. It sends a GET request to the specified endpoint (`http://localhost:4000/raw`) and prints the response to the console. It assumes the Encore.ts application is running locally on port 4000.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/raw-endpoints.mdx#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ curl http://localhost:4000/raw\nHello, raw world!\n\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image with Specific Services and Gateways using Encore CLI - Bash\nDESCRIPTION: This snippet demonstrates how to build a Docker image using the Encore CLI, specifying particular services and gateways to include in the Docker image. The image is tagged with the desired name and version using 'MY-IMAGE:TAG'. It is especially useful for selectively including components in the Docker image.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/self-host.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nencore build docker --services=service1,service2 --gateways=api-gateway MY-IMAGE:TAG\n```\n\n----------------------------------------\n\nTITLE: Invalid Global Middleware Definition\nDESCRIPTION: Example of incorrectly defined middleware in the global scope without the required 'global' directive.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/middleware_err_not_in_service.txt#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n//encore:middleware target=all\nfunc AllInSvc(req middleware.Request, next middleware.Next) middleware.Response {\n    return next(req)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Parameters and API Endpoint - Go\nDESCRIPTION: This snippet defines a Params struct for the API endpoint 'Foo' and implements the endpoint function. It accepts a context.Context and a pointer to Params, returning an error. The Params struct includes fields for a string, a byte array, and an integer.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/request_params.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// basic.go --\npackage basic\n\nimport \"context\"\n\ntype Params struct {\n    String string   `json:\\\",omitempty\\\"`\n    Array  [3]byte  `json:\\\",omitempty\\\"`\n    Int int\n}\n\n//encore:api public\nfunc Foo(ctx context.Context, p *Params) error { return nil }\n\n```\n\n----------------------------------------\n\nTITLE: Internal Configuration Unmarshaling for DsConfig in Go with Encore\nDESCRIPTION: This snippet contains the function for unmarshaling DsConfig from a JSON representation into the Go struct. It integrates with Encore's config loading to ensure configurations are handled robustly and efficiently.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/merge_identical_comments.txt#2025-04-21_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfunc encoreInternalTypeConfigUnmarshaler_svc_DsConfig(itr *jsoniter.Iterator, path []string) (obj DsConfig) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"Foo\":\n\t\t\tobj.Foo = config.CreateValue[string](itr.ReadString(), append(path, \"Foo\"))\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying Application to Encore Cloud using Git\nDESCRIPTION: This snippet demonstrates how to deploy the application to Encore Cloud by adding changes, committing, and pushing to the 'encore' remote. This process integrates the Slack notification functionality and is part of the final steps for cloud deployment.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_29\n\nLANGUAGE: shell\nCODE:\n```\n$ git add -A .\n$ git commit -m 'Add slack integration'\n$ git push encore\n```\n\n----------------------------------------\n\nTITLE: Using Encore CLI Commands with Specific Namespaces\nDESCRIPTION: This snippet shows how to use the --namespace flag with various Encore CLI commands to specify a particular namespace for operations such as running the app, opening a database shell, or resetting databases.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/infra-namespaces.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# Run the app using the \"my-ns\" namespace\n$ encore run --namespace my-ns\n\n# Open a database shell to the \"my-ns\" namespace\n$ encore db shell DATABASE_NAME --namespace my-ns\n\n# Reset all databases within the \"my-ns\" namespace\n$ encore db reset --all --namespace my-ns\n```\n\n----------------------------------------\n\nTITLE: Bucket Creation with Encore Storage\nDESCRIPTION: This code demonstrates how to create a bucket in Encore using the `Bucket` class. It initializes a bucket named \"profile-pictures\" and sets the `versioned` option to false. The bucket is then exported as a constant for use throughout the application.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Bucket } from \"encore.dev/storage/objects\";\n\nexport const profilePictures = new Bucket(\"profile-pictures\", {\n  versioned: false\n});\n```\n\n----------------------------------------\n\nTITLE: Calling an External Service Function in Go\nDESCRIPTION: This code snippet demonstrates calling a function from another Encore service using a public API method `Baz`. It imports the `svca` package and invokes its `Foo` method, passing the context to perform operations defined in the `svca` service.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/api_call_servicestruct.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage svcb\n\nimport (\"context\"; \"example.com/svca\")\n\n//encore:api public\nfunc Baz(ctx context.Context) error { return svca.Foo(ctx) }\n```\n\n----------------------------------------\n\nTITLE: Querying a single row with raw SQL using TypeScript\nDESCRIPTION: This TypeScript function `getTodoTitle` demonstrates how to query a single row from the `todo_item` table using `db.rawQueryRow` and a raw SQL query with parameters. It retrieves the `title` column based on the provided `id`.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/databases.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n\"async function getTodoTitle(id: number): string | undefined {\n  const row = await db.rawQueryRow(\\\"SELECT title FROM todo_item WHERE id = $1\\\", id);\n  return row?.title;\n}\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Raw HTTP Endpoint with Encore\nDESCRIPTION: This code defines a raw HTTP endpoint `Foo` using the `//encore:api public raw` annotation.  The `Foo` function takes an `http.ResponseWriter` and `http.Request` as arguments, allowing direct handling of HTTP requests and responses. This function doesn't return any value.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/raw_endpoint.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage code\nimport \"net/http\"\n\n//encore:api public raw\nfunc Foo(w http.ResponseWriter, req *http.Request) {}\n```\n\n----------------------------------------\n\nTITLE: Configuring PubSub Subscriptions with Custom Handlers\nDESCRIPTION: Sets up PubSub subscriptions with custom configuration including retry policies, deadlines, and message retention. Defines two subscriptions to BasicTopic with different handlers and configurations.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nvar (\n    _ = pubsub.NewSubscription(shared.BasicTopic, \"basic-subscription\",\n        pubsub.SubscriptionConfig {\n            Handler: Subscriber1,\n            MaxConcurrency: 25,\n            AckDeadline: 45 * time.Second,\n            MessageRetention: 5 * time.Hour * 24 + -10 * time.Hour,\n            RetryPolicy: &pubsub.RetryPolicy{\n                MaxRetries: 3,\n                MinBackoff: 8 * time.Second,\n                MaxBackoff: 32 * time.Minute,\n            },\n        },\n    )\n\n    _ = pubsub.NewSubscription(shared.BasicTopic, \"another-subscription\",\n        pubsub.SubscriptionConfig { Handler: domain.SubscriptionCode },\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Serving Templates from Dynamic Paths with EJS in Encore.ts\nDESCRIPTION: This snippet shows how to serve templates based on a dynamic path parameter. It uses `currentRequest` to extract the path from the request and then renders the corresponding template file. It defaults to `index.html` if no path is provided. It also configures the content type to `text/html` before sending the response.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/frontend/template-engine.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\nimport { APICallMeta, currentRequest } from \"encore.dev\";\nimport ejs, { Options } from \"ejs\";\n\nconst BASE_PATH = \"./template/views\";\nconst ejsOptions: Options = { views: [BASE_PATH] };\n\nexport const servePathTemplate = api.raw(\n  { expose: true, path: \"/!path\", method: \"GET\" },\n  async (req, resp) => {\n    const { path } = (currentRequest() as APICallMeta).pathParams;\n    const viewPath = `${BASE_PATH}/${path ?? \"index\"}.html`;\n    const html = await ejs.renderFile(viewPath, ejsOptions);\n    resp.setHeader(\"content-type\", \"text/html\");\n    resp.end(html);\n  },\n);\n\n```\n\n----------------------------------------\n\nTITLE: Archiving Secret Value\nDESCRIPTION: The `encore secret archive` command archives a secret value based on its ID.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_24\n\nLANGUAGE: shell\nCODE:\n```\n$ encore secret archive <id>\n```\n\n----------------------------------------\n\nTITLE: Defining Pub/Sub Topic in Go with Encore\nDESCRIPTION: This snippet defines a pub/sub topic using Encore's pubsub package. It creates a BasicTopic with a custom MessageType and configures it for at-least-once delivery.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_subscriber_creates_service.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage shared\n\nimport (\n    \"encore.dev/pubsub\"\n)\n\ntype MessageType struct {\n    Name string\n}\n\nvar (\n    BasicTopic = pubsub.NewTopic[*MessageType](\"basic-topic\", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Raw API Endpoint in Encore - Go\nDESCRIPTION: This snippet defines a public raw API endpoint using the Encore framework. Raw APIs involve handling HTTP requests directly using the net/http package. There are no explicit parameters for the 'API' function as it's intended to demonstrate a placeholder function signature.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_raw_call.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"net/http\"\n)\n\n//encore:api public raw\nfunc API(w http.ResponseWriter, req *http.Request) { }\n```\n\n----------------------------------------\n\nTITLE: Connecting to Database via Shell\nDESCRIPTION: The `encore db shell` command opens a psql shell connected to the specified database.  It defaults to the local environment but can connect to other environments using the `--env` flag.  Permissions can be modified using `--write`, `--admin`, and `--superuser` flags.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\n$ encore db shell <database-name> [--env=<name>]\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest Command Line in VS Code\nDESCRIPTION: This snippet shows how to configure VS Code settings to use `encore test` as the command line for running Vitest tests. Adding this configuration in `.vscode/settings.json` ensures a seamless integration of the Vitest extension in the IDE for an enhanced development experience.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/testing.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"vitest.commandLine\\\": \\\"encore test\\\"\\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing a Redis Cache Cluster in Go with Encore\nDESCRIPTION: Creates a new cache cluster named 'my-cache-cluster' with the AllKeysLRU eviction policy using Encore's caching API. This will be provisioned as a Redis instance by Encore at deployment time.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/caching.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport \"encore.dev/storage/cache\"\n\nvar MyCacheCluster = cache.NewCluster(\"my-cache-cluster\", cache.ClusterConfig{\n    // EvictionPolicy tells Redis how to evict keys when the cache reaches\n    // its memory limit. For typical cache use cases, cache.AllKeysLRU is a good default.\n    EvictionPolicy: cache.AllKeysLRU,\n})\n```\n\n----------------------------------------\n\nTITLE: Defining API Endpoint with Encore in Go\nDESCRIPTION: This snippet defines a basic API endpoint using Encore in Go. It requires the Go programming language and the Encore framework to function. The function takes a context and returns an error. No specific parameters are required for this function and it is expected to return nil as the placeholder.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_no_config.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n)\n\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Form for Single File Upload\nDESCRIPTION: This HTML form provides a file input field and a submit button, allowing users to select a single file for upload.  The form's method is set to POST, the enctype is set to multipart/form-data, and the action is set to /upload.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/how-to/file-uploads.md#2025-04-21_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<form method=\"POST\" enctype=\"multipart/form-data\" action=\"/upload\">\n    <label for=\"filefield\">Single file upload:</label><br>\n    <input type=\"file\" name=\"filefield\">\n    <input type=\"submit\">\n</form>\n```\n\n----------------------------------------\n\nTITLE: Testing Auth Info Override in Go with Encore\nDESCRIPTION: Test suite verifying authentication override functionality including user ID persistence, reset between tests, and propagation to API calls. Uses Encore's testing utilities and auth package.\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/et_override_user.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc TestOverrideAuthInfo(t *testing.T) {\n    curr, _ := auth.UserID()\n    if curr != \"\" {\n        t.Fatalf(\"got uid %q, want %q\", curr, \"\")\n    }\n\n    et.OverrideAuthInfo(\"foo\", nil)\n\n    curr, _ = auth.UserID()\n    if curr != \"foo\" {\n        t.Fatalf(\"got uid %q, want %q\", curr, \"foo\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Data into a Database in Encore\nDESCRIPTION: Example of inserting data into a SQL database using Encore's sqldb package. The function uses the Exec method to execute an INSERT statement with parameterized values.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/code-snippets.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nimport \"encore.dev/storage/sqldb\"\n\n// insert inserts a todo item into the database.\nfunc insert(ctx context.Context, id, title string, done bool) error {\n\t_, err := tododb.Exec(ctx, `\n\t\tINSERT INTO todo_item (id, title, done)\n\t\tVALUES ($1, $2, $3)\n\t`, id, title, done)\n\treturn err\n}\n```\n\n----------------------------------------\n\nTITLE: SQL Database Configuration in JSON\nDESCRIPTION: Configuration for SQL databases, including host, TLS settings, and database-specific settings like connection limits and credentials.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"sql_servers\": [\n    {\n      \"host\": \"db.myencoreapp.com:5432\",\n      \"tls_config\": {\n        \"disabled\": false,\n        \"ca\": \"---BEGIN CERTIFICATE---\\n...\",\n        \"disable_tls_hostname_verification\": false,\n        \"disable_ca_verification\": false\n      },\n      \"databases\": {\n        \"my-database\": {\n          \"name\": \"my-postgres-db-name\",\n          \"max_connections\": 100,\n          \"min_connections\": 10,\n          \"username\": \"db_user\",\n          \"password\": {\n            \"$env\": \"DB_PASSWORD\"\n          }\n        }\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Cache Cluster in Encore\nDESCRIPTION: Shows how to create a Redis cache cluster in Encore. The cluster is configured with an eviction policy that determines how keys are removed when memory limits are reached.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/code-snippets.md#2025-04-21_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nimport \"encore.dev/storage/cache\"\n\nvar MyCacheCluster = cache.NewCluster(\"my-cache-cluster\", cache.ClusterConfig{\n    // EvictionPolicy tells Redis how to evict keys when the cache reaches\n    // its memory limit. For typical cache use cases, cache.AllKeysLRU is a good default.\n    EvictionPolicy: cache.AllKeysLRU,\n})\n```\n\n----------------------------------------\n\nTITLE: Generating API Clients with Encore CLI\nDESCRIPTION: Examples of using the 'encore gen client' command to generate API clients for different languages and environments.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/client-generation.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# Generate a TypeScript client for calling the hello-a8bc application based on the primary environment\nencore gen client hello-a8bc --output=./client.ts\n\n# Generate a Go client for the hello-a8bc application based on the locally running code\nencore gen client hello-a8bc --output=./client.go --env=local\n\n# Generate an OpenAPI client for the hello-a8bc application based on the primary environment\nencore gen client hello-a8bc --lang=openapi --output=./openapi.json\n```\n\n----------------------------------------\n\nTITLE: Configuring Infrastructure for Self-hosting URL Shortener\nDESCRIPTION: Infrastructure configuration for self-hosting the URL shortener service with a PostgreSQL database. Specifies database connection details including host, username and password requirements.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/rest-api.mdx#2025-04-21_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"$schema\": \"https://encore.dev/schemas/infra.schema.json\",\n   \"sql_servers\": [\n      {\n         \"host\": \"my-db-host:5432\",\n         \"databases\": {\n            \"url\": {\n               \"username\": \"my-db-owner\",\n                \"password\": {\"$env\": \"DB_PASSWORD\"}\n            }\n         }\n      }\n   ]\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Encore Frontend Client\nDESCRIPTION: This command generates a frontend request client for the specified Encore application. It uses the application ID, output path for the generated client file, and the target environment. The generated client provides type-safe access to backend services from the frontend.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/frontend/request-client.mdx#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n\"$ encore gen client <ENCORE-APP-ID> --output=./src/client.ts --env=<ENV_NAME>\"\n```\n\n----------------------------------------\n\nTITLE: Defining Config struct for Encore service in Go\nDESCRIPTION: This snippet defines the `Config` struct, which is used to load configuration values for the service using `encore.dev/config`. The config struct contains fields utilizing other config structs defined in `utils` and `helpers`.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/types_from_multiple_packages.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype Config struct {\n    A helpers.ExtraConfig\n    B utils.ExtraConfig\n    C helpers.ExtraConfig\n    D utils.ExtraConfig\n    E helpers.SingleUse\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking Individual Endpoints for Encore Testing\nDESCRIPTION: Shows how to mock a specific API endpoint for an individual test. This approach uses et.MockEndpoint to provide a test implementation that returns predefined data.\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_33\n\nLANGUAGE: go\nCODE:\n```\nfunc Test_Something(t *testing.T) {\n    t.Parallel()\n    \n    et.MockEndpoint(products.GetPrice, func(ctx context.Context, p *products.PriceParams) (*products.PriceResponse, error) {\n        return &products.PriceResponse{Price: 100}, nil\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript paths for Encore\nDESCRIPTION: This JSON snippet shows how to configure the `paths` option in the `tsconfig.json` file to allow TypeScript to resolve imports from the `encore.dev` library. This is necessary for using Encore's features within a NestJS project.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/how-to/nestjs.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"compilerOptions\": {\n      \"paths\": {\n         \"~encore/*\": [\n            \"./encore.gen/*\"\n         ]\n      }\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Logto Configuration in TypeScript\nDESCRIPTION: This snippet demonstrates how to update the Logto configuration to include the API resource for requesting access tokens for the Encore API. The 'resources' field in the 'LogtoConfig' is updated to inform Logto of the API resource requirement.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/logto-auth.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LogtoConfig } from '@logto/react';\n\nconst config: LogtoConfig = {\n  // ...other configs\n  resources: ['<your-api-resource-indicator>'],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Type and Using it Without Argument in Go\nDESCRIPTION: This code defines a generic type `Generic` with a type parameter `T`. It then uses this generic type as a field in the `Params` struct, but it does not provide a type argument. This causes a missing type argument error during parsing. The error is highlighted in the 'want: errors' section of the test.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/missing_generic_param.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage foo\n\nimport \"context\"\n\ntype Params struct {\n    C *Generic\n}\n\ntype Generic[T any] struct {\n    Val *T\n}\n\n//encore:api public\nfunc Dummy(ctx context.Context, p *Params) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration for BsConfig in Encore (Go)\nDESCRIPTION: This snippet defines the BsConfig structure and handles its configuration loading in the Encore framework. The structure has a field 'Foo' of type config.String, intended for configuration management.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/merge_identical_comments.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n)\n\ntype BsConfig struct{\n    Foo config.String // Some extra comment\n}\n\nvar _ = config.Load[BsConfig]()\n```\n\n----------------------------------------\n\nTITLE: Defining PubSub Message Type and Topic in Go with Encore\nDESCRIPTION: This snippet defines a MessageType struct with a PubSub attribute and creates a BasicTopic using Encore's pubsub package. It demonstrates the use of custom message types and topic configuration in Encore's PubSub system.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_attributes_not_start_encore.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage shared\n\nimport (\n    \"encore.dev/pubsub\"\n)\n\ntype MessageType struct {\n    Name string `pubsub-attr:\"encorename\"`\n}\n\nvar BasicTopic = pubsub.NewTopic[*MessageType](\"same-name\", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })\n```\n\n----------------------------------------\n\nTITLE: Running All Semgrep Rules\nDESCRIPTION: Command to execute all semgrep rules in a directory against a codebase\nSOURCE: https://github.com/encoredev/encore/blob/main/tools/semgrep-rules/semgrep-go/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsemgrep -f path/to/semgrep-go/ .\n```\n\n----------------------------------------\n\nTITLE: Getting Object Attributes in Encore\nDESCRIPTION: This snippet illustrates how to retrieve object attributes using the `attrs` method and check object existence with the `exists` method in Encore's object storage.  `attrs` returns metadata about the object, while `exists` returns a boolean.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst attrs = await profilePictures.attrs(\"my-image.jpeg\");\nconst exists = await profilePictures.exists(\"my-image.jpeg\");\n```\n\n----------------------------------------\n\nTITLE: Defining API Schema with Unsupported Interface in Go\nDESCRIPTION: This snippet defines a struct 'Params' with an unsupported 'any' type and a public API function 'Any'. The use of 'any' (an interface type) in API schemas is not supported by Encore, resulting in an error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_err_any.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n)\n\ntype Params struct {\n    Foo any\n}\n\n//encore:api public\nfunc Any(ctx context.Context, p *Params) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Deploying to Encore's Development Cloud in Shell\nDESCRIPTION: These shell commands add changes to the repository, commit them with a message, and push the code to Encore's development cloud, triggering a CI/CD process for deployment. Requires git and an Encore account.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\n$ git add -A .\n$ git commit -m 'Initial commit'\n$ git push encore\n```\n\n----------------------------------------\n\nTITLE: Defining API Response Structure in Go\nDESCRIPTION: This code snippet defines a struct named Response which holds the data structure for the API's response, containing an exported boolean and an unexported string. It serves to standardize response formats across API calls.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/unexported.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport \"context\"\n\ntype Response struct {\n    Exported bool\n    unexported string\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Configuration Type Definition in Go\nDESCRIPTION: Shows an invalid configuration structure where config.Value is nested within another config.Value, which is not allowed in Encore's configuration system. The code demonstrates what not to do when defining configuration types.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/config_err_wrapper_used_in_wrapper.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    \"encore.dev/config\"\n)\n\ntype Config struct {\n    Name config.Value[config.Value[string]]\n}\n\nvar cfg = config.Load[Config]()\n\n\n// encore:api\nfunc Subscriber1(ctx context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Main Program in Go\nDESCRIPTION: This Go program contains a simple main function that prints 'Hello, world!' to the standard output. There are no specific dependencies apart from Go itself. This is commonly used as an introductory example to demonstrate basic program execution in Go.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/compiler/build/testdata/basic.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\nfunc main() {\n    println(\"Hello, world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic API Endpoint with Encore in Go\nDESCRIPTION: Defines a simple API function named MyAPI, which does nothing and returns a nil error. This function is an API endpoint in the Encore framework and leverages the context package for request handling.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_config.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Current Request Handler in Go\nDESCRIPTION: Public API endpoint that returns information about the current request including the path and cron idempotency key. Uses Encore's CurrentRequest() functionality.\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/encore_currentrequest.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public\nfunc CurrentRequest(ctx context.Context) (*RequestData, error) {\n    req := encore.CurrentRequest()\n    return &RequestData{\n        Path: req.Path,\n        IdempotencyKey: req.CronIdempotencyKey,\n    }, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple API Endpoint in Go\nDESCRIPTION: This snippet defines a basic API endpoint named `MyAPI` using the `//encore:api` directive. The function takes a context as input and returns an error. In this example, the API endpoint simply returns `nil`, indicating no error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_inline_struct.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Pub/Sub Topic in Go with Encore\nDESCRIPTION: This snippet shows how to create a subscription to the defined pub/sub topic. It sets up a subscription named 'foo-service-sub' with a handler function that processes incoming messages.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_subscriber_creates_service.txt#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\npackage foo\n\nimport (\n    \"context\"\n\n    \"encore.dev/pubsub\"\n\n    \"test/shared\"\n)\n\nvar _ = pubsub.NewSubscription(\n    shared.BasicTopic,\n    \"foo-service-sub\",\n    pubsub.SusbcriptionConfig { Handler: func(ctx context.Context, msg *shared.MessageType) error {\n        return nil\n    }},\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring sqlc - YAML\nDESCRIPTION: This YAML configuration sets up sqlc to generate Go code from SQL queries and schemas, specifying the database type and paths to the query and migration files.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nversion: \"2\"\nsql:\n  - engine: \"postgresql\"\n    queries: \"db/query.sql\"\n    schema: \"./db/migrations\"\n    gen:\n      go:\n        package: \"db\"\n        out: \"db\"\n        sql_package: \"pgx/v5\"\n\n```\n\n----------------------------------------\n\nTITLE: Configuring PubSub Topic and Subscription in Go\nDESCRIPTION: Sets up a PubSub topic and subscription with at-least-once delivery guarantee. Includes a handler that logs pubsub events with request information.\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/encore_currentrequest.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nvar topic = pubsub.NewTopic[*Event](\"topic\", pubsub.TopicConfig{\n    DeliveryGuarantee: pubsub.AtLeastOnce,\n})\n\nvar _ = pubsub.NewSubscription(topic, \"sub\", pubsub.SubscriptionConfig[*Event]{\n    Handler: func(ctx context.Context, event *Event) error {\n        req := encore.CurrentRequest()\n        rlog.Info(\"pubsub event\",\n            \"type\", req.Type,\n            \"msg\", req.Message,\n        )\n        return nil\n    },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining TypeScript Interface in External File\nDESCRIPTION: This code defines a 'foo' interface in a separate 'foo.ts' file. The interface has a single property 'bar' of type string, providing a simple data structure that can be imported by other modules.\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/src/parser/types/testdata/reexport_single.txt#2025-04-21_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface foo {\n  bar: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Helper Config Definitions in Encore - Golang\nDESCRIPTION: Defines 'ExtraConfig' and 'SingleUse' structs in the 'helpers' package for additional configuration using Encore. The 'ExtraConfig' struct includes a string 'Foo' and a 'Baz' as a dynamic value, and 'SingleUse' tracks if a resource should be locked.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/name_conflicts.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage helpers\n\nimport (\n\t\"encore.dev/config\"\n)\n\ntype ExtraConfig struct{\n    Foo config.String\n    Baz config.Value[[]byte]\n}\n\ntype SingleUse struct {\n    Lock bool\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Rewritten Hello World in Go\nDESCRIPTION: This snippet also defines a main function that prints 'Hello, rewritten world!' to the console, showcasing an alternative implementation. The required dependency is the Go programming language, with no parameters and a string as output.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/compiler/build/testdata/rewrite.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\nfunc main() {\n    println(\"Hello, rewritten world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Encore Service in Go\nDESCRIPTION: This snippet defines a minimal Encore service with a public API method `Foo`. The `Service` struct represents the service, and the `Foo` method is designed to be called with a context. It does not perform any operation and returns nil.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/api_call_servicestruct.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svca\n\nimport \"context\"\n\n//encore:service\ntype Service struct{}\n\n//encore:api public\nfunc (s *Service) Foo(context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Initializing PubSub Topics in Go\nDESCRIPTION: This snippet demonstrates the initialization of a PubSub topic using Encore's PubSub integration in Go. The pubsub.NewTopic function is used to create a topic with a specific type and configuration. The init function illustrates how to pass the initialized topic to a function. This setup is essential for apps requiring message delivery with at least once guarantee.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_topic_invalid_usage.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport (\n    \"encore.dev/pubsub\"\n)\n\ntype MessageType struct {\n    Name string\n}\n\nvar BasicTopic = pubsub.NewTopic[*MessageType](\"same-name\", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })\n\nfunc SomeFunc(t *pubsub.Topic[*MessageType]) {}\n\nfunc init() {\n    SomeFunc(BasicTopic)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing API Endpoint Foo in Encore for Go\nDESCRIPTION: This snippet defines a public API function named Foo which accepts a context parameter and currently returns nil. It serves as a placeholder for further API logic. Dependencies include 'context'.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/sqldb_cross_service.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n//encore:api public\nfunc Foo(ctx context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining API Endpoint in Go\nDESCRIPTION: Defines a simple API endpoint `MyAPI` using the `//encore:api` annotation. This endpoint takes a context as input and returns an error.  It shows the basic structure for defining APIs with Encore.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_config.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Outbox Table in SQL\nDESCRIPTION: This SQL snippet creates the necessary 'outbox' table for storing transactional Pub/Sub messages. It includes columns for id, topic, data, and insertion timestamp.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/pubsub-outbox.md#2025-04-21_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE outbox (\n    id BIGSERIAL PRIMARY KEY,\n    topic TEXT NOT NULL,\n    data JSONB NOT NULL,\n    inserted_at TIMESTAMPTZ NOT NULL\n);\nCREATE INDEX outbox_topic_idx ON outbox (topic, id);\n```\n\n----------------------------------------\n\nTITLE: Duplicate Cron Job Definition in Go\nDESCRIPTION: Attempts to define another cron job with the same name 'cronfood' but different schedule (runs every Thursday), which causes a validation error due to duplicate names.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cron_job_definition_repeat.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nvar _ = cron.NewJob(\"cronfood\", cron.JobConfig{\n\tTitle:    \"Cron Foo Bar Bazz\",\n\tSchedule: \"* * * * 4\",\n\tEndpoint: Cron,\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS SNS/SQS in Encore\nDESCRIPTION: Configuration for AWS SNS topics and SQS queues with their respective ARNs for pub/sub functionality.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"pubsub\": [\n    {\n      \"type\": \"aws_sns_sqs\",\n      \"topics\": {\n        \"my-topic\": {\n          \"arn\": \"arn:aws:sns:us-east-1:123456789012:my-topic\",\n          \"subscriptions\": {\n            \"my-queue\": {\n              \"arn\": \"arn:aws:sqs:us-east-1:123456789012:my-queue\"\n            }\n          }\n        }\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Auth0 Authentication Provider\nDESCRIPTION: Manages authentication state, login, logout, and token validation using cookies and session storage for state management\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/auth0-auth.md#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const Auth0Provider = {\n  client: getRequestClient(),\n  isAuthenticated: () => !!Cookies.get(\"auth-token\"),\n  async login(returnTo: RedirectURL): Promise<RedirectURL> { ... },\n  async logout(): Promise<RedirectURL> { ... },\n  async validate(state: string, authCode: string): Promise<RedirectURL> { ... }\n};\n```\n\n----------------------------------------\n\nTITLE: Loading Other Configurations - Go\nDESCRIPTION: This snippet defines the OtherConfig structure with two fields (Foo and Bar) and uses the Encore framework's config.Load function for configuration loading while facilitating unmarshalling.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/multiple_configs_in_service.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"encore.dev/config\"\n)\n\ntype OtherConfig struct{\n    Foo config.String // Foo is great in Otherconfig\n    Bar config.Int\n}\n\nvar _ = config.Load[OtherConfig]()\n```\n\n----------------------------------------\n\nTITLE: Creating a Database Table in PostgreSQL\nDESCRIPTION: This SQL snippet creates a table named `users` with `id` and `name` columns, and inserts a sample row. This illustrates a basic database setup and data insertion.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/deploy-to-railway.md#2025-04-21_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\n\"     CREATE TABLE users (\\n        id SERIAL PRIMARY KEY,\\n        name TEXT\\n     );\\n     INSERT INTO users (name) VALUES ('Alice');\"\n```\n\n----------------------------------------\n\nTITLE: Defining Cron Job with Configuration in Go\nDESCRIPTION: Defines a cron job named 'cronfood' with specific configuration including title, schedule (runs every Friday), and endpoint. Also includes an additional string variable assignment.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cron_job_definition_repeat.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nvar _, bd = cron.NewJob(\"cronfood\", cron.JobConfig{\n\tTitle:    \"Cron Food Bar\",\n\tSchedule: \"* * * * 5\",\n\tEndpoint: Cron,\n}), \"barfoo\"\n```\n\n----------------------------------------\n\nTITLE: Encore API Call Implementation\nDESCRIPTION: Example of making cross-service API calls using Encore's simplified function-like syntax, with automatic type checking and error handling\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_21\n\nLANGUAGE: Go\nCODE:\n```\nimport \"encore.app/hello\"\n\n//encore:api public\nfunc MyOtherAPI(ctx context.Context) error {\n    resp, err := hello.Ping(ctx, &hello.PingParams{Name: \"World\"})\n    if err == nil {\n        log.Println(resp.Message) // \"Hello, World!\"\n    }\n    return err\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Structured Logging in Go with Encore's rlog Package\nDESCRIPTION: Demonstrates how to use the rlog package to create structured logs with Info and Error levels. The example shows logging with key-value pairs for additional context.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/observability/logging.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nrlog.Info(\"log message\",\n\t\"user_id\", 12345,\n\t\"is_subscriber\", true)\nrlog.Error(\"something went terribly wrong!\",\n\t\"err\", err)\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image with Services and Gateways - Bash\nDESCRIPTION: This snippet demonstrates how to build a Docker image for an Encore application specifying included services and gateways via command line arguments. The command allows customization of the default build behavior.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/build.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nencore build docker --services=service1,service2 --gateways=api-gateway MY-IMAGE:TAG\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple API Endpoint in Go\nDESCRIPTION: This snippet shows a basic API endpoint definition in Go using Encore. It represents a function that retrieves a price from an external API.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/develop/mocking.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n//encore:api private\nfunc GetPrice(ctx context.Context, p *PriceParams) (*PriceResponse, error) {\n    // Call external API to get the price\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages to the Topic in Go\nDESCRIPTION: This snippet shows how to publish a message to the PubSub topic. It demonstrates usage from both the 'svc' package and directly from the global scope.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/parser/resource/usage/testdata/pubsub_usage.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage usage\nimport \"example.com/svc\"\n\nvar x = svc.Topic.Publish(svc.Message{}) // use svc.Topic call Publish\nvar y = Topic.Publish(svc.Message{})\n```\n\n----------------------------------------\n\nTITLE: Configuring Global CORS in Encore\nDESCRIPTION: This JSON snippet defines the `global_cors` configuration in the `encore.app` file, allowing developers to specify allowed origins for requests both with and without credentials. The `allow_origins_without_credentials` array specifies origins that are allowed for requests without credentials, defaulting to all domains if nil. The `allow_origins_with_credentials` array specifies origins that are allowed for requests that include credentials, and may include wildcards.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/integrate-frontend.mdx#2025-04-21_snippet_6\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"global_cors\": {\n    // allow_origins_without_credentials specifies the allowed origins for requests\n    // that don't include credentials. If nil it defaults to allowing all domains\n    // (equivalent to [\"*\"]).\n    \"allow_origins_without_credentials\": [\n      \"<ORIGIN-GOES-HERE>\"\n    ],\n\n    // allow_origins_with_credentials specifies the allowed origins for requests\n    // that include credentials. If a request is made from an Origin in this list\n    // Encore responds with Access-Control-Allow-Origin: <Origin>.\n    //\n    // The URLs in this list may include wildcards (e.g. \"https://*.example.com\"\n    // or \"https://*-myapp.example.com\").\n    \"allow_origins_with_credentials\": [\n      \"<DOMAIN-GOES-HERE>\"\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Validation Rules in Request Schema\nDESCRIPTION: This snippet demonstrates how to combine validation rules using Encore.ts, ensuring that multiple conditions must be satisfied for a request to be valid.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Schema {\n  // Must be both >= 3 and <= 1000\n  count: number & (Min<3> & Max<1000>);\n\n  // Must be either a URL or an email\n  contact: string & (IsURL | IsEmail);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Topic Reference in Go with Encore Pub/Sub\nDESCRIPTION: Demonstrates how to create a reference to a Pub/Sub topic that can be passed around freely, while specifying the required permissions for static analysis.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/pubsub.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nsignupRef := pubsub.TopicRef[pubsub.Publisher[*SignupEvent]](Signups)\n\n// signupRef is of type pubsub.Publisher[*SignupEvent], which allows publishing.\n```\n\n----------------------------------------\n\nTITLE: Creating a Main Package in Go\nDESCRIPTION: This snippet defines the main package and an empty main function in Go. It serves as the entry point of the program, but initially performs no actions until modified by the overlay.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/compiler/build/testdata/overlay.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\nfunc main() {\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Labeled Metrics in Go\nDESCRIPTION: Shows how to define and use labeled metrics with a custom struct to track metrics with additional context, such as success status\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/observability/metrics.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype Labels struct {\n    Success bool\n}\n\nvar OrdersProcessed = metrics.NewCounterGroup[Labels, uint64](\"orders_processed\", metrics.CounterConfig{})\n\nfunc process(order *Order) {\n    var success bool\n    // ... populate success with true/false ...\n    OrdersProcessed.With(Labels{Success: success}).Increment()\n}\n```\n\n----------------------------------------\n\nTITLE: General Syntax for Encore Exec Command in Bash\nDESCRIPTION: This snippet provides the general syntax for using the `encore exec` command. Replace `<your-command>` with the desired command that should be executed within the initialized Encore environment.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/develop/running-scripts.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nencore exec -- <your-command>\n```\n\n----------------------------------------\n\nTITLE: Creating Encore Application for Booking System\nDESCRIPTION: Command to create a new Encore application using a starting-point branch for the booking system project. This sets up the initial project structure with a ready-to-use frontend.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ encore app create booking-system --example=github.com/encoredev/example-booking-system/tree/starting-point\n```\n\n----------------------------------------\n\nTITLE: Infrastructure Declaration with Encore\nDESCRIPTION: Demonstrate how infrastructure is defined directly in application code using type-safe objects, avoiding separate configuration files and manual maintenance\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/other/vs-terraform.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Example of infrastructure declaration\nconst database = new Postgres({\n  name: \"myapp-db\",\n  version: \"13.3\"\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing and Accessing Secrets in Go\nDESCRIPTION: This snippet demonstrates the initialization and accessing of the `secrets` struct's field `Foo` inside the `init` function. This is a common pattern to initialize secrets upon service startup.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/parser/resource/usage/testdata/secret_usage.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc init() {\n    secrets.Foo // use svc.secrets field Foo\n    x := secrets // use svc.secrets other\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an API Endpoint in Go\nDESCRIPTION: This snippet defines a basic API function 'MyAPI' within the svc package that currently returns nil, serving as a placeholder for future implementation.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/json_tags.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Test with Mocked Dependencies\nDESCRIPTION: Shows how to write a test using a mocked implementation of the sendgridClient interface. Demonstrates instantiating the service with a mock client for testing.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/dependency-injection.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc TestFoo(t *testing.T) {\n    svc := &Service{sendgridClient: &myMockClient{}}\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Encore to Latest Version\nDESCRIPTION: This shell command updates Encore to the latest version. It can be run if you suspect your Encore installation is outdated. The command updates the software and outputs the result in the terminal.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/install.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nencore version update\n```\n\n----------------------------------------\n\nTITLE: Cron Job Handler Function in Go\nDESCRIPTION: Implements the endpoint handler function for the cron job that returns a simple response structure with a message. This function is referenced as the Endpoint in the cron job configurations.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cron_job_definition_repeat.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public path=/cron\nfunc Cron(ctx context.Context) (*Response, error) {\n\tmsg := \"Hello, Cron!\"\n\treturn &Response{Message: msg}, nil\n}\n\ntype Response struct {\n\tMessage string\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Interface from Module in TypeScript\nDESCRIPTION: This code re-exports the 'foo' interface from a local './foo' module. This pattern allows for organizing code across multiple files while providing a consolidated export point.\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/src/parser/types/testdata/reexport_single.txt#2025-04-21_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport { foo } from \"./foo\";\n```\n\n----------------------------------------\n\nTITLE: Install Encore CLI\nDESCRIPTION: This snippet provides the installation commands for the Encore CLI, allowing users to set up the Encore local development environment on different operating systems.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/migration/express-migration.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbrew install encoredev/tap/encore\n```\n\nLANGUAGE: bash\nCODE:\n```\ncurl -L https://encore.dev/install.sh | bash\n```\n\nLANGUAGE: bash\nCODE:\n```\niwr https://encore.dev/install.ps1 | iex\n```\n\n----------------------------------------\n\nTITLE: Creating String Keyspace with Invalid Key Pattern\nDESCRIPTION: Attempts to create a string keyspace with a key pattern that does not use all defined key fields, which triggers a compilation error\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cache_err_keyspace_invalid.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nvar keyspace = cache.NewStringKeyspace[Key](cluster, cache.KeyspaceConfig{\n    KeyPattern: \"foo/:ID\",\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Dummy Public API in Go\nDESCRIPTION: This snippet defines a dummy public API endpoint `Dummy` for the `bar` service using the `//encore:api public` annotation. The `Dummy` function simply returns `nil`, indicating a successful operation without performing any specific logic. This showcases a basic API definition within an Encore service.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/svc_migration_db.txt#2025-04-21_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\n//encore:api public\nfunc Dummy(context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Setting Up a Subscription for the Topic in Go\nDESCRIPTION: This snippet creates a subscription to the previously defined topic. It uses a handler function that currently does nothing (returns nil). The subscription is configured under the name 'bar'.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/parser/resource/usage/testdata/pubsub_usage.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nvar Sub = pubsub.NewSubscription(Topic, \"bar\", // use svc.Topic fn pubsub.NewSubscription arg 0\n    pubsub.SubscriptionConfig{\n        Handler: func(m *Message) error {\n            return nil\n        },\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Running Encore Application Locally\nDESCRIPTION: Command to start the Encore application in the local development environment. This command runs the app and provides access to the local development dashboard.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/quick-start.mdx#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ cd your-app-name # replace with the app name you picked\n$ encore run\n```\n\n----------------------------------------\n\nTITLE: Running Encore Application\nDESCRIPTION: The `encore run` command starts your application in the local development environment. It supports flags for debugging, file watching, and specifying the port number.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ encore run [--debug] [--watch=true] [--port NUMBER] [flags]\n```\n\n----------------------------------------\n\nTITLE: Setting ENCORE_GOROOT\nDESCRIPTION: This command sets the `ENCORE_GOROOT` environment variable. `ENCORE_GOROOT` must be set to the path to the [Encore Go runtime](https://github.com/encoredev/go).  It is recommended to use the path from an existing Encore installation. This ensures the proper functioning of the Encore application by enabling it to locate the required Go runtime. The input is a string representing the path.\nSOURCE: https://github.com/encoredev/encore/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\nexport ENCORE_GOROOT=/opt/homebrew/Cellar/encore/0.16.2/libexec/encore-go\n```\n\n----------------------------------------\n\nTITLE: Sample API Access Token Response - JSON\nDESCRIPTION: This JSON snippet shows an example response from the Encore Cloud API after a successful request for an API access token. It includes the access token, its type, its expiration duration, and the actor associated with the token.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/integrations/oauth-clients.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n\"{\\\"access_token\\\":\\\"MTcyODQ3NTg3NXww...GDxfmxnuq9zDEAmHmP5D44=\\\",\\\"token_type\\\":\\\"Bearer\\\",\\\"expires_in\\\":3600, \\\"actor\\\": \\\"o2c_my_key_id\\\"}\"\n```\n\n----------------------------------------\n\nTITLE: Defining Encore API with Auth Directive in Go\nDESCRIPTION: This snippet defines an Encore API function with an auth directive. However, it results in an error because no auth handler is defined for the application.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_auth_no_authhandler.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport \"context\"\n\n//encore:api auth\nfunc API(ctx context.Context) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: Initializing API Endpoints with Encore in Go\nDESCRIPTION: This snippet initializes an API endpoint for the Foo method, registering it for handling HTTP requests. It defines request and response types, along with functions for encoding and decoding data.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/unexported.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc init() {\n    __api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Required Go Packages for Slack Bot\nDESCRIPTION: Go import statements for the packages required to implement the Slack bot, including crypto functions for HMAC verification.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/slack-bot.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"encore.dev/beta/errs\"\n\t\"encore.dev/rlog\"\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing a Counter Metric in Go\nDESCRIPTION: Demonstrates how to create a counter metric to track the number of processed orders using Encore's metrics package\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/observability/metrics.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport \"encore.dev/metrics\"\n\nvar OrdersProcessed = metrics.NewCounter[uint64](\"orders_processed\", metrics.CounterConfig{})\n\nfunc process(order *Order) {\n    // ...\n    OrdersProcessed.Increment()\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration in Go\nDESCRIPTION: This line of code uses the Encore config package to load a configuration of type Config, making the various configurations available at runtime for the service.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/generic_named_types.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nvar _ = config.Load[*Config]()\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Cron Job with Fixed Schedule\nDESCRIPTION: Creates a cron job that runs every Friday with a custom title. Uses fixed schedule pattern '* * * * 5'.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cron_job_definition.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nvar _ = cron.NewJob(\"cronfooboo\", cron.JobConfig{\n\tTitle:     \"Cron Foo Boo\",\n\tSchedule: \"* * * * 5\",\n\tEndpoint: CronAPI,\n})\n```\n\n----------------------------------------\n\nTITLE: Defining SearchResponse Struct in Go\nDESCRIPTION: Go struct definition for the SearchResponse type, representing the structure of the Pexels API response.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/meeting-notes.mdx#2025-04-21_snippet_8\n\nLANGUAGE: go\nCODE:\n```\ntype SearchResponse struct {\n\tPhotos []struct {\n\t\tId  int `json:\"id\"`\n\t\tSrc struct {\n\t\t\tMedium    string `json:\"medium\"`\n\t\t\tLandscape string `json:\"landscape\"`\n\t\t} `json:\"src\"`\n\t\tAlt string `json:\"alt\"`\n\t} `json:\"photos\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting a Namespace using Encore CLI\nDESCRIPTION: This command deletes the specified infrastructure namespace 'my-ns' along with all associated data. This is a critical operation as it cannot be undone.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/infra-namespaces.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ encore namespace delete my-ns\n```\n\n----------------------------------------\n\nTITLE: Testing GetBookableSlots API with cURL\nDESCRIPTION: Shell command to test the GetBookableSlots API endpoint using cURL, requesting bookable slots for a specific date.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncurl http://localhost:4000/slots/2024-12-01\n```\n\n----------------------------------------\n\nTITLE: Cross-Service API Call Generation\nDESCRIPTION: Generated internal method for making API calls between services using Encore's runtime API SDK\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/api_call.txt#2025-04-21_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nfunc EncoreInternal_apicalls_Foo(ctx context.Context) error {\n\t_, err := EncoreInternal_api_APIDesc_Foo.Call(__api.NewCallContext(ctx), &EncoreInternal_FooReq{})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pub/Sub Topic in TypeScript\nDESCRIPTION: Example demonstrating how to create a typed Pub/Sub topic for handling signup events using Encore.ts framework.\nSOURCE: https://github.com/encoredev/encore/blob/main/README.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Topic } \"encore.dev/pubsub\"\n\nexport interface SignupEvent {\n    userID: string;\n}\n\nexport const signups = new Topic<SignupEvent>(\"signups\", {\n    deliveryGuarantee: \"at-least-once\",\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing 404 Response for Static Files - TypeScript\nDESCRIPTION: This code snippet describes setting a custom 404 Not Found response for static file requests in Encore.ts. By specifying the `notFound` option, the system serves a custom HTML file (`not_found.html`) when a requested static file is not found, offering enhanced user experience. The setup depends on Encore.ts and a Node.js runtime.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/static-assets.mdx#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"encore.dev/api\";\n\nexport const assets = api.static(\n  { expose: true, path: \"/!path\", dir: \"./assets\", notFound: \"./not_found.html\" },\n);\n```\n\n----------------------------------------\n\nTITLE: Invalid Cron Job Definition in Go using Encore Framework\nDESCRIPTION: Demonstrates an incorrect implementation of a cron job using Encore's cron package. The code fails because the endpoint is not defined as an Encore API and the resource is defined outside of a service context.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cron_job_err_not_api.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"encore.dev/cron\"\n)\n\nvar _ = cron.NewJob(\"my-job\", cron.JobConfig{\n\tSchedule: \"* * * * 5\",\n\tEndpoint: CronFunc,\n})\n\n\nfunc CronFunc(ctx context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing PubSub Subscription in Encore\nDESCRIPTION: Configuration for creating a PubSub subscription with a handler for processing signup events, supporting method injection and event processing\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_17\n\nLANGUAGE: Go\nCODE:\n```\npubsub.SubscriptionConfig[*SignupEvent]{\n    Handler: SendWelcomeEmail,\n}\n```\n\nLANGUAGE: Go\nCODE:\n```\nvar _ = pubsub.NewSubscription(\n    user.Signups, \"send-welcome-email\",\n    pubsub.SubscriptionConfig[*SignupEvent]{\n        Handler: pubsub.MethodHandler((*Service).SendWelcomeEmail),\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Signing Up for Encore\nDESCRIPTION: The `encore auth signup` command creates a new user account on the Encore platform. It usually requires providing an email address and password.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n$ encore auth signup\n```\n\n----------------------------------------\n\nTITLE: Creating Monitor Service Database Schema\nDESCRIPTION: SQL migration to create the checks table for monitoring uptime\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_11\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE checks (\n    id BIGSERIAL PRIMARY KEY,\n    site_id BIGINT NOT NULL,\n    up BOOLEAN NOT NULL,\n    checked_at TIMESTAMP WITH TIME ZONE NOT NULL\n);\n```\n\n----------------------------------------\n\nTITLE: Environment-Based Request Handling\nDESCRIPTION: Shows how to implement different behaviors based on environment type using Encore metadata\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_30\n\nLANGUAGE: go\nCODE:\n```\nswitch encore.Meta().Environment.Type {\ncase encore.EnvTest, encore.EnvDevelopment:\n    return MarkEmailVerified(ctx, userID)\ndefault:\n    return SendVerificationEmail(ctx, userID)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Kubernetes with Encore CLI\nDESCRIPTION: Command to update kubectl configuration for a specific Encore environment. Requires specifying the environment name as a parameter.\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_42\n\nLANGUAGE: bash\nCODE:\n```\nencore k8s configure --env=ENV_NAME\n```\n\n----------------------------------------\n\nTITLE: Using Nested Array of Objects in Schema\nDESCRIPTION: This snippet demonstrates how to define a schema with an array of objects in Encore.ts, allowing for structured data validation.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/validation.mdx#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Schema {\n  users:  { name: string; age: number }[];\n}\n```\n\n----------------------------------------\n\nTITLE: Redis Configuration\nDESCRIPTION: Configuration for Redis including authentication and connection pool settings\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"redis\": {\n    \"cache\": {\n      \"host\": \"redis.myencoreapp.com:6379\",\n      \"database_index\": 0,\n      \"auth\": {\n        \"type\": \"auth\",\n        \"auth_string\": {\n          \"$env\": \"REDIS_AUTH_STRING\"\n        }\n      },\n      \"max_connections\": 50,\n      \"min_connections\": 5\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Service Discovery Configuration\nDESCRIPTION: Configuration for service discovery including base URLs and authentication settings\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"service_discovery\": {\n    \"user-service\": {\n      \"base_url\": \"https://user.myencoreapp.com\",\n      \"auth\": [\n        {\n          \"type\": \"key\",\n          \"id\": 1,\n          \"key\": {\n            \"$env\": \"USER_SERVICE_API_KEY\"\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Query\nDESCRIPTION: Sample GraphQL query for retrieving all books. This query fetches the author and title of each book in the database.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/graphql.mdx#2025-04-21_snippet_10\n\nLANGUAGE: graphql\nCODE:\n```\nquery GetBooks {\n  books {\n    author\n    title\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Restarting Encore Daemon\nDESCRIPTION: The `encore daemon` command attempts to restart the Encore daemon, which manages background processes.  This can resolve unexpected behavior.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n$ encore daemon\n```\n\n----------------------------------------\n\nTITLE: Configuring Temporal Server Address in Go\nDESCRIPTION: Sets up configuration for the Temporal server address, allowing different addresses for local and cloud environments.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/temporal.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage greeting\n\nimport \"encore.dev/config\"\n\ntype Config struct {\n    TemporalServer string\n}\n\nvar cfg = config.Load[*Config]()\n```\n\nLANGUAGE: cue\nCODE:\n```\npackage greeting\n\nTemporalServer: [\n\t// These act as individual case statements\n    if #Meta.Environment.Cloud == \"local\" { \"localhost:7233\" },\n\n    // TODO: configure this to match your own cluster address\n    \"my.cluster.address:7233\",\n][0] // Return the first value which matches the condition\n```\n\n----------------------------------------\n\nTITLE: Initializing Configuration in Service Package\nDESCRIPTION: Defines a configuration struct with various types and uses Encore's config.Load method for configuration management\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/multiple_configs_in_service.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype Config struct {\n    Name        string    // The users name\n    Port        uint16\n    ReadOnly    bool      // true if we're in read only mode\n}\n\nvar _ = config.Load[*Config]()\n```\n\n----------------------------------------\n\nTITLE: Cloning an Encore Application\nDESCRIPTION: The `encore app clone` command downloads an existing Encore application to your local machine. It requires the app ID and the target directory.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ encore app clone [app-id] [directory]\n```\n\n----------------------------------------\n\nTITLE: External Package Endpoint\nDESCRIPTION: Defines a private API endpoint in an external package that returns nil. Used as a target for the external cron job.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cron_job_definition.txt#2025-04-21_snippet_7\n\nLANGUAGE: go\nCODE:\n```\n//encore:api private\nfunc Endpoint(ctx context.Context) error {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Secret Value\nDESCRIPTION: The `encore secret set` command sets the value of a secret. The `--type` flag specifies the environments to which the secret applies.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_22\n\nLANGUAGE: shell\nCODE:\n```\n$ encore secret set --type <types> <secret-name>\n```\n\n----------------------------------------\n\nTITLE: Printing Hello World in Go\nDESCRIPTION: This snippet contains the main function of a Go program that prints 'Hello, world!' to the console. The primary dependency is the Go programming language itself. It takes no parameters and outputs a string to standard output.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/compiler/build/testdata/rewrite.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\nfunc main() {\n    println(\"Hello, world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Cross-Service Config Access in Encore\nDESCRIPTION: Demonstrates an invalid usage pattern where a library attempts to access a service's configuration. This violates Encore's requirement that configurations can only be accessed within the service that loaded them.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/config_err_use_from_other_service.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage foo\n\nimport (\n    \"test/svc\"\n)\n\nfunc init() {\n    if svc.Cfg.FooEnabled {\n        // do something\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring GCP Pub/Sub in Encore\nDESCRIPTION: This snippet demonstrates how to configure Google Cloud Platform Pub/Sub in an Encore application. It defines a topic named 'user-events' with a subscription 'user-notification' that uses push configuration.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"pubsub\": [\n    {\n      \"type\": \"gcp_pubsub\",\n      \"project_id\": \"my-gcp-project\",\n      \"topics\": {\n        \"user-events\": {\n          \"name\": \"user-events-topic\",\n          \"project_id\": \"my-gcp-project\",\n          \"subscriptions\": {\n            \"user-notification\": {\n              \"name\": \"user-notification-subscription\",\n              \"push_config\": {\n                \"id\": \"user-push\",\n                \"service_account\": \"service-account@my-gcp-project.iam.gserviceaccount.com\"\n              }\n            }\n          }\n        }\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Generating API Access Token with cURL - Bash\nDESCRIPTION: This Bash command demonstrates how to make a request to the Encore Cloud OAuth token endpoint to generate an API access token using cURL. It requires the client ID and client secret to be set as environment variables and conforms to the OAuth 2.0 client credentials grant request format.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/integrations/oauth-clients.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n\"curl -d \\\"client_id=${OAUTH_CLIENT_ID}\\\" -d \\\"client_secret=${OAUTH_CLIENT_SECRET}\\\" \\\\n     -d \\\"grant_type=client_credentials\\\" \\\"https://api.encore.cloud/api/oauth/token\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Defining Service with Encore.ts\nDESCRIPTION: Create a service definition using Encore's Service primitive, which groups related files and functionality\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/quick-start.mdx#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Service } from \"encore.dev/service\";\n\nexport default new Service(\"hello\");\n```\n\n----------------------------------------\n\nTITLE: Authentication Methods Configuration in JSON\nDESCRIPTION: Configuration for authentication methods, demonstrating how to set up a shared key authentication.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"auth\": [\n    {\n      \"type\": \"key\",\n      \"id\": 1,\n      \"key\": {\n        \"$env\": \"SERVICE_API_KEY\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Slack Signing Secret in Go\nDESCRIPTION: Go code for defining a struct to hold the Slack signing secret. This is used for securing the webhook endpoint.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/slack-bot.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nvar secrets struct {\n\tSlackSigningSecret string\n}\n```\n\n----------------------------------------\n\nTITLE: Starting the Frontend\nDESCRIPTION: Commands to navigate to the frontend directory, install dependencies, and start the frontend development server.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/meeting-notes.mdx#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ cd you-app-name/frontend\n$ npm install\n$ npm run dev\n```\n\n----------------------------------------\n\nTITLE: Defining Note Structure in Go\nDESCRIPTION: Go struct definition for the Note type, representing the data structure for meeting notes.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/meeting-notes.mdx#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ntype Note struct {\n\tID       string `json:\"id\"`\n\tText     string `json:\"text\"`\n\tCoverURL string `json:\"cover_url\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Newsletter Subscriber Cron Job\nDESCRIPTION: Implements a cron job for sending emails to newsletter subscribers, running every Friday.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cron_job_definition.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nvar _ = cron.NewJob(\"cronfoo\", cron.JobConfig{\n\tTitle:     \"Cron Foo Bar\",\n\tSchedule: \"* * * * 5\",\n\tEndpoint: CronAPI,\n})\n```\n\n----------------------------------------\n\nTITLE: Alternative Configuration Type with Encore Config\nDESCRIPTION: Demonstrates another configuration struct using Encore's typed configuration with config.String and config.Int\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/multiple_configs_in_service.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype OtherConfig struct{\n    Foo config.String // Foo is great in Otherconfig\n    Bar config.Int\n}\n\nvar _ = config.Load[OtherConfig]()\n```\n\n----------------------------------------\n\nTITLE: Starting Encore Application in Debug Mode\nDESCRIPTION: Command to launch an Encore application with a headless Delve server that pauses until a debugger is attached\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/debug.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ encore run --debug=break\n```\n\n----------------------------------------\n\nTITLE: Creating Site Service Directory Structure\nDESCRIPTION: Shell commands to create the initial directory structure for the site service\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ mkdir site\n$ touch site/encore.service.ts\n```\n\n----------------------------------------\n\nTITLE: Database Creation and Configuration in Encore\nDESCRIPTION: Shows how to create and configure a new SQL database in an Encore service\nSOURCE: https://github.com/encoredev/encore/blob/main/go_llm_instructions.txt#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\npackage todo\n\nvar tododb = sqldb.NewDatabase(\"todo\", sqldb.DatabaseConfig{\n    Migrations: \"./migrations\",\n})\n```\n\n----------------------------------------\n\nTITLE: Checking Encore Application\nDESCRIPTION: The `encore check` command verifies your application for compile-time errors. It utilizes the Encore compiler for static analysis.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ encore check\n```\n\n----------------------------------------\n\nTITLE: AWS CloudWatch Metrics Configuration in JSON\nDESCRIPTION: Configuration for AWS CloudWatch metrics, specifying collection interval and namespace.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"metrics\": {\n    \"type\": \"aws_cloudwatch\",\n    \"collection_interval\": 60,\n    \"namespace\": \"MyAppMetrics\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Encore Application Locally\nDESCRIPTION: Commands to navigate to the booking system directory and run the Encore application locally for development and testing.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ cd booking-system\n$ encore run\n```\n\n----------------------------------------\n\nTITLE: Linking Encore App to Server\nDESCRIPTION: The `encore app link` command associates a local Encore application with the Encore server. It requires the application ID.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n$ encore app link [app-id]\n```\n\n----------------------------------------\n\nTITLE: Building Encore Docker Image\nDESCRIPTION: Builds a portable Docker image of the Encore application, with options to specify base image and push to remote repository.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_30\n\nLANGUAGE: shell\nCODE:\n```\n$ encore build docker\n```\n\n----------------------------------------\n\nTITLE: Pub/Sub Subscription Creation\nDESCRIPTION: Demonstrates creating a subscription to handle events from a topic\nSOURCE: https://github.com/encoredev/encore/blob/main/ts_llm_instructions.txt#2025-04-21_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Subscription } from \"encore.dev/pubsub\";\n\nconst _ = new Subscription(signups, \"send-welcome-email\", {\n    handler: async (event) => {\n        // Send a welcome email using the event.\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: TypeScript Module Export Chain\nDESCRIPTION: A series of connected TypeScript files demonstrating module export patterns, including re-exports, constant declarations, and interface definitions.\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/src/parser/types/testdata/reexport_wildcard.txt#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport { foo } from \"./foo\";\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport * from \"./bar\";\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport const foo = \"foo\";\nexport interface bar {\n    num: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing gops Package for Goland Debugging\nDESCRIPTION: Go command to install the gops package required for process attachment in Goland\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/debug.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ngo get -t github.com\\/google\\/gops\\/\n```\n\n----------------------------------------\n\nTITLE: Listing Secrets\nDESCRIPTION: The `encore secret list` command lists the available secrets, optionally filtering by specific keys.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_23\n\nLANGUAGE: shell\nCODE:\n```\n$ encore secret list [keys...]\n```\n\n----------------------------------------\n\nTITLE: Initializing Go Service Structure\nDESCRIPTION: Defines a service struct with an API method, contains a type error in the receiver type\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_receiver_typo.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\t\"encore.dev/types/uuid\"\n)\n\n//encore:service\ntype Service struct {}\n```\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public\nfunc (s *Serviice) Str(ctx context.Context, p *Params) error { return nil }\n```\n\n----------------------------------------\n\nTITLE: PubSub Subscriber Function in Different Service\nDESCRIPTION: Defines a subscriber function in a separate service, which cannot be used as a direct handler for a PubSub subscription\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_subscription_func_not_in_service.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc Subscriber(ctx context.Context, msg *shared.MessageType) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Graceful Shutdown Configuration\nDESCRIPTION: Settings for controlling graceful shutdown behavior including total shutdown time and component-specific timeouts\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"graceful_shutdown\": {\n    \"total\": 30,\n    \"shutdown_hooks\": 10,\n    \"handlers\": 20\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Showing Current Encore User\nDESCRIPTION: The `encore auth whoami` command displays information about the currently logged-in user.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\n$ encore auth whoami\n```\n\n----------------------------------------\n\nTITLE: Creating a New Encore Application\nDESCRIPTION: The `encore app create` command initializes a new Encore application. It requires a name for the application.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ encore app create [name]\n```\n\n----------------------------------------\n\nTITLE: API Endpoint Definition\nDESCRIPTION: Defines a public API endpoint function that currently returns no error\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/cache_err_keyspace_invalid.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n//encore:api public\nfunc Foo(context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Starting VPN Connection\nDESCRIPTION: The `encore vpn start` command sets up a secure connection to private environments via a VPN.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_28\n\nLANGUAGE: shell\nCODE:\n```\n$ encore vpn start\n```\n\n----------------------------------------\n\nTITLE: Defining Monitor Service\nDESCRIPTION: TypeScript code defining the monitor service using Encore's Service class.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Service } from \"encore.dev/service\";\n\nexport default new Service(\"monitor\");\n```\n\n----------------------------------------\n\nTITLE: Outputting Encore Environment Information\nDESCRIPTION: The `encore daemon env` command displays the environment configuration used by the Encore daemon.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\n$ encore daemon env\n```\n\n----------------------------------------\n\nTITLE: Executing Scripts in Encore Environment\nDESCRIPTION: Compiles and runs a Go script within the local Encore app environment.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ encore exec <path/to/script>\n```\n\n----------------------------------------\n\nTITLE: Configuring Kubernetes for Encore\nDESCRIPTION: Updates kubectl config to point to the Kubernetes cluster(s) for the specified Encore environment.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\n$ encore k8s configure --env=ENV_NAME\n```\n\n----------------------------------------\n\nTITLE: Unarchiving Secret Value\nDESCRIPTION: The `encore secret unarchive` command unarchives a secret value based on its ID.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_25\n\nLANGUAGE: shell\nCODE:\n```\n$  encore secret unarchive <id>\n```\n\n----------------------------------------\n\nTITLE: Attaching Delve to Running Process in Terminal\nDESCRIPTION: Command to attach Delve debugger to a running process using its Process ID\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/how-to/debug.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ dlv attach 51894\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image (Shell)\nDESCRIPTION: This shell command builds a Docker image for the application. It utilizes the `encore build docker` command to compile the application and package it into a Docker image named `uptime:v1.0`. This command is typically executed from the root of the project directory.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/uptime.md#2025-04-21_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\n$ encore build docker uptime:v1.0\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration with Encore Framework\nDESCRIPTION: Initializes configuration loading mechanism using Encore's config package\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/basic_named_struct_single_use.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nvar _ = config.Load[*Config]()\n```\n\n----------------------------------------\n\nTITLE: Checking VPN Status\nDESCRIPTION: The `encore vpn status` command shows the current status of the VPN connection.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/cli-reference.md#2025-04-21_snippet_29\n\nLANGUAGE: shell\nCODE:\n```\n$ encore vpn status\n```\n\n----------------------------------------\n\nTITLE: Testing Database Connection - Bash\nDESCRIPTION: This snippet verifies the database connection by invoking the API set up in the Encore app, ensuring that the application can interact successfully with the database.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/deploy-to-digital-ocean-wip.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncurl https://myapp.ondigitalocean.app/names/1\n```\n\n----------------------------------------\n\nTITLE: Displaying Current Encore User\nDESCRIPTION: Shows information about the currently logged-in Encore user.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n$ encore auth whoami\n```\n\n----------------------------------------\n\nTITLE: Linking Encore Application with Server\nDESCRIPTION: Links an Encore application with the server using the app ID.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ encore app link [app-id]\n```\n\n----------------------------------------\n\nTITLE: Registering Encore Internal Authentication Handler\nDESCRIPTION: Generates an internal authentication descriptor with decoding logic for HTTP Authorization headers and service registration mechanism\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/authhandlergen/testdata/servicestruct.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nvar EncoreInternal_authhandler_AuthDesc_AuthHandler = &__api.AuthHandlerDesc[string]{\n\tAuthHandler: func(ctx context.Context, params string) (info __model.AuthInfo, err error) {\n\t\tsvc, initErr := EncoreInternal_svcstruct_Service.Get()\n\t\tif initErr != nil {\n\t\t\treturn info, initErr\n\t\t}\n\t\tinfo.UID, err = svc.AuthHandler(ctx, params)\n\t\treturn info, err\n\t},\n\tDecodeAuth: func(httpReq *http.Request) (params string, err error) {\n\t\tif auth := httpReq.Header.Get(\"Authorization\"); auth != \"\" {\n\t\t\tfor _, prefix := range [...]string{\"Bearer \", \"Token \"} {\n\t\t\t\tif strings.HasPrefix(auth, prefix) {\n\t\t\t\t\tif params = auth[len(prefix):]; params != \"\" {\n\t\t\t\t\t\treturn params, nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"\", errs.B().Code(errs.Unauthenticated).Msg(\"invalid auth param\").Err()\n\t},\n\tDefLoc:      uint32(0x0),\n\tEndpoint:    \"AuthHandler\",\n\tHasAuthData: false,\n\tService:     \"code\",\n\tSvcNum:      1,\n}\n```\n\n----------------------------------------\n\nTITLE: Running Ruleguard Rules\nDESCRIPTION: Command to execute all ruleguard rules against a Go codebase with maximum severity checking disabled\nSOURCE: https://github.com/encoredev/encore/blob/main/tools/semgrep-rules/semgrep-go/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nruleguard -c=0 -rules path/to/semgrep-go/ruleguard.rules.go ./...\n```\n\n----------------------------------------\n\nTITLE: Direct Secrets Configuration\nDESCRIPTION: Configuration for directly specified secrets and environment variable references\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"secrets\": {\n    \"API_TOKEN\": \"embedded-secret-value\",\n    \"DB_PASSWORD\": {\n      \"$env\": \"DB_PASSWORD\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Config Unmarshaler in Go\nDESCRIPTION: Automatically generated unmarshaler function that knows how to convert a JSON representation into an instance of the `Config` struct, including handling `uuid.UUID` and `[]byte` fields with custom unmarshaling logic. It uses the `jsoniter` library for parsing.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_config.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t__etype \"encore.dev/appruntime/shared/etype\"\n\tuuid \"encore.dev/types/uuid\"\n\t\"fmt\"\n\tjsoniter \"github.com/json-iterator/go\"\n)\n\n/*\nThese functions are automatically generated and maintained by Encore to allow config values\nto be unmarshalled into the correct types. They are not intended to be used directly. They\nare automatically updated by Encore whenever you change the data types used within your\ncalls to config.Load[T]().\n*/\n\n// Concrete unmarshalers for all config.Load calls, including those using generic types.\n// These instances are used directly by calls to `config.Load[T]()`.\nvar (\n\tencoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {\n\t\treturn func() *Config {\n\t\t\t// If the value is null, we return nil\n\t\t\tif itr.ReadNil() {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Otherwise we unmarshal the value and return a pointer to it\n\t\t\tobj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))\n\t\t\treturn &obj\n\t\t}()\n\t}\n)\n\n// encoreInternalTypeConfigUnmarshaler_svc_Config will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"Name\":\n\t\t\tobj.Name = itr.ReadString()\n\t\tcase \"Port\":\n\t\t\tobj.Port = itr.ReadUint16()\n\t\tcase \"ReadOnly\":\n\t\t\tobj.ReadOnly = itr.ReadBool()\n\t\tcase \"MagicNumber\":\n\t\t\tobj.MagicNumber = itr.ReadInt()\n\t\tcase \"ID\":\n\t\t\tobj.ID = func() (rtn uuid.UUID) {\n\t\t\t\tdecoder := new(__etype.Unmarshaller)\n\t\t\t\trtn = __etype.UnmarshalOne(decoder, __etype.UnmarshalUUID, \"value\", itr.ReadString(), true)\n\t\t\t\tif err := decoder.Error; err != nil {\n\t\t\t\t\tpanic(fmt.Sprintf(\"unable to decode the config: %v\", err))\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}()\n\t\tcase \"PublicKey\":\n\t\t\tobj.PublicKey = func() (rtn []byte) {\n\t\t\t\tdecoder := new(__etype.Unmarshaller)\n\t\t\t\trtn = __etype.UnmarshalOne(decoder, __etype.UnmarshalBytes, \"value\", itr.ReadString(), true)\n\t\t\t\tif err := decoder.Error; err != nil {\n\t\t\t\t\tpanic(fmt.Sprintf(\"unable to decode the config: %v\", err))\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}()\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Curl Command for Testing URL Retrieval Endpoint\nDESCRIPTION: Example curl command to test the URL retrieval endpoint of the URL shortener service running locally. Demonstrates how to call the endpoint from the command line.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/rest-api.mdx#2025-04-21_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n$ curl http://localhost:4000/url/your-id-from-the-previous-step\n```\n\n----------------------------------------\n\nTITLE: Defining Recursive Data Structures in Go\nDESCRIPTION: This snippet defines several recursive data structures in Go, including `Recursive`, `MutualOne`, and `MutualTwo`.  These structures contain fields that refer to themselves or each other, creating a web of dependencies.  The `Recursive` struct contains fields that are slices and pointer to slices of itself and another struct.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/recursive.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage basic\n\nimport \"context\"\n\ntype Recursive struct {\n    Basic []Recursive\n    Pointer []*Recursive\n    Mutual []MutualTwo\n}\n\ntype MutualOne struct {\n    Basic []MutualTwo\n    Pointer []*MutualTwo\n    Self []Recursive\n    SelfPointer []*Recursive\n}\n\ntype MutualTwo struct {\n    Basic []MutualOne\n    Pointer []*MutualOne\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Pub/Sub Topic Declaration in Go\nDESCRIPTION: This code snippet demonstrates the incorrect usage of the pubsub.NewTopic function within a function (SomeAPI). According to Encore's design, pub/sub topics should be declared as package-level variables to ensure proper initialization and handling. The purpose is to highlight the error that Encore generates when a topic is declared in an invalid location.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_import_aliased_and_used_in_func.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n\n    pb \"encore.dev/pubsub\"\n)\n\ntype MyMessage struct {}\n\n//encore:api\nfunc SomeAPI(ctx context.Context) error {\n    topic := pb.NewTopic[MyMessage](\"basic-topic\")\n    topic.Publish(ctx, &MyMessage{})\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Encore Secrets\nDESCRIPTION: Lists secrets in Encore, optionally for specific keys.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_22\n\nLANGUAGE: shell\nCODE:\n```\n$ encore secret list [keys...]\n```\n\n----------------------------------------\n\nTITLE: Logging in to Encore\nDESCRIPTION: Authenticates the user with Encore.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n$ encore auth login\n```\n\n----------------------------------------\n\nTITLE: Calling Encore API from Command Line\nDESCRIPTION: Example of how to call the Encore API endpoint using curl from the command line. This demonstrates how to interact with the API once it's running.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/quick-start.mdx#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ curl http://localhost:4000/hello/world\n```\n\n----------------------------------------\n\nTITLE: Stopping Encore VPN\nDESCRIPTION: Stops the Encore VPN connection.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_29\n\nLANGUAGE: shell\nCODE:\n```\n$ encore vpn stop\n```\n\n----------------------------------------\n\nTITLE: Git Commit for Deployment\nDESCRIPTION: This shell command snippet shows the necessary commands to commit changes to a git repository and push them to the Encore platform, which will trigger the deployment process for the application.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/rest-api.mdx#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ git add -A .\n$ git commit -m 'Initial commit'\n$ git push encore\n```\n\n----------------------------------------\n\nTITLE: API Endpoint Registration and Metadata Configuration\nDESCRIPTION: Comprehensive configuration for API endpoint registration, including request/response handling, middleware, and routing details\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/basic.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Go Encore app\nDESCRIPTION: Command to create a new Encore application using the Go hello-world example.\nSOURCE: https://github.com/encoredev/encore/blob/main/README.md#2025-04-21_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nencore app create --example=hello-world\n```\n\n----------------------------------------\n\nTITLE: Initializing application directories and files with Shell\nDESCRIPTION: This snippet illustrates how to create a new service directory and initial files needed for a URL shortening service using shell commands. It involves creating a `url` directory and initializing files like `encore.service.ts` and `url.ts`.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/rest-api.mdx#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ mkdir url\n$ touch url/encore.service.ts\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ touch url/url.ts\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ mkdir url/migrations\n$ touch url/migrations/001_create_tables.up.sql\n```\n\n----------------------------------------\n\nTITLE: Initializing Encore Application from Existing Repository\nDESCRIPTION: Creates a new Encore application from an existing repository.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ encore app init [name]\n```\n\n----------------------------------------\n\nTITLE: Internal API Endpoint Registration and Handling\nDESCRIPTION: Comprehensive autogenerated code for registering and handling API endpoints with serialization, deserialization, and request/response processing\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/response_params.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage basic\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\t__etype \"encore.dev/appruntime/shared/etype\"\n\t__serde \"encore.dev/appruntime/shared/serde\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n}\n\ntype EncoreInternal_FooReq struct{}\n\ntype EncoreInternal_FooResp = *Params\n\nvar EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{\n\t// Extensive API descriptor configuration...\n}\n```\n\n----------------------------------------\n\nTITLE: Initialize an Encore App\nDESCRIPTION: This snippet demonstrates how to create a new Encore application by running the initialization command in the project directory. It generates an `encore.app` file necessary for an Encore project.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/migration/express-migration.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nencore app init\n```\n\n----------------------------------------\n\nTITLE: Mocking API Calls with Encore in Go\nDESCRIPTION: Encore provides built-in support for mocking API calls, and interfaces for automatically generating mock objects for your services. This feature is particularly useful when writing unit tests to isolate and test specific parts of your application without relying on external dependencies.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/introduction.md#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\n\"Encore provides built-in support for [mocking API calls](/docs/go/develop/testing/mocking), and interfaces for automatically generating mock objects for your services.\"\n```\n\n----------------------------------------\n\nTITLE: Configure tsconfig.json for Encore\nDESCRIPTION: This snippet shows how to modify the `tsconfig.json` file by adding path mappings for Encore, which allows the framework to correctly identify imported modules.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/migration/express-migration.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"~encore/*\": [\n        \"./encore.gen/*\"\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Compiler Configuration for Encore Project\nDESCRIPTION: This tsconfig.json file configures TypeScript compilation options, specifically setting up path aliases for Encore-generated files and local modules.\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/tests/testdata/tsconfig.txt#2025-04-21_snippet_3\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"~encore/*\": [\"./encore.gen/*\"],\n      \"@bar/*\": [\"./bar/*\"]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Encore Docker Image with Custom Port\nDESCRIPTION: This bash command demonstrates how to run an Encore Docker image with a custom port by setting the PORT environment variable.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/ci-cd.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -e PORT=8081 -p 8081:8081 MY-IMAGE:TAG\n```\n\n----------------------------------------\n\nTITLE: Defining MessageType Struct in Go\nDESCRIPTION: Defines a shared MessageType struct with a Name field, used as the message type for the PubSub topic.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_subscriber_different_service.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage shared\n\ntype MessageType struct {\n    Name string\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Service Commands\nDESCRIPTION: Shell commands for running the service, triggering shutdown, and verifying shutdown log message.\nSOURCE: https://github.com/encoredev/encore/blob/main/e2e-tests/testdata/testscript/graceful_shutdown.txt#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrun\nshutdown\nchecklog '{\"message\": \"shutting down\"}'\n```\n\n----------------------------------------\n\nTITLE: Defining Server Option Structures in Go\nDESCRIPTION: This snippet defines the ServerOption and Config structures used to configure server settings in Encore. It includes fields for HTTP, TCP, and GRPC options.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/json_tags.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n)\n\ntype ServerOption struct {\n    Option   int64\n    Disabled bool `json:\",omitempty\"` // True if this is disabled\n}\n\ntype Config struct {\n    HTTP    ServerOption\n    Another ServerOption `json:\"a_n_o_t_h_e_r\"`\n    TCP     ServerOption `json:\",omitempty\"`\n    GRPC    ServerOption `json:\",omitempty\"`\n}\n\nvar _ = config.Load[*Config]()\n```\n\n----------------------------------------\n\nTITLE: Invalid PubSub Subscription Configuration\nDESCRIPTION: Demonstrates an incorrect PubSub subscription configuration where the handler is defined in a different service, which is not allowed\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_subscription_func_not_in_service.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nvar _ = pubsub.NewSubscription(BasicTopic, \"basic-subscription\", pubsub.SusbcriptionConfig { Handler: svc2.Subscriber })\n```\n\n----------------------------------------\n\nTITLE: Creating PubSub Topic and Subscription in Go\nDESCRIPTION: Creates a PubSub topic and subscription using Encore's pubsub package. The subscription handler is incorrectly referenced from another service.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_subscriber_different_service.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc1\n\nimport (\n    \"context\"\n\n    \"encore.dev/pubsub\"\n\n    \"test/shared\"\n    \"test/svc2\"\n)\n\nvar BasicTopic = pubsub.NewTopic[*shared.MessageType](\"basic-topic\", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })\n\nvar _ = pubsub.NewSubscription(BasicTopic, \"basic-subscription\", pubsub.SusbcriptionConfig { Handler: svc2.Subscriber })\n\n// encore:api\nfunc Stuff(ctx context.Context) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Monitor Service Check Migration\nDESCRIPTION: SQL migration script to create checks table for recording uptime monitoring results\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/uptime.md#2025-04-21_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE checks (\n    id BIGSERIAL PRIMARY KEY,\n    site_id BIGINT NOT NULL,\n    up BOOLEAN NOT NULL,\n    checked_at TIMESTAMP WITH TIME ZONE NOT NULL\n);\n```\n\n----------------------------------------\n\nTITLE: Defining an API Function in Go\nDESCRIPTION: The MyAPI function is defined as an Encore API endpoint, currently returning nil. It serves as a placeholder for future functionality, allowing for the integration of business logic when needed.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/generic_named_types.txt#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Package Configuration for Encore Project\nDESCRIPTION: NPM package configuration specifying project dependencies including encore.dev framework and module type settings.\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/tests/testdata/builtins.txt#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"foo\",\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"encore.dev\": \"^1.35.0\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring an API Endpoint with Encore in Go\nDESCRIPTION: This Go snippet defines an API endpoint using Encore\\'s raw directive, which is not allowed for private APIs. It demonstrates the restriction on declaring private APIs as raw endpoints. The required dependency is the net/http package, and the incorrect directive usage is criticized in the example. The snippet shows the HTTP response writer and request being used as parameters for the function.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_raw_internal.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nimport \"net/http\"\n\n//encore:api raw\nfunc API(w http.ResponseWriter, req *http.Request) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Rollout Structure in TypeScript\nDESCRIPTION: This TypeScript snippet defines the structure of the 'Rollout' object, which encapsulates the state and status of a rollout process in the Encore Cloud API. It includes unique identifiers, statuses, conclusion states, timestamps for various phases, and structures for individual rollout phases.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/integrations/api-reference.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// The representation of a rollout.\ntype Rollout = {\n  // Unique id of the rollout.\n  id: string;\n\n  // The current status of the rollout.\n  status: \"pending\" | \"queued\" | \"running\" | \"completed\";\n\n  // What the conclusion was of the rollout (when status is \"completed\").\n  // If the status is not \"completed\" the conclusion is \"pending\".\n  conclusion: \"pending\" | \"canceled\" | \"failure\" | \"success\";\n\n  // When the rollout was queued, started, and completed.\n  queued_at: Date | null;\n  started_at: Date | null;\n  completed_at: Date | null;\n\n  // Information about the various rollout phases.\n  // See type definitions below.\n  build: RolloutPhase<BuildStatus, BuildConclusion>;\n  infra: RolloutPhase<InfraStatus, InfraConclusion>;\n  deploy: RolloutPhase<DeployStatus, DeployConclusion>;\n}\n\n// Common structure of the various rollout phases.\ntype RolloutPhase<Status, Conclusion> = {\n  // Unique id of the phase.\n  id: string;\n\n  // The current status of the rollout phase.\n  status: Status;\n\n  // What the conclusion was of the phase.\n  conclusion: Conclusion;\n\n  // When the phase was queued, started, and completed.\n  queued_at: Date | null;\n  started_at: Date | null;\n  completed_at: Date | null;\n}\n\n// The current status and conclusion of a build.\n// If the status is not \"completed\" the conclusion is \"unknown\".\ntype BuildStatus = \"queued\" | \"running\" | \"completed\";\ntype BuildConclusion = \"unknown\" | \"canceled\" | \"failure\" | \"success\";\n\n// The current status and conclusion of an infra change.\n// The \"proposed\" status means the change is awaiting human approval.\n// The \"rejected\" conclusion means a human rejected the proposed infra change.\ntype InfraStatus = \"pending\" | \"proposed\" | \"queued\" | \"running\" | \"completed\";\ntype InfraConclusion = \"unknown\" | \"canceled\" | \"failure\" | \"rejected\" | \"success\";\n\n// The current status and conclusion of a deploy.\n// If the status is not \"completed\" the conclusion is \"unknown\".\ntype DeployStatus = \"queued\" | \"running\" | \"completed\";\ntype DeployConclusion = \"unknown\" | \"canceled\" | \"failure\" | \"success\";\n```\n\n----------------------------------------\n\nTITLE: Define Invalid Secret Struct in Go\nDESCRIPTION: This code snippet defines a Go struct named `secrets` with a field `Foo` of type `int`. This is intended to trigger an error because secret fields must be of type string. The `package svc` declaration indicates that this code belongs to the `svc` package.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/secrets_non_string.txt#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage svc\n\nvar secrets struct {\n    Foo int\n}\n```\n\n----------------------------------------\n\nTITLE: Attempting Cache Cluster Initialization with Invalid Configuration\nDESCRIPTION: Demonstrates an invalid cache cluster configuration by using an incorrect eviction policy value, which would trigger an error\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/parser/infra/caches/testdata/cluster.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nvar b = cache.NewCluster(\n    \"foo\", cache.ClusterConfig{\n        EvictionPolicy: \"x\",\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Subscription Handler in Go\nDESCRIPTION: Defines the subscription handler function in a separate service, which causes an error in Encore's PubSub configuration.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_subscriber_different_service.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage svc2\n\nimport (\n    \"context\"\n\n    \"test/shared\"\n)\n\n//encore:api\nfunc Subscriber(ctx context.Context, msg *shared.MessageType) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PubSub Subscription Handler (Go)\nDESCRIPTION: This snippet defines the `Subscriber` function, which is intended to be a PubSub subscription handler. However, it is defined in a separate package/service (`shared`) from where the subscription is created, leading to an error in Encore.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/pubsub_err_subscriber_not_function.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage shared\n\nfunc Subscriber(ctx context.Context, msg *shared.MessageType) error {\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Calling a Raw API Endpoint from Another API - Go\nDESCRIPTION: This snippet showcases an illegal attempt to call a raw API endpoint directly from another endpoint within the Encore application. The 'NonRaw' function attempts to call the 'API' function with nil values, violating Encore's constraints that disallow raw API calls from other endpoints.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/rpc_raw_call.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n//encore:api public\nfunc NonRaw(ctx context.Context) error {\n    API(nil, nil)\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration for CsConfig in Encore (Go)\nDESCRIPTION: This snippet defines the CsConfig structure and loads its configuration using the Encore framework. Similar to AsConfig, CsConfig includes a field 'Foo' of type config.String, providing structured configuration management.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/merge_identical_comments.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"context\"\n\n\t\"encore.dev/config\"\n)\n\ntype CsConfig struct{\n    // Multiline test\n    // comment to deduplicate.\n    Foo config.String\n}\n\nvar _ = config.Load[CsConfig]()\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Auth Handlers in Encore (Error Case)\nDESCRIPTION: This code demonstrates an invalid scenario where two auth handlers are defined in the same Encore application. Encore only allows one auth handler per application, resulting in a compilation error.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/app/testdata/auth_handler_multiple.txt#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n    \"context\"\n    \"encore.dev/beta/auth\"\n)\n\n//encore:authhandler\nfunc MyAuth(ctx context.Context, token string) (auth.UID, error) { return \"\", nil }\n\n//encore:authhandler\nfunc MyAuth2(ctx context.Context, token string) (auth.UID, error) { return \"\", nil }\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image for URL Shortener Service\nDESCRIPTION: Command to build a Docker image of the URL shortener service using Encore's CLI. The resulting image can be deployed to any cloud provider that supports Docker containers.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/tutorials/rest-api.mdx#2025-04-21_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n$ encore build docker url-shortener:v1.0\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image with Infrastructure Config\nDESCRIPTION: Command to build a Docker image with infrastructure configuration using the Encore build command\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/self-host/configure-infra.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nencore build docker --config path/to/infra-config.json MY-IMAGE:TAG\n```\n\n----------------------------------------\n\nTITLE: GCP Cloud Monitoring Configuration in JSON\nDESCRIPTION: Configuration for GCP Cloud Monitoring, specifying project ID, resource type, labels, and metric names.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/configure-infra.md#2025-04-21_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"metrics\": {\n    \"type\": \"gcp_cloud_monitoring\",\n    \"collection_interval\": 60,\n    \"project_id\": \"my-gcp-project\",\n    \"monitored_resource_type\": \"gce_instance\",\n    \"monitored_resource_labels\": {\n      \"instance_id\": \"1234567890\",\n      \"zone\": \"us-central1-a\"\n    },\n    \"metric_names\": {\n      \"cpu_usage\": \"compute.googleapis.com/instance/cpu/usage_time\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Resetting All Databases in a Specific Namespace using Encore CLI\nDESCRIPTION: This command resets all databases associated with the specified namespace 'my-ns'. It ensures that the databases are cleared in that isolated context.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/cli/infra-namespaces.md#2025-04-21_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n$ encore db reset --all --namespace my-ns\n```\n\n----------------------------------------\n\nTITLE: Logging into DigitalOcean's Container Registry - Bash\nDESCRIPTION: This snippet describes the command to log in to DigitalOcean's container registry using the DigitalOcean CLI.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/self-host/deploy-to-digital-ocean-wip.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndoctl registry login\n```\n\n----------------------------------------\n\nTITLE: Initializing API with Encore in Go\nDESCRIPTION: This code snippet initializes a simple API endpoint using the Encore framework. The function MyAPI is an API function that accepts a context parameter and returns an error type. This setup indicates a simple API operation, albeit without specific functional implementation yet, which is typical during the initial stages of development.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/cuegen/testdata/json_tags.txt#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n//encore:api\nfunc MyAPI(ctx context.Context) (error) {\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Ping Endpoint with curl\nDESCRIPTION: Shell command to test the Ping endpoint using curl, checking the status of google.com.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/uptime.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncurl http://localhost:4000/ping/google.com\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Inference with Example Use Cases in TypeScript\nDESCRIPTION: Shows three examples of type inference: Infer1 successfully extracts 'string' from an object with property X, Infer2 results in 'never' when property X is missing, and Infer3 demonstrates direct conditional type inference without using the Iface utility.\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/src/parser/types/testdata/infer.txt#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Infer1 = Iface<{ X: string }>; // string\nexport type Infer2 = Iface<{ Y: string }>; // never\nexport type Infer3 = { X: string } extends { X: infer A } ? A : never; // string\n```\n\n----------------------------------------\n\nTITLE: Project Package Configuration\nDESCRIPTION: Package configuration for a TypeScript module using Encore framework, specifying module type and dependency\nSOURCE: https://github.com/encoredev/encore/blob/main/tsparser/tests/testdata/query_header.txt#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"foo\",\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"encore.dev\": \"^1.35.0\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Service Interface for Bar\nDESCRIPTION: Automatically generated interface for the Bar service to define the API surface and support mocking\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/multiple_services.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype Interface interface {\n\tBar(ctx context.Context) error\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying with Connected GitHub Account\nDESCRIPTION: These commands show how to deploy your application when you have connected your GitHub account to Encore Cloud. It involves adding changes, committing, and pushing to the 'origin' remote.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/deploy/deploying.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ git add -A .\n$ git commit -m 'Commit message'\n$ git push origin\n```\n\n----------------------------------------\n\nTITLE: Creating Encore Account and Application\nDESCRIPTION: This command creates a free Encore Cloud account and a new Encore application. It's the first step in setting up your deployment environment.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/deploy/deploying.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ encore app create\n```\n\n----------------------------------------\n\nTITLE: Updating Migration Version - SQL\nDESCRIPTION: This SQL command updates the `version` column in the `schema_migrations` table to allow for re-running the last migration. It decrements the version by 1.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/primitives/databases.md#2025-04-21_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nUPDATE schema_migrations SET version = version - 1;\n```\n\n----------------------------------------\n\nTITLE: Creating Encore Application for Uptime Monitor\nDESCRIPTION: Command to create a new Encore application using a starting-point branch for the uptime monitor project.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/uptime.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ encore app create uptime --example=github.com/encoredev/example-app-uptime/tree/starting-point\n```\n\n----------------------------------------\n\nTITLE: Registering an API Endpoint in Go\nDESCRIPTION: This snippet initializes and registers an API endpoint with Encore. It defines request and response structures and includes handlers for encoding and decoding HTTP requests and responses in the service. The registration occurs during the initialization phase, which associates the API endpoint with the function implementation.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/complex_omitempty.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage basic\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\t__etype \"encore.dev/appruntime/shared/etype\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n}\n\n// Additional types and endpoint descriptor code omitted for brevity.\n```\n\n----------------------------------------\n\nTITLE: Dynamic AppID Notation in Encore Templates\nDESCRIPTION: This snippet shows the notation to use in your template's source code instead of hardcoding an `AppID`.  When a developer creates an app using the template, `{{ENCORE_APP_ID}}` will be dynamically replaced with their new and unique `AppID` avoiding manual code adjustments.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/community/submit-template.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n\"{ {ENCORE_APP_ID} }\"\n```\n\n----------------------------------------\n\nTITLE: Generating Configuration Unmarshaler for Temporal Client\nDESCRIPTION: Automatically generated JSON unmarshaling functions for parsing Temporal client configuration, supporting complex nested configuration loading\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/multi_package.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc encoreInternalTypeConfigUnmarshaler_temporal_ClientOptions(itr *jsoniter.Iterator, path []string) (obj temporal.ClientOptions) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"HostPort\":\n\t\t\tobj.HostPort = itr.ReadString()\n\t\tcase \"Namespace\":\n\t\t\tobj.Namespace = itr.ReadString()\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Internal Unmarshaller for Config - Go\nDESCRIPTION: This snippet establishes an internal unmarshaller function for the Config type to accurately convert JSON configurations into Go types, taking advantage of the jsoniter package.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/multiple_configs_in_service.txt#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport (\n\t\"encore.dev/config\"\n\t\"github.com/json-iterator/go\"\n)\n\n// encoreInternalTypeConfigUnmarshaler_svc_Config will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"Name\":\n\t\t\tobj.Name = itr.ReadString()\n\t\tcase \"Port\":\n\t\t\tobj.Port = itr.ReadUint16()\n\t\tcase \"ReadOnly\":\n\t\t\tobj.ReadOnly = itr.ReadBool()\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Availability File with Shell Command\nDESCRIPTION: Shell command to create a new Go file for implementing availability management functionality.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n$ touch booking/availability.go\n```\n\n----------------------------------------\n\nTITLE: Running Daemon with Built Binary\nDESCRIPTION: This command starts the Encore daemon. It assumes that the `encore` binary has been built from source and the necessary environment variables (`ENCORE_RUNTIMES_PATH` and `ENCORE_GOROOT`) have been set. The `-f` flag is used to run the daemon in the foreground. The command requires the built `encore` binary to function, which can be obtained by following the initial build instructions.  There are no explicit inputs.\nSOURCE: https://github.com/encoredev/encore/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\n./encore daemon -f\n```\n\n----------------------------------------\n\nTITLE: Internal API Endpoint Registration in Go\nDESCRIPTION: This code snippet shows how Encore internally registers API endpoints. It registers the `Foo` endpoint and defines the request and response types.  It also includes functions for encoding, decoding, cloning, and handling the API request and response using JSON and HTTP.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/auth_handler.txt#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n}\n\ntype EncoreInternal_FooReq struct{}\n\ntype EncoreInternal_FooResp = __api.Void\n\nvar EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{\n\tAccess: __api.Private,\n\tAppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {\n\t\terr := Foo(ctx)\n\t\tif err != nil {\n\t\t\treturn __api.Void{}, err\n\t\t}\n\t\treturn __api.Void{}, nil\n\t},\n\tCloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {\n\t\tvar clone *EncoreInternal_FooReq\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tCloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {\n\t\tvar clone EncoreInternal_FooResp\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tDecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {\n\t\treturn __api.Void{}, nil\n\t},\n\tDecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {\n\t\treqData = new(EncoreInternal_FooReq)\n\t\treturn reqData, nil, nil\n\t},\n\tDefLoc: uint32(0x0),\n\tEncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {\n\t\treturn nil, nil, nil\n\t},\n\tEncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {\n\t\treturn nil\n\t},\n\tEndpoint:            \"Foo\",\n\tFallback:            false,\n\tGlobalMiddlewareIDs: []string{},\n\tMethods:             []string{\"GET\", \"POST\"},\n\tPath:                \"/code.Foo\",\n\tPathParamNames:      nil,\n\tRaw:                 false,\n\tRawHandler:          nil,\n\tRawPath:             \"/code.Foo\",\n\tReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {\n\t\treturn \"/code.Foo\", nil, nil\n\t},\n\tReqUserPayload: func(reqData *EncoreInternal_FooReq) any {\n\t\treturn nil\n\t},\n\tService:           \"code\",\n\tServiceMiddleware: []*__api.Middleware{},\n\tSvcNum:            1,\n\tTags:              nil,\n}\n```\n\n----------------------------------------\n\nTITLE: Logging out from Encore\nDESCRIPTION: Logs out the currently authenticated user from Encore.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n$ encore auth logout\n```\n\n----------------------------------------\n\nTITLE: JSON Telemetry Event Example in Encore\nDESCRIPTION: Demonstrates the structure of a typical telemetry event captured during application creation, including anonymous identifier and event properties\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/platform/management/telemetry.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"event\": \"app.create\",\n    \"anonymousId\": \"a-uuid-unique-for-the-installation\",\n    \"properties\": {\n        \"error\": false,\n        \"lang\": \"go\",\n        \"template\": \"graphql\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Single Semgrep Rule\nDESCRIPTION: Command to execute a single semgrep rule against a codebase\nSOURCE: https://github.com/encoredev/encore/blob/main/tools/semgrep-rules/semgrep-go/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsemgrep -f path/to/semgrep-go/rule.yml .\n```\n\n----------------------------------------\n\nTITLE: Describing the schema_migrations table with SQL\nDESCRIPTION: This SQL query describes the `schema_migrations` table, showing its columns (`version` and `dirty`), their types, and the primary key constraint.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/primitives/databases.md#2025-04-21_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\n\"database=# \\\\d schema_migrations\n          Table \\\"public.schema_migrations\\\"\n Column  |  Type   | Collation | Nullable | Default\n---------+---------+-----------+----------+---------\n version | bigint  |           | not null |\n dirty   | boolean |           | not null |\nIndexes:\n    \\\"schema_migrations_pkey\\\" PRIMARY KEY, btree (version)\"\n```\n\n----------------------------------------\n\nTITLE: Updating Golden Test Output Files with Go Test Command\nDESCRIPTION: Command to update all expected output files for golden tests in the clientgen package. Uses the -golden-update flag to automatically update the expected test outputs after verifying the current output is correct.\nSOURCE: https://github.com/encoredev/encore/blob/main/pkg/clientgen/testdata/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo test ./internal/clientgen -golden-update\n```\n\n----------------------------------------\n\nTITLE: Internal API Endpoint Handling and Registration\nDESCRIPTION: This code is generated by Encore to handle the API endpoint `Foo`. It includes request and response types, encoding and decoding logic, and registration of the endpoint with the Encore runtime. It uses `jsoniter` for JSON processing and `encore.dev/appruntime/apisdk/api` for API registration.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/path_params.txt#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\t__etype \"encore.dev/appruntime/shared/etype\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n}\n\ntype EncoreInternal_FooReq struct {\n\tPayload *Params\n\tP0      int\n\tP1      string\n}\n\ntype EncoreInternal_FooResp = __api.Void\n\nvar EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{\n\tAccess: __api.Public,\n\tAppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {\n\t\terr := Foo(ctx, reqData.P0, reqData.P1, reqData.Payload)\n\t\tif err != nil {\n\t\t\treturn __api.Void{}, err\n\t\t}\n\t\treturn __api.Void{}, nil\n\t},\n\tCloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {\n\t\tvar clone *EncoreInternal_FooReq\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tCloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {\n\t\tvar clone EncoreInternal_FooResp\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tDecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {\n\t\treturn __api.Void{}, nil\n\t},\n\tDecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {\n\t\treqData = new(EncoreInternal_FooReq)\n\t\tdec := new(__etype.Unmarshaller)\n\t\t// Trim the leading slash from wildcard parameter, as Encore's semantics excludes it,\n\t\t// while the httprouter implementation includes it.\n\t\tps[1] = strings.TrimPrefix(ps[1], \"/\")\n\n\t\treqData.P0 = __etype.UnmarshalOne(dec, __etype.UnmarshalInt, \"id\", ps[0], true)\n\t\tif value, err := url.PathUnescape(ps[1]); err == nil {\n\t\t\tps[1] = value\n\t\t}\n\t\treqData.P1 = __etype.UnmarshalOne(dec, __etype.UnmarshalString, \"baz\", ps[1], true)\n\t\tparams := new(Params)\n\t\treqData.Payload = params\n\t\tswitch m := httpReq.Method; m {\n\t\tcase \"POST\":\n\t\t\t// Decode request body\n\t\t\tpayload := dec.ReadBody(httpReq.Body)\n\t\t\titer := jsoniter.ParseBytes(json, payload)\n\n\t\t\tfor iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {\n\t\t\t\tswitch strings.ToLower(key) {\n\t\t\t\tcase \"string\":\n\t\t\t\t\tdec.ParseJSON(\"String\", iter, &params.String)\n\t\t\t\tcase \"int\":\n\t\t\t\t\tdec.ParseJSON(\"Int\", iter, &params.Int)\n\t\t\t\tdefault:\n\t\t\t\t\t_ = iter.SkipAndReturnBytes()\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}) {\n\t\t\t}\n\n\t\tdefault:\n\t\t\tpanic(\"HTTP method is not supported\")\n\t\t}\n\t\tif err := dec.Error; err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\treturn reqData, ps, nil\n\t},\n\tDefLoc: uint32(0x0),\n\tEncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {\n\t\tparams := reqData.Payload\n\t\tif params == nil {\n\t\t\t// If the payload is nil, we need to return an empty request body.\n\t\t\treturn httpHeader, queryString, err\n\t\t}\n\n\t\t// Encode request body\n\t\tstream.WriteObjectStart()\n\t\tstream.WriteObjectField(\"String\")\n\t\tstream.WriteVal(params.String)\n\t\tstream.WriteMore()\n\t\tstream.WriteObjectField(\"Int\")\n\t\tstream.WriteVal(params.Int)\n\t\tstream.WriteObjectEnd()\n\n\t\treturn httpHeader, queryString, err\n\t},\n\tEncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {\n\t\treturn nil\n\t},\n\tEndpoint:            \"Foo\",\n\tFallback:            false,\n\tGlobalMiddlewareIDs: []string{},\n\tMethods:             []string{\"POST\"},\n\tPath:                \"/foo/:id/*baz\",\n\tPathParamNames:      []string{\"id\", \"baz\"},\n\tRaw:                 false,\n\tRawHandler:          nil,\n\tRawPath:             \"/foo/:0/*1\",\n\tReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {\n\t\tparams := __api.UnnamedParams{__etype.MarshalOne(__etype.MarshalInt, reqData.P0), __etype.MarshalOne(__etype.MarshalString, reqData.P1)}\n\t\treturn \"/foo\" + \"/\" + url.PathEscape(params[0]) + \"/\" + url.PathEscape(params[1]), params, nil\n\t},\n\tReqUserPayload: func(reqData *EncoreInternal_FooReq) any {\n\t\treturn reqData.Payload\n\t},\n\tService:           \"code\",\n\tServiceMiddleware: []*__api.Middleware{},\n\tSvcNum:            1,\n\tTags:              nil,\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Installed Encore Version\nDESCRIPTION: This shell command checks the currently installed version of Encore. No dependencies are required. It outputs the current version, such as 'v1.28.0', to the terminal. The output is a simple version string.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/ts/install.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nencore version\n```\n\n----------------------------------------\n\nTITLE: Generating Service Interface for Encore API\nDESCRIPTION: Autogenerated interface definition for service API, providing type safety and mocking support\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/endpointgen/testdata/response_params.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// Code generated by encore. DO NOT EDIT.\n\npackage basic\n\nimport \"context\"\n\n// Interface defines the service's API surface area, primarily for mocking purposes.\n//\n// Raw endpoints are currently excluded from this interface, as Encore does not yet\n// support service-to-service API calls to raw endpoints.\ntype Interface interface {\n\tFoo(ctx context.Context) (*Params, error)\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Telemetry Debug Mode\nDESCRIPTION: Shell command for enabling debug mode to view telemetry data being sent.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/telemetry.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nexport ENCORE_TELEMETRY_DEBUG=1\n```\n\n----------------------------------------\n\nTITLE: Encore API Endpoint Registration in Go\nDESCRIPTION: Code snippet for registering the `Foo` API endpoint with Encore, setting up an internal request-response process. Utilizes Encore's `__api` package for endpoint description and handling.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/maingen/testdata/service_struct.txt#2025-04-21_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\npackage code\n\nimport (\n\t\"context\"\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc init() {\n\t__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)\n}\n\ntype EncoreInternal_FooReq struct{}\n\ntype EncoreInternal_FooResp = __api.Void\n\nvar EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{\n\tAccess: __api.Private,\n\tAppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {\n\t\tsvc, initErr := EncoreInternal_svcstruct_Service.Get()\n\t\tif initErr != nil {\n\t\t\treturn __api.Void{}, initErr\n\t\t}\n\t\terr := svc.Foo(ctx)\n\t\tif err != nil {\n\t\t\treturn __api.Void{}, err\n\t\t}\n\t\treturn __api.Void{}, nil\n\t},\n\tCloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {\n\t\tvar clone *EncoreInternal_FooReq\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tCloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {\n\t\tvar clone EncoreInternal_FooResp\n\t\tbytes, err := jsoniter.ConfigDefault.Marshal(r)\n\t\tif err == nil {\n\t\t\terr = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)\n\t\t}\n\t\treturn clone, err\n\t},\n\tDecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {\n\t\treturn __api.Void{}, nil\n\t},\n\tDecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {\n\t\treqData = new(EncoreInternal_FooReq)\n\t\treturn reqData, nil, nil\n\t},\n\tDefLoc: uint32(0x0),\n\tEncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {\n\t\treturn nil, nil, nil\n\t},\n\tEncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {\n\t\treturn nil\n\t},\n\tEndpoint:            \"Foo\",\n\tFallback:            false,\n\tGlobalMiddlewareIDs: []string{},\n\tMethods:             []string{\"GET\", \"POST\"},\n\tPath:                \"/code.Foo\",\n\tPathParamNames:      nil,\n\tRaw:                 false,\n\tRawHandler:          nil,\n\tRawPath:             \"/code.Foo\",\n\tReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {\n\t\treturn \"/code.Foo\", nil, nil\n\t},\n\tReqUserPayload: func(reqData *EncoreInternal_FooReq) any {\n\t\treturn nil\n\t},\n\tService:           \"code\",\n\tServiceMiddleware: []*__api.Middleware{},\n\tSvcNum:            1,\n\tTags:              nil,\n}\n```\n\n----------------------------------------\n\nTITLE: Encore Internal Middleware Implementation in Go\nDESCRIPTION: This code represents the generated internal implementation for the middleware defined in the `code` package. It uses the `encore.dev/appruntime/apisdk/api` package to define a `Middleware` struct, which includes the `Invoke` function that calls the actual middleware function defined in the service. It retrieves the service instance and executes its `Middleware` method.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/middlewaregen/testdata/service_struct.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage code\n\nimport (\n\t__api \"encore.dev/appruntime/apisdk/api\"\n\terrs \"encore.dev/beta/errs\"\n\tmiddleware \"encore.dev/middleware\"\n)\n\nvar EncoreInternal_middleware_middleware_Middleware = &__api.Middleware{\n\tDefLoc: uint32(0x0),\n\tGlobal: false,\n\tID:     \"example.com.Middleware\",\n\tInvoke: func(req middleware.Request, next middleware.Next) middleware.Response {\n\t\tsvc, err := EncoreInternal_svcstruct_Service.Get()\n\t\tif err != nil {\n\t\t\treturn middleware.Response{\n\t\t\t\tErr:        err,\n\t\t\t\tHTTPStatus: errs.HTTPStatus(err),\n\t\t\t}\n\t\t}\n\t\treturn svc.Middleware(req, next)\n\t},\n\tName:    \"Middleware\",\n\tPkgName: \"code\",\n}\n```\n\n----------------------------------------\n\nTITLE: Installing sqlc Tool - Shell\nDESCRIPTION: This shell command installs the sqlc tool, which compiles SQL queries into type-safe Go code, essential for the database interactions in the booking service.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ go install github.com/sqlc-dev/sqlc/cmd/sqlc@latest\n\n```\n\n----------------------------------------\n\nTITLE: Registering Encore Service Internal Metadata\nDESCRIPTION: Generates internal service registration and metadata configuration for Encore framework service discovery and initialization\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/apigen/servicestructgen/testdata/init_svc.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage basic\n\nimport __service \"encore.dev/appruntime/apisdk/service\"\n\nfunc init() {\n\t__service.Register(EncoreInternal_svcstruct_Service)\n}\n\nvar EncoreInternal_svcstruct_Service = &__service.Decl[Service]{\n\tName:        \"Service\",\n\tService:     \"basic\",\n\tSetup:       initService,\n\tSetupDefLoc: uint32(0x0),\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Encore CLI Version\nDESCRIPTION: Reports the current version of the Encore application.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/cli/cli-reference.md#2025-04-21_snippet_25\n\nLANGUAGE: shell\nCODE:\n```\n$ encore version\n```\n\n----------------------------------------\n\nTITLE: Defining Cowsay ASCII Art in Go\nDESCRIPTION: Go constant defining the ASCII art for the cowsay command, used to format the response message.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/slack-bot.md#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nconst cowart = `\n ________________________________________\n< %- 38s >\n ----------------------------------------\n        \\   ^__^\n         \\  (oo)\\_______\n            (__)\\       )\\/\\\n                ||----w |\n                ||     ||\n`\n```\n\n----------------------------------------\n\nTITLE: Generating Config Unmarshaler in Go\nDESCRIPTION: This auto-generated code provides unmarshaling logic for the `Config` struct using the `jsoniter` library. It handles reading JSON data and converting it into the corresponding struct fields, including nested structs. This ensures configuration values are correctly loaded from JSON files or environment variables.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/codegen/infragen/configgen/testdata/basic_inline_struct.txt#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage svc\n\nimport jsoniter \"github.com/json-iterator/go\"\n\n/*\nThese functions are automatically generated and maintained by Encore to allow config values\nto be unmarshalled into the correct types. They are not intended to be used directly. They\nare automatically updated by Encore whenever you change the data types used within your\ncalls to config.Load[T]().\n*/\n\n// Concrete unmarshalers for all config.Load calls, including those using generic types.\n// These instances are used directly by calls to `config.Load[T]()`.\nvar (\n\tencoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {\n\t\treturn func() *Config {\n\t\t\t// If the value is null, we return nil\n\t\t\tif itr.ReadNil() {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Otherwise we unmarshal the value and return a pointer to it\n\t\t\tobj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))\n\t\t\treturn &obj\n\t\t}()\n\t}\n)\n\n// encoreInternalTypeConfigUnmarshaler_svc_Config will unmarshal the JSON representation into the given type, taking account for\n// the `config.Value` dynamic functions.\nfunc encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {\n\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\tswitch field {\n\t\tcase \"HTTP\":\n\t\t\tobj.HTTP = func() (obj struct {\n\t\t\t\tEnabled bool\n\t\t\t\tPort    uint32\n\t\t\t}) {\n\t\t\t\titr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {\n\t\t\t\t\tswitch field {\n\t\t\t\t\tcase \"Enabled\":\n\t\t\t\t\t\tobj.Enabled = itr.ReadBool()\n\t\t\t\t\tcase \"Port\":\n\t\t\t\t\t\tobj.Port = itr.ReadUint32()\n\t\t\t\t\tdefault:\n\t\t\t\t\t\titr.Skip()\n\t\t\t\t\t}\n\t\t\t\t\treturn true\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}()\n\t\tdefault:\n\t\t\titr.Skip()\n\t\t}\n\t\treturn true\n\t})\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Booking Service File\nDESCRIPTION: Shell command to create a new file named slots.go inside the booking folder, which will contain the booking service logic.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/tutorials/booking-system.mdx#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ touch booking/slots.go\n```\n\n----------------------------------------\n\nTITLE: SQL Migration Setup\nDESCRIPTION: This SQL migration file is used to update the database schema.  While the content of the migration is not provided, the file name suggests a migration named 'foo' and represents the 'up' migration which is applied when migrating to a newer version.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/parser/resource/usage/testdata/sqldb_usage.txt#2025-04-21_snippet_0\n\nLANGUAGE: SQL\nCODE:\n```\n\"-- svc/migrations/1_foo.up.sql --\"\n```\n\n----------------------------------------\n\nTITLE: Twitter Icon SVG Component\nDESCRIPTION: SVG markup for Twitter logo icon used in the community page navigation\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/community/get-involved.md#2025-04-21_snippet_2\n\nLANGUAGE: svg\nCODE:\n```\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"#111111\" stroke=\"none\"><path d=\"M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z\" /></svg>\n```\n\n----------------------------------------\n\nTITLE: Expected Output Verification\nDESCRIPTION: This snippet outlines the expected output from the modified Go program, which should print 'Hello, rewritten world!'. This is critical for debugging and ensuring code correctness.\nSOURCE: https://github.com/encoredev/encore/blob/main/v2/compiler/build/testdata/rewrite.txt#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nHello, rewritten world!\n```\n\n----------------------------------------\n\nTITLE: Embedding Service Catalog Video\nDESCRIPTION: HTML video element configuration for displaying the service catalog demonstration video with autoplay, inline playback, loop, controls, and muting enabled.\nSOURCE: https://github.com/encoredev/encore/blob/main/docs/go/observability/service-catalog.md#2025-04-21_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<video autoPlay playsInline loop controls muted className=\"w-full h-full\">\n\t<source src=\"/assets/docs/servicecatalogvideo.mp4\" className=\"w-full h-full\" type=\"video/mp4\" />\n</video>\n```"
  }
]