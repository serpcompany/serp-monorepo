[
  {
    "owner": "quantumlib",
    "repo": "cirq",
    "content": "TITLE: Example Factoring via Shor's Algorithm Python\nDESCRIPTION: This code shows an example of factoring an integer using Shor's algorithm, employing the `find_factor` function with a specified (classical in this example) order finder. It calculates the factors p and q and prints the result.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Example of factoring via Shor's algorithm (order finding).\"\"\"\n# Number to factor\nn = 184573\n\n# Attempt to find a factor\np = find_factor(n, order_finder=classical_order_finder)\nq = n // p\n\nprint(\"Factoring n = pq =\", n)\nprint(\"p =\", p)\nprint(\"q =\", q)\n```\n\n----------------------------------------\n\nTITLE: Simulating a Bell State Circuit\nDESCRIPTION: This code snippet demonstrates how to create and simulate a Bell state circuit using Cirq's simulator. It initializes a simulator, creates a circuit to generate a Bell state, simulates the circuit to view the wave function, and then samples the circuit to obtain a distribution of results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Create a circuit to generate a Bell State:\n# 1/sqrt(2) * ( |00⟩ + |11⟩ )\nbell_circuit = cirq.Circuit()\nq0, q1 = cirq.LineQubit.range(2)\nbell_circuit.append(cirq.H(q0))\nbell_circuit.append(cirq.CNOT(q0, q1))\n\n# Initialize Simulator\ns = cirq.Simulator()\n\nprint('Simulate the circuit:')\nresults = s.simulate(bell_circuit)\nprint(results)\n\n# For sampling, we need to add a measurement at the end\nbell_circuit.append(cirq.measure(q0, q1, key='result'))\n\n# Sample the circuit\nsamples = s.run(bell_circuit, repetitions=1000)\n```\n\n----------------------------------------\n\nTITLE: Running a Circuit via Sampler in Python\nDESCRIPTION: This snippet showcases how to use the sampler interface to execute a quantum circuit on the IonQ API. It creates a `cirq.Circuit`, obtains a sampler object using `service.sampler`, and runs the circuit for 100 repetitions. The results are returned in a pandas DataFrame, making it easy to integrate with other Cirq classes and data processing workflows.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/jobs.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nqubit = cirq.LineQubit(0)\ncircuit = cirq.Circuit(\n    cirq.X(qubit)**0.5,            # Square root of NOT.\n    cirq.measure(qubit, key='x')   # Measurement store in key 'x'\n)\nsampler = service.sampler(target='qpu')\nresult = sampler.run(program=circuit, repetitions=100)\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Factoring Functions Python\nDESCRIPTION: This code provides functions to factor integers using Shor's algorithm and related classical techniques. It includes functions for finding factors of prime powers, finding factors of composite integers using a given order finder (quantum or classical), and pre-processing steps to check for even numbers, prime numbers, and prime powers.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Functions for factoring from start to finish.\"\"\"\ndef find_factor_of_prime_power(n: int) -> Optional[int]:\n    \"\"\"Returns non-trivial factor of n if n is a prime power, else None.\"\"\"\n    for k in range(2, math.floor(math.log2(n)) + 1):\n        c = math.pow(n, 1 / k)\n        c1 = math.floor(c)\n        if c1**k == n:\n            return c1\n        c2 = math.ceil(c)\n        if c2**k == n:\n            return c2\n    return None\n\n\ndef find_factor(\n    n: int,\n    order_finder: Callable[[int, int], Optional[int]] = quantum_order_finder,\n    max_attempts: int = 30\n) -> Optional[int]:\n    \"\"\"Returns a non-trivial factor of composite integer n.\n\n    Args:\n        n: Integer to factor.\n        order_finder: Function for finding the order of elements of the\n            multiplicative group of integers modulo n.\n        max_attempts: number of random x's to try, also an upper limit\n            on the number of order_finder invocations.\n\n    Returns:\n        Non-trivial factor of n or None if no such factor was found.\n        Factor k of n is trivial if it is 1 or n.\n    \"\"\"\n    # If the number is prime, there are no non-trivial factors.\n    if sympy.isprime(n):\n        print(\"n is prime!\")\n        return None\n    \n    # If the number is even, two is a non-trivial factor.\n    if n % 2 == 0:\n        return 2\n    \n    # If n is a prime power, we can find a non-trivial factor efficiently.\n    c = find_factor_of_prime_power(n)\n    if c is not None:\n        return c\n    \n    for _ in range(max_attempts):\n        # Choose a random number between 2 and n - 1.\n        x = random.randint(2, n - 1)\n        \n        # Most likely x and n will be relatively prime.\n        c = math.gcd(x, n)\n        \n        # If x and n are not relatively prime, we got lucky and found\n        # a non-trivial factor.\n        if 1 < c < n:\n            return c\n        \n        # Compute the order r of x modulo n using the order finder.\n        r = order_finder(x, n)\n        \n        # If the order finder failed, try again.\n        if r is None:\n            continue\n        \n        # If the order r is even, try again.\n        if r % 2 != 0:\n            continue\n        \n        # Compute the non-trivial factor.\n        y = x**(r // 2) % n\n        assert 1 < y < n\n        c = math.gcd(y - 1, n)\n        if 1 < c < n:\n            return c\n\n    print(f\"Failed to find a non-trivial factor in {max_attempts} attempts.\")\n    return None\n```\n\n----------------------------------------\n\nTITLE: Constructing a Simple Circuit in Cirq with Python\nDESCRIPTION: This snippet creates a simple circuit consisting of two moments. The first moment contains a `CZ` gate between the first two qubits and an `X` gate on the third qubit. The second moment contains a `CZ` gate between the second and third qubits. The circuit is then printed, showing the sequence of operations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncz01 = cirq.CZ(qubits[0], qubits[1])\nx2 = cirq.X(qubits[2])\ncz12 = cirq.CZ(qubits[1], qubits[2])\nmoment0 = cirq.Moment([cz01, x2])\nmoment1 = cirq.Moment([cz12])\ncircuit = cirq.Circuit((moment0, moment1))\n\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Simulating Quantum Teleportation with Cirq and verifying Bloch Vectors\nDESCRIPTION: This snippet simulates the teleportation circuit using Cirq's `Simulator`. It extracts the final state vector of the simulation and computes the Bloch vector of Bob's qubit. It then compares Bob's Bloch vector with the initial message qubit's Bloch vector using `np.testing.assert_allclose` to verify successful teleportation. Dependencies: `cirq` and `numpy`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Simulate the teleportation circuit and get the final state of Bob's qubit.\"\"\"\n# Get a simulator.\nsim = cirq.Simulator()\n\n# Simulate the teleportation circuit.\nresult = sim.simulate(circuit)\n\n# Get the Bloch vector of Bob's qubit.\nbobs_bloch_vector = cirq.bloch_vector_from_state_vector(result.final_state_vector, index=1)\nprint(\"Bloch vector of Bob's qubit:\")\nprint(np.round(bobs_bloch_vector, 3))\n\n# Verify they are the same state!\nnp.testing.assert_allclose(bobs_bloch_vector, message_bloch_vector, atol=1e-6)\n```\n\n----------------------------------------\n\nTITLE: Circuit Compilation for CZ Target Gateset\nDESCRIPTION: This code shows how to compile a quantum circuit for a specific target gateset, in this case, the CZTargetGateset.  It uses the cirq.optimize_for_target_gateset function to apply a series of transformation passes to convert the circuit into one that uses only CZ and single-qubit gates. The assertion confirms the compiled circuit is equivalent to the original.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/transformers.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Original QFT Circuit on 3 qubits.\nq = cirq.LineQubit.range(3)\ncircuit = cirq.Circuit(cirq.QuantumFourierTransformGate(3).on(*q), cirq.measure(*q))\nprint(\"Original Circuit:\", circuit, \"\\n\", sep=\"\\n\")\n\n# Compile the circuit for CZ Target Gateset.\ngateset = cirq.CZTargetGateset(allow_partial_czs=True)\ncz_circuit = cirq.optimize_for_target_gateset(circuit, gateset=gateset)\ncirq.testing.assert_circuits_with_terminal_measurements_are_equivalent(circuit, cz_circuit)\nprint(\"Circuit compiled for CZ Target Gateset:\", cz_circuit, \"\\n\", sep=\"\\n\")\n```\n\n----------------------------------------\n\nTITLE: Create Order Finding Circuit with ModularExp in Cirq\nDESCRIPTION: This snippet defines a function `make_order_finding_circuit` that constructs the quantum circuit for order finding using the `ModularExp` gate and quantum phase estimation. The circuit includes Hadamard gates, the modular exponential operation, an inverse quantum Fourier transform, and measurement of the exponent register.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef make_order_finding_circuit(x: int, n: int) -> cirq.Circuit:\n    \"\"\"Returns quantum circuit which computes the order of x modulo n.\n\n    The circuit uses Quantum Phase Estimation to compute an eigenvalue of\n    the following unitary:\n\n        U|y⟩ = |y * x mod n⟩      0 <= y < n\n        U|y⟩ = |y⟩                n <= y\n\n    Args:\n        x: positive integer whose order modulo n is to be found\n        n: modulus relative to which the order of x is to be found\n\n    Returns:\n        Quantum circuit for finding the order of x modulo n\n    \"\"\"\n    L = n.bit_length()\n    target = cirq.LineQubit.range(L)\n    exponent = cirq.LineQubit.range(L, 3 * L + 3)\n\n    # Create a ModularExp gate sized for these registers.\n    mod_exp = ModularExp([2] * L, [2] * (2 * L + 3), x, n)\n\n    return cirq.Circuit(\n        cirq.X(target[L - 1]),\n        cirq.H.on_each(*exponent),\n        mod_exp.on(*target, *exponent),\n        cirq.qft(*exponent, inverse=True),\n        cirq.measure(*exponent, key='exponent'),\n    )\n```\n\n----------------------------------------\n\nTITLE: Create a Simple Cirq Circuit\nDESCRIPTION: Creates a simple quantum circuit using the Cirq library.  The circuit consists of a square root of X gate on qubit q0, a CNOT gate with q0 as control and q1 as target, and measurement of both qubits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_ionq.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\n\nq0, q1 = cirq.LineQubit.range(2)\ncircuit = cirq.Circuit(\n    cirq.X(q0)**0.5,             # Square root of X\n    cirq.CX(q0, q1),              # CNOT\n    cirq.measure(q0, q1, key='b') # Measure both qubits\n)\ncircuit\n```\n\n----------------------------------------\n\nTITLE: Building Circuits with Generators in Cirq using Python\nDESCRIPTION: This code snippet demonstrates two methods for constructing quantum circuits in Cirq using generator expressions. It shows how to append operations to a circuit using a generator and how to initialize a circuit directly with a generator. Both examples apply Hadamard gates to three line qubits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Append with generator\ncircuit = cirq.Circuit()\ncircuit.append(cirq.H(q) for q in cirq.LineQubit.range(3))\nprint(circuit)\n# Initializer with generator\nprint(cirq.Circuit(cirq.H(q) for q in cirq.LineQubit.range(3)))\n```\n\n----------------------------------------\n\nTITLE: Prepare Plus State Layer in Cirq\nDESCRIPTION: This function prepares a layer of qubits in the superposition state |+⟩ by applying a Hadamard gate to each qubit in a grid. The function takes the grid `length` as input, which determines the dimensions of the grid (length x length), yielding a Hadamard gate applied to each `cirq.GridQubit(i, j)`\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/variational_algorithm.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef prepare_plus_layer(length):\n    for i in range(length):\n        for j in range(length):\n            yield cirq.H(cirq.GridQubit(i, j))\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Gate in Cirq\nDESCRIPTION: This code defines a custom single-qubit gate called `RationalGate` in Cirq.  The gate implements a unitary transformation based on the 3-4-5 triangle ratios.  It overrides the `_num_qubits_` method to specify the number of qubits the gate acts on and the `_unitary_` method to define the gate's unitary matrix. It also defines `__str__` for a custom string representation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_49\n\nLANGUAGE: python\nCODE:\n```\nclass RationalGate(cirq.Gate):\n    def _num_qubits_(self) -> int:\n        return 1\n\n    def _unitary_(self):\n        return np.array([[3 / 5, 4 / 5], [-4 / 5, 3 / 5]])\n\n    def __str__(self):\n        return 'ζ'\n```\n\n----------------------------------------\n\nTITLE: Simulating a circuit in Cirq\nDESCRIPTION: This snippet demonstrates how to simulate a Cirq circuit using the `cirq.Simulator`. It instantiates a simulator, passes the circuit created earlier to the `run` method with a specified number of repetitions, and then prints the measurement results. This shows how to get sample outputs from the circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Example of simulating a circuit in Cirq.\"\"\"\n# Get a simulator.\nsimulator = cirq.Simulator()\n\n# Pass the circuit to the simulator.run method.\nresult = simulator.run(circuit, repetitions=1)\nprint(\"Measurement results:\")\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Simulating Quantum Circuits with Cirq in Python\nDESCRIPTION: This snippet shows code related to simulating the execution of a Cirq-defined quantum circuit. It could include setting up a simulator object, running the circuit simulation, and retrieving the results. This simulation allows testing of quantum algorithms before deployment on real quantum hardware.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\nimport cirq\n# Code for simulating a Cirq circuit\n# Requires further decompilation to understand the simulator setup and results.\n```\n\n----------------------------------------\n\nTITLE: Simulating a Noisy Circuit with DensityMatrixSimulator in Cirq\nDESCRIPTION: This code demonstrates how to simulate a noisy quantum circuit using the `cirq.DensityMatrixSimulator`. It applies a depolarizing channel to a qubit and then simulates the circuit, returning the final density matrix of the system. This allows for simulating the effects of noise on the quantum state.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_71\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit(cirq.depolarize(0.2)(a))\nprint(f'Circuit:\\n{circuit}\\n')\n\n# Get the density matrix simulator.\nsimulator = cirq.DensityMatrixSimulator()\n```\n\n----------------------------------------\n\nTITLE: Using InsertStrategy.EARLIEST in Cirq with Python\nDESCRIPTION: This snippet demonstrates the `InsertStrategy.EARLIEST` strategy. It creates a circuit and appends a `CZ` gate. Then, it appends Hadamard gates using `InsertStrategy.EARLIEST`.  The H gate acting on q2 is added to the same moment as the CZ gate since they operate on different qubits. The H gate acting on q0 is added to a later moment as it would conflict with the CZ gate, which also operates on q0 and q1.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.circuits import InsertStrategy\n\ncircuit = cirq.Circuit()\ncircuit.append([cirq.CZ(q0, q1)])\ncircuit.append([cirq.H(q0), cirq.H(q2)], strategy=InsertStrategy.EARLIEST)\n\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Creating a Quantum Circuit in Cirq\nDESCRIPTION: This snippet creates a `cirq.Circuit` and appends Hadamard gates (`cirq.H`) to qubits where the sum of their row and column indices is even, and X gates (`cirq.X`) to qubits where the sum is odd. It then prints the resulting circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/variational_algorithm.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit()\ncircuit.append(cirq.H(q) for q in qubits if (q.row + q.col) % 2 == 0)\ncircuit.append(cirq.X(q) for q in qubits if (q.row + q.col) % 2 == 1)\n\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Using Custom Two-Qubit Gate in Cirq Circuit\nDESCRIPTION: This code snippet creates a Cirq circuit that utilizes the custom two-qubit gate defined previously.  The custom gate is applied to two qubits using `this_gate.on(*cirq.LineQubit.range(2))`. The resulting circuit diagram, displaying the symbols defined for each wire, is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/custom_gates.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ncirc = cirq.Circuit(\n    this_gate.on(*cirq.LineQubit.range(2))\n)\n\nprint(\"Circuit with custom two-qubit gate:\")\nprint(circ)\n```\n\n----------------------------------------\n\nTITLE: Oracle Construction in Cirq\nDESCRIPTION: This code snippet defines a function `oracle` that constructs a quantum oracle using a function represented as a NumPy array. The oracle is implemented as a diagonal matrix gate in Cirq, where the diagonal entries are the values of the input function. The function takes the function values `fs` and the qubits `qubits` as input and returns a Cirq `Operation` representing the oracle.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef oracle(fs: np.ndarray, qubits: Sequence[cirq.Qid]) -> cirq.Operation:\n    \"\"\"Construct a sample oracle using a function as above.\n\n    This will create an operation with a unitary matrix that is diagonal\n    and whose entries correspond to the values of the input function 'fs'.\n    \"\"\"\n    return cirq.MatrixGate(np.diag(fs).astype(complex))(*qubits)\n```\n\n----------------------------------------\n\nTITLE: Optimize Circuit with Cirq Transformers Python\nDESCRIPTION: This function `optimize_circuit` demonstrates how to compose several built-in Cirq transformers to optimize a quantum circuit.  It merges k-qubit unitaries, drops negligible operations, expands composite gates, and synchronizes terminal measurements. The `k` parameter defines the maximum qubit count for merging unitaries, and the `context` provides optional transformer context configurations. The function also includes an assertion to verify the equivalence of the original and optimized circuits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/transformers.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef optimize_circuit(circuit, context=None, k=2):\n    # Merge 2-qubit connected components into circuit operations.\n    optimized_circuit = cirq.merge_k_qubit_unitaries(\n        circuit, k=k, rewriter=lambda op: op.with_tags(\"merged\"), context=context\n    )\n\n    # Drop operations with negligible effect / close to identity.\n    optimized_circuit = cirq.drop_negligible_operations(optimized_circuit, context=context)\n\n    # Expand all remaining merged connected components.\n    optimized_circuit = cirq.expand_composite(\n        optimized_circuit, no_decomp=lambda op: \"merged\" not in op.tags, context=context\n    )\n\n    # Synchronize terminal measurements to be in the same moment.\n    optimized_circuit = cirq.synchronize_terminal_measurements(optimized_circuit, context=context)\n\n    # Assert the original and optimized circuit are equivalent.\n    cirq.testing.assert_circuits_with_terminal_measurements_are_equivalent(\n        circuit, optimized_circuit\n    )\n\n    return optimized_circuit\n\n\nq = cirq.LineQubit.range(3)\ncircuit = cirq.Circuit(\n    cirq.H(q[1]),\n    cirq.CNOT(*q[1:]),\n    cirq.H(q[0]),\n    cirq.CNOT(*q[:2]),\n    cirq.H(q[1]),\n    cirq.CZ(*q[:2]),\n    cirq.H.on_each(*q[:2]),\n    cirq.CNOT(q[2], q[0]),\n    cirq.measure_each(*q),\n)\nprint(\"Original Circuit:\", circuit, sep=\"\\n\")\nprint(\"Optimized Circuit:\", optimize_circuit(circuit), sep=\"\\n\")\n```\n\n----------------------------------------\n\nTITLE: Add noise to operation, moment, or sequence\nDESCRIPTION: Demonstrates how to add noise to individual operations, moments, or a sequence of moments using a `cirq.NoiseModel`. It showcases how to create a noise model from a depolarizing channel and apply it to different parts of a circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# Create a noise model.\nnoise_model = cirq.NoiseModel.from_noise_model_like(cirq.depolarize(p=0.01))\n\n# Get a qubit register.\nqreg = cirq.LineQubit.range(2)\n\n# Add noise to an operation.\nop = cirq.CNOT(*qreg)\nnoisy_op = noise_model.noisy_operation(op)\n\n# Add noise to a moment.\nmoment = cirq.Moment(cirq.H.on_each(qreg))\nnoisy_moment = noise_model.noisy_moment(moment, system_qubits=qreg)\n\n# Add noise to a sequence of moments.\ncircuit = cirq.Circuit(cirq.H(qreg[0]), cirq.CNOT(*qreg))\nnoisy_circuit = noise_model.noisy_moments(circuit, system_qubits=qreg)\n```\n\n----------------------------------------\n\nTITLE: Define Inverse QFT Circuit Generator in Python\nDESCRIPTION: This code defines a function `make_qft_inverse` to generate the inverse QFT circuit.  It takes a list of qubits as input, reverses the order, and applies Hadamard and controlled-Z rotations with negative exponents. This function mirrors the structure of the QFT but with reversed qubit order and inverted control rotation exponents.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef make_qft_inverse(qubits):\n    \"\"\"Generator for the inverse QFT on a list of qubits.\"\"\"\n    qreg = list(qubits)[::-1]\n    while len(qreg) > 0:\n        q_head = qreg.pop(0)\n        yield cirq.H(q_head)\n        for i, qubit in enumerate(qreg):\n            yield (cirq.CZ ** (-1 / 2 ** (i + 1))))(qubit, q_head)\n```\n\n----------------------------------------\n\nTITLE: Inserting channels in circuits\nDESCRIPTION: Shows how to modify a circuit by inserting channels at a specific point using the `insert` method. The example demonstrates adding bit-flip channels at the start of the circuit to model state preparation errors.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ncirc.insert(0, cirq.bit_flip(p=0.1).on_each(qreg))\nprint(circ)\n```\n\n----------------------------------------\n\nTITLE: Initializing Qubits and Gates in Cirq\nDESCRIPTION: This snippet demonstrates how to initialize qubits and common quantum gates using the Cirq library. Qubits are the fundamental units of quantum information, and gates are the operations performed on them.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nimport cirq\n\n# Example: Initializing qubits\nq0 = cirq.GridQubit(0, 0)\nq1 = cirq.GridQubit(0, 1)\n\n# Example: Creating gates\nh_gate = cirq.H\ncnot_gate = cirq.CNOT\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Quantum Circuit with Cirq\nDESCRIPTION: This snippet demonstrates how to create a quantum circuit using Cirq. It defines three named qubits, creates a list of quantum operations (Hadamard and CNOT gates), and then constructs a circuit from these operations. The circuit is then printed to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Creating a circuit.\"\"\"\n# Define three qubits.\na = cirq.NamedQubit(\"a\")\nb = cirq.NamedQubit(\"b\")\nc = cirq.NamedQubit(\"c\")\n\n# Define a list of operations.\nops = [cirq.H(a), cirq.H(b), cirq.CNOT(b, c), cirq.H(b)]\n\n# Create a circuit from the list of operations.\ncircuit = cirq.Circuit(ops)\nprint(\"Circuit:\\n\")\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Using InsertStrategy.NEW in Cirq with Python\nDESCRIPTION: This snippet demonstrates the `InsertStrategy.NEW` strategy. It appends three Hadamard gates to a circuit, forcing each gate to be placed in a new moment. This results in a circuit with three moments, each containing a single Hadamard gate.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit()\ncircuit.append([cirq.H(q0), cirq.H(q1), cirq.H(q2)], strategy=InsertStrategy.NEW)\n\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Validating Moment and Circuit on Sycamore Device in Cirq\nDESCRIPTION: This snippet validates a `cirq.Moment` consisting of an X gate and a SYC gate, as well as validating a complete `cirq.Circuit`. It demonstrates how `validate_moment` and `validate_circuit` methods check the validity of quantum operations and circuit structures on the Sycamore device.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/devices.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nop1 = cirq.X(q2)\nop2 = cirq_google.SYC(q1, q3)\ntry:\n    my_device.validate_moment(cirq.Moment([op1, op2]))\nexcept Exception as e:\n    print(e)\n\nmy_circuit = cirq.Circuit(\n    cirq.PhasedXPowGate(phase_exponent=0.3)(q1),\n    cirq.PhasedXPowGate(phase_exponent=0.3)(q2),\n    cirq_google.SYC(q1, q2),\n    cirq_google.SYC(q2, q3),\n)\nmy_device.validate_circuit(my_circuit)\n```\n\n----------------------------------------\n\nTITLE: VQE Ansatz Step Construction in Cirq\nDESCRIPTION: This code defines functions to construct one step of the VQE ansatz. `initial_step` prepares all qubits in the |+> state using the `prepare_plus_layer` function. `one_step` then applies the `rot_z_layer`, `rot_11_layer`, and `rot_x_layer` functions in sequence, with respective parameters `h_half_turns`, `j_half_turns`, and `x_half_turns`. The example then initializes a circuit, append both layers and then print the full circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/variational_algorithm.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef initial_step(length):\n    yield prepare_plus_layer(length)\n\ndef one_step(h, jr, jc, x_half_turns, h_half_turns, j_half_turns):\n    length = len(h)\n    yield rot_z_layer(h, h_half_turns)\n    yield rot_11_layer(jr, jc, j_half_turns)\n    yield rot_x_layer(length, x_half_turns)\n\nh, jr, jc = random_instance(3)\n\ncircuit = cirq.Circuit()  \ncircuit.append(initial_step(len(h)))\ncircuit.append(one_step(h, jr, jc, 0.1, 0.2, 0.3))\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Define QFT Circuit Generator Function in Python\nDESCRIPTION: This code defines a function `make_qft` that generates a Quantum Fourier Transform (QFT) circuit for a given list of qubits. It iterates through the qubits, applying a Hadamard gate to each and then controlled-Z rotations based on the remaining qubits. The function utilizes Cirq's `H` and `CZ` gates.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef make_qft(qubits):\n    \"\"\"Generator for the QFT on a list of qubits.\"\"\"\n    qreg = list(qubits)\n    while len(qreg) > 0:\n        q_head = qreg.pop(0)\n        yield cirq.H(q_head)\n        for i, qubit in enumerate(qreg):\n            yield (cirq.CZ ** (1 / 2 ** (i + 1))))(qubit, q_head)\n```\n\n----------------------------------------\n\nTITLE: Simulating Cirq Circuit with Custom Decomposed Gate\nDESCRIPTION: This code simulates the circuit containing the custom SWAP gate. The simulation results show that the state of the qubits has been swapped as defined by the custom gate's decomposition.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/custom_gates.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nsim.simulate(circ)\n```\n\n----------------------------------------\n\nTITLE: Creating Gates and Operations in Cirq with Python\nDESCRIPTION: This snippet demonstrates how to create gates and operations in Cirq. It shows examples of defining gates like CNOT and Pauli-Z, using exponentiation for square root gates, creating parameterized gates, and applying these gates to specific qubits to create operations. It also shows examples of creating line qubits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Example gates\ncnot_gate = cirq.CNOT\npauli_z = cirq.Z\n\n# Use exponentiation to get square root gates.\nsqrt_x_gate = cirq.X**0.5\n\n# Some gates can also take parameters\nsqrt_sqrt_y = cirq.YPowGate(exponent=0.25)\n\n# Create two qubits at once, in a line.\nq0, q1 = cirq.LineQubit.range(2)\n\n# Example operations\nz_op = cirq.Z(q0)\nnot_op = cirq.CNOT(q0, q1)\nsqrt_iswap_op = cirq.SQRT_ISWAP(q0, q1)\n\n# You can also use the gates you specified earlier.\ncnot_op = cnot_gate(q0, q1)\npauli_z_op = pauli_z(q0)\nsqrt_x_op = sqrt_x_gate(q0)\nsqrt_sqrt_y_op = sqrt_sqrt_y(q0)\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Transformer with @cirq.transformer\nDESCRIPTION: This code demonstrates creating custom transformers using the `@cirq.transformer` decorator.  It shows both a function-based transformer (`reverse_circuit`) and a class-based transformer (`SubstituteGate`). It constructs a sample circuit, then transforms and prints the original and transformed circuits using the custom transformers.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/custom_transformers.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@cirq.transformer\ndef reverse_circuit(circuit, *, context=None):\n    \"\"\"Transformer to reverse the input circuit.\"\"\"\n    return circuit[::-1]\n\n\n@cirq.transformer\nclass SubstituteGate:\n    \"\"\"Transformer to substitute `source` gates with `target` in the input circuit.\"\"\"\n\n    def __init__(self, source, target):\n        self._source = source\n        self._target = target\n\n    def __call__(self, circuit, *, context=None):\n        batch_replace = []\n        for i, op in circuit.findall_operations(lambda op: op.gate == self._source):\n            batch_replace.append((i, op, self._target.on(*op.qubits)))\n        transformed_circuit = circuit.unfreeze(copy=True)\n        transformed_circuit.batch_replace(batch_replace)\n        return transformed_circuit\n\n\n# Build your circuit\nq = cirq.NamedQubit(\"q\")\ncircuit = cirq.Circuit(\n    cirq.X(q), cirq.CircuitOperation(cirq.FrozenCircuit(cirq.X(q), cirq.Y(q))), cirq.Z(q)\n)\n# Transform and compare the circuits.\nsubstitute_gate = SubstituteGate(cirq.X, cirq.S)\nprint(\"Original Circuit:\", circuit, \"\\n\", sep=\"\\n\")\nprint(\"Reversed Circuit:\", reverse_circuit(circuit), \"\\n\", sep=\"\\n\")\nprint(\"Substituted Circuit:\", substitute_gate(circuit), sep=\"\\n\")\n```\n\n----------------------------------------\n\nTITLE: Creating a PasqalVirtualDevice with specified control radius\nDESCRIPTION: This snippet demonstrates how to create a `PasqalVirtualDevice` with a specified control radius and a set of qubits. The `control_radius` parameter defines the maximum distance between qubits for two-qubit gates.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/pasqal/devices.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq_pasqal import PasqalVirtualDevice\n\n# A PasqalVirtualDevice with a control radius of 2.0 times the lattice spacing.\np_device = PasqalVirtualDevice(control_radius=2.0, qubits=p_qubits)\n\n```\n\n----------------------------------------\n\nTITLE: Nesting Circuits with CircuitOperation\nDESCRIPTION: This code demonstrates how to nest a subcircuit within a main circuit using `cirq.CircuitOperation`. The subcircuit is first frozen to prevent further modifications, and then wrapped in a `CircuitOperation` and added to the main circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nsubcircuit = cirq.Circuit(cirq.H(q1), cirq.CZ(q0, q1), cirq.CZ(q2, q1), cirq.H(q1))\nsubcircuit_op = cirq.CircuitOperation(subcircuit.freeze())\ncircuit = cirq.Circuit(cirq.H(q0), cirq.H(q2), subcircuit_op)\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Applying a Pauli-X Gate to a Qubit in Cirq with Python\nDESCRIPTION: This snippet creates a Pauli-X gate using `cirq.X` and then applies it to the first qubit in the `qubits` list using `x_gate(qubits[0])`. It prints the resulting operation, showcasing how to transform a gate into an operation on a specific qubit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# This is a Pauli X gate. It is an object instance.\nx_gate = cirq.X\n# Applying it to the qubit at location (0, 0) (defined above)\n# turns it into an operation.\nx_op = x_gate(qubits[0])\n\nprint(x_op)\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Two-Qubit Gate in Cirq\nDESCRIPTION: This code defines a custom two-qubit gate by inheriting from cirq.Gate. It specifies the number of qubits as 2 using the `_num_qubits_` method and provides the unitary matrix representation using the `_unitary_` method. The `_circuit_diagram_info_` method specifies the symbols for each qubit in the circuit diagram.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/custom_gates.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass AnotherGate(cirq.Gate):\n    def __init__(self):\n        super(AnotherGate, self)\n\n    def _num_qubits_(self):\n        return 2\n    \n    def _unitary_(self):\n        return np.array([\n            [1.0, -1.0, 0.0,  0.0],\n            [0.0,  0.0, 1.0,  1.0],\n            [1.0,  1.0, 0.0,  0.0],\n            [0.0,  0.0, 1.0, -1.0]\n        ]) / np.sqrt(2)\n    \n    def _circuit_diagram_info_(self, args):\n        return \"Top wire symbol\", \"Bottom wire symbol\"\n\nthis_gate = AnotherGate()\n```\n\n----------------------------------------\n\nTITLE: Creating two basic quantum circuits with Cirq\nDESCRIPTION: This snippet creates two quantum circuits, `circuit1` and `circuit2`, using the Cirq library. Each circuit consists of a Hadamard gate, a Z gate with different exponents, another Hadamard gate, and a measurement gate, all acting on a single qubit. The circuits are then printed to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nq0 = cirq.LineQubit(0)\n\ncircuit1 = cirq.Circuit([cirq.H(q0), cirq.Z(q0)**0.5, cirq.H(q0), cirq.measure(q0)])\nprint(f\"circuit1:\\n{circuit1}\")\n\ncircuit2 = cirq.Circuit([cirq.H(q0), cirq.Z(q0)**0.25, cirq.H(q0), cirq.measure(q0)])\nprint(f\"circuit2:\\n{circuit2}\")\n```\n\n----------------------------------------\n\nTITLE: Generating Quantum Walk and Sampling with Cirq\nDESCRIPTION: This code defines the `generate_walk()` function, which constructs a quantum circuit for the quantum walk, simulates it, and returns the final distribution of the walker's position. It initializes the circuit, appends the initial state and the walk steps, measures the position qubits, and runs the simulation using `cirq.Simulator()`. The results are then converted into a histogram.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/quantum_walks.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nnumber_qubits = 7\niterator = 30\nsample_number = 5000\n\ndef generate_walk(number_qubits, iterator, sample_number):\n\n    circuit = cirq.Circuit()\n\n    circuit.append(initial_state())\n    for j in range(iterator):\n        circuit.append(walk_step())\n    circuit.append(cirq.measure(*qubits, key='x'))\n\n    simulator = cirq.Simulator()\n    result = simulator.run(circuit, repetitions=sample_number)\n    final = result.histogram(key='x')\n\n    return final\n\nfinal = generate_walk(number_qubits, iterator, sample_number)\nprint(final)\n```\n\n----------------------------------------\n\nTITLE: Fourier Transform over Z_2^n in Python\nDESCRIPTION: Implements the Fourier transform over the Z_2^n group.  It takes a numpy array 'v' of length 2**n as input, where n is an integer. It iterates through all possible values of 'y' and 'x' from 0 to N-1, calculating the Fourier coefficient for each 'y' based on the input array 'v' and the bitwise dot product. The function returns a numpy array 'v_hat' containing the Fourier transformed values, normalized by the square root of N.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef fourier_transform_over_z2(v: np.ndarray) -> np.ndarray:\n    \"\"\"Fourier transform function over z_2^n group.\n\n    Args:\n        v: an array with 2**n elements.\n\n    Returns:\n        vs: a numpy array with same length as input.\n    \"\"\"\n    N = len(v)\n    assert bin(N).count(\"1\") == 1, \"v must be a 2**n long vector\"\n    v_hat = np.array([0.0] * N)\n    for y in range(N):\n        for x in range(N):\n            v_hat[y] += ((-1)**bitwise_dot(x, y)) * v[x]\n    return v_hat / np.sqrt(N)\n```\n\n----------------------------------------\n\nTITLE: Creating a Parameterized Circuit in Cirq\nDESCRIPTION: This snippet defines a Cirq circuit with parameterized gates using `sympy.Symbol`. The symbolic value 's' is used as the exponent for `cirq.X` gates applied to two qubits. This allows for the gate strength to be varied during simulation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_61\n\nLANGUAGE: python\nCODE:\n```\nimport sympy as sp\n\n# Get qubits to use in the circuit.\na = cirq.NamedQubit(\"a\")\nb = cirq.NamedQubit(\"b\")\n\n# Define a parameterized value.\nval = sp.Symbol(\"s\")\n\n# Create a circuit.\ncircuit = cirq.Circuit(cirq.X.on(a) ** val, cirq.X.on(b) ** val)\n\n# Display it.\nprint(\"Circuit with parameterized gates:\\n\")\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Run a Cirq Circuit on Azure Quantum\nDESCRIPTION: Runs a Cirq circuit on the Azure Quantum service.  The `service.run()` method submits the circuit for execution, specifying the program (circuit) and the number of repetitions. The default target specified during service initialization is used.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_ionq.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nresult = service.run(program=circuit, repetitions=100)\n```\n\n----------------------------------------\n\nTITLE: Measuring a Single PauliString Observable in Cirq\nDESCRIPTION: Demonstrates the use of `cirq.measure_single_paulistring` to measure a PauliString observable. It shows how to package the observable into a PauliMeasurementGate and measure the qubits in the observable's eigenstates. The example showcases a circuit applying the observable directly and measuring the qubits independently, then contrasts this with using `cirq.measure_single_paulistring`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nsim = cirq.Simulator()\nobservable = Za * Zb\n# A PauliMeasurementGate.\ntyprint(cirq.measure_single_paulistring(observable, key='m'))\n# Measure the observable on the bell state.\ncircuit = cirq.Circuit(\n    cirq.H(a), cirq.CNOT(a, b), cirq.measure_single_paulistring(observable, key='m')\n)\nprint(f\"dirac notation: {sim.simulate(circuit).dirac_notation()}\")\nprint(f\"measurements: {sim.run(circuit, repetitions=100).histogram(key='m')}\")\n```\n\nLANGUAGE: python\nCODE:\n```\n# The same circuit, but applying the observable as an operator and measuring separately.\ncircuit = cirq.Circuit(cirq.H(a), cirq.CNOT(a, b), observable, cirq.measure([a, b], key='m'))\nprint(f\"dirac notation: {sim.simulate(circuit).dirac_notation()}\")\nprint(f\"measurements: {sim.run(circuit, repetitions=100).histogram(key='m')}\")\n```\n\n----------------------------------------\n\nTITLE: Decomposing a Toffoli Gate\nDESCRIPTION: This code snippet demonstrates the decomposition of a 3-qubit Toffoli gate (controlled-controlled-X) into simpler gates that can be executed on devices with limited qubit support. It shows how to use cirq.decompose and create a circuit with the decomposed gates.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nq0, q1, q2 = cirq.LineQubit.range(3)\nprint(cirq.Circuit(cirq.decompose(cirq.TOFFOLI(q0, q1, q2))))\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Gate with Decompose Protocol in Cirq\nDESCRIPTION: This code defines a custom `HXGate` class that inherits from `cirq.Gate` and implements the `_decompose_` method. This method specifies how the custom gate can be decomposed into simpler gates (Hadamard and X gates in this case).\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_56\n\nLANGUAGE: python\nCODE:\n```\nclass HXGate(cirq.Gate):\n    def _num_qubits_(self) -> int:\n        return 1\n\n    def _decompose_(self, qubits):\n        return cirq.H(*qubits), cirq.X(*qubits)\n\n    def __str__(self):\n        return 'HX'\n```\n\n----------------------------------------\n\nTITLE: Appending Multiple Operations Simultaneously in Cirq with Python\nDESCRIPTION: This snippet demonstrates appending multiple operations at once. It creates two moments in the `Circuit` object by adding gates that can and cannot be executed in the same time slice because they operate on the same qubits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit()\ncircuit.append([cirq.CZ(q0, q1), cirq.H(q2), cirq.H(q0), cirq.CZ(q1, q2)])\n\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Run Cirq Circuit on IonQ QPU via Azure Quantum\nDESCRIPTION: Runs a Cirq circuit on the IonQ QPU via Azure Quantum.  The `target` argument is explicitly set to `\"ionq.qpu\"`. A timeout is specified to accommodate potential queue times.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_ionq.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nresult = service.run(\n    program=circuit,\n    repetitions=100,\n    target=\"ionq.qpu\",\n    timeout_seconds=500 # Set timeout to 500 seconds to accommodate current queue time on QPU\n)\n```\n\n----------------------------------------\n\nTITLE: Set Input State of Eigenvalue Register in Python\nDESCRIPTION: This code adds a Pauli-X gate to the `u_bit` at the beginning of the circuit to prepare the |1> eigenstate, as the initial state is |0> and the phase acquired from the operator is trivial in that case.  This ensures a non-trivial phase is accumulated during the controlled unitary operations. The gate is inserted at the beginning of the circuit using `phase_estimator.insert(0, cirq.X(u_bit))`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Set the input state of the eigenvalue register.\"\"\"\n# Add gate to change initial state to |1>.\nphase_estimator.insert(0, cirq.X(u_bit))\n```\n\n----------------------------------------\n\nTITLE: Creating a measurement gate\nDESCRIPTION: This code creates a `cirq.MeasurementGate` object with one qubit and a specified key for identifying the measurement results.  It then prints the gate.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/operators.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nmeasurement = cirq.MeasurementGate(num_qubits=1, key=\"key\")\nprint(\"Measurement:\", measurement)\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Quantum Circuit in Cirq\nDESCRIPTION: This code defines a basic quantum circuit using Cirq. It initializes two qubits, applies square root X gates, a CZ gate, and optionally measures the qubits. The circuit is then printed to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/simulation.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nq0 = cirq.GridQubit(0, 0)\nq1 = cirq.GridQubit(1, 0)\n\n\ndef basic_circuit(meas=True):\n    sqrt_x = cirq.X**0.5\n    yield sqrt_x(q0), sqrt_x(q1)\n    yield cirq.CZ(q0, q1)\n    yield sqrt_x(q0), sqrt_x(q1)\n    if meas:\n        yield cirq.measure(q0, key='q0'), cirq.measure(q1, key='q1')\n\n\ncircuit = cirq.Circuit()\ncircuit.append(basic_circuit())\n\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Simulating with Specific Qubit Order\nDESCRIPTION: This code simulates a circuit with a specific qubit order, demonstrating how qubit order affects the final state vector.  It initializes qubits with names, creates a simple circuit with a X gate on one qubit and prints the absolute value of the final state vector.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/simulation.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nq_stay = cirq.NamedQubit('q_stay')\nq_flip = cirq.NamedQubit('q_flip')\nc = cirq.Circuit(cirq.X(q_flip))\n\n# first qubit in order flipped\nresult = simulator.simulate(c, qubit_order=[q_flip, q_stay])\nprint(abs(result.final_state_vector).round(3))\n```\n\n----------------------------------------\n\nTITLE: Monte Carlo wavefunction simulation\nDESCRIPTION: Illustrates simulating a noisy circuit using Monte Carlo wavefunction simulation with `cirq.Simulator`. The example defines a circuit with a bit-flip channel and then simulates it to observe the stochastic output of the wavefunction. The `cirq.Simulator` samples a Kraus operator and applies it, which results in different outcomes on each run.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# Get a circuit.\nqbit = cirq.NamedQubit(\"Q\")\ncircuit = cirq.Circuit(cirq.bit_flip(p=0.5).on(qbit))\n\n# Display it.\nprint(\"Simulating circuit:\")\nprint(circuit)\n\n# Simulate with the cirq.Simulator.\nsim = cirq.Simulator()\npsi = sim.simulate(circuit).dirac_notation()\n\n# Display the final wavefunction.\nprint(\"\\nFinal wavefunction:\")\nprint(psi)\n```\n\n----------------------------------------\n\nTITLE: Simulating with Alternate Qubit Order\nDESCRIPTION: This code simulates a circuit with an alternative qubit order, demonstrating how changing the qubit order affects the final state vector. It reverses the qubit order from the previous example.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/simulation.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# second qubit in order flipped\nresult = simulator.simulate(c, qubit_order=[q_stay, q_flip])\nprint(abs(result.final_state_vector).round(3))\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Swap Gate with Decomposition in Cirq\nDESCRIPTION: This code defines a custom SWAP gate in Cirq by specifying its decomposition into three CNOT gates. The `_decompose_` method defines the decomposition of the gate into a sequence of other gates. The `_circuit_diagram_info_` method sets the display name of the gate in the circuit diagram.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/custom_gates.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass MySwap(cirq.Gate):\n    def __init__(self):\n        super(MySwap, self)\n\n    def _num_qubits_(self):\n        return 2\n\n    def _decompose_(self, qubits):\n        a, b = qubits\n        yield cirq.CNOT(a, b)\n        yield cirq.CNOT(b, a)\n        yield cirq.CNOT(a, b)\n    \n    def _circuit_diagram_info_(self, args):\n        return [\"CustomSWAP\"] * self.num_qubits()\n\nmy_swap = MySwap()\n```\n\n----------------------------------------\n\nTITLE: Inserting Operations with a New Moment Strategy\nDESCRIPTION: This snippet shows how to insert each operation of a circuit into its own `Moment` using `cirq.InsertStrategy.NEW`. This is important when designing circuits for Pasqal devices.  A circuit containing simultaneous Hadamard gates that would fail validation is converted into a valid circuit by ensuring each operation is in its own moment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/pasqal/getting_started.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ninitial_circuit = cirq.Circuit()\ninitial_circuit.append(cirq.H(p_qubits[0]))\ninitial_circuit.append(cirq.H(p_qubits[1]))\nprint('Initial Circuit, does not pass validation:')\nprint(initial_circuit)\ntry:\n    p_device.validate_circuit(initial_circuit)\nexcept ValueError as e:\n    # Uh oh!  This circuit does not pass validation.\n    print(e)\n\npasqal_circuit = cirq.Circuit(initial_circuit.all_operations(),\n                              strategy=cirq.InsertStrategy.NEW)\nprint('')\nprint('Converted Circuit, passes validation:')\nprint(pasqal_circuit)\n\n# Now the circuit validates correctly!\np_device.validate_circuit(pasqal_circuit)\n```\n\n----------------------------------------\n\nTITLE: Converting Results to Cirq Result\nDESCRIPTION: This snippet demonstrates how to convert the results obtained from the IonQ API to a `cirq.Result` object.  This allows the user to take advantage of existing Cirq result analysis tooling.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/getting_started.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nprint(results.to_cirq_result())\n```\n\n----------------------------------------\n\nTITLE: Creating a parameterized quantum circuit using SymPy\nDESCRIPTION: This snippet defines a parameterized quantum circuit using the SymPy library for symbolic computation within Cirq. It creates a symbolic parameter 'theta', then constructs a circuit containing a Hadamard gate, a parameterized Z gate, another Hadamard gate, and a measurement gate. This parameterized circuit allows running the same circuit with different values of 'theta'.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\ntheta = sympy.Symbol(\"theta\")\n\ncircuit = cirq.Circuit([cirq.H(q0), cirq.Z(q0)**theta, cirq.H(q0), cirq.measure(q0)])\nprint(f\"circuit:\\n{circuit}\")\n```\n\n----------------------------------------\n\nTITLE: Visualize QFT Circuit with Cirq in Python\nDESCRIPTION: This snippet generates a QFT circuit for 4 qubits using the `make_qft` function and prints it out. It initializes 4 line qubits using `cirq.LineQubit.range(4)`, then constructs a `cirq.Circuit` from the output of the `make_qft` function, and finally prints the resulting circuit for visual inspection.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Visually check the QFT circuit.\"\"\"\nqubits = cirq.LineQubit.range(4)\nqft = cirq.Circuit(make_qft(qubits))\nprint(qft)\n```\n\n----------------------------------------\n\nTITLE: Running a Cirq Circuit with Simulator\nDESCRIPTION: This code simulates a Cirq circuit using the `cirq.Simulator`. It creates an instance of the simulator, runs the defined circuit, and prints the measurement results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/simulation.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsimulator = cirq.Simulator()\nresult = simulator.run(circuit)\n\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Measurement Operations in Cirq Quantum Circuit in Python\nDESCRIPTION: This code snippet shows the likely inclusion of measurement operations on qubits inside a Cirq circuit. These measurements are essential for extracting the computation results from a quantum simulation or a quantum device. It allows the program to observe the quantum state.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nimport cirq\n# Measurement operations on qubits\n# Specific measurement bases and target qubits require more context.\n```\n\n----------------------------------------\n\nTITLE: Use Built-in Inverse QFT Operation in Cirq with Python\nDESCRIPTION: This example demonstrates how to use the built-in `cirq.qft` function with the `inverse=True` argument to obtain the inverse QFT operation. It then constructs a `cirq.Circuit` from this operation. The `without_reverse=True` argument ensures no qubit reversal at the end of the circuit, and the circuit is printed for inspection.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Use the built-in inverse QFT in Cirq.\"\"\"\niqft_operation = cirq.qft(*qubits, inverse=True, without_reverse=True)\niqft_cirq = cirq.Circuit(iqft_operation)\nprint(iqft_cirq)\n```\n\n----------------------------------------\n\nTITLE: Getting the unitary representation of a gate\nDESCRIPTION: This code snippet shows how to obtain the unitary representation of a gate (in this case, the Pauli-X gate) using the `cirq.unitary` protocol. The resulting unitary matrix is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/operators.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nunitary = cirq.unitary(cirq.ops.X)\nprint(f\"Unitary of {unitary_operation.gate} is:\\n\", unitary)\n```\n\n----------------------------------------\n\nTITLE: Measure Observables in Circuit with Cirq\nDESCRIPTION: This snippet demonstrates how to use `cirq.measure_observables` to estimate the mean and variance of a sequence of PauliString observables in a quantum circuit. It requires `cirq` and defines observables as a list of PauliStrings (Za * Zb, 4 * Xa). The stopping criteria determines the number of repetitions used for estimation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.work.observable_measurement import measure_observables, RepetitionsStoppingCriteria\n\nobservables = [Za * Zb, 4 * Xa]\nresults = measure_observables(\n    circuit, observables, cirq.Simulator(), stopping_criteria=RepetitionsStoppingCriteria(100)\n)\n# Print the mean and variance measured for each observable\nfor result in results:\n    print(result.observable, result.mean, result.variance)\n```\n\n----------------------------------------\n\nTITLE: Connecting to Azure Quantum Service using Cirq\nDESCRIPTION: This snippet connects to the Azure Quantum service using the `AzureQuantumService` class from `azure.quantum.cirq`.  It requires the resource ID and location of your Azure Quantum Workspace, as well as a default target for Honeywell.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_honeywell.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom azure.quantum.cirq import AzureQuantumService\nservice = AzureQuantumService(\n    resource_id=\"\",\n    location=\"\",\n    default_target=\"honeywell.hqs-lt-s1-apival\"\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Cirq Device\nDESCRIPTION: This code defines a custom Cirq device called `MyDevice` that inherits from `cirq.Device`. It defines the available qubits (5 line qubits), supported gates (X, Y, Z, and CZ), and provides custom validation logic to ensure operations are valid on the device. The class contains methods to initialize the device, validate individual operations, validate entire circuits, and define device metadata. The validation logic enforces qubit availability, adjacency for two-qubit gates, and supported gate types. A global limit on the total number of CZ gates is also added.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/devices.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass MyDevice(cirq.Device):\n    \"\"\"Five qubits on a line, supporting X/Y/Z and CZ between neighbors.\"\"\"\n\n    def __init__(self):\n        # Specify the qubits available to the device\n        self._qubits = set(cirq.LineQubit.range(5))\n        # Specify which gates are valid\n        self._supported_gates = cirq.Gateset(\n            cirq.XPowGate, cirq.YPowGate, cirq.ZPowGate, cirq.CZPowGate\n        )\n\n    def validate_operation(self, operation):\n        \"\"\"Check to make sure `operation` is valid.\n\n        `operation` must be on qubits found on the device\n        and if it is a two qubit gate the qubits must be adjacent\n\n        Raises:\n          ValueError: if operation acts on qubits not found on the device.\n          ValueError: if two qubit gates have non-local interactions.\n          ValueError: if the operation is not in the supported gates.\n        \"\"\"\n        # Ensure that the operation's qubits are available on the device\n        if any(x not in self._qubits for x in operation.qubits):\n            raise ValueError(\"Using qubits not found on device.\")\n\n        # Ensure that the operation's qubits are adjacent if there are two of them\n        if len(operation.qubits) == 2:\n            p, q = operation.qubits\n            if not p.is_adjacent(q):\n                raise ValueError('Non-local interaction: {}'.format(repr(operation)))\n\n        # Ensure that the operation itself is a supported one\n        if operation not in self._supported_gates:\n            raise ValueError(\"Unsupported operation type.\")\n\n    def validate_circuit(self, circuit):\n        \"\"\"Check to make sure `circuit` is valid.\n\n        Calls validate_operation on all operations as well as imposing\n        a global limit on the total number of CZ gates.\n\n        Raises:\n          ValueError: if `validate_operation` raises for any operation in the\n            circuit.\n          ValueError: if there are more than 10 CZ gates in the entire circuit.\n        \"\"\"\n        # Call Device's `validate_operation`, which calls the `validate_operation`\n        #   function specified above on each operation in the circuit\n        super().validate_circuit(circuit)\n        # Ensure that no more than 10 two-qubit CZ gates exist in the circuit\n        cz_count = sum(1 for mom in circuit for op in mom if len(op.qubits) == 2)\n        if cz_count > 10:\n            raise ValueError(\"Too many total CZs\")\n\n    @property\n    def metadata(self):\n        \"\"\"MyDevice GridDeviceMetadata.\"\"\"\n        # Since `MyDevice` is planar it is a good idea to subclass the\n        # GridDeviceMetadata class to communicate additional device information to\n        # the user.\n        return cirq.GridDeviceMetadata(\n            qubit_pairs=[(p, q) for p in self._qubits for q in self._qubits if p.is_adjacent(q)],\n            gateset=self._supported_gates,\n        )\n```\n\n----------------------------------------\n\nTITLE: Create circuit from noisy OP_TREE\nDESCRIPTION: Demonstrates how to create a circuit from a noisy `cirq.OP_TREE` obtained using a noise model. The `noisy_moment` variable, which contains a noisy moment, is used to construct a new `cirq.Circuit`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ncirq.Circuit(noisy_moment)\n```\n\n----------------------------------------\n\nTITLE: Getting Kraus operators for a measurement gate\nDESCRIPTION: This code shows how to obtain the Kraus operators of a `cirq.MeasurementGate` using `cirq.kraus`.  The Kraus operators are printed, separated by newlines.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/operators.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nkraus_ops = cirq.kraus(measurement)\nprint(f\"Kraus operators of {measurement} are:\", *kraus_ops, sep=\"\\n\\n\")\n```\n\n----------------------------------------\n\nTITLE: Compiling Circuit for Google Target Gateset (Sycamore)\nDESCRIPTION: This code creates a circuit and then transforms it to be compatible with the Google Sycamore target gateset. The `cirq.optimize_for_target_gateset` function applies a sequence of optimizations to compile the circuit into a set of gates supported by the specified target.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/best_practices.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Create your circuit here\nmy_circuit = cirq.Circuit()\n\n# Convert the circuit to run on a Google target gateset.\n# The google specific `cirq.CompilationTargetGateset` specifies the target gateset\n# and a sequence of appropriate optimization routines that should be executed to compile\n# a circuit to run on this target. \nsycamore_circuit = cirq.optimize_for_target_gateset(my_circuit, gateset=cg.SycamoreTargetGateset())\n```\n\n----------------------------------------\n\nTITLE: Building Circuits by Appending Lists of Operations in Python\nDESCRIPTION: This code snippet demonstrates constructing a quantum circuit in Cirq by appending a preconstructed list of operations to the circuit. It initializes an empty circuit, creates a list of Hadamard gates applied to three line qubits using a list comprehension, appends the list of operations to the circuit, and then prints the resulting circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit()\nops = [cirq.H(q) for q in cirq.LineQubit.range(3)]\ncircuit.append(ops)\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: DensityMatrixSimulator with NoiseModel\nDESCRIPTION: Shows how to define a `cirq.DensityMatrixSimulator` with a specified noise model. In this example, a generalized amplitude damping channel is used as the noise model for the simulator.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nnoisy_dsim = cirq.DensityMatrixSimulator(noise=cirq.generalized_amplitude_damp(p=0.1, gamma=0.5))\n```\n\n----------------------------------------\n\nTITLE: Using PhaseFlipChannel in Cirq (Python)\nDESCRIPTION: This code demonstrates using the `cirq.PhaseFlipChannel` to simulate phase flip errors. It initializes a qubit in superposition using a Hadamard gate, applies the phase flip channel with a probability of 0.2, applies another Hadamard gate, and then measures the qubit. The simulation runs 1000 times, and the resulting histogram is printed to observe the effects of the phase flip.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/representing_noise.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nq0 = cirq.LineQubit(0)\ncircuit = cirq.Circuit(\n    cirq.H(q0),\n    cirq.phase_flip(p=0.2).on(q0),\n    cirq.H(q0),\n    cirq.measure(q0, key='result')\n)\nresult = cirq.Simulator(seed=0).run(circuit, repetitions=1000)\nprint(\"Phase flip:\", result.histogram(key='result'))\n```\n\n----------------------------------------\n\nTITLE: Generate Balanced and Constant Functions in Python\nDESCRIPTION: This code defines three functions: `gen_balanced_function`, `gen_constant_function`, and `choose_random_function`. `gen_balanced_function` generates a boolean function that returns -1 for half of the inputs and 1 for the other half. `gen_constant_function` generates a boolean function that returns either -1 or 1 for all inputs. `choose_random_function` randomly picks either a balanced or constant function.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef gen_balanced_function(N: int) -> np.ndarray:\n    \"\"\"Generates a balanced function for N bits.\n\n    Creates a function 𝑓:{0,1}^N → {−1,1}\n    where f(x)=-1 for half of the inputs and f(x)=1 for the other half.\n\n    Returns:\n       the function as represented by a 1-d numpy array of size N\n    \"\"\"\n    half_size = N // 2\n    f = np.ones(N)\n    flip_loc = np.random.permutation(N)[:half_size]\n    f[flip_loc] = -1\n    return f\n\n\ndef gen_constant_function(N: int) -> np.ndarray:\n    \"\"\"Generates a constant  function for N bits.\n\n    Creates a function 𝑓:{0,1}^𝑛 → {−1,1}\n    where f(x)=c for all inputs.\n    \n    c is randomly chosen as either -1 or 1, but, once chosen,\n    is constant for all values of x.\n\n    Returns:\n        the function as represented by a 1-d numpy array of size N\n    \"\"\"\n\n    flip = np.random.random() > 0.5\n    f = np.ones(N) if flip else -1 * np.ones(N)\n    return f\n\ndef choose_random_function() -> Tuple[str, np.ndarray]:\n    \"\"\"Randomly choose a function from constant or balanced distributions.\n\n    Returns:\n        a Tuple of the distribution (\"B\" or \"C\") and the function as an array.\n    \"\"\"\n    if np.random.rand() > 0.5:\n        f = gen_balanced_function(N)\n        dist = \"B\"\n    else:\n        f = gen_constant_function(N)\n        dist = \"C\"\n    return dist, f\n```\n\n----------------------------------------\n\nTITLE: Resolving Parameters - Python\nDESCRIPTION: This snippet shows how to resolve the parameters in a Cirq circuit using a dictionary. The `cirq.resolve_parameters` function replaces the symbolic parameter 'a' with the value 0.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nprint(cirq.resolve_parameters(circuit, {\"a\": 0}))\n```\n\n----------------------------------------\n\nTITLE: Creating parameterized gate using ZPowGate in Cirq\nDESCRIPTION: This snippet shows an alternative way to define a parameterized quantum circuit, using `cirq.ZPowGate` to create a parameterized Z gate.  The circuit consists of Hadamard gates, a ZPowGate with a symbolic exponent 'theta', and a measurement gate. The result is a parameterized circuit that can be used to simulate the system at different gate exponents.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit(\n    cirq.H(q0), cirq.ZPowGate(exponent=theta)(q0), cirq.H(q0), cirq.measure(q0)\n)\nprint(f\"circuit:\\n{circuit}\")\n```\n\n----------------------------------------\n\nTITLE: Validating Unitary Equivalence (Python)\nDESCRIPTION: This code snippet shows how to validate unitary equivalence using `cirq.testing.assert_allclose_up_to_global_phase`, ensuring that the routed circuit (with reordered qubits) performs the same unitary transformation as the original circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/routing_transformer.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nprint(circuit)\nprint(routed_circuit)\n\n# This will not raise an errors now\ncirq.testing.assert_allclose_up_to_global_phase(circuit.unitary(), routed_circuit.unitary(qubit_order=order), atol=1e-8)\n```\n\n----------------------------------------\n\nTITLE: Square Root of X Gate using __pow__ in Cirq\nDESCRIPTION: This example demonstrates how to create the square root of the X gate by raising `cirq.X` to the power of 0.5 using the `__pow__` method.  It shows how the gate's unitary matrix changes after this operation. This relies on cirq.unitary to display the matrix representation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/custom_gates.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nprint(cirq.unitary(cirq.X))\n# prints\n# [[0.+0.j 1.+0.j]\n#  [1.+0.j 0.+0.j]]\n\nsqrt_x = cirq.X**0.5\nprint(cirq.unitary(sqrt_x))\n# prints\n# [[0.5+0.5j 0.5-0.5j]\n#  [0.5-0.5j 0.5+0.5j]]\n```\n\n----------------------------------------\n\nTITLE: Displaying a Cirq Circuit\nDESCRIPTION: This code snippet demonstrates how to display a Cirq circuit composed of a list of quantum operations (ops). It uses the `cirq.Circuit` constructor to create a circuit from the provided `ops` list and prints the resulting circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nprint(cirq.Circuit(ops))\n```\n\n----------------------------------------\n\nTITLE: Creating Loschmidt Echo Circuit\nDESCRIPTION: This function creates a Loschmidt echo circuit using a random unitary U, defined by a sequence of random rotations between grid interaction layers. It takes qubits, the number of cycles (depth), a two-qubit gate, an optional pause duration, and a seed for random number generation as inputs.  It returns a Cirq circuit that performs the Loschmidt echo experiment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/echoes.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef create_loschmidt_echo_circuit(\n    qubits: Sequence[cirq.GridQubit],\n    cycles: int,\n    twoq_gate: cirq.Gate = cirq.FSimGate(np.pi / 4, 0.0),\n    pause: Optional[cirq.Duration] = None,\n    seed: Optional[int] = None,\n) -> cirq.Circuit:\n    \"\"\"Returns a Loschmidt echo circuit using a random unitary U.\n    \n    Args:\n        qubits: Qubits to use.\n        cycles: Depth of random rotations in the forward & reverse unitary.\n        twoq_gate: Two-qubit gate to use.\n        pause: Optional duration to pause for between U and U^\\dagger.\n        seed: Seed for circuit generation.\n    \"\"\"\n    # Forward (U) operations.\n    forward = random_rotations_between_grid_interaction_layers_circuit(\n        qubits,\n        depth=cycles,\n        two_qubit_op_factory=lambda a, b, _: twoq_gate.on(a, b),\n        pattern=cirq.experiments.GRID_STAGGERED_PATTERN,\n        single_qubit_gates=[cirq.PhasedXPowGate(phase_exponent=p, exponent=0.5)\n                            for p in np.arange(-1.0, 1.0, 0.25)],\n        seed=seed\n    )\n\n    # Optional pause.\n    if pause is not None:\n        wait = cirq.Moment(cirq.WaitGate(pause).on(q) for q in qubits)\n    else:\n        wait = []\n    \n    # Reverse (U^\\dagger) operations.\n    reverse = cirq.inverse(forward)\n\n    # Measure all qubits.\n    measure = cirq.measure(*qubits, key=\"z\")\n\n    return forward + wait + reverse + measure\n```\n\n----------------------------------------\n\nTITLE: Simulate Phase Estimation and Convert to Theta Values in Python\nDESCRIPTION: This code simulates the complete phase estimation circuit, retrieves measurement results, and converts the measured bitstrings into estimates of the phase `theta`. It runs the circuit using `cirq.Simulator`, then extracts the measurement results for the qubits. Finally, it converts these binary measurements to an estimated value for θ.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Simulate the circuit and convert from measured bit values to estimated θ values.\"\"\"\n# Simulate the circuit.\nsim = cirq.Simulator()\nresult = sim.run(phase_estimator, repetitions=10)\n\n# Convert from output bitstrings to estimate θ values.\ntheta_estimates = np.sum(2 ** np.arange(n_bits) * result.measurements['m'], axis=1) / 2**n_bits\nprint(theta_estimates)\n```\n\n----------------------------------------\n\nTITLE: Accessing State Vector with Cirq Simulator\nDESCRIPTION: This code demonstrates how to access the full state vector after simulating a circuit using `simulator.simulate`. It creates a circuit, simulates it without measurements, and prints the final state vector using numpy.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/simulation.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\ncircuit = cirq.Circuit()\ncircuit.append(basic_circuit(False))\nresult = simulator.simulate(circuit, qubit_order=[q0, q1])\n\nprint(np.around(result.final_state_vector, 3))\n```\n\n----------------------------------------\n\nTITLE: Using Custom Decomposed Swap Gate in Cirq Circuit\nDESCRIPTION: This code creates a Cirq circuit that uses the custom SWAP gate defined with a decomposition.  The X gate is applied to the first qubit, and then the custom SWAP gate is applied to the first two qubits.  The circuit diagram is printed, showing the custom SWAP gate.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/custom_gates.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nqreg = cirq.LineQubit.range(2)\ncirc = cirq.Circuit(\n    cirq.X(qreg[0]),\n    my_swap.on(*qreg)\n)\n\nprint(\"Circuit:\")\nprint(circ)\n```\n\n----------------------------------------\n\nTITLE: Generating Quantum Fourier Transform circuit in Cirq\nDESCRIPTION: This function should generate the Quantum Fourier Transform (QFT) circuit for a given list of qubits. It takes a list of qubits as input and yields the necessary gates to construct the QFT circuit in the correct order. The intended implementation is not provided in the source document.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef make_qft(qubits):\n    \"\"\"Generator for the QFT on a list of qubits.\n    \n    For four qubits, the answer is:\n    \n                          ┌───────┐   ┌────────────┐   ┌───────┐\n    0: ───H───@────────@───────────@───────────────────────────────────────\n              │        │           │\n    1: ───────@^0.5────┼─────H─────┼──────@─────────@──────────────────────\n                       │           │      │         │\n    2: ────────────────@^0.25──────┼──────@^0.5─────┼─────H────@───────────\n                                   │                │          │\n    3: ────────────────────────────@^(1/8)──────────@^0.25─────@^0.5───H───\n                      └───────┘   └────────────┘   └───────┘\n    \"\"\"\n    # Your code here!\n```\n\n----------------------------------------\n\nTITLE: Quantum Teleportation Circuit with Classical Control\nDESCRIPTION: This code creates a quantum teleportation circuit using classical control. The circuit prepares a message, creates a Bell state, performs Bell measurement and then applies X and Z gates on Bob's qubit based on the measurement results from Alice's qubit and the message qubit respectively.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/classical_control.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Teleports `_message` from Alice to Bob.\nalice = cirq.NamedQubit('alice')\nbob = cirq.NamedQubit('bob')\nmessage = cirq.NamedQubit('_message')\n\nmessage_circuit = cirq.Circuit(\n    # Create the message.\n    cirq.X(message) ** 0.371,\n    cirq.Y(message) ** 0.882,\n)\n\nteleport_circuit = cirq.Circuit(\n    # Create Bell state to be shared between Alice and Bob.\n    cirq.H(alice),\n    cirq.CNOT(alice, bob),\n    # Prepare message circuit\n    message_circuit,\n    # Bell measurement of the message and Alice's entangled qubit.\n    cirq.CNOT(message, alice),\n    cirq.H(message),\n    cirq.measure(message, key='M'),\n    cirq.measure(alice, key='A'),\n    # Uses the two classical bits from the Bell measurement to recover the\n    # original quantum message on Bob's entangled qubit.\n    cirq.X(bob).with_classical_controls('A'),\n    cirq.Z(bob).with_classical_controls('M'),\n)\nprint(circuit)\n\n# Simulate the message and teleport circuits for Bloch vectors to compare\n#     the state of the teleported qubit before and after teleportation.\nsim = cirq.Simulator()\nmessage_bloch_vector = cirq.bloch_vector_from_state_vector(\n    sim.simulate(message_circuit).final_state_vector, index=0\n)\nteleport_bloch_vector = cirq.bloch_vector_from_state_vector(\n    sim.simulate(teleport_circuit).final_state_vector, index=2\n)\nprint(f\"Message Qubit State: {message_bloch_vector}\")\nprint(f\"Teleported Bob's Qubit state: {teleport_bloch_vector}\")\n```\n\n----------------------------------------\n\nTITLE: Get a circuit to simulate\nDESCRIPTION: This snippet defines a function `basic_circuit` that generates a simple quantum circuit with single and two-qubit gates, including optional measurements. It utilizes square root of X gates and a CZ gate. The function yields these operations and optionally adds measurement gates at the end. A circuit with measurements is created using this function and printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Get a circuit to simulate.\"\"\"\n\n\ndef basic_circuit(measure=True):\n    \"\"\"Returns a simple circuit with some one- and two-qubit gates,\n    as well as (optionally) measurements.\n    \"\"\"\n    # Gates we will use in the circuit.\n    sqrt_x = cirq.X**0.5\n    cz = cirq.CZ\n\n    # Yield the operations.\n    yield sqrt_x(a), sqrt_x(b)\n    yield cz(a, b)\n    yield sqrt_x(a), sqrt_x(b)\n    if measure:\n        yield cirq.measure(a, b)\n\n\n# Create a circuit including measurements.\ncircuit = cirq.Circuit(basic_circuit())\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Single-Qubit Gate in Cirq\nDESCRIPTION: This code defines a custom single-qubit gate in Cirq by inheriting from cirq.Gate and implementing the _num_qubits_ and _unitary_ magic methods.  The _num_qubits_ method specifies that the gate acts on one qubit, and the _unitary_ method defines the gate's unitary matrix. The _circuit_diagram_info_ method defines the symbol to display in circuit diagrams.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/custom_gates.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass MyGate(cirq.Gate):\n    def __init__(self):\n        super(MyGate, self)\n        \n    def _num_qubits_(self):\n        return 1\n    \n    def _unitary_(self):\n        return np.array([\n            [1.0,  1.0],\n            [-1.0, 1.0]\n        ]) / np.sqrt(2)\n    \n    def _circuit_diagram_info_(self, args):\n        return \"G\"\n\nmy_gate = MyGate()\n```\n\n----------------------------------------\n\nTITLE: Edge Coloring for CZ Gate Optimization\nDESCRIPTION: Implements a greedy algorithm to solve the edge coloring problem for optimizing the arrangement of CZ gates in the quantum circuit. The goal is to reduce the number of moments by grouping CZ gates that don't share qubits.  The input is the adjacency matrix of a graph.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/hidden_linear_function.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef edge_coloring(A):\n    \"\"\"Solves edge coloring problem.\n    \n    Args:\n        A: adjacency matrix of a graph.\n    \n    Returns list of lists of edges, such as edges in each list \n    do not have common vertex. \n    Tries to minimize length of this list.\n    \"\"\"\n    A = np.copy(A)\n    n = A.shape[0]\n    ans = []\n    while np.max(A) != 0:\n        edges_group = []\n        used = np.zeros(n, dtype=bool)\n        for i in range(n):\n            for j in range(n):\n                if A[i][j] == 1 and not used[i] and not used[j]:\n                    edges_group.append((i, j))\n                    A[i][j] = 0\n                    used[i] = used[j] = True\n        ans.append(edges_group)\n    return ans\n```\n\n----------------------------------------\n\nTITLE: Creating a circuit from generator functions\nDESCRIPTION: This snippet defines a function `xor_swap` that generates a sequence of CNOT gates to perform a qubit swap using XOR operations.  It then creates a Cirq circuit using the generated operations, demonstrating the auto-flattening feature of Cirq circuits when constructed from generators.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Creating a circuit from generator functions.\"\"\"\n\n\ndef xor_swap(a, b):\n    \"\"\"Swaps two qubits with three CNOTs.\"\"\"\n    yield cirq.CNOT(a, b)  # |a> |b> --> |a> |a ^ b>\n    yield cirq.CNOT(b, a)  # |a> |a ^ b> --> |a ^ a ^ b> | a ^ b> = |b>|a^b>\n    yield cirq.CNOT(a, b)  # |b> |a ^ b> --> |b>|a ^ b ^ b> = |b> |a>\n\n\ncirq.Circuit(xor_swap(a, b))\n```\n\n----------------------------------------\n\nTITLE: Creating a Circuit for Expectation Value\nDESCRIPTION: This code uses the `cirq.contrib.quimb` (ccq) library to create a circuit that allows computation of the expectation value of the ZZ observable.  It constructs a circuit that includes the original circuit, the observable, and the adjoint of the original circuit. The resulting circuit is then visualized.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ntot_c = ccq.circuit_for_expectation_value(circuit, ZZ)\nSVGCircuit(tot_c)\n```\n\n----------------------------------------\n\nTITLE: Simulating Grover's Algorithm with Pasqal Noise Model in Cirq\nDESCRIPTION: This snippet demonstrates how to incorporate a custom noise model (PasqalNoiseModel) into a Cirq circuit for simulating the effects of noise on a quantum computation. It requires the `cirq` library and a pre-defined device object. It simulates the grover circuit with the custom noise and plots the noisy results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/pasqal/getting_started.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Use the custom noise model of Pasqal devices\nnoise_model = PasqalNoiseModel(device)\ngrover_circuit = generate_pasqal_grover()\ngrover_circuit = grover_circuit.with_noise(noise_model)\ngrover_circuit.append(cirq.measure(*q_meas, key='x'))\n\n# Run a simulation locally locally\ndata_raw = sampler.run(grover_circuit, repetitions=200)\n\n# Plot the results\ndata0 = data_raw.data.to_dict()\nvec=[j for j in range(4)]\nres=np.zeros(len(vec))\nfor jj in range(200):\n    number = data0['x'][jj]\n    res[number] += 1\nres=res/200.\n\nfig = plt.figure()\nax = fig.add_axes([0.16, 0.16, 0.78, 0.78])\nax.plot(vec, res,'o')\nax.set_xticks(vec)\nax.set_xticklabels([r'$|00\\rangle$',r'$|01\\rangle$', r'$|10\\rangle$', r'$|11\\rangle$'])\nplt.xlabel(r'$j$', fontsize=20)\nplt.ylabel(r'$p$', fontsize=20)\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Simulating Cirq Circuit with Custom Gate\nDESCRIPTION: This code simulates a Cirq circuit containing a custom gate using the cirq.Simulator. The simulation results are then printed, demonstrating that circuits with custom gates can be simulated like standard Cirq circuits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/custom_gates.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsim = cirq.Simulator()\n\nres = sim.simulate(circ)\nprint(res)\n```\n\n----------------------------------------\n\nTITLE: Creating a Bell State Circuit in Cirq\nDESCRIPTION: This code snippet creates a basic Bell state circuit using Cirq. It initializes a circuit, defines two qubits, applies a Hadamard gate to the first qubit, applies a CNOT gate with the first qubit as control and the second as target, and then measures both qubits. The circuit is then printed to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/rigetti/getting_started.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nbell_circuit = cirq.Circuit()\nqubits = cirq.LineQubit.range(2)\nbell_circuit.append(cirq.H(qubits[0]))\nbell_circuit.append(cirq.CNOT(qubits[0], qubits[1]))\nbell_circuit.append(cirq.measure(qubits[0], qubits[1], key='m'))\nprint(bell_circuit)\n```\n\n----------------------------------------\n\nTITLE: Building a Noise Model with cirq_google\nDESCRIPTION: This code snippet demonstrates how to construct a noise model from noise properties using the `cirq_google.NoiseModelFromGoogleNoiseProperties` function.  The resulting `noise_model` can be used for simulating noisy quantum circuits, particularly within a Quantum Virtual Machine (QVM).\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_26\n\nLANGUAGE: Python\nCODE:\n```\nnoise_model = cirq_google.NoiseModelFromGoogleNoiseProperties(noise_props)\n```\n\n----------------------------------------\n\nTITLE: Using BitFlipChannel in Cirq (Python)\nDESCRIPTION: This code snippet demonstrates how to use the `cirq.BitFlipChannel` (or `cirq.bit_flip`) to simulate bit flip errors. It creates a circuit with a bit flip channel applied to a qubit and then measures the qubit. The probability of a bit flip is set to 0.2, and the simulation is run 1000 times to generate a histogram of the measurement results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/representing_noise.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nq0 = cirq.LineQubit(0)\ncircuit = cirq.Circuit(\n    cirq.bit_flip(p=0.2).on(q0),\n    cirq.measure(q0, key='result')\n)\nresult = cirq.Simulator(seed=0).run(circuit, repetitions=1000)\nprint(result.histogram(key='result'))\n```\n\n----------------------------------------\n\nTITLE: Creating a controlled Hadamard gate\nDESCRIPTION: This snippet creates a controlled Hadamard gate using `cirq.ControlledGate` with the `cirq.H` gate as the sub-gate. It then prints the unitary matrix representation of the controlled Hadamard gate, rounded to 3 decimal places.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/operators.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ncontrolled_hadamard = cirq.ControlledGate(sub_gate=cirq.H, num_controls=1)\nprint(cirq.unitary(controlled_hadamard).round(3))\n```\n\n----------------------------------------\n\nTITLE: Plotting Histogram from Sparse Results with Cirq\nDESCRIPTION: This snippet demonstrates plotting only the non-zero entries in a histogram by first computing the histogram using `result.histogram()` and passing its result to `cirq.plot_state_histogram`. This prevents plotting unnecessary zero-count states in sparse results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/state_histograms.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nhistogram = result.histogram(key = 'measure_all')\n_ = cirq.plot_state_histogram(histogram, plt.subplot())\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Example Classical Post-Processing Python\nDESCRIPTION: This code demonstrates how to use the classical post-processing function to interpret the measurement from an order-finding circuit. It sets the values of n and x, samples the circuit, prints the raw measurements and the integer in the exponent register, and then calls the `process_measurement` function to determine the order.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Example of the classical post-processing.\"\"\"\n# Set n and x here\nn = 6\nx = 5\n\nprint(f\"Finding the order of x = {x} modulo n = {n}\\n\")\nmeasurement = cirq.sample(circuit, repetitions=1)\nprint(\"Raw measurements:\")\nprint(measurement)\n\nprint(\"\\nInteger in exponent register:\")\nprint(measurement.data)\n\nr = process_measurement(measurement, x, n)\nprint(\"\\nOrder r =\", r)\nif r is not None:\n    print(f\"x^r mod n = {x}^{r} mod {n} = {x**r % n}\")\n```\n\n----------------------------------------\n\nTITLE: Appending Operations to a Circuit in Cirq with Python\nDESCRIPTION: This snippet demonstrates how to append operations to a circuit using the `Circuit.append` method. It first defines three grid qubits and creates an empty circuit. It then appends a `CZ` gate between the first two qubits and a Hadamard gate on the third qubit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nq0, q1, q2 = [cirq.GridQubit(i, 0) for i in range(3)]\ncircuit = cirq.Circuit()\ncircuit.append([cirq.CZ(q0, q1), cirq.H(q2)])\n\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Running a Circuit on QPU\nDESCRIPTION: This snippet runs the same circuit as above but specifies the `qpu` target. This ensures that the circuit is run on the actual IonQ quantum processing unit. Note that running on the QPU may take longer due to queue times.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/getting_started.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nresult = service.run(circuit, repetitions=100, target='qpu')\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Running a Bell State Circuit on Rigetti QVM\nDESCRIPTION: This code snippet imports necessary modules, retrieves a RigettiQCSService instance connected to the QVM, runs the Bell state circuit on the QVM, and prints the measurement histogram. It uses the first available processor from the previously listed processors. The `as_qvm=True` argument specifies that the circuit should run on the Quantum Virtual Machine.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/rigetti/getting_started.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq_rigetti import circuit_transformers, circuit_sweep_executors, get_rigetti_qcs_service\n\nSERVICE_NAME = processors_list[0]\nprint(SERVICE_NAME)\nservice = get_rigetti_qcs_service(SERVICE_NAME, as_qvm=True, noisy=False)\nresult = service.run(bell_circuit, repetitions=1000)\n\nprint(result.histogram(key='m'))\n```\n\n----------------------------------------\n\nTITLE: Creating a Linspace parameter sweep in Cirq\nDESCRIPTION: This snippet demonstrates how to create a parameter sweep using `cirq.Linspace`. It defines a sweep of 5 equally spaced values for the parameter 'theta' between 0 and 2.5. The snippet iterates through the sweep and prints each parameter value.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Create a sweep over 5 equally spaced values from 0 to 2.5.\nparams = cirq.Linspace(key=\"theta\", start=0, stop=2.5, length=5)\nfor param in params:\n    print(param)\n```\n\n----------------------------------------\n\nTITLE: Setting up Virtual Engine with Noisy Simulator\nDESCRIPTION: This snippet creates a device object, a simulated processor object, and a virtual engine. It packages the noisy simulator and device within the engine to mimic the interface used for real quantum processors. This allows running circuits on the QVM in a similar way as on real Google quantum hardware.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/quantum_virtual_machine.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Package the simulator and device in an Engine.\n# The device object\ndevice = cirq_google.engine.create_device_from_processor_id(processor_id)\n# The simulated processor object\nsim_processor = cirq_google.engine.SimulatedLocalProcessor(\n    processor_id=processor_id, sampler=sim, device=device, calibrations={cal.timestamp // 1000: cal}\n)\n# The virtual engine\nsim_engine = cirq_google.engine.SimulatedLocalEngine([sim_processor])\nprint(\n    \"Your quantum virtual machine\",\n    processor_id,\n    \"is ready, here is the qubit grid:\",\n    \"\\n========================\\n\",\n)\nprint(sim_engine.get_processor(processor_id).get_device())\n```\n\n----------------------------------------\n\nTITLE: Initializing IonQ Service with API Key in Python\nDESCRIPTION: This snippet shows how to instantiate a `cirq_ionq.Service` object, passing the IonQ API key directly as a parameter. The API key grants access to IonQ's quantum computing resources. The code assumes that `cirq_ionq` is already installed and available in the Python environment. This method requires storing the API key in the code.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/access.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cirq_ionq as ionq\n\nservice = ionq.Service(api_key='tomyheart')\n```\n\n----------------------------------------\n\nTITLE: Physical Z Gate in Cirq\nDESCRIPTION: This code demonstrates how to apply a physical Z gate in Cirq using `cirq_google.PhysicalZTag`. Adding this tag to a Z gate forces the hardware to perform a physical operation that affects the frequency of the qubit, incurring a duration of 20 ns.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/devices.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncirq.Z(cirq.GridQubit(5, 5)).with_tags(cirq_google.PhysicalZTag())\n```\n\n----------------------------------------\n\nTITLE: Setting up a Cirq Sampler\nDESCRIPTION: This snippet sets up a Cirq sampler for running the quantum circuits. It checks if `device_name` is `None`. If so, it uses a `cirq.DensityMatrixSimulator` with a depolarizing noise model. Otherwise, it attempts to use `cirq_google` to get a sampler from a real quantum device using the Google Quantum Engine.  The `device_name` variable is a placeholder and should be set to the name of a real device for actual hardware experiments.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/isolated_xeb.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndevice_name = None  # change me!\n\nif device_name is None:\n    sampler = cirq.DensityMatrixSimulator(noise=cirq.depolarize(5e-3))\nelse:\n    import cirq_google as cg\n    sampler = cg.get_engine_sampler(device_name, gate_set_name='sqrt_iswap')\n    device = cg.get_engine_device(device_name)\n\n    import cirq.contrib.routing as ccr\n    graph = ccr.gridqubits_to_graph_device(device.qubits)\n    pos = {q: (q.row, q.col) for q in graph.nodes}\n    import networkx as nx\n    nx.draw_networkx(graph, pos=pos)\n```\n\n----------------------------------------\n\nTITLE: Running Parameter Sweep with ParamResolver and Measurements (Python)\nDESCRIPTION: This snippet showcases the use of `cirq.ParamResolver` to define a sweep of parameter values for a quantum circuit and uses `simulator.run_sweep` to run the circuit for each set of parameter values. Measurements are added to the circuit, and the results of each trial in the sweep are printed, showing the effect of different parameter values on the measurement outcomes. The parameter 'x' is swept across values to demonstrate this functionality.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/simulation.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nresolvers = [cirq.ParamResolver({'x': y / 2.0}) for y in range(3)]\ncircuit = cirq.Circuit()\ncircuit.append([rot_w_gate(q0), rot_w_gate(q1)])\ncircuit.append([cirq.measure(q0, key='q0'), cirq.measure(q1, key='q1')])\nresults = simulator.run_sweep(program=circuit, params=resolvers, repetitions=2)\nfor result in results:\n    print(f\"params:{result.params}\")\n    print(f\"measurements:\")\n    print(result)\n```\n\n----------------------------------------\n\nTITLE: Creating custom channel with KrausChannel\nDESCRIPTION: This code creates a custom channel representing an X-basis measurement using `cirq.KrausChannel`.  It defines the Kraus operators for the measurement and associates them with a measurement key 'x'. This allows the result of the measurement (the index of the Kraus operator that was effectively applied) to be stored in the simulation results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# This is equivalent to an X-basis measurement.\nops = [np.array([[1, 1], [1, 1]]) * 0.5, np.array([[1, -1], [-1, 1]]) * 0.5]\nx_meas = cirq.KrausChannel(ops, key='x')\n```\n\n----------------------------------------\n\nTITLE: Parameter Resolution in Cirq\nDESCRIPTION: This code demonstrates how to resolve parameters in a Cirq circuit using a `cirq.ParamResolver`.  It creates a `ParamResolver` which maps the symbols 'alpha', 'beta', and 'gamma' to specific numerical values, and then calls `cirq.resolve_parameters` to apply this mapping to the circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/variational_algorithm.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nresolver = cirq.ParamResolver({'alpha': 0.1, 'beta': 0.3, 'gamma': 0.7})\nresolved_circuit = cirq.resolve_parameters(circuit, resolver)\n```\n\n----------------------------------------\n\nTITLE: Compiling Arbitrary Two-Qubit Unitary to SqrtIswap in Cirq\nDESCRIPTION: This snippet compiles an arbitrary two-qubit unitary, represented as a matrix, into a sequence of $\\sqrt{\\text{iSWAP}}$ operations using `cirq.two_qubit_matrix_to_sqrt_iswap_operations`. It creates a random unitary matrix and then converts it to sqrt_iswap operations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Compile an arbitrary two-qubit operation to the sqrt_iswap gateset.\"\"\"\nops = cirq.two_qubit_matrix_to_sqrt_iswap_operations(\n    q0=qubits[0], q1=qubits[1], mat=cirq.testing.random_unitary(dim=4, random_state=1)\n)\ncirq.Circuit(ops)\n```\n\n----------------------------------------\n\nTITLE: Nested CircuitOperations for QFT\nDESCRIPTION: This code shows how to nest `CircuitOperation` instances within each other to represent a Quantum Fourier Transform (QFT). The example defines `qft_1`, `qft_2`, and `qft_3`, where each higher-level QFT includes the previous one as a subcircuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nqft_1 = cirq.CircuitOperation(cirq.FrozenCircuit(cirq.H(q0)))\nqft_2 = cirq.CircuitOperation(cirq.FrozenCircuit(cirq.H(q1), cirq.CZ(q0, q1) ** 0.5, qft_1))\nqft_3 = cirq.CircuitOperation(\n    cirq.FrozenCircuit(cirq.H(q2), cirq.CZ(q1, q2) ** 0.5, cirq.CZ(q0, q2) ** 0.25, qft_2)\n)\n# etc.\n```\n\n----------------------------------------\n\nTITLE: Optimizing a Circuit for Pasqal Gateset\nDESCRIPTION: This code snippet demonstrates how to optimize a Cirq circuit for the `PasqalGateset`.  It uses `cirq.optimize_for_target_gateset` to convert logical gates into native hardware gates that are supported by the Pasqal device.  The resulting optimized circuit can then be validated successfully against the `PasqalVirtualDevice`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/pasqal/getting_started.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npasqal_gateset=cirq_pasqal.PasqalGateset(include_additional_controlled_ops=False)\npasqal_circuit = cirq.optimize_for_target_gateset(initial_circuit,\n                                                  gateset=pasqal_gateset)\n\n# TODO(https://github.com/quantumlib/Cirq/issues/6655) - remove after fixup\npasqal_circuit = cirq.Circuit(pasqal_circuit.all_operations(),\n                              strategy=cirq.InsertStrategy.NEW)\n\nprint(pasqal_circuit)\n\n# Now the circuit validates correctly!\np_device.validate_circuit(pasqal_circuit)\n```\n\n----------------------------------------\n\nTITLE: Creating TwoDQubit array in Cirq-Pasqal\nDESCRIPTION: This snippet demonstrates two ways to create an array of `TwoDQubit` objects in cirq-pasqal, representing qubits arranged on a square lattice in 2D. The first method uses a list comprehension, while the second uses the static method `TwoDQubit.square` for a more concise initialization.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/pasqal/devices.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq_pasqal import TwoDQubit\n\n# An array of 9 Pasqal qubits on a square lattice in 2D\np_qubits = [TwoDQubit(i, j) for i in range(3) for j in range(3)]\n\n# Equivalently, using one of Pasqal's qubit classes' static methods for qubit register creation\np_qubits = TwoDQubit.square(3)  # Initializes qubits in a square grid of side 3\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Quantum Circuit with Cirq\nDESCRIPTION: This code creates a quantum circuit using Cirq, applying Hadamard gates to all qubits, followed by entangling gates derived from the grid graph using `ccq.get_grid_moments`.  Finally, it applies single qubit Rx rotations and visualizes the circuit using `SVGCircuit`.  It depends on the 'graph' object created previously.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nqubits = [cirq.GridQubit(*n) for n in graph]\ncircuit = cirq.Circuit(\n    cirq.H.on_each(qubits),\n    ccq.get_grid_moments(graph),\n    cirq.Moment([cirq.rx(0.456).on_each(qubits)]),\n)\nSVGCircuit(circuit)\n```\n\n----------------------------------------\n\nTITLE: Simulating Randomized Algorithm and Creating Confusion Matrix in Python\nDESCRIPTION: This code simulates the randomized algorithm to determine whether a function is balanced or constant. It generates functions from either the balanced or constant distribution, runs the randomized algorithm on these functions, and then creates a confusion matrix to evaluate the performance of the algorithm. It uses pandas to store the results and create the pivot table for analysis.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nN = 128 # size of the problem, n=7, N=2^7=128\nsamples_size_per_function = 3\nnumber_of_functions_to_try = 1000\n\n\nres = pd.DataFrame()\nfor _ in range(number_of_functions_to_try):\n    dist, f = choose_random_function()\n    decision = randomized_alg(f, samples_size_per_function)\n    res=pd.concat([res, pd.DataFrame({\n        \"Distribution\": [dist],\n        \"Decision\":[decision],\n        \"Count\": [1]\n    })], ignore_index=True)\nconfusion = res.pivot_table(index=\"Distribution\",\n                            columns=\"Decision\",\n                            values=\"Count\",\n                            aggfunc=\"sum\")\n# Translate the counts into percentage\nconfusion.div(confusion.sum(axis=1), axis=0).apply(lambda x: round(x, 4) * 100)\n```\n\n----------------------------------------\n\nTITLE: Parameterizing Circuits for XEB Fitting in Python\nDESCRIPTION: This code snippet parameterizes the circuits in the circuit library using `cirq.experiments.xeb_fitting.parameterize_circuit`. It sets options to characterize all angles in the `PhasedFSimGate` and then applies the parameterization to each circuit in the library. The resulting parameterized circuits are stored in `pcircuits`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.experiments.xeb_fitting import (\n    parameterize_circuit, \n    characterize_phased_fsim_parameters_with_xeb_by_pair, \n    SqrtISwapXEBOptions,\n)\n\n# Set which angles we want to characterize (all)\noptions = SqrtISwapXEBOptions(\n    characterize_theta = True,\n    characterize_zeta = True,\n    characterize_chi = True,\n    characterize_gamma = True,\n    characterize_phi = True\n)\n# Parameterize the sqrt(iswap)s in our circuit library\npcircuits = [parameterize_circuit(circuit, options) for circuit in circuit_library]\n```\n\n----------------------------------------\n\nTITLE: Running Quantum Volume Algorithm\nDESCRIPTION: This code snippet contains the core logic for running the Quantum Volume algorithm. It iterates through different depths and repetitions, generating model circuits, computing their heavy sets, routing and compiling the circuits, and sampling them using the configured samplers. The results are stored and averaged to calculate the Heavy Output Generation (HOG) probability.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_volume.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# This cell contains the business logic that actually runs the quantum volume algorithm with\n# parameters specified in the previous cell.\nfrom cirq.contrib import quantum_volume\nfrom collections import defaultdict\nimport numpy as np\n\nfor sampler in samplers:\n    sampler['probabilities'] = defaultdict(int)\n    sampler['routed-probabilities'] = defaultdict(int)\n    sampler['compiled-probabilities'] = defaultdict(int)\n\nfor depth in depths:\n    num_qubits = depth  # Square matrix.\n    print(f\"Running simulation with {num_qubits} qubits and a depth of {depth}\")\n    for i in range(num_repetitions):\n        print(f\"    Repetition {i + 1} of {num_repetitions}\")\n        # Generate a model circuit and compute its heavy set.\n        model_circuit = quantum_volume.generate_model_circuit(\n            num_qubits, depth, random_state=np.random.RandomState())\n        heavy_set = quantum_volume.compute_heavy_set(model_circuit)\n        print(f\"        Heavy Set: {heavy_set}\")\n\n        # Route and compile the model circuit.\n        compilation_result = quantum_volume.compile_circuit(\n            model_circuit, \n            device_graph=device_graph, \n            routing_attempts=1)\n        compiled_circuit = optimize(compilation_result.circuit)\n\n        # Run the given samplers over the model, compiled, and optimized circuits.\n        for sampler in samplers:\n            probability = quantum_volume.sample_heavy_set(\n                compilation_result, heavy_set, sampler=sampler['sampler'])\n            sampler['probabilities'][depth] += probability\n            print(f\"        {sampler['label']} HOG probability: {probability}\")\n\n            routed_probability = quantum_volume.sample_heavy_set(\n                compilation_result,\n                heavy_set,\n                sampler=sampler['sampler'],\n                repetitions=repetitions)\n            sampler['routed-probabilities'][depth] += routed_probability\n            print(\n                f\"        {sampler['label']} HOG routed probability: {routed_probability}\"\n            )\n\n            compiled_probability = quantum_volume.sample_heavy_set(\n                compilation_result,\n                heavy_set,\n                sampler=sampler['sampler'])\n            sampler['compiled-probabilities'][depth] += compiled_probability\n            print(\n                f\"        {sampler['label']} HOG compiled probability: {compiled_probability}\"\n            )\n\n    # Compute the average performance over the total number of runs.\n    for sampler in samplers:\n        sampler['probabilities'][depth] /= num_repetitions\n        sampler['routed-probabilities'][depth] /= num_repetitions\n        sampler['compiled-probabilities'][depth] /= num_repetitions\n        print(f\"    Average {sampler['label']} HOG probability: \"\n              f\"{sampler['probabilities'][depth]}\")\n        print(f\"    Average {sampler['label']} optimized HOG probability: \"\n              f\"{sampler['routed-probabilities'][depth]}\")\n        print(f\"    Average {sampler['label']} compiled HOG probability: \"\n              f\"{sampler['compiled-probabilities'][depth]}\")\n```\n\n----------------------------------------\n\nTITLE: Initializing a Quantum Circuit with Specific Gates - Python\nDESCRIPTION: This snippet shows how to create a basic quantum circuit and add quantum gates to it. It initializes a circuit and applies single and two-qubit gates.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\nEctpu5zJ+6nDy1c0V+iZa7or6wsa5MoghuPEREceH+Bl+lRwIOhR4YAD6W5Ah7sB+AgRuTO8SAIw5clbuuhuzX4G/It0xfVicsduPAFeZlshgKfOX3AD4TOto8G4OaGsa78Cx32kZHcyYKOFg6XKm+yJ+wLwygBHoYnAB5GJ67RYYgOEviBOrauDeWJ8oS9yS8s5mVe7ypfTvLMTtkMBVrf/q18QUduf08Xe4LBIKucf+kp65FWoqNjKIofKBrFe2NJPuN5N/IMD8OT8bFR1YGL9IK6GMqSX5xWdJUpuCvyr2g8+DUmloqPHhfgYVix7t+/ATzYE3Suf//ab/gBbzSV9agXww/4kpCQJMBjnRvGCwCPx9X/j8O/CW383dhQF75z///Srfv/KwPlPIJvBB5oN87Pz9ECz97HZzo2lCXo98Lgr6zsXO73MmbdSLtxTe0unuGBB8ljdRMMlFvweLLIfV97ZcPyVcePH/eGEn4gO14XFha6/isK8HC9he75AgI83OOVVUwFeFgptD8+F+AR2Gc03gR4BNbIjk8FeNiheuB7CvAIrI9dnwrwsEv5re8rwGNrbez8RICHner7v7cAD/+62P2uAA+7Hdh8fwEemzWx4x0BHnaobn1PAR7WGjn5DAEeTnZnj8VNgMfeMVSAx97xciffRIBHYPUEeATWx65PBXjYpfzW9xXgsbU2dn4iwMNO9f3fW4CHf13sfleAh90ObL6/AI/NmjjhHQEeTnBhfRwEeKzXw65XAjzsUj7wfQV4BNbH6Z8K8HC6Q3sofgI89o6ZAjz2jpc7+SYCPAKrJ8AjsD52fSrAwy7lt76vAI+ttbHzEwEedqrv/94CPPzrYve7AjzsdmDz/QV4bNbECe8I8HCCC+vjIMBjvR52vRLgYZfyge8rwCOwPk7/VICH0x3aQ/ET4LF3zBTgsXe83Mk3EeARWD0BHoH1setTAR52Kb/1fQV4bK2NnZ8I8LBTff/3FuDhXxe73xXgYbcDm+8vwGOzJk54R4CHE1xYHwcBHuv1sOuVAA+7lA98XwEegfVx+qcCPJzu0B6KnwCPvWOmAI+94+VOvokAj8DqCfAIrI9dnwrwsEv5re8rwGNrbez8RICHner7v7cAD/+62P2uAA+7Hdh8fwEemzVxwjsCPJzgwvo4CPBYr4ddrwR42KV84PsK8Aisj9M/FeDhdIf2UPwAPNrb26mtrW1TmJ2ddcw35ecMe7eTZWfpVtW/6Mbdf1FBUbH3/f1+4As8xkZHaHl5iVY4oIPX34b3zbC6uqqOzX1oaCiFhISQucexGfxdS94LngKmJ7578+qmB9hjM1+bn5t78/3T5y7RTU4nN+78QTkH88yP9/UeutY/e0j1T2qo7mkNTU9N0urKMiEv5ESgSRtPWuJ0lZ6RxX7cp+u379PFiuua7ue+ywJ41D2upton1dT2sZXQwPjlyZd0fZvQsDACIAwNC6fzlyrZk3t09eY9ysjM0nVLV11XAY8nD6gOaYW9WViY9/qi64sg74If8OVA7iG6dquKw306c/6Srlu67roKeHA6qX30J3V1fFb5FvI1nVtYeASFh7MvvL9ceYOuwpebVZSUnKLztq65tgE8/qRnj/5Lzx7+uS7enuJ63XvBeIH6GfxAyCsoUn7Al5Ol5cG4/J64Ruu7v+kp+/Hs4X/pS1+P9zvp8oRrZRQRGUEREZEUzuHqjbtUefMOVV6/Q7Fx8d777+eD8bGf9KTmP8oT1MVUns+GmPVWHdqEcd4VGRnF3kTR4SPHqOLabaq4cYeOHDuh43auvCaAB9LJEw4D37+u80XHF4Lf8AO+IG1UXGdPOFSyL0g/shEZwOPfnF7+TWjjq/oq5/tm2zxYGqH9g/Y/AurCt+//H7p9739VHSxY93DzdTYCD7QblxcXaWlpccs+lp1+X98qXUZWNt26+z/c7/WHtBt9hO3uaKPGusfUUPuIOj5/pGX2A56sLC/7nOXuw7S0NDp27NimUFBQ4O4vxrEX4OF6C93zBVC49fT0UG9vr9r7Hs/PzzvmiwC+TE/PcJimYyfKuBP3D7rOnYb5hQI8TJNeNNZSAzceGp49ovm5GYqJjuYQpTopzHN89/AeHiMsLCysO47G38bEUGxsLEVFcSMhIoIrpZGqsuV7DTkOvgLLXFAvLS15g/kad4IHCPBDdT5xpyD2vtsMp5WZmRkVSsvPq451AA90HsqGvsFfKp3UP2Xo8axGwY5Y/q3j9x7OeurY4Cd8mZ2do7iERLp+657y5cKVazpu58prdne2M4SqVhCqmztxY2ON/Af5mI4Nv4O5uXmanZ9T+zMXrqgOQ3TipgvwUJIDeNQ9rSaklTr2BukjzuMLGt46tkVOK3NzczTL3qSmZTCAAvCoonKGt7IZCgAIwg+EL33d7EksxcXFEcptHZtKK1xPmJtboDneX2JQC1+u3rwrwMMjOIBH7eMHDKE48B5+xMfH8T6e602hOmyhxUVOK/BlfoGyDuQqP5B/nRDg4dX7/bvX9Mzjy9DAN68vutKKqlcvLBp1at6j87YS0IM7cgV4GLYAeDxjWAtgi86qhIQESoiP5/QSrzpyveYF8QDlysICBy7TDuUXCvDwo+3rV00q7wL0GPs5YnjC3kRzG1DHhrSygLTCnqz+ChHg4Ufk4aEBeloDiP4f+utFg0oriYmJag9gFKxtamqKJicnCfvy85d5UOn/cD/L/3C78WCwbuHq6+C32sid6g21j6mJw6/VZdU3grShr3xf9PZ7JSalKNiBgXLSblz7KZnAo5E96e1uV3lVdJTRT7J2lruPkpOTqbCwkAA4fPe5ubnu/mIcewEerrfQPV8Amfj3799V+Pbtm/cY76ET3CnbyMgIDQ4OcRikoiMlCnZc407D/MLDTomi7fF4qYDHI9WACPm1ShkZ6ZSRns4duf47QTCiAxUchImJCe8xXiclJVFKSgqlpqaqRgga74Af6GiXTa8CSHfo8AOIwt4MuCt8ML0AiDIBiG+MhoeHaXDISCslp8pVxzrSigAPQyV03qHiipGFDdyRGx0dSZkZGSpAUx0bgC08GRoaVqNxr7If8OTC5as6bufKa/Z0MfDgGTfoXP/S20WZmexJZialcj6kaxvitIIwPDxCp89e9HbiYhaObEQAHvAEIB2+JCUlKE+QXpD36NimGdYinSAfi4lPVCOk0blefu6ijtu58pptn95z3oUZatU0yCNxs7KyKIvTChpGOjbUE4e5DoZ0MsQBDW7ADoxelxkehuKz/Ls1IBTPiOLZUPAkO5t94f3GQQnB8gidU/BjeGSUklPTvZ4I8FhT+H3zGwOkMxwc505clVbYk6SkxLWTgni0zPXqEfYDAWlGwQ5ADwEeXpUnGHjUqpmD1WrUerZKK9mcXrK1AY/JySkaGWVfRn8qOCgzPLx2eA/e/PXcyMMYEM7NTCk/4AmAlI4NA4HgB3yZmpoR4OFH5JGhQQa2Bhx8y/7AjwMHDqjg5/RtvzUwMEAIP378oNIzF9SqABgol50jwAOimsADHeuNdU8oNiaKMnjkfXp6mr66MA/wNfu9IiKjvf1e56Xd6P2dY2WAxton7Mkj+t7fq/yAJ8nch7VXNuS/OTk5KgBymMdoH7t9E+DhdgddFH90/gEm+IZRVAr5vUXu7HDK9uXLF+rq6ubQRXmFR+jabYwurOJp/AI8TI8U8MDoAx4xhcK4iIlwYWEBJW5RWVWVTY/36FwyfwM4zuAOLWSqqFgBegCAoDNFVyeX+R1kTzwLYFaNskFnBgJmNWGPDR4gYIQPABTCxpGKvX191M3ppKu7m46WlBqduAAeUnFVGhrAA1NgH1Ijz4ZKTU1WaQXpBTBJxzbOQLGb/UBYXFo1OqZ41Pr5SwI8TL17ujo8M9Qe0sC3fioqKuRQRLmcD+naunl2I2Y1dnf30CmeDYUyBSNyBXgYigN4qFmDGNnG0COHy4PD7Am82ZjvBMujnz/HCL5093Tz0laRqsMQnesAUrIZCrQDeHD+BWA7Njrk8aRIdYbo0AiNfcMTngnMaeUcN7jVUj2cVgR4GIrPzs5QAy/9ZkDbGjp8uIjDYU4rh7nepGegCDrUe3p62ZteiolL8HoiwGMtFXxoeavgIHxBJ67pC+q4OjbUq+FJT28fh15VnmA5KyzVIzM8DMUnxscUhMIM21dNdSqdFHNaQXrRNXMQA056PZ6kpGXKDA8/P/53f79QA4Ew03Z1ZYlMT7Ckio5tngd39XrSyo+BQQEefkQeGR70AtuWN6+MtFJcTMUcgrmhbYL+lc7OTjIGyv1BV3mJ12yeOSjbeuDRVP+EYUcqFaoR9wVqdQAdGo2NjXn7vVZ4xVIMkkMb5RwvOSaboQCARxMDKIAozOAsKizgmRD5dIDB4F7Z0M+TzoOXEZAXm8cYlOz2LYQ7ZPQuxut2hST+QVMAPzV0ppoj/c1OVrxWa9oH7U47u9Dnz5+ppaWVQwsdOFigOgwxcuoQr1ssm6HAS244YOQ6Mv/01BQqKyul0tJTlL5FZRUzCTCTBzN7zGC+BkVGZyOmz2FEiZnBYtkf2fQqgErOkJoNMKRGOZvHuCt8OXjwoPLEhB+AUb7bhw8fqJnTCdIKZkNVqpG4VTJSxyMS8jxAQVSQsO7noYM5VFZayumlTNuoEHho5l8TPJLN8OSuVFx9fri93R0KQMGT0aEfKv8qKy2jI0eC27Azb4nfQUsrlykIXLbg2VAoU9AxJcDDUAlr4QIKYtkR7I8cOcxppUx5g+VHdGwYYQhPmtmTpeVV9gNLwtwR4OEjdsfnD6qsR3k/PTlGpznvQv6F8lrHhmUVVf6l0st7OnuxwtuRK8DDUBzAo9GzpCj2qH+VlZ2m06fLtMHBL1++evKw9xQaDjhoLJ904tRpHT8DV17zY+s7BWvhycryAqeV0yqt5OXpWeITM3NbWt9T63sOvDfyL342AT8zQoCH8RMC8ABAR/7194t65QnSCfIwXbPIATtQrsCTuMRkAR5+UnPz65eqToy0EhkeSmWnOf9iTzD4TceG2Zzwo5V96ejsFuDhR+TR4SFOKzzLlgc3fGh5rdLIafjCIZhLWqG9iNDc3GwMlOPOddSHsVSibCbwMAaUoo8ln8uPMu5fKeW2Y2KinhlQmHFjthunZ+e9A7JQ/5LNUMALPLiNMj46bHhy6pQa2LBXNMJAY3MZO9+9rgGau6mbAI/dVHuf3wudPuj49g3mMx0wqs8p29u3b+n58xfU1NREGdkH1cPm0JDAWqyyGQpgpBQ6plAYoxO38soVunLl8pajPuFzr8+zWzDCA6+xB+w4ceIElZSU0KFDh7xTaEGaZdOrAJZt6+/vpz6eqYG9eYy7Hj16VAX4g6UZMKURMMp3++uvv1Q6aXr+XM2GUp243BGSfUCmJkMnBTx4hA7WYUV6OcYd6hUVV6iC04uukWwAivCjqek5DfISJGrEJzcmzknF1fvTBfAwPZn8OcyeVChf0KDQtcEP5Qt7c/zkadVheOUaZni4f6pwMDRTwIPTyXMADw7l3MhGOkG5shG0BuN+uAbyPTOtTM7MqY4pdOSW8TILshkKdLR9YE8wqu0RLS3Mejy5osprHRph1HqTqn8Z6QXPu0EeVnnjNmFtadmI5gA8OK00sSdIK0gjKg/j9KKr3tTZ2eXNv5ZWyAAe7EuJAA/vT/LT+2aVTlC2hIf+8pYrwR4hbd4Qz+lC/vX8Bdorz5UnaKtUXLslwMMj0iQDD6Ot8pjevGr0pBOjvNcFPDBozszDIqJjBXiYP1ifPWYQoP2IciUxnjXievEVzr+wdryODQMrTU/eNbcI8PAj8ujIkFGmsCdtH5qVH0bdOLid3i9fvjTajdzHUnT0BOdbGPxzhzKz9cAuP1/V0W8ZS1p5gAe3H0+UHFf1LtSHU1L0LCWKlU2ee9qNo2Pj7IcxIAv1L9kMBUzggXxrZmrM2z45dfLknpEIS6JiuW0zYHa9uaS527+kAA+3O+iy+KMD0Dcg+njtpK2hoZEePnpEDx8+pJS0LLrCo3CvcAPiYJ4AD9OnV8/ruGLEHblcGKMT9969KrpXdZfy8vLMU9btsXRSW1ubCmgM+B4DdJw5c0YFTDMH9MB1dK3lui5i+/wFOvxML3z3kKW8vJzOnj1LJ7kwhycIGx9c9fTpU5VOajit5OYVcTrh0YVccZWROsYPC3nbcwAPriA11T+mM9yJa6QVngXDs5l0bFg2qabmIcGTvv4vnH8ZS1ycvRDcRouOuO/WNfu6O5Uf8GVuapyq7t1Tvly+pOdh1fgd1NTUsCePlC9HePk3ta43p5c0AR7KdgAP+IH0AuhRyRCqisuVqqoqSuOlDnVsbe3tnrRSw2vgj3nyr9sCPHzE7mz7SM8b4MkTotUlTif3qOruXVU2+JwWtEM8VFalFc7DqjngoaaYCQXokZikp7EftMjv0oUAPFD3gidIK3c5jdxD4PSiazYUZhGY5cr07IIB0tkXAR7/n70zga5qq+//j4wkDJlIICNhDIQxYQjTY57U1S7brrrs0mXr0mqtVqt16NNa+/yrfetVq9Vap74uu1xLO7jUqi2EeYbHe/B4TAmEDEwBQggBkhAywH9/982+CRDYGe6555x7v4e1Offe7HvO73x+9/zO3vu7h16nV6pGQhPDktV6XeZZP1v1AnViu3evRT1Pep4r6l7BfRIQPDDCw5kpM524DiePefdOs75HDu/fLW8dO6KfJ3imbFD1FafWUTt+/E0Vu7bp+KWGQ1Hw6MfBp958I/hcycxI0/fKevVcKSoq6if38D9qamrS/sCz5cDBwz33inquqA4O8fHOrBE2fKvDe4Smxpuq/KU6nahnS1XFqT73yoaQjvDYuXOn7OhpYymYPF2Xu5aosnDW+OzwXrBHzwbBQ88MoJ/vu2TRwgX6/tiknu9OTY+IDg07dgTqjVfrbwTavVas0eUvj2IKu1kQPPAcgYDeeb81+HxfvDiyOkhhNJdJgNz3ddihh/CEFDxCCJOHigwC+w8c0BXu8vJtkqrmX0UjLgWPx32rBQ/1MEblbkbRNNm8aZNKG58reEDoeDJVVFTo0R1oWEdCTziIHRQ8Huft1DsIHvAJ/NDXNzif8Ql6vRufPCl47Nq1K1CxKy+XnPxJupC0TPVap+AR8FhA8NgdbFwvLZkfvFecEjww/3351nLZqnxSd/GyrthB9ChlT53gbWQEDzQYtrXckc2bEb82yZIlS4J5QvkCvwP4QzeCKN8YwQPPFgoeAdJG8DjSIxCuWLFc+2Sjeq44JnicO6/9At80qIV/tWCr4tfckoWhdL+vjxUQPHbrRsOYR12ySd0nED0WLFjgyHVhPbet6h7ZonyCPQWPpzFD8DBCOvbwxyZ1nyCGOSZ4qKlgtih/QIRqwWioHiGdgkevf/oKHqOTE2XTxk36fsF0r05sWHMt4JNt+l6h4PE05YDgsUstWL5LsG4E4hfuFdwzTgkex44d188V+ObRiFgKHk+7RU6deEPwrEcZLCszI+gTJwUP81zZv1+N9NHiIAWPvq4JCB7qXoHgUXmq57kSeN6HckoriB2BTg3b9MwAEDsoePR64knBY/HihfrZ/jZVT3FO8LigOzSgLHzl6jUKHr3uCL4yggfEqI72NoE/NqnnSFkZ1/wLQvLwCwoeHnYOTXOHAAUPO3cKHnZGfshBwcNZL1HwcJbvUI9OwWOo5Jz7HgUP59gO58gUPIZDz5nvUvBwhutwj0rBY7gEQ/99Ch6hZxqKI1LwCAXF0B6DgkdoeQ71aBQ8hkrO2e9R8HCWr9NHp+DhNGEe33cEKHjYXUbBw87IDzkoeDjrJQoezvId6tEpeAyVnHPfo+DhHNvhHJmCx3DoOfNdCh7OcB3uUSl4DJdg6L9PwSP0TENxRAoeoaAY2mNQ8Agtz6EejYLHUMk5+z0KHs7ydfroFDycJszj+44ABQ+7yyh42Bn5IQcFD2e9RMHDWb5DPToFj6GSc+57FDycYzucI1PwGA49Z75LwcMZrsM9KgWP4RIM/fcpeISeaSiOSMEjFBRDewwKHqHlOdSjUfAYKjlnv0fBw1m+Th+dgofThHl83xGg4GF3GQUPOyM/5KDg4ayXKHg4y3eoR6fgMVRyzn2PgodzbIdzZAoew6HnzHcpeDjDdbhHpeAxXIKh/z4Fj9AzDcURKXiEgmJoj0HBI7Q8h3o0Ch5DJefs9yh4OMvX6aNT8HCaMI/vOwIUPOwuo+BhZ+SHHBQ8nPUSBQ9n+Q716BQ8hkrOue9R8HCO7XCOTMFjOPSc+S4FD2e4DveoFDyGSzD036fgEXqmoTgiBY9QUAztMSh4hJbnUI9GwWOo5Jz9HgUPZ/k6fXQKHk4T5vF9R4CCh91lFDzsjPyQg4KHs16i4OEs36EenYLHUMk59z0KHs6xHc6RKXgMh54z36Xg4QzX4R6VgsdwCYb++xQ8Qs80FEek4BEKiqE9BgWP0PIc6tEoeAyVnLPfo+DhLF+nj07Bw2nCPL7vCFDwsLuMgoedkR9yUPBw1ksUPJzlO9SjU/AYKjnnvkfBwzm2wzkyBY/h0HPmuxQ8nOE63KNS8BguwdB/n4JH6JmG4ogUPEJBMbTHoOARWp5DPRoFj6GSc/Z7FDyc5ev00Sl4OE2Yx/cdAQoedpdR8LAz8kMOCh7OeomCh7N8h3p0Ch5DJefc9yh4OMd2OEem4DEces58l4KHM1yHe1QKHsMlGPrvU/AIPdNQHJGCRygohvYYFDxCy3OoR6PgMVRyzn6PgoezfJ0+OgUPpwnz+L4jQMHD7rLBCh7379+X6upquXDhQjDhfVVVlUyfPl3mzJkjs2fPlsLCQsnNzZWcnBwZPXq03RDmGBYBCh7Dwmf9MgUPKyJXMlDwcAX7c09KweO5eFz7IwUP19A/88QUPJ6JxtU/UPBwFX+/J6fg0S8W1z+k4OG6C54ygILHU0hc+YCChyvYrSel4GFF5OkMFDw87R4a5wYBCh526oMVPDo6OqShoUGuX78uN27ceCxNmDBB8vPzdRo3bpykpaVJenq6JCYm2g1hjmERoOAxLHzWL1PwsCJyJQMFD1ewP/ekFDyei8e1P1LwcA39M09MweOZaFz9AwUPV/H3e3IKHv1icf1DCh6uu+ApAyh4PIXElQ8oeLiC3XpSCh5WRJ7OQMHD0+6hcW4QoOBhpz5YwaO7u1va2tp0am1tfez1qFGjZMyYMTolJSXJyJEjdYqNjbUbwhzDIkDBY1j4rF+m4GFF5EoGCh6uYH/uSSl4PBePa3+k4OEa+meemILHM9G4+gcKHq7i7/fkFDz6xeL6hxQ8XHfBUwZQ8HgKiSsfUPBwBbv1pBQ8rIg8nYGCh6fdQ+PcIEDBw059sIKH/YjM4QaBkAge5eVSrtL43ImyeNkqlVZK1oQcNy7He+d89EiOHt4vRw/tVft9UlpSIps3bZRNGzfJhAnjHbG3prZWyreWy1blk7qLl2XZyrWydOU6KV201JHz+fGgrgke5du0X6ZMnxm4V5aulPRxmX5EGHKbuzo71H2yT17X98s+WbFiuWzS98pGPeIv5CdUBzx37rz2B+6VhsZbsvSFtbLshXUyt2ShE6fz5TEpeHjPbRQ8vOcTWOSa4NHzXClTZa+y5aoMpp4rSaojETeRe3ea9TPlDfVcOf3WG7Jx48aetMGxUeTHjh3Xz5Utqhz2aESseqao58qqdTKtqJgu6SFAwcN7PwU3BI/cgsmySMWtRSpmjcua4D0oLlj0UHUQRVn4tZ7y8OLFC1W9cZOuO2ZmOlNfwHTj27Zt13HrytVrqs6o6o0r1sj8hUtcIODNU1Lw8KZfBmoVBY+BkmK+qCFAwcPuagoedkZ+yBEKwQONhWhgTx6TIlNVhW7q9GJJSU3zw+U7buMjdYbaC+d0QmFp4YJS2bBhvWxYv17Gj6fg4bgDnnECVwQPdY+Ub1NClNpnZE6QqTOKZZq6V0aPGfsMK6PrY4wC1PdK9TnBvbJi+XJ9r\n```\n\n----------------------------------------\n\nTITLE: Measuring in Z or X basis using Parameterized Circuit\nDESCRIPTION: This snippet shows how to combine measurements in different bases (Z or X) into a single circuit using a parameter sweep. A `sympy.Symbol` is used to parameterize the Hadamard gate, allowing for either a Z-basis measurement ('t': 0) or an X-basis measurement ('t': 1). The `cirq.Simulator` is used with `params` to run both variations in a single call.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/best_practices.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# STRATEGY #2: Have a parameterized circuit.\ncircuit_sweep = cirq.Circuit(\n    cirq.H(q)**sympy.Symbol('t'),\n    cirq.measure(q, key='out'))\n\nsamples_sweep = sampler.sample(circuit_sweep,\n                               repetitions=5,\n                               params=[{'t': 0}, {'t': 1}])\nprint(samples_sweep)\n```\n\n----------------------------------------\n\nTITLE: Defining a Circuit (Python)\nDESCRIPTION: This code defines a simple quantum circuit consisting of CNOT, X, and H gates operating on four qubits. It initializes the qubits as a linear array and then constructs the circuit with a series of moments.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/routing_transformer.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# The circuit to be routed\nq = cirq.LineQubit.range(4)\ncircuit = cirq.Circuit([\n    cirq.Moment(cirq.CNOT(q[2], q[0]), cirq.CNOT(q[1], q[3])),\n    cirq.Moment(cirq.X(q[0]), cirq.CNOT(q[1], q[2])),\n    cirq.Moment(cirq.CNOT(q[0], q[1])),\n    cirq.Moment(cirq.H.on_each(q[1], q[2])),\n    cirq.Moment(cirq.CNOT(q[1], q[0]), cirq.CNOT(q[3], q[2])),\n])\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Classical Control with SymPy Condition in Cirq\nDESCRIPTION: This snippet demonstrates classical control using a SymPy expression. The X gate on `q2` is applied only if the measurement results of `q0` (key 'a') and `q1` (key 'b') are equal. The circuit is then simulated, and the measurement results are printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/classical_control.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nq0, q1, q2 = cirq.LineQubit.range(3)\na, b = sympy.symbols('a b')\nsympy_cond = sympy.Eq(a, b)\ncircuit = cirq.Circuit(\n    cirq.H.on_each(q0, q1),\n    cirq.measure(q0, key='a'),\n    cirq.measure(q1, key='b'),\n    cirq.X(q2).with_classical_controls(sympy_cond),\n    cirq.measure(q2, key='c'),\n)\nprint(circuit)\nresults = cirq.Simulator(seed=2).run(circuit, repetitions=8)\nprint(results.data)\n```\n\n----------------------------------------\n\nTITLE: Simulating a Quantum Circuit with Specified Qubit Order in Cirq\nDESCRIPTION: This snippet simulates a quantum circuit using Cirq's `simulator.simulate` method. It includes specifying the `qubit_order` to define the order of the qubits in the final state vector. The `final_state_vector` and `dirac_notation` are then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nresult = simulator.simulate(circuit, qubit_order=[a, b])\n\n# Print the final state vector (wavefunction).\nprint(\"State vector:\")\nprint(np.around(result.final_state_vector, 3))\n\n# Print the state vector in Dirac notation.\nprint(\"\\nDirac notation:\")\nprint(result.dirac_notation())\n```\n\n----------------------------------------\n\nTITLE: Circuit Simulation in Python\nDESCRIPTION: This code simulates the created circuit using Cirq's `Simulator` for 1000 repetitions.  It then displays a histogram of the measurement results for the 'z' key, demonstrating the probability distribution of the output states.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Without noise, only the 1 state is measured.\"\"\"\nresult = cirq.Simulator().run(circuit, repetitions=1000)\nresult.histogram(key=\"z\")\n```\n\n----------------------------------------\n\nTITLE: Simulating and Verifying Forrelation in Cirq\nDESCRIPTION: This snippet shows how to simulate the Fourier Checking circuit using Cirq's simulator and verify the forrelation. It asserts that the final state vector's first element is close to the forrelation value. Additionally, it simulates the circuit step by step, printing the Dirac notation and the probability of observing the |0> state at each step. It requires `circuit` variable containing the prepared circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nassert np.isclose(circuit.final_state_vector(ignore_terminal_measurements=True, dtype=np.complex64)[0], forrelation)\n\ns = cirq.Simulator()\nfor step in s.simulate_moment_steps(circuit):\n    print(step.dirac_notation())\n    print(\"|0> state probability to observe: \",\n          np.abs(step.state_vector(copy=True)[0])**2)\n```\n\n----------------------------------------\n\nTITLE: Using channels in a Cirq circuit\nDESCRIPTION: This code demonstrates how to incorporate a bit-flip channel into a Cirq circuit. First, it determines the number of qubits the channel acts on. Then, it applies the channel to each qubit in a three-qubit register, creating a circuit that simulates bit-flip noise on multiple qubits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Example of using channels in a circuit.\"\"\"\n# See the number of qubits a channel acts on.\nnqubits = bit_flip.num_qubits()\nprint(f\"Bit flip channel acts on {nqubits} qubit(s).\\n\")\n\n# Apply the channel to each qubit in a circuit.\ncircuit = cirq.Circuit(bit_flip.on_each(cirq.LineQubit.range(3)))\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Using PhaseDampingChannel in Cirq (Python)\nDESCRIPTION: This code demonstrates the use of `cirq.PhaseDampingChannel`. It initializes a qubit in superposition using a Hadamard gate, applies the phase damping channel, applies another Hadamard gate, and measures the qubit.  The phase damping channel's `gamma` parameter is derived from a phase flip probability `p` to demonstrate the equivalence between `PhaseFlipChannel` and `PhaseDampingChannel`. The simulation runs 1000 times to print the resulting histogram and show the effects of the phase damping.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/representing_noise.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nq0 = cirq.LineQubit(0)\n# Convert p=0.2 to gamma\np = 0.2\ngamma = 1 - (2 * p - 1) ** 2\nprint(f\"{gamma=}\")\ncircuit = cirq.Circuit(\n    cirq.H(q0),\n    cirq.phase_damp(gamma=gamma).on(q0),\n    cirq.H(q0),\n    cirq.measure(q0, key='result')\n)\nresult = cirq.Simulator(seed=0).run(circuit, repetitions=1000)\nprint(\"Phase damp:\", result.histogram(key='result'))\n```\n\n----------------------------------------\n\nTITLE: Creating and Validating a Circuit with PasqalVirtualDevice\nDESCRIPTION: This code initializes a `PasqalVirtualDevice` with a control radius of 2.1 and a set of qubits.  It then constructs a sample quantum circuit and attempts to validate it against the device's constraints. A `ValueError` is expected if the circuit contains operations not supported by the device. Specifically, it shows that CX gates are not natively supported, and validation will fail unless the circuit is optimized for the Pasqal gateset.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/pasqal/getting_started.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Initialize and create a circuit\ninitial_circuit = cirq.Circuit()\ninitial_circuit.append(cirq.CZ(p_qubits[0], p_qubits[1]))\ninitial_circuit.append(cirq.Z(p_qubits[0]))\ninitial_circuit.append(cirq.CX(p_qubits[0], p_qubits[2]))\n\n# Create a Pasqal device with a control radius of 2.1 (in units of the lattice spacing)\np_device=PasqalVirtualDevice(control_radius=2.1, qubits=p_qubits)\n\n# Validate the circuit using the device\ntry:\n    p_device.validate_circuit(initial_circuit)\nexcept ValueError as e:\n    # Uh oh!  This circuit does not pass validation.\n    print(e)\n```\n\n----------------------------------------\n\nTITLE: Calculating Tensor Expectation Value (ccq)\nDESCRIPTION: This code calculates the expectation value of the ZZ observable for the circuit using `ccq.tensor_expectation_value`. This function simplifies the process of calculating expectation values directly using tensor network methods. This leverages the `circuit` and `ZZ` observable defined previously.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nccq.tensor_expectation_value(circuit, ZZ)\n```\n\n----------------------------------------\n\nTITLE: Defining circuit with multiple channels\nDESCRIPTION: Illustrates how to define a circuit with multiple noisy channels acting on different qubits and at different moments. The example combines various built-in and custom channels, like depolarizing, bit-phase flip, and bit-flip channels, with operations like QFT, reset, and measurement.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nqreg = cirq.LineQubit.range(4)\ncirc = cirq.Circuit(\n    cirq.H.on_each(qreg),\n    cirq.depolarize(p=0.01).on_each(qreg),\n    cirq.qft(*qreg),\n    bit_phase_flip.on_each(qreg[1::2]),\n    cirq.qft(*qreg, inverse=True),\n    cirq.reset(qreg[1]),\n    cirq.measure(*qreg),\n    cirq.bit_flip(p=0.07).controlled(1).on(*qreg[2:]),\n)\n\nprint(\"Circuit with multiple channels:\\n\")\nprint(circ)\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Parametrized Gate in Cirq\nDESCRIPTION: This code defines a custom gate with a parameter, theta. The `RotationGate` class inherits from `cirq.Gate` and initializes with a theta value.  The `_unitary_` method returns the unitary matrix based on this parameter, and the `_circuit_diagram_info_` method displays the gate with its parameter value in the circuit diagram.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/custom_gates.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass RotationGate(cirq.Gate):\n    def __init__(self, theta):\n        super(RotationGate, self)\n        self.theta = theta\n        \n    def _num_qubits_(self):\n        return 1\n    \n    def _unitary_(self):\n        return np.array([\n            [np.cos(self.theta), np.sin(self.theta)],\n            [np.sin(self.theta), -np.cos(self.theta)]\n        ]) / np.sqrt(2)\n    \n    def _circuit_diagram_info_(self, args):\n        return f\"R({self.theta})\"\n```\n\n----------------------------------------\n\nTITLE: Printing Unitary Matrix for Pauli-Y\nDESCRIPTION: This code prints the unitary matrix representation of the Pauli-Y gate using the `cirq.unitary` protocol. This demonstrates how to obtain the matrix form of a quantum gate in Cirq, which is crucial for many quantum algorithms and simulations. The code requires the `cirq` library.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/protocols.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nprint(cirq.unitary(cirq.Y))\n```\n\n----------------------------------------\n\nTITLE: Random Problem Instance Generation in Python\nDESCRIPTION: This code defines functions to generate random problem instances for a VQE simulation. The `rand2d` function creates a 2D array filled with randomly chosen +1 or -1 values. The `random_instance` function uses `rand2d` to generate random transverse field terms (h) and coupling field terms (jr and jc). It returns a tuple containing these three arrays, representing a random problem instance.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/variational_algorithm.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport random\ndef rand2d(rows, cols):\n    return [[random.choice([+1, -1]) for _ in range(cols)] for _ in range(rows)]\n\ndef random_instance(length):\n    # transverse field terms\n    h = rand2d(length, length)\n    # links within a row\n    jr = rand2d(length - 1, length)\n    # links within a column\n    jc = rand2d(length, length - 1)\n    return (h, jr, jc)\n\nh, jr, jc = random_instance(3)\nprint(f'transverse fields: {h}')\nprint(f'row j fields: {jr}')\nprint(f'column j fields: {jc}')\n```\n\n----------------------------------------\n\nTITLE: Classical Control with KeyCondition in Cirq\nDESCRIPTION: This snippet demonstrates the use of classical control in Cirq using `KeyCondition`. The Hadamard gate on `q1` is applied only if the measurement of `q0` with key 'a' returns 1. The circuit is then simulated, and the measurement results are printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/classical_control.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nq0, q1 = cirq.LineQubit.range(2)\ncircuit = cirq.Circuit(\n    cirq.H(q0),\n    cirq.measure(q0, key='a'),\n    cirq.H(q1).with_classical_controls('a'),\n    cirq.measure(q1, key='b'),\n)\nprint(circuit)\nprint(cirq.Simulator().run(circuit, repetitions=1000).histogram(key='b'))\n```\n\n----------------------------------------\n\nTITLE: Compile for Target Gateset - Python\nDESCRIPTION: This code demonstrates how to compile a Cirq circuit for specific target gatesets using `cirq.optimize_for_target_gateset`. It generates a random circuit and compiles it to both `cirq.CZTargetGateset` and `cirq.SqrtIswapTargetGateset`. The compiled circuits are then verified for equivalence using `cirq.testing.assert_circuits_with_terminal_measurements_are_equivalent`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_85\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.testing.random_circuit(qubits=4, n_moments=6, op_density=0.8, random_state=1234)\nprint(f\"Original Circuit (depth {len(circuit)}):\", circuit)\ncz_compiled_circuit = cirq.optimize_for_target_gateset(circuit, gateset=cirq.CZTargetGateset())\ncirq.testing.assert_circuits_with_terminal_measurements_are_equivalent(\n    circuit, cz_compiled_circuit, atol=1e-6\n)\nprint(f\"Compiled circuit for CZ Target (depth {len(cz_compiled_circuit)}):\", cz_compiled_circuit)\nsqrt_iswap_compiled_circuit = cirq.optimize_for_target_gateset(\n    circuit, gateset=cirq.SqrtIswapTargetGateset()\n)\ncirq.testing.assert_circuits_with_terminal_measurements_are_equivalent(\n    circuit, sqrt_iswap_compiled_circuit, atol=1e-6\n)\nprint(\n    f\"Compiled circuit for Sqrt-Iswap Target (depth {len(sqrt_iswap_compiled_circuit)}):\",\n    sqrt_iswap_compiled_circuit,\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Circuit Moment-by-Moment in Cirq with Python\nDESCRIPTION: This code snippet demonstrates how to construct a Cirq circuit by explicitly defining each moment. It creates a circuit where each Hadamard gate on a line qubit is placed in its own moment, preventing Cirq from automatically shifting the operations into the earliest possible moment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Creates each gate in a separate moment by passing an iterable of Moments instead of Operations.\nprint(cirq.Circuit(cirq.Moment([cirq.H(q)]) for q in cirq.LineQubit.range(3)))\n```\n\n----------------------------------------\n\nTITLE: Running a parameter sweep simulation with Cirq\nDESCRIPTION: This snippet demonstrates how to perform a parameter sweep simulation using Cirq. It defines a sweep of parameter values for 'theta', then runs the simulation of the circuit for each value of 'theta' in the sweep. The results of each simulation run are then printed to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nsim = cirq.Simulator()\nresults = sim.run_sweep(circuit, repetitions=25, params=[{\"theta\": 0.5}, {\"theta\": 0.25}])\nfor result in results:\n    print(f\"param: {result.params}, result: {result}\")\n```\n\n----------------------------------------\n\nTITLE: Export Cirq Circuit to OpenQASM 3.0 in Python\nDESCRIPTION: This example demonstrates exporting a simple Cirq circuit to OpenQASM 3.0 format using `cirq.qasm`. The circuit consists of an X gate and a measurement operation.  It shows how to specify the OpenQASM version when exporting the circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/interop.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nq0 = cirq.NamedQubit('q0')\ncircuit = cirq.Circuit(cirq.X(q0), cirq.measure(q0, key='mmm'))\nqasm_str = cirq.qasm(circuit, args=cirq.QasmArgs(version=\"3.0\"))\nprint(qasm_str)\n```\n\n----------------------------------------\n\nTITLE: Accessing Final Density Matrix from Simulation (Python)\nDESCRIPTION: This snippet demonstrates how to access the final density matrix of a quantum circuit simulation using `cirq.DensityMatrixSimulator`. It creates a circuit with a Hadamard gate and an amplitude damping channel, simulates the circuit, and then prints the final density matrix, rounded to three decimal places, to show the state of the system after the operations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/simulation.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nq = cirq.NamedQubit('a')\ncircuit = cirq.Circuit(cirq.H(q), cirq.amplitude_damp(0.2)(q))\nsimulator = cirq.DensityMatrixSimulator()\nresult = simulator.simulate(circuit)\nprint(np.around(result.final_density_matrix, 3))\n```\n\n----------------------------------------\n\nTITLE: PauliString Sum Simplification with Cirq\nDESCRIPTION: Demonstrates the simplification of sums of PauliStrings in Cirq, including combining terms and distributing operations. It shows how terms are simplified and combined when adding or multiplying Pauli operators.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ntyprint(-2 * Xa + 3 * Za)\ntyprint(-2 * Xa * Xa + 3 * Za * Zb)\n```\n\n----------------------------------------\n\nTITLE: Create Registers and Display Qubit Count for Shor's Algorithm\nDESCRIPTION: This snippet creates the target and exponent qubit registers required for implementing Shor's algorithm using the defined `ModularExp` gate. It also calculates and prints the total number of qubits needed based on the integer to be factored.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# The target register has L qubits.\ntarget = cirq.LineQubit.range(L)\n\n# The exponent register has 2L + 3 qubits.\nexponent = cirq.LineQubit.range(L, 3 * L + 3)\n\n# Display the total number of qubits to factor this n.\nprint(f\"To factor n = {n} which has L = {L} bits, we need 3L + 3 = {3 * L + 3} qubits.\")\n```\n\n----------------------------------------\n\nTITLE: Energy Function Definition for VQE in Cirq\nDESCRIPTION: This code defines a function `energy_func` that calculates the energy of a given measurement outcome for the VQE problem. It takes the problem size (`length`), transverse fields (`h`), and coupling fields (`jr` and `jc`) as input. The function reshapes the measurement data, converts it to +1/-1 values, and calculates the total energy based on the Hamiltonian defined by `h`, `jr`, and `jc`. It returns a function, closures over the problem instance, that takes measurements as input and returns the energy as output.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/variational_algorithm.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\ndef energy_func(length, h, jr, jc):\n    def energy(measurements):\n        # Reshape measurement into array that matches grid shape.\n        meas_list_of_lists = [measurements[i * length:(i + 1) * length]\n                              for i in range(length)]\n        # Convert true/false to +1/-1.\n        pm_meas = 1 - 2 * np.array(meas_list_of_lists).astype(np.int32)\n\n        tot_energy = np.sum(pm_meas * h)\n        for i, jr_row in enumerate(jr):\n            for j, jr_ij in enumerate(jr_row):\n                tot_energy += jr_ij * pm_meas[i, j] * pm_meas[i + 1, j]\n        for i, jc_row in enumerate(jc):\n            for j, jc_ij in enumerate(jc_row):\n                tot_energy += jc_ij * pm_meas[i, j] * pm_meas[i, j + 1]\n        return tot_energy\n    return energy\nprint(results.histogram(key='x', fold_func=energy_func(3, h, jr, jc)))\n```\n\n----------------------------------------\n\nTITLE: Simulating Quantum Circuits with Cirq\nDESCRIPTION: This snippet demonstrates how to simulate a quantum circuit using the Cirq simulator. The simulator allows you to observe the behavior of the circuit and obtain measurement results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\nimport cirq\n\n# Create a circuit\ncircuit = cirq.Circuit()\ncircuit.append(cirq.H(cirq.GridQubit(0, 0)))\ncircuit.append(cirq.CNOT(cirq.GridQubit(0, 0), cirq.GridQubit(0, 1)))\n\n# Simulate the circuit\nsimulator = cirq.Simulator()\nresult = simulator.run(circuit, repetitions=1000)\n\n# Print the results\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Running Sweep with Simulator - Python\nDESCRIPTION: This snippet demonstrates running a circuit using `cirq.Simulator` with a parameter sweep. The code simulates the circuit for multiple values of the parameter 'a' (0 and 1) and prints the simulation results for each parameter value. The circuit is repeated 25 times for each parameter value.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nsim = cirq.Simulator()\nresults = sim.run_sweep(circuit, repetitions=25, params=cirq.Points('a', [0, 1]))\nfor result in results:\n    print(f\"param: {result.params}, result: {result}\")\n```\n\n----------------------------------------\n\nTITLE: Optimizing PhasedFSimGate Parameters using Cirq\nDESCRIPTION: This code snippet utilizes `cirq.experiments.xeb_fitting` to characterize the `PhasedFSimGate` parameters. It parameterizes the circuits, performs the characterization with the provided data and options, and stores the results in `characterization_result`.  Multiprocessing is used to speed up the computation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/isolated_xeb.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport multiprocessing\npool = multiprocessing.get_context('spawn').Pool()\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.experiments.xeb_fitting import (\n    parameterize_circuit,\n    characterize_phased_fsim_parameters_with_xeb,\n    SqrtISwapXEBOptions,\n)\n\n# Set which angles we want to characterize (all)\noptions = SqrtISwapXEBOptions(\n    characterize_theta = True,\n    characterize_zeta = True,\n    characterize_chi = True,\n    characterize_gamma = True,\n    characterize_phi = True\n)\n# Parameterize the sqrt(iswap)s in our circuit library\npcircuits = [parameterize_circuit(circuit, options) for circuit in circuits]\n\n# Run the characterization loop\ncharacterization_result = characterize_phased_fsim_parameters_with_xeb(\n    sampled_df,\n    pcircuits,\n    cycle_depths,\n    options,\n    pool=pool,\n    # ease tolerance so it converges faster:\n    fatol=5e-3,\n    xatol=5e-3\n)\n```\n\n----------------------------------------\n\nTITLE: Running Loschmidt Echo Experiment on QCS\nDESCRIPTION: This snippet runs the Loschmidt echo experiment on the Quantum Computing Service (QCS). It retrieves the Engine sampler, creates a batch of Loschmidt echo circuits for each qubit set and cycle value, runs the batch on the QCS, and then calculates the ground state probability for each result using the `to_ground_state_prob` function.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/echoes.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Run the Loschmidt echo experiment.\"\"\"\nsampler = cg.get_engine_sampler(processor_id=processor_id, gate_set_name=\"sqrt_iswap\")\n\nprobs = []\nfor trial in range(trials):\n    print(\"\\r\", f\"Status: On trial {trial + 1} / {trials}\", end=\"\")\n\n    # Create the batch of circuits.\n    batch = [\n        create_loschmidt_echo_circuit(qubits, cycles=c, pause=pause, seed=trial)\n        for qubits in qubit_sets for c in cycle_values\n    ]\n\n    # Run the batch.\n    results = sampler.run_batch(programs=batch, repetitions=nreps)\n\n    # Determine the ground state probability for each result.\n    probs.append([to_ground_state_prob(*res) for res in results])\n```\n\n----------------------------------------\n\nTITLE: Using No-Compile Tags with Circuit Optimization Python\nDESCRIPTION: This snippet illustrates how to use \"no-compile\" tags to prevent specific operations from being transformed during circuit optimization. It creates a circuit with echo pulses tagged as \"spin_echoes\", then optimizes the circuit twice, first without ignoring any tags and then ignoring the \"spin_echoes\" tag using `cirq.TransformerContext`.  The `k` parameter specifies the maximum qubit count to be merged during the k-qubit unitary merging.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/transformers.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Echo pulses inserted in the circuit to prevent dephasing during idling should be ignored.\ncircuit = cirq.Circuit(\n    cirq.H(q[0]),\n    cirq.CNOT(*q[:2]),\n    [\n        op.with_tags(\"spin_echoes\") for op in [cirq.X(q[0]) ** 0.5, cirq.X(q[0]) ** -0.5]\n    ],  # the echo pulses\n    [cirq.CNOT(*q[1:]), cirq.CNOT(*q[1:])],\n    [cirq.CNOT(*q[:2]), cirq.H(q[0])],\n    cirq.measure_each(*q),\n)\n# Original Circuit\nprint(\"Original Circuit:\", circuit, \"\\n\", sep=\"\\n\")\n\n# Optimized Circuit without tags_to_ignore\nprint(\"Optimized Circuit without specifying tags_to_ignore:\")\nprint(optimize_circuit(circuit, k=1), \"\\n\")\n\n# Optimized Circuit ignoring operations marked with tags_to_ignore.\nprint(\"Optimized Circuit while ignoring operations marked with tags_to_ignore:\")\ncontext = cirq.TransformerContext(tags_to_ignore=[\"spin_echoes\"])\nprint(optimize_circuit(circuit, k=1, context=context), \"\\n\")\n```\n\n----------------------------------------\n\nTITLE: Appending Operations using Generators in Cirq\nDESCRIPTION: This code defines a generator function `my_layer` that yields a series of Cirq operations, including single qubit Hadamard gates and two-qubit CZ gates. The circuit appends the operations generated by `my_layer` and then iterates through the generator to print each yielded operation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef my_layer():\n    yield cirq.CZ(q0, q1)\n    yield [cirq.H(q) for q in (q0, q1, q2)]\n    yield [cirq.CZ(q1, q2)]\n    yield [cirq.H(q0), [cirq.CZ(q1, q2)]]\n\n\ncircuit = cirq.Circuit()\ncircuit.append(my_layer())\n\nfor x in my_layer():\n    print(x)\n```\n\n----------------------------------------\n\nTITLE: Installing stable version of cirq-google using pip\nDESCRIPTION: This command installs the stable release version of the cirq-google Python package using pip. It ensures that the necessary dependencies, including cirq-core, are installed along with cirq-google. This is the recommended way to install the package for most users.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-google/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install cirq-google\n```\n\n----------------------------------------\n\nTITLE: Adding Noise to a Circuit\nDESCRIPTION: This snippet demonstrates how to add noise to a circuit using a `NoiseModel`. It defines a `ConstantQubitNoiseModel` that adds a depolarizing channel to every qubit in each moment and then applies it to the circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_77\n\nLANGUAGE: python\nCODE:\n```\n# Get a noiseless circuit.\nnoise = cirq.ConstantQubitNoiseModel(cirq.depolarize(0.2))\ncircuit = cirq.Circuit(cirq.H(a), cirq.CNOT(a, b), cirq.measure(a, b))\nprint(f'Circuit with no noise:\\n{circuit}\\n')\n\n# Add noise to the circuit.\nsystem_qubits = sorted(circuit.all_qubits())\nnoisy_circuit = cirq.Circuit()\nfor moment in circuit:\n    noisy_circuit.append(noise.noisy_moment(moment, system_qubits))\nprint(f'Circuit with noise:\\n{noisy_circuit}')\n```\n\n----------------------------------------\n\nTITLE: Check if a circuit is parameterized\nDESCRIPTION: This snippet demonstrates how to check if a Cirq circuit is parameterized using the `cirq.is_parameterized` function. It takes a circuit as input and returns a boolean indicating whether the circuit contains any symbolic parameters.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncirq.is_parameterized(circuit)\n```\n\n----------------------------------------\n\nTITLE: Printing Connectivity Graph from Device Metadata in Cirq\nDESCRIPTION: This code snippet retrieves and prints the connectivity graph of the Sycamore device from its metadata using the `nx_graph` attribute. The connectivity graph represents the allowed two-qubit gate connections on the device.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/devices.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nprint(metadata.nx_graph)\n```\n\n----------------------------------------\n\nTITLE: Grid Search Optimization with Cirq\nDESCRIPTION: This code snippet performs a grid search over a defined parameter space to find the minimum value of an objective function using Cirq. It defines a parameter sweep using `cirq.Linspace`, simulates the circuit for each parameter combination, and tracks the minimum objective value and corresponding parameters. Dependencies: cirq, simulator, objective function (obj_func), and a quantum circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/variational_algorithm.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nsweep_size = 10\nsweep = (cirq.Linspace(key='alpha', start=0.0, stop=1.0, length=sweep_size)\n         * cirq.Linspace(key='beta', start=0.0, stop=1.0, length=sweep_size)\n         * cirq.Linspace(key='gamma', start=0.0, stop=1.0, length=sweep_size))\nresults = simulator.run_sweep(circuit, params=sweep, repetitions=100)\n\nmin = None\nmin_params = None\nfor result in results:\n    value = obj_func(result)\n    if min is None or value < min:\n        min = value\n        min_params = result.params\nprint(f'Minimum objective value is {min}.')\n```\n\n----------------------------------------\n\nTITLE: Creating a Points parameter sweep in Cirq\nDESCRIPTION: This snippet demonstrates how to create a parameter sweep using `cirq.Points`. It defines a sweep of specific values for the parameter 'theta'. The snippet iterates through the sweep and prints each parameter value.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nparams = cirq.Points(key=\"theta\", points=[0, 1, 3])\nfor param in params:\n    print(param)\n```\n\n----------------------------------------\n\nTITLE: Flattening Circuit Expressions - Python\nDESCRIPTION: This snippet demonstrates how to flatten a Cirq circuit that contains expressions using `cirq.flatten`. The flattening process replaces expressions with new symbols and provides a mapping between the original expressions and the new symbols.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# Flatten returns two objects, the circuit with new symbols, and the mapping from old to new values.\nc_flat, expr_map = cirq.flatten(circuit)\nprint(c_flat)\nprint(expr_map)\n```\n\n----------------------------------------\n\nTITLE: Import Cirq Circuit from OpenQASM 3.0 in Python\nDESCRIPTION: This snippet imports a quantum circuit from an OpenQASM 3.0 string using `circuit_from_qasm`. It demonstrates how to define qubits and measurements in OpenQASM 3.0 and then load them into Cirq.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/interop.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.contrib.qasm_import import circuit_from_qasm\ncircuit = circuit_from_qasm(\"\"\"\nOPENQASM 3.0;\ninclude \\\"stdgates.inc\\\";\n\n// Qubits: [q0]\nqubit[2] q;\nbit[2] m_mmm;\n\nx q;\nm_mmm = measure q;\n\"\"\")\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: PauliString Properties and Methods\nDESCRIPTION: This snippet demonstrates how to access the qubits in a `PauliString`, remap the `PauliString` to new qubits using `with_qubits`, and access the `cirq.Gate` object representing the operation using `gate`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\npauli_string = -1 * cirq.X(a) * cirq.Y(b) * cirq.Z(c)\ntyprint(pauli_string)\n# The PauliString's qubits.\nprint(pauli_string.qubits)\n# Remap the PauliString to new qubits.\nnew_qubits = cirq.LineQubit.range(3, 6)\nnew_pauli_string = pauli_string.with_qubits(*new_qubits)\ntyprint(new_pauli_string)\nprint(new_pauli_string.qubits)\n# The PauliString's gate.\ntyprint(pauli_string.gate)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Controlled Rx Gate (CRx)\nDESCRIPTION: This code defines a custom controlled-Rx gate (CRx) in Cirq. It inherits from `cirq.Gate` and implements the `_num_qubits_` and `_unitary_` methods to specify the number of qubits (2) and the unitary matrix for the CRx gate, respectively.  The `theta` parameter determines the rotation angle.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_53\n\nLANGUAGE: python\nCODE:\n```\nclass CRx(cirq.Gate):\n    def __init__(self, theta):\n        self.theta = theta\n\n    def _num_qubits_(self):\n        return 2\n\n    def _unitary_(self):\n        return np.array(\n            [\n                [1, 0, 0, 0],\n                [0, 1, 0, 0],\n                [0, 0, np.cos(self.theta / 2), -1j * np.sin(self.theta / 2)],\n                [0, 0, -1j * np.sin(self.theta / 2), np.cos(self.theta / 2)],\n            ]\n        )\n\n    def _circuit_diagram_info_(self, args):\n        return '@', f'Rx({self.theta / np.pi}π)'\n```\n\n----------------------------------------\n\nTITLE: Displaying Algorithm Based Gates in Cirq\nDESCRIPTION: This snippet uses the display_gates function to display documentation for the algorithm based gates BooleanHamiltonianGate, QuantumFourierTransformGate, and PhaseGradientGate. The display_gates function retrieves each gate from the cirq module and displays its docstring using IPython.display.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndisplay_gates(\"BooleanHamiltonianGate\", \"QuantumFourierTransformGate\", \"PhaseGradientGate\")\n```\n\n----------------------------------------\n\nTITLE: Ejecting Z Gates in Cirq\nDESCRIPTION: This snippet uses the `cirq.eject_z` optimizer to push `cirq.Z` gates towards the end of the circuit.  This aims to simplify the circuit structure by consolidating Z gates.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.eject_z(circuit)\ncircuit\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Cirq Circuit\nDESCRIPTION: This snippet demonstrates creating a simple quantum circuit using Cirq.  It initializes two qubits, applies a Hadamard gate to the first qubit, a CNOT gate between the two qubits, and then measures both qubits into a classical register named 'b'.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_honeywell.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\n\nq0, q1 = cirq.LineQubit.range(2)\ncircuit = cirq.Circuit(\n    cirq.H(q0), # Hadamard\n    cirq.CNOT(q0, q1), # CNOT\n    cirq.measure(q0, q1, key='b') # Measure both qubits into classical register \"b\"\n)\ncircuit\n```\n\n----------------------------------------\n\nTITLE: Simulating Expectation Values with Cirq\nDESCRIPTION: This code demonstrates how to simulate expectation values for given observables in a quantum circuit using Cirq. It defines observables, simulates the circuit, and prints the expectation values.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/simulation.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nXX_obs = cirq.X(q0) * cirq.X(q1)\nZZ_obs = cirq.Z(q0) * cirq.Z(q1)\nev_list = simulator.simulate_expectation_values(\n    cirq.Circuit(basic_circuit(False)), observables=[XX_obs, ZZ_obs]\n)\nprint(ev_list)\n```\n\n----------------------------------------\n\nTITLE: Simulating Rx Rotations and Plotting Probabilities\nDESCRIPTION: This code simulates a quantum circuit consisting of a series of small Rx rotations applied to a qubit. It calculates and plots the probability of measuring the qubit in the ground state at each simulation step.  It uses `cirq.simulate_moment_steps` to step through the circuit and `step.state_vector` to extract the quantum state. Requires `numpy` and `matplotlib` for plotting.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_47\n\nLANGUAGE: python\nCODE:\n```\n# Get a qubit.\na = cirq.NamedQubit('a')\n\n# Get a circuit of a bunch of X rotations.\nnum_angles = 200\ncircuit = cirq.Circuit([cirq.Rx(rads=np.pi / 50.0)(a) for theta in range(num_angles)])\n\n# List to store probabilities of the ground state.\nprobs = []\n\n# Step through the simulation results.\nfor step in simulator.simulate_moment_steps(circuit):\n    prob = np.abs(step.state_vector(copy=True)) ** 2\n    probs.append(prob[0])\n\n# Plot the probability of the ground state at each simulation step.\nplt.style.use('seaborn-v0_8-whitegrid')\nplt.plot(probs, 'o')\nplt.xlabel(\"Step\")\nplt.ylabel(\"Probability of ground state\");\n```\n\n----------------------------------------\n\nTITLE: Installing the stable version of cirq-pasqal with pip\nDESCRIPTION: This command installs the stable version of the cirq-pasqal package using pip.  It ensures that the core cirq dependencies are installed automatically.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-pasqal/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install cirq-pasqal\n```\n\n----------------------------------------\n\nTITLE: Initializing AQT Local Simulator (Noisy) in Python\nDESCRIPTION: This code initializes the AQT local simulator in noisy mode (with a noise model) using `AQTSamplerLocalSimulator`.  This will return results that are representative of the real device (with noise).\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/aqt/getting_started.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.aqt.aqt_sampler import AQTSamplerLocalSimulator\n\naqt_sampler = AQTSamplerLocalSimulator(simulate_ideal=False)\n```\n\n----------------------------------------\n\nTITLE: Creating a Circuit with a Depolarizing Channel in Cirq\nDESCRIPTION: This code creates a Cirq circuit with a depolarizing channel applied to a qubit, followed by a measurement. The `cirq.depolarize` function is used to introduce noise into the circuit, which is useful for simulating realistic quantum hardware.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_68\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit(cirq.depolarize(0.2)(a), cirq.measure(a))\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Creating a Random Cirq Circuit\nDESCRIPTION: This snippet demonstrates how to create a random quantum circuit using Cirq. It initializes a square grid of qubits, then generates a circuit with a specified number of moments and operation density.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-web/circuit_example.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nqubits = [cirq.GridQubit(x, y) for x in range(10) for y in range(10)]\n\nimport cirq.testing\nfrom cirq.protocols import circuit_diagram_info\ncircuit = cirq.testing.random_circuit(cirq.GridQubit.square(10), n_moments=5, op_density=.7)\n```\n\n----------------------------------------\n\nTITLE: Exploring the mixture of a bit-flip channel\nDESCRIPTION: This code creates a bit-flip channel and then iterates through the probabilistic mixture of unitaries that represent the channel, printing the probability and the corresponding unitary for each element of the mixture.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/operators.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nbit_flip = cirq.bit_flip(p=0.05)\nprobs, unitaries = cirq.mixture(bit_flip)\n\nfor prob, unitary in cirq.mixture(bit_flip):\n    print(f\"With probability {prob}, apply \\n{unitary}\\n\")\n```\n\n----------------------------------------\n\nTITLE: Defining Quantum Walk Step with Cirq\nDESCRIPTION: This snippet defines the `walk_step()` function, which represents a single step in the quantum walk. It flips the coin qubit using a Hadamard gate, then implements the addition and subtraction operators to move the walker's position forward or backward based on the coin's state. It uses controlled-X gates to implement the addition and subtraction.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/quantum_walks.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef walk_step():\n\n    # \"Flip\" the coin vector\n\n    yield cirq.H.on(cirq.GridQubit(0, number_qubits))\n\n    # Implement the Addition Operator\n\n    yield cirq.X.on(cirq.GridQubit(0, number_qubits))\n\n    for i in range(number_qubits, 0, -1):\n        \n        controls = [cirq.GridQubit(0, v) for v in range(number_qubits, i-1, -1)]\n        yield cirq.X.on(cirq.GridQubit(0, i-1)).controlled_by(*controls)\n        if (i > 1):\n            yield cirq.X.on(cirq.GridQubit(0, i-1))\n\n    yield cirq.X.on(cirq.GridQubit(0, number_qubits))\n\n    # Implement the Subtraction Operator\n\n    for i in range(1, number_qubits+1):\n\n        controls = [cirq.GridQubit(0, v) for v in range(number_qubits, i-1, -1)]\n        yield cirq.X.on(cirq.GridQubit(0, i-1)).controlled_by(*controls)\n        if (i < number_qubits):\n            yield cirq.X.on(cirq.GridQubit(0, i))\n```\n\n----------------------------------------\n\nTITLE: Rabi-Flop Experiment Solution in Cirq\nDESCRIPTION: This is the solution code snippet for the Rabi-flop experiment in Cirq. It defines a parameterized circuit with a rotation about the X axis, followed by a measurement. It uses `cirq.Linspace` to generate a set of `ParamResolver`s and then plots the sampled fraction.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_67\n\nLANGUAGE: python\nCODE:\n```\nimport pandas\n\nq = cirq.NamedQubit(\"q\")\nparameterized_circuit = cirq.Circuit([cirq.Rx(rads=sp.Symbol(\"theta\"))(q), cirq.measure(q)])\nparam_resolvers = cirq.Linspace(start=0, stop=np.pi, length=100, key='theta')\nresults = cirq.Simulator().sample(\n    program=parameterized_circuit, params=param_resolvers, repetitions=repetitions\n)\npandas.crosstab(results.theta, results.q).plot()\n```\n\n----------------------------------------\n\nTITLE: Visualizing Quantum Teleportation Circuit\nDESCRIPTION: This snippet defines a gate (X^0.25) to prepare the message qubit, then creates and prints the teleportation circuit using the `make_quantum_teleportation_circuit` function. This allows for visual inspection of the teleportation protocol's operations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Visualize the teleportation circuit.\"\"\"\n# Gate to put the message qubit in some state to send.\ngate = cirq.X ** 0.25\n\n# Create the teleportation circuit.\ncircuit = make_quantum_teleportation_circuit(gate)\nprint(\"Teleportation circuit:\\n\")\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Converting Kraus operators to Choi representation\nDESCRIPTION: This code demonstrates how to convert a set of Kraus operators representing a depolarizing channel into its Choi representation using `cirq.kraus_to_choi`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/operators.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndepo_channel = cirq.DepolarizingChannel(p=0.01, n_qubits=1)\nkraus_rep = cirq.kraus(depo_channel)\nprint(kraus_rep)\n```\n\nLANGUAGE: python\nCODE:\n```\nchoi_rep = cirq.kraus_to_choi(kraus_rep)\nprint(choi_rep)\n```\n\n----------------------------------------\n\nTITLE: Run a Circuit with Quantum Engine API\nDESCRIPTION: This code demonstrates how to create and run a quantum circuit using Cirq and the Quantum Engine API. It initializes the engine, creates a simple circuit with a measurement, and then runs the circuit using the engine's sampler, printing the histogram and data of the results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/engine.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport cirq_google as cg\n\n# A simple sample circuit\nqubit = cirq.GridQubit(5, 2)\ncircuit = cirq.Circuit(\n    cirq.X(qubit)**0.5,                 # Square root of NOT.\n    cirq.measure(qubit, key='result')   # Measurement.\n)\n\n# Create an Engine object.\n# Replace YOUR_PROJECT_ID with the id from your cloud project.\nengine = cg.Engine(project_id=YOUR_PROJECT_ID)\n\n# Create a sampler from the engine\nsampler = engine.get_sampler(processor_id='PROCESSOR_ID')\n\n# This will run the circuit and return the results in a 'Result'\nresults = sampler.run(circuit, repetitions=1000)\n\n# Sampler results can be accessed several ways\n\n# For instance, to see the histogram of results\nprint(results.histogram(key='result'))\n\n# Or the data itself\nprint(results.data)\n```\n\n----------------------------------------\n\nTITLE: Running a Circuit on the Quantum Virtual Machine\nDESCRIPTION: This snippet defines a simple quantum circuit using `cirq` and runs it on the configured quantum virtual machine.  The circuit consists of an X gate, a SQRT_ISWAP gate, and a measurement. The results are then printed as a histogram.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/quantum_virtual_machine.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nq0 = cirq.GridQubit(4, 4)\nq1 = cirq.GridQubit(4, 5)\ncircuit = cirq.Circuit(cirq.X(q0), cirq.SQRT_ISWAP(q0, q1), cirq.measure([q0, q1], key=\"measure\"))\n\nresults = sim_engine.get_sampler(processor_id).run(circuit, repetitions=3000)\n\nprint(results.histogram(key=\"measure\"))\n```\n\n----------------------------------------\n\nTITLE: Using Top-Level Constructs in Cirq (Python)\nDESCRIPTION: Demonstrates the preferred way to access Cirq classes and objects at the package level. Instead of referencing module names within Cirq, use the top-level constructs to avoid code breakage if modules are renamed or classes are moved between versions. For example, using `cirq.X` instead of `cirq.ops.X`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/best_practices.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# Good practice:\ncirq.X\n\n# Avoid:\ncirq.ops.X\n```\n\n----------------------------------------\n\nTITLE: Monte Carlo simulation with `run` method\nDESCRIPTION: Demonstrates Monte Carlo wavefunction simulation using the `run` method of `cirq.Simulator` to simulate a noisy circuit multiple times.  It runs a circuit with a bit-flip channel and a measurement 100 times, displaying the resulting histogram of measurement outcomes.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit(cirq.bit_flip(p=0.5).on(qbit), cirq.measure(qbit))\nres = sim.run(circuit, repetitions=100)\nprint(res.histogram(key=qbit))\n```\n\n----------------------------------------\n\nTITLE: Creating and Printing a Probabilistic Gate\nDESCRIPTION: This code creates a probabilistic X gate using the `with_probability` method and then iterates through the mixture representation of the gate using `cirq.mixture`. It prints the probability and the corresponding operator for each element in the mixture.  This exemplifies how to create and inspect probabilistic quantum gates in Cirq.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/protocols.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprobabilistic_x = cirq.X.with_probability(.3)\n\nfor p, op in cirq.mixture(probabilistic_x):\n    print(f\"probability: {p}\")\n    print(\"operator:\")\n    print(op)\n```\n\n----------------------------------------\n\nTITLE: Connecting to Azure Quantum Service with Cirq\nDESCRIPTION: Connects to the Azure Quantum service using the `AzureQuantumService` class from `azure.quantum.cirq`.  It requires a resource ID and location from the Azure Quantum portal, and allows for setting a default target (e.g., an IonQ simulator).\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_ionq.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom azure.quantum.cirq import AzureQuantumService\nservice = AzureQuantumService(\n    resource_id=\"\",\n    location=\"\",\n    default_target=\"ionq.simulator\"\n)\n```\n\n----------------------------------------\n\nTITLE: Combining sweeps with cartesian product in Cirq\nDESCRIPTION: This snippet demonstrates how to combine two parameter sweeps using the cartesian product operation (`*`). It creates two sweeps, `sweep1` using `cirq.Linspace` and `sweep2` using `cirq.Points`, and then combines them using the `*` operator. The resulting sweep includes all possible combinations of parameter values from the two sweeps. Each combination is printed to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nsweep1 = cirq.Linspace(\"theta\", 0, 1, 5)\nsweep2 = cirq.Points(\"gamma\", [0, 3])\n# By taking the product of these two sweeps, you can sweep over all possible\n# combinations of the parameters.\nfor param in sweep1 * sweep2:\n    print(param)\n```\n\n----------------------------------------\n\nTITLE: Use Built-in QFT Operation in Cirq with Python\nDESCRIPTION: This code snippet demonstrates how to use the built-in `cirq.qft` function to create a QFT operation and construct a `cirq.Circuit` from it.  The `without_reverse=True` argument specifies that the output qubit order should not be reversed. The resulting circuit is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Use the built-in QFT in Cirq.\"\"\"\nqft_operation = cirq.qft(*qubits, without_reverse=True)\nqft_cirq = cirq.Circuit(qft_operation)\nprint(qft_cirq)\n```\n\n----------------------------------------\n\nTITLE: Example: Classically compute order of an element in Python\nDESCRIPTION: This code snippet demonstrates the use of the `classical_order_finder` function. It sets n to 15 and x to 8, then calls the function to find the order of x modulo n. Finally, it prints the value of x^r mod n to verify that the computed order is correct, confirming that x raised to the power of r modulo n equals 1.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nn = 15  # The multiplicative group is [1, 2, 4, 7, 8, 11, 13, 14].\nx = 8\nr = classical_order_finder(x, n)\n\n# Check that the order is indeed correct.\nprint(f\"x^r mod n = {x}^{r} mod {n} = {x**r % n}\")\n```\n\n----------------------------------------\n\nTITLE: Displaying Pauli String Gates in Cirq\nDESCRIPTION: This snippet uses the display_gates function to display documentation for the Pauli string gates DensePauliString, MutableDensePauliString, and PauliStringPhasorGate. The display_gates function retrieves each gate from the cirq module and displays its docstring using IPython.display.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndisplay_gates(\"DensePauliString\", \"MutableDensePauliString\", \"PauliStringPhasorGate\")\n```\n\n----------------------------------------\n\nTITLE: Running a Quantum Circuit with IonQ API and Cirq\nDESCRIPTION: This code snippet demonstrates the basic steps of running a quantum circuit on the IonQ platform using Cirq. It includes creating a quantum circuit, initializing the IonQ service with an API key, submitting the circuit for execution, and processing the results. The code assumes you have a valid IonQ API key and cirq and cirq_ionq packages installed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/service.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport cirq_ionq as ionq\n\n# A circuit that applies a square root of NOT and then a measurement.\nqubit = cirq.LineQubit(0)\ncircuit = cirq.Circuit(\n  cirq.X(qubit)**0.5,      # Square root of NOT.\n  cirq.measure(qubit, key='x')  # Measurement store in key 'x'\n)\n\n# Create a ionq.Service object.\n# Replace API_KEY with your API key.\n# Alternatively, if you have the IONQ_API_KEY environment\n# variable set, you can omit specifying this api_key parameters.\nservice = ionq.Service(api_key=API_KEY)\n\n# Run a program against the service. This method will block execution until\n# the result is returned (determined by periodically polling the IonQ API).\nresult = service.run(circuit=circuit, repetitions=100, target='qpu')\n\n# The return object of run is a cirq.Result object.\n# From this object, you can get a histogram of results.\nhistogram = result.histogram(key='x')\nprint(f'Histogram: {histogram}')\n\n# You can also get the data as a pandas frame.\nprint(f'Data:\\n{result.data}')\n```\n\n----------------------------------------\n\nTITLE: Getting Unitary of a CNOT Gate in Cirq\nDESCRIPTION: This code snippet shows how to retrieve the unitary matrix representation of a CNOT gate in Cirq. It uses the `cirq.unitary` function to obtain the unitary matrix and then prints it to the console. The `cirq.CNOT` object represents the controlled-NOT gate.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nprint(cirq.unitary(cirq.CNOT))\n```\n\n----------------------------------------\n\nTITLE: Validating Circuits on a Custom Cirq Device\nDESCRIPTION: This code demonstrates how to use the custom `MyDevice` class to validate Cirq circuits. It creates a circuit `my_circuit` that is valid for the device and another circuit `too_many_czs` which contains too many CZ gates and therefore, would be invalid on the device, as per the device implementation. It then validates each operation of the invalid circuit to show that the individual operations are valid, but that the circuit as a whole is invalid.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/devices.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nmy_custom_device = MyDevice()\n\nmy_circuit = cirq.Circuit(\n    cirq.X(cirq.LineQubit(0)),\n    cirq.X(cirq.LineQubit(2)),\n    cirq.X(cirq.LineQubit(4)),\n    cirq.CZ(*cirq.LineQubit.range(2)),\n)\ntoo_many_czs = cirq.Circuit(cirq.CZ(*cirq.LineQubit.range(2)) for _ in range(11))\n\n# my_circuit is valid for my_custom_device.\nmy_custom_device.validate_circuit(my_circuit)\n\n# each operation of too_many_czs is valid individually...\nfor moment in too_many_czs:\n    for op in moment:\n        my_custom_device.validate_operation(op)\n```\n\n----------------------------------------\n\nTITLE: Getting Number of Qubits from Calibration\nDESCRIPTION: This snippet retrieves the current calibration data from the IonQ service and extracts the number of qubits available on the device. It assumes that a `cirq_ionq.Service` object named `service` has already been instantiated. The output is the number of qubits, which can be used to define valid `cirq.LineQubit`s for the circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/circuits.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncalibration = service.get_current_calibration()\nnum_qubits = calibration.num_qubits()\nprint(num_qubits)\n```\n\n----------------------------------------\n\nTITLE: Simplifying the Circuit\nDESCRIPTION: This code demonstrates the process of simplifying a quantum circuit by merging k-qubit unitaries and dropping negligible operations. It aims to reduce the gate count and qubit count, making the circuit more efficient for simulation or execution. The number of operations and qubits is printed before and after simplification.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ncompressed_c = tot_c.copy()\nprint(len(list(compressed_c.all_operations())), len(compressed_c.all_qubits()))\n```\n\n----------------------------------------\n\nTITLE: Retrieving Job by ID\nDESCRIPTION: This snippet shows how to retrieve a job using its ID and check its status.  It creates a new `cirq_ionq.Job` object.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/getting_started.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nsame_job = service.get_job(job_id=job_id)\nprint(f'Status: {same_job.status()}')\n```\n\n----------------------------------------\n\nTITLE: Encoding with Five-Qubit Code\nDESCRIPTION: This snippet creates a StabilizerCode instance for a five-qubit code, defines qubits, encodes them into a circuit, simulates the circuit for initial states 0 and 1, and prints the encoded states. This uses different stabilizer generators and can correct both X and Z errors.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/stabilizer_code.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ncode = sc.StabilizerCode(group_generators=['XZZXI', 'IXZZX', 'XIXZZ', 'ZXIXZ'], correctable_errors=['X', 'Z'])\n\nadditional_qubits = [cirq.NamedQubit(str(i)) for i in range(code.n - code.k)]\nunencoded_qubits = [cirq.NamedQubit('c')]\nqubits = additional_qubits + unencoded_qubits\n\ncircuit = code.encode(additional_qubits, unencoded_qubits)\n\nfor initial_state in [0, 1]:\n    results = cirq.Simulator().simulate(circuit, qubit_order=qubits, initial_state=initial_state)\n    print('%d becomes:\\n %s\\n' % (initial_state, cirq.dirac_notation(4.0 * results.state_vector())))\n```\n\n----------------------------------------\n\nTITLE: Create GHZ State Builder Circuit in Python\nDESCRIPTION: This code snippet defines a GHZ state builder circuit using Cirq. It creates a line of 17 qubits, applies a Hadamard gate to the first qubit, and then applies a series of CNOT gates to the remaining qubits. Finally, it measures all the qubits and prints the circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_basic_example.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Define an abstract line of 17 qubits\nnumber_of_qubits = 17\nqubits = cirq.LineQubit.range(number_of_qubits)\n\n# Create a GHZ circuit on this qubit line\nghz_circuit = cirq.Circuit(\n    cirq.H(qubits[0]),\n    *[cirq.CNOT(qubits[i - 1], qubits[i]) for i in range(1, number_of_qubits)],\n    cirq.measure(*qubits, key='out'),\n)\nprint(ghz_circuit)\n```\n\n----------------------------------------\n\nTITLE: KrausChannel Example in Cirq\nDESCRIPTION: This code snippet showcases the usage of `KrausChannel` to represent noise in a Cirq circuit, modeling amplitude damping. It defines Kraus operators and creates a channel. This example requires the `cirq` and `numpy` libraries.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/representing_noise.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nq0 = cirq.LineQubit(0)\n# equivalent to cirq.amplitude_damp(gamma=0.2)\ngamma = 0.2\nmy_channel = cirq.KrausChannel(\n    [\n        np.array([[0, np.sqrt(gamma)], [0, 0]]),    # decay |1) -> |0)\n        np.array([[1, 0], [0, np.sqrt(1-gamma)]]),  # stay in |1)\n    ],\n    key='op_num',\n)\ncircuit = cirq.Circuit(\n    cirq.X(q0),\n    my_channel.on(q0),\n    cirq.measure(q0, key='result')\n)\nresult = cirq.Simulator(seed=0).run(circuit, repetitions=20)\n# `op_num` and `result` are always equal.\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Creating a Grid of Qubits in Cirq with Python\nDESCRIPTION: This snippet creates a 3x3 grid of qubits using `cirq.GridQubit.square(3)` and then prints the first qubit and the entire list of qubits. This demonstrates how to define and access qubits arranged in a grid structure, which is common in many quantum devices.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nqubits = cirq.GridQubit.square(3)\n\nprint(qubits[0])\nprint(qubits)\n```\n\n----------------------------------------\n\nTITLE: Benchmarking 2Q XEB Fidelities using Cirq\nDESCRIPTION: This code snippet benchmarks the fidelities of the sampled circuits using `cirq.experiments.xeb_fitting.benchmark_2q_xeb_fidelities`. It takes the sampled data, the circuits, and the cycle depths as input and returns a pandas DataFrame `fids` containing the fidelity measurements.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/isolated_xeb.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.experiments.xeb_fitting import benchmark_2q_xeb_fidelities\nfids = benchmark_2q_xeb_fidelities(\n    sampled_df=sampled_df,\n    circuits=circuits,\n    cycle_depths=cycle_depths,\n)\nfids\n```\n\n----------------------------------------\n\nTITLE: Common Quantum Gates in Cirq\nDESCRIPTION: This code snippet demonstrates the use of various common quantum gates available in the Cirq library. It initializes three qubits and applies a range of single-qubit, two-qubit, and three-qubit gates, including Pauli gates, controlled gates, Hadamard gate, rotation gates, and swap gates.  It requires the Cirq and NumPy libraries.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_44\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Examples of common gates defined in Cirq.\"\"\"\n# Get some qubits.\nq0, q1, q2 = cirq.LineQubit.range(3)\n\n# Get a bunch of common gates defined in Cirq.\nops = [\n    cirq.X(q0),  # Pauli-X.\n    cirq.Y(q1),  # Pauli-Y.\n    cirq.Z(q2),  # Pauli-Z.\n    cirq.CZ(q0, q1),  # Controlled-Z gate.\n    cirq.CNOT(q1, q2),  # Controlled-X gate.\n    cirq.H(q0),  # Hadamard gate.\n    cirq.T(q1),  # T gate.\n    cirq.S(q2),  # S gate.\n    cirq.CCZ(q0, q1, q2),  # Controlled CZ gate.\n    cirq.SWAP(q0, q1),  # Swap gate.\n    cirq.CSWAP(q0, q1, q2),  # Controlled swap gate.\n    cirq.CCX(q0, q1, q2),  # Toffoli (CCNOT) gate.\n    cirq.ISWAP(q0, q1),  # ISWAP gate.\n    cirq.Rx(rads=0.5 * np.pi)(q0),  # Rotation about X.\n    cirq.Ry(rads=0.5 * np.pi)(q1),  # Rotation about Y.\n    cirq.Rz(rads=0.5 * np.pi)(q2),  # Rotation about Z.\n    cirq.X(q0) ** 0.5,  # Sqrt of NOT gate.\n]\n```\n\n----------------------------------------\n\nTITLE: Contracting the Tensor Network\nDESCRIPTION: This code contracts the tensor network to compute the expectation value of the observable. The `inplace=True` argument modifies the tensor network directly during the contraction.  The result is then converted to a real number if it is close to real using `np.real_if_close` and then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nzz = tn.contract(inplace=True)\nzz = np.real_if_close(zz)\nprint(zz)\n```\n\n----------------------------------------\n\nTITLE: Overriding Cost Function in Cirq's RouteCQC (Python)\nDESCRIPTION: This code snippet demonstrates how to override the default cost function used in Cirq's `RouteCQC` class by creating a subclass. The overridden `_cost` method computes the number of executable two-qubit gates after applying a series of SWAP gates, allowing for custom routing strategies.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/routing_transformer.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Tuple, Sequence, Any\n\nQidIntPair = Tuple[int, int]\n\nclass RouteCQCSimpleCostFunction(cirq.RouteCQC):\n  @classmethod\n  def _cost(\n        cls,\n        mm: cirq.MappingManager,\n        swaps: Tuple[QidIntPair, ...],\n        two_qubit_ops: Sequence[QidIntPair],\n    ) -> Any:\n        \"\"\"Computes the # of 2-qubit gates executable after applying SWAPs.\"\"\"\n        for swap in swaps:\n            mm.apply_swap(*swap)\n        ret = sum(1 for op_ints in two_qubit_ops if mm.is_adjacent(*op_ints))\n        for swap in swaps:\n            mm.apply_swap(*swap)\n        return ret\n```\n\n----------------------------------------\n\nTITLE: Creating a Moment with CZ and X Gates in Cirq with Python\nDESCRIPTION: This snippet creates a `Moment` object containing a `CZ` gate acting on the first two qubits and an `X` gate acting on the third qubit.  It then prints the moment, demonstrating how to group operations that occur at the same abstract time slice.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncz = cirq.CZ(qubits[0], qubits[1])\nx = cirq.X(qubits[2])\nmoment = cirq.Moment(x, cz)\n\nprint(moment)\n```\n\n----------------------------------------\n\nTITLE: Import Cirq Circuit from OpenQASM 2.0 in Python\nDESCRIPTION: This example demonstrates importing a quantum circuit from an OpenQASM 2.0 string using `circuit_from_qasm`. It defines a simple circuit with Hadamard gates and measurements, and then prints the resulting Cirq circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/interop.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.contrib.qasm_import import circuit_from_qasm\ncircuit = circuit_from_qasm(\"\"\"\n    OPENQASM 2.0;\n    include \\\"qelib1.inc\\\";\n    qreg q[3];\n    creg meas[3];\n    h q;\n    measure q -> meas;\n    \"\"\")\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Convert Quirk URL to Cirq Circuit (Python)\nDESCRIPTION: This snippet demonstrates how to convert a quantum circuit created in Quirk to a Cirq circuit using the `cirq.quirk_url_to_circuit` function. It takes a Quirk URL as input, parses it, and returns the corresponding Cirq circuit. The resulting circuit is then printed to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/interop.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nquirk_url = \"https://algassert.com/quirk#circuit=%7B%22cols%22:[[%22H%22,%22H%22],[%22%E2%80%A2%22,%22X%22],[%22H%22,%22H%22]]}\"\nc= cirq.quirk_url_to_circuit(quirk_url)\n\nprint(c)\n```\n\n----------------------------------------\n\nTITLE: Printing Valid Gate Sets on Device in Cirq\nDESCRIPTION: This snippet iterates through each gate set that is valid on the device specification and prints the name of each gate set. Then, it iterates through each gate in the gate set and prints the gate ID and gate duration in picoseconds.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfor gateset in spec.valid_gate_sets:\n    print(gateset.name)\n    print('-------')\n    # Prints each gate valid in the set with its duration\n    for gate in gateset.valid_gates:\n        print('%s %d' % (gate.id, gate.gate_duration_picos))\n    print()\n```\n\n----------------------------------------\n\nTITLE: Optimizing Circuit for Target Gateset in Cirq\nDESCRIPTION: This code snippet optimizes a given quantum circuit (`stabilizer_circuit_for_hardware`) for a specific target gate set (`cirq.SqrtIswapTargetGateset`). It uses `cirq.optimize_for_target_gateset` to decompose the circuit into gates compatible with the specified hardware architecture, improving its suitability for execution on real quantum hardware. It maps the qubits to physical qubits and then prints the resulting circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ntest_stabilizer_circuit = cirq.optimize_for_target_gateset(\n    stabilizer_circuit_for_hardware,\n    context=cirq.TransformerContext(deep=True),\n    gateset=cirq.SqrtIswapTargetGateset(),\n)\n# Map circuit qubits to hardware ones.\nqubit_map = dict(zip([measure_qubit] + data_qubits, device_stabilizer_plaquette))\n# Re-map the circuit to the hardware qubits.\ntest_stabilizer_circuit = test_stabilizer_circuit.transform_qubits(lambda q: qubit_map[q])\nprint(f'Z-stabilizer circuit optimized for {processor_id}:')\nprint('========================')\nprint(test_stabilizer_circuit)\n```\n\n----------------------------------------\n\nTITLE: Alternate Stepping Behavior for Cirq Simulation\nDESCRIPTION: This code demonstrates an alternative approach to stepping through a circuit simulation when `simulate_moment_steps` is not supported. It splits the circuit into chunks and passes the results of each chunk as the initial state for the next chunk.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/simulation.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nchunks = [cirq.Circuit(moment) for moment in basic_circuit()]\nnext_state = 0  # represents the all-zero state\nfor i, chunk in enumerate(chunks):\n    result = simulator.simulate(chunk, initial_state=next_state)\n    next_state = result.final_state_vector\n    print(f'state at step {i}: {np.around(next_state, 3))}')\n```\n\n----------------------------------------\n\nTITLE: Creating an IonQ Job Directly in Python\nDESCRIPTION: This code snippet demonstrates how to create a quantum job on the IonQ API using the `service.create_job` method. This method is non-blocking, meaning it immediately returns a `cirq_ionq.Job` object with the job ID without waiting for the job to complete. This allows users to submit jobs and retrieve the results later, which can be beneficial when dealing with long queueing times.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/jobs.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nqubit = cirq.LineQubit(0)\ncircuit = cirq.Circuit(\n    cirq.X(qubit)**0.5,            # Square root of NOT.\n    cirq.measure(qubit, key='x')   # Measurement store in key 'x'\n)\njob = service.create_job(circuit=circuit, target='qpu', repetitions=100)\nprint(job)\n```\n\n----------------------------------------\n\nTITLE: Virtual Gate Elimination in Cirq\nDESCRIPTION: This example demonstrates the elimination of virtual Z gates in Cirq. Since Z gates have zero duration on the device, a moment containing only a Z gate will disappear, resulting in only the X gate being executed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/devices.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncirq.Circuit(\n  cirq.Moment(cirq.Z(cirq.GridQubit(4,4))),\n  cirq.Moment(cirq.X(cirq.GridQubit(4,5)))\n)\n```\n\n----------------------------------------\n\nTITLE: Build Phase Estimation Circuit (First Part) in Python\nDESCRIPTION: This code builds the initial part of the phase estimation circuit. It creates `n_bits` qubits and one ancilla qubit (`u_bit`). Hadamard gates are applied to all `n_bits` qubits to create an equal superposition.  Then, controlled-U gates are applied where the control qubits are the `n_bits` qubits, and the target is the `u_bit`. The control exponent of each controlled-U gate depends on the index of the control qubit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Build the first part of the circuit for phase estimation.\"\"\"\n# Get qubits for the phase estimation circuit.\nqubits = cirq.LineQubit.range(n_bits)\nu_bit = cirq.NamedQubit('u')\n\n# Build the first part of the phase estimation circuit.\nphase_estimator = cirq.Circuit(cirq.H.on_each(*qubits))\n\nfor i, bit in enumerate(qubits):\n    phase_estimator.append(cirq.ControlledGate(U).on(bit, u_bit) ** (2 ** (n_bits - i - 1)))\n```\n\n----------------------------------------\n\nTITLE: Sampling Two-Qubit XEB Circuits in Python\nDESCRIPTION: This code snippet samples from the generated two-qubit XEB circuits using `cirq.experiments.xeb_sampling.sample_2q_xeb_circuits`. It takes the sampler, circuit library, cycle depths, combinations by layer, and other parameters to execute the circuits and collect bitstring samples. The `repetitions` parameter specifies the number of times each circuit is executed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.experiments.xeb_sampling import sample_2q_xeb_circuits\nsampled_df = sample_2q_xeb_circuits(\n    sampler=sampler,\n    circuits=circuit_library,\n    cycle_depths=cycle_depths,\n    combinations_by_layer=combs_by_layer,\n    shuffle=np.random.RandomState(52),\n    repetitions=10_000,\n)\nsampled_df\n```\n\n----------------------------------------\n\nTITLE: Decomposing a Cirq Gate\nDESCRIPTION: This snippet showcases how to use the `cirq.decompose` function to decompose a gate (in this case, a circuit containing the custom `HXGate`) into its constituent gates. It decomposes the HX gate into H and X, and further decomposes H into Y**0.5 and X.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_58\n\nLANGUAGE: python\nCODE:\n```\nprint(cirq.Circuit(cirq.decompose(circuit)))\n```\n\n----------------------------------------\n\nTITLE: Writing a Custom Cirq Transformer\nDESCRIPTION: This snippet shows how to create a custom Cirq transformer using the `@cirq.transformer` decorator. The example provided replaces an X gate followed by a Z gate with a Y gate by composing together the `map_operations` and `merge_operations` primitives.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_81\n\nLANGUAGE: python\nCODE:\n```\n@cirq.transformer\ndef xz_optimizer(circuit, *, context=None):\n    \"\"\"Replaces an X followed by a Z with a Y.\"\"\"\n\n    def merge_func(op1, op2):\n        return cirq.Y(*op1.qubits) if op1.gate == cirq.X and op2.gate == cirq.Z else None\n\n    return cirq.merge_operations(circuit, merge_func)\n\n\ncircuit = cirq.Circuit(cirq.X(a), cirq.Z(a), cirq.CZ(a, b), cirq.X(a))\nprint(f\"Before optimizing:\\n{circuit}\\n\")\ncircuit = xz_optimizer(circuit)\nprint(f\"After optimizing:\\n{circuit}\")\n```\n\n----------------------------------------\n\nTITLE: Substituting Gates using cirq.map_operations Primitive\nDESCRIPTION: This code uses the `cirq.map_operations` primitive to substitute gates within a circuit. It defines `substitute_gate_using_primitives`, which replaces occurrences of a `source` gate with a `target` gate. The example demonstrates how the primitive integrates with `TransformerContext`'s `deep` and `tags_to_ignore` parameters to control recursive behavior and ignore tagged operations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/custom_transformers.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@cirq.transformer\ndef substitute_gate_using_primitives(circuit, *, context=None, source=cirq.X, target=cirq.S):\n    \"\"\"Transformer to substitute `source` gates with `target` in the input circuit.\n\n    The transformer is implemented using `cirq.map_operations` primitive and hence\n    has built-in support for\n      1. Recursively running the transformer on sub-circuits if `context.deep is True`.\n      2. Ignoring operations tagged with any of `context.tags_to_ignore`.\n    \"\"\"\n    return cirq.map_operations(\n        circuit,\n        map_func=lambda op, _: target.on(*op.qubits) if op.gate == source else op,\n        deep=context.deep if context else False,\n        tags_to_ignore=context.tags_to_ignore if context else (),\n    )\n\n\n# Build your circuit from x_y_x components.\nx_y_x = [cirq.X(q), cirq.Y(q), cirq.X(q).with_tags(\"ignore\")]\ncircuit = cirq.Circuit(x_y_x, cirq.CircuitOperation(cirq.FrozenCircuit(x_y_x)), x_y_x)\n# Note that you want to transform the CircuitOperations and ignore tagged operations.\ncontext = cirq.TransformerContext(deep=True, tags_to_ignore=(\"ignore\",))\n```\n\n----------------------------------------\n\nTITLE: Installing the Latest Pre-Release Version of Cirq-AQT using pip\nDESCRIPTION: This snippet shows how to install the latest pre-release version of the Cirq-AQT module using pip.  It uses the ~= operator to select the latest version compatible with the 1.* and dev naming convention.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-aqt/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install --upgrade cirq-aqt~=1.0.dev\n```\n\n----------------------------------------\n\nTITLE: Creating and Validating a Quantum Circuit in Cirq (Python)\nDESCRIPTION: This code snippet creates a quantum circuit in Cirq consisting of an XX gate acting on two qubits, raised to the power of 0.5. It then validates the circuit against the AQT device and prints both the circuit and the qubits involved.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/aqt/getting_started.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit(cirq.XX(qubits[0], qubits[1])**0.5)\ndevice.validate_circuit(circuit)\nprint(circuit, qubits)\n```\n\n----------------------------------------\n\nTITLE: Using AmplitudeDampingChannel in Cirq (Python)\nDESCRIPTION: This code demonstrates the use of `cirq.AmplitudeDampingChannel` to represent energy dissipation.  It initializes a qubit to |1> using an X gate, then applies the amplitude damping channel with a specified decay probability `gamma`. The qubit is then measured, and the simulation is run to observe the effect of the damping.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/representing_noise.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nq0 = cirq.LineQubit(0)\ncircuit = cirq.Circuit(\n    cirq.X(q0),\n    cirq.amplitude_damp(gamma=0.2).on(q0),\n    cirq.measure(q0, key='result')\n)\nresult = cirq.Simulator(seed=0).run(circuit, repetitions=1000)\nprint(result.histogram(key='result'))\n```\n\n----------------------------------------\n\nTITLE: Simplify Flipped CNOTs: Transformer (Solution) - Python\nDESCRIPTION: This snippet presents a solution for simplifying a Cirq circuit by replacing a CNOT gate surrounded by Hadamard gates with an equivalent gate. It uses `cirq.merge_operations_to_circuit_op` to identify and merge Hadamard-CNOT-Hadamard sequences, and `cirq.map_operations` to replace these sequences with simplified gates, improving circuit efficiency.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_84\n\nLANGUAGE: python\nCODE:\n```\n# @title Expand to view the solution\ndef simplify_flipped_cnots(circuit, *, context=None):\n    \"\"\"Replaces a CX surrounded by Hadamards\"\"\"\n\n    def can_merge(ops1, ops2):\n        merged = cirq.Circuit(ops1, ops2)\n        return (\n            len(merged) <= 3\n            and all(o.gate == cirq.H for o in merged[0].operations)\n            and merged[1].operations[0].gate == cirq.CNOT\n            and (len(merged) < 3 or all(o.gate == cirq.H for o in merged[2].operations))\n        )\n\n    merged_tag = \"h_cx_h\"\n    circuit = cirq.merge_operations_to_circuit_op(\n        circuit, can_merge, merged_circuit_op_tag=merged_tag\n    )\n\n    def map_func(op, _):\n        if merged_tag not in op.tags:\n            return op\n        cops = [*op.untagged.mapped_circuit().all_operations()]\n        return cirq.CNOT(*cops[2].qubits[::-1]) if len(cops) == 5 else cops\n\n    return cirq.map_operations(circuit, map_func)\n\n\ncircuit = cirq.Circuit(\n    cirq.H.on_each(a, b, c), cirq.CNOT(a, b), cirq.H.on_each(a, b), cirq.CZ(a, b)\n)\nprint(f\"Before optimizing:\\n{circuit}\\n\")\nprint(f\"After optimizing:\\n{simplify_flipped_cnots(circuit)}\")\n```\n\n----------------------------------------\n\nTITLE: Optimizing Stabilizer Circuit for Hardware with Noise in Cirq\nDESCRIPTION: This code optimizes the larger stabilizer grid circuit for a target gate set, preparing it for noisy simulations. It decomposes the circuit using `cirq.decompose` and then optimizes it using `cirq.optimize_for_target_gateset` for the `cirq.SqrtIswapTargetGateset` gate set, accounting for hardware constraints.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ntest_stabilizer_grid_circuit = cirq.optimize_for_target_gateset(\n    cirq.Circuit(cirq.decompose(stabilizer_grid_circuit)),\n    context=cirq.TransformerContext(deep=True),\n    gateset=cirq.SqrtIswapTargetGateset(),\n)\nprint(test_stabilizer_grid_circuit)\n```\n\n----------------------------------------\n\nTITLE: Creating a square root of X gate\nDESCRIPTION: This code snippet demonstrates how to raise a unitary gate to a power, specifically creating a square root of X gate using `cirq.X ** (1 / 2)`. The unitary representation of the resulting gate is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/operators.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsqrt_not = cirq.X ** (1 / 2)\nprint(cirq.unitary(sqrt_not))\n```\n\n----------------------------------------\n\nTITLE: Quantum Circuit Simulation and Measurement in Cirq\nDESCRIPTION: This code snippet demonstrates how to simulate a quantum circuit using Cirq's `Simulator`. It constructs a circuit, appends the `initial_step` and `one_step` functions, and then measures all qubits. The `simulator.run` method executes the circuit for a specified number of repetitions (100), and the results are then printed as a histogram.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/variational_algorithm.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nsimulator = cirq.Simulator()\ncircuit = cirq.Circuit()\ncircuit.append(initial_step(len(h)))\ncircuit.append(one_step(h, jr, jc, 0.1, 0.2, 0.3))\ncircuit.append(cirq.measure(*qubits, key='x'))\nresults = simulator.run(circuit, repetitions=100)\nprint(results.histogram(key='x'))\n```\n\n----------------------------------------\n\nTITLE: Install Cirq Package in Python\nDESCRIPTION: This snippet attempts to import the Cirq library. If Cirq is not installed, it installs Cirq using pip. This ensures that the subsequent code can run without the 'ModuleNotFoundError'.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/interop.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Defining Sycamore Gate Set in Cirq\nDESCRIPTION: This snippet configures the 'sycamore' gate set within Cirq, defining valid gates such as 'syc', 'xy', 'xy_pi', 'xy_half_pi', 'z', 'xyz', 'meas', 'wait', and 'circuit'. Each gate is specified with its ID, number of qubits, valid arguments (including name and type), gate duration, and valid targets. This configuration defines the gates available for the Sycamore processor.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-google/cirq_google/devices/specifications/weber_2021_12_10_device_spec.proto.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nvalid_gate_sets {\n  name: \"sycamore\"\n  valid_gates {\n    id: \"syc\"\n    number_of_qubits: 2\n    valid_args {\n      name: \"phase_match\"\n      type: STRING\n    }\n    gate_duration_picos: 12000\n    valid_targets: \"2_qubit_targets\"\n  }\n  valid_gates {\n    id: \"xy\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"axis_half_turns\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"half_turns\"\n      type: FLOAT\n    }\n    gate_duration_picos: 25000\n  }\n  valid_gates {\n    id: \"xy_pi\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"axis_half_turns\"\n      type: FLOAT\n    }\n    gate_duration_picos: 25000\n  }\n  valid_gates {\n    id: \"xy_half_pi\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"axis_half_turns\"\n      type: FLOAT\n    }\n    gate_duration_picos: 25000\n  }\n  valid_gates {\n    id: \"z\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"half_turns\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"type\"\n      type: STRING\n    }\n  }\n  valid_gates {\n    id: \"xyz\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"x_exponent\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"z_exponent\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"axis_phase_exponent\"\n      type: FLOAT\n    }\n    gate_duration_picos: 25000\n  }\n  valid_gates {\n    id: \"meas\"\n    valid_args {\n      name: \"key\"\n      type: STRING\n    }\n    valid_args {\n      name: \"invert_mask\"\n      type: REPEATED_BOOLEAN\n    }\n    gate_duration_picos: 4000000\n    valid_targets: \"meas_targets\"\n  }\n  valid_gates {\n    id: \"wait\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"nanos\"\n      type: FLOAT\n    }\n  }\n  valid_gates {\n    id: \"circuit\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Operations and Connectivity on Sycamore Device in Cirq\nDESCRIPTION: This example validates operations for the Sycamore device, including a single-qubit Hadamard gate and a two-qubit SYC gate. It checks for valid gate types and qubit connectivity. An exception is printed if the validation fails, showcasing connectivity constraints.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/devices.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nq1, q2, q3 = cirq.GridQubit(7, 4), cirq.GridQubit(7, 5), cirq.GridQubit(7, 6)\nop1 = cirq.H(q1)\nop2 = cirq_google.SYC(q1, q3)\n\ntry:\n    my_device.validate_operation(op1)\nexcept Exception as e:\n    print(e)\n\ntry:\n    my_device.validate_operation(op2)\nexcept Exception as e:\n    print(e)\n```\n\n----------------------------------------\n\nTITLE: Running with Error Mitigation and Sharpening\nDESCRIPTION: This code snippet demonstrates how to use error mitigation and sharpening options when running a circuit on the IonQ platform. It shows how to pass the `error_mitigation` and `sharpen` parameters to the `service.run` method to improve circuit performance. This requires a valid IonQ API key and the cirq and cirq_ionq libraries.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/service.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Run a program against the service with error mitigation and sharpening\nresult = service.run(\n  circuit=circuit,\n  repetitions=100,\n  target='qpu',\n  error_mitigation={'debias': True},\n  sharpen=True\n)\n```\n\n----------------------------------------\n\nTITLE: Simulating Quantum Walk and Generating Graph\nDESCRIPTION: This code snippet simulates a quantum random walk using the 'generate_walk' function with the specified number of qubits, iterator, and sample number. The resulting distribution 'final' is then visualized using the 'graph' function. Dependencies include the functions generate_walk and graph which are assumed to be defined elsewhere.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/quantum_walks.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfinal = generate_walk(number_qubits, iterator, sample_number)\ngraph(final)\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-release Cirq-IonQ with pip\nDESCRIPTION: This command installs the latest pre-release version of the cirq-ionq module using pip. The ~= operator ensures that pip selects the most recent version compatible with the 1.0.dev specification.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-ionq/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install --upgrade cirq-ionq~=1.0.dev\n```\n\n----------------------------------------\n\nTITLE: Defining qubits, rotations and ZZ layers in Cirq (Python)\nDESCRIPTION: This snippet defines the qubit arrangement, single-qubit X rotations, and two-qubit ZZ interaction layers that constitute a single step of the quantum circuit. The qubits are arranged in a specific layout based on their IDs. The `theta` parameter represents the rotation angle for the X rotations. The `zz_pi_2` gate is a ZZ gate with a rotation angle of -pi/2. The zz_layer variables define moments containing ZZ interactions along different edges of the qubit arrangement. A single step is created by combining the X rotations and ZZ layers into a FrozenCircuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_utility_sim_4a.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# These 30 qubits contain the measured observable:\n#\n#   37-38-39-40-41-42         .   X--Y--39-Y--X--Y          .\n#   |           |             .   |           |             .\n#   52          53            .   X          53             .\n#   |           |             .   |           |             .\n#   56-57-58-59-60-61-62-63   .   X--57-X--59-60-61-X--Y    .\n#         |           |       .         |           |       .\n#         71          72      .         71          Y       .\n#         |           |       .         |           |       .\n#   75-76-77-78-79-80-81      .   Z--76-77-78-X--Y--81      .\n#   |           |             .   |           |             .\n#   90          91            .   Y           Y             .\n#   |           |             .   |           |             .\n#   94-95       98            .   94-95       98            .\n#\nqubit_ids = [\n    *range(37, 43),  # row 0\n    *range(52, 54),  # row 1\n    *range(56, 64),  # row 2\n    *range(71, 73),  # row 3\n    *range(75, 82),  # row 4\n    *range(90, 92),  # row 5\n    94, 95, 98,      # row 6\n]\nq = {i: cirq.NamedQubit(f'q{i}') for i in qubit_ids}\nqubits = list(q.values())\n\n# This parameter will be used to sweep over X rotation angles.\ntheta = sympy.Symbol('theta')\nx_rotations = cirq.Moment(cirq.rx(theta).on_each(qubits))\n\n# This is the ZZ(-pi/2) gate described in equation (2).\nzz_pi_2 = cirq.ZZ ** -0.5\n\n# Each of these moments performs ZZ interactions along\n# 1/3 of the edges in the region, corresponding to the\n# red, blue, and green edges in Fig. 1b.\nzz_layer_1 = cirq.Moment(\n    zz_pi_2(q[37], q[52]),\n    zz_pi_2(q[41], q[53]),\n    zz_pi_2(q[56], q[57]),\n    zz_pi_2(q[58], q[71]),\n    zz_pi_2(q[59], q[60]),\n    zz_pi_2(q[61], q[62]),\n    zz_pi_2(q[72], q[81]),\n    zz_pi_2(q[76], q[77]),\n    zz_pi_2(q[78], q[79]),\n    zz_pi_2(q[94], q[95]),\n)\nzz_layer_2 = cirq.Moment(\n    zz_pi_2(q[38], q[39]),\n    zz_pi_2(q[40], q[41]),\n    zz_pi_2(q[53], q[60]),\n    zz_pi_2(q[57], q[58]),\n    zz_pi_2(q[62], q[63]),\n    zz_pi_2(q[71], q[77]),\n    zz_pi_2(q[75], q[76]),\n    zz_pi_2(q[79], q[80]),\n    zz_pi_2(q[90], q[94]),\n    zz_pi_2(q[91], q[98]),\n)\nzz_layer_3 = cirq.Moment(\n    zz_pi_2(q[37], q[38]),\n    zz_pi_2(q[39], q[40]),\n    zz_pi_2(q[41], q[42]),\n    zz_pi_2(q[52], q[56]),\n    zz_pi_2(q[58], q[59]),\n    zz_pi_2(q[60], q[61]),\n    zz_pi_2(q[62], q[72]),\n    zz_pi_2(q[75], q[90]),\n    zz_pi_2(q[77], q[78]),\n    zz_pi_2(q[79], q[91]),\n    zz_pi_2(q[80], q[81]),\n)\n\n# This circuit encapsulates a single \"step\", as shown\n# in Fig. 1a.\nstep = cirq.FrozenCircuit(\n    x_rotations,\n    zz_layer_1,\n    zz_layer_2,\n    zz_layer_3,\n)\n# Uncomment this line to print the circuit diagram for\n# a single step of the circuit.\n# print(step)\n```\n\n----------------------------------------\n\nTITLE: Using the unitary protocol in Cirq\nDESCRIPTION: This code demonstrates the use of the `cirq.unitary` protocol to obtain the unitary matrix representation of Cirq objects such as Pauli gates and circuits. It prints the unitary matrix for the X gate and a simple circuit composed of X and Y gates on two qubits.  The code requires the `cirq` library.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/protocols.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nprint(cirq.X)\nprint(\"cirq.X unitary:\\n\", cirq.unitary(cirq.X))\n\na, b = cirq.LineQubit.range(2)\ncircuit = cirq.Circuit(cirq.X(a), cirq.Y(b))\nprint(circuit)\nprint(\"circuit unitary:\\n\", cirq.unitary(circuit))\n```\n\n----------------------------------------\n\nTITLE: Sampling Rx Rotations and Plotting Probabilities\nDESCRIPTION: This code simulates a quantum circuit with Rx rotations and estimates the ground state probability by sampling the qubit's state at each step.  It uses `cirq.simulate_moment_steps` to simulate the circuit and `step.sample` to obtain samples. It calculates the probability of the ground state based on the samples and plots the results.  Requires `numpy` and `matplotlib` for plotting.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_48\n\nLANGUAGE: python\nCODE:\n```\n# Number of times to sample.\nrepetitions = 100\n\n# List to store the probability of the ground state.\nsampled_probs = []\n\nfor i, step in enumerate(simulator.simulate_moment_steps(circuit)):\n    samples = step.sample([a], repetitions=repetitions)\n    prob = np.sum(samples, axis=0)[0] / repetitions\n    sampled_probs.append(prob)\n\n\n# Plot the probability of the ground state at each simulation step.\nplt.style.use('seaborn-v0_8-whitegrid')\nplt.plot(sampled_probs, 'o')\nplt.xlabel(\"Step\")\nplt.ylabel(\"Probability of ground state\");\n```\n\n----------------------------------------\n\nTITLE: Simulating a Circuit with a Custom Gate\nDESCRIPTION: This code simulates a Cirq circuit containing a custom gate, `RationalGate`. It creates a circuit with the custom gate applied to a qubit, uses the `cirq.Simulator` to simulate the circuit, and then prints the final state vector of the qubit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_52\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit(rg(a))\nsimulator = cirq.Simulator()\nresult = simulator.simulate(circuit)\nprint(result.final_state_vector)\n```\n\n----------------------------------------\n\nTITLE: Building Stabilizer Grid Circuit in Cirq\nDESCRIPTION: This code defines a larger stabilizer grid circuit with data and measurement qubits using `cirq.NamedQubit`. It constructs the circuit by applying Hadamard gates to the measurement qubits, followed by a series of CX gates between data and measurement qubits to implement the stabilizer measurements. Finally, it measures all data and measurement qubits and maps the named qubits to GridQubits on the hardware layout.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Consider the following grid, where numbers represent\n# measure qubits and letters represent data qubits:\n#\n#     A\n#    B0C\n#   D1E2F\n#    G3H4J\n#     K5L\n#      M\n#\n# Center Z-plaquettes on [0, 3, 4] and\n# X-plaquettes on [1, 2, 5]\n\n# Instantiate the alphabetical data qubits and numerical measurement qubits.\ngrid_data_qubits = {x: cirq.NamedQubit(x) for x in 'ABCDEFGHJKLM'}\ngrid_meas_qubits = {x: cirq.NamedQubit(str(x)) for x in range(6)}\n\n# Build the diamond shaped stabilizer circuit from six layered smaller stabilizers.\nstabilizer_grid_circuit = cirq.Circuit(\n    cirq.H.on_each(grid_meas_qubits[x] for x in [1, 2, 5]),\n    *[cirq.CX(grid_data_qubits[x], grid_meas_qubits[0]) for x in 'ABCE'],\n    *[cirq.CX(grid_meas_qubits[1], grid_data_qubits[x]) for x in 'BDEG'],\n    *[cirq.CX(grid_meas_qubits[2], grid_data_qubits[x]) for x in 'CEFH'],\n    *[cirq.CX(grid_data_qubits[x], grid_meas_qubits[3]) for x in 'EGHK'],\n    *[cirq.CX(grid_data_qubits[x], grid_meas_qubits[4]) for x in 'FHJL'],\n    *[cirq.CX(grid_meas_qubits[5], grid_data_qubits[x]) for x in 'HKLM'],\n    cirq.H.on_each(grid_meas_qubits[x] for x in [1, 2, 5]),\n    *[cirq.measure(mq) for mq in grid_meas_qubits.values()],\n    *[cirq.measure(dq) for dq in grid_data_qubits.values()],\n)\n# Map the named qubits of the stabilizer circuit to GridQubits on the hardware.\nqubit_map = {\n    cirq.NamedQubit('A'): cirq.GridQubit(4, 3),\n    cirq.NamedQubit('B'): cirq.GridQubit(5, 2),\n    cirq.NamedQubit('0'): cirq.GridQubit(5, 3),\n    cirq.NamedQubit('C'): cirq.GridQubit(5, 4),\n    cirq.NamedQubit('D'): cirq.GridQubit(6, 1),\n    cirq.NamedQubit('1'): cirq.GridQubit(6, 2),\n    cirq.NamedQubit('E'): cirq.GridQubit(6, 3),\n    cirq.NamedQubit('2'): cirq.GridQubit(6, 4),\n    cirq.NamedQubit('F'): cirq.GridQubit(6, 5),\n    cirq.NamedQubit('G'): cirq.GridQubit(7, 2),\n    cirq.NamedQubit('3'): cirq.GridQubit(7, 3),\n    cirq.NamedQubit('H'): cirq.GridQubit(7, 4),\n    cirq.NamedQubit('4'): cirq.GridQubit(7, 5),\n    cirq.NamedQubit('J'): cirq.GridQubit(7, 6),\n    cirq.NamedQubit('K'): cirq.GridQubit(8, 3),\n    cirq.NamedQubit('5'): cirq.GridQubit(8, 4),\n    cirq.NamedQubit('L'): cirq.GridQubit(8, 5),\n    cirq.NamedQubit('M'): cirq.GridQubit(9, 4),\n}\nstabilizer_grid_circuit = stabilizer_grid_circuit.transform_qubits(lambda q: qubit_map[q])\nprint(stabilizer_grid_circuit)\n```\n\n----------------------------------------\n\nTITLE: Running a Simple Cirq Program on QCS in Python\nDESCRIPTION: This snippet demonstrates how to define a simple quantum circuit using Cirq, run it on the specified processor using the `run_sweep` method, and retrieve the results. It creates a circuit with an X gate, followed by measurement.  The results are then printed to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/colab.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# A simple example.\nq = cirq.GridQubit(5, 2)\ncircuit = cirq.Circuit(cirq.X(q)**0.5, cirq.measure(q, key='m'))\n\njob = processor.run_sweep(\n    program=circuit,\n    repetitions=1000)\n\nresults = [str(int(b)) for b in job.results()[0].measurements['m'][:, 0]]\nprint('Success!  Results:')\nprint(''.join(results))\n```\n\n----------------------------------------\n\nTITLE: Measuring a state vector in Cirq\nDESCRIPTION: This snippet demonstrates how to measure a state vector using `cirq.measure_state_vector`. It initializes a state vector, performs a measurement on it, and prints the measurement result and the resultant state vector.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/operators.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\npsi = np.ones(shape=(2,)) / np.sqrt(2)\nprint(\"Wavefunction:\\n\", psi.round(3))\n```\n\nLANGUAGE: python\nCODE:\n```\nresults, psi_prime = cirq.measure_state_vector(psi, indices=[0])\n\nprint(\"Measured:\", results[0])\nprint(\"Resultant state:\\n\", psi_prime)\n```\n\n----------------------------------------\n\nTITLE: Simulating Error Correction Circuit\nDESCRIPTION: This snippet simulates the circuit with the added error and correction, displaying the state vector of qubits and ancillas in Dirac notation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/stabilizer_code.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nresults = cirq.Simulator().simulate(circuit, qubit_order=(qubits+ancillas), initial_state=0)\nprint('%s' % (cirq.dirac_notation(results.state_vector())))\n```\n\n----------------------------------------\n\nTITLE: Getting the Unitary Representation of a Hadamard Gate in Cirq\nDESCRIPTION: This snippet retrieves and displays the unitary matrix representation of a Hadamard gate using the cirq.unitary() function. This matrix describes how the gate transforms the quantum state.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Get the unitary of a gate, here the Hadamard gate.\"\"\"\ncirq.unitary(cirq.H)\n```\n\n----------------------------------------\n\nTITLE: Creating a depolarizing channel\nDESCRIPTION: This code demonstrates how to create a `cirq.DepolarizingChannel` with a specified probability `p` and number of qubits `n_qubits`. It then prints the channel.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/operators.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndepo_channel = cirq.DepolarizingChannel(p=0.01, n_qubits=1)\nprint(depo_channel)\n```\n\n----------------------------------------\n\nTITLE: Initializing AQT Sampler and Device in Python\nDESCRIPTION: This code initializes an `AQTSampler` with the specified workspace, resource, and access token. It also retrieves an AQT device with a specified number of qubits using `get_aqt_device` and prints the device information.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/aqt/getting_started.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nworkspace = 'WORKSPACE_NAME'\nresource = 'RESOURCE_NAME'\naqt_sampler = AQTSampler(workspace=workspace, resource=resource, access_token=access_token)\n\ndevice, qubits = get_aqt_device(2)\nprint(device)\n```\n\n----------------------------------------\n\nTITLE: Converting Circuit to Unitary Tensor Network\nDESCRIPTION: This snippet converts a quantum circuit into a unitary tensor network using `circuit_to_tensors` function from the `cirq.contrib.quimb` module, initializing it with `initial_state=None` to represent a unitary transformation. The resulting tensor network is then visualized using Quimb.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Cirq-to-Tensor-Networks.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ntensors, qubit_frontier, fix = ccq.circuit_to_tensors(circuit, qubits, initial_state=None)\ntn = qtn.TensorNetwork(tensors)\nprint(qubit_frontier)\ntn.graph(fix=fix, color=['Q0', 'Q1', 'Q2'], figsize=(8, 8))\n```\n\n----------------------------------------\n\nTITLE: Conditional CZ Rotation Layer in Cirq\nDESCRIPTION: This function applies conditional CZ rotations based on the `jr` and `jc` fields, representing coupling terms. For each element in `jr` and `jc`, it applies a `cirq.CZPowGate` between neighboring qubits. If the corresponding field value is -1, it applies X gates before and after the CZ gate to conjugate the interaction.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/variational_algorithm.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef rot_11_layer(jr, jc, half_turns):\n    \"\"\"Yields rotations about |11> conditioned on the jr and jc fields.\"\"\"\n    cz_gate = cirq.CZPowGate(exponent=half_turns)    \n    for i, jr_row in enumerate(jr):\n        for j, jr_ij in enumerate(jr_row):\n            q = cirq.GridQubit(i, j)\n            q_1 = cirq.GridQubit(i + 1, j)\n            if jr_ij == -1:\n                yield cirq.X(q)\n                yield cirq.X(q_1)\n            yield cz_gate(q, q_1)\n            if jr_ij == -1:\n                yield cirq.X(q)\n                yield cirq.X(q_1)\n\n    for i, jc_row in enumerate(jc):\n        for j, jc_ij in enumerate(jc_row):\n            q = cirq.GridQubit(i, j)\n            q_1 = cirq.GridQubit(i, j + 1)\n            if jc_ij == -1:\n                yield cirq.X(q)\n                yield cirq.X(q_1)\n            yield cz_gate(q, q_1)\n            if jc_ij == -1:\n                yield cirq.X(q)\n                yield cirq.X(q_1)\n```\n\n----------------------------------------\n\nTITLE: Placing a Circuit with HardcodedQubitPlacer in Cirq\nDESCRIPTION: This code demonstrates the use of `HardcodedQubitPlacer` with a pre-specified mapping from named topology to device qubits. It initializes the placer with a mapping generated by `all_offset_placements`, places the circuit using `place_circuit`, and visualizes the placement. The `HardcodedQubitPlacer` provides ultimate control over qubit placement but requires a pre-defined list of valid placements.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/qubit-placement.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nrainbow_mapping = all_offset_placements(rainbow_graph)\nhardcoded = HardcodedQubitPlacer(mapping=rainbow_mapping)\n\nplaced_c, placement = hardcoded.place_circuit(circuit, problem_topology=topo, shared_rt_info=shared_rt_info, rs=rs)\ncirq.draw_placements(rainbow_graph, circuit_graph, [placement])\n```\n\n----------------------------------------\n\nTITLE: Basic State Histogram Plotting with Cirq\nDESCRIPTION: This code creates a simple quantum circuit consisting of Hadamard gates on four qubits followed by measurement. It then simulates the circuit and plots the resulting state histogram using `cirq.plot_state_histogram`. The plot shows the probability of each possible measurement outcome.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/state_histograms.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nq = cirq.LineQubit.range(4)\ncircuit = cirq.Circuit([cirq.H.on_each(*q), cirq.measure(*q)])\nresult = cirq.Simulator().run(circuit, repetitions=100)\n_ = cirq.plot_state_histogram(result, plt.subplot())\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Installing the latest pre-release version of cirq-pasqal with pip\nDESCRIPTION: This command installs the latest pre-release version of the cirq-pasqal package using pip. The `~=` specifier selects the latest version compatible with `1.*` and `dev` in the name.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-pasqal/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install --upgrade cirq-pasqal~=1.0.dev\n```\n\n----------------------------------------\n\nTITLE: Transform Circuit for Device Execution in Python\nDESCRIPTION: This snippet transforms the GHZ circuit to use the `cirq.SqrtIswapTargetGateset`, which is supported by the Weber processor. It uses `cirq.optimize_for_target_gateset` function for this transformation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_basic_example.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Convert the gates in the GHZ circuit to the \"SqrtIswap\" gateset, which the device uses.\ntranslated_ghz_circuit = cirq.optimize_for_target_gateset(\n    ghz_circuit, context=cirq.TransformerContext(deep=True), gateset=cirq.SqrtIswapTargetGateset()\n)\nprint(translated_ghz_circuit)\n```\n\n----------------------------------------\n\nTITLE: Reordering Qubits (Python)\nDESCRIPTION: This code snippets demonstrate how to add a permutation gate that undoes the action of inserted SWAP gates and reorder qubits to initial physical qubits in `routed_circuit` based on their ordering in `circuit`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/routing_transformer.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Add a permutation gate that undoes the action of inserted SWAP gates\ninitial_qubits, sorted_qubits = zip(*sorted(swap_mapping.items(), key=lambda x: x[1]))\ninverse_swap_permutation = [sorted_qubits.index(q) for q in initial_qubits]\nrouted_circuit.append(cirq.QubitPermutationGate(list(inverse_swap_permutation)).on(*sorted_qubits))\n```\n\nLANGUAGE: python\nCODE:\n```\n# Reorder to initial physical qubits in `routed_circuit` based on their ordering in `circuit`\n_, order = zip(*sorted(list(initial_mapping.items()), key=lambda x: x[0]))\n```\n\n----------------------------------------\n\nTITLE: Estimating Circuit Fidelities with Cirq\nDESCRIPTION: This function estimates circuit fidelities from the sampled probabilities for each sampled dataset. It takes a sampled DataFrame, a list of circuits, and cycle depths as input. It returns the estimated circuit fidelities using the `benchmark_2q_xeb_fidelities` function from `cirq.experiments.xeb_fitting`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# use the same circuit library and cycle_depths for both\n#   noise models' sampled data.\ndef estimate_fidelities(sampled_df):\n    return xeb_fitting.benchmark_2q_xeb_fidelities(\n        sampled_df=sampled_df, circuits=circuit_library, cycle_depths=cycle_depths\n    )\n\n\ncircuit_fidelities = list(map(estimate_fidelities, sampled_dfs))\n```\n\n----------------------------------------\n\nTITLE: Reducing Circuit Size with CircuitOperation\nDESCRIPTION: This snippet demonstrates how to reduce the size of a circuit using `cirq.CircuitOperation`. This is especially useful for circuits with repetitive structures. Using `CircuitOperation` can significantly reduce the serialized size of the circuit, avoiding errors when sending large circuits to Quantum Engine.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/best_practices.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Repeatedly apply Hadamard and measurement to 10 qubits.\nmy_circuit = cirq.Circuit()\nqubits = cirq.GridQubit.rect(2, 5)\nfor i in range(100):\n    my_circuit.append(cirq.H.on_each(*qubits))\n    for qb in qubits:\n        my_circuit.append(cirq.measure(qb, key=cirq.MeasurementKey.parse_serialized(f'{i}:m{qb}')))\n\nprint(my_circuit)\n\n# The same circuit, but defined using CircuitOperations.\n# This is ~1000x smaller when serialized!\nq = cirq.NamedQubit(\"q\")\nsub_circuit = cirq.FrozenCircuit(cirq.H(q), cirq.measure(q, key='m'))\ncircuit_op = cirq.CircuitOperation(sub_circuit).repeat(100)\nshort_circuit = cirq.Circuit(\n    circuit_op.with_qubits(q).with_measurement_key_mapping({'m': f'm{q}'}) for q in qubits\n)\nprint(short_circuit)\n```\n\n----------------------------------------\n\nTITLE: Running Noiseless Simulation of Stabilizer Circuit in Cirq\nDESCRIPTION: This code simulates the stabilizer circuit without noise using `qsimcirq.QSimSimulator`.  It runs the circuit for a specified number of repetitions and measures the execution time. This provides a baseline for comparing the results with noisy simulations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nnoiseless_sim = qsimcirq.QSimSimulator()\n\nrepetitions = 100\nstart = time.time()\nresults = noiseless_sim.run(stabilizer_grid_circuit, repetitions=repetitions)\nelapsed = time.time() - start\nprint(f'{repetitions} repetitions completed in {elapsed:.03f}s')\n```\n\n----------------------------------------\n\nTITLE: Importing Cirq and Cirq-Google\nDESCRIPTION: This snippet imports the Cirq library and the Cirq-Google extension, which provides functionalities specific to Google's quantum hardware. `cirq_google` is typically used to interact with the Google Quantum Engine.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/best_practices.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq_google as cg\nimport sympy\n```\n\n----------------------------------------\n\nTITLE: Creating an Asynchronous Job\nDESCRIPTION: This snippet creates an asynchronous job to run the circuit. It uses the `create_job` method to submit the circuit to the IonQ API, and then retrieves the job ID. This allows you to submit a circuit and retrieve the results later.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/getting_started.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\njob = service.create_job(circuit, repetitions=100)\njob_id = job.job_id()\nprint(f'Job id: {job_id}')\n```\n\n----------------------------------------\n\nTITLE: Getting Unitary Matrices of Operations\nDESCRIPTION: This code snippet shows how to retrieve the unitary matrix representation of various quantum operations in Cirq using the cirq.unitary() function. It demonstrates this for a single gate (X), a two-qubit gate (SWAP), and an entire circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nprint('Unitary of the X gate')\nprint(cirq.unitary(cirq.X))\n\nprint('Unitary of SWAP operator on two qubits.')\nq0, q1 = cirq.LineQubit.range(2)\nprint(cirq.unitary(cirq.SWAP(q0, q1)))\n\nprint('Unitary of a sample circuit')\nprint(cirq.unitary(cirq.Circuit(cirq.X(q0), cirq.SWAP(q0, q1))))\n```\n\n----------------------------------------\n\nTITLE: Creating a Random Cirq Circuit\nDESCRIPTION: This snippet creates a random quantum circuit using Cirq. It generates a circuit with a specified number of qubits (3 in this case), a number of moments (10), and an operation density (0.8). Empty moments are dropped to optimize the circuit, and the resulting circuit is visualized using `SVGCircuit`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Cirq-to-Tensor-Networks.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nqubits = cirq.LineQubit.range(3)\ncircuit = cirq.testing.random_circuit(qubits, n_moments=10, op_density=0.8, random_state=52)\ncircuit = cirq.drop_empty_moments(circuit)\nSVGCircuit(circuit)\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Two-Qubit XEB Fidelities in Python\nDESCRIPTION: This snippet benchmarks the two-qubit XEB fidelities using `cirq.experiments.xeb_fitting.benchmark_2q_xeb_fidelities`. It takes the sampled data, circuit library, and cycle depths to estimate the fidelities of the two-qubit gates. The resulting fidelities are stored in the `fids` variable.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.experiments.xeb_fitting import benchmark_2q_xeb_fidelities\nfids = benchmark_2q_xeb_fidelities(\n    sampled_df=sampled_df,\n    circuits=circuit_library,\n    cycle_depths=cycle_depths,\n)\nfids\n```\n\n----------------------------------------\n\nTITLE: Parallel Gate Execution in Cirq\nDESCRIPTION: This code demonstrates how to execute two gates in parallel using Cirq's Moment. The X gates are applied to two different qubits within the same moment, allowing for simultaneous execution on the hardware.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/devices.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ncirq.Circuit(\n  cirq.Moment(cirq.X(cirq.GridQubit(4,4)), cirq.X(cirq.GridQubit(4,5)))\n)\n```\n\n----------------------------------------\n\nTITLE: Converting Noisy Circuit to Dense Density Matrix\nDESCRIPTION: This snippet calculates the density matrix of the noisy circuit using both the `tensor_density_matrix` function from `cirq.contrib.quimb` and the `final_density_matrix` function from Cirq. The resulting density matrices are then compared using `np.testing.assert_allclose` to ensure they are equivalent within a certain tolerance.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Cirq-to-Tensor-Networks.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nrho_tn = ccq.tensor_density_matrix(circuit, qubits)\nrho_cirq = cirq.final_density_matrix(circuit, qubit_order=qubits)\nnp.testing.assert_allclose(rho_cirq, rho_tn, atol=1e-5)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Device Topology with Cirq\nDESCRIPTION: This snippet sets up the device topology for the XEB experiment. If a `device_name` is provided, it retrieves the device object from Google QCS. Otherwise, it creates a mock device graph using `cirq.GridQubit`s and a `cirq.DensityMatrixSimulator`. It also converts the device into a graph of qubits using `cirq.contrib.routing.gridqubits_to_graph_device`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndevice_name = None  # change me!\n\nimport cirq.contrib.routing as ccr\nimport networkx as nx\n\nif device_name is None:\n    qubits = cirq.GridQubit.rect(3, 2, 4, 3)\n    # Delete one qubit from the rectangular arangement to\n    # 1) make it irregular 2) simplify simulation.\n    qubits = qubits[:-1]\n    sampler = cirq.DensityMatrixSimulator(noise=cirq.depolarize(5e-3))\n    graph = ccr.gridqubits_to_graph_device(qubits)\nelse:\n    import cirq_google as cg\n    sampler = cg.get_engine_sampler(device_name, gate_set_name='sqrt_iswap')\n    device = cg.get_engine_device(device_name)\n    qubits = sorted(device.qubits)\n    graph = ccr.gridqubits_to_graph_device(device.qubits)\n\n\npos = {q: (q.row, q.col) for q in qubits}\nnx.draw_networkx(graph, pos=pos)\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq using pip in Python\nDESCRIPTION: This code snippet attempts to import the Cirq library. If Cirq is not installed, it installs it using pip, and then imports it. It handles the ImportError and prints messages to the console during the installation process.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/gates.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n```\n\n----------------------------------------\n\nTITLE: Creating Virtual Engine from Device in Python\nDESCRIPTION: This snippet creates a `cirq_google.SimulatedLocalEngine` from a specific device, `cirq_google.Sycamore`. It uses the `create_noiseless_virtual_engine_from_device` function and then prints the processor ID and the device object associated with the processor.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/virtual_engine_interface.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsycamore_engine = cirq_google.engine.create_noiseless_virtual_engine_from_device(\n    'sycamore', cirq_google.Sycamore\n)\n\n# Note that the previous function creates an engine with just one processor\nprint([proc.processor_id for proc in sycamore_engine.list_processors()])\nprint(sycamore_engine.get_processor('sycamore').get_device())\n```\n\n----------------------------------------\n\nTITLE: Running a Quantum Circuit on AQT Sampler (Python)\nDESCRIPTION: This code snippet runs a given quantum circuit on the AQT sampler for a specified number of repetitions (100 in this case).  The results are then printed to the console. Implicit measurement is performed by the sampler.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/aqt/getting_started.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\naqt_sweep = aqt_sampler.run(circuit, repetitions=100)\nprint(aqt_sweep)\n```\n\n----------------------------------------\n\nTITLE: Installing Stable Cirq with Optional Modules\nDESCRIPTION: Installs the stable version of Cirq along with all optional modules, including cirq-ionq, using the pip package manager.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-ionq/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npip install cirq\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq and Importing Libraries\nDESCRIPTION: This code snippet checks if Cirq is installed and installs it if necessary. It also imports the Cirq and Matplotlib libraries, which are required for creating and plotting heatmaps.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/heatmaps.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n\nimport matplotlib.pyplot as plt\n```\n\n----------------------------------------\n\nTITLE: Building Circuits by Appending Operations One-by-One with Python\nDESCRIPTION: This code snippet demonstrates how to construct a quantum circuit in Cirq by appending Hadamard gates to individual qubits one at a time. It initializes an empty circuit, defines three line qubits, and then appends a Hadamard gate to each qubit using the `circuit.append()` method. Finally, it prints the resulting circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit()\nqubits = cirq.LineQubit.range(3)\ncircuit.append(cirq.H(qubits[0]))\ncircuit.append(cirq.H(qubits[1]))\ncircuit.append(cirq.H(qubits[2]))\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Authenticating and Accessing Quantum Engine in Python\nDESCRIPTION: This snippet attempts to authenticate with the Google Quantum Computing Service and retrieves the engine and processor objects. It handles potential errors like invalid credentials or insufficient permissions by printing informative messages. The code checks for successful sign-in (specific to Colab testing), gets the engine, lists available processors, and then retrieves the specified processor.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/colab.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom google.auth.exceptions import DefaultCredentialsError\nfrom google.api_core.exceptions import PermissionDenied\n\n# Create an Engine object to use, providing the project id and the args\ntry: \n    if qcs_objects.signed_in: # This line only needed for colab testing.\n        engine = cirq_google.get_engine()\n    print(f\"Successful authentication using project {project_id}!\")\n    print('Available Processors: ')\n    print(engine.list_processors())\n    print(f'Using processor: {processor_id}')\n    processor = engine.get_processor(processor_id)\nexcept DefaultCredentialsError as err: \n    print(\"Could not authenticate to Google Quantum Computing Service.\")\n    print(\" Tips: If you are using Colab: make sure the previous cell was executed successfully.\")\n    print(\"       If this notebook is not in Colab (e.g. Jupyter notebook), make sure gcloud is installed and `gcloud auth application-default login` was executed.\")\n    print()\n    print(\"Error message:\")\n    print(err)\nexcept PermissionDenied as err:\n    print(f\"While you are authenticated to Google Cloud it seems the project '{project_id}' does not exist or does not have the Quantum Engine API enabled.\")\n    print(\"Error message:\")\n    print(err)\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries: cirq, qsimcirq, matplotlib, numpy, sympy\nDESCRIPTION: This snippet imports necessary libraries for quantum circuit simulation, plotting, and numerical computation. It imports `cirq` for quantum circuit definition, `qsimcirq` for simulation, `matplotlib.pyplot` for plotting, `numpy` for numerical operations, and `sympy` for symbolic calculations. These libraries are essential for creating and running quantum circuit simulations and visualizing the results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_utility_sim_4b.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport qsimcirq\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport sympy\n```\n\n----------------------------------------\n\nTITLE: Compiling CircuitOperation with Deep Transformation\nDESCRIPTION: This example shows how to compile a circuit containing `CircuitOperation` with `deep=True` in the `TransformerContext`. This will optimize the contents of the `CircuitOperation` while preserving the structure, leading to a device-compatible circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/best_practices.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsyc_circuit = cirq.optimize_for_target_gateset(\n    short_circuit,\n    gateset=cg.SycamoreTargetGateset(),\n    context=cirq.TransformerContext(deep=True)\n)\nprint(syc_circuit)\n```\n\n----------------------------------------\n\nTITLE: Plotting Readout Error in Cirq\nDESCRIPTION: This code snippet retrieves and plots the readout error data from the `noise_props.readout_errors` attribute.  It generates two heatmaps: one for the probability of measuring a true |0> as |1>, and another for the probability of measuring a true |1> as |0>.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/qubit_picking.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nprint(f\"One qubit error data: readout_errors\")\nfig, axes = plt.subplots(1, 2, figsize=(20, 10))\nfor i, ax, title in zip(\n    range(2), axes.flat, [\"True |0> measured as |1>\", \"True |1> measured as |0>\"]\n):\n    measures = {\n        qubit: readout_error[i] for qubit, readout_error in noise_props.readout_errors.items()\n    }\n    ax.set_title(title)\n    _ = cirq.Heatmap(measures).plot(ax, vmax=0.4, vmin=0)\nfig.show()\n```\n\n----------------------------------------\n\nTITLE: Inserting Spin Echoes in Cirq\nDESCRIPTION: This code demonstrates how to insert spin echoes on the ancilla qubit. It defines a set of Pi pulses (`cirq.PhasedXPowGate`) and generates a sequence of alternating Pi pulses to create the spin echo. It then inserts these echoes into the circuit at a specified moment (moment 5 in this example) and aligns the single-qubit spin echo gates into other moments with single-qubit gates using `cirq.stratified_circuit`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# Gates for spin echoes. Note that these gates are self-inverse.\npi_pulses = [\n    cirq.PhasedXPowGate(phase_exponent=p, exponent=1.0) for p in (-0.5, 0.0, 0.5, 1.0)\n]\n\n# Generate spin echoes on ancilla.\nnum_echoes = 3\nrandom_state = np.random.RandomState(1)\n\nspin_echo = []\nfor _ in range(num_echoes):\n    op = random_state.choice(pi_pulses).on(qubits[0])\n    spin_echo += [op, cirq.inverse(op)]\n\n# Insert spin echo operations to circuit.\noptimized_circuit_with_spin_echoes = circuit.copy()\noptimized_circuit_with_spin_echoes.insert(5, spin_echo)\n\n# Align single-qubit spin echo gates into other moments of single-qubit gates.\noptimized_circuit_with_spin_echoes = cirq.stratified_circuit(\n    optimized_circuit_with_spin_echoes, \n    categories=[lambda op : len(op.qubits) == 1, lambda op : len(op.qubits) == 2]\n)\noptimized_circuit_with_spin_echoes\n```\n\n----------------------------------------\n\nTITLE: Iterating over a Cirq Circuit\nDESCRIPTION: This snippet shows how to iterate over a Cirq circuit, printing each moment in the circuit. Iteration produces moments, which represent collections of operations that can be executed simultaneously.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit(cirq.H(q0), cirq.CZ(q0, q1))\nfor moment in circuit:\n    print(moment)\n```\n\n----------------------------------------\n\nTITLE: Printing Qubit Set from Device Metadata in Cirq\nDESCRIPTION: This snippet accesses and prints the set of qubits available on the Sycamore device using the `qubit_set` attribute of the device metadata. This provides information about the physical qubits available on the device.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/devices.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nprint(metadata.qubit_set)\n```\n\n----------------------------------------\n\nTITLE: Building and Parameterizing the Cirq Circuit\nDESCRIPTION: This snippet constructs the overall quantum circuit by repeating a single step (defined previously) multiple times. It then defines the Z observable on qubit 62. A set of theta values is defined to sweep over, and these are converted into cirq.Points.  Finally, the snippet configures qsim simulation options, enabling CPU threads and potentially GPU.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_utility_sim_4b.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# The circuit used to generate Fig. 4b consists of 20 steps.\n# Changing \"repetitions\" here will adjust the number of steps simulated.\nall_steps = cirq.CircuitOperation(step, repetitions=20)\ncircuit = cirq.Circuit(all_steps)\n\n# This is the Z observable on qubit 62.\nobservables = [cirq.Z(q[62])]\n\n# These are approximately the values of theta plotted for experimental values\n# in Fig. 4b. Changing this list will adjust the simulation to test other\n# theta values.\ntheta_values = [*np.linspace(0, 0.8, 9), 1, np.pi / 2]\nparams = cirq.Points(key=\"theta\", points=theta_values)\n\n# These options are used to tune qsim performance.\n# On CPU, \"cpu_threads\" should be set to the number of cores available.\nopt = qsimcirq.QSimOptions(max_fused_gate_size=4, cpu_threads=24)\n# To use GPU instead, uncomment this line:\n# opt = qsimcirq.QSimOptions(use_gpu=True, gpu_mode=1)\nsimulator = qsimcirq.QSimSimulator(qsim_options=opt)\n```\n\n----------------------------------------\n\nTITLE: Inspecting Measurement Results from DFE in Python\nDESCRIPTION: This code snippet iterates through the trial results from the intermediate results of the DFE and prints rho_i, sigma_i, and the Pauli operator for each measurement. This provides a detailed view of the individual measurements and their contributions to the fidelity estimation.  It accesses information through `intermediate_results.trial_results`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/direct_fidelity_estimation.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfor trial_result in intermediate_results.trial_results:\n    print('rho_i=%.3f\\tsigma_i=%.3f\\tPauli:%s' % (trial_result.pauli_trace.rho_i, trial_result.sigma_i, trial_result.pauli_trace.P_i))\n```\n\n----------------------------------------\n\nTITLE: Running Batches of Circuits on Device in Cirq\nDESCRIPTION: This snippet runs the previously created batches of circuits (unoptimized, optimized, and with spin echoes) on the device using `device_sampler.sampler.run_batch`. The results are processed to calculate the survival probability for each circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Run all circuits.\"\"\"\nall_probs = []\nfor b in (batch, batch_with_optimization, batch_with_optimization_and_spin_echoes):\n    results = device_sampler.sampler.run_batch(b, repetitions=nreps)\n    all_probs.append([to_survival_prob(*res) for res in results])\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq (Python)\nDESCRIPTION: This snippet attempts to import the cirq library. If it's not installed, it installs cirq using pip and then imports it.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/routing_transformer.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    import cirq\n\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Quantum Circuit Generation for Problem\nDESCRIPTION: Generates a Cirq quantum circuit to solve the Hidden Linear Function problem.  It creates Hadamard gates for superposition, CZ gates based on the matrix A (optimized via edge coloring), S gates based on vector b, and final Hadamard gates before measurement. The function requires an instance of the `HiddenLinearFunctionProblem` class.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/hidden_linear_function.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef generate_circuit_for_problem(problem):\n    \"\"\"Generates `cirq.Circuit` which solves instance of Hidden Linear Function problem.\"\"\"\n    \n    qubits = cirq.LineQubit.range(problem.n)\n    circuit = cirq.Circuit()\n    \n    # Hadamard gates at the beginning (creating equal superposition of all states).\n    circuit += cirq.Moment([cirq.H(q) for q in qubits])\n    \n    # Controlled-Z gates encoding the matrix A.\n    for layer in edge_coloring(problem.A):\n        for i, j in layer:\n            circuit += cirq.CZ(qubits[i], qubits[j])\n        \n    # S gates encoding the vector b.\n    circuit += cirq.Moment([cirq.S.on(qubits[i]) for i in range(problem.n) if problem.b[i] == 1])\n            \n    # Hadamard gates at the end.\n    circuit += cirq.Moment([cirq.H(q) for q in qubits])\n    \n    # Measurements.\n    circuit += cirq.Moment([cirq.measure(qubits[i], key=str(i)) for i in range(problem.n)]) \n    \n    return circuit\n\ndef solve_problem(problem, print_circuit=False):\n    \"\"\"Solves instance of Hidden Linear Function problem.\n    \n    Builds quantum circuit for given problem and simulates\n    it with the Clifford simulator. \n    \n    Returns measurement result as binary vector, which is\n    guaranteed to be a solution to given problem.\n    \"\"\"\n    circuit = generate_circuit_for_problem(problem)\n        \n    if print_circuit:\n        print(circuit)\n    \n    sim = cirq.CliffordSimulator()\n    result = sim.simulate(circuit)\n    z = np.array([result.measurements[str(i)][0] for i in range(problem.n)])\n    return z\n\nsolve_problem(problem_10_64, print_circuit=True)\n```\n\n----------------------------------------\n\nTITLE: Create an Asynchronous Job on Azure Quantum\nDESCRIPTION: Creates an asynchronous job to run a Cirq circuit on Azure Quantum. The `service.create_job()` method submits the circuit and returns a `Job` object. This allows checking the job status and retrieving results later.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_ionq.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\njob = service.create_job(\n    program=circuit,\n    repetitions=100,\n    target=\"ionq.simulator\"\n)\n```\n\n----------------------------------------\n\nTITLE: Resolving Parameters in Flattened Circuit - Python\nDESCRIPTION: This snippet iterates through the new sweep created after flattening and resolves the parameters in the flattened circuit for each parameter set in the sweep. This demonstrates how to use the transformed sweep to evaluate the flattened circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfor params in new_sweep:\n    print(c_flat, '=>', end=' ')\n    print(cirq.resolve_parameters(c_flat, params))\n```\n\n----------------------------------------\n\nTITLE: Displaying Unitary of a CRx Gate\nDESCRIPTION: This code calculates and prints the unitary matrix of a custom controlled-Rx (CRx) gate with a rotation angle of 0.5π. It uses `cirq.unitary` to obtain the unitary matrix and `np.around` to round the values for better readability. Requires `numpy`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_54\n\nLANGUAGE: python\nCODE:\n```\nprint(np.around(cirq.unitary(CRx(0.5 * np.pi)), 3))\n```\n\n----------------------------------------\n\nTITLE: Accessing Device Metadata and Displaying Device Graph in Cirq\nDESCRIPTION: This snippet shows how to access metadata associated with a custom Cirq device and display its graph representation using NetworkX. It retrieves the metadata from `my_custom_device` and then uses `nx.draw` to visualize the device's graph, assuming the metadata includes a NetworkX graph (`nx_graph`).\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/devices.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nmy_metadata = my_custom_device.metadata\n\n# Display device graph:\nnx.draw(my_metadata.nx_graph)\n```\n\n----------------------------------------\n\nTITLE: Creating a unitary operation using Pauli-X gate in Cirq\nDESCRIPTION: This code snippet demonstrates how to create a unitary operation using the Pauli-X gate on a specific qubit in Cirq. It creates a `cirq.LineQubit` and applies the `cirq.X` gate to it, creating a `cirq.Operation`. Then, it prints the resulting unitary operation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/operators.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nqubit = cirq.LineQubit(0)\nunitary_operation = cirq.ops.X.on(qubit)  # cirq.X can also be used for cirq.ops.X\nprint(unitary_operation)\n```\n\n----------------------------------------\n\nTITLE: Creating PauliSums with Addition\nDESCRIPTION: This code shows how to create `cirq.PauliSum` objects by adding `PauliString` objects together. Numbers are treated as coefficients on the identity operator. It showcases sums of single-qubit `PauliString` objects.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Numbers are treated as coefficients on the identity I (on a unique bias qubit)\ntyprint(Xa + 4 + 5j)\n# Sums of single qubit PauliStrings\ntyprint(Xa + Xa)\ntyprint(Xa + Za)\ntyprint(Xa + Zb)\n```\n\n----------------------------------------\n\nTITLE: Install Cirq-Google and QSimCirq with Pip\nDESCRIPTION: This snippet attempts to import `cirq`, `cirq_google`, and `qsimcirq`. If these packages are not found, it installs them using `pip`.  This ensures the necessary libraries are available for quantum circuit simulation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/quantum_virtual_machine.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\n    import cirq_google\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq-google\n    print(\"installed cirq.\")\n    import cirq\n    import cirq_google\n\ntry:\n    import qsimcirq\nexcept ImportError:\n    print(\"installing qsimcirq...\")\n    !pip install --quiet qsimcirq\n    print(f\"installed qsimcirq.\")\n    import qsimcirq\n```\n\n----------------------------------------\n\nTITLE: Z Stabilizer Circuit with Data Measurement (Cirq)\nDESCRIPTION: This snippet modifies the original Z stabilizer circuit to include measurements of the data qubits after the stabilizer measurement. This allows for guessing where the error(s) took place by observing the final states of the data qubits. The measurements are performed in a separate moment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Add measurements to the data qubits.\nstabilizer_circuit_for_hardware = stabilizer_circuit + (\n    cirq.Moment(cirq.measure(data_qubit, key=str(data_qubit)[-1]) for data_qubit in data_qubits)\n)\nprint(f'Z-stabilizer circuit with data measurement:')\nprint('========================')\nprint(stabilizer_circuit_for_hardware)\n```\n\n----------------------------------------\n\nTITLE: Initializing Quantum Walk State with Cirq\nDESCRIPTION: This code initializes the qubit register to represent the initial state of the quantum walk.  It applies an X gate to specific qubits to initialize both the position vector and the coin qubit to the |1⟩ state (representing the |↓⟩ state for the coin). The function uses `cirq.X.on()` to apply the X gate to the specified qubits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/quantum_walks.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef initial_state():\n\n    yield cirq.X.on(cirq.GridQubit(0, 1))\n    yield cirq.X.on(cirq.GridQubit(0, number_qubits))\n```\n\n----------------------------------------\n\nTITLE: Slicing a Cirq Circuit\nDESCRIPTION: This example demonstrates how to slice a Cirq circuit to create a new circuit containing only the moments within the specified slice. Slicing is useful for extracting portions of a circuit for analysis or modification.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit(cirq.H(q0), cirq.CZ(q0, q1), cirq.H(q1), cirq.CZ(q0, q1))\nprint(circuit[1:3])\n```\n\n----------------------------------------\n\nTITLE: Simulating Randomized Algorithm with Repetitions and Confusion Matrix in Python\nDESCRIPTION: This code extends the previous simulation by running the randomized algorithm multiple times for each function. It then uses the majority decision from these repetitions to make a final decision about whether the function is balanced or constant. A confusion matrix is created to evaluate the performance improvement achieved by using repetitions, effectively decreasing error rate.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nN = 128\nsamples_size_per_function = 3\nrepetitions_of_randomized_alg = 3\nnumber_of_functions_to_try = 1000\n\nres = pd.DataFrame()\nfor _ in range(number_of_functions_to_try):\n    dist, f = choose_random_function()\n    constant_minus_blanaced_count = 0\n    for _ in range(repetitions_of_randomized_alg):\n        decision = randomized_alg(f, samples_size_per_function)\n        constant_minus_blanaced_count += 1 if decision == \"constant\" else -1\n    final_decision = \"constant\" if constant_minus_blanaced_count > 0 else \"balanced\"\n    res=pd.concat([res, pd.DataFrame({\n        \"Distribution\": [dist],\n        \"Decision\":[final_decision],\n        \"Count\": [1]\n    })], ignore_index=True)\nconfusion = res.pivot_table(index=\"Distribution\",\n                            columns=\"Decision\",\n                            values=\"Count\",\n                            aggfunc=\"sum\")\n# Translate the counts into percentage\nconfusion.div(confusion.sum(axis=1), axis=0).apply(lambda x: round(x, 4) * 100)\n```\n\n----------------------------------------\n\nTITLE: Transform Circuit for CZ Gateset\nDESCRIPTION: Transforms a quantum circuit into a specific gateset (CZ gateset in this example) using `cirq.optimize_for_target_gateset`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/start.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ngateset = cirq.CZTargetGateset(allow_partial_czs=True)\ntransformed_circuit = cirq.optimize_for_target_gateset(hw_circuit, gateset=gateset)\nprint(transformed_circuit)\n```\n\n----------------------------------------\n\nTITLE: Running Quantum Volume Algorithm with Routing Attempts\nDESCRIPTION: This snippet runs the Quantum Volume algorithm across a range of routing attempts. It imports `numpy` and relevant functions from `cirq.contrib`.  It defines a noise model using `cirq.ConstantQubitNoiseModel` and `cirq.DepolarizingChannel`, sets up the simulation using `cirq.DensityMatrixSimulator`, then calculates the quantum volume for each routing attempt using `quantum_volume.calculate_quantum_volume`. The results are stored in a list.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_volume_routing.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Run the Quantum Volume algorithm over the above parameters.\n\nimport numpy as np\nfrom cirq.contrib import quantum_volume, routing\n\nsamplers = [\n        cirq.DensityMatrixSimulator(noise=cirq.ConstantQubitNoiseModel(\n        qubit_noise_gate=cirq.DepolarizingChannel(p=.005)))]\n\nresults = []\nfor r in routing_attempts:\n    print(f\"Running with {r} routing attempt(s)\")\n    results.append(quantum_volume.calculate_quantum_volume(num_circuits=num_circuits,\n                            depth=depth,\n                            num_qubits=depth,\n                            device_graph=routing.gridqubits_to_graph_device(qubits),\n                            samplers=samplers,\n                            compiler=compiler,\n                            random_state=np.random.RandomState(52),\n                            repetitions=repetitions,\n                            routing_attempts=r))\n```\n\n----------------------------------------\n\nTITLE: Get Job Results from Azure Quantum\nDESCRIPTION: Waits for an asynchronous job to complete and retrieves the results using the blocking call `job.results()`. The returned object is a `SimulatorResult`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_ionq.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nresult = job.results()\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Expanding Kraus Operators in Pauli Basis in Cirq\nDESCRIPTION: This snippet demonstrates how to expand Kraus operators in the Pauli basis using `cirq.expand_matrix_in_orthogonal_basis`. This is useful for analyzing the effects of noise in terms of Pauli operators.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_70\n\nLANGUAGE: python\nCODE:\n```\nfor i, kraus in enumerate(cirq.kraus(cirq.depolarize(0.2))):\n    pauli_ex = cirq.expand_matrix_in_orthogonal_basis(kraus, cirq.PAULI_BASIS)\n    print(f\"Kraus operator {i} is:\", pauli_ex, sep=\"\\n\", end=\"\\n\\n\")\n```\n\n----------------------------------------\n\nTITLE: Mocking Device Topology with NetworkX and Cirq in Python\nDESCRIPTION: This snippet creates a graph of qubits to mimic a small device topology, using `cirq.GridQubit` and `networkx`.  It defines a 3x2 grid of qubits, selects the first 5 to create an irregular shape, and then creates a graph representing the connectivity between adjacent qubits. The graph is visualized using `networkx.draw_networkx`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport networkx as nx\nimport itertools\n\n# a set of six example GridQubits\nqubits = cirq.GridQubit.rect(3, 2, 4, 3)\n# only use the first num_qubits many qubits\nnum_qubits = 5\nqubits = qubits[:num_qubits]\n\n# create graph from adjacent qubits\ngraph = nx.Graph((q1, q2) for (q1, q2) in itertools.combinations(qubits, 2) if q1.is_adjacent(q2))\npos = {q: (q.row, q.col) for q in qubits}\nnx.draw_networkx(graph, pos=pos)\n```\n\n----------------------------------------\n\nTITLE: Benchmark Circuit Creation in Python\nDESCRIPTION: This code defines helper functions and a `create_benchmark_circuit` function, which generates an 'OTOC-like' circuit for benchmarking. It uses random rotations and two-qubit gates and can optionally incorporate optimization, alignment, and spin echoes. The function takes qubits, cycles, a two-qubit gate, and a seed as input.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# @markdown Helper functions.\nfrom typing import Optional, Sequence\nfrom cirq.experiments import random_rotations_between_grid_interaction_layers_circuit\n\n\n# Gates for spin echoes.\npi_pulses = [\n    cirq.PhasedXPowGate(phase_exponent=p, exponent=1.0) for p in (-0.5, 0.0, 0.5, 1.0)\n]\n\n\ndef create_benchmark_circuit(\n    qubits: Sequence[cirq.GridQubit],\n    cycles: int,\n    twoq_gate: cirq.Gate = cirq.SQRT_ISWAP,\n    seed: Optional[int] = None,\n    with_optimization: bool = False,\n    with_alignment: bool = False,\n    with_spin_echoes: bool = False,\n) -> cirq.Circuit:\n    \"\"\"Returns an \"OTOC-like\" circuit [1] used to benchmark optimization and/or\n    alignment and/or spin echoes.\n\n    Args:\n        qubits: Qubits to use.\n        cycles: Depth of random rotations in the forward & reverse unitary.\n        twoq_gate: Two-qubit gate to use.\n        seed: Seed for circuit generation.\n        with_optimization: Run a series of optimizations on the circuit.\n        with_alignment: Align moments and synchronize terminal measurements.\n        with_spin_echoes: Insert spin echoes on ancilla qubit.\n    \n    References:\n        [1] Fig. S10 of https://arxiv.org/abs/2101.08870.\n    \"\"\"\n    ancilla, qubits = qubits[0], qubits[1:]\n\n    # Put ancilla into the |1⟩ state and couple it to the rest of the qubits.\n    excite_ancilla = [cirq.X(ancilla), twoq_gate(ancilla, qubits[0])]\n\n    # Forward operations.\n    forward = random_rotations_between_grid_interaction_layers_circuit(\n        qubits, \n        depth=cycles,\n        two_qubit_op_factory=lambda a, b, _: twoq_gate.on(a, b),\n        pattern=cirq.experiments.GRID_STAGGERED_PATTERN,\n        single_qubit_gates=[cirq.PhasedXPowGate(phase_exponent=p, exponent=0.5)\n                            for p in np.arange(-1.0, 1.0, 0.25)],\n        seed=seed\n    )\n\n    # Full circuit. Note: We are intentionally creating a bad circuit structure\n    # by putting each operation in a new moment (via `cirq.InsertStrategy.New`)\n    # to show the advantages of optimization & alignment.\n    circuit = cirq.Circuit(excite_ancilla)\n    circuit.append(forward.all_operations(), strategy=cirq.InsertStrategy.NEW)\n    circuit.append(cirq.inverse(forward).all_operations(), strategy=cirq.InsertStrategy.NEW)\n    circuit.append(cirq.inverse(excite_ancilla[1:]))\n    circuit.append(cirq.measure(ancilla, key=\"z\"), strategy=cirq.InsertStrategy.NEW)\n\n    # Run optimization.\n    if with_optimization:\n        cirq.MergeInteractionsToSqrtIswap().optimize_circuit(circuit)\n        circuit = cirq.eject_phased_paulis(circuit)\n        circuit = cirq.eject_z(circuit)\n        circuit = cirq.drop_negligible_operations(circuit)\n        circuit = cirq.drop_empty_moments(circuit)\n\n    # Insert spin echoes. Note: It's important to do this after optimization, as\n    # optimization will remove spin echoes.\n    if with_spin_echoes:\n        random_state = np.random.RandomState(seed)\n\n        spin_echo = []\n        for _ in range(cycles * 2):\n            op = random_state.choice(pi_pulses).on(ancilla)\n            spin_echo += [op, cirq.inverse(op)]\n\n        circuit.insert(2, spin_echo)\n\n    # Alignment.\n    if with_alignment:\n        circuit = cirq.align_right(circuit)\n        circuit = synchronize_terminal_measurements(circuit)\n\n    return circuit\n\n\ndef to_survival_prob(result: cirq.Result) -> float:\n    return np.mean(np.sum(result.measurements[\"z\"], axis=1) == 1)\n```\n\n----------------------------------------\n\nTITLE: Creating Device-Ready Circuit\nDESCRIPTION: This code snippet demonstrates how to create a simple device-ready circuit using Cirq. It initializes a `cirq.GridQubit` and applies an X gate to the power of 0.5, followed by a measurement. The resulting circuit is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_builder_code.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# create your device ready circuit here!\nq0 = cirq.GridQubit(4, 1)\nyour_circuit = cirq.Circuit([(cirq.X**0.5)(q0), cirq.measure(q0)])\nprint(your_circuit)\n```\n\n----------------------------------------\n\nTITLE: Generating a Library of Two-Qubit Circuits in Python\nDESCRIPTION: This snippet generates a library of random two-qubit circuits using `cirq.experiments.random_quantum_circuit_generation.generate_library_of_2q_circuits`. It specifies the number of circuits to generate, the two-qubit gate to use (sqrt(ISWAP) in this case), and a random state for reproducibility. The length of the generated circuit library is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.experiments import random_quantum_circuit_generation as rqcg\n\ncircuit_library = rqcg.generate_library_of_2q_circuits(\n    n_library_circuits=20, \n    two_qubit_gate=cirq.ISWAP**0.5,\n    random_state=52,\n)\nprint(len(circuit_library))\n```\n\n----------------------------------------\n\nTITLE: Validating a Circuit Against Device Constraints in Cirq\nDESCRIPTION: This snippet demonstrates how to validate a circuit against the constraints defined by a custom Cirq device. It attempts to validate a circuit (`too_many_czs`) using the `validate_circuit` method of a custom device (`my_custom_device`). If the circuit violates any constraints, an exception is caught and printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/devices.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    my_custom_device.validate_circuit(too_many_czs)\nexcept Exception as e:\n    print(e)\n```\n\n----------------------------------------\n\nTITLE: Using the mixture protocol in Cirq\nDESCRIPTION: This snippet demonstrates using the `cirq.mixture` protocol to obtain the probabilities and Kraus operators of a bit-flip channel. It iterates through the returned pairs and prints the probability and corresponding Kraus operator for each component of the mixture.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Example of using the mixture protocol.\"\"\"\nfor prob, kraus in cirq.mixture(bit_flip):\n    print(f\"With probability {prob}, apply\\n\", kraus, end=\"\\n\\n\")\n```\n\n----------------------------------------\n\nTITLE: Simulating Circuit with Repetitions and Generating Histograms in Cirq\nDESCRIPTION: This snippet simulates a quantum circuit with a specified number of repetitions using Cirq's `simulator.run` method. It demonstrates how to obtain a histogram of measurement results using the `histogram` method and how to plot a state histogram using `cirq.plot_state_histogram`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\n# Sample from the circuit 1000 times.\nresult = simulator.run(circuit, repetitions=1000)\n\n# Get a histogram of measurement results.\nprint(result.histogram(key=\"a,b\"))\n\n# Plot a state histogram of the result.\ncirq.plot_state_histogram(result)\n```\n\n----------------------------------------\n\nTITLE: Measure Shor's Period Finding Circuit in Cirq\nDESCRIPTION: This snippet demonstrates how to sample measurements from the Shor's period finding circuit. It displays both the raw measurements and the integer representation of the bitstrings in the exponent register using `cirq.sample` and `res.data`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ncircuit = make_order_finding_circuit(x=5, n=6)\nres = cirq.sample(circuit, repetitions=8)\n\nprint(\"Raw measurements:\")\nprint(res)\n\nprint(\"\\nInteger in exponent register:\")\nprint(res.data)\n```\n\n----------------------------------------\n\nTITLE: Creating custom channel with MixedUnitaryChannel\nDESCRIPTION: This snippet creates a custom noise channel using `cirq.MixedUnitaryChannel`. It is equivalent to a bit-flip channel with probability 0.1. The `mix` variable defines the probability and the unitary matrix to be applied. In this case, with 0.9 probability the identity is applied and with 0.1 probability, the X gate is applied, which is a bit-flip.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nq0 = cirq.LineQubit(0)\n# This is equivalent to a bit-flip error with probability 0.1.\nmix = [\n    (0.9, np.array([[1, 0], [0, 1]], dtype=np.complex64)),\n    (0.1, np.array([[0, 1], [1, 0]], dtype=np.complex64)),\n]\nbit_flip_mix = cirq.MixedUnitaryChannel(mix)\n```\n\n----------------------------------------\n\nTITLE: Simulating Loschmidt Echo\nDESCRIPTION: This snippet simulates the Loschmidt echo circuit using Cirq's simulator. It runs the circuit for a specified number of repetitions (`nreps`) and calculates the survival probability (ground state probability) from the simulation results. This probability should ideally be 1.0 in a noiseless environment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/echoes.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Loschmidt echo benchmark on a simulator.\"\"\"\n# Simulate the circuit.\nnreps = 20_000\nres = cirq.Simulator().run(circuit, repetitions=nreps)\n\n# Verify the survival probability is 1.0.\nground_state_prob = np.mean(np.sum(res.measurements[\"z\"], axis=1) == 0)\nprint(\"Survival probability:\", ground_state_prob)\n```\n\n----------------------------------------\n\nTITLE: Configuring Quantum Volume Parameters\nDESCRIPTION: This snippet sets up the parameters for the Quantum Volume algorithm, including the number of repetitions, maximum depth, depths to test, and the number of samples per circuit.  It defines an `optimize` function that optimizes the circuit for the CZTargetGateset.  It also defines the samplers (ideal and noisy simulators) and their associated plot configurations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_volume.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# This cell sets up the parameters for the quantum volume algorithm.\n# Feel free to mess with these!\nimport cirq\n\nnum_repetitions = 10  # This is supposed to be >= 100.\nmax_depth = 5\ndepths = range(2, max_depth)  # The depths and number of qubits\nrepetitions = 10_000  # The number of times to sample per circuit\n\ndef optimize(circuit):\n    return cirq.optimize_for_target_gateset(circuit, gateset=cirq.CZTargetGateset())\n\n# Here is the important set-up: the samplers and their plot configurations.\n# These are what will be run on the generated circuit, and then evaluated.\nsamplers = [{\n    'label': 'Ideal simulation',\n    'sampler': cirq.Simulator(),\n    'marker': '+',\n    'color': 'tab:green',\n}, {\n    'label': 'Noisy simulation',\n    'sampler':\n    cirq.DensityMatrixSimulator(noise=cirq.ConstantQubitNoiseModel(\n        qubit_noise_gate=cirq.DepolarizingChannel(p=0.005))),\n    'color': 'tab:red',\n    'marker': 'o',\n}]\n\nprint(f\"Configuration: depths from {depths[0]} to {depths[-1]} with \"\n      f\"{num_repetitions} runs of {len(samplers)} samplers\")\n```\n\n----------------------------------------\n\nTITLE: Drawing TiltedSquareLattice\nDESCRIPTION: This snippet demonstrates how to create and draw a TiltedSquareLattice topology with different width and height parameters using Cirq and matplotlib. It iterates through different side lengths to create multiple subplots showing different TiltedSquareLattice configurations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/named_topologies.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport itertools\nfrom cirq import TiltedSquareLattice\n\nside_lens = np.arange(1, 4+1)\nl = len(side_lens)\n\nfig, axes = plt.subplots(l, l, figsize=(3.5*l, 3*l))\nfor widthi, heighti in itertools.product(np.arange(l), repeat=2):\n    width = side_lens[widthi]\n    height = side_lens[heighti]\n    ax = axes[heighti, widthi]\n    topo = TiltedSquareLattice(width, height)\n    topo.draw(ax=ax, tilted=False)\n        \n    if widthi == 0:\n        ax.set_ylabel(f'Height {height}', fontsize=14)\n    if heighti == l-1:\n        ax.set_xlabel(f'Width {width}', fontsize=14)\n    \n    ax.set_title(f'n = {topo.n_nodes}', fontsize=14)\n        \nfig.tight_layout()\n```\n\n----------------------------------------\n\nTITLE: Installing and Importing Cirq\nDESCRIPTION: This snippet attempts to import the cirq library and installs it if it is not found. It also imports necessary modules from cirq and a custom module `stabilizer_code`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/stabilizer_code.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n    \nfrom cirq.contrib.svg import SVGCircuit\nimport examples.stabilizer_code as sc\n```\n\n----------------------------------------\n\nTITLE: Define Adder arithmetic gate in Cirq (Python)\nDESCRIPTION: This code defines a quantum addition gate called `Adder` in Cirq, inheriting from `cirq.ArithmeticGate`. The gate adds the value of the input register to the target register modulo N_t. It overrides the `registers`, `with_registers`, and `apply` methods to specify the gate's behavior. The `apply` method simply sums the register values, and the `cirq.ArithmeticGate` class infers the modular arithmetic necessary for reversibility.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass Adder(cirq.ArithmeticGate):\n    \"\"\"Quantum addition.\"\"\"\n    def __init__(\n        self,\n        target_register: [int, Sequence[int]],\n        input_register: Union[int, Sequence[int]],\n    ):\n        self.target_register = target_register\n        self.input_register = input_register\n\n    def registers(self) -> Sequence[Union[int, Sequence[int]]]:\n        return self.target_register, self.input_register\n\n    def with_registers(\n        self, *new_registers: Union[int, Sequence[int]]\n    ) -> 'Adder':\n        return Adder(*new_registers)\n\n    def apply(self, *register_values: int) -> Union[int, Iterable[int]]:\n        return sum(register_values)\n    def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs):\n        wire_symbols = [' + ' for _ in range(len(self.input_register)+len(self.target_register))]\n        return cirq.CircuitDiagramInfo(wire_symbols=tuple(wire_symbols))\n```\n\n----------------------------------------\n\nTITLE: Simulating a circuit with the `simulate` method\nDESCRIPTION: This snippet shows how to use the `simulate` method in Cirq to obtain the wavefunction of a circuit. It creates a circuit without measurements by calling `basic_circuit` with `measure=False`. This illustrates how to access the full quantum state, as opposed to just measurement results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Simulating a circuit with the `simulate` method.\"\"\"\n# Get a circuit without measurements.\ncircuit = cirq.Circuit(basic_circuit(measure=False))\n```\n\n----------------------------------------\n\nTITLE: Type Annotation with Conditional Cirq Import (Python)\nDESCRIPTION: This snippet demonstrates the recommended approach for using type annotations with `cirq` classes to prevent import cycles. It guards the `cirq` import with `TYPE_CHECKING` and uses `from __future__ import annotations` to defer evaluation of annotations. The function `accepts_sampler` is annotated to accept a `cirq.Sampler`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/style.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    import cirq\n\ndef accepts_sampler(sampler: cirq.Sampler) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Calculating Fidelity Metrics in Python\nDESCRIPTION: This code iterates through the collected records and calculates the values for `e_u`, `u_u`, and `m_u` based on the pure and sampled probabilities. These values are used in the XEB fidelity estimation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/xeb_theory.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfor record in records:\n    e_u = np.sum(record['pure_probs']**2)\n    u_u = np.sum(record['pure_probs']) / DIM\n    m_u = np.sum(record['pure_probs'] * record['sampled_probs'])\n    record.update(\n        e_u=e_u,\n        u_u=u_u,\n        m_u=m_u,    \n    )\n```\n\n----------------------------------------\n\nTITLE: Placing a Circuit with NaiveQubitPlacer in Cirq\nDESCRIPTION: This code shows the usage of `NaiveQubitPlacer`, which directly maps input qubits to device qubits without considering connectivity.  It should be used with caution, as it requires careful qubit selection during circuit construction. The placement is visualized using `cirq.draw_placements`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/qubit-placement.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nnaive = NaiveQubitPlacer()\n\nplaced_c, placement = naive.place_circuit(circuit, problem_topology=topo, shared_rt_info=shared_rt_info, rs=rs)\ncirq.draw_placements(rainbow_graph, circuit_graph, [placement])\n```\n\n----------------------------------------\n\nTITLE: Flattening Sympy Formulas into Symbols\nDESCRIPTION: This code demonstrates how to flatten a sympy formula into a symbol for each value of a sweep. This avoids issues with serialization and potential performance problems with sympy by pre-computing the values of the formula and storing them in a new symbol.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/best_practices.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Suppose we have a gate with a complicated formula.  (e.g. \"2^t - 1\")\n# This formula cannot be serialized\n# It could potentially encounter sympy slowness.\ngate_with_formula = cirq.XPowGate(exponent=2 ** sympy.Symbol('t') - 1)\nsweep = cirq.Linspace('t', start=0, stop=1, length=5)\n\n# Instead of sweeping the formula, we will pre-compute the values of the formula\n# at every point and store it a new symbol called '<2**t - 1>'\nsweep_for_gate, flat_sweep = cirq.flatten_with_sweep(gate_with_formula, sweep)\n\nprint(repr(sweep_for_gate))\n\nprint(list(flat_sweep.param_tuples()))\n```\n\n----------------------------------------\n\nTITLE: Graphing Quantum Walk Results with Matplotlib\nDESCRIPTION: This code defines the `graph()` function, which takes the final distribution from the quantum walk simulation and plots it using Matplotlib. It extracts the x and y values from the distribution, sorts them, and then creates a scatter plot.  It requires the `matplotlib.pyplot` library.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/quantum_walks.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef graph(final):\n\n    x_arr = list(final.keys())\n    y_arr = [dict(final)[j] for j in dict(final).keys()]\n\n    x_arr_final = []\n    y_arr_final = []\n\n    while (len(x_arr) > 0):\n\n        x_arr_final.append(min(x_arr))\n        y_arr_final.append(y_arr[x_arr.index(min(x_arr))])\n        holder = x_arr.index(min(x_arr))\n        del x_arr[holder]\n        del y_arr[holder]\n\n    plt.plot(x_arr_final, y_arr_final)\n    plt.scatter(x_arr_final, y_arr_final)\n    plt.show()\n\ngraph(final)\n```\n\n----------------------------------------\n\nTITLE: Configuring Project and Processor IDs in Python\nDESCRIPTION: This snippet defines variables for the Google Cloud Project ID and Processor ID, taking input via Colab's form input feature. It then uses these IDs to initialize the QCS objects needed for interacting with the quantum computing service, including obtaining an engine and processor.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/colab.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# The Google Cloud Project id to use.\nproject_id = '' #@param {type:\"string\"}\nprocessor_id = \"\" #@param {type:\"string\"}\n\nfrom cirq_google.engine.qcs_notebook import get_qcs_objects_for_notebook\n# For real engine instances, delete 'virtual=True' below.\nqcs_objects = get_qcs_objects_for_notebook(project_id, processor_id, virtual=True)\nengine = qcs_objects.engine\nprocessor_id = qcs_objects.processor_id\n```\n\n----------------------------------------\n\nTITLE: Initializing Cirq Grid Qubits\nDESCRIPTION: This snippet imports the Cirq and Cirq-Google libraries and initializes a rectangular grid of qubits using `cirq.GridQubit.rect`. This creates a set of qubits arranged in a 3x2 grid, which are essential for building quantum circuits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_volume.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport cirq_google\nqubits = cirq.GridQubit.rect(3,2)\nqubits\n```\n\n----------------------------------------\n\nTITLE: Running a Parameterized Circuit Sweep with RigettiQCSSampler\nDESCRIPTION: This code snippet runs a parameterized circuit sweep using the `RigettiQCSSampler`. It executes the previously defined parameterized circuit for a range of parameter values defined by `cirq.Linspace`. The results are then organized into a Pandas DataFrame for easy analysis, showing the measurement outcomes for each parameter value.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/rigetti/getting_started.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\n\nresults = sampler.run_sweep(circuit, params, repetitions=10)\ndata = {f't={result.params[\"t\"]}': [measurement[0] for measurement in result.measurements['m']] for result in results}\n\npd.DataFrame(data)\n```\n\n----------------------------------------\n\nTITLE: Estimating Probability through Repetitions\nDESCRIPTION: This code demonstrates how to estimate the probability of measuring the |0> state by running the circuit multiple times and calculating the frequency of the |0> state. It then decides if the input functions are forrelated based on the measured probability.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nrepetitions = 100\nobs = s.run(circuit, repetitions=repetitions)\nqubits_name = ','.join(str(q) for q in qubits)\ntimes_zero_was_measured = len(obs.data[obs.data[qubits_name] == 0])\nprint(\n    f\"times zero state was measured from {repetitions} measurements:\" +\n    f\"{times_zero_was_measured} - {float(times_zero_was_measured/repetitions)*100}%\"\n)\nif float(times_zero_was_measured / repetitions) > 0.05:\n    print(\"fs and gs is forrelated!\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Tilted Square Lattice Topology in Cirq\nDESCRIPTION: This code creates a `cirq.TiltedSquareLattice` topology representing the arrangement of qubits. It then visualizes this topology using `cirq.draw_gridlike` to display the qubit arrangement.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/qubit-placement.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntopo = cirq.TiltedSquareLattice(3, 2)\n_ = cirq.draw_gridlike(topo.graph, tilted=False)\n```\n\n----------------------------------------\n\nTITLE: Hello Qubit Example\nDESCRIPTION: A simple example of running a circuit on a quantum processor, demonstrating qubit definition, circuit creation, sampling, and result printing.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/start.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport cirq_google as cg\n\ndef example(engine, processor_id):\n    \"\"\"Hello qubit example run against a quantum processor.\"\"\"\n\n    # Define a qubit on the device.\n    processor = engine.get_processor(processor_id)\n    qubit = sorted(processor.get_device().metadata.qubit_set)[0]\n\n    # Create a circuit (qubits start in the |0> state).\n    circuit = cirq.Circuit(\n        cirq.X(qubit)**0.5,                # Square root of NOT.\n        cirq.measure(qubit, key='result')  # Measurement.\n    )\n\n    sampler = processor.get_sampler()\n    print(\"Sampling circuit on Quantum Engine...\\n\")\n    results = sampler.run(circuit, repetitions=1000)\n\n    print(\"\\nMeasurement results:\")\n    print(results)\n\nif __name__ == '__main__':\n    # Set up QCS objects.\n    from cirq_google.engine.qcs_notebook import get_qcs_objects_for_notebook\n    qcs_objects = get_qcs_objects_for_notebook(project_id='')\n    processor_id = qcs_objects.processor_id\n    engine = qcs_objects.engine\n\n    example(engine, processor_id)\n```\n\n----------------------------------------\n\nTITLE: Displaying More Single Qubit Gates in Cirq\nDESCRIPTION: This snippet uses the display_gates function to display documentation for the single qubit gates PhasedXPowGate, PhasedXZGate, and HPowGate. The display_gates function retrieves each gate from the cirq module and displays its docstring using IPython.display.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndisplay_gates(\"PhasedXPowGate\", \"PhasedXZGate\", \"HPowGate\")\n```\n\n----------------------------------------\n\nTITLE: Simulating a Processor with Device Record in Cirq\nDESCRIPTION: This snippet retrieves a simulated processor device and its connectivity graph. It initializes a `SimulatedProcessorWithLocalDeviceRecord` and then obtains the device and its corresponding networkx graph representing qubit connectivity, which is visualized using `cirq.draw_gridlike`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/qubit-placement.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq_google.workflow import SimulatedProcessorWithLocalDeviceRecord\nrainbow_record = SimulatedProcessorWithLocalDeviceRecord('rainbow')\nrainbow_device = rainbow_record.get_device()\nrainbow_graph = rainbow_device.metadata.nx_graph\n\n_ = cirq.draw_gridlike(rainbow_graph, tilted=False)\n```\n\n----------------------------------------\n\nTITLE: Running Parallel XEB with Cirq\nDESCRIPTION: This code snippet demonstrates how to run parallel two-qubit XEB using `cirq.experiments.parallel_two_qubit_xeb`. It sets up a simulation with a depolarizing noise model and then calls the function to perform the XEB experiment. The `sampler` parameter specifies the simulator or a ProcessorSampler, and `qubits` specifies the qubits to be used in the experiment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Simulation\nqubits = cirq.GridQubit.rect(3, 2, 4, 3)\nresult = cirq.experiments.parallel_two_qubit_xeb(\n    sampler=cirq.DensityMatrixSimulator(noise=cirq.depolarize(5e-3), dtype=np.complex128),  # Any simulator or a ProcessorSampler.\n    qubits=qubits\n)\n```\n\n----------------------------------------\n\nTITLE: Running Stabilizer Circuit Simulation in Cirq\nDESCRIPTION: This snippet runs a pre-optimized stabilizer circuit (`test_stabilizer_circuit`) using a quantum simulator (`sim_engine`). It specifies the number of repetitions for the simulation and measures the elapsed time. The `get_sampler` method retrieves a sampler for a specific processor ID, and the `run` method executes the simulation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Run for 1k repetitions.\nrepetitions = 1000\nstart = time.time()\nresults = sim_engine.get_sampler(processor_id).run(test_stabilizer_circuit, repetitions=repetitions)\nelapsed = time.time() - start\nprint(f'{repetitions} repetitions completed in {elapsed:.03f}s')\n```\n\n----------------------------------------\n\nTITLE: Grover's Algorithm Implementation for Pasqal using Cirq\nDESCRIPTION: This code implements Grover's algorithm using Cirq, targeting Pasqal devices. It defines functions for state preparation, oracle implementation, and the Grover diffusion operator. It generates a circuit, optimizes it for the Pasqal gateset, validates it against a virtual device, and adds a measurement.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/pasqal/getting_started.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\n#Place qubits at vertices of an equilateral triangle\nqs = [TwoDQubit(0, 0), TwoDQubit(1, 0), TwoDQubit(0.5, np.sqrt(3)/2)]\nq_meas = [TwoDQubit(1, 0), TwoDQubit(0, 0)]\n\ndef state_preparation():\n    for q in qs[:-1]:\n        yield cirq.H(q)\n    yield cirq.X(qs[-1])\n    yield cirq.H(qs[-1])\n\ndef oracle():\n    # Signals the state 10\n    yield cirq.X(qs[0])\n    yield cirq.CCX(*qs)\n    yield cirq.X(qs[0])\n\ndef grover_operator():\n    for q in qs[:-1]:\n        yield cirq.H(q)\n        yield cirq.X(q)\n\n    yield cirq.CZ(*qs[:-1])\n\n    for q in qs[:-1]:\n        yield cirq.X(q)\n        yield cirq.H(q)\n        \ndef generate_grover():\n    yield state_preparation()\n    yield oracle()\n    yield grover_operator()\n        \ndef generate_pasqal_grover():\n    pasqal_gateset=cirq_pasqal.PasqalGateset(include_additional_controlled_ops=False)\n    grover_cicruit = cirq.optimize_for_target_gateset(cirq.Circuit(generate_grover()),\n                                                      gateset=pasqal_gateset)\n    return cirq.Circuit(grover_cicruit.all_operations(),\n                        strategy=cirq.InsertStrategy.NEW)\n    \ndevice = PasqalVirtualDevice(control_radius=1.1, qubits=qs)        \ngrover_circuit = generate_pasqal_grover()\ndevice.validate_circuit(grover_circuit)\ngrover_circuit.append(cirq.measure(*q_meas, key='x'))\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Gate in a Cirq Circuit\nDESCRIPTION: This code snippet demonstrates how to use a custom gate, `RationalGate`, within a Cirq circuit. It initializes a named qubit, creates an instance of the custom gate, applies the gate to the qubit, and then prints the resulting quantum circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_50\n\nLANGUAGE: python\nCODE:\n```\na = cirq.NamedQubit('a')\nrg = RationalGate()\nprint(cirq.Circuit(rg(a)))\n```\n\n----------------------------------------\n\nTITLE: Defining FSim Gate Set in Cirq\nDESCRIPTION: This snippet defines the 'fsim' gate set in Cirq, including the 'fsim', 'xy', 'z', 'xyz', 'meas', 'wait', and 'circuit' gates.  The 'fsim' gate requires arguments like 'theta', 'phi', and 'phase_match'. It configures a gate set used with the FSim gate.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-google/cirq_google/devices/specifications/weber_2021_12_10_device_spec.proto.txt#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nvalid_gate_sets {\n  name: \"fsim\"\n  valid_gates {\n    id: \"fsim\"\n    number_of_qubits: 2\n    valid_args {\n      name: \"theta\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"phi\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"phase_match\"\n      type: STRING\n    }\n    valid_targets: \"2_qubit_targets\"\n  }\n  valid_gates {\n    id: \"xy\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"axis_half_turns\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"half_turns\"\n      type: FLOAT\n    }\n    gate_duration_picos: 25000\n  }\n  valid_gates {\n    id: \"z\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"half_turns\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"type\"\n      type: STRING\n    }\n  }\n  valid_gates {\n    id: \"xyz\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"x_exponent\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"z_exponent\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"axis_phase_exponent\"\n      type: FLOAT\n    }\n    gate_duration_picos: 25000\n  }\n  valid_gates {\n    id: \"meas\"\n    valid_args {\n      name: \"key\"\n      type: STRING\n    }\n    valid_args {\n      name: \"invert_mask\"\n      type: REPEATED_BOOLEAN\n    }\n    gate_duration_picos: 4000000\n    valid_targets: \"meas_targets\"\n  }\n  valid_gates {\n    id: \"wait\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"nanos\"\n      type: FLOAT\n    }\n  }\n  valid_gates {\n    id: \"circuit\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initialize Multiprocessing Pool, Python\nDESCRIPTION: This code initializes a multiprocessing pool using the 'spawn' context. This allows for parallel execution of tasks, which can significantly speed up computations, particularly when dealing with large datasets or computationally intensive operations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nimport multiprocessing\n\npool = multiprocessing.get_context('spawn').Pool()\n```\n\n----------------------------------------\n\nTITLE: Checking Job Status\nDESCRIPTION: This snippet retrieves and prints the status of a given job. It uses the `status` method of the job object to get the current status of the job, such as 'queued', 'running', or 'completed'.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/getting_started.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nprint(f'Status: {job.status()}')\n```\n\n----------------------------------------\n\nTITLE: Accessing Device Metadata in Cirq\nDESCRIPTION: This code snippet demonstrates how to access the metadata of the Sycamore device using the `metadata` attribute. It prints the type of the metadata object, which is a subclass of `cirq.DeviceMetadata`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/devices.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nmetadata = my_device.metadata\nprint(type(metadata))\n```\n\n----------------------------------------\n\nTITLE: Calculating Estimated Time of Tensor Contraction\nDESCRIPTION: This code estimates the time required for the tensor network contraction, assuming a processing rate of 3 gigaflops (3e9 floating-point operations per second). It accesses the `opt_cost` attribute from the `path_info` object and divides it by the assumed gigaflops rate.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\npath_info.opt_cost / int(3e9) # assuming 3gflop, in seconds\n```\n\n----------------------------------------\n\nTITLE: Parameterizing Quantum Circuit with Sympy Symbols in Cirq\nDESCRIPTION: This code demonstrates how to parameterize a quantum circuit in Cirq using `sympy.Symbol`. It defines three symbols (`alpha`, `beta`, `gamma`) and uses them as parameters for the `one_step` function. The resulting parameterized circuit is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/variational_algorithm.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\ncircuit = cirq.Circuit()\nalpha = sympy.Symbol('alpha')\nbeta = sympy.Symbol('beta')\ngamma = sympy.Symbol('gamma')\ncircuit.append(initial_step(len(h)))\ncircuit.append(one_step(h, jr, jc, alpha, beta, gamma))\ncircuit.append(cirq.measure(*qubits, key='x'))\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Circuit Output with State Histogram in Python\nDESCRIPTION: This code snippet demonstrates how to visualize the output of a quantum circuit using a state histogram. It uses `cirq.plot_state_histogram` to plot the histogram of the measured results. The plot's axes are then configured to remove the ticks and the plot is displayed using `matplotlib.pyplot`. Requires the `cirq` and `matplotlib.pyplot` modules to be imported.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_basic_example.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nax = cirq.plot_state_histogram(results.histogram(key='out'))\nax.get_xaxis().set_ticks([])\nplt.gcf().set_size_inches(10, 4)\nplt.show(ax)\n```\n\n----------------------------------------\n\nTITLE: Conditional Z Rotation Layer in Cirq\nDESCRIPTION: This function applies Z rotations conditioned on the values in the field `h`. It iterates through the `h` array, and if `h_ij` is 1, it applies a `cirq.ZPowGate` with the specified `half_turns` exponent to the corresponding `cirq.GridQubit(i, j)`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/variational_algorithm.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef rot_z_layer(h, half_turns):\n    \"\"\"Yields Z rotations by half_turns conditioned on the field h.\"\"\"\n    gate = cirq.ZPowGate(exponent=half_turns)\n    for i, h_row in enumerate(h):\n        for j, h_ij in enumerate(h_row):\n            if h_ij == 1:\n                yield gate(cirq.GridQubit(i, j))\n```\n\n----------------------------------------\n\nTITLE: Creating a Cirq circuit with unitary, noisy channel and measurement\nDESCRIPTION: This code creates a `cirq.Circuit` containing a Hadamard gate, a depolarizing channel, and a measurement gate acting on the same qubit.  The resulting circuit is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/operators.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit(\n    cirq.H(qubit),\n    cirq.depolarize(p=0.01).on(qubit),\n    cirq.measure(qubit)\n)\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Importing Cirq and Dependencies in Python\nDESCRIPTION: This code snippet checks if the Cirq library is installed. If not, it installs Cirq using pip and then imports the necessary modules, including `cirq` and `cirq_google`. It sets up the environment to work with Cirq and Cirq-Google functionalities.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/virtual_engine_interface.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n\nimport cirq_google\nimport sympy\n```\n\n----------------------------------------\n\nTITLE: Creating TwoDQubits for Pasqal\nDESCRIPTION: This code creates a 6x6 square array of `TwoDQubit` objects. The `TwoDQubit` class represents a qubit positioned in 2D space and is equivalent to a `ThreeDQubit` with a fixed z-coordinate of 0. This snippet demonstrates a concise way to create a grid of qubits using the `square` method of the `TwoDQubit` class.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/pasqal/getting_started.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\np_qubits = TwoDQubit.square(6)    # 6x6 square array of TwoDQubits\n```\n\n----------------------------------------\n\nTITLE: Analyzing Fidelity Change After Characterization\nDESCRIPTION: This snippet uses `cirq.experiments.xeb_fitting.before_and_after_characterization` to compare the fidelities before and after the parameter characterization process. The function combines the initial fidelity data (`fids`) with the characterization results to produce a DataFrame (`before_after_df`) showing the impact of parameter optimization on circuit fidelity.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/isolated_xeb.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.experiments.xeb_fitting import before_and_after_characterization\nbefore_after_df = before_and_after_characterization(fids, characterization_result)\nbefore_after_df\n```\n\n----------------------------------------\n\nTITLE: Classical Control with CircuitOperation and Variable Scope\nDESCRIPTION: Illustrates how classical controls interact with `CircuitOperation` for creating local variable scopes within a circuit in Cirq. The example demonstrates that measurement keys inside a subcircuit are distinct from those outside, even if they have the same name.  The `FrozenCircuit` ensures the subcircuit is immutable.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/classical_control.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nq0 = cirq.LineQubit(0)\nsubcircuit = cirq.FrozenCircuit(cirq.measure(q0, key='a'), cirq.X(q0).with_classical_controls('a'))\ncircuit = cirq.Circuit(\n    cirq.measure(q0, key='a'),\n    cirq.CircuitOperation(subcircuit, repetitions=2),\n    cirq.X(q0).with_classical_controls('a'),\n)\nprint(\"Original Circuit\")\nprint(circuit)\nprint(\"Circuit with nested circuit unrolled.\")\nprint(cirq.CircuitOperation(cirq.FrozenCircuit(circuit)).mapped_circuit(deep=True))\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq in Python\nDESCRIPTION: This code snippet attempts to import the `cirq` library and installs it if it's not already present. It uses `pip` to install `cirq` and then imports the library.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/qubit-placement.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n```\n\n----------------------------------------\n\nTITLE: Map Transformed Circuit to Device Qubits in Python\nDESCRIPTION: This code snippet maps the transformed GHZ circuit to a chosen line of qubits on the device. It creates a dictionary to map the circuit's qubits to the device qubits and then uses the `transform_qubits` function to replace the qubits in the circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_basic_example.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Map the line of circuit qubits to the chosen line of device qubits.\nqubit_map = dict(zip(qubits, device_qubit_chain))\n# Then replace qubits in the circuit according to that map.\ndevice_ready_ghz_circuit = translated_ghz_circuit.transform_qubits(lambda q: qubit_map[q])\nprint(device_ready_ghz_circuit)\n```\n\n----------------------------------------\n\nTITLE: Quantum Volume Calculation with Cirq\nDESCRIPTION: This snippet calculates the quantum volume using the Cirq library. It generates a set of error rates, creates density matrix simulators with corresponding noise models, optimizes the circuit for a specific target gate set, and then calculates the quantum volume based on the specified parameters.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_volume_errors.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nfrom cirq.contrib import quantum_volume, routing\n\nerrors = np.logspace(-1, -4, num=num_samplers)\nsamplers = [\n        cirq.DensityMatrixSimulator(noise=cirq.ConstantQubitNoiseModel(\n        qubit_noise_gate=cirq.DepolarizingChannel(p=error)))\n    for error in errors]\n\ndef optimize(circuit):\n    return cirq.optimize_for_target_gateset(circuit, gateset=cirq.SqrtIswapTargetGateset())\n\nresult = quantum_volume.calculate_quantum_volume(\n    num_circuits=num_circuits,\n    depth=depth,\n    num_qubits=depth,\n    device_graph=routing.gridqubits_to_graph_device(device.metadata.qubit_set),\n    samplers=samplers,\n    compiler=optimize,\n    repetitions=repetitions)\n```\n\n----------------------------------------\n\nTITLE: Plotting with Single Axes in Cirq using Matplotlib\nDESCRIPTION: This code snippet demonstrates the recommended implementation of a `plot` method that can operate in both memory and interactive modes. It takes an optional `ax` argument of type `plt.Axes`. If `ax` is not provided, it creates a new figure and axes. The code includes logic to conditionally display the plot using `fig.show()` in interactive mode and returns the `ax` instance for customization.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/plotting.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any, List, Optional\nimport matplotlib.pyplot as plt\n\nclass Foo:\n    ...\n    def plot(self, ax: Optional[plt.Axes]=None, **plot_kwargs: Any) -> plt.Axes:\n        show_plot = not ax\n        if ax is None:\n            fig, ax = plt.subplots(1, 1)  # or your favorite figure setup\n        # Call methods of the ax instance like ax.plot to plot on it.\n        ...\n        if show_plot:\n            fig.show()\n        return ax\n```\n\n----------------------------------------\n\nTITLE: Visualizing Cirq Circuit in 3D with Custom Symbol Resolver\nDESCRIPTION: This snippet builds a 3D circuit diagram from a Cirq circuit using `cirq_web`. It defines a custom symbol resolver `FunkyHadamard` that overrides the symbol for Hadamard gates. A `Circuit3D` object is instantiated and displayed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-web/circuit_example.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport cirq_web\nfrom typing import Optional\nfrom cirq_web.circuits.symbols import SymbolInfo\n\nclass FunkyHadamard(cirq_web.circuits.symbols.SymbolResolver):\n    def resolve(self, operation: cirq.Operation) -> Optional[SymbolInfo]:\n        if isinstance(operation.gate, cirq.HPowGate):\n            return SymbolInfo(['Hello!'], ['yellow'])\n        else:\n            return None\n        \nresolvers = list(cirq_web.circuits.symbols.DEFAULT_SYMBOL_RESOLVERS) + [\n    FunkyHadamard()\n]\n\nfrom cirq_web import Circuit3D\nc3d = Circuit3D(circuit, resolvers, 2.5)\ndisplay(c3d)\n```\n\n----------------------------------------\n\nTITLE: Creating Heatmap of Measurement Results in Cirq\nDESCRIPTION: This snippet creates a heatmap visualizing the measurement results. It calculates the frequency of $|1\\rangle$ measurements for both measurement and data qubits and stores them in dictionaries. These dictionaries are then combined into a `cirq.Heatmap` object, which is plotted to show the relative frequency of each qubit measuring $|1\\rangle$.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nmeas_map = {qubit_map[measure_qubit]: sum(results.measurements['meas']) / repetitions}\n\ndata_map = {\n    qubit_map[dq]: sum(results.measurements[str(dq)[-1]]) / repetitions for dq in data_qubits\n}\n\nheatmap = cirq.Heatmap({**meas_map, **data_map})\nheatmap.plot()\n```\n\n----------------------------------------\n\nTITLE: Defining Two-Bit Boolean Functions in Cirq\nDESCRIPTION: This code defines qubits and quantum operations representing constant and balanced boolean functions with two input bits. It uses CNOT and X gates to implement these functions on the third qubit. The `constant` and `balanced` tuples contain lists of Cirq operations corresponding to the different functions.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_39\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Operations to query all possible functions on two bits.\nTwo of these functions are constant, and six of these functions are balanced.\n\"\"\"\n# Define three qubits to use.\nq0, q1, q2 = cirq.LineQubit.range(3)\n\n# Define the operations to query each of the two constant functions.\nconstant = ([], [cirq.X(q2)])\n\n# Define the operations to query each of the six balanced functions.\nbalanced = (\n    [cirq.CNOT(q0, q2)],\n    [cirq.CNOT(q1, q2)],\n    [cirq.CNOT(q0, q2), cirq.CNOT(q1, q2)],\n    [cirq.CNOT(q0, q2), cirq.X(q2)],\n    [cirq.CNOT(q1, q2), cirq.X(q2)],\n    [cirq.CNOT(q0, q2), cirq.CNOT(q1, q2), cirq.X(q2)],\n)\n```\n\n----------------------------------------\n\nTITLE: Convert Quirk JSON to Cirq Circuit (Python)\nDESCRIPTION: This snippet shows how to convert a quantum circuit represented in Quirk JSON format to a Cirq circuit using the `cirq.quirk_json_to_circuit` function.  It first imports the `json` library to parse the JSON string into a Python dictionary.  The dictionary is then passed to `cirq.quirk_json_to_circuit` to create the Cirq circuit, which is subsequently printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/interop.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nquirk_str=\"\"\"{\n  \"cols\": [\n    [\n      \"H\",\n      \"H\"\n    ],\n    [\n      \"•\",\n      \"X\"\n    ],\n    [\n      \"H\",\n      \"H\"\n    ]\n  ]\n}\"\"\"\nquirk_json=json.loads(quirk_str)\nc= cirq.quirk_json_to_circuit(quirk_json)\n\nprint(c)\n```\n\n----------------------------------------\n\nTITLE: Circuit Initialization with rot_x_layer in Cirq\nDESCRIPTION: This code snippet initializes a quantum circuit using Cirq and appends a layer of X rotations (rot_x_layer) to it. It assumes that `rot_x_layer` function is defined elsewhere and takes the number of qubits and a rotation angle as input. The resulting circuit is then printed to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/variational_algorithm.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit()\ncircuit.append(rot_x_layer(2, 0.1))\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Inconsistent Gate Implementation - Python\nDESCRIPTION: This code snippet showcases an example of an inconsistent gate implementation for testing purposes using the `cirq.testing` package. The `InconsistentXGate` class attempts to implement an X gate but incorrectly defines its unitary matrix and decomposition, resulting in a Y gate instead. This allows `cirq.testing.assert_decompose_is_consistent_with_unitary` to detect the inconsistency.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_87\n\nLANGUAGE: python\nCODE:\n```\nclass InconsistentXGate(cirq.Gate):\n    def _num_qubits_(self) -> int:\n        return 1\n\n    def _decompose_(self, qubits):\n        yield cirq.H(qubits[0])\n        yield cirq.Z(qubits[0])\n        yield cirq.H(qubits[0])\n\n    def _unitary_(self):\n        return np.array([[0, -1j], [1j, 0]])  # Oops! Y instead of X!\n\n\n# cirq.testing.assert_decompose_is_consistent_with_unitary(InconsistentXGate())\n```\n\n----------------------------------------\n\nTITLE: CZ Target Conversion Transformer\nDESCRIPTION: This code defines a transformer that converts a given circuit into one that uses CZ gates and single-qubit rotations. It utilizes analytical decomposition methods and transformer primitives for recursive execution and ignore tagging. The transformer decomposes only operations on one or two qubits, serving as an example of transformer usage with analytical decomposition.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/custom_transformers.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@cirq.transformer\ndef convert_to_cz_target(circuit, *, context=None, atol=1e-8, allow_partial_czs=True):\n    \"\"\"Transformer to rewrite the given circuit using CZs + 1-qubit rotations.\n\n    Note that the transformer decomposes only operations on <= 2-qubits and is\n    presented as an illustration of using transformer primitives + analytical\n    decomposition methods.\n    \"\"\"\n\n    def map_func(op: cirq.Operation, _) -> cirq.OP_TREE:\n        if not (cirq.has_unitary(op) and cirq.num_qubits(op) <= 2):\n            return op\n        matrix = cirq.unitary(op)\n        qubits = op.qubits\n        if cirq.num_qubits(op) == 1:\n            g = cirq.single_qubit_matrix_to_phxz(matrix)\n            return g.on(*qubits) if g else []\n        return cirq.two_qubit_matrix_to_cz_operations(\n            *qubits, matrix, allow_partial_czs=allow_partial_czs, atol=atol\n        )\n\n    return cirq.map_operations_and_unroll(\n        circuit,\n        map_func,\n        deep=context.deep if context else False,\n        tags_to_ignore=context.tags_to_ignore if context else (),\n    )\n\n```\n\n----------------------------------------\n\nTITLE: Printing Gateset from Device Metadata in Cirq\nDESCRIPTION: This code snippet retrieves and prints the `gateset` from the device metadata. The `gateset` indicates what types and families of Cirq gates that are accepted by all qubits across the device.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/devices.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nprint(metadata.gateset)\n```\n\n----------------------------------------\n\nTITLE: Importing Modules (Cirq, Numpy, Pandas)\nDESCRIPTION: This snippet imports modules required for quantum circuit handling, numerical computation, data manipulation, and circuit visualization. Specifically, it imports `cirq` for defining quantum circuits and operations, `numpy` for numerical calculations, `pandas` for data analysis using dataframes, and `SVGCircuit` from `cirq.contrib.svg` for displaying the circuit diagrams.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Cirq-to-Tensor-Networks.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport numpy as np\nimport pandas as pd\nfrom cirq.contrib.svg import SVGCircuit\n```\n\n----------------------------------------\n\nTITLE: Creating Heatmap of Noiseless Simulation Results in Cirq\nDESCRIPTION: This snippet generates a heatmap from the results of a noiseless simulation.  It extracts the measurement data for both measurement and data qubits for a specific repetition and then plots it using `cirq.Heatmap`. This visualizes the measurement outcomes across the qubit grid.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# Set to view results from each repetition.\nrepetition = 0  # @param {type:\"number\"}\nmeas_map = {\n    qubit_map[q]: results.measurements[str(q)][repetition] for q in grid_meas_qubits.values()\n}\n\ndata_map = {\n    qubit_map[q]: results.measurements[str(q)][repetition] for q in grid_data_qubits.values()\n}\n\nheatmap = cirq.Heatmap({**meas_map, **data_map})\nheatmap.plot()\n```\n\n----------------------------------------\n\nTITLE: PauliSumExponential Power Operations in Cirq\nDESCRIPTION: Demonstrates taking powers of `PauliSumExponential`s to multiply the exponent. It illustrates the usage of the exponentiation operator on PauliSumExponentials.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ntyprint(cirq.PauliSumExponential(Xa * Zb, exponent=3))\ntyprint(cirq.PauliSumExponential(Xa * Zb, exponent=3) ** 5)\n```\n\n----------------------------------------\n\nTITLE: Appending operations with InsertStrategy.EARLIEST\nDESCRIPTION: This snippet demonstrates the `InsertStrategy.EARLIEST` strategy when appending operations to a Cirq circuit. It initializes a circuit, appends a CZ gate, and then appends Hadamard gates. The `InsertStrategy.EARLIEST` allows the H gate on qubit `c` to slide back to the first moment because it does not conflict with any prior operations, while H gates on qubits `a` and `b` stay in the second moment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Appending operations with InsertStrategy.EARLIEST.\"\"\"\n# Create an empty circuit.\ncircuit = cirq.Circuit()\n\n# Append an operation.\n# Note: InsertStrategy.EARLIEST is used by default if not otherwise specified.\ncircuit.append([cirq.CZ(a, b)])\n\n# Append more operations.\n# Note: InsertStrategy.EARLIEST is used by default if not otherwise specified.\ncircuit.append([cirq.H(a), cirq.H(b), cirq.H(c)])\n\n# Display the circuit.\nprint(\"Circuit:\\n\")\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Serializing a Cirq object to a file\nDESCRIPTION: This code snippet shows how to serialize a Cirq object to a file using the `cirq.to_json` function. It assumes that the `filepath` variable has been defined previously with a path to store the JSON data.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/serialization.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncirq.to_json(obj, filepath)\n```\n\n----------------------------------------\n\nTITLE: Plotting Two-Qubit Gate FSim Error in Cirq\nDESCRIPTION: This code snippet retrieves and plots the two-qubit gate FSim error data from the `noise_props.fsim_errors` attribute. It iterates through supported two-qubit gates, filters for each gate type, calculates the norm of the FSim gate parameters, and visualizes the error for each qubit pair using `cirq.TwoQubitInteractionHeatmap`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/qubit_picking.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint(f\"Two qubit error data: fsim_errors\")\ntwo_qubit_gates = noise_props.two_qubit_gates()\nfig, axes = plt.subplots(1, 2, figsize=(20, 10))\naxes = iter(axes)\nfor gate in two_qubit_gates:\n    measures = {\n        op_id.qubits: fsim_refit_gate\n        for op_id, fsim_refit_gate in noise_props.fsim_errors.items()\n        if op_id.gate_type == gate\n    }\n    if measures:\n        ax = next(axes)\n        # Norm the Fsim refit gate parameters as an approximate of how good a qubit is.\n        measures = {\n            qubits: np.linalg.norm([fsim_refit_gate.theta, fsim_refit_gate.phi])\n            for qubits, fsim_refit_gate in measures.items()\n        }\n        ax.set_title(f\"{gate.__name__} Pauli error\")\n        _ = cirq.TwoQubitInteractionHeatmap(measures).plot(ax)\n\nfig.show()\n```\n\n----------------------------------------\n\nTITLE: Classical Control with BitMaskKeyCondition in Cirq\nDESCRIPTION: This snippet showcases the use of `BitMaskKeyCondition` in Cirq. It creates a circuit where an X gate is applied to qubit 5 only if the bits corresponding to qubits 1, 2, and 4 are 1 (i.e., (measurement result & 13) == 13).  The circuit is simulated and measurement data is printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/classical_control.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nqs = cirq.LineQubit.range(5)\ncond = cirq.BitMaskKeyCondition.create_equal_mask('q_{0..4}', bitmask=13)\ncircuit = cirq.Circuit(\n    cirq.H.on_each(qs),\n    cirq.measure(qs, key='q_{0..4}'),\n    cirq.X(cirq.q(5)).with_classical_controls(cond),\n    cirq.measure(cirq.q(5), key='q_5'),\n)\ncircuit\nprint(cirq.Simulator().run(circuit, repetitions=2**5).data)\n```\n\n----------------------------------------\n\nTITLE: Converting Kraus operators to superoperator representation\nDESCRIPTION: This code snippet demonstrates how to convert a set of Kraus operators into the superoperator representation using `cirq.kraus_to_superoperator`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/operators.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nsuper_rep = cirq.kraus_to_superoperator(kraus_rep)\nprint(super_rep)\n```\n\n----------------------------------------\n\nTITLE: Generating Random Circuits with Cirq in Python\nDESCRIPTION: This snippet generates a library of 20 random two-qubit circuits using `cirq.SQRT_ISWAP` as the entangling gate.  It utilizes `cirq.experiments.random_quantum_circuit_generation.generate_library_of_2q_circuits` to achieve this. `RANDOM_SEED` ensures reproducibility.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.experiments import random_quantum_circuit_generation as rqcg\n\nRANDOM_SEED = np.random.RandomState(53)\n\ncircuit_library = rqcg.generate_library_of_2q_circuits(\n    n_library_circuits=20, two_qubit_gate=cirq.SQRT_ISWAP, random_state=RANDOM_SEED\n)\nmax_depth = 100\ncycle_depths = np.arange(3, max_depth, 20)\n```\n\n----------------------------------------\n\nTITLE: Deserializing a Cirq object from a file\nDESCRIPTION: This code snippet demonstrates how to deserialize a Cirq object from a file using the `cirq.read_json` function.  It assumes that the `filepath` variable has been defined previously with a path from which to read the JSON data.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/serialization.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nobj = cirq.read_json(filepath)\n```\n\n----------------------------------------\n\nTITLE: Setting up Shared Runtime Information in Cirq\nDESCRIPTION: This code sets up shared runtime information required for the qubit placement process, including a run ID and the device.  This information provides context for qubit placers.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/qubit-placement.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# set up some other required arguments.\n# In a real `cirq_google.workflow.execute()` run, these will be\n# handled for you.\n\nfrom cirq_google.workflow import SharedRuntimeInfo\nshared_rt_info = SharedRuntimeInfo(run_id='example', device=rainbow_device)\n\nrs = np.random.RandomState(10)\n```\n\n----------------------------------------\n\nTITLE: Defining Qubits and ZZ Interactions using Cirq\nDESCRIPTION: This snippet defines the qubits for the quantum circuit and constructs the ZZ interactions. It creates a grid of qubits using `cirq.NamedQubit`. It also defines the ZZ(-pi/2) gate and constructs three moments (`zz_layer_1`, `zz_layer_2`, `zz_layer_3`) representing ZZ interactions along different edges of the qubit arrangement. The qubit layout and ZZ interactions are based on the experiment described in the linked paper.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_utility_sim_4b.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# These 28 qubits construct the three \"bricks\" around qubit 62:\n#\n#           41-42-43-44-45\n#           |           |\n#           53          54\n#           |           |\n#     58-59-60-61-62-63-64-65-66\n#     |           |           |\n#     71          72          73\n#     |           |\n#     77-78-79-80-81-82-83-84-85\n#\nqubit_ids = [\n    *range(41, 46),  # row 0\n    *range(53, 55),  # row 1\n    *range(58, 67),  # row 2\n    *range(71, 74),  # row 3\n    *range(77, 86),  # row 4\n]\nq = {i: cirq.NamedQubit(f'q{i}') for i in qubit_ids}\nqubits = list(q.values())\n\n# This parameter will be used to sweep over X rotation angles.\ntheta = sympy.Symbol('theta')\nx_rotations = cirq.Moment(cirq.rx(theta).on_each(qubits))\n\n# This is the ZZ(-pi/2) gate described in equation (2).\nzz_pi_2 = cirq.ZZ ** -0.5\n\n# Each of these moments performs ZZ interactions along\n# 1/3 of the edges in the region, corresponding to the\n# red, blue, and green edges in Fig. 1b.\nzz_layer_1 = cirq.Moment(\n    zz_pi_2(q[41], q[53]),\n    zz_pi_2(q[43], q[44]),\n    zz_pi_2(q[58], q[71]),\n    zz_pi_2(q[59], q[60]),\n    zz_pi_2(q[61], q[62]),\n    zz_pi_2(q[63], q[64]),\n    zz_pi_2(q[72], q[81]),\n    zz_pi_2(q[73], q[85]),\n    zz_pi_2(q[78], q[79]),\n    zz_pi_2(q[83], q[84]),\n)\nzz_layer_2 = cirq.Moment(\n    zz_pi_2(q[42], q[43]),\n    zz_pi_2(q[44], q[45]),\n    zz_pi_2(q[53], q[60]),\n    zz_pi_2(q[54], q[64]),\n    zz_pi_2(q[62], q[63]),\n    zz_pi_2(q[65], q[66]),\n    zz_pi_2(q[71], q[77]),\n    zz_pi_2(q[79], q[80]),\n    zz_pi_2(q[81], q[82]),\n    zz_pi_2(q[84], q[85]),\n)\nzz_layer_3 = cirq.Moment(\n    zz_pi_2(q[41], q[42]),\n    zz_pi_2(q[45], q[54]),\n    zz_pi_2(q[58], q[59]),\n    zz_pi_2(q[60], q[61]),\n    zz_pi_2(q[62], q[72]),\n    zz_pi_2(q[64], q[65]),\n    zz_pi_2(q[66], q[73]),\n    zz_pi_2(q[77], q[78]),\n    zz_pi_2(q[80], q[81]),\n    zz_pi_2(q[82], q[83]),\n)\n\n# This circuit encapsulates a single \"step\", as shown\n# in Fig. 1a.\nstep = cirq.FrozenCircuit(\n    x_rotations,\n    zz_layer_1,\n    zz_layer_2,\n    zz_layer_3,\n)\n# Uncomment this line to print the circuit diagram for\n# a single step of the circuit.\n# print(step)\n```\n\n----------------------------------------\n\nTITLE: Creating a Parameterized Circuit in Cirq\nDESCRIPTION: This code snippet creates a parameterized quantum circuit in Cirq. It defines a single qubit, creates a circuit with a Hadamard gate raised to a symbolic power 't', and then measures the qubit. The 't' parameter is a `sympy.Symbol`, and a `cirq.Linspace` is used to define a set of parameter values for a sweep.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/rigetti/getting_started.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nqubit = cirq.LineQubit.range(1)[0]\n\ncircuit = cirq.Circuit(\n    cirq.H(qubit)**sympy.Symbol('t'),\n    cirq.measure(qubit, key='m'))\nparams = cirq.Linspace('t', start=0, stop=4, length=5)\n\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Qutrit Gate in Cirq\nDESCRIPTION: This code defines a custom gate called `QutritPlusGate` that acts on a qutrit (a 3-level quantum system). It implements the `_qid_shape_` method to specify the gate's dimension, the `_unitary_` method to define its unitary matrix, and the `_circuit_diagram_info_` method to customize its representation in circuit diagrams.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/qudits.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport numpy as np\n\nclass QutritPlusGate(cirq.Gate):\n    \"\"\"A gate that adds one in the computational basis of a qutrit.\n    \n    This gate acts on three-level systems. In the computational basis of\n    this system it enacts the transformation U|x〉 = |x + 1 mod 3〉, or\n    in other words U|0〉 = |1〉, U|1〉 = |2〉, and U|2> = |0〉.\n    \"\"\"\n    \n    def _qid_shape_(self):\n        # By implementing this method this gate implements the\n        # cirq.qid_shape protocol and will return the tuple (3,)\n        # when cirq.qid_shape acts on an instance of this class.\n        # This indicates that the gate acts on a single qutrit.\n        return (3,)\n\n    def _unitary_(self):\n        # Since the gate acts on three level systems it has a unitary \n        # effect which is a three by three unitary matrix.\n        return np.array([[0, 0, 1],\n                         [1, 0, 0],\n                         [0, 1, 0]])\n\n    def _circuit_diagram_info_(self, args):\n        return '[+1]'\n```\n\n----------------------------------------\n\nTITLE: Running Parameter Sweeps on Virtual Engine in Python\nDESCRIPTION: This code demonstrates running a parameter sweep on the virtual engine using `run_sweep`. It defines a circuit with a parameterized X gate and sweeps the parameter 't' from 0 to 2 with 20 steps.  The results are then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/virtual_engine_interface.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nqubit = cirq.GridQubit(7, 2)\ncircuit = cirq.Circuit(cirq.X(qubit) ** sympy.Symbol('t'), cirq.measure(qubit, key='m'))\njob = weber.run_sweep(circuit, params=cirq.Linspace('t', 0, 2, 20), repetitions=1000)\nprint(f'job is type {type(job)}')\nprint(f'job has id {job.id()} and status {job.execution_status()}')\nprint('')\n\nprint('Now executing results!')\nresults = job.results()\nprint('')\nprint(f'job has id {job.id()} and status {job.execution_status()}')\n\nprint('')\nprint('Results:')\nfor result in results:\n    print(result.histogram(key='m'))\n```\n\n----------------------------------------\n\nTITLE: Displaying Two Qubit Gate Constants in Cirq\nDESCRIPTION: This snippet uses the display_gates function to display documentation for the two qubit gate constants CX, CZ, SWAP, ISWAP, ISWAP_INV, SQRT_ISWAP, and SQRT_ISWAP_INV. The display_gates function retrieves each gate from the cirq module and displays its docstring using IPython.display.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndisplay_gates(\"CX\", \"CZ\", \"SWAP\", \"ISWAP\", \"ISWAP_INV\", \"SQRT_ISWAP\", \"SQRT_ISWAP_INV\")\n```\n\n----------------------------------------\n\nTITLE: Fitting Exponential Decays to Fidelities (Cirq)\nDESCRIPTION: This snippet fits exponential decays to the circuit fidelities to estimate by-layer fidelities. It leverages the `xeb_fitting.fit_exponential_decays` function to analyze the circuit fidelities obtained for varying circuit lengths.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfitted_fidelities = list(map(xeb_fitting.fit_exponential_decays, circuit_fidelities))\n```\n\n----------------------------------------\n\nTITLE: Importing necessary Python libraries\nDESCRIPTION: This snippet imports several Python libraries commonly used in quantum computing and data analysis. It imports `random` for generating random numbers, `matplotlib.pyplot` for plotting and visualization, and `numpy` for numerical computations and array manipulation.  These libraries provide tools for creating simulations, analyzing data, and visualizing results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport random\nimport matplotlib.pyplot as plt\nimport numpy as np\n```\n\n----------------------------------------\n\nTITLE: Engine Object Creation in Python\nDESCRIPTION: This code snippet creates an `Engine` object using the provided `project_id` and retrieves the device specification of the processor with the given `processor_id`. This setup is crucial for running circuits on Google's Quantum Computing Service (QCS).\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Create an Engine object to use.\nspec = cg.Engine(project_id).get_processor(processor_id).get_device_specification()\n```\n\n----------------------------------------\n\nTITLE: Modifying Plot Properties in Cirq\nDESCRIPTION: This snippet demonstrates how to modify plot properties like title, xlabel, ylabel, and tick labels when creating a state histogram. It defines a function `binary_labels` to generate binary labels for the tick marks and passes these labels along with custom title and axis labels to `cirq.plot_state_histogram`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/state_histograms.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef binary_labels(num_qubits):\n    return [bin(x)[2:].zfill(num_qubits) for x in range(2 ** num_qubits)]\n\nq = cirq.LineQubit.range(3)\ncircuit = cirq.Circuit([cirq.H.on_each(*q), cirq.measure(*q)])\nresult = cirq.Simulator().run(circuit, repetitions=100)\n_ = cirq.plot_state_histogram(result, plt.subplot(), title = 'Custom Plot Title', xlabel = 'Custom X-Axis Label', ylabel = 'Custom Y-Axis Label', tick_label=binary_labels(3))\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Set Up Unitary and Phase Estimation Parameters in Python\nDESCRIPTION: This code sets the parameters for the phase estimation algorithm. It defines `theta`, which represents the phase in the unitary operator U = Z^(2*theta).  It also defines `n_bits`, which determines the number of qubits used for estimating theta, thus controlling the accuracy of the approximation. Finally, the unitary operator `U` is defined as a `cirq.Z` gate raised to the power of `2 * theta`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Set up the unitary and number of bits to use in phase estimation.\"\"\"\n# Value of θ which appears in the definition of the unitary U above.\n# Try different values.\ntheta = 0.234\n\n# Define the unitary U.\nU = cirq.Z ** (2 * theta)\n\n# Accuracy of the estimate for theta. Try different values.\nn_bits = 3\n```\n\n----------------------------------------\n\nTITLE: Plotting State Histograms in Cirq\nDESCRIPTION: This code snippet shows how to plot state histograms of measurement results using Cirq and Matplotlib. It demonstrates how to plot a histogram directly from the samples and how to use the histogram function to create a sparse histogram that excludes empty qubit states.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\n\ncirq.plot_state_histogram(samples, plt.subplot())\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Kraus Operators from Mixture Representation in Cirq\nDESCRIPTION: This snippet shows how `cirq.kraus` generates Kraus operators from the mixture representation if the operator implements `SupportsMixture` but not `SupportsKraus`. It converts probabilities and unitaries to Kraus operators, demonstrating the conversion from a probabilistic X gate.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/protocols.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ncirq.kraus(cirq.X.with_probability(0.25))\n```\n\n----------------------------------------\n\nTITLE: Generating a Random Circuit on a Tilted Square Lattice in Cirq\nDESCRIPTION: This snippet generates a random quantum circuit using `cirq.experiments.random_rotations_between_grid_interaction_layers_circuit` on the specified `TiltedSquareLattice` topology. The generated circuit consists of random rotations between interaction layers, with a defined depth. The circuit is then displayed using `SVGCircuit`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/qubit-placement.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.experiments.random_rotations_between_grid_interaction_layers_circuit(\n    qubits=sorted(topo.nodes_as_gridqubits()),\n    depth=4,\n)\n\nfrom cirq.contrib.svg import SVGCircuit\nSVGCircuit(circuit)\n```\n\n----------------------------------------\n\nTITLE: Defining Valid Qubits\nDESCRIPTION: This section lists the valid qubit indices available for use within the quantum circuit.  Each entry specifies a qubit in the form of a string, representing the row and column coordinates (e.g., '0_5'). This constrains the overall qubit layout of the device.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-google/cirq_google/devices/specifications/weber_2021_12_10_device_spec_for_grid_device.proto.txt#_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nvalid_qubits: \"0_5\"\nvalid_qubits: \"0_6\"\nvalid_qubits: \"1_4\"\nvalid_qubits: \"1_5\"\nvalid_qubits: \"1_6\"\nvalid_qubits: \"1_7\"\nvalid_qubits: \"2_4\"\nvalid_qubits: \"2_5\"\nvalid_qubits: \"2_6\"\nvalid_qubits: \"2_7\"\nvalid_qubits: \"2_8\"\nvalid_qubits: \"3_2\"\nvalid_qubits: \"3_3\"\nvalid_qubits: \"3_4\"\nvalid_qubits: \"3_5\"\nvalid_qubits: \"3_6\"\nvalid_qubits: \"3_7\"\nvalid_qubits: \"3_8\"\nvalid_qubits: \"3_9\"\nvalid_qubits: \"4_1\"\nvalid_qubits: \"4_2\"\nvalid_qubits: \"4_3\"\nvalid_qubits: \"4_4\"\nvalid_qubits: \"4_5\"\nvalid_qubits: \"4_6\"\nvalid_qubits: \"4_7\"\nvalid_qubits: \"4_8\"\nvalid_qubits: \"4_9\"\nvalid_qubits: \"5_0\"\nvalid_qubits: \"5_1\"\nvalid_qubits: \"5_2\"\nvalid_qubits: \"5_3\"\nvalid_qubits: \"5_4\"\nvalid_qubits: \"5_5\"\nvalid_qubits: \"5_6\"\nvalid_qubits: \"5_7\"\nvalid_qubits: \"5_8\"\nvalid_qubits: \"6_1\"\nvalid_qubits: \"6_2\"\nvalid_qubits: \"6_3\"\nvalid_qubits: \"6_4\"\nvalid_qubits: \"6_5\"\nvalid_qubits: \"6_6\"\nvalid_qubits: \"6_7\"\nvalid_qubits: \"7_2\"\nvalid_qubits: \"7_3\"\nvalid_qubits: \"7_4\"\nvalid_qubits: \"7_5\"\nvalid_qubits: \"7_6\"\nvalid_qubits: \"8_3\"\nvalid_qubits: \"8_4\"\nvalid_qubits: \"8_5\"\nvalid_qubits: \"9_4\"\n```\n\n----------------------------------------\n\nTITLE: Visualizing Final State Probability\nDESCRIPTION: This snippet demonstrates how to visualize the probability distribution of the final state of the quantum circuit using matplotlib. It calculates the final state vector, then plots the probability (absolute value squared) for each state.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfinal_state = circuit.final_state_vector(ignore_terminal_measurements=True, dtype=np.complex64)\nplt.fill_between(np.arange(len(final_state)),\n                 np.abs(final_state)**2)\nplt.xlabel(\"State of qubits\")\nplt.ylabel(\"Probability\")\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Qubit Selection for Loschmidt Echoes\nDESCRIPTION: This snippet defines a list of qubit configurations (`qubit_sets_indices`) to run the Loschmidt echo experiment on. The indices are then converted into `cirq.GridQubit` objects and stored in the `qubit_sets` list. One of the qubit configurations is intentionally selected to have a high calibration error.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/echoes.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Pick sets of qubits to run Loschmidt echoes on.\"\"\"\nqubit_sets_indices = [\n    [(4, 7), (4, 8), (5, 8), (5, 7)],\n    [(0, 5), (0, 6), (1, 6), (1, 5)],  # From the calibration, we expect this to be the worst configuration.\n    [(2, 6), (2, 7), (3, 7), (3, 6)],\n    [(7, 3), (7, 4), (8, 4), (8, 3)],\n]\n\n# Convert indices to grid qubits.\nqubit_sets = [[cirq.GridQubit(*idx) for idx in qubit_indices] \n              for qubit_indices in qubit_sets_indices]\n```\n\n----------------------------------------\n\nTITLE: Measuring a density matrix in Cirq\nDESCRIPTION: This snippet demonstrates how to measure a density matrix using `cirq.measure_density_matrix`. It initializes a density matrix, performs a measurement on it, and prints the measurement result and the resultant density matrix.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/operators.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nrho = np.ones(shape=(2, 2)) / 2.0\nprint(\"State:\\n\", rho)\n```\n\nLANGUAGE: python\nCODE:\n```\nmeasurements, rho_prime = cirq.measure_density_matrix(rho, indices=[0])\n\nprint(\"Measured:\", measurements[0])\nprint(\"Resultant state:\\n\", rho_prime)\n```\n\n----------------------------------------\n\nTITLE: Executing Circuit on QVM\nDESCRIPTION: This code snippet executes a provided circuit on the Quantum Virtual Machine created earlier. It retrieves a sampler from the `sim_engine` and runs the circuit for a specified number of repetitions. It measures and prints the execution time and the simulation results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_builder_code.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncircuit = your_circuit  # @param\n\nreps = 3000\nstart = time.time()\nresults = sim_engine.get_sampler(processor_id).run(circuit, repetitions=reps)\nelapsed = time.time() - start\n\nprint('Circuit successfully executed on your quantum virtual machine', processor_id)\nprint(f'QVM runtime: {elapsed:.04g}s ({reps} reps)')\nprint('You can now print or plot \"results\"')\n```\n\n----------------------------------------\n\nTITLE: Initializing the Router (Python)\nDESCRIPTION: This snippet initializes the router using Sycamore device hardware, retrieves the device graph from the device metadata and then creates the `RouteCQC` router object.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/routing_transformer.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Initialize the router with Sycamore device hardware\nimport cirq_google as cg\ndevice = cg.Sycamore\ndevice_graph = device.metadata.nx_graph\nrouter = cirq.RouteCQC(device_graph)\n\n# Let's look at what the device architecture looks like\nprint(device)\n```\n\n----------------------------------------\n\nTITLE: Exception Handling\nDESCRIPTION: Illustrates the `try...except` block for exception handling in Python. It shows how to catch and handle potential errors that might occur during code execution, ensuring that the program doesn't crash unexpectedly.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\ntry:\n    result = 1 / 0\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\n```\n\n----------------------------------------\n\nTITLE: Classical Post-Processing of Quantum Measurement Result Python\nDESCRIPTION: This function processes the measurement result from the order finding circuit. It extracts the eigenvalue estimate, uses the continued fractions algorithm to determine the order, and validates the order by checking if x**r mod n == 1. It depends on the fractions module.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef process_measurement(result: cirq.Result, x: int, n: int) -> Optional[int]:\n    \"\"\"Interprets the output of the order finding circuit.\n\n    Specifically, it determines s/r such that exp(2πis/r) is an eigenvalue\n    of the unitary\n\n        U|y⟩ = |xy mod n⟩  0 <= y < n\n        U|y⟩ = |y⟩         n <= y\n    \n    then computes r (by continued fractions) if possible, and returns it.\n\n    Args:\n        result: result obtained by sampling the output of the\n            circuit built by make_order_finding_circuit\n\n    Returns:\n        r, the order of x modulo n or None.\n    \"\"\"\n    # Read the output integer of the exponent register.\n    exponent_as_integer = result.data[\"exponent\"][0]\n    exponent_num_bits = result.measurements[\"exponent\"].shape[1]\n    eigenphase = float(exponent_as_integer / 2**exponent_num_bits)\n\n    # Run the continued fractions algorithm to determine f = s / r.\n    f = fractions.Fraction.from_float(eigenphase).limit_denominator(n)\n    \n    # If the numerator is zero, the order finder failed.\n    if f.numerator == 0:\n        return None\n    \n    # Else, return the denominator if it is valid.\n    r = f.denominator\n    if x**r % n != 1:\n        return None\n    return r\n```\n\n----------------------------------------\n\nTITLE: Creating Heatmap of Noisy Simulation Results in Cirq\nDESCRIPTION: This snippet creates a heatmap from the results of a noisy simulation.  It extracts the measurement data for both measurement and data qubits for a specific repetition and plots it using `cirq.Heatmap`. This allows for visualizing the impact of hardware noise on the measurement outcomes across the qubit grid, allowing for error analysis.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# Set to view results from each repetition.\nrepetition = 0  # @param {type:\"number\"}\nmeas_map = {\n    qubit_map[q]: results.measurements[str(q)][repetition] for q in grid_meas_qubits.values()\n}\n\ndata_map = {\n    qubit_map[q]: results.measurements[str(q)][repetition] for q in grid_data_qubits.values()\n}\n\nheatmap = cirq.Heatmap({**meas_map, **data_map})\nheatmap.plot()\n```\n\n----------------------------------------\n\nTITLE: Parallel Operations with CircuitOperation\nDESCRIPTION: This snippet illustrates how `CircuitOperation` can be used to represent parallel operations on different qubits.  It creates two `CircuitOperation` instances, one repeated three times on `q0` and another repeated twice on `q1`, and adds them to the same moment in the circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nsubcircuit_op = cirq.CircuitOperation(cirq.FrozenCircuit(cirq.H(q0)))\ncircuit = cirq.Circuit(\n    subcircuit_op.repeat(3), subcircuit_op.repeat(2).with_qubit_mapping({q0: q1})\n)\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq\nDESCRIPTION: This snippet attempts to import the Cirq library and, if it fails (due to ImportError), it installs Cirq using pip. This ensures that the necessary library is available for the rest of the code to function correctly.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/echoes.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    !pip install --quiet cirq\n```\n\n----------------------------------------\n\nTITLE: Generating Random Two-Qubit Circuit in Python\nDESCRIPTION: This code generates a random two-qubit circuit using `cirq.experiments.random_quantum_circuit_generation.random_rotations_between_two_qubit_circuit`. It specifies the two qubits, the depth of the circuit, the two-qubit gate as `cirq.SQRT_ISWAP`, and the set of single-qubit gates defined earlier. The generated circuit is then visualized using `SVGCircuit`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/xeb_theory.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport cirq_google as cg\nfrom cirq.experiments import random_quantum_circuit_generation as rqcg\n\nq0, q1 = cirq.LineQubit.range(2)\ncircuit = rqcg.random_rotations_between_two_qubit_circuit(\n    q0, q1, \n    depth=4, \n    two_qubit_op_factory=lambda a, b, _: cirq.SQRT_ISWAP(a, b), \n    single_qubit_gates=SINGLE_QUBIT_GATES\n)\nSVGCircuit(circuit)\n```\n\n----------------------------------------\n\nTITLE: Check Job Status on Azure Quantum\nDESCRIPTION: Checks the status of an asynchronous job submitted to Azure Quantum using the `job.status()` method.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_ionq.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\njob.status()\n```\n\n----------------------------------------\n\nTITLE: Creating InternalGate in Cirq\nDESCRIPTION: This snippet demonstrates how to create an instance of `cirq_google.InternalGate`, which acts as a placeholder for Google internal gates. The arguments `gate_module`, `gate_name`, and `num_qubits` are used to identify the correct gate during translation. Additional arguments can be passed via `internal_gate_args`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/internal_gates.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ninternal_gate_args = {\n    # Arguments to be passed to the constructor of the internal gate.\n}\ninternal_gate = cirq_google.InternalGate(\n    gate_module='GATE_MODULE',  # Module of class. \n    gate_name='GATE_NAMPE',  # Class name.\n    num_qubits=2,  # Number of qubits that the gate acts on.\n    **internal_gate_args)\ninternal_gate\n```\n\n----------------------------------------\n\nTITLE: Formatting Notebooks with nbformat\nDESCRIPTION: This snippet demonstrates how to format iPython notebooks using the `check/nbformat` script. It explains how to check the formatting and apply the changes automatically, and how to add this to git pre-commit hook.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/notebooks.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncheck/nbformat\ncheck/nbformat --apply\n```\n\n----------------------------------------\n\nTITLE: Running a Simple Circuit on Simulator\nDESCRIPTION: This snippet constructs a simple quantum circuit using Cirq and runs it on the IonQ simulator. It defines two qubits, applies a square root of X gate to the first qubit, applies a CNOT gate between the two qubits, and measures both qubits. The results are then printed to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/getting_started.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nq0, q1 = cirq.LineQubit.range(2)\ncircuit = cirq.Circuit(\n    cirq.X(q0) ** 0.5,            # Square root of X\n    cirq.CX(q0, q1),              # CNOT\n    cirq.measure(q0, q1, key='b') # Measure both qubits\n)\nresult = service.run(circuit, repetitions=100)\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Defining Cycle Depths for XEB Experiment\nDESCRIPTION: This snippet defines the cycle depths to be used in the XEB experiment. `max_depth` is set to 100, and `cycle_depths` is a NumPy array that ranges from 3 to `max_depth` with a step of 20. These depths determine the length of the quantum circuits used in the XEB sampling.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/isolated_xeb.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# We will truncate to these lengths\nmax_depth = 100\ncycle_depths = np.arange(3, max_depth, 20)\ncycle_depths\n```\n\n----------------------------------------\n\nTITLE: Adding and Correcting Errors\nDESCRIPTION: This snippet appends an X error to the second qubit, simulates the circuit, and then applies a correction circuit to the qubits using ancilla qubits, and displays the circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/stabilizer_code.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Append an error:\ncircuit.append(cirq.X(qubits[1]))\n\n# Correct the error:\nancillas = [cirq.NamedQubit(f\"d{i}\") for i in range(code.n - code.k)]\ncircuit += code.correct(qubits, ancillas)\n\nSVGCircuit(circuit)\n```\n\n----------------------------------------\n\nTITLE: Explicit PauliString Construction\nDESCRIPTION: This code demonstrates building `cirq.PauliString` objects using the constructor with lists, arguments, and dictionary arguments. This explicit construction is useful for generative code.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Compose two Xa and a coefficient, as a list.\ntyprint(cirq.PauliString([4, Xa, 5j * Za]))\n# Compose Xa and Za and a coefficient, as arguments.\ntyprint(cirq.PauliString(4, Xa, 5j * Za))\n# Compose Xa and Za and a coefficient, as dictionary arguments.\ntyprint(cirq.PauliString(20j, {a: cirq.X}, {a: cirq.Z}))\n```\n\n----------------------------------------\n\nTITLE: Displaying Two Qubit PowGates in Cirq\nDESCRIPTION: This snippet uses the display_gates function to display documentation for the two qubit PowGates SwapPowGate, ISwapPowGate, CZPowGate, CXPowGate, and PhasedISwapPowGate. The display_gates function retrieves each gate from the cirq module and displays its docstring using IPython.display.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndisplay_gates(\"SwapPowGate\", \"ISwapPowGate\", \"CZPowGate\", \"CXPowGate\", \"PhasedISwapPowGate\")\n```\n\n----------------------------------------\n\nTITLE: Using Custom Cost Function Router in Cirq (Python)\nDESCRIPTION: This snippet shows how to instantiate and use a custom router with the overridden cost function defined previously. It creates an instance of `RouteCQCSimpleCostFunction` and applies it to a circuit, printing both the original and routed circuits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/routing_transformer.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nnew_router = RouteCQCSimpleCostFunction(device_graph)\nrouted_circuit = new_router(circuit)\nprint(circuit)\nprint(routed_circuit)\n```\n\n----------------------------------------\n\nTITLE: Using Custom Parametrized Gate in a Cirq Circuit\nDESCRIPTION: This code demonstrates the usage of the custom, parameterized `RotationGate` within a Cirq circuit.  A `RotationGate` instance is created with a specific theta value (0.1), and is applied to a qubit.  The resulting circuit, showing the gate with its parameter, is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/custom_gates.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ncirc = cirq.Circuit(\n    RotationGate(theta=0.1).on(cirq.LineQubit(0))\n)\n\nprint(\"Circuit with a custom rotation gate:\")\nprint(circ)\n```\n\n----------------------------------------\n\nTITLE: Conditional Statement Example\nDESCRIPTION: Demonstrates the use of a conditional statement (`if`) to execute different code blocks based on a condition. It provides a simple example of how to control the flow of execution using boolean logic.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nif condition:\n    print(\"Condition is true\")\nelse:\n    print(\"Condition is false\")\n```\n\n----------------------------------------\n\nTITLE: Serial Gate Execution in Cirq\nDESCRIPTION: This code shows how to execute two gates in serial by placing them in separate moments. The X gates are applied to two different qubits in consecutive moments, ensuring sequential execution on the hardware.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/devices.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncirq.Circuit(\n  cirq.Moment(cirq.X(cirq.GridQubit(4,4))),\n  cirq.Moment(cirq.X(cirq.GridQubit(4,5)))\n)\n```\n\n----------------------------------------\n\nTITLE: List IonQ Targets using Azure Quantum Service\nDESCRIPTION: Lists available quantum computing targets accessible through the Azure Quantum service. The `provider_id` argument can be used to filter targets by provider (e.g., \"ionq\").\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_ionq.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nservice.targets(provider_id=\"ionq\")\n```\n\n----------------------------------------\n\nTITLE: Constructing symbolic expression using SymPy\nDESCRIPTION: This snippet constructs a symbolic expression using SymPy. It defines a symbolic variable 'a' and then creates an expression `0.5 * a + 0.25`. The expression is printed to the console. This demonstrates how to define more complex parameter dependencies using SymPy.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Construct an expression for 0.5 * a + 0.25:\nexpr = 0.5 * sympy.Symbol(\"a\") + 0.25\nprint(expr)\n```\n\n----------------------------------------\n\nTITLE: Mixture of Gate.with_probability channel\nDESCRIPTION: Shows how to obtain and print the mixture of a channel created using `Gate.with_probability`. This demonstrates how to access the Kraus operators and their associated probabilities for a channel defined directly from a gate with a probability parameter.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfor prob, kraus in cirq.mixture(channel):\n    print(f\"With probability {prob}, apply\\n\", kraus, end=\"\\n\\n\")\n```\n\n----------------------------------------\n\nTITLE: Plotting Sparse Sampled Data\nDESCRIPTION: This code snippet demonstrates plotting sparse sampled data using Cirq. It extracts counts from the result data structure with the histogram() function and then passes that to cirq.plot_state_histogram. This method ignores qubit states that were never seen.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Pull of histogram counts from the result data structure\ncounts = samples.histogram(key='result')\nprint(counts)\n\n# Graph the histogram counts instead of the results\ncirq.plot_state_histogram(counts, plt.subplot())\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Mapping LineTopology to GridQubits (Automatic)\nDESCRIPTION: This snippet demonstrates automatically mapping a LineTopology to the SYC23 device using `cirq.get_placements`. It then visualizes a sparse selection of the generated placements. The complete number of placements is printed to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/named_topologies.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ntopo = LineTopology(9)\nplacements = cirq.get_placements(SYC23_GRAPH, topo.graph)\ncirq.draw_placements(SYC23_GRAPH, topo.graph, placements[::300])\nprint('...\\n')\nprint(f'{len(placements)} total placements')\n```\n\n----------------------------------------\n\nTITLE: Stepping Through Cirq Circuit Simulation\nDESCRIPTION: This code demonstrates how to step through a circuit simulation moment by moment using `simulate_moment_steps`.  It prints the state vector at each step of the simulation, which is useful for debugging.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/simulation.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit()\ncircuit.append(basic_circuit())\nfor i, step in enumerate(simulator.simulate_moment_steps(circuit)):\n    print('state at step %d: %s' % (i, np.around(step.state_vector(copy=True), 3)))\n```\n\n----------------------------------------\n\nTITLE: Visualize Order Finding Circuit in Cirq\nDESCRIPTION: This snippet demonstrates how to create and visualize the quantum circuit for period finding using the `make_order_finding_circuit` function and Cirq's circuit printing capabilities.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ncircuit = make_order_finding_circuit(x, n)\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Answer Check Python\nDESCRIPTION: This code snippet checks if the calculated factors p and q are correct by verifying that their product equals the original number n.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Check the answer is correct.\"\"\"\np * q == n\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq with Pip in Python\nDESCRIPTION: This snippet attempts to import the cirq library. If cirq is not found, it installs cirq using pip and then imports it. This ensures that the environment has the necessary cirq library for the rest of the code to execute.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    import cirq\n\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Creating and Activating Python Virtual Environment\nDESCRIPTION: These commands create a Python virtual environment named 'cirq-py3' using virtualenvwrapper, activate the environment, upgrade pip, and install development dependencies. It requires virtualenvwrapper to be installed and configured.  You may need to `source ~/.bashrc` if virtualenvwrapper wasn't already initialized.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nmkvirtualenv cirq-py3 --python=/usr/bin/python3\n```\n\nLANGUAGE: bash\nCODE:\n```\nworkon cirq-py3\n```\n\nLANGUAGE: bash\nCODE:\n```\npython -m pip install --upgrade pip\n```\n\nLANGUAGE: bash\nCODE:\n```\npython -m pip install -r dev_tools/requirements/dev.env.txt\n```\n\n----------------------------------------\n\nTITLE: Sampling 2Q XEB Circuits with Cirq\nDESCRIPTION: This function samples 2Q XEB circuits using a given sampler and a set of predefined circuit parameters. It takes a sampler, a list of circuits, cycle depths, combinations by layer, a random seed for shuffling, and the number of repetitions. It then returns the sampled data as a Pandas DataFrame.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport cirq.experiments.xeb_sampling as xeb_sampling\nimport cirq.experiments.xeb_fitting as xeb_fitting\n\n# use the same circuit library, cycle depths, combinations by layer,\n#   random seed and repetitions for both noise models' samplers.\ndef sample_df(sampler):\n    return xeb_sampling.sample_2q_xeb_circuits(\n        sampler=sampler,\n        circuits=circuit_library,\n        cycle_depths=cycle_depths,\n        combinations_by_layer=combs_by_layer,\n        shuffle=RANDOM_SEED,\n        repetitions=1000,\n    )\n\n\nsampled_dfs = list(map(sample_df, samplers))\n```\n\n----------------------------------------\n\nTITLE: Printing Sycamore Device Information with Cirq\nDESCRIPTION: This snippet imports cirq_google and networkx, then prints the Sycamore device, which is a specific device implementation within Cirq. This displays the structure and connectivity of the device.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/devices.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq_google\nimport networkx as nx\n\nmy_device = cirq_google.Sycamore\nprint(my_device)\n```\n\n----------------------------------------\n\nTITLE: Running Tests for Changed Files\nDESCRIPTION: This command runs tests associated with files that have been changed in the Cirq project. It requires the 'check/pytest-changed-files' script to be present. BASE_REVISION is an optional argument specifying the commit to compare against.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n./check/pytest-changed-files [BASE_REVISION]\n```\n\n----------------------------------------\n\nTITLE: Displaying Matrix Gates in Cirq\nDESCRIPTION: This snippet uses the display_gates function to display documentation for the matrix gates MatrixGate, DiagonalGate, TwoQubitDiagonalGate, and ThreeQubitDiagonalGate. The display_gates function retrieves each gate from the cirq module and displays its docstring using IPython.display.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndisplay_gates(\"MatrixGate\", \"DiagonalGate\", \"TwoQubitDiagonalGate\", \"ThreeQubitDiagonalGate\")\n```\n\n----------------------------------------\n\nTITLE: Accessing Sycamore23 Qubits with Grid Coordinates in Cirq (Python)\nDESCRIPTION: Shows how to access qubits on the Sycamore23 device using grid coordinates in Cirq. The grid is accessed similarly to the Sycamore device, allowing specification of qubit location on the hardware's layout. It is important to note that the Sycamore23 grid is a subset of the full Sycamore grid.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/devices.md#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n  0123456789\n0 ----------\n1 ----------\n2 ----------\n3 --A-------\n4 -ABC------\n5 ABCDE-----\n6 -CDEFG----\n7 --EFGHI---\n8 ---GHI----\n9 ----I-----\n```\n\n----------------------------------------\n\nTITLE: Run Circuit and Plot Results\nDESCRIPTION: Executes a quantum circuit on the Quantum Engine using the Sampler and plots the state histogram using `cirq.plot_state_histogram`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/start.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nprint(\"Scheduling execution on the Quantum Engine...\\n\")\nprint(\"You can view jobs at: https://console.cloud.google.com/quantum/\"\n      \"jobs?project={}\\n\".format(project_id))\n\n# Print out the results. This blocks until the results are returned.\nresults = sampler.run(hw_circuit, repetitions=1000)\ncirq.plot_state_histogram(results)\n```\n\n----------------------------------------\n\nTITLE: Plotting and Analyzing Circuit Fidelity vs Cycle Depth\nDESCRIPTION: This snippet plots the circuit fidelity against the cycle depth, including a marker for each data point. It also plots a theoretical curve representing the expected fidelity decay based on the depolarizing error rate. The snippet uses `E_PAULI` and `DIM` which are assumed to be defined earlier in the code. Finally the code adds axis labels, a legend, sets a logarithmic scale and adjusts the layout for optimal viewing.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/xeb_theory.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nplt.plot(\n    fids['cycle_depth'], \n    fids['fidelity'],\n    marker='o',\n    label='Least Squares')\n\nxx = np.linspace(0, fids['cycle_depth'].max())\n\n# In XEB, we extract the depolarizing fidelity, which is\n# related to (but not equal to) the Pauli error.\n# For the latter, an error involves doing X, Y, or Z with E_PAULI/3\n# but for the former, an error involves doing I, X, Y, or Z with e_depol/4\ne_depol = E_PAULI / (1 - 1/DIM**2)\n\n# The additional factor of four in the exponent is because each layer\n# involves two moments of two qubits (so each layer has four applications\n# of a single-qubit single-moment depolarizing channel).\nplt.plot(xx, (1-e_depol)**(4*xx), label=r'$(1-\\\\mathrm{e\\\\_depol})^{4d}$')\n\nplt.ylabel('Circuit fidelity', fontsize=18)\nplt.xlabel('Cycle Depth $d$', fontsize=18)\nplt.legend(loc='best')\nplt.yscale('log')\nplt.tight_layout()\n```\n\n----------------------------------------\n\nTITLE: Running pyQuil QVM and Compiler in Background\nDESCRIPTION: This code snippet uses the `subprocess` module to start the pyQuil QVM and Compiler as background processes. The `qvm` command is run with the `--quiet` and `-S` flags, and the `quilc` command is run with the `--quiet` and `-R` flags. This ensures that the QVM and compiler are running before executing quantum circuits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/rigetti/getting_started.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport subprocess\n\nsubprocess.Popen([\"qvm\", \"--quiet\", \"-S\"])\nsubprocess.Popen([\"quilc\", \"--quiet\", \"-R\"])\n```\n\n----------------------------------------\n\nTITLE: Kraus Representation of Depolarizing Channel in Cirq\nDESCRIPTION: This snippet demonstrates how to obtain the Kraus operators for a depolarizing channel using `cirq.kraus`. It shows the basic usage of the function with a depolarizing channel instance, where the p parameter indicates the depolarizing probability.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/protocols.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ncirq.kraus(cirq.DepolarizingChannel(p=0.3))\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using Qubit in Cirq\nDESCRIPTION: This snippet likely involves initializing a qubit, potentially using the Cirq library, and using it to perform quantum operations, though the specific operations are not shown in the isolated snippet.  The context suggests that `cS` is likely a variable related to quantum states. The value of `vW` may relate to a quantum amplitude or probability.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_16\n\nLANGUAGE: Python\nCODE:\n```\n6xft46Ch4s/BQoeLsJ/xqkpeDwDjMsfh1vwuNfSop4nW1WHk22CxnU0qE9TzxWUwTglbODH0K7WD6xVz5S66vNy7cpFWa/KXuvXr5N16rniFCMKHvYbkYKHnVG4c4RT8EAnOaSxqRkyRcWrKUUzZezY1HBfsifP91B1lENZuKaqUpWFz8uSskWqLLxBl4cz1bTfTmwUPOxUKXjYGXk5BwUPL3uHtrlCgIKHHTsFDzsjP+QYruCxc9cuJXZs1Y24XQ8f6d7q6RlZakqyJD9cvuM2PpJH0nL3jtzTqVkWLVoo69auUWmtZGVlOXJ+jvCwY3VH8FD3CXriqvslLj5B3StZ+n5JTBhpNzgKcjx89DBwr9xr1vsVy5fJWnWfrF2zRq/r5AQCjvCwU6XgYWcU7hwUPMJNfGDnc0Xw2ILnCoT0rfqZktHzXImLjRuY0RGeq7u7Sz9PWu7dkY72tsAzRZXB1qjnSkJCgiNXT8HDjpWCh51RuHOES/DYvn27Gk0QKAs/GhEj6RmZkqZSYiLrjfA56o0YmWbqjUvKypRAu1bXHbHOqRMbBQ87VQoedkZezkHBw8veoW2uEKDgYcdOwcPOyA85hi147FSCR3lA8Lh9u1lkxAiVcOX6Pz8gcNxG9CI069IsXrRIVq9eJWtUcmpoMgUPu0vdEjzQo22LaqBqVesZ4V4ZgfuF94p2GFj03iuJslwJHqtXrZJVKqWlOtPzj4KH/V6h4GFnFO4cFDzCTXxg53Nb8NDPE/1ciRmYwVGQKyYmRpLUuoBJIxNl9OjR+nmCMtjKlSspeLjofwoeLsJ/xqnDKXiYER537txVzfuoN7LO2NctpiyM/dIlS4L1xoyMjL7ZQvaagocdJQUPOyMv56Dg4WXv0DZXCFDwsGOn4GFn5IccwxU8Tp06JW+++aZOLS2tfQqtLLwa/8cnxEt8fLwkqDRt2jSZPWuWzJo9S1LGOjOVEQUPQ/7ZezcED9wnJ06ckOPH35QHDx7wXnnCPajv4j7B/ZKgRsDMmFEUuFfU/TLKofnoKXg84YR+3lLw6AeKyx9R8HDZAc84fbgFj/v321XZ67i8qZ4rb6rnCkX0px0TEzNCl73i1WgOCB+zUP7SqVji4pwZBcMRHk/74clPKHg8ScT99+ESPN566y1dFkaZuE11/tGCBzv+9P4ATFk4LlB3LCqarsvCs1W9ccyYMb35QviKgocdJgUPOyMv56Dg4WXv0DZXCFDwsGOn4GFn5IccwxU8rl27LvX1V+Xq1Xrp6OhQFW5cNcWOvr6PjY2V2NgYiY2JFQxHHq8WK5+g1u/AqA8nNgoedqrhFjxg0dWrV9W9Uq/vla6uLt4rT7gJUSNG3yuB+wVTvuE+wVo3Tk09QsHjCSf085aCRz9QXP6IgofLDnjG6cMteHR2dgaeKeq5Uq+eL/qhwjLYY96BkI4yWBySakCcoMpfeKYgYfSHExsFDztVCh52RuHOES7B49q1az1l4auCGIa1DllvfNzbut6o4hPKxJmZ41RZeIKOXRjx4cRGwcNOlYKHnZGXc1Dw8LJ3aJsrBCh42LFT8LAz8kOO4QoeWGgYjbdIap21wEa94zHXGxyYbgIVbPQqRGE2MJ3RY1lD8oaChx2jG4IH7hFzvzzSN4v6ZZgfh93kqMhhcODeCAiFED+cu1coeNh/VhQ87IzCnYOCR7iJD+x84RY88BwxzxQtomsz+Vzp6y3zTMHDNih+9JTB+uYL5WsKHnaaFDzsjMKdI1yCx+Nl4Z6r7L1Rw33ZnjyfwaHrjRBrVXKyLEzBw/4zoOBhZ+TlHBQ8vOwd2uYKgf37DwQW1FLzrSeMTJbiOSUyc/Z8yVQKO7cAgfMVZ6TizFtSeeakzJo5QzZu3CAbNqyXgvx8IvIRAfQ4r6mpkdra2sf2uITi4mKdMA1TTk6O6l0yQfeK89HlRaWpNTW1ahHTrWox+XI5f6FaZs0t1TFs2oziqOTR30U3XL+mYhfi11sy4lG3il0bZKNKZWWL+8vOzyKUAAUPu2PdEDy2qNiFRZixGPOkqTNUDCuRWaocNkrNwc9N1JR47XJOlb1Q/kIM27B+vY5hKINhnQIntpNq+sqtyi/l5duksel2wCfKLwWFU5w4nS+PeeVirVSeDfgkIy1Vl4nxbME0ltyihwAEjy0qfiGO3W/vkGJ1n8xWKTd/YvRAsFzpxZoqOXf2lI5feTnZ+l5Zr+LY9OnTLd8c2p+bmpq0P/Bc2btvfzB+oXzs1NRmQ7PUvW9hkexzKn6dU8+UhmtXBP5A/MLeqQ5a7l0tz9yXAASPcrWQPOqNNXUXdZ2xeM58mTJ9Zt9sUf36uprNAmWuitNvKQFKZFNPuxfW5uTmfQIUPLzvI1oYZgL79+/XlTpUth90dMmEnDyVclVl25k598N8eSE5HXqCNN68Lo0NN2Tu3Dmyft1aWadSfl5eSI7Pg4SHQGNjox5abIYYmz3OXlhYqFO+ErGwUBpSWlpaeAzjWYZMAAIWGqZQsTtztkIm5CJ+5UtmFgVbA7WttUXHr1sqfo0ZPUrHLsSwRSy4GkRRsafgYXezO4JHoLEQMSwtPVOydQzLU1ObOTOdg52Ct3J0d3fJrZs3gmnd2rWyFmWwteuU4DHKEWMDgocSobZukytqCks8V7JV2TgtfZwj5/PjQe/dbQ76JFc14sIvKBej8wi36CEQFDy2bNXiIO4TxLCU1PTogWC50rvNTdLU2KDvl8mTCmUtYtjaNXqdO8tXh/RnI3hsUT7ZvXevjl0Bv+Q7NrXZkAx18UsdHQ+kST1XmhpvSFdHu6xZs6bHL2speLjol3CcWgseqjMDylyV587rdq/xKm6NyxwfjtP74hytLfd0m9fNhuuSmjJWt3uh3rhw4QJf2B/tRlLwiPZfAK//KQIQPCB2IPDfunVbEtSciQkJIyUWki63xwhg2GVJyXxZu2a1Khytlrzc3Mf+zjfeJnD37l1BRQDp9u3bwT2sxhz6SBA6xqoFtrFYmlO9R71NyV/WQfBA78KtqmL3plocMDFxZE8MY2NhX09iegvEr+zsCbJmdSB+LVzAgmtfRpH+moKH3cOuCB4qdgV6SG9VN2mMimGJOo45Nee+nYL3ciB+qfWYVRohq1at0uUvxLFRoxwSPE6eCjxXVNm46sIF7Q88W+Lj470HxyWL8DwJ+GWETJkyWT9XViufzFSjoLlFD4E3jh0TNKwjhl26dEUSRwbiF++V3t+AnqpH3TCxKs2YMUNwnyCOTZ06pTdTCF9pwUP55P+UT3bt2h2IX2odPcQw3LPcAgRi1UMFzxV0BII/kOAbjvCI7F8IBA/TUQ6dG9C5JAHP94SEyL7wwV5dz9Tdubk5wXavBaUlgz0K87tAgIKHC9B5Sm8TOHHihBw+fESlw7oBGKUhszyBty0Pn3UJ8Qn6QYjFZGcUFcnCBaVSqlJWZmb4jOCZhk3g/v370tLS8lhqbW3Vx4XIkZKSooWOpKQkQXJqoe1hXwgPECSAxbERuw6pdK7yXKAFBk37rNQFGcXFxqnCfIJeDHt81nhZoGLXgtJSVfEuCubhi8gnQMHD7uNwCx5YxBSxy8Swrq5uFboYv/p6Co1PiapBIlHFsERVBitRsQuV7lK1x3PaiQ0NIgG/HJGLly6qU2BNBD5U+rKOV4tiG5/kFxToZwp8UljIqYz6cor01xWVlXLoUKAMVl9/TTeoM4Y97nXUIfW9omLY5EmTVewqUZ3nSiTPoVkC0LnL+OT1N97oeaYE1nV53LLofRcbE6t9MlJ1MBg7doz2B+IX/MJYH9m/i8uXL8uRI2j3OiLnz59XFxsoc7Htq9fvsag3qvJWvIpd2WqKb11vVHXHGUXOTMPXe2a+CgUBCh6hoMhjRBQBBH7Mg4+e0qbxV5dYI+oqh3cxgQVl49Tcp7F6bYeJqnJXUJCvG8eHd2R+O5wEOjo61HzgD55KsMGIHOhdG3jIx7M3ZzidM8RzNTc3S7WKXTXVNXL9xnV1FF3VVjs2Thmk6CmuFwFUi5dC2EPsQgzDOjXcoocABQ+7r8MteGARZh2/VAyrVjHs4cOH2kg2uDzuK8w7jxSvymBoXA+UwQoce0Y3NNxUZeJqXTa+1XRLGcPnyuMeUb3V8Vzp8Ut6epp6rqBcXKBHyT6Zl+8jl8D169d17EIcu3OnWV1ooOzFGNbrc9QhTfwaN26cvk8wfa5T0+beb29XZeJq/WypU2sUGF+Yfa9l0fsKLOJ74ldS0kiBP0wMi14q0XHlmOEBbV5IN240BC5ahy3WG80vAPVG0/aVoqa00mWuiareOJ7TfhlGXt5T8PCyd2ibKwTa2tq00AGxA70L9caY/5gvUDBCwnQKiWpY8KjkZElWCQVYbv4hgMYkJDQy9X2NKwg82GP1Hg967W+15+ZtAughjVE7iF/tqpJnKts9dW5vGx8m69BUp2OYGruPCh5iFxJHMIXJAR45DQUPuyPCLXg8evRIxy4Tw9TbwMYy2GPOQtlrhJrua4SKYclJiF9JOobhWe3Eho4RLeqZ0qqeLegowefK05T1c0VPCTNCdxIxzxV0GOEWPQRQ7grcK63S2cl7pT/Pm/oj9uhUhXslScWxhARnpshDHQdl4paWVmlrwyj2ngcKnytB9wAFnikxiGHqOWLiF/bcIpsAnum4PwL1xge9F8v7I8giWG9UMQvTEwbuD858EQTk8RcUPDzuIJpHAiRAAiRAAiRAAiQQWgIUPOw8wy142C1iDhIgARIgARIgARIgARIgARKwE6DgYWfEHCRAAiRAAiRAAiRAAhFEgIKH3ZkUPOyMmIMESIAESIAESIAESIAESMB7BCh4eM8ntIgESIAESIAESIAESMBBAhQ87HApeNgZMQcJkAAJkAAJkEDkEmhsbBSsN8ONBEjAfwQoePjPZ7SYBHxHAPNyd3V19Zv0wnVqPkTMiYjXZu0IzO3KjQRIgARIgAScIEDBw06VgoedEXOQAAmQAAmQAAlELoH//d//lXe84x2Re4G8MhKIYAIUPCLYubw0EvAKAYgdt2/f1qm5uTn4Gp+lpaVJVlaWZGZmytixY2XMmDE6QQDhRgIkQAIkQAJOEKDgYadKwcPOiDlIgARIgARIgAQikwBGd3znO9+Rl156KTIvkFdFAhFOgIJHhDuYl0cCXiDw4MEDuXz5sly6dCm4N68LCgpk2rRpOuXk5GjxAwJIcnKyF0ynDSRAAiRAAhFIgIKH3akUPOyMmIMESIAESIAESCAyCfzqV7+S//qv/5Kvf/3rgnYKbiRAAv4iQMHDX/6itWEg0N3dLSZhKiYkbk8TwJRTSDExMdZpqNra2qSysvKpVFFRIcXFxVJaWqrT1KlTBQIIEkZ6cCMBEhgcgYcPHwbjF14zfvXPz8Qv7M00eohl3KKHAAUPu6/dEDxQ/sKoUOwDxS+WwZ70FOIWtr7xC3GMGwmQgLsETBkMMYx1yGf7wpTBTB0Se5bBns2Lf3GPwGc+8xm5evWqvOtd75J3vvOd7hni0JlNzEKZi/XGZ0M2MatvuYsx69m8vPQXCh5e8gZt8QSBxlu3pOHGDbmhUtv9+/KwRwBhw2Gve+LjEyQhASleUlPT1EJeGXoxr5EjR/Zm6vOKgkcfGHxJAg4SaG1t1bHrxo0GaW6+/Zj44eBpfXVoNAwG4leCjBo1SseujIwMFctSfXUdNHZ4BCh42PmFW/BAZRtlL5OM8NHd/VAZS+EDHkNl28Qv7BG7sJgqEkUP+2+aOUjASQKYttfEr5aWlp4yGDqfIIZxA4G4uHgdwxITE/RUxohdiGMoj3EjAS8ROH36tHzta1/TJhUWFgZfe8nG4dqCONXQ0KDj1m0Vv0y7F8pj3AIEHqs3jh4t4zJQ5sqQlJQUIvIBAQoePnASTQwvgaoLF+TsmTNyRiWsMdHR2SmdHZ1K9e4OryEePlty8ihdMEXhtGBigUxXU1JNnTpNNRj2H/gpeHjYmTQtoghgrlnELqSLFy9Kh4pdnSqGdXV1RtR1DudiEhISg/ErM3NccEq9/Pz84RyW3/UZAQoedoeFW/CAwHHmzNlgDGtvb9fxCzGMDYYBf6FHIcpeo0aNllGjR8k0NTLWTAsKAYQbCZCAewQwXa8pg6HjCWIXUnd3l3tGeezMSUlJwTJYbm5uMH5B+OBGAl4i8IMf/ED27t0bNAniB4SPSNogdpw9Gyh3XVTxS8csVXdkvbHXy33rjZh2PVDmmip5eXm9mfjKswQoeHjWNTTMLQJHX39d9u3bpx9w1+qvSfuDdnnQ/kBPseCWTV47LxRt9IZOVQuOz5kzWxYvXiyLFy2S8ePH92sqBY9+sfBDEgg5gUuXLuvYhQL6qVOnBA2GSB0dHSE/l18PiMo24leail+YPk/Hr8WLZNasWX69JNo9BAIUPOzQwi14oKKN2LVnz169x4g1xC+sA8behgF/oadhoPwViGGLVNkLMaxMJcQ2biRAAu4RQI9wxDCk2tq6YPxCbOMWIIApi9PSVB1SlcNmzJih4xfiGMpj3EjAKwRQ7vjTP/3Tx9p/MKUVpraKpK2uri7Q7qXavlBvRJsX642Pe1jXG1WdETELgpepNxbPnPl4Rr7zJAEKHp50C41yk8CRI0dk9549smvXLmlpbZPRY1JkzNhUSUhMdNMsT527Aw0Q7W0q3VeNhMWyYsVyWbF8uWRnZ/drJwWPfrHwQxIIOQGM6ti1a7fs2r1LKs5Wyuixgfg1imviBFl3q4YHxC7EsPT0VBW7VugYNm/evGAevoh8AhQ87D4Ot+ABYdbEL+wTRybp8tcYFcdi4+LsBkdBjkcPH0nHg0D5C3Fs+fJlwRiWnJwcBQR4iSTgXQJvnTyp64+IXxjhgfrjGNVJbGQS703jtc6OB9KhYleHKoNNnjxJxbAVOo5NmjTJZOGeBFwnsHPnTnn11VcfswOLlmPx8kjaamtrZfdu1Bt3S+W58ypmqXqjavtKHs21VI2fu3S9MVDuGqem3zPtXnPnzjFZuPcwAQoeHnYOTXOHwKFDhwQPue07dsqImDiZNLVICqdMV6MZMtwxyINnvXKpVi7VVsulumopnjlD1q5ZLatVylNDk/vbKHj0R4WfkUDoCaCnzvYdO2SHSlVV1Tp+TVLxK2/i5NCfzKdHbL7dqOPXZRW/4uNiZI2KXWvXrJEFCxb49Ipo9lAIUPCwU3ND8ED82r49EMOy8ybKZBW/UA5jg2HAX12dHbrshfiFMtjq1atkzerVKo6t0dPE2L3KHCRAAk4RePPECR2/EMPuqU5zOn5NK5LMrP47hDllh5ePe+PaFUH8QsrPy1ExbI2OY1PV9HzcSMArBL785S9LZWXlU+a89NJLekqjp/7g0w+qa2p0uxfqjdU1daq8pcpcqtyVm08B0rj09q2buryFMtfIxHhdZ0S5q7S0xGTh3sMEKHh42Dk0zR0CBw4ckG3btkv5tm0yNjVDFi1bKYuWvCA5+RPdMciDZ33z6GE5enifvH54v8womi6bNm2UjRs2qOHI/c+BT8HDg06kSRFJAD11ysu3qVQuNRcvyeKlK2WximFzSxdH5PUO5aKuXKyRo4f2q/i1Tx7cb5FNG1X8UjFsSVnZUA7H7/iUAAUPu+PcEDy29sQv7GfPWyBlKn4hho1JSbUbHAU52u+36bIX4hfKYBtU2WvTxg2yUcWx0WoxTW4kQALuETh2/Lhs3Roog3U9GqFjF2LY5Gkz3DPKY2euOPWmvHHkgI5f4zMzdOzasGG9FBUVecxSmhOtBLAWz1//9V/3e/lvf/vb5b3vfW+/f/PjhxcuVMu27dtkmypzXbpar+uNi5a+ILPnL/Tj5Thi88WaC/L6kf267tjd2a7LXCh3YWorbt4nQMHD+z6ihWEmsF8LHiisbpPUjCxZ+sJaldZIXgGVbuMKiB2H9u3SaUbRNNm8aZNKG585/yoFD0POW3vMKYwpRDBPad89rBw5cqROiWoqt/j4eJ3iOKWItxzYjzU1EDy2lstWJXjUXbwsy1aq+LVynZQuWtpP7uj8CAXXQ/t3ymEVw9pa7sjmzYhfm2TJkiXRCSRKr5qCh93xrggeKn5tUfFrq9rPX7hEx7DlKoaNpeChHXa/rVUO7w+Uv7CH0IFOJ4hhFDzsv2nmIAEnCRw7pgQPFb+2qPj1aESsLFN1yGWr1sm0omInT+urY5868YYcUbELZbAsJXjoTnMqjlHw8JUbI9rYn/70p/Lb3/6232scN26cfPvb3+73b3788MKFC7qjL+LWlavXVJ1R1RtXrNHlLz9ejxM211w4p8pdu1W71049Fd/bVL0RneXKyih4OME71Mek4BFqojye7wlQ8LC7kIKHnZEfcmBB2Dt37sjdu3d1Mq9hOxZ0Tk9P13vMCz5q1Cjh/ODe9yoFD7uPKHjYGUVDDgoedi9T8LAzCncOCh7hJs7zkcDACVDwsLOi4GFnxBzuEvjoRz8qt2/ffqYRX/jCF9QaprOe+Xc//YGCh91bFDzsjLycg4KHl71D21whQMHDjp2Ch52RH3KgMNfQ0KAWVryh9+Y1bM/Ly9NpwoQJWvSAAJKiFl7k5m0CFDzs/qHgYWcUDTkoeNi9TMHDzijcOSh4hJs4z0cCAydAwcPOioKHnRFzuEfg9ddfl29+85vPNQBTSb7//e9/bh6//JGCh91TFDzsjLycg4KHl71D21whQMHDjp2Ch52RH3JA4Lhy5cpj6fLly9r0KVOmCFJhYaFkZmbqlJGR4YfLimobKXjY3U/Bw84oGnJQ8LB7mYKHnVG4c1DwCDdxno8EBk6AgoedFQUPOyPmcI8AxA6IHs/b0AHwe9/73vOy+OZvFDzsrqLgYWfk5RwUPLzsHdrmCgEKHnbsFDzsjPyQo76+Xurq6gQLXfdNsH3GjBlSXFws06ZNE4zyyM7OlqysLD9cVlTbSMHD7n4KHnZG0ZCDgofdyxQ87IzCnYOCR7iJ83wkMHACFDzsrCh42BkxhzsEMPMBprMayPaZz3xGSkpKBpLV03koeNjdQ8HDzsjLOSh4eNk7tM0VAhQ87NgpeNgZ+SEHRnOcP38+mKqqqvRr2D5v3jydIHrk5+fr6a0genDzNgEKHnb/UPCwM4qGHBQ87F6m4GFnFO4cFDzCTXznI4GBE6DgYWdFwcPOiDncIYCFyrFg+UC2VatWyYc//OGBZPV0HgoedvdQ8LAz8nIOCh5e9g5tc4UABQ87dgoedkZ+yHHx4kWprKyUiooKvcdrJGylpaU6zZkzRwoKCnTKzc31w2VFtY0UPOzup+BhZxQNOSh42L1MwcPOKNw5KHiEmzjPRwIDJ0DBw86KgoedEXO4Q+DFF18U1I0HsiUlJcmrr746kKyezkPBw+4eCh52Rl7OQcHDy96hba4QoOBhx07Bw87IDzkoePjBS4OzkYKHnRcFDzujaMhBwcPuZQoedkbhzkHBI9zEeT4SGDgBCh52VhQ87IyYI/wE0OHvy1/+8qBO/Jd/+ZeyePHiQX3Ha5kpeNg9QsHDzsjLOSh4eNk7tM0VAhQ87NgpeNgZ+SEHBQ8/eGlwNlLwsPOi4GFnFA05KHjYvUzBw84o3DkoeISbOM9HAgMnQMHDzoqCh50Rc4SfAEZr7Ny5c1AnXrZsmXzsYx8b1He8lpmCh90jFDzsjLycg4KHl71D21whQMHDjp2Ch52RH3JQ8PCDlwZnIwUPOy8KHnZG0ZCDgofdyxQ87IzCnYOCR7iJ83wkMHACFDzsrCh42BkxR3gJdHV1yYc+9CFpb28f1IljY2P1tFYJCQmD+p6XMlPwsHuDgoedkZdzUPDwsndomysEKHjYsVPwsDPyQw4KHn7w0uBspOBh50XBw84oGnJQ8LB7mYKHnVG4c1DwCDdxno8EBk6AgoedFQUPOyPmCC+BvXv3yg9+8IMhnfTP//zPZcWKFUP6rhe+RMHD7gUKHnZGXs5BwcPL3qFtrhCg4GHHTsHDzsgPOSh4+MFLg7ORgoedFwUPO6NoyEHBw+5lCh52R\n```\n\n----------------------------------------\n\nTITLE: Sampling and Printing from F and U Sets in Python\nDESCRIPTION: Demonstrates how to use the `draw_two_distribution_from_f_set` and `draw_two_distribution_from_u_set` functions to generate sample distributions. The code generates distributions from both the forrelated ('F') and uniform ('U') sets, prints the resulting distributions and their correlation/forrelation values, and creates stem plots to visualize the generated distributions. The `plt.stem` calls, along with related statements, are excluded, as they are plotting commands and outside the scope of the prompt.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nn = 6\nN = 2 ** n\n\nfs, gs, forrelation, correlation = draw_two_distribution_from_f_set(N)\nprint('Correlation and forrelation from F set')\nprint(f\"fs: {list(fs)}\")\nprint(f\"gs: {list(gs)}\")\nprint(f'Correlation: {correlation} Forrelation: {forrelation}')\nplt.figure(figsize=(15, 5))\nplt.stem(fs)\nplt.stem(gs, linefmt='--r', markerfmt='ro')\nplt.title(f\"Two distributions from F set\")\n\nprint('')\nprint('Correlation and forrelation from U set')\nfs, gs, forrelation, correlation = draw_two_distribution_from_u_set(N)\nprint(f\"fs: {list(fs)}\")\nprint(f\"gs: {list(gs)}\")\nprint(f'Correlation: {correlation} Forrelation: {forrelation}')\n\nplt.figure(figsize=(15, 5))\nplt.stem(fs)\nplt.stem(gs, linefmt='--r', markerfmt='ro')\n_ = plt.title(f\"Two distributions from U set\")\n```\n\n----------------------------------------\n\nTITLE: Loading Noise Properties in Cirq with Python\nDESCRIPTION: This code snippet loads the median device calibration data for a specified processor ID ('rainbow' in this case) using `cirq_google.engine.load_median_device_calibration` and then generates a `cirq_google.GoogleNoiseProperties` object from this calibration data.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/qubit_picking.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nprocessor_id = \"rainbow\"\ncal = cirq_google.engine.load_median_device_calibration(processor_id)\nnoise_props = cirq_google.noise_properties_from_calibration(cal)\n```\n\n----------------------------------------\n\nTITLE: Getting Qubits After Simplification\nDESCRIPTION: After simplifying the circuit, this code retrieves the remaining qubits in the circuit.  It prints the number of remaining qubits after simplification, which can be useful for resource estimation and debugging.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# simplification might eliminate qubits entirely for large graphs and \n# shallow `p`, so re-get the current qubits.\nqubits = sorted(tot_c.all_qubits())\nprint(len(qubits))\n```\n\n----------------------------------------\n\nTITLE: Simulating a Parameterized Circuit in Cirq\nDESCRIPTION: This code simulates the parameterized circuit defined in the previous snippet using `cirq.Simulator`. It iterates through a range of values for the parameter 's', creates a `param_resolver` for each value, and then simulates the circuit with that resolver, printing the final state vector for each parameter value.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_62\n\nLANGUAGE: python\nCODE:\n```\nsimulator = cirq.Simulator()\n\n# Simulate the circuit for several values of the parameter.\nnum_params = 5\nfor y in range(num_params):\n    result = simulator.simulate(circuit, param_resolver={\"s\": y / 4.0})\n    print(f\"s={y}: {np.around(result.final_state_vector, 2)}\\n\")\n```\n\n----------------------------------------\n\nTITLE: Storing Deutsch Algorithm Operations in a Dictionary in Cirq\nDESCRIPTION: This snippet stores the operations needed to query each function in the Deutsch algorithm in a dictionary. The dictionary maps oracle names to the operations required to enact the corresponding function on two qubits. This is used in the implementation of the Deutsch-Jozsa Algorithm.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\n# Get qubits for the operations to act on.\nq0, q1 = cirq.LineQubit.range(2)\n\n# Define the dictionary of operations. The key of each dictionary entry\n```\n\n----------------------------------------\n\nTITLE: Decomposing a Hadamard Gate\nDESCRIPTION: This code snippet demonstrates how to decompose a Hadamard gate into simpler gates using the cirq.decompose() protocol. It shows how to get a sequence of gates equivalent to the H gate.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nprint(cirq.decompose(cirq.H(cirq.LineQubit(0))))\n```\n\n----------------------------------------\n\nTITLE: Running Pytest, Pylint, and Mypy\nDESCRIPTION: These commands run pytest, pylint, and mypy, the core tools for testing, linting, and type checking Cirq code. They require pytest, pylint, and mypy to be installed, as well as their respective configuration files to be present.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\npytest\n```\n\nLANGUAGE: bash\nCODE:\n```\npylint --rcfile=dev_tools/conf/.pylintrc cirq\n```\n\nLANGUAGE: bash\nCODE:\n```\nmypy --config-file=dev_tools/conf/mypy.ini .\n```\n\n----------------------------------------\n\nTITLE: Displaying Three Qubit Gate Constants in Cirq\nDESCRIPTION: This snippet uses the display_gates function to display documentation for the three qubit gate constants CCX, CCZ, and CSWAP. The display_gates function retrieves each gate from the cirq module and displays its docstring using IPython.display.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndisplay_gates(\"CCX\", \"CCZ\", \"CSWAP\")\n```\n\n----------------------------------------\n\nTITLE: Checking the Deutsch-Jozsa Circuit\nDESCRIPTION: This code snippet simulates a user-defined Deutsch-Jozsa circuit (`your_circuit`) for both constant and balanced functions. It runs the circuit 10 times for each oracle and prints the measurement results. This allows the user to verify whether their circuit correctly distinguishes between constant and balanced functions.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_41\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Check your answer by running this cell.\"\"\"\nsimulator = cirq.Simulator()\n\nprint(\"\\nYour result on constant functions:\")\nfor oracle in constant:\n    result = simulator.run(cirq.Circuit(your_circuit(oracle)), repetitions=10)\n    print(result)\n\nprint(\"\\nYour result on balanced functions:\")\nfor oracle in balanced:\n    result = simulator.run(cirq.Circuit(your_circuit(oracle)), repetitions=10)\n    print(result)\n```\n\n----------------------------------------\n\nTITLE: PauliString Construction with Multiplication\nDESCRIPTION: This code shows the different uses of the `*` operator with `PauliString` objects: scalar multiplication, composition (same qubit), and tensor product (different qubits). It demonstrates how these operations can be combined and how Pauli operators cancel or anti-commute during composition.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Complex scalar multiplication.\ntyprint((4 + 5j) * Xa)\n# Composition\ntyprint(Xa * Xa)\ntyprint(Xa * Za)\n# Tensor\ntyprint(Xa * Xb)\ntyprint(Xa * Zb)\n```\n\n----------------------------------------\n\nTITLE: List Programs using Quantum Engine API\nDESCRIPTION: This snippet demonstrates how to list programs using the `cirq_google.Engine.list_programs()` method, filtering by creation date and labels. It then iterates through the programs and their associated jobs, printing their IDs and statuses.  It also illustrates how to filter jobs under specific programs.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/engine.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq_google.engine.client.quantum import enums\n\n# Initialize the engine object\nengine = cirq_google.Engine(project_id='YOUR_PROJECT_ID')\n\n# List all the programs on the project since 2020/09/20 that have\n# the \"variational\" label with any value and the \"experiment\" label\n# with value \"vqe001\":\nprograms = engine.list_programs(\n                created_after=datetime.date(2020,9,20),\n                has_labels={\"variational\":\"*\", \"experiment\":\"vqe001\"}\n           )\nfor p in programs:\n   print(p.program_id, p.create_time())\n   # the same filtering parametrization is available as in engine.list_jobs()\n   # for example here we list the jobs under the programs that failed\n   for j in p.list_jobs(execution_states=[enums.ExecutionStatus.State.FAILURE]):\n     print(j.job_id, j.status())\n```\n\n----------------------------------------\n\nTITLE: Converting Circuit to Density Matrix Tensors\nDESCRIPTION: This snippet converts a quantum circuit into a tensor network representation of its density matrix using `circuit_to_density_matrix_tensors` from `cirq.contrib.quimb`. The resulting tensors are used to create a Quimb tensor network, which is then visualized.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Cirq-to-Tensor-Networks.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ntensors, qubit_frontier, fix = ccq.circuit_to_density_matrix_tensors(circuit=circuit, qubits=qubits)\ntn = qtn.TensorNetwork(tensors)\ntn.graph(fix=fix, color=['Q0', 'Q1', 'Q2'])\n```\n\n----------------------------------------\n\nTITLE: Configuration Parameters for Quantum Volume Calculation\nDESCRIPTION: This snippet sets up the configuration parameters for the quantum volume calculation, including the number of circuits, depth, number of samplers, repetitions, and the device (Sycamore). It imports the necessary libraries and prints the configuration details.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_volume_errors.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport cirq_google\n\n# Configuration parameters. Feel free to mess with these!\nnum_circuits = 10\ndepth = 4\nnum_samplers = 50\nrepetitions = 10_000\ndevice=cirq_google.Sycamore\n\nprint(f\"Configuration: depth {depth} with \"\n      f\"{num_circuits} circuits of {num_samplers} samplers\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Fused Noise Model in Cirq with Python\nDESCRIPTION: This code defines a `FusedNoiseModel` class that applies multiple noise models in sequence to each moment in a quantum circuit. The `noisy_moment` method iterates through the provided noise models and applies them sequentially to each moment.  It inherits from `cirq.NoiseModel`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Sequence\n\n\nclass FusedNoiseModel(cirq.NoiseModel):\n    \"\"\"A noise model that applies other noise models in sequence\"\"\"\n\n    def __init__(self, models: Sequence[cirq.NoiseModel]):\n        self.models = models\n\n    def noisy_moment(self, moment: 'cirq.Moment', system_qubits: Sequence['cirq.Qid']):\n        \"\"\"Produce a list of moments by applying each model in sequence to the available moments\"\"\"\n\n        moments = [moment]\n        for model in self.models:\n            new_moments = []\n            for moment in moments:\n                ret = model.noisy_moment(moment, system_qubits)\n                # handle constituent noise models returning lists of or singleton moments\n                new_moments.extend([ret] if isinstance(ret, cirq.Moment) else ret)\n            moments = new_moments\n        return moments\n```\n\n----------------------------------------\n\nTITLE: Circuit creation with EARLIEST and NEW_THEN_INLINE strategies\nDESCRIPTION: This snippet shows how to create a specific circuit layout by combining `InsertStrategy.EARLIEST` (default) and `InsertStrategy.NEW_THEN_INLINE`. The first `append` uses the default `EARLIEST` strategy, and the second append employs `NEW_THEN_INLINE` to group gates into the same moment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n# Define three qubits.\na = cirq.NamedQubit('a')\nb = cirq.NamedQubit('b')\nc = cirq.NamedQubit('c')\n\n# Get an empty circuit.\ncircuit = cirq.Circuit()\n\n# Append these gates using cirq.InsertStrategy.EARLIEST (the default strategy).\ncircuit.append([cirq.CZ(a, b), cirq.H(c), cirq.H(a)])\n\n# Append these gates using cirq.InsertStrategy.NEW_THEN_INLINE.\ncircuit.append(\n    [cirq.H(b), cirq.CZ(b, c), cirq.H(b), cirq.H(a), cirq.H(a)],\n    strategy=cirq.InsertStrategy.NEW_THEN_INLINE,\n)\n\n# Display the circuit.\nprint(\"Circuit:\\n\")\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Creating Circuit with LineQubits\nDESCRIPTION: This snippet creates a quantum circuit using LineQubit.  It defines three qubits (a, b, c), applies a series of quantum gates (CNOT, CZ, SWAP, PhasedXPowGate, Z), and then measures the qubits.  The circuit is then visualized using SVGCircuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/svg/example.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\na, b, c = cirq.LineQubit.range(3)\nSVGCircuit(cirq.Circuit(\n    cirq.CNOT(a, b),\n    cirq.CZ(b, c),\n    cirq.SWAP(a, c),\n    cirq.PhasedXPowGate(exponent=0.123, phase_exponent=0.456).on(c),\n    cirq.Z(a),\n    cirq.measure(a, b, c, key='z')\n))\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq and qsimcirq (Conditional)\nDESCRIPTION: This snippet attempts to import the cirq and qsimcirq libraries. If the import fails, it installs the libraries using pip. The try-except blocks handle the ImportError that occurs if the libraries are not already installed. The `!pip install` command is used to execute pip from within the notebook environment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_utility_sim_4b.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n\ntry:\n    import qsimcirq\nexcept ImportError:\n    print(\"installing qsimcirq...\")\n    !pip install --quiet qsimcirq\n    print(f\"installed qsimcirq.\")\n```\n\n----------------------------------------\n\nTITLE: Kraus Representation of Unitary Operator in Cirq\nDESCRIPTION: This snippet demonstrates how `cirq.kraus` handles unitary operators by returning a single-element tuple containing the unitary matrix. It also compares the output of `cirq.kraus` with `cirq.unitary` and checks if the operator supports Kraus representation using `cirq.has_kraus`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/protocols.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nprint(cirq.kraus(cirq.Y))\nprint(cirq.unitary(cirq.Y))\nprint(cirq.has_kraus(cirq.Y))\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq with all optional modules using pip\nDESCRIPTION: This command installs Cirq along with all optional modules, including cirq-google.  It installs the stable release of Cirq and ensures all dependencies are installed.  It is an alternative to installing cirq-google separately if you want all Cirq features.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-google/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npip install cirq\n```\n\n----------------------------------------\n\nTITLE: Displaying a Circuit with a Custom CRx Gate\nDESCRIPTION: This snippet demonstrates how to display a Cirq circuit that includes a custom controlled-Rx (CRx) gate. It defines two qubits, creates an instance of the `CRx` gate with a rotation angle of 0.25π, applies it to the qubits, and then prints a circuit diagram representation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_55\n\nLANGUAGE: python\nCODE:\n```\n# Get qubits.\na = cirq.NamedQubit('a')\nb = cirq.NamedQubit('b')\n\n# Display the circuit.\nprint('Circuit diagram:')\nprint(cirq.Circuit(CRx(0.25 * np.pi)(a, b)))\n```\n\n----------------------------------------\n\nTITLE: Copyright Notice in Python\nDESCRIPTION: A standard copyright notice for The Cirq Developers, indicating the project and the organization responsible for its development.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n##### Copyright 2021 The Cirq Developers\n```\n\n----------------------------------------\n\nTITLE: Read Processor Specification from File - Python\nDESCRIPTION: This code snippet reads a processor specification from a file and prints the first 10 lines. It uses `importlib.resources` to read the file content from the `cirq_google.devices.specifications` package.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/virtual_engine_interface.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport importlib\nfrom cirq_google.devices import specifications\n\n# Get the processor identifier and file location from MOST_RECENT_TEMPLATES.\nprocessor_id, template_name = next(\n    iter(cirq_google.engine.virtual_engine_factory.MOST_RECENT_TEMPLATES.items())\n)\n# Read the protobuf template.\ndevice_str = importlib.resources.read_text(specifications, template_name)\n# Print just the first 10 lines of the very long protobuf specification.\nprint(f'Processor: {processor_id}')\nprint('\\n'.join(device_str.splitlines()[:10]))\nprint('...')\n\n```\n\n----------------------------------------\n\nTITLE: Generating Multiple Random Circuits in Python\nDESCRIPTION: This code generates a list of random two-qubit circuits using the same function as before, but creating `N_CIRCUITS` (10 in this case) different circuits. The circuits are initialized with a `MAX_DEPTH` (100), but will later be truncated.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/xeb_theory.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Make long circuits (which we will truncate)\nMAX_DEPTH = 100\nN_CIRCUITS = 10\ncircuits = [\n    rqcg.random_rotations_between_two_qubit_circuit(\n        q0, q1, \n        depth=MAX_DEPTH, \n        two_qubit_op_factory=lambda a, b, _: cirq.SQRT_ISWAP(a, b), \n        single_qubit_gates=SINGLE_QUBIT_GATES)\n    for _ in range(N_CIRCUITS)\n]\n```\n\n----------------------------------------\n\nTITLE: Running Miscellaneous Checks\nDESCRIPTION: This command runs miscellaneous checks on the Cirq project. It includes checks like verifying that code outside `cirq.contrib` doesn't reference anything inside `cirq.contrib`. It requires the 'check/misc' script to be present.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n./check/misc\n```\n\n----------------------------------------\n\nTITLE: Creating Grid Qubits in Cirq\nDESCRIPTION: This snippet defines a square grid of qubits using `cirq.GridQubit` and prints the resulting list of qubits. The `length` variable determines the size of the grid.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/variational_algorithm.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# define the length and width of the grid.\nlength = 3\n\n# define qubits on the grid.\nqubits = cirq.GridQubit.square(length)\n\nprint(qubits)\n```\n\n----------------------------------------\n\nTITLE: Plotting Sparse Output State Histogram with Cirq\nDESCRIPTION: This code creates a circuit where one qubit is put in superposition and then CNOT gates are applied to the remaining qubits based on the first qubit's state. This leads to a sparse output when measured. The code then plots a state histogram of the measured results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/state_histograms.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nq = cirq.LineQubit.range(6)\ncircuit = cirq.Circuit([cirq.H(q[0]), [cirq.CNOT(q[0], q[i]) for i in range(1, 6, 1)], cirq.measure(*q, key='measure_all')])\nresult = cirq.Simulator().run(circuit, repetitions=100)\n_ = cirq.plot_state_histogram(result, plt.subplot())\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Plot Circuit Fidelities by Layer with Custom Options\nDESCRIPTION: This Python code defines a function `_p_gen` that generates another function `_p`. The `_p` function plots circuit fidelities by layer based on options encoded in `_p_gen`. These options control data rescaling, exponential decay, color mapping, and labeling. The function uses `matplotlib` for plotting and assumes the existence of a data frame with fidelity data.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndef _p_gen(ax, rescale=False, decay=5e-3, color=None, colors=colors, label=None):\n    \"\"\"Create a _p function to graph circuit fidelities by layer.\n    It encodes the visualization options:\n    - rescale: rescale data under the exponential decay line to range [0,1].\n    - decay: exponent defining the exponential decay reference line.\n    - color: plot everything in given color, use by-qubit color map otherwise.\n    - colors: the by-qubit color map.\n    - label: label to give the data in the legend.\n    \"\"\"\n\n    def _p(record):\n        \"\"\"For a row of a fidelity data frame, plot based on encoded options\"\"\"\n\n        # pull fidelities from data frame row/record\n        data = record.fidelities\n\n        # plot horizontal at 1.0 fidelity\n        ax.axhline(1, color='grey', ls='--')\n\n        # compute exponential decay line from record parameters (a, layer_fid)\n        # these were computed by previous fitting from fidelity data\n        xx = np.linspace(0, record.cycle_depths.max())\n        exp = xeb_fitting.exponential_decay(xx, a=record.a, layer_fid=record.layer_fid)\n\n        # rescale data to expand area under exponential reference decay line\n        # the range from zero to the reference line becomes the range [0, 1]\n        # also plot that reference line in blue, which, once rescaled, is horizontal\n        if rescale:\n            data = data / ((1 - decay) ** (4 * record.cycle_depths))\n            exp = exp / ((1 - decay) ** (4 * xx))\n            ax.plot(xx, xx**0, label=r'Normalized Reference', color='blue')\n        else:\n            ax.plot(xx, (1 - decay) ** (4 * xx), label=r'Exponential Reference', color='blue')\n\n        _, _, pair = record.name\n        q0, q1 = pair\n        # use qubit pair to color map if color is not supplied, else just use color\n        plot_color = colors[pair] if color is None else color\n        # use qubit pair as label if not supplied, else just use label\n        plot_label = f'{q0}-{q1}' if label is None else label\n\n        # plot the data with the selected color and label\n        ax.plot(record.cycle_depths, data, 'o-', color=plot_color, label=plot_label)\n        # also plot the data-fitted exponential line\n        ax.plot(xx, exp, color=plot_color, alpha=0.3)\n\n    return _p\n```\n\n----------------------------------------\n\nTITLE: Combining Classical Control Conditions with SymPy\nDESCRIPTION: Demonstrates combining multiple classical control conditions, including SymPy expressions, in Cirq. The `with_classical_controls` method is used to apply conditions based on measurement results.  The simulation then executes the circuit to verify the conditions.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/classical_control.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nq0, q1, q2, q3, q4 = cirq.LineQubit.range(5)\na = sympy.symbols('a')\nsympy_cond = sympy.Eq(a, 0)\ncircuit = cirq.Circuit(\n    cirq.H.on_each(q0, q1, q2),\n    cirq.measure(q0, q1, key='a'),\n    cirq.measure(q2, key='b'),\n    cirq.X(q3).with_classical_controls('b', sympy_cond),\n    cirq.X(q4).with_classical_controls('b').with_classical_controls(sympy_cond),\n    cirq.measure(q3, key='c'),\n    cirq.measure(q4, key='d'),\n)\nprint(circuit)\nresults = cirq.Simulator(seed=1).run(circuit, repetitions=8)\nprint(results.data)\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq if not present\nDESCRIPTION: This code snippet attempts to import the Cirq library. If the import fails due to `ImportError`, it executes a shell command to install Cirq using pip.  After installation, it prints a confirmation message. It's a common pattern in notebooks to ensure dependencies are installed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/isolated_xeb.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Defining a NetworkX graph\nDESCRIPTION: This snippet defines a NetworkX graph representing the SYC23 device architecture, which is used as a target device for mapping named topologies.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/named_topologies.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport networkx as nx\nSYC23_GRAPH = nx.from_edgelist([\n    ((3, 2), (4, 2)), ((4, 1), (5, 1)), ((4, 2), (4, 1)), \n    ((4, 2), (4, 3)), ((4, 2), (5, 2)), ((4, 3), (5, 3)), \n    ((5, 1), (5, 0)), ((5, 1), (5, 2)), ((5, 1), (6, 1)), \n    ((5, 2), (5, 3)), ((5, 2), (6, 2)), ((5, 3), (5, 4)), \n    ((5, 3), (6, 3)), ((5, 4), (6, 4)), ((6, 1), (6, 2)), \n    ((6, 2), (6, 3)), ((6, 2), (7, 2)), ((6, 3), (6, 4)), \n    ((6, 3), (7, 3)), ((6, 4), (6, 5)), ((6, 4), (7, 4)), \n    ((6, 5), (7, 5)), ((7, 2), (7, 3)), ((7, 3), (7, 4)), \n    ((7, 3), (8, 3)), ((7, 4), (7, 5)), ((7, 4), (8, 4)), \n    ((7, 5), (7, 6)), ((7, 5), (8, 5)), ((8, 3), (8, 4)), \n    ((8, 4), (8, 5)), ((8, 4), (9, 4)), \n])\n```\n\n----------------------------------------\n\nTITLE: Using AsymmetricDepolarizingChannel in Cirq (Python)\nDESCRIPTION: This code demonstrates the use of `cirq.AsymmetricDepolarizingChannel`. It initializes three qubits in different bases (X, Y, and Z), applies the asymmetric depolarizing channel with specified probabilities for X, Y, and Z errors, then returns the qubits to their original bases before measuring. The simulation runs 1000 times and the histograms are printed to observe the effect of the asymmetric depolarization.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/representing_noise.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nq0, q1, q2 = cirq.LineQubit.range(3)\nasym_depol = cirq.asymmetric_depolarize(p_x=0, p_y=0.05, p_z=0.2)\ncircuit = cirq.Circuit(\n    cirq.H(q0),  # initialize X basis\n    cirq.H(q1),  # initialize Y basis\n    cirq.S(q1),\n    asym_depol.on_each(q0, q1, q2),\n    cirq.H(q0),  # return to Z-basis\n    cirq.S(q1) ** -1,\n    cirq.H(q1),\n    cirq.measure(q0, key='result_0'),\n    cirq.measure(q1, key='result_1'),\n    cirq.measure(q2, key='result_2'),\n)\nresult = cirq.Simulator(seed=0).run(circuit, repetitions=1000)\n# Basis states are only affected by error in other bases.\nprint(\"X basis:\", result.histogram(key='result_0'))\nprint(\"Y basis:\", result.histogram(key='result_1'))\nprint(\"Z basis:\", result.histogram(key='result_2'))\n```\n\n----------------------------------------\n\nTITLE: Importing Modules in Test Code (Python)\nDESCRIPTION: This snippet demonstrates how to import Cirq modules in test code, mimicking external usage. For core framework code, it imports the entire `cirq` module.  For code outside the core, it imports from the highest level possible. It highlights import conventions specifically for test environments.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/style.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport cirq\nqubit = cirq.NamedQubit('a')\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Gate in a Cirq Circuit\nDESCRIPTION: This code demonstrates how to use the custom `HXGate` defined in the previous snippet within a Cirq circuit. It creates an instance of the gate, applies it to a qubit, and then asserts that the gate has a unitary representation (due to the `_decompose_` method).\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_57\n\nLANGUAGE: python\nCODE:\n```\nHX = HXGate()\n\na = cirq.NamedQubit('a')\ncircuit = cirq.Circuit(HX(a))\nassert cirq.has_unitary(HX(a))\nprint(circuit, cirq.unitary(circuit), sep=\"\\n\\n\")\n```\n\n----------------------------------------\n\nTITLE: Displaying Do Nothing Gates in Cirq\nDESCRIPTION: This snippet uses the display_gates function to display documentation for the do nothing gates IdentityGate and WaitGate. The display_gates function retrieves each gate from the cirq module and displays its docstring using IPython.display.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndisplay_gates(\"IdentityGate\", \"WaitGate\")\n```\n\n----------------------------------------\n\nTITLE: Initializing Quantum State with Cirq\nDESCRIPTION: This code snippet initializes a quantum state by applying an X gate followed by a Hadamard and an S gate to a specified qubit using the Cirq library. The initial state is prepared by applying the X gate to the qubit at (0,1), and then a superposition is created using H and S gates on the qubit at (0, number_qubits).\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/quantum_walks.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef initial_state():\n\n    yield cirq.X.on(cirq.GridQubit(0, 1))\n    \n    yield cirq.H.on(cirq.GridQubit(0, number_qubits))\n    yield cirq.S.on(cirq.GridQubit(0, number_qubits))\n```\n\n----------------------------------------\n\nTITLE: Ground State Probability Helper\nDESCRIPTION: This function calculates the ground state probability from a Cirq result object. It determines the fraction of measurement outcomes where all qubits are in the |0⟩ state.  This is used to analyze the results of the Loschmidt echo experiment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/echoes.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef to_ground_state_prob(result: cirq.Result) -> float:\n    return np.mean(np.sum(result.measurements[\"z\"], axis=1) == 0)\n```\n\n----------------------------------------\n\nTITLE: Parameter Sweep and Simulation in Cirq\nDESCRIPTION: This code performs a parameter sweep over the parameterized circuit using `cirq.Linspace`. It creates a sweep with 5 values for each of the 'alpha', 'beta', and 'gamma' parameters, runs the circuit for each parameter combination, and prints the parameter values along with the objective function value for each run.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/variational_algorithm.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nsweep = (cirq.Linspace(key='alpha', start=0.1, stop=0.9, length=5)\n         * cirq.Linspace(key='beta', start=0.1, stop=0.9, length=5)\n         * cirq.Linspace(key='gamma', start=0.1, stop=0.9, length=5))\nresults = simulator.run_sweep(circuit, params=sweep, repetitions=100)\nfor result in results:\n    print(result.params.param_dict, obj_func(result))\n```\n\n----------------------------------------\n\nTITLE: Displaying Pauli Operators in Cirq\nDESCRIPTION: This snippet uses the display_gates function to display documentation for Pauli operators XX, YY, and ZZ. The display_gates function retrieves each gate from the cirq module and displays its docstring using IPython.display.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndisplay_gates(\"XX\", \"YY\", \"ZZ\")\n```\n\n----------------------------------------\n\nTITLE: Simulating Expectation Values with qsimcirq (Python)\nDESCRIPTION: This snippet simulates the quantum circuit using the `qsimcirq` simulator and calculates the expectation values of the specified observables for different values of the `theta` parameter. The simulation results are stored and printed, along with the theta value for each simulation point. It uses a timing decorator `%%time` to measure the execution time.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_utility_sim_4a.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n%%time\n# This will log after each value of theta is simulated. Its purpose is to\n# give an indication of total runtime before all simulations finish.\nresults = []\nfor i, result in enumerate(simulator.simulate_expectation_values_sweep_iter(circuit, observables, params)):\n    results.append(result)\n    print(f\"Completed theta={theta_values[i]:.3f}; value={result}\")\n\n# Runtimes logged in the output of this cell were achieved using a machine with\n# 24 cores and 80GB of RAM.\n```\n\n----------------------------------------\n\nTITLE: Installing and Importing Cirq\nDESCRIPTION: This code snippet checks if the Cirq library is installed. If not, it installs Cirq using pip. Then, it imports Cirq, cirq_google, sympy, and numpy.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# @title Setup { vertical-output: true, display-mode: \"form\" }\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n\nimport cirq_google\nimport sympy\nimport numpy as np\n```\n\n----------------------------------------\n\nTITLE: Qubit Left Rotation Circuit using Generators\nDESCRIPTION: This code defines a function `left_rotate` which uses a generator to create a sequence of `xor_swap` operations, effectively rotating the state of qubits to the left.  It creates a circuit to left rotate 5 qubits using the defined generator function.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\ndef left_rotate(qubits):\n    \"\"\"Rotates qubits to the left.\"\"\"\n    for i in range(len(qubits) - 1):\n        a, b = qubits[i : i + 2]\n        yield xor_swap(a, b)\n\n\n# Get five qubits on a line.\nline = cirq.LineQubit.range(5)\n\n# Create a circuit which rotates the qubits to the left.\n# uncomment the next line to compare with your circuit\n# print(cirq.Circuit(left_rotate(line)))\n```\n\n----------------------------------------\n\nTITLE: Loschmidt Echo Experiment Parameters\nDESCRIPTION: This snippet sets the parameters for running the Loschmidt echo experiment on the Quantum Engine. It defines the `processor_id`, a list of `cycle_values` (depths), an optional `pause` duration, the number of repetitions (`nreps`), and the number of independent experiments (`trials`). These parameters are used to generate and execute the Loschmidt echo circuits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/echoes.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Set parameters for Loschmidt echo benchmark.\"\"\"\nprocessor_id = \"weber\"\ncycle_values = range(0, 80 + 1, 2)\npause = None\nnreps = 20_000\ntrials = 10\n```\n\n----------------------------------------\n\nTITLE: Measuring in Z or X basis using separate circuits\nDESCRIPTION: This code demonstrates measuring a qubit in either the Z or X basis using separate `cirq.Circuit` instances.  It utilizes the `cirq.Simulator` to obtain samples from each circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/best_practices.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nq = cirq.GridQubit(1, 1)\nsampler = cirq.Simulator()\n\n# STRATEGY #1: Have a separate circuit and sample call for each basis.\ncircuit_z = cirq.Circuit(\n    cirq.measure(q, key='out'))\ncircuit_x = cirq.Circuit(\n    cirq.H(q),\n    cirq.measure(q, key='out'))\nsamples_z = sampler.sample(circuit_z, repetitions=5)\nsamples_x = sampler.sample(circuit_x, repetitions=5)\n\nprint(\"Measurement in Z Basis:\", samples_z, sep=\"\\n\")\nprint(\"Measurement in X Basis:\", samples_x, sep=\"\\n\")\n```\n\n----------------------------------------\n\nTITLE: Cirq Installation Check\nDESCRIPTION: This snippet attempts to import the Cirq library. If Cirq is not installed, it installs it using pip.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_volume_errors.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Building Quantum Circuits with Cirq\nDESCRIPTION: This snippet shows how to build a quantum circuit by adding gates to qubits. The circuit represents a sequence of quantum operations to be performed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\nimport cirq\n\n# Create a circuit\ncircuit = cirq.Circuit()\n\n# Add gates to the circuit\ncircuit.append(cirq.H(cirq.GridQubit(0, 0)))\ncircuit.append(cirq.CNOT(cirq.GridQubit(0, 0), cirq.GridQubit(0, 1)))\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq and qsim in Python\nDESCRIPTION: This snippet attempts to import cirq, cirq_google, and qsimcirq. If the import fails, it installs the respective packages using pip. It also imports matplotlib.pyplot and time modules.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_basic_example.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\n    import cirq_google\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq-google\n    print(\"installed cirq.\")\n    import cirq\n    import cirq_google\n\ntry:\n    import qsimcirq\nexcept ImportError:\n    print(\"installing qsimcirq...\")\n    !pip install --quiet qsimcirq\n    print(f\"installed qsimcirq.\")\n    import qsimcirq\n\n# Other modules used in this colab\nimport matplotlib.pyplot as plt\nimport time\n```\n\n----------------------------------------\n\nTITLE: Constructing IonQ Service Object\nDESCRIPTION: This snippet shows how to construct an IonQ service object using an API key and a default target. The API key is needed to authenticate with the IonQ API, and the default target specifies whether to use the simulator or the QPU.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/getting_started.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nAPI_KEY = 'tomyheart' # Replace with your IonQ API key\n\nservice = ionq.Service(api_key=API_KEY, \n                       default_target='simulator')\n```\n\n----------------------------------------\n\nTITLE: Creating Results Dictionary and Plotting Data in Python\nDESCRIPTION: This snippet creates a dictionary from the raw simulation data, calculates the frequency of each state, and generates a plot showing the probability of measuring each state. It uses libraries like numpy and matplotlib. The `data_raw` object needs to be pre-defined.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/pasqal/getting_started.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Create dictionary of results\ndata0 = data_raw.data.to_dict()\nvec=[j for j in range(4)]\nres=np.zeros(len(vec))\nfor jj in range(200):\n    number = data0['x'][jj]\n    res[number] += 1\nres=res/200.\n\n# Display plot of states\nfig = plt.figure()\nax = fig.add_axes([0.16, 0.16, 0.78, 0.78])\nax.plot(vec, res,'o')\nax.set_xticks(vec)\nax.set_xticklabels([r'$|00\\rangle$',r'$|01\\rangle$', r'$|10\\rangle$', r'$|11\\rangle$'])\nplt.xlabel(r'$j$', fontsize=20)\nplt.ylabel(r'$p$', fontsize=20)\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: PasqalSampler Usage Example in Cirq\nDESCRIPTION: This code demonstrates how to use the PasqalSampler class in Cirq to run a simple quantum circuit on a Pasqal virtual device. It initializes a ThreeDQubit, creates a PasqalVirtualDevice, builds a circuit with an X gate and a measurement, and then uses the PasqalSampler to execute the circuit. Note that the access token needs to be provided to properly initialize the sampler, and the provided token 'my_token' must be replaced with an actual access token.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/pasqal/sampler.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nfrom cirq_pasqal import ThreeDQubit, PasqalVirtualDevice, PasqalSampler\n\n# A simple sample circuit\nqubit = ThreeDQubit(0, 0, 0)\np_device = PasqalVirtualDevice(control_radius=2.1, qubits=[qubit])\np_circuit = cirq.Circuit(device=p_device)\np_circuit.append(cirq.X(qubit))                        # NOT gate.\np_circuit.append(cirq.measure(qubit, key='result'))    # Measurement.\n\n\n# Create a PasqalSampler object to use.\n# Replace 'my_token' with the access token and uncomment next lines.\n\n# PASQAL_API_ACCESS_TOKEN = 'my_token'\n# sampler = cirq_pasqal.PasqalSampler(remote_host='http://34.98.71.118/v0/pasqal', access_token=PASQAL_API_ACCESS_TOKEN)\n# results = sampler.run(p_circuit, repetitions=1000) # Runs the circuit and returns the results in a 'Result'\n```\n\n----------------------------------------\n\nTITLE: Logging Transformer Steps using cirq.TransformerLogger\nDESCRIPTION: This snippet demonstrates how to use `cirq.TransformerLogger` to log the steps of a transformer. It creates a `TransformerContext` with a logger, applies the `reverse_circuit` and `substitute_gate` transformers, and then displays the logged steps. It shows the functionality of automatically logging the initial and final circuits for each step.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/custom_transformers.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Note that you want to log the steps.\ncontext = cirq.TransformerContext(logger=cirq.TransformerLogger())\n# Transform the circuit.\ntransformed_circuit = reverse_circuit(circuit, context=context)\ntransformed_circuit = substitute_gate(transformed_circuit, context=context)\n# Show the steps.\ncontext.logger.show()\n```\n\n----------------------------------------\n\nTITLE: Import necessary libraries in Python\nDESCRIPTION: This code imports standard Python libraries like fractions, math, random, numpy, sympy, and typing, along with the Cirq library for quantum computing.  These libraries provide functions for mathematical operations, random number generation, symbolic calculations, type hinting, and quantum circuit manipulation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport fractions\nimport math\nimport random\n\nimport numpy as np\nimport sympy\nfrom typing import Callable, Iterable, List, Optional, Sequence, Union\n\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Configuring Annotation Text Properties in Heatmap\nDESCRIPTION: This code demonstrates how to modify the annotation text properties of a `cirq.TwoQubitInteractionHeatmap`. It updates the plot by setting a specific annotation format (`.1E`) and customizing the font family, size, and weight of the annotation text.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/heatmaps.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n_, ax = plt.subplots(figsize=(8, 8))\n_ = two_qubit_interaction_heatmap.plot(ax,\n                                       title = 'Heatmap with modified Annotation Text',\n                                       annotation_format = '.1E',\n                                       annotation_text_kwargs = {\n                                           'family' : 'monospace',\n                                           'size' : 'large',\n                                           'weight' : 'bold'\n                                       })\n```\n\n----------------------------------------\n\nTITLE: Simplifying Tensor Network with Rank Simplification\nDESCRIPTION: This code simplifies the tensor network by folding together 1- and 2-qubit gates using `tn.rank_simplify`. The `inplace=True` argument modifies the tensor network directly. It then visualizes the simplified tensor network, coloring nodes based on qubit indices.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ntn.rank_simplify(inplace=True)\ntn.graph(color=['Q0', 'Q1', 'Q2'])\n```\n\n----------------------------------------\n\nTITLE: Noisy Simulation with DensityMatrixSimulator\nDESCRIPTION: This snippet shows how to perform a noisy simulation using the `DensityMatrixSimulator` with a specified noise model. The simulation is performed in steps, and the density matrix is printed after each step.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_78\n\nLANGUAGE: python\nCODE:\n```\n# Define a noise model.\nnoise = cirq.ConstantQubitNoiseModel(cirq.depolarize(0.2))\n\n# Pass this noise model into the simulator.\nsimulator = cirq.DensityMatrixSimulator(noise=noise)\n\n# Get a circuit to simulate.\ncircuit = cirq.Circuit(cirq.H(a), cirq.CNOT(a, b), cirq.measure(a, b))\n\n# Simulate the circuit in steps.\nfor i, step in enumerate(simulator.simulate_moment_steps(circuit)):\n    print(f'After step {i} state was\\n{step.density_matrix()}\\n')\n```\n\n----------------------------------------\n\nTITLE: Defining Different Types of Qubits in Cirq with Python\nDESCRIPTION: This snippet demonstrates how to define qubits using different methods in Cirq: `NamedQubit` for labeling qubits by abstract names, `LineQubit` for linear arrays, and `GridQubit` for rectangular lattices. It provides examples of creating individual qubits and ranges of qubits using each type.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Using named qubits can be useful for abstract algorithms\n# as well as algorithms not yet mapped onto hardware.\nq0 = cirq.NamedQubit('source')\nq1 = cirq.NamedQubit('target')\n\n# Line qubits can be created individually\nq3 = cirq.LineQubit(3)\n\n# Or created in a range\n# This will create LineQubit(0), LineQubit(1), LineQubit(2)\nq0, q1, q2 = cirq.LineQubit.range(3)\n\n# Grid Qubits can also be referenced individually\nq4_5 = cirq.GridQubit(4, 5)\n\n# Or created in bulk in a square\n# This will create 16 qubits from (0,0) to (3,3)\nqubits = cirq.GridQubit.square(4)\n```\n\n----------------------------------------\n\nTITLE: Creating a Quantum Circuit (Large Grid)\nDESCRIPTION: This code creates a quantum circuit for a larger grid, applying Hadamard gates, entangling gates, and Rx rotations to each qubit.  It depends on the 'graph' object defined in the previous snippet.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nqubits = [cirq.GridQubit(*n) for n in graph]\ncircuit = cirq.Circuit(\n    cirq.H.on_each(qubits),\n    ccq.get_grid_moments(graph),\n    cirq.Moment([cirq.rx(0.456).on_each(qubits)]),\n)\n```\n\n----------------------------------------\n\nTITLE: Getting Kraus operators of a unitary operation\nDESCRIPTION: This code snippet demonstrates how to retrieve the Kraus operators of a unitary operation using the `cirq.kraus` protocol. It takes a unitary operation as input and prints the Kraus operators associated with it.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/operators.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nkraus_ops = cirq.kraus(unitary_operation)\nprint(f\"Kraus operators of {unitary_operation.gate} are:\", *kraus_ops, sep=\"\\n\")\n```\n\n----------------------------------------\n\nTITLE: Sampling a Parameterized Circuit in Cirq\nDESCRIPTION: This code demonstrates sampling a parameterized circuit using `cirq.sample`. It defines a list of `ParamResolver`s, samples the circuit with the defined parameters, and then prints a description of the resulting pandas DataFrame.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_64\n\nLANGUAGE: python\nCODE:\n```\nresults = simulator.sample(program=circuit, params=resolvers, repetitions=10)\n\nresults.describe()\n```\n\n----------------------------------------\n\nTITLE: Plotting Two-Qubit Gate Pauli Error in Cirq\nDESCRIPTION: This code snippet retrieves and plots the two-qubit gate Pauli error data from the `noise_props.gate_pauli_errors` attribute. It iterates through supported two-qubit gates, filters for each gate type, and visualizes the Pauli error for each qubit pair using `cirq.TwoQubitInteractionHeatmap`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/qubit_picking.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntwo_qubit_gates = noise_props.two_qubit_gates()\nprint(f\"Two qubit error data: gate_pauli_errors\")\nfig, axes = plt.subplots(1, 2, figsize=(20, 10))\naxes = iter(axes)\nfor gate in two_qubit_gates:\n    measures = {\n        op_id.qubits: pauli_error\n        for op_id, pauli_error in noise_props.gate_pauli_errors.items()\n        if op_id.gate_type == gate\n    }\n    if measures:\n        ax = next(axes)\n        ax.set_title(f\"{gate.__name__} Pauli error\")\n        _ = cirq.TwoQubitInteractionHeatmap(measures).plot(ax)\n\nfig.show()\n```\n\n----------------------------------------\n\nTITLE: Installing pre-release Cirq with all optional modules using pip\nDESCRIPTION: This command installs the latest pre-release version of Cirq with all optional modules, including cirq-google, using pip. The `~=` operator ensures compatibility with the 1.* development versions. This provides access to the newest Cirq features but might include unstable code.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-google/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npip install --upgrade cirq~=1.0.dev\n```\n\n----------------------------------------\n\nTITLE: Generating Measurement Histogram in Cirq\nDESCRIPTION: This code generates a multi-measurement histogram from the simulation results. It uses a custom folding function (`fold_func`) to combine the measurement results into a more readable format. The histogram is then plotted using `cirq.plot_state_histogram` and displayed. It requires the `results` object from a previous simulation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# A labeling function.\ndef fold_func(bits) -> str:\n    suffix = \"\".join(map(str, [bits[i][0] for i in range(1,5)]))\n    return f\"{bits[0][0]}_{suffix}\"\n\n\nhist = results.multi_measurement_histogram(keys=['meas'] + list('abcd'), fold_func=fold_func)\n\nprint(\"Results (<meas>_<data>)\")\nax = cirq.plot_state_histogram(hist)\nplt.setp(ax.get_xticklabels(), rotation=30, horizontalalignment='right')\nplt.show(ax)\n```\n\n----------------------------------------\n\nTITLE: Classical Random Walk Simulation in Python\nDESCRIPTION: This code defines a classical random walk simulation. It takes the probability of moving right, the number of steps, and the initial position as input. It simulates the walk by repeatedly flipping a weighted coin and updating the walker's position accordingly.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/quantum_walks.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Defines all of the necessary parameters\n\nN = 50    # Defines the total number of steps our walker will take\npr = 0.5  # Defines the probability of our walker stepping to the right\ni = 0     # Defines the initial position of our walker\n\ndef random_walk(pr, N, i):\n    \n    position = i\n    \n    # Repeatedly queries our random variable and moves our walker for the specified number of steps\n    \n    for j in range(N):\n    \n        coin_flip = list(np.random.choice(2, 1, p=[1-pr, pr])) # Flips our weighted coin\n        position += 2*coin_flip[0]-1 # Moves our walker according to the coin flip \n    \n    return position\n    \nprint(\"The walker is located at: x = {var}\".format(var = random_walk(pr, N, i)))\n```\n\n----------------------------------------\n\nTITLE: Plotting Quantum Volume Results\nDESCRIPTION: This snippet creates a plot of the Quantum Volume results, designed to resemble Figure 2 in the referenced research paper. It visualizes the Heavy Output Generation (HOG) probability for different samplers and circuit depths. It also includes reference lines for asymptotic ideal heavy output probability and the HOG threshold.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_volume.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Create a chart that is designed to look as similar as possible to\n# Figure 2 in https://arxiv.org/pdf/1811.12926.pdf.\n\nfrom matplotlib import pyplot as plt\n\nfig, axs = plt.subplots()\nfor idx, sampler in enumerate(samplers):\n    axs.scatter([d + idx / 10 for d in depths],\n                sampler['probabilities'].values(),\n                marker='+',\n                c=f\"{sampler['color']}\",\n                label=f\"{sampler['label']}\")\n    axs.scatter([d + idx / 10 for d in depths],\n                sampler['routed-probabilities'].values(),\n                marker=\"o\",\n                c=f\"{sampler['color']}\",\n                label=f\"{sampler['label']} Routed\")\n    axs.scatter([d + idx / 10 for d in depths],\n                sampler['compiled-probabilities'].values(),\n                marker=\"s\",\n                c=f\"{sampler['color']}\",\n                label=f\"{sampler['label']} Compiled\")\n\n# Line markers for asymptotic ideal heavy output probability and the ideal\n# Heavy Output Generation threshold.\naxs.axhline((1 + np.log(2)) / 2,\n            color='tab:green',\n            label='Asymptotic ideal',\n            linestyle='dashed')\naxs.axhline(2 / 3, label='HOG threshold', color='k', linestyle='dotted')\n# Making the plot look consistent.\naxs.set_ybound(0.0, 1)\naxs.xaxis.set_major_locator(plt.MultipleLocator(1))\naxs.set_xlabel(\"width/depth of model circuit m=d\")\naxs.set_ylabel(\"est. heavy output probability h(d)\")\nfig.suptitle('Experimental data for square quantum volume circuits')\naxs.legend(loc='best')\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq-core (Pre-release)\nDESCRIPTION: This command installs the latest pre-release version of `cirq-core` using pip. The `--upgrade` flag ensures that any existing version is updated, and `~=1.0.dev` specifies the latest version compatible with `1.*` and `dev` in the name.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install --upgrade cirq-core~=1.0.dev\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq with Pip\nDESCRIPTION: This code snippet attempts to import the Cirq library. If the import fails, it installs Cirq using pip, and then imports it again. This is a common pattern to ensure that Cirq is available in the current environment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/best_practices.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    import cirq\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Colormap Properties in Heatmap\nDESCRIPTION: This snippet shows how to modify colormap properties of a `cirq.TwoQubitInteractionHeatmap`. It updates the plot by setting the minimum and maximum values for the colormap (`vmin` and `vmax`) and changing the colormap (`cmap`) to 'plasma'.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/heatmaps.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n_, ax = plt.subplots(figsize=(8, 8))\n_ = two_qubit_interaction_heatmap.plot(ax,\n                                       title = 'Heatmap with modified Colormap',\n                                       vmin = 0.1,\n                                       vmax = 0.4,\n                                       collection_options = {\n                                           'cmap' : 'plasma'\n                                       })\n```\n\n----------------------------------------\n\nTITLE: Constructing Quantum Circuit with API Gates\nDESCRIPTION: This snippet creates a `cirq.Circuit` using the IonQ API-supported gates.  It defines three `cirq.LineQubit`s and then applies a sequence of single-qubit and two-qubit gates, including Pauli rotations, Hadamard, CNOT, SWAP, Molmer-Sorensen gates (XX, YY, ZZ), and measurements.  The resulting circuit is then printed to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/circuits.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nq0, q1, q2 = cirq.LineQubit.range(3)\ncircuit = cirq.Circuit(\n    cirq.X(q0)**0.5, cirq.Y(q1)**0.5, cirq.Z(q2)**0.25, # Pauli Pow gates\n    cirq.X(q0), cirq.Y(q1), cirq.Z(q2), # Pauli gates\n    cirq.rx(0.1)(q0), cirq.ry(0.1)(q1), cirq.rz(0.1)(q2), # Single qubit rotations\n    cirq.H(q1), # Special case of Hadamard\n    cirq.CNOT(q0, q1), cirq.SWAP(q2, q1), # Controlled-not and its SWAP cousin\n    cirq.XX(q0, q1)**0.2, cirq.YY(q1, q2)**0.2, cirq.ZZ(q2, q0)**0.2, # MS gates\n    cirq.measure(q0, key='x'), # Single qubit measurement\n    cirq.measure(q1, q2, key='y') # Two qubit measurement\n)\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Running All Tests\nDESCRIPTION: This command runs all tests in the Cirq project using pytest. It performs a comprehensive test of the entire codebase. It requires the 'check/pytest' script to be present. files-and-flags-for-pytest are optional arguments for specifying files and flags for pytest.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\n./check/pytest [files-and-flags-for-pytest]\n```\n\n----------------------------------------\n\nTITLE: Creating Quantum Teleportation Circuit in Cirq\nDESCRIPTION: This function constructs a quantum teleportation circuit using Cirq. It takes a gate as input, which prepares the message qubit in a specific state. The circuit prepares an entangled Bell state between Alice and Bob, performs a Bell measurement on Alice's qubits, and applies conditional gates on Bob's qubit based on the measurement outcomes. The function returns the constructed Cirq circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef make_quantum_teleportation_circuit(gate):\n    \"\"\"Returns a circuit for quantum teleportation.\n    \n    This circuit 'teleports' a random qubit state prepared by\n    the input gate from Alice to Bob.\n    \"\"\"\n    circuit = cirq.Circuit()\n    \n    # Get the three qubits involved in the teleportation protocol.\n    msg = cirq.NamedQubit(\"Message\")\n    alice = cirq.NamedQubit(\"Alice\")\n    bob = cirq.NamedQubit(\"Bob\")\n    \n    # The input gate prepares the message to send.\n    circuit.append(gate(msg))\n\n    # Create a Bell state shared between Alice and Bob.\n    circuit.append([cirq.H(alice), cirq.CNOT(alice, bob)])\n    \n    # Bell measurement of the Message and Alice's entangled qubit.\n    circuit.append([cirq.CNOT(msg, alice), cirq.H(msg), cirq.measure(msg, alice)])\n\n    # Uses the two classical bits from the Bell measurement to recover the\n    # original quantum message on Bob's entangled qubit.\n    circuit.append([cirq.CNOT(alice, bob), cirq.CZ(msg, bob)])\n\n    return circuit\n```\n\n----------------------------------------\n\nTITLE: Combining sweeps with zipping in Cirq\nDESCRIPTION: This snippet demonstrates how to combine two parameter sweeps using the zipping operation (`+`). It creates two sweeps, `sweep1` and `sweep2`, using `cirq.Points`, and then combines them using the `+` operator. The resulting sweep includes element-wise combinations of parameter values from the two sweeps, similar to Python's `zip` function.  If the sweeps have differing lengths, the resulting sweep will have length equal to the shortest sweep.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nsweep1 = cirq.Points(\"theta\", [1, 2, 3])\nsweep2 = cirq.Points(\"gamma\", [0, 3, 4])\n# By taking the sum of these two sweeps, you can combine the sweeps\n# elementwise (similar to python's zip function):\nfor param in sweep1 + sweep2:\n    print(param)\n```\n\n----------------------------------------\n\nTITLE: List Jobs using Quantum Engine API\nDESCRIPTION: This snippet shows how to list all jobs within a project that meet specified criteria, such as creation date and execution status, using the `cirq_google.Engine.list_jobs()` method.  It then iterates through the found jobs and prints their job ID, status, and creation time.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/engine.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq_google.engine.client.quantum import enums\n\n# Initialize the engine object\nengine = cirq_google.Engine(project_id='YOUR_PROJECT_ID')\n\n# List all the jobs on the project since 2020/09/20 that succeeded:\njobs = engine.list_jobs(created_after=datetime.date(2020,9,20),\n                        execution_states=[enums.ExecutionStatus.State.SUCCESS])\nfor j in jobs:\n   print(j.job_id, j.status(), j.create_time())\n```\n\n----------------------------------------\n\nTITLE: Computing Incremental Coverage (Full)\nDESCRIPTION: This command computes incremental test coverage for the Cirq project. It runs all tests and analyzes the coverage of changed lines. It requires the 'check/pytest-and-incremental-coverage' script to be present. BASE_REVISION is an optional argument specifying the commit to compare against.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\n./check/pytest-and-incremental-coverage [BASE_REVISION]\n```\n\n----------------------------------------\n\nTITLE: Defining Cycle Depths in Python\nDESCRIPTION: This snippet defines the cycle depths to be used in the XEB experiment. It creates a NumPy array `cycle_depths` containing a range of depths from 3 to `max_depth` (100), incrementing by 20. These depths determine the lengths of the circuits used in the experiment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# We will truncate to these lengths\nmax_depth = 100\ncycle_depths = np.arange(3, max_depth, 20)\ncycle_depths\n```\n\n----------------------------------------\n\nTITLE: Get State Probabilities from Simulator Result\nDESCRIPTION: Retrieves state probabilities from a `SimulatorResult` object.  The `.probabilities()` method returns a dictionary where keys are classical register values and values are their probabilities.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_ionq.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nresult.probabilities()\n```\n\n----------------------------------------\n\nTITLE: Recursive Sub-Circuit Transformation in Cirq\nDESCRIPTION: This code demonstrates how to recursively run a transformer on every nested sub-circuit wrapped inside a cirq.CircuitOperation by setting context.deep=True in the cirq.TransformerContext object. It also showcases how to ignore tagged circuit operations using context.tags_to_ignore.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/transformers.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nq = cirq.LineQubit.range(2)\ncircuit_op = cirq.CircuitOperation(\n    cirq.FrozenCircuit(cirq.I.on_each(*q), cirq.CNOT(*q), cirq.I(q[0]).with_tags(\"ignore\"))\n)\ncircuit = cirq.Circuit(\n    cirq.I(q[0]), cirq.I(q[1]).with_tags(\"ignore\"), circuit_op, circuit_op.with_tags(\"ignore\")\n)\nprint(\"Original Circuit:\", circuit, \"\\n\", sep=\"\\n\\n\")\n\ncontext = cirq.TransformerContext(tags_to_ignore=[\"ignore\"], deep=False)\nprint(\"Optimized Circuit with deep=False and tags_to_ignore=['ignore']:\\n\")\nprint(cirq.drop_negligible_operations(circuit, context=context), \"\\n\\n\")\n\ncontext = cirq.TransformerContext(tags_to_ignore=[\"ignore\"], deep=True)\nprint(\"Optimized Circuit with deep=True and tags_to_ignore=['ignore']:\\n\")\nprint(cirq.drop_negligible_operations(circuit, context=context), \"\\n\")\n```\n\n----------------------------------------\n\nTITLE: Creating Perturbed SQRT_ISWAP Gate Substitution in Python\nDESCRIPTION: This code creates a perturbed version of the `SQRT_ISWAP` gate by introducing a random phase shift. It defines a gate substitution function `_sub_iswap` that replaces instances of `SQRT_ISWAP` in a circuit with this perturbed version. The `phi_angles` dictionary stores a unique, randomly generated `phi` angle for each qubit pair.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom collections import defaultdict\n\nphi_angles = defaultdict(lambda: RANDOM_SEED.uniform(low=0, high=2 / 16 * np.pi))\n\n\ndef _sub_iswap(op):\n    if op.gate == cirq.SQRT_ISWAP:\n        # add coherent error to the phi angle while creating a sqrt iswap gate\n        perturbed_sqrt_iswap = cirq.PhasedFSimGate.from_fsim_rz(\n            theta=-np.pi / 4,\n            phi=phi_angles[op.qubits],\n            rz_angles_before=(0, 0),\n            rz_angles_after=(0, 0),\n        )\n\n        return perturbed_sqrt_iswap.on(*op.qubits)\n    return op\n```\n\n----------------------------------------\n\nTITLE: Plotting Fidelity vs Cycle Depth\nDESCRIPTION: This snippet defines a function `per_cycle_depth` that calculates and plots fidelity data for a given cycle depth. It calculates the fidelity using the numerator and denominator columns of the input DataFrame, plots the data points with a color corresponding to the cycle depth, and adds the plot line to a global list for the legend. The function expects a Pandas DataFrame `df` with 'x', 'y', 'numerator', 'denominator', and 'cycle_depth' columns.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/xeb_theory.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n_lines = []\ndef per_cycle_depth(df):\n    fid_lsq = df['numerator'].sum() / df['denominator'].sum()\n    \n    cycle_depth = df.name    \n    xx = np.linspace(0, df['x'].max())\n    l, = plt.plot(xx, fid_lsq*xx, color=colors[cycle_depth])\n    plt.scatter(df['x'], df['y'], color=colors[cycle_depth])\n    \n    global _lines\n    _lines += [l] # for legend\n    return pd.Series({'fidelity': fid_lsq})\n\nfids = df.groupby('cycle_depth').apply(per_cycle_depth).reset_index()\nplt.xlabel(r'$e_U - u_U$', fontsize=18)\nplt.ylabel(r'$m_U - u_U$', fontsize=18)\n_lines = np.asarray(_lines)\nplt.legend(_lines[[0,-1]], cycle_depths[[0,-1]], loc='best', title='Cycle depth')\nplt.tight_layout()\n```\n\n----------------------------------------\n\nTITLE: MixedUnitaryChannel Example in Cirq\nDESCRIPTION: This code demonstrates how to use the `MixedUnitaryChannel` to model noise in a Cirq circuit. It creates a channel that applies either the identity or the X gate with different probabilities. This example requires the `cirq` library.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/representing_noise.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nmy_channel = cirq.MixedUnitaryChannel(\n    [(0.8, cirq.unitary(cirq.I)), (0.2, cirq.unitary(cirq.X))],\n    key='op_num',\n)\ncircuit = cirq.Circuit(\n    my_channel.on(q0),\n    cirq.measure(q0, key='result')\n)\nresult = cirq.Simulator(seed=0).run(circuit, repetitions=20)\n# `op_num` and `result` are always equal.\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Importing Cirq-Quimb and Quimb Modules\nDESCRIPTION: This snippet imports `cirq.contrib.quimb` for integrating Cirq circuits with Quimb tensor network library. It imports the `quimb` and `quimb.tensor` modules to enable the use of tensor network functionalities for quantum circuit analysis.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Cirq-to-Tensor-Networks.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport cirq.contrib.quimb as ccq\nimport quimb\nimport quimb.tensor as qtn\n```\n\n----------------------------------------\n\nTITLE: Chaining Transformers and Logging\nDESCRIPTION: This example defines a transformer `reverse_and_substitute` that chains the `reverse_circuit` and `substitute_gate` transformers.  It creates a `TransformerContext` with a logger, applies the composite transformer, and displays the logged steps. The output shows the nested transformer calls with proper indentation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/custom_transformers.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@cirq.transformer\ndef reverse_and_substitute(circuit, context=None):\n    reversed_circuit = reverse_circuit(circuit, context=context)\n    reversed_and_substituted_circuit = substitute_gate(reversed_circuit, context=context)\n    return reversed_and_substituted_circuit\n\n\n# Note that you want to log the steps.\ncontext = cirq.TransformerContext(logger=cirq.TransformerLogger())\n# Transform the circuit.\ntransformed_circuit = reverse_and_substitute(circuit, context=context)\n# Show the steps.\ncontext.logger.show()\n```\n\n----------------------------------------\n\nTITLE: Defining Dataframe Selection and Plotting Functions\nDESCRIPTION: This snippet defines functions for selecting data from a pandas DataFrame based on a specified key-value pair and for plotting the performance results. The `select` function filters the DataFrame based on a column value. The `plot1` function plots the durations of Cirq and Quimb calculations against the number of moments, with labels. The `plot` function normalizes the durations by the number of calls and calls `plot1` for different qubit numbers, and adds axis labels.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Cirq-to-Tensor-Networks.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef select(df, k, v):\n    return df[df[k] == v].drop(k, axis=1)\n\npd.DataFrame.select = select\n\ndef plot1(df, labelfmt):\n    for k in ['duration_cirq', 'duration_quimb']:\n        plt.plot(df['n_moments'], df[k], '.-', label=labelfmt.format(k))\n    plt.legend(loc='best')\n\n\ndef plot(df):\n    df['duration_cirq'] /= df['n_call_cirq']\n    df['duration_quimb'] /= df['n_call_quimb']\n    plot1(df.select('n_qubits', 3), 'n = 3, {}')\n    plot1(df.select('n_qubits', 6), 'n = 6, {}')\n    plt.xlabel('N Moments')\n    plt.ylabel('Time / s')\n    \nplot(df)\nplt.tight_layout()\n```\n\n----------------------------------------\n\nTITLE: Generating Bloch Sphere HTML with cirq-web\nDESCRIPTION: This Python code demonstrates how to generate a 3D Bloch sphere visualization using the cirq-web module and save it to an HTML file. It requires the cirq and cirq_web packages. It initializes a zero state, converts it to a valid state vector, creates a BlochSphere object, and then generates the HTML file. The file can then be opened in a web browser to view the Bloch sphere.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-web/README.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nfrom cirq_web import BlochSphere\n\n# Prepare a state\nzero_state = [1+0j, 0+0j]\nstate_vector = cirq.to_valid_state_vector(zero_state)\n\n# Create and display the Bloch sphere\nsphere = BlochSphere(state_vector=state_vector)\nsphere.generate_html_file()\n```\n\n----------------------------------------\n\nTITLE: Accessing Sycamore Qubits with Grid Coordinates in Cirq (Python)\nDESCRIPTION: Demonstrates how to access qubits on the Sycamore device using grid coordinates within the Cirq framework. It uses `cirq.GridQubit(row, col)` to specify the location of a qubit on the Sycamore grid. Understanding the grid layout is essential for designing quantum circuits compatible with the Sycamore hardware.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/devices.md#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n  0123456789\n0 -----AB---\n1 ----ABCD--\n2 ---ABCDEF-\n3 --ABCDEFGH\n4 -ABCDEFGHI\n5 ABCDEFGHI-\n6 -CDEFGHI--\n7 --EFGHI---\n8 ---GHI----\n9 ----I-----\n```\n\n----------------------------------------\n\nTITLE: Unrolling CircuitOperation with mapped_circuit\nDESCRIPTION: This example demonstrates using the `mapped_circuit` method to unroll a `CircuitOperation` into a regular circuit. It shows how to unroll only the outermost layer (deep=False) and how to recursively unroll all layers (deep=True) to reveal the fully expanded circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n# A large CircuitOperation with other sub-CircuitOperations.\nprint('Original qft_3 CircuitOperation')\nprint(qft_3)\n# Unroll the outermost CircuitOperation to a normal circuit.\nprint('Single layer unroll:')\nprint(qft_3.mapped_circuit(deep=False))\n# Unroll all of the CircuitOperations recursively.\nprint('Recursive unroll:')\nprint(qft_3.mapped_circuit(deep=True))\n```\n\n----------------------------------------\n\nTITLE: PauliStringPhasor Simplification in Cirq\nDESCRIPTION: Illustrates how the printed representation of a `PauliStringPhasor` can change based on the level of simplification possible, without affecting the object's interface. It shows examples of how the output format can vary depending on simplification.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ntyprint(np.exp(2j * Xa * Zb))\ntyprint(np.exp(3j * Xa * Zb))\n```\n\n----------------------------------------\n\nTITLE: Specifying Contraction Ordering\nDESCRIPTION: This snippet demonstrates specifying a contraction ordering for the tensor network, especially useful for low-qubit-number circuits. It creates a sequence of tags indicating the order in which to contract the tensors. The tags are then used to color the graph for visualization.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Cirq-to-Tensor-Networks.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\npartial = 12\ntags_seq = [(f'i{i}b', f'i{i}f') for i in range(partial)]\ntn.graph(fix=fix, color = [x for x, _ in tags_seq] + [y for _, y in tags_seq], figsize=(8, 8))\n```\n\n----------------------------------------\n\nTITLE: Convert Simulator Result to Cirq Result\nDESCRIPTION: Converts a `SimulatorResult` object to a `cirq.Result` object using the `.to_cirq_result()` method.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_ionq.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nresult.to_cirq_result()\n```\n\n----------------------------------------\n\nTITLE: Define Modular Exponential Gate for Shor's Algorithm in Cirq\nDESCRIPTION: This snippet defines a `ModularExp` class, inheriting from `cirq.ArithmeticGate`, to implement quantum modular exponentiation.  It includes methods for initialization, register management, applying the gate, and defining circuit diagram information.  The core logic resides in the `apply` method, which calculates `(target * base**exponent) % modulus`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass ModularExp(cirq.ArithmeticGate):\n    \"\"\"Quantum modular exponentiation.\n\n    This class represents the unitary which multiplies base raised to exponent\n    into the target modulo the given modulus. More precisely, it represents the\n    unitary V which computes modular exponentiation x**e mod n:\n\n        V|y⟩|e⟩ = |y * x**e mod n⟩ |e⟩     0 <= y < n\n        V|y⟩|e⟩ = |y⟩ |e⟩                  n <= y\n\n    where y is the target register, e is the exponent register, x is the base\n    and n is the modulus. Consequently,\n\n        V|y⟩|e⟩ = (U**e|y)|e⟩\n\n    where U is the unitary defined as\n\n        U|y⟩ = |y * x mod n⟩      0 <= y < n\n        U|y⟩ = |y⟩                n <= y\n    \"\"\"\n    def __init__(\n        self,\n        target: Sequence[int],\n        exponent: Union[int, Sequence[int]],\n        base: int,\n        modulus: int\n    ) -> None:\n        if len(target) < modulus.bit_length():\n            raise ValueError(\n                f'Register with {len(target)} qubits is too small for modulus'\n                f' {modulus}'\n            )\n        self.target = target\n        self.exponent = exponent\n        self.base = base\n        self.modulus = modulus\n\n    def registers(self) -> Sequence[Union[int, Sequence[int]]]:\n        return self.target, self.exponent, self.base, self.modulus\n\n    def with_registers(\n        self, *new_registers: Union[int, Sequence[int]]\n    ) -> 'ModularExp':\n        \"\"\"Returns a new ModularExp object with new registers.\"\"\"\n        if len(new_registers) != 4:\n            raise ValueError(\n                f'Expected 4 registers (target, exponent, base, '\n                f'modulus), but got {len(new_registers)}'\n            )\n        target, exponent, base, modulus = new_registers\n        if not isinstance(target, Sequence):\n            raise ValueError(\n                f'Target must be a qubit register, got {type(target)}'\n            )\n        if not isinstance(base, int):\n            raise ValueError(\n                f'Base must be a classical constant, got {type(base)}'\n            )\n        if not isinstance(modulus, int):\n            raise ValueError(\n              f'Modulus must be a classical constant, got {type(modulus)}'\n            )\n        return ModularExp(target, exponent, base, modulus)\n\n    def apply(self, *register_values: int) -> int:\n        \"\"\"Applies modular exponentiation to the registers.\n\n        Four values should be passed in.  They are, in order:\n          - the target\n          - the exponent\n          - the base\n          - the modulus\n\n        Note that the target and exponent should be qubit\n        registers, while the base and modulus should be\n        constant parameters that control the resulting unitary.\n        \"\"\"\n        assert len(register_values) == 4\n        target, exponent, base, modulus = register_values\n        if target >= modulus:\n            return target\n        return (target * base**exponent) % modulus\n\n    def _circuit_diagram_info_(\n      self, args: cirq.CircuitDiagramInfoArgs\n    ) -> cirq.CircuitDiagramInfo:\n        \"\"\"Returns a 'CircuitDiagramInfo' object for printing circuits.\n\n        This function just returns information on how to print this operation\n        out in a circuit diagram so that the registers are labeled\n        appropriately as exponent ('e') and target ('t').\n        \"\"\"\n        assert args.known_qubits is not None\n        wire_symbols = [f't{i}' for i in range(len(self.target))]\n        e_str = str(self.exponent)\n        if isinstance(self.exponent, Sequence):\n            e_str = 'e'\n            wire_symbols += [f'e{i}' for i in range(len(self.exponent))]\n        wire_symbols[0] = f'ModularExp(t*{self.base}**{e_str} % {self.modulus})'\n        return cirq.CircuitDiagramInfo(wire_symbols=tuple(wire_symbols))\n```\n\n----------------------------------------\n\nTITLE: Creating Noiseless Virtual Engine from Templates in Python\nDESCRIPTION: This snippet demonstrates how to create a `cirq_google.SimulatedLocalEngine` instance from example processor templates. It uses the `create_noiseless_virtual_engine_from_latest_templates()` function to generate an engine with predefined device specifications, which closely match previous versions of Google quantum hardware.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/virtual_engine_interface.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nengine = cirq_google.engine.create_noiseless_virtual_engine_from_latest_templates()\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq in Editable Mode\nDESCRIPTION: These commands install individual Cirq modules (cirq-core, cirq-google, cirq-ionq, cirq-aqt) in editable mode using pip. This allows you to modify the source code of these modules and have the changes reflected immediately without reinstalling. Requires pip to be installed and the current directory to be the Cirq repository root.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\npip install -e ./cirq-core -e ./cirq-google -e ./cirq-ionq -e ./cirq-aqt\n```\n\n----------------------------------------\n\nTITLE: Cirq Installation Check\nDESCRIPTION: This code snippet checks if the `cirq` library is installed. If not, it installs Cirq using `pip` and then imports it.  This ensures the code can run even if Cirq is not already present in the environment. It handles potential `ImportError` exceptions.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/protocols.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq \n```\n\n----------------------------------------\n\nTITLE: Create Quantum Virtual Machine in Python\nDESCRIPTION: This snippet constructs a Quantum Virtual Machine that mimics a Google quantum hardware device. It involves loading device calibration data, constructing a `cirq.NoiseModel`, building a `qsimcirq.QsimSimulator` with the noise model, creating a `cirq.Device` that imposes constraints, and packaging the simulator and device into a `cirq.Engine` interface.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_basic_example.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nprocessor_id = \"weber\"  # @param {type:\"string\"}\n\n# Construct a simulator with a noise model based on the specified processor.\ncal = cirq_google.engine.load_median_device_calibration(processor_id)\nnoise_props = cirq_google.noise_properties_from_calibration(cal)\nnoise_model = cirq_google.NoiseModelFromGoogleNoiseProperties(noise_props)\nsim = qsimcirq.QSimSimulator(noise=noise_model)\n\n# Create a device from the public device description\ndevice = cirq_google.engine.create_device_from_processor_id(processor_id)\n# Build the simulated local processor from the simulator and device.\nsim_processor = cirq_google.engine.SimulatedLocalProcessor(\n    processor_id=processor_id, sampler=sim, device=device, calibrations={cal.timestamp // 1000: cal}\n)\n# Package the processor to use an Engine interface\nsim_engine = cirq_google.engine.SimulatedLocalEngine([sim_processor])\nprint(\n    \"Your quantum virtual machine\",\n    processor_id,\n    \"is ready, here is the qubit grid:\"\n    \"\\n========================\\n\",\n)\nprint(sim_engine.get_processor(processor_id).get_device())\n```\n\n----------------------------------------\n\nTITLE: Using GeneralizedAmplitudeDampingChannel in Cirq (Python)\nDESCRIPTION: This code demonstrates the use of `cirq.GeneralizedAmplitudeDampingChannel` which models bidirectional energy dissipation. It initializes two qubits, one in the |0> state and one in the |1> state using an X gate.  The generalized amplitude damping channel is then applied to both qubits with specified probabilities for energy transfer (`gamma`) and environmental excitation (`p`). The qubits are then measured and the simulation is run to observe the effect on each initialized state.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/representing_noise.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nq0, q1 = cirq.LineQubit.range(2)\ncircuit = cirq.Circuit(\n    cirq.X(q1),\n    cirq.generalized_amplitude_damp(gamma=0.2, p=0.2).on_each(q0, q1),\n    cirq.measure(q0, key='result_0'),\n    cirq.measure(q1, key='result_1'),\n)\nresult = cirq.Simulator(seed=0).run(circuit, repetitions=1000)\nprint(\"Starting in |0):\", result.histogram(key='result_0'))\nprint(\"Starting in |1):\", result.histogram(key='result_1'))\n```\n\n----------------------------------------\n\nTITLE: Plotting State Histogram of Bell State Results\nDESCRIPTION: This snippet uses Cirq's `plot_state_histogram` function to visually represent the results of the Bell state experiment. It takes the measurement histogram from the previous result and plots it, showing the probabilities of different measurement outcomes.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/rigetti/getting_started.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ncirq.plot_state_histogram(result.histogram(key='m'))\n```\n\n----------------------------------------\n\nTITLE: Calculating Theoretical Distribution Height\nDESCRIPTION: This function calculates the theoretical height of the binomial distribution for a given position in the random walk. It uses the binomial coefficient from scipy.special to compute the probability of being at a specific location after N steps, considering the probability of moving right (pr).\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/quantum_walks.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef height_calculate(x, N, pr):\n    \n    a = (N + x)/2\n    b = (N - x)/2\n    \n    if (x%2 == 0):\n        var = scipy.special.binom(N, a)*(pr**a)*((1-pr)**b)\n    else:\n        var = 0\n    return var\n\npositions = range(-1*N, N+1)\nheights = [height_calculate(x, N, pr) for x in positions]\nplt.bar(positions, heights)\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Complex PauliString Expressions\nDESCRIPTION: This code shows the associativity of the `*` operator with `PauliString` objects when combined with scalar multiplication, composition, and tensor products. It highlights how the order of operations on the same qubit must be preserved for consistent results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# The two PauliStrings from before\ntyprint(Xa * Za)\ntyprint(Xa * Zb)\n# Correct order of operations on qubit a, which merge to a single -Z operation.\ntyprint(Xa * Za * Xa)\n# Combined together with a coefficient.\ntyprint((3 + 6j) * (Xa * Za) * (Xa * Zb))\n# The same PauliString with different ordering and a split coefficient.\ntyprint(Xa * Zb * Za * (3 + 0j) * Xa * (1 + 2j))\n# A different PauliString where the terms applied to qubit a have changed order.\ntyprint(Za * Zb * Xa * (3 + 0j) * Xa * (1 + 2j))\n```\n\n----------------------------------------\n\nTITLE: Class Definition with Annotation\nDESCRIPTION: Defines a class with a type hint annotation for a variable. This snippet demonstrates the use of type hints to improve code readability and maintainability.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nclass MyClass:\n    my_variable: str\n```\n\n----------------------------------------\n\nTITLE: Using cirq.mixture Protocol\nDESCRIPTION: This snippet showcases the use of the `cirq.mixture` protocol on the `cirq.depolarize` channel. It iterates through the unitary operations and their associated probabilities, demonstrating how channels that can be represented as a mixture of unitaries can be simulated efficiently.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_74\n\nLANGUAGE: python\nCODE:\n```\nfor p, u in cirq.mixture(cirq.depolarize(0.2)):\n    print(f\"prob = {p}\\nunitary: \\n{u}\\n\")\n```\n\n----------------------------------------\n\nTITLE: Invert Mask Example in Cirq\nDESCRIPTION: This code demonstrates how to use the `invert_mask` parameter in a `cirq.measure` gate to flip the result of a measurement. The `invert_mask` field is a list of booleans indicating bits to flip in the final output.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/representing_noise.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nq0 = cirq.LineQubit(0)\ncircuit = cirq.Circuit(\n    cirq.X(q0),\n    cirq.measure(q0, key='result', invert_mask=[True])\n)\nresult = cirq.Simulator(seed=0).run(circuit, repetitions=1000)\nprint(result.histogram(key='result'))\n```\n\n----------------------------------------\n\nTITLE: Visualize Inverse QFT Circuit with Cirq in Python\nDESCRIPTION: This snippet creates an inverse QFT circuit for 4 qubits using the `make_qft_inverse` function and prints the circuit diagram. It uses `cirq.LineQubit.range(4)` to define the qubits, then constructs a `cirq.Circuit` and prints it for visualization.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Visually check the inverse QFT circuit.\"\"\"\nqubits = cirq.LineQubit.range(4)\niqft = cirq.Circuit(make_qft_inverse(qubits))\nprint(iqft)\n```\n\n----------------------------------------\n\nTITLE: Creating Batches of Circuits for Benchmarking in Cirq\nDESCRIPTION: This snippet creates batches of circuits for benchmarking purposes.  It generates three lists: one with unoptimized circuits, one with optimized and aligned circuits, and one with optimized, aligned, and spin echo-enhanced circuits.  Each list contains circuits for different cycle values.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Create all circuits.\"\"\"\nbatch = [\n    create_benchmark_circuit(qubits, cycles=c, seed=seed)\n    for c in cycle_values\n]\nbatch_with_optimization = [\n    create_benchmark_circuit(qubits, cycles=c, seed=seed, with_optimization=True, with_alignment=True)\n    for c in cycle_values\n]\nbatch_with_optimization_and_spin_echoes = [\n    create_benchmark_circuit(qubits, cycles=c, seed=seed, with_optimization=True, with_alignment=True, with_spin_echoes=True)\n    for c in cycle_values\n]\n```\n\n----------------------------------------\n\nTITLE: Connect to GKE Cluster using kubectl - Shell\nDESCRIPTION: This command connects to the cirq-infra GKE cluster using kubectl.  It requires the Cloud SDK to be installed and configured.  The command retrieves credentials for the cluster in the us-central1-a zone within the cirq-infra project. This enables kubectl to manage resources within the cluster.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/dev_tools/cirq-infra/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngcloud container clusters get-credentials cirq-infra --zone us-central1-a --project cirq-infra\n```\n\n----------------------------------------\n\nTITLE: Print Original and Substituted Circuits\nDESCRIPTION: This snippet prints the original quantum circuit and the circuit after a gate substitution, allowing for comparison of the two circuits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/custom_transformers.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nprint(\"Original Circuit:\", circuit, \"\\n\", sep=\"\\n\")\nprint(\n    \"Substituted Circuit:\",\n    substitute_gate_using_primitives(circuit, context=context),\n    \"\\n\",\n    sep=\"\\n\",\n)\n```\n\n----------------------------------------\n\nTITLE: Simulating Z Stabilizer Circuit with Fixed Noise (Cirq)\nDESCRIPTION: This snippet simulates the Z stabilizer circuit with the introduced bit-flip error. The circuit is run for 100 repetitions and the state histogram is plotted.  The expected output is a histogram showing the measure qubit consistently in the |1⟩ state, indicating that the error was detected.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nresult = simulator.run(stabilizer_circuit_with_error, repetitions=100)\nax = cirq.plot_state_histogram(result)\nplt.show(ax)\n```\n\n----------------------------------------\n\nTITLE: Defining Cycle Depths for Circuit Truncation\nDESCRIPTION: This code defines a NumPy array `cycle_depths` representing the different depths to which the random circuits will be truncated. The depths range from 1 to `MAX_DEPTH` (100) with a step of 9, effectively testing the circuit fidelity at various lengths.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/xeb_theory.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# We will truncate to these lengths\ncycle_depths = np.arange(1, MAX_DEPTH + 1, 9)\ncycle_depths\n```\n\n----------------------------------------\n\nTITLE: Plotting HOG Probability vs Routing Attempts\nDESCRIPTION: This snippet generates a plot showing the Heavy Output Generation (HOG) probability as a function of the number of routing attempts. It imports `matplotlib.pyplot` and `statistics`. It calculates the mean sampler result for each routing attempt and then plots these probabilities against the corresponding number of routing attempts.  It also adds horizontal lines representing the asymptotic ideal HOG probability and the HOG threshold.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_volume_routing.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Create a chart that plots the HOG rate relative to the simulated error ratio.\n\nfrom matplotlib import pyplot as plt\nimport statistics\n\nprobs = []\nfor idx, r in enumerate(routing_attempts):\n    result = results[idx]\n    probs.append(statistics.mean([res.sampler_result for res in result]))\n\nfig, axs = plt.subplots()\naxs.plot(routing_attempts, probs)\n\n# Line markers for asymptotic ideal heavy output probability and the ideal Heavy\n# Output Generation threshold.\naxs.axhline((1 + np.log(2)) / 2,\n            color='tab:green',\n            label='Asymptotic ideal',\n            linestyle='dashed')\naxs.axhline(2 / 3, label='HOG threshold', color='k', linestyle='dotted')\naxs.set_ybound(0.4, 1)\naxs.set_xlabel(\"Number of routing attempts\")\naxs.set_ylabel(\"est. heavy output probability\")\nfig.suptitle(f'HOG probability by number of routing attempts for d={depth}')\n```\n\n----------------------------------------\n\nTITLE: Defining a custom channel with cirq.Gate\nDESCRIPTION: Defines a custom quantum channel, `BitAndPhaseFlipChannel`, as a subclass of `cirq.Gate`. This channel implements a mixed operation involving the identity and Y gates with probabilities determined by the parameter `p`. The `_mixture_` method specifies the probabilities and unitary operations, and `_has_mixture_` indicates that a mixture is defined.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass BitAndPhaseFlipChannel(cirq.Gate):\n    def _num_qubits_(self) -> int:\n        return 1\n\n    def __init__(self, p: float) -> None:\n        self._p = p\n\n    def _mixture_(self):\n        ps = [1.0 - self._p, self._p]\n        ops = [cirq.unitary(cirq.I), cirq.unitary(cirq.Y)]\n        return tuple(zip(ps, ops))\n\n    def _has_mixture_(self) -> bool:\n        return True\n\n    def _circuit_diagram_info_(self, args) -> str:\n        return f\"BitAndPhaseFlip({self._p})\"\n```\n\n----------------------------------------\n\nTITLE: Importing Cirq and AQT Modules in Python\nDESCRIPTION: This snippet imports necessary modules from Cirq and Cirq's AQT module for interacting with AQT's quantum devices and samplers. It also defines a placeholder for the AQT access token which should be replaced with the user's actual token.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/aqt/getting_started.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nfrom cirq.aqt.aqt_device import get_aqt_device\nfrom cirq.aqt.aqt_sampler import AQTSampler\naccess_token = 'MY_TOKEN'\n```\n\n----------------------------------------\n\nTITLE: Printing a Cirq Circuit\nDESCRIPTION: This snippet demonstrates how to print a Cirq circuit to the console. This is a common debugging and visualization technique to inspect the structure and contents of a quantum circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Defining Valid Qubits in Cirq\nDESCRIPTION: This configuration specifies a list of valid qubit IDs within the Cirq environment. These strings represent the physical or logical qubits that can be used in quantum circuits and algorithms.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-google/cirq_google/devices/specifications/weber_2021_12_10_device_spec.proto.txt#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nvalid_qubits: \"0_5\"\nvalid_qubits: \"0_6\"\nvalid_qubits: \"1_4\"\nvalid_qubits: \"1_5\"\nvalid_qubits: \"1_6\"\nvalid_qubits: \"1_7\"\nvalid_qubits: \"2_4\"\nvalid_qubits: \"2_5\"\nvalid_qubits: \"2_6\"\nvalid_qubits: \"2_7\"\nvalid_qubits: \"2_8\"\nvalid_qubits: \"3_2\"\nvalid_qubits: \"3_3\"\nvalid_qubits: \"3_4\"\nvalid_qubits: \"3_5\"\nvalid_qubits: \"3_6\"\nvalid_qubits: \"3_7\"\nvalid_qubits: \"3_8\"\nvalid_qubits: \"3_9\"\nvalid_qubits: \"4_1\"\nvalid_qubits: \"4_2\"\nvalid_qubits: \"4_3\"\nvalid_qubits: \"4_4\"\nvalid_qubits: \"4_5\"\nvalid_qubits: \"4_6\"\nvalid_qubits: \"4_7\"\nvalid_qubits: \"4_8\"\nvalid_qubits: \"4_9\"\nvalid_qubits: \"5_0\"\nvalid_qubits: \"5_1\"\nvalid_qubits: \"5_2\"\nvalid_qubits: \"5_3\"\nvalid_qubits: \"5_4\"\nvalid_qubits: \"5_5\"\nvalid_qubits: \"5_6\"\nvalid_qubits: \"5_7\"\nvalid_qubits: \"5_8\"\nvalid_qubits: \"6_1\"\nvalid_qubits: \"6_2\"\nvalid_qubits: \"6_3\"\nvalid_qubits: \"6_4\"\nvalid_qubits: \"6_5\"\nvalid_qubits: \"6_6\"\nvalid_qubits: \"6_7\"\nvalid_qubits: \"7_2\"\nvalid_qubits: \"7_3\"\nvalid_qubits: \"7_4\"\nvalid_qubits: \"7_5\"\nvalid_qubits: \"7_6\"\nvalid_qubits: \"8_3\"\nvalid_qubits: \"8_4\"\nvalid_qubits: \"8_5\"\nvalid_qubits: \"9_4\"\n```\n\n----------------------------------------\n\nTITLE: Circuit with Multiple Expressions - Python\nDESCRIPTION: This code creates a circuit with multiple gates containing symbolic expressions. Specifically, it constructs a circuit where qubit `q0` undergoes an X rotation by an angle `a / 4` and a Y rotation by an angle `1 - a / 2`, followed by a measurement.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\na = sympy.Symbol('a')\ncircuit = cirq.Circuit(cirq.X(q0)**(a / 4), cirq.Y(q0)**(1 - a / 2), cirq.measure(q0))\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Using Custom Gate in a Cirq Circuit\nDESCRIPTION: This code snippet creates a Cirq circuit that uses the custom gate defined in the previous snippet. It applies the gate to a qubit and then prints the circuit, demonstrating how the custom gate is represented in the circuit diagram.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/custom_gates.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncirc = cirq.Circuit(\n    my_gate.on(cirq.LineQubit(0))\n)\n\nprint(\"Circuit with custom gates:\")\nprint(circ)\n```\n\n----------------------------------------\n\nTITLE: Iteratively Simplifying Circuit (k=1,2)\nDESCRIPTION: This iteratively simplifies a quantum circuit by first merging 2-qubit unitaries and then 1-qubit unitaries.  Negligible operations are then dropped and empty moments are removed before printing the final number of operations and qubits and rendering an SVG of the simplified circuit. This requires the 'compressed_c' circuit defined previously.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ncompressed_c= cirq.merge_k_qubit_unitaries(compressed_c, k=2)\ncompressed_c = cirq.merge_k_qubit_unitaries(compressed_c, k=1)\n\ncompressed_c = cirq.drop_negligible_operations(compressed_c, atol=1e-6)\ncompressed_c = cirq.drop_empty_moments(compressed_c)\nprint(len(list(compressed_c.all_operations())), len(compressed_c.all_qubits()))\nSVGCircuit(compressed_c)\n```\n\n----------------------------------------\n\nTITLE: Plotting Benchmarking Results in Cirq\nDESCRIPTION: This snippet plots the survival probabilities of the different circuit batches against the number of cycles. It uses Matplotlib to generate a plot showing the performance of unoptimized circuits, optimized circuits, and circuits with spin echoes.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Plot results.\"\"\"\nlabels = [\"Unoptimized\", \"Optimization + Alignment\", \"Optimization + Alignment + Spin echoes\"]\n\nfor (probs, label) in zip(all_probs, labels):\n    plt.plot(cycle_values, probs, \"-o\", label=label)\n\nplt.xlabel(\"Cycles\")\nplt.ylabel(\"Survival probability\")\nplt.legend();\n```\n\n----------------------------------------\n\nTITLE: Git Log for Commit History\nDESCRIPTION: This shell command retrieves all commits since the last release, formatting them with the commit hash and subject.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/release.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\ngit log \"--pretty=%h %s\"\n```\n\n----------------------------------------\n\nTITLE: Coloring Plots by Cycle Depth using Seaborn\nDESCRIPTION: This snippet uses the Seaborn library to generate a color palette based on the cycle depths of the XEB experiment. It maps each cycle depth to a unique color from the palette, which is later used to color data points in the plots. The cycle depths are expected to be available in a variable called `cycle_depths`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/xeb_theory.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport seaborn as sns\ncolors = sns.cubehelix_palette(n_colors=len(cycle_depths))\ncolors = {k: colors[i] for i, k in enumerate(cycle_depths)}\n```\n\n----------------------------------------\n\nTITLE: Print Cirq Result\nDESCRIPTION: Prints the `cirq.Result` object returned after running a quantum circuit on Azure Quantum.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_ionq.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Simulating Stabilizer Code Encoding\nDESCRIPTION: This snippet simulates the stabilizer code encoding circuit for initial states 0 and 1. The results are printed in Dirac notation to visualize the encoded states.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/stabilizer_code.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfor initial_state in [0, 1]:\n    results = cirq.Simulator().simulate(circuit, qubit_order=qubits, initial_state=initial_state)\n    print('%d becomes %s' % (initial_state, cirq.dirac_notation(results.state_vector())))\n```\n\n----------------------------------------\n\nTITLE: Running All Continuous Integration Checks\nDESCRIPTION: This command runs all continuous integration checks for the Cirq project. It performs formatting, linting, testing, and coverage analysis. It requires the 'check/all' script to be present. BASE_REVISION, --only-changed-files, and --apply-format-changes are optional arguments.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\n./check/all [BASE_REVISION] [--only-changed-files] [--apply-format-changes]\n```\n\n----------------------------------------\n\nTITLE: Validating a Circuit Against the Sycamore Device in Cirq with Python\nDESCRIPTION: This code snippet demonstrates how to validate a Cirq circuit against the constraints of the Sycamore device. It creates adjacent and non-adjacent qubit pairs, creates operations using the Sycamore gate, and then validates circuits containing these operations. A working circuit with adjacent qubits raises no issues, while a circuit with non-adjacent qubits raises a ValueError.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Create some qubits.\nq0 = cirq.GridQubit(5, 6)\nq1 = cirq.GridQubit(5, 5)\nq2 = cirq.GridQubit(4, 5)\n\n# Create operations using the Sycamore gate, which is supported by the Sycamore device.\n# However, create operations for both adjacent and non-adjacent qubit pairs.\nadjacent_op = cirq_google.SYC(q0, q1)\nnonadjacent_op = cirq_google.SYC(q0, q2)\n\n# A working circuit for the Sycamore device raises no issues.\nworking_circuit = cirq.Circuit()\nworking_circuit.append(adjacent_op)\nvalid = cirq_google.Sycamore.validate_circuit(working_circuit)\n\n# A circuit using invalid operations.\nbad_circuit = cirq.Circuit()\nbad_circuit.append(nonadjacent_op)\ntry:\n    cirq_google.Sycamore.validate_circuit(bad_circuit)\nexcept ValueError as e:\n    print(e)\n```\n\n----------------------------------------\n\nTITLE: Retrieving XEB Errors and Fidelity with Cirq\nDESCRIPTION: This code snippet retrieves and prints the Pauli error, XEB error, and XEB fidelity from the `TwoQubitXEBResult` object.  These metrics provide quantitative measures of the performance of the two-qubit gate being characterized.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# `TwoQubitXEBResult` also has methods to retrieve errors.\nprint('pauli errors:', result.pauli_error())\nprint('xeb errors:', result.xeb_error(*qubits[:2]))\nprint('xeb fidelity:', result.xeb_fidelity(*qubits[:2]))\n```\n\n----------------------------------------\n\nTITLE: Download historical results using Engine API\nDESCRIPTION: This snippet demonstrates how to download historical results from the Quantum Engine API, given a program ID and a job ID. It recreates the job object using the `get_program` and `get_job` methods and retrieves the historical results, assuming the program and job IDs have been saved from a previous run. It uses sympy to define a symbolic parameter in the circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/engine.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Initialize the engine object\nengine = cirq_google.Engine(project_id='YOUR_PROJECT_ID')\n\n# Create an example circuit\nqubit = cirq.GridQubit(5, 2)\ncircuit = cirq.Circuit(\n    cirq.X(qubit)**sympy.Symbol('t'),\n    cirq.measure(qubit, key='result')\n)\nparam_sweep = cirq.Linspace('t', start=0, stop=1, length=10)\n\n# Run the circuit\njob = e.run_sweep(program=circuit,\n                  params=param_sweep,\n                  repetitions=1000,\n                  processor_id='PROCESSOR_ID',\n                  gate_set=GATE_SET)\n\n# Save the program and jo id for later\nprogram_id = job.program_id\njob_id = job.job_id\n\n# Retrieve the results\nresults = job.results()\n\n# ...\n# Some time later, the results can be retrieved\n# ...\n\n# Recreate the job object\nhistorical_job = engine.get_program(program_id=program_id).get_job(job_id=job_id)\n\n# Retrieve the results\nhistorical_results = historical_job.results()\n```\n\n----------------------------------------\n\nTITLE: Plotting Simulation Results with Matplotlib\nDESCRIPTION: This snippet plots the simulation results using `matplotlib`. The expectation values are extracted from the `results` list, and a scatter plot is generated with theta values on the x-axis and expectation values on the y-axis. The plot is labeled and displayed. The x-axis is formatted with symbolic labels for specific theta values.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_utility_sim_4b.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Each element of \"results\" is a list of one expectation value (for Z[62]).\nplot_results = [x[0].real for x in results]\n\n# Plot the results in the format of Fig. 4b.\nplt.plot(np.array(theta_values), plot_results, 'bo')\nplt.xlabel(r\"$ R_X $ angle $ \\theta_h $\")\nplt.ylabel(r\"$ \\langle Z_{62} \\rangle $\")\nplt.xticks(np.linspace(0, np.pi / 2, 5), [\"0\", \"π/8\", \"π/4\", \"3π/8\", \"π/2\"])\nplt.yticks(np.linspace(0, 1, 6))\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Placing a Circuit with RandomDevicePlacer in Cirq\nDESCRIPTION: This snippet demonstrates using `RandomDevicePlacer` to map the circuit onto the device. It initializes the placer, calls `place_circuit` to get the placed circuit and placement map, and visualizes the placement using `cirq.draw_placements`. The `RandomDevicePlacer` finds a random, valid placement using networkx subgraph monomorphism routines.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/qubit-placement.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq_google.workflow import NaiveQubitPlacer, RandomDevicePlacer, HardcodedQubitPlacer\nrdp = RandomDevicePlacer()\n\nplaced_c, placement = rdp.place_circuit(circuit, problem_topology=topo, shared_rt_info=shared_rt_info, rs=rs)\ncirq.draw_placements(rainbow_graph, circuit_graph, [placement])\n```\n\n----------------------------------------\n\nTITLE: Mermaid Diagram: Feature Request Workflow\nDESCRIPTION: This Mermaid diagram illustrates the workflow for triaging feature requests within the Cirq project. It visually represents the steps involved in evaluating and processing new feature requests, from initial submission to acceptance or closure. The diagram helps in understanding the decision-making process and the different stages a feature request goes through.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/triage.md#_snippet_0\n\nLANGUAGE: Mermaid\nCODE:\n```\ngraph TD\\\n\\tA[Untriaged Feature Request] --> K\\\n    K[label: kind/feature-request] --> ND{Needs discussion?}\\\n    ND --> |yes| F[label: triage/discuss & Cirq Cynque]     \\\n    ND --> |no| B{Should we do this?}\\\n    F --> B\\\n\\tB --> |no| E[CLOSED]\\\n    B --> |yes| D\\\n    B --> |we are not sure it's feasible | DP[label: triage/needs-feasibility]  \\\n    B --> |maybe if enough people request it| EVI[label: triage/awaiting-more-evidence]\\\n    DP --> |design proposed/improved| ND      \\\n    D[label: triage/accepted]\\\n    DP --> |stale after 60d|E\\\n    EVI --> |stale after 60d|E\\\n\n\n    style D fill:#00FF00        \\\n    style E fill:#FF0000\n```\n\n----------------------------------------\n\nTITLE: Constructing a Frozen Circuit Directly\nDESCRIPTION: This snippet demonstrates a more concise way to construct a circuit operation with a frozen circuit by directly creating a `cirq.FrozenCircuit` inside the `cirq.CircuitOperation`. This avoids the separate freezing step.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit(\n    cirq.CircuitOperation(\n        cirq.FrozenCircuit(cirq.H(q1), cirq.CZ(q0, q1), cirq.CZ(q2, q1), cirq.H(q1))\n    )\n)\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Accessing Fidelities Dataframe after Characterization in Cirq\nDESCRIPTION: This snippet retrieves the dataframe containing fidelities calculated after the characterization process. The `characterization_result` object stores the fidelities data. Dependencies include `characterize_phased_fsim_parameters_with_xeb_by_pair` and the dataframes used by this function.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ncharacterization_result.fidelities_df\n```\n\n----------------------------------------\n\nTITLE: Simulating a Quantum Circuit with Noise in Cirq\nDESCRIPTION: This code snippet creates a density matrix simulator with depolarizing noise applied to each qubit. This simulator is then used for running the quantum circuit. The noise model uses cirq.depolarize with a probability of 0.1.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/direct_fidelity_estimation.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# We then create a sampler. For this example, we use a simulator but the code can accept a hardware sampler.\nnoise = cirq.ConstantQubitNoiseModel(cirq.depolarize(0.1))\nsampler = cirq.DensityMatrixSimulator(noise=noise)\n```\n\n----------------------------------------\n\nTITLE: Checkout and Create a New Branch - Git\nDESCRIPTION: This command checks out the `main` branch and creates a new branch named `new_branch_name` from it.  It's used to isolate changes during development.  The `new_branch_name` should be replaced with a descriptive name for the feature or fix being implemented.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit checkout main -b new_branch_name\n```\n\n----------------------------------------\n\nTITLE: Quantum Order Finder Python\nDESCRIPTION: This function implements the quantum order finder. It creates the order finding circuit using `make_order_finding_circuit`, samples from the circuit using `cirq.sample`, and then processes the measurement result using the `process_measurement` function. It requires the `make_order_finding_circuit` function and the `process_measurement` function.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndef quantum_order_finder(x: int, n: int) -> Optional[int]:\n    \"\"\"Computes smallest positive r such that x**r mod n == 1.\n    \n    Args:\n        x: integer whose order is to be computed, must be greater than one\n           and belong to the multiplicative group of integers modulo n (which\n           consists of positive integers relatively prime to n),\n        n: modulus of the multiplicative group.\n    \"\"\"\n    # Check that the integer x is a valid element of the multiplicative group\n    # modulo n.\n    if x < 2 or n <= x or math.gcd(x, n) > 1:\n        raise ValueError(f'Invalid x={x} for modulus n={n}.')\n\n    # Create the order finding circuit.\n    circuit = make_order_finding_circuit(x, n)\n    \n    # Sample from the order finding circuit.\n    measurement = cirq.sample(circuit)\n    \n    # Return the processed measurement result.\n    return process_measurement(measurement, x, n)\n```\n\n----------------------------------------\n\nTITLE: Deutsch-Jozsa Algorithm Solution with Cirq\nDESCRIPTION: This code implements the Deutsch-Jozsa algorithm using Cirq. It initializes the target qubit to the $|-\\rangle$ state, applies Hadamard gates to the input qubits, queries the oracle, and then applies Hadamard gates again. Finally, it uses CCX and X gates to put the result in the final qubit before measurement.  It depends on Cirq library for building and using quantum gates and circuits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_42\n\nLANGUAGE: python\nCODE:\n```\ndef dj_circuit(oracle):\n    # Phase kickback trick.\n    yield cirq.X(q2), cirq.H(q2)\n\n    # Get an equal superposition over input bits.\n    yield cirq.H(q0), cirq.H(q1)\n\n    # Query the function.\n    yield oracle\n\n    # Use interference to get result, put last qubit into |1>.\n    yield cirq.H(q0), cirq.H(q1), cirq.H(q2)\n\n    # Use a final OR gate to put result in final qubit.\n    yield cirq.X(q0), cirq.X(q1), cirq.CCX(q0, q1, q2)\n    yield cirq.measure(q2)\n```\n\n----------------------------------------\n\nTITLE: Creating Optimized Benchmark Circuit with Alignment and Spin Echoes in Cirq\nDESCRIPTION: This snippet creates a benchmark circuit with optimization, alignment, and spin echoes enabled. The `with_optimization`, `with_alignment`, and `with_spin_echoes` parameters are set to `True`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\noptimized_circuit_with_spin_echoes = create_benchmark_circuit(qubits, cycles=2, seed=1, with_optimization=True, with_alignment=True, with_spin_echoes=True)\nprint(f\"Circuit with optimization + alignment + spin echoes ({len(optimized_circuit_with_spin_echoes)} moments):\\n\")\noptimized_circuit_with_spin_echoes\n```\n\n----------------------------------------\n\nTITLE: Creating Github Token Secret\nDESCRIPTION: This command creates a Kubernetes secret named `triage-party-github-token` in the `triage-party` namespace. It reads the Github token from the file specified by `$HOME/.github-token` and stores it in the secret.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/dev_tools/triage-party/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nkubectl create secret generic triage-party-github-token -n triage-party --from-file=token=$HOME/.github-token\n```\n\n----------------------------------------\n\nTITLE: Loschmidt Echo Circuit Visualization\nDESCRIPTION: This snippet demonstrates how to create and visualize a Loschmidt echo circuit using the `create_loschmidt_echo_circuit` function. It creates a circuit with a 2x2 grid of qubits, 2 cycles, and a pause of 5 nanoseconds. The circuit is then displayed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/echoes.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"See an example circuit.\"\"\"\ncircuit = create_loschmidt_echo_circuit(\n    qubits=cirq.GridQubit.square(2), cycles=2, pause=cirq.Duration(nanos=5.0)\n)\ncircuit\n```\n\n----------------------------------------\n\nTITLE: Listing Processors and Devices in Python\nDESCRIPTION: This code iterates through the processors available in the virtual engine and prints their IDs and device layouts. It retrieves each processor using `engine.list_processors()` and then prints the processor ID and its device specification obtained using `proc.get_device()`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/virtual_engine_interface.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfor proc in engine.list_processors():\n    print(proc.processor_id)\n    print('-----------------')\n    print(proc.get_device())\n    print('\\n\\n\\n')\n```\n\n----------------------------------------\n\nTITLE: Objective Function Calculation for VQE in Cirq\nDESCRIPTION: This code defines a function `obj_func` that calculates the expectation value of the objective function based on the simulation results. It takes a `result` object (from `simulator.run`) as input, calculates the energy histogram using the `energy_func`, and computes the average energy over all repetitions. The expectation value is then printed to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/variational_algorithm.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef obj_func(result):\n    energy_hist = result.histogram(key='x', fold_func=energy_func(3, h, jr, jc))\n    return np.sum([k * v for k,v in energy_hist.items()]) / result.repetitions\nprint(f'Value of the objective function {obj_func(results)}')\n```\n\n----------------------------------------\n\nTITLE: Installing pre-release version of cirq-google using pip\nDESCRIPTION: This command installs the latest pre-release version of cirq-google using pip. The `~=` operator ensures compatibility with the 1.* development versions. This provides access to the newest features but might include unstable code.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-google/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install --upgrade cirq-google~=1.0.dev\n```\n\n----------------------------------------\n\nTITLE: Initializing Z Stabilizer Circuit with Fixed Noise (Cirq)\nDESCRIPTION: This snippet introduces a fixed noise by applying an X gate to a randomly chosen data qubit before running the Z stabilizer circuit.  This simulates a single bit-flip error on one of the data qubits.  The measure qubit will flip to reflect the parity change introduced by the error.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nrandom_data_qubit = random.choice(data_qubits)\nstabilizer_circuit_with_error = cirq.X(random_data_qubit) + stabilizer_circuit\n\nprint(f'Z-stabilizer circuit with single error:')\nprint('========================')\nprint(stabilizer_circuit_with_error)\n```\n\n----------------------------------------\n\nTITLE: Adding Upstream Remote to Git\nDESCRIPTION: This command adds a remote named 'upstream' to your local git repository, pointing to the main Cirq repository. This allows you to fetch and merge changes from the official Cirq repository into your local fork. It requires git to be installed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ngit remote add upstream https://github.com/quantumlib/Cirq.git\n```\n\n----------------------------------------\n\nTITLE: HTML Script Inclusion Example HTML\nDESCRIPTION: This snippet demonstrates how to include a bundled Javascript file in an HTML file. It assumes the bundled file is named `YOUR_VIZ_NAME.bundle.js` and is located in the root directory.  Replace `YOUR_VIZ_NAME` with the correct name of your bundled javascript file.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-web/cirq_ts/README.md#_snippet_2\n\nLANGUAGE: HTML\nCODE:\n```\n<script src=\"/YOUR_VIZ_NAME.bundle.js\"></script>\n```\n\n----------------------------------------\n\nTITLE: Cirq Installation Python\nDESCRIPTION: This snippet checks if the `cirq` library is installed. If not, it installs it using `pip`. This ensures that the notebook can run even if the environment doesn't have Cirq installed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/hidden_linear_function.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Evaluating Confusion Matrix for Fourier Checking\nDESCRIPTION: This snippet generates a confusion matrix by running the Fourier Checking algorithm multiple times with functions drawn from either the uniform (U) set or the forrelation (F) set. It evaluates the performance of the algorithm, showing acceptance/rejection rates for both types of function pairs.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nres = pd.DataFrame()\nrepetitions = 100\nnum_rounds = 1000\nfor _ in range(num_rounds):\n    if np.random.rand() > 0.5:\n        fs, gs, _, _ = draw_two_distribution_from_f_set(N)\n        source = \"F set\"\n    else:\n        fs, gs, _, _ = draw_two_distribution_from_u_set(N)\n        source = \"U set\"\n\n    circuit = cirq.Circuit(fourier_checking_algorithm(qubits, fs, gs))\n    obs = s.run(circuit, repetitions=repetitions)\n    times_zero_was_measured = len(obs.data[obs.data[qubits_name] == 0])\n    decision = \"accept\" if times_zero_was_measured / repetitions > 0.05 else \"reject\"\n    res=pd.concat([res, pd.DataFrame({\n        \"Source\": [source],\n        \"Decision\":[decision],\n        \"Count\": [1]\n    })], ignore_index=True)\nconfusion = res.pivot_table(index=\"Source\", columns=\"Decision\", values=\"Count\", aggfunc=\"sum\")\n# Translate the counts into percentage\nconfusion.div(confusion.sum(axis=1), axis=0).apply(lambda x: round(x, 4) * 100)\n```\n\n----------------------------------------\n\nTITLE: Update Local Main and Merge - Git\nDESCRIPTION: This series of commands updates the local `main` branch with the latest changes from the upstream Cirq repository and then merges those changes into the feature branch. This ensures the feature branch is up-to-date and minimizes merge conflicts.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# Track the upstream repo (if your local repo hasn't):\ngit remote add upstream https://github.com/quantumlib/Cirq.git\n\n# Update your local main.\ngit fetch upstream\ngit checkout main\ngit merge upstream/main\n# Merge local main into your branch.\ngit checkout new_branch_name\ngit merge main\n```\n\n----------------------------------------\n\nTITLE: Importing Cirq and Cirq-Pasqal\nDESCRIPTION: This snippet imports the necessary Cirq and Cirq-Pasqal libraries. It attempts to import `cirq`, and if it fails, installs it using `pip` before re-attempting the import. It then imports specific classes from `cirq` and `cirq_pasqal` that are used throughout the notebook to define qubits, devices, and noise models.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/pasqal/getting_started.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\nimport cirq_pasqal\nfrom cirq_pasqal import ThreeDQubit, TwoDQubit, PasqalVirtualDevice, PasqalNoiseModel\n```\n\n----------------------------------------\n\nTITLE: Creating a Quantum Circuit using LineQubits and CNOTs in Cirq\nDESCRIPTION: This snippet shows how to create a quantum circuit using LineQubits, Hadamard gates, and CNOT gates. It defines four line qubits, applies Hadamard gates to the first two, applies CNOT gates, and a Hadamard gate to the second qubit. The resulting circuit is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Creating a circuit.\"\"\"\n# Define four line qubits. NamedQubits would also work, however this demonstrates a more succint syntax.\nq = cirq.LineQubit.range(4)\n\n# Define a list of operations.\nops = [cirq.H(q[0]), cirq.H(q[1]), cirq.CNOT(q[1], q[2]), cirq.CNOT(q[0], q[3]), cirq.H(q[1])]\n\n# Create a circuit from the list of operations.\nprint(\"Circuit:\\n\")\nprint(cirq.Circuit(ops))\n```\n\n----------------------------------------\n\nTITLE: License Header\nDESCRIPTION: This section displays the Apache 2.0 license, specifying the permissions and limitations under which the code can be used. It ensures proper attribution and usage guidelines.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/_template.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#@title Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n```\n\n----------------------------------------\n\nTITLE: Contracting Tensor Network Cumulatively\nDESCRIPTION: This snippet performs a cumulative contraction of the tensor network using the specified tag sequence. The `contract_cumulative` method from Quimb is used to perform the contraction, and the resulting tensor network is visualized.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Cirq-to-Tensor-Networks.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ntn2 = tn.contract_cumulative(tags_seq, inplace=False)\ntn2.graph(fix=fix, color=['Q0', 'Q1', 'Q2', 'kQ1'], figsize=(8, 8))\n```\n\n----------------------------------------\n\nTITLE: Displaying Measurement Gates in Cirq\nDESCRIPTION: This snippet uses the display_gates function to display documentation for the measurement gate MeasurementGate. The display_gates function retrieves each gate from the cirq module and displays its docstring using IPython.display.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndisplay_gates(\"MeasurementGate\")\n```\n\n----------------------------------------\n\nTITLE: Randomized Algorithm to Determine Function Type in Python\nDESCRIPTION: This code defines a function `randomized_alg` that samples a given function at a specified number of random inputs. Based on the sampled outputs, it guesses whether the function is balanced or constant. If all sampled outputs are the same, it guesses that the function is constant; otherwise, it guesses that the function is balanced. It requires a numpy array as input and an integer indicating sample size.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef randomized_alg(f:np.ndarray, sample_size:int) -> str:\n    \"\"\"Samples the function f from `sample_size` different inputs.\n\n    Queries the function f a number of times equal to sample_size.\n    If all the inputs are the same, then guess that the function\n    is constant.  If any inputs are different, then guess the function\n    is balanced.\n\n    Args:\n        f: the function to sample\n        sample_size: number of times to sample the function f\n\n    Returns:\n        a string representing the type of function, either\n            \"balanced\" or \"constant\"\n    \"\"\"\n    N = len(f)\n    sample_index = np.random.choice(N, size=sample_size)\n    if len(set(f[sample_index])) == 2:\n        return \"balanced\"\n    return \"constant\"\n```\n\n----------------------------------------\n\nTITLE: Install Cirq in Python\nDESCRIPTION: This code snippet attempts to import the Cirq library and, if it fails, installs it using pip.  It prints messages to the console indicating whether Cirq was already installed or if the installation was successful. This ensures the necessary quantum computing library is available.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Aligning Gates to the Right in Cirq\nDESCRIPTION: This snippet aligns the gates in the circuit as far right as possible using the `cirq.align_right` function. This might be useful in specific scenarios where right-alignment is preferred.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nright_aligned_circuit = cirq.align_right(circuit)\nright_aligned_circuit\n```\n\n----------------------------------------\n\nTITLE: Importing Cirq and other Libraries in Python\nDESCRIPTION: This snippet imports necessary libraries for the rest of the notebook, including `cirq` for quantum circuit manipulation, `numpy` for numerical operations, and `matplotlib` for plotting.  The `%matplotlib inline` magic command configures matplotlib to display plots inline within the notebook.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport numpy as np\n\n%matplotlib inline\nfrom matplotlib import pyplot as plt\n```\n\n----------------------------------------\n\nTITLE: Defining Qubits and Pauli Operations\nDESCRIPTION: This code snippet defines three qubits using `cirq.LineQubit.range` and creates four Pauli operations (Xa, Xb, Za, Zb) using `cirq.X` and `cirq.Z` applied to the defined qubits. The utility function `typrint` is used to display the types and values of these Pauli operations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# A couple qubits.\na, b, c = cirq.LineQubit.range(3)\n# A set of Pauli operations to build PauliStrings from.\nXa = cirq.X(a)\nXb = cirq.X(b)\nZa = cirq.Z(a)\nZb = cirq.Z(b)\n\n# Test the typrint function.\ntyprint(Xa, Xb, Za, Zb)\n```\n\n----------------------------------------\n\nTITLE: Deutsch's Algorithm Circuit with Cirq\nDESCRIPTION: This Python code defines a function `deutsch_algorithm` that constructs a quantum circuit for Deutsch's algorithm, given an oracle representing a boolean function. The circuit applies Hadamard gates to the input qubits, queries the oracle, and then applies another Hadamard gate before measuring the output qubit. It depends on the Cirq library for quantum circuit construction.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_37\n\nLANGUAGE: python\nCODE:\n```\noracles = {\n    '0': [],\n    '1': [cirq.X(q1)],\n    'x': [cirq.CNOT(q0, q1)],\n    'notx': [cirq.CNOT(q0, q1), cirq.X(q1)],\n}\n\n\"\"\"Creating the circuit used in Deutsch's algorithm.\"\"\"\n\n\ndef deutsch_algorithm(oracle):\n    \"\"\"Returns the circuit for Deutsch's algorithm given an input\n    oracle, i.e., a sequence of operations to query a particular function.\n    \"\"\"\n    yield cirq.X(q1)\n    yield cirq.H(q0), cirq.H(q1)\n    yield oracle\n    yield cirq.H(q0)\n    yield cirq.measure(q0)\n\n\nfor key, oracle in oracles.items():\n    print(f\"Circuit for f_{key}:\")\n    print(cirq.Circuit(deutsch_algorithm(oracle)), end=\"\\n\\n\")\n```\n\n----------------------------------------\n\nTITLE: Export Circuit to QASM - Python\nDESCRIPTION: This snippet demonstrates how to export a Cirq circuit to the QASM (Quantum Assembly Language) format using the `circuit.to_qasm()` method.  It creates a simple circuit with Hadamard, CNOT, and CCZ gates and then prints its QASM representation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_88\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Export a circuit to Qasm.\"\"\"\na, b, c = cirq.LineQubit.range(3)\ncircuit = cirq.Circuit(cirq.H(a), cirq.H(c), cirq.CNOT(a, b), cirq.CCZ(a, b, c))\nprint(circuit.to_qasm())\n```\n\n----------------------------------------\n\nTITLE: Define quimb Dependency\nDESCRIPTION: Specifies quimb as a dependency with a minimum version of 1.8. quimb is a Python library for quantum information and many-body calculations, indicating that the contrib module might involve such computations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/requirements.txt#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nquimb>=1.8\n```\n\n----------------------------------------\n\nTITLE: Create and Run Circuit on Virtual Engine - Python\nDESCRIPTION: This snippet parses a device specification string into a `DeviceSpecification` object using `google.protobuf.text_format`.  It then creates a `SimulatedLocalEngine` from the specification and runs a quantum circuit on it. The snippet also prepares a sampler and attempts to run a simple circuit, handling potential `ValueErrors`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/virtual_engine_interface.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport google.protobuf.text_format as text_format\n\n# Import the spec.\ndevice_spec = cirq_google.api.v2.device_pb2.DeviceSpecification()\ntext_format.Parse(device_str, device_spec)\nfour_engine = cirq_google.engine.create_noiseless_virtual_engine_from_proto(\n    processor_id, device_spec\n)\n# Prepare a sampler.\nprint([proc.processor_id for proc in four_engine.list_processors()])\nprocessor = four_engine.get_processor(processor_id)\nprint(processor.get_device())\nsampler = processor.get_sampler()\n\nq1_1 = cirq.GridQubit(1, 1)\nq1_2 = cirq.GridQubit(1, 2)\nq2_1 = cirq.GridQubit(2, 1)\n# Run a circuit with one each of Z, CZ, Measure, and CircuitOperation.\ncircuit = cirq.Circuit(\n    cirq.CircuitOperation(cirq.FrozenCircuit(cirq.Z(q2_1), cirq.CZ(q1_1, q1_2))),\n    cirq.measure(q1_1),\n    cirq.measure(q2_1),\n)\nprint('results', '\\n')\ntry:\n    print(sampler.run(circuit))\nexcept ValueError as e:\n    print(e)\n\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Terminal Measurements in Cirq\nDESCRIPTION: This snippet uses `cirq.synchronize_terminal_measurements` to move all measurements to the final moment of the circuit, provided that the final moment can accommodate them without overlapping other operations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.synchronize_terminal_measurements(circuit)\ncircuit\n```\n\n----------------------------------------\n\nTITLE: Converting Circuit to Dense Unitary Matrix\nDESCRIPTION: This snippet calculates the unitary matrix representation of the quantum circuit using both the `tensor_unitary` function from `cirq.contrib.quimb` and the `unitary` function from Cirq. The unitary matrices are then compared using `np.testing.assert_allclose` to ensure consistency.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Cirq-to-Tensor-Networks.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nu_tn = ccq.tensor_unitary(circuit, qubits)\nu_cirq = circuit.unitary(qubit_order=qubits)\nnp.testing.assert_allclose(u_cirq, u_tn, atol=1e-7)\n```\n\n----------------------------------------\n\nTITLE: Initializing RigettiQCSSampler for Parametric Compilation\nDESCRIPTION: This code initializes a `RigettiQCSSampler` instance with a Quilc parametric compilation executor. It imports the necessary functions and then creates a sampler that uses the specified service name and QVM setting.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/rigetti/getting_started.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq_rigetti import get_rigetti_qcs_sampler\n\nexecutor = circuit_sweep_executors.with_quilc_parametric_compilation\nsampler = get_rigetti_qcs_sampler(SERVICE_NAME, as_qvm=True, executor=executor)\n```\n\n----------------------------------------\n\nTITLE: Creating a measurement operation\nDESCRIPTION: This code snippet demonstrates how to create a measurement operation by applying a measurement gate to a qubit.  The `cirq.MeasurementGate` is applied to the qubit using the `on` method. The resulting measurement operation is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/operators.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nmeasurement_operation = measurement.on(qubit)\nprint(measurement_operation)\n```\n\n----------------------------------------\n\nTITLE: Setting Experiment Parameters for Circuit Benchmarking in Cirq\nDESCRIPTION: This snippet sets the experiment parameters for benchmarking the circuit. It defines the qubits, cycle values, number of repetitions, and a seed for the random number generator.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Set experiment parameters.\"\"\"\nqubits = cg.line_on_device(device_sampler.device, length=7)\ncycle_values = range(0, 100 + 1, 4)\nnreps = 20_000\nseed = 1\n```\n\n----------------------------------------\n\nTITLE: Visualizing Circuit in 3D using cirq_web\nDESCRIPTION: This snippet shows how to visualize a large quantum circuit in 3D using `cirq_web`. It first installs the `cirq_web` package and then creates a `cirq_web.Circuit3D` object from the circuit. The `display` function is used to render the 3D visualization.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n!pip install --quiet cirq-web\nimport cirq_web\n\ncircuit_vis = cirq_web.Circuit3D(stabilizer_grid_circuit)\ndisplay(circuit_vis)\n```\n\n----------------------------------------\n\nTITLE: Querying Qid Shape of a Gate in Cirq\nDESCRIPTION: This code creates an instance of the `QutritPlusGate` and uses `cirq.qid_shape` to verify that it acts on a single qutrit. It prints the result, which will be (3,).\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/qudits.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Create an instance of the qutrit gate defined above.\ngate = QutritPlusGate()\n\n# Verify that it acts on a single qutrit.\nprint(cirq.qid_shape(gate))\n```\n\n----------------------------------------\n\nTITLE: Installing Stable Cirq Release\nDESCRIPTION: This snippet shows how to install a stable release of Cirq using pip. It is required for notebooks that only use released features.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/notebooks.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install cirq\n```\n\n----------------------------------------\n\nTITLE: Classically compute order of an element in Python\nDESCRIPTION: This function calculates the smallest positive integer r such that x**r mod n == 1, where x is an element of the multiplicative group modulo n. It checks if x is a valid input and belongs to the multiplicative group.  It raises a ValueError if x is invalid and returns the order r once x**r mod n equals 1.  The inputs are x (the element) and n (the modulus).\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef classical_order_finder(x: int, n: int) -> Optional[int]:\n    \"\"\"Computes smallest positive r such that x**r mod n == 1.\n\n    Args:\n        x: Integer whose order is to be computed, must be greater than one\n           and belong to the multiplicative group of integers modulo n (which\n           consists of positive integers relatively prime to n),\n        n: Modulus of the multiplicative group.\n\n    Returns:\n        Smallest positive integer r such that x**r == 1 mod n.\n        Always succeeds (and hence never returns None).\n\n    Raises:\n        ValueError when x is 1 or not an element of the multiplicative\n        group of integers modulo n.\n    \"\"\"\n    # Make sure x is both valid and in Z_n.\n    if x < 2 or x >= n or math.gcd(x, n) > 1:\n        raise ValueError(f\"Invalid x={x} for modulus n={n}.\")\n    \n    # Determine the order.\n    r, y = 1, x\n    while y != 1:\n        y = (x * y) % n\n        r += 1\n    return r\n```\n\n----------------------------------------\n\nTITLE: Adding Deep Support with add_deep_support=True\nDESCRIPTION: This code snippet demonstrates how to enable recursive execution of transformers on `cirq.CircuitOperation` instances using `@cirq.transformer(add_deep_support=True)`. It defines `reverse_circuit_deep` and `SubstituteGateDeep` with deep support and uses a `TransformerContext` with `deep=True` to transform a circuit containing a `CircuitOperation`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/custom_transformers.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@cirq.transformer(add_deep_support=True)\ndef reverse_circuit_deep(circuit, *, context=None):\n    \"\"\"Transformer to reverse the input circuit.\"\"\"\n    return circuit[::-1]\n\n\n@cirq.transformer(add_deep_support=True)\nclass SubstituteGateDeep(SubstituteGate):\n    \"\"\"Transformer to substitute `source` gates with `target` in the input circuit.\"\"\"\n\n    pass\n\n\n# Note that you want to transform the CircuitOperations.\ncontext = cirq.TransformerContext(deep=True)\n# Transform and compare the circuits.\nsubstitute_gate_deep = SubstituteGateDeep(cirq.X, cirq.S)\nprint(\"Original Circuit:\", circuit, \"\\n\", sep=\"\\n\")\nprint(\n    \"Reversed Circuit with deep=True:\",\n    reverse_circuit_deep(circuit, context=context),\n    \"\\n\",\n    sep=\"\\n\",\n)\nprint(\n    \"Substituted Circuit with deep=True:\", substitute_gate_deep(circuit, context=context), sep=\"\\n\"\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq in Python\nDESCRIPTION: This code snippet attempts to import the Cirq library. If Cirq is not installed, it installs Cirq using pip and prints a message indicating the installation status.  It handles the case where Cirq might not be pre-installed in the environment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/aqt/getting_started.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Converting Circuit to Tensor Network\nDESCRIPTION: This code converts the quantum circuit into a tensor network representation using `ccq.circuit_to_tensors` and adds bra tensors to cap the network.  It then visualizes the tensor network graph with node coloring based on qubit indices and displays the resulting plot using `plt.show()`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ntensors, qubit_frontier, fix = ccq.circuit_to_tensors(\n    circuit=tot_c, qubits=qubits)\nend_bras = [\n    qtn.Tensor(\n        data=quimb.up().squeeze(),\n        inds=(f'i{qubit_frontier[q]}_q{q}',),\n        tags={'Q0', 'bra0'}) for q in qubits\n]\n\ntn = qtn.TensorNetwork(tensors + end_bras)\ntn.graph(color=['Q0', 'Q1', 'Q2'])\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Random Problem Generation\nDESCRIPTION: Defines functions to generate random instances of the Hidden Linear Function problem and to find 'interesting' problems where the size of the subspace L_q is greater than a specified minimum. This is important to avoid trivial problem instances.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/hidden_linear_function.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef random_problem(n, seed=None):\n    \"\"\"Generates instance of the problem with given `n`.\n    \n    Args:\n        n: dimension of the problem.\n    \"\"\"\n    if seed is not None:\n        np.random.seed(seed) \n    A = np.random.randint(0, 2, size=(n,n))\n    for i in range(n):\n        for j in range(i+1):\n            A[i][j] = 0\n    b = np.random.randint(0, 2, size=n)\n    problem = HiddenLinearFunctionProblem(A, b)\n    return problem\n        \ndef find_interesting_problem(n, min_L_size):\n    \"\"\"Generates \"interesting\" instance of the problem.\n    \n    Returns instance of problem with given `n`, such that size of \n    subspace `L_q` is at least `min_L_size`.\n    \n    Args:\n        n: dimension of the problem.\n        min_L_size: minimal cardinality of subspace L.\n    \"\"\"\n    for _ in range(1000):\n        problem = random_problem(n)\n        problem.bruteforce_solve()\n        if len(problem.L) >= min_L_size and not np.max(problem.A) == 0:\n            return problem\n    return None\n\nproblem = find_interesting_problem(10, 4)\nprint(\"Size of subspace L: %d\" % len(problem.L))\nprint(\"Number of solutions: %d\" % len(problem.all_zs))\n```\n\n----------------------------------------\n\nTITLE: Getting Kraus operators of a depolarizing channel\nDESCRIPTION: This snippet shows how to retrieve the Kraus operators of a `cirq.DepolarizingChannel` using `cirq.kraus`. The Kraus operators are then printed, with each element rounded to two decimal places.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/operators.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nkraus_ops = cirq.kraus(depo_channel)\nprint(f\"Kraus operators of {depo_channel} are:\", *[op.round(2) for op in kraus_ops], sep=\"\\n\\n\")\n```\n\n----------------------------------------\n\nTITLE: Optimizing Circuit with MergeInteractionsToSqrtIswap in Cirq\nDESCRIPTION: This snippet uses the `cirq.MergeInteractionsToSqrtIswap` optimizer to merge consecutive interactions on two qubits into a unitary matrix. It then decomposes this unitary using $\\sqrt{\\text{iSWAP}}$ gates, attempting to convert to the target gateset and reduce circuit depth by reducing the number of operations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ncirq.MergeInteractionsToSqrtIswap().optimize_circuit(circuit)\ncircuit\n```\n\n----------------------------------------\n\nTITLE: Using the CZ Conversion Transformer\nDESCRIPTION: This snippet builds a quantum circuit containing three versions of a random component: a normal component, a `CircuitOperation` version, and an ignore-tagged `CircuitOperation` version. It then applies the `convert_to_cz_target` transformer to this circuit, ensuring circuit equivalence and logging the executed steps using `TransformerContext` and `TransformerLogger`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/custom_transformers.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Build the circuit from three versions of the same random component\ncomponent = cirq.testing.random_circuit(qubits=3, n_moments=2, op_density=0.8, random_state=1234)\ncomponent_operation = cirq.CircuitOperation(cirq.FrozenCircuit(component))\n# A normal component, a CircuitOperation version, and a ignore-tagged CircuitOperation version\ncircuit = cirq.Circuit(component, component_operation, component_operation.with_tags('ignore'))\n# Note that you want to transform the CircuitOperations, ignore tagged operations, and log the steps.\ncontext = cirq.TransformerContext(\n    deep=True, tags_to_ignore=(\"ignore\",), logger=cirq.TransformerLogger()\n)\n# Run your transformer.\nconverted_circuit = convert_to_cz_target(circuit, context=context)\n# Ensure that the resulting circuit is equivalent.\ncirq.testing.assert_circuits_with_terminal_measurements_are_equivalent(circuit, converted_circuit)\n# Show the steps executed.\ncontext.logger.show()\n```\n\n----------------------------------------\n\nTITLE: Dependency Specification\nDESCRIPTION: This snippet specifies a dependency named `a_dependency` with version `0.2.3`. It shows the basic format for declaring a direct dependency within a requirements file.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/dev_tools/requirements/test_data/a.req.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\na_dependency==0.2.3\n```\n\n----------------------------------------\n\nTITLE: Getting the Unitary Matrix of a Qutrit Gate in Cirq\nDESCRIPTION: This snippet creates an instance of the `QutritPlusGate` and retrieves its unitary matrix using `cirq.unitary`. It prints the unitary matrix, which is a 3x3 matrix because the gate acts on a qutrit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/qudits.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Create an instance of the qutrit gate defined above. This gate implements _unitary_.\ngate = QutritPlusGate()\n\n# Because it acts on qutrits, its unitary is a 3 by 3 matrix.\nprint(cirq.unitary(gate))\n```\n\n----------------------------------------\n\nTITLE: NumPy Kronecker Product Example\nDESCRIPTION: This code demonstrates the behavior of `numpy.kron` which is related to qubit and amplitude ordering in Cirq simulations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/simulation.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\noutside = [1, 10]\ninside = [1, 2]\nprint(np.kron(outside, inside))\n```\n\n----------------------------------------\n\nTITLE: Creating an Asynchronous Job on Azure Quantum\nDESCRIPTION: This snippet creates an asynchronous job on the Azure Quantum service using the `create_job` method. It takes the quantum circuit and number of repetitions as input and returns a `Job` object that can be used to track the job's progress.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_honeywell.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\njob = service.create_job(\n    program=circuit,\n    repetitions=100\n)\n```\n\n----------------------------------------\n\nTITLE: Graph Fused and Coherent Data, Python\nDESCRIPTION: This Python code creates two subplots using `matplotlib` to compare 'Unscaled Coherent' and 'Rescaled Fused' fidelity data. It iterates through the fidelity datasets, applies the `_p_gen` function with different `rescale` parameters, adds labels and titles using the `extras` function, and displays the figure.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfig, axes = plt.subplots(1, 2, figsize=(18, 6.5), sharey=True)\ntwo_fidelities = [fitted_fidelities[0], fitted_fidelities[3]]\ntitles = [r'Unscaled Coherent', r'Rescaled Fused']\nfor fidelities, rescale, ax, title in zip(two_fidelities, [False, True], axes.flat, titles):\n    fidelities.apply(_p_gen(ax, rescale=rescale), axis=1)\n    extras(ax, title)\n\nfig.tight_layout()\nfig.show()\n```\n\n----------------------------------------\n\nTITLE: Installing Test Dependencies\nDESCRIPTION: This snippet specifies the dependencies required for a testing environment. It installs packages listed in 'deps/pytest.txt' and 'deps/notebook.txt', likely including pytest and Jupyter Notebook related packages. These dependencies are important for running automated tests and interactive notebook execution.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/dev_tools/requirements/isolated-base.env.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n-r deps/pytest.txt\n-r deps/notebook.txt\n```\n\n----------------------------------------\n\nTITLE: Illustrating Qubit Ordering in Simulation\nDESCRIPTION: This code snippet illustrates the relationship between qubit order and amplitude ordering in the wave function. It demonstrates the nested loop ordering of qubits when mapping to amplitudes.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/simulation.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ni = 0\nfor first in [0, 1]:\n    for second in [0, 1]:\n        print('amps[{}] is for first={}, second={}'.format(i, first, second))\n        i += 1\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq in Python\nDESCRIPTION: This code snippet attempts to import the cirq library. If the import fails, it installs cirq using pip and then imports it. It also imports the numpy library which is needed for matrix operations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/custom_gates.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n    \nimport numpy as np\n```\n\n----------------------------------------\n\nTITLE: Use Adder gate in Cirq circuit (Python)\nDESCRIPTION: This code demonstrates the usage of the `Adder` gate in a Cirq circuit.  It creates two 2-qubit registers, applies X gates to initialize them to |10> and |01> respectively, then uses the `Adder` gate to add the input register to the target register. Finally, it measures all qubits and creates a `cirq.Circuit` object to simulate and observe the result.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Two qubit registers.\nqreg1 = cirq.LineQubit.range(2)\nqreg2 = cirq.LineQubit.range(2, 4)\n\n# Define an adder gate for two 2D input and target qubits.\nadder = Adder(input_register=[2, 2], target_register=[2, 2])\n\n# Define the circuit.\ncirc = cirq.Circuit(\n    cirq.X.on(qreg1[0]),\n    cirq.X.on(qreg2[1]),\n    adder.on(*qreg1, *qreg2),\n    cirq.measure_each(*qreg1),\n    cirq.measure_each(*qreg2)\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Offset Placements for Tilted Square Lattice in Cirq\nDESCRIPTION: This code defines a helper function `all_offset_placements` that generates placements for `TiltedSquareLattice` topologies anchored from a specified offset qubit. It generates candidate topologies, creates placements using `nodes_to_gridqubits` with the offset parameter, and filters out invalid placements based on the device graph.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/qubit-placement.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport itertools\n\ndef all_offset_placements(device_graph, offset=(4, 2), min_sidelength=2, max_sidelength=5):\n    # Generate candidate tilted square lattice topologies\n    sidelens = list(itertools.product(range(min_sidelength, max_sidelength + 1), repeat=2))\n    topos = [cirq.TiltedSquareLattice(width, height) for width, height in sidelens]\n    \n    # Make placements using TiltedSquareLattice.nodes_to_gridqubits offset parameter\n    placements = {topo: topo.nodes_to_gridqubits(offset=offset) for topo in topos}\n    \n    # Only allow placements that are valid on the device graph\n    placements = {topo: mapping for topo, mapping in placements.items()\n                  if cirq.is_valid_placement(device_graph, topo.graph, mapping)}\n    return placements\n```\n\n----------------------------------------\n\nTITLE: Simulating Expectation Values with qsimcirq\nDESCRIPTION: This snippet uses the `qsimcirq` simulator to calculate the expectation values of the defined observable (Z on qubit 62) for a range of theta values. The `simulate_expectation_values_sweep_iter` function is used to iterate through the parameter sweep. The execution time is measured using the `%%time` magic command.  The simulation results are printed after each theta value is processed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_utility_sim_4b.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n%%time\n# This will log after each value of theta is simulated. Its purpose is to\n# give an indication of total runtime before all simulations finish.\nresults = []\nfor i, result in enumerate(simulator.simulate_expectation_values_sweep_iter(circuit, observables, params)):\n    results.append(result)\n    print(f\"Completed theta={theta_values[i]:.3f}; value={result}\")\n\n# Runtimes logged in the output of this cell were achieved using a machine with\n# 24 cores and 80GB of RAM.\n```\n\n----------------------------------------\n\nTITLE: Plotting Simulation Results with Matplotlib (Python)\nDESCRIPTION: This snippet plots the simulation results obtained in the previous step using `matplotlib`. It negates the expectation values for visual simplicity.  The plot displays the expectation values as a function of the rotation angle `theta`. The x-axis is labeled with values and the y-axis is labeled with the observable being measured.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_utility_sim_4a.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Each element of \"results\" is a list of one expectation value.\n# For visual simplicity, the results are negated.\nplot_results = [-x[0].real for x in results]\n\n# Plot the results in the format of Fig. 4a.\nplt.plot(np.array(theta_values), plot_results, 'bo')\nplt.xlabel(r\"$ R_X $ angle $ \\theta_h $\")\nplt.ylabel(r\"$ \\langle X_{37,41,52,56,57,58,62,79} Y_{38,40,42,63,72,80,90,91} Z_{75} \\rangle $\")\nplt.xticks(np.linspace(0, np.pi / 2, 5), [\"0\", \"π/8\", \"π/4\", \"3π/8\", \"π/2\"])\nplt.yticks(np.linspace(0, 1, 6))\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: JSON Resolver Cache (Python)\nDESCRIPTION: This Python snippet defines a function that returns an empty dictionary, decorated with `@functools.lru_cache`. This cache is used to store resolvers for JSON serialization and deserialization within a Cirq module. It's placed in `<top_level_package>/json_resolver_cache.py`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/modules.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@functools.lru_cache()  # pragma: no cover\ndef _class_resolver_dictionary() -> Dict[str, ObjectFactory]:  # pragma: no cover\n    return {}\n```\n\n----------------------------------------\n\nTITLE: Building a Noisy Simulator with Cirq and QSim\nDESCRIPTION: This code loads the median device noise calibration for a selected processor, transforms the calibration data into Cirq noise properties, creates a noise model, and sets up a `qsim` simulator with the noise model. This allows for realistic noisy simulation of quantum circuits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/quantum_virtual_machine.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Load the median device noise calibration for your selected processor.\ncal = cirq_google.engine.load_median_device_calibration(processor_id)\n# Create the noise properties object.\nnoise_props = cirq_google.noise_properties_from_calibration(cal)\n# Create a noise model from the noise properties.\nnoise_model = cirq_google.NoiseModelFromGoogleNoiseProperties(noise_props)\n# Prepare a qsim simulator using the noise model.\nsim = qsimcirq.QSimSimulator(noise=noise_model)\n```\n\n----------------------------------------\n\nTITLE: Printing Fidelity Metrics\nDESCRIPTION: This snippet demonstrates how to access and print the fidelity metrics (1q, 2q, and spam) from the `cirq_ionq.Calibration` object using the `fidelities()` method. It provides insight into the gate quality and measurement accuracy of the IonQ QPU. Requires a `cirq_ionq.Calibration` object named `calibration`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/calibrations.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nprint(calibration.fidelities())\n```\n\n----------------------------------------\n\nTITLE: Extracting and Visualizing Circuit Connectivity in Cirq\nDESCRIPTION: This code extracts the connectivity graph from the generated circuit using `cirq.contrib.routing.get_circuit_connectivity`. The extracted graph represents the qubit connections within the circuit, which is then visualized using `cirq.draw_gridlike`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/qubit-placement.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.contrib.routing import get_circuit_connectivity\ncircuit_graph = get_circuit_connectivity(circuit)\n_ = cirq.draw_gridlike(circuit_graph, tilted=False)\n```\n\n----------------------------------------\n\nTITLE: Listing Available Quantum Processors using RigettiQCSService\nDESCRIPTION: This code snippet imports the `RigettiQCSService` and retrieves a list of available quantum processors. It then extracts the IDs of the processors and prints them to the console. This allows the user to select a specific quantum processor to run their circuits on.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/rigetti/getting_started.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq_rigetti import RigettiQCSService\n\nquantum_processors = RigettiQCSService.list_quantum_processors().quantum_processors\nprocessors_list = [quantum_processor.id for quantum_processor in quantum_processors]\nprint(processors_list)\n```\n\n----------------------------------------\n\nTITLE: Aligning Gates to the Left in Cirq\nDESCRIPTION: This snippet aligns the gates in the circuit as far left as possible using the `cirq.align_left` function. This minimizes the number of moments and can reduce circuit execution time. The resulting circuit is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nleft_aligned_circuit = cirq.align_left(circuit)\nleft_aligned_circuit\n```\n\n----------------------------------------\n\nTITLE: Plotting Fidelities Before and After Characterization in Cirq\nDESCRIPTION: This snippet plots the fidelities before and after characterization against the cycle depth.  It iterates through rows of the `before_after_df` dataframe, plotting data points and exponential decay curves. Dependencies include matplotlib and numpy.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfor i, row in before_after_df.iterrows():\n    plt.axhline(1, color='grey', ls='--')\n    plt.plot(row['cycle_depths_0'], row['fidelities_0'], '*', color='red')\n    plt.plot(row['cycle_depths_c'], row['fidelities_c'], 'o', color='blue')\n\n    xx = np.linspace(0, np.max(row['cycle_depths_0']))\n    plt.plot(xx, exponential_decay(xx, a=row['a_0'], layer_fid=row['layer_fid_0']), \n             color='red', label=f'f_0 = {row[\"layer_fid_0\"]:.3f}')\n    plt.plot(xx, exponential_decay(xx, a=row['a_c'], layer_fid=row['layer_fid_c']), \n             color='blue', label=f'f_c = {row[\"layer_fid_c\"]:.3f}')\n    \n    plt.xlabel('Cycle Depth')\n    plt.ylabel('Fidelity')\n    plt.legend(loc='best')\n    plt.tight_layout()\n    plt.show()\n```\n\n----------------------------------------\n\nTITLE: Creating Quantum Virtual Machine\nDESCRIPTION: This snippet creates a `cirq.SimulatedLocalEngine` instance, which represents a Quantum Virtual Machine. It takes a `processor_id` (either \"rainbow\" or \"weber\") and the `qsimcirq.QSimSimulator` class as input.  It also prints the qubit grid of the created virtual machine.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_builder_code.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nprocessor_id = \"rainbow\"  # @param {type:\"string\"}\n\n# Instantiate an engine.\nsim_engine = cirq_google.engine.create_default_noisy_quantum_virtual_machine(\n    processor_id=processor_id, simulator_class=qsimcirq.QSimSimulator\n)\nprint(\n    \"Your quantum virtual machine\",\n    processor_id,\n    \"is ready, here is the qubit grid:\",\n    \"\\n========================\\n\",\n)\nprint(sim_engine.get_processor(processor_id).get_device())\n```\n\n----------------------------------------\n\nTITLE: Inspecting Transformer Actions Python\nDESCRIPTION: This code demonstrates how to inspect the actions of transformers within the `optimize_circuit` function using `cirq.TransformerContext` and `cirq.TransformerLogger`.  A logger instance is created and passed to the `optimize_circuit` function. The log can then be shown to inspect the transformations that have been applied to the circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/transformers.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncontext = cirq.TransformerContext(logger=cirq.TransformerLogger())\noptimized_circuit = optimize_circuit(circuit, context)\ncontext.logger.show()\n```\n\n----------------------------------------\n\nTITLE: Rabi-Flop Experiment Attempt in Cirq\nDESCRIPTION: This is a code snippet for a Rabi-flop experiment using Cirq. It sets up a parameterized circuit with a rotation about the X axis, followed by a measurement. It is designed as an exercise with placeholders for the user to fill in.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_66\n\nLANGUAGE: python\nCODE:\n```\nimport pandas\n\nq = cirq.NamedQubit(\"q\")\ntheta = sp.Symbol(\"theta\")\nparameterized_circuit = cirq.Circuit(\n    # your code here\n    cirq.measure(q)\n)\n# replace None with something else\nparam_resolvers = None\nrepetitions = 100\nresults = cirq.Simulator().sample(\n    program=parameterized_circuit, params=param_resolvers, repetitions=repetitions\n)\n\n# You can test with the following plot\n# pandas.crosstab(results.theta, results.q).plot()\n```\n\n----------------------------------------\n\nTITLE: Listing Python Modules\nDESCRIPTION: This command lists the Python modules to be added to the virtualenv. This is preparatory to the `add2virtualenv` step.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\npython dev_tools/modules.py list\n```\n\n----------------------------------------\n\nTITLE: Simulating a Circuit with Cirq Simulator\nDESCRIPTION: This code simulates the Grover circuit locally using Cirq's `Simulator`.  It creates a simulator instance, runs the circuit with 200 repetitions, and stores the raw data.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/pasqal/getting_started.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nsampler = cirq.Simulator()\ndata_raw = sampler.run(grover_circuit, repetitions=200)\n```\n\n----------------------------------------\n\nTITLE: Running Performance Profiles and Creating Dataframe\nDESCRIPTION: This snippet iterates through different numbers of qubits and moments, running the `profile` function for each combination. The results are stored in a list of records, which is then converted into a pandas DataFrame. The head of the DataFrame is then displayed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Cirq-to-Tensor-Networks.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nrecords = []\nmax_qubits = 6\nmax_moments = 500\nfor n_qubits in [3, max_qubits]:\n    for n_moments in range(1, max_moments, 50):\n        record = profile(n_qubits=n_qubits, n_moments=n_moments)\n        records.append(record)\n        print('.', end='', flush=True)\n\ndf = pd.DataFrame(records)\ndf.head()\n```\n\n----------------------------------------\n\nTITLE: Displaying Single Qubit Gate Constants in Cirq\nDESCRIPTION: This snippet uses the display_gates function to display documentation for the single qubit gates X, Y, Z, H, S, and T.  The display_gates function retrieves each gate from the cirq module and displays its docstring using IPython.display.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndisplay_gates(\"X\", \"Y\", \"Z\", \"H\", \"S\", \"T\")\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq with Pip\nDESCRIPTION: This snippet demonstrates how to install Cirq using pip. It first upgrades pip to the latest version, then installs the cirq package. This is the basic installation method for getting started with Cirq.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/install.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython -m pip install --upgrade pip\npython -m pip install cirq\n```\n\n----------------------------------------\n\nTITLE: Running Direct Fidelity Estimation with Cirq in Python\nDESCRIPTION: This code snippet runs the Direct Fidelity Estimation (DFE) algorithm on the created circuit using the specified simulator.  The function dfe.direct_fidelity_estimation takes the circuit, qubits, sampler, number of measured operators, and samples per term as input parameters. `n_measured_operators=None` indicates that all Pauli strings are used and `samples_per_term=0` uses the dense matrix simulator without sampling.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/direct_fidelity_estimation.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# We run the DFE:\nestimated_fidelity, intermediate_results = dfe.direct_fidelity_estimation(\n        circuit,\n        qubits,\n        sampler,\n        n_measured_operators=None,  # None=returns all the Pauli strings\n        samples_per_term=0)  # 0=use dense matrix simulator\n\nprint('Estimated fidelity: %.2f' % (estimated_fidelity))\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq in Python\nDESCRIPTION: This code snippet attempts to import the cirq library and, if it's not found, installs it using pip. This ensures that cirq is available for subsequent operations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/devices.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n```\n\n----------------------------------------\n\nTITLE: Creating a Single-Qubit Heatmap in Cirq\nDESCRIPTION: This snippet creates a `cirq.Heatmap` object with custom data mapping from `cirq.GridQubit` tuples to float values.  It then generates a plot of the heatmap using Matplotlib.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/heatmaps.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsingle_qubit_heatmap = cirq.Heatmap({\n    (cirq.GridQubit(0, 0),): 0.1,\n    (cirq.GridQubit(0, 1),): 0.2,\n    (cirq.GridQubit(0, 2),): 0.3,\n    (cirq.GridQubit(1, 0),): 0.4,\n})\n\n_, ax = plt.subplots(figsize=(8, 8))\n_ = single_qubit_heatmap.plot(ax);\n```\n\n----------------------------------------\n\nTITLE: Simplifying Expectation Value Circuit (ccq)\nDESCRIPTION: This code utilizes a utility function `ccq.simplify_expectation_value_circuit` from `cirq.contrib.quimb` to fully simplify the circuit created for expectation value calculation.  This simplifies the 'tot_c' circuit in-place and visualizes the resulting simplified circuit using `SVGCircuit`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nccq.simplify_expectation_value_circuit(tot_c)\nSVGCircuit(tot_c)\n```\n\n----------------------------------------\n\nTITLE: Generating Standalone HTML File for Cirq Visualization with Python\nDESCRIPTION: This code demonstrates how to generate a standalone HTML file of a Cirq visualization using the `generate_html_file` method of the `Widget` class. The code sets the output directory, filename, and a flag to open the file in the browser after creation. It assumes `MyWidget` has been defined and instantiated from the inherited `widget.Widget` class.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-web/cirq_web/README.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nwidget = MyWidget()\n\noutput_directory = './'\nfile_name = 'YOUR_VIZ.html'\nopen_in_browser = False\n\nwidget.generate_html_file(output_directory, file_name, open_in_browser)\n```\n\n----------------------------------------\n\nTITLE: Manual Verification in Virtual Environment (Test PyPI)\nDESCRIPTION: This bash script creates a new virtual environment, installs development requirements, installs the Cirq package from Test PyPI with the specific version, and then runs a python script to print the Cirq version. This allows for manual verification of the release.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/release.md#_snippet_10\n\nLANGUAGE: Bash\nCODE:\n```\nmkvirtualenv \"verify_test_${VER}\" --python=/usr/bin/python3\npip install -r dev_tools/requirements/dev.env.txt\npip install --extra-index-url=https://test.pypi.org/simple/ cirq==\"${VER}\"\npython -c \"import cirq; print(cirq.__version__)\"\npython  # just do some stuff checking that latest features are present\n```\n\n----------------------------------------\n\nTITLE: Defining Device Stabilizer Plaquette (Cirq)\nDESCRIPTION: This snippet defines a stabilizer plaquette as a list of GridQubits, representing an X-shaped region of qubits on a physical device. This is meant to represent a small physical region on a quantum processor used for performing a stabilizer measurement.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Device_stabilizer_plaquette is an X-shaped region of qubits\n# on the actual device.\ndevice_stabilizer_plaquette = [\n    cirq.GridQubit(5, 3),\n    cirq.GridQubit(5, 2),\n    cirq.GridQubit(4, 3),\n    cirq.GridQubit(5, 4),\n    cirq.GridQubit(6, 3),\n]\n```\n\n----------------------------------------\n\nTITLE: Using DepolarizingChannel in Cirq (Python)\nDESCRIPTION: This code demonstrates the use of `cirq.DepolarizingChannel`. It initializes three qubits in different bases (X, Y, and Z), applies the depolarizing channel with a probability of 0.2 to each qubit, then returns the qubits to their original bases before measuring. The simulation runs 1000 times, and the histograms for each qubit are printed to observe the effect of the depolarization.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/representing_noise.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nq0, q1, q2 = cirq.LineQubit.range(3)\ncircuit = cirq.Circuit(\n    cirq.H(q0),  # initialize X basis\n    cirq.H(q1),  # initialize Y basis\n    cirq.S(q1),\n    cirq.depolarize(p=0.2).on_each(q0, q1, q2),\n    cirq.H(q0),  # return to Z-basis\n    cirq.S(q1) ** -1,\n    cirq.H(q1),\n    cirq.measure(q0, key='result_0'),\n    cirq.measure(q1, key='result_1'),\n    cirq.measure(q2, key='result_2'),\n)\nresult = cirq.Simulator(seed=0).run(circuit, repetitions=1000)\n# All basis states are equally affected.\nprint(\"X basis:\", result.histogram(key='result_0'))\nprint(\"Y basis:\", result.histogram(key='result_1'))\nprint(\"Z basis:\", result.histogram(key='result_2'))\n```\n\n----------------------------------------\n\nTITLE: Creating Unoptimized Benchmark Circuit in Cirq\nDESCRIPTION: This snippet creates a benchmark circuit without any optimization or spin echoes using the `create_benchmark_circuit` function. It sets the `cycles` parameter to 2 and the `seed` to 1.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ncircuit = create_benchmark_circuit(qubits, cycles=2, seed=1)\nprint(f\"Unoptimized circuit ({len(circuit)} moments):\\n\")\ncircuit\n```\n\n----------------------------------------\n\nTITLE: Defining All Possible Single-Qubit Gates\nDESCRIPTION: This code defines a list of all possible single-qubit gates by combining different exponents. These gates will be used in the random quantum circuit generation process.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/xeb_theory.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport itertools\nSINGLE_QUBIT_GATES = [\n    cirq.PhasedXZGate(x_exponent=0.5, z_exponent=z, axis_phase_exponent=a)\n    for a, z in itertools.product(exponents, repeat=2)\n]\nSINGLE_QUBIT_GATES[:10], '...'\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for XEB in Python\nDESCRIPTION: This snippet imports necessary libraries: NumPy for numerical operations and SVGCircuit from cirq.contrib.svg for visualizing quantum circuits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/xeb_theory.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Standard imports\nimport numpy as np\n\nfrom cirq.contrib.svg import SVGCircuit\n```\n\n----------------------------------------\n\nTITLE: Install Cirq if not present\nDESCRIPTION: This snippet attempts to import the Cirq library. If the import fails, it installs Cirq using pip and then imports it. It ensures that the Cirq library is available for the rest of the code.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n```\n\n----------------------------------------\n\nTITLE: PauliString Distribution in Cirq\nDESCRIPTION: Illustrates how Cirq supports arbitrary combinations and parenthesizations of `+` and `*` for PauliStrings, handling distribution as expected. It presents examples of distributing Pauli operators within expressions.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ntyprint(-2 * Xa * (Xa + Xb))\ntyprint(-2 * Xa * (Za + Zb))\ntyprint(-2 * Xa * (Za + Xb * Zb))\n```\n\n----------------------------------------\n\nTITLE: Visualizing XEB Results with Cirq\nDESCRIPTION: This code snippet visualizes the results of the XEB experiment using methods provided by the `TwoQubitXEBResult` class. It plots a heatmap of XEB errors, the fitted model of XEB error for a qubit pair, and a histogram of all XEB errors.  These visualizations help analyze the performance of the two-qubit gates.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# The returned result is an instance of the `TwoQubitXEBResult` class which provides visualization methods like \nresult.plot_heatmap();  # plot the heatmap of XEB errors\nresult.plot_fitted_exponential(*qubits[:2]);  # plot the fitted model of xeb error of a qubit pair.\nresult.plot_histogram();  # plot a histogram of all xeb errors.\n```\n\n----------------------------------------\n\nTITLE: Importing necessary libraries\nDESCRIPTION: This snippet imports necessary libraries for working with Cirq, including typing for type hinting, matplotlib for plotting, numpy for numerical operations, and networkx for graph algorithms.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/named_topologies.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Iterable, List, Optional, Sequence\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport networkx as nx\n```\n\n----------------------------------------\n\nTITLE: Decomposing a Cirq Gate Once\nDESCRIPTION: This code demonstrates the use of `cirq.decompose_once`, which decomposes a given operation or circuit only one level deep. This is in contrast to `cirq.decompose` which recursively decomposes operations until it cannot decompose them further.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_59\n\nLANGUAGE: python\nCODE:\n```\nprint(cirq.Circuit(cirq.decompose_once(HX(a))))\n```\n\n----------------------------------------\n\nTITLE: Displaying Cirq Widget in IPython Notebook with Python\nDESCRIPTION: This snippet illustrates how to display a Cirq visualization widget in a Jupyter or Colab notebook using the `display` function. This relies on IPython's `_repr_html_` magic method. The code assumes that `MyWidget` has been defined and instantiated from the inherited `widget.Widget` class.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-web/cirq_web/README.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nwidget = MyWidget()\ndisplay(widget)\n```\n\n----------------------------------------\n\nTITLE: Dropping Negligible Operations and Empty Moments in Cirq\nDESCRIPTION: This snippet utilizes `cirq.drop_negligible_operations` and `cirq.drop_empty_moments` to further optimize the circuit by removing operations that have a negligible effect and moments that are empty, respectively.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.drop_negligible_operations(circuit)\ncircuit = cirq.drop_empty_moments(circuit)\ncircuit\n```\n\n----------------------------------------\n\nTITLE: Configuring Quantum Volume Experiment Parameters\nDESCRIPTION: This snippet imports `cirq` and `cirq_google` and defines configuration parameters for the Quantum Volume experiment. It sets the number of circuits, depth, maximum routing attempts, the range of routing attempts to test, the number of repetitions, and the qubit grid. It also defines a compiler function to optimize circuits for the `cirq.CZTargetGateset()` gate set.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_volume_routing.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport cirq_google\n\n# Configuration parameters. Feel free to mess with these!\nnum_circuits = 10\ndepth = 4\nmax_routing_attempts = 100\nrouting_attempts = range(1, max_routing_attempts, 10)\nrepetitions = 10_000\nqubits = cirq.GridQubit.rect(3,2)\n\ndef compiler(circuit):\n      return cirq.optimize_for_target_gateset(circuit, gateset=cirq.CZTargetGateset())\n\nprint(f\"Configuration: depth {depth} with \"\n      f\"{num_circuits} circuits of routing attempts {routing_attempts}\")\n```\n\n----------------------------------------\n\nTITLE: Grouping Measurement Results in a Histogram in Cirq\nDESCRIPTION: This code snippet demonstrates how to use the `fold_func` argument in the `histogram` method to group measurement results under a key before counting them up. It groups results based on whether the two measurement results agree.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nprint(\n    result.histogram(\n        key=\"a,b\", fold_func=lambda bits: \"agree\" if bits[0] == bits[1] else \"disagree\"\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Cherry-Pick Commits for Patch\nDESCRIPTION: This bash script integrates specific commits into the release branch using `git cherry-pick`. Merge conflicts must be resolved carefully. This is only used for PATCH updates.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/release.md#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\ngit cherry-pick <commit>\n```\n\n----------------------------------------\n\nTITLE: Initializing IonQ Service using Environment Variable in Python\nDESCRIPTION: This snippet shows how to instantiate a `cirq_ionq.Service` object without explicitly passing the API key. It relies on the `cirq_ionq` library to automatically retrieve the API key from the `IONQ_API_KEY` environment variable. It assumes the `IONQ_API_KEY` environment variable has been set previously.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/access.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport cirq_ionq as ionq\n\nservice = ionq.Service()\n```\n\n----------------------------------------\n\nTITLE: Validate Operations on Device\nDESCRIPTION: This snippet demonstrates how to validate operations on the Sycamore device. It shows that operations on adjacent qubits are validated, while operations on non-adjacent qubits raise a `ValueError` due to device constraints.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_80\n\nLANGUAGE: python\nCODE:\n```\n# Get non-adjacent qubits on the Sycamore device.\nq55 = cirq.GridQubit(5, 5)\nq56 = cirq.GridQubit(5, 6)\nq66 = cirq.GridQubit(6, 6)\n\n# Operations on adjacent qubits will be validated.\ncirq_google.Sycamore.validate_operation(cirq.SQRT_ISWAP(q55, q56))\ncirq_google.Sycamore.validate_operation(cirq.SQRT_ISWAP(q56, q66))\n\n# Operation on non-adjacent qubits will raise an error.\nops = [cirq.SQRT_ISWAP(q55, q66)]\ncircuit = cirq.Circuit(ops)\nprint(circuit)\n\ntry:\n    cirq_google.Sycamore.validate_circuit(circuit)\nexcept ValueError as ex:\n    print(f\"error, as expected: \\n{ex}\")\n```\n\n----------------------------------------\n\nTITLE: Initializing Walk State (Alternative) with Cirq\nDESCRIPTION: This code defines an alternative `initial_state()` function, which initializes the qubit register with a different starting state. In this case, it only applies an X gate to `cirq.GridQubit(0, 1)`, initializing the position vector, but *not* the coin qubit.  The effect of this changes the shape of the probability distribution of the walk.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/quantum_walks.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef initial_state():\n\n    yield cirq.X.on(cirq.GridQubit(0, 1))\n\nfinal = generate_walk(number_qubits, iterator, sample_number)\ngraph(final)\n```\n\n----------------------------------------\n\nTITLE: Running Mypy Type Checking\nDESCRIPTION: This command runs the mypy type checker on the Cirq project. It verifies that the code adheres to the defined type hints and catches potential type errors. It requires the 'check/mypy' script to be present and configured with mypy. files-and-flags-for-mypy are optional arguments for specifying files and flags for mypy.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n./check/mypy [files-and-flags-for-mypy]\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq in Python\nDESCRIPTION: This snippet attempts to import Cirq. If the import fails, it installs Cirq using pip and then re-imports it. It also imports IPython.display and inspect, and defines a function display_gates for displaying gate documentation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    \nimport IPython.display as ipd\nimport cirq\nimport inspect\n\ndef display_gates(*gates):\n    for gate_name in gates:\n        ipd.display(ipd.Markdown(\"---\"))\n        gate = getattr(cirq, gate_name)\n        ipd.display(ipd.Markdown(f\"#### cirq.{gate_name}\"))\n        ipd.display(ipd.Markdown(inspect.cleandoc(gate.__doc__ or \"\")))\n    else:\n        ipd.display(ipd.Markdown(\"---\"))    \n```\n\n----------------------------------------\n\nTITLE: Defining Pulse Gate Set in Cirq\nDESCRIPTION: This section configures the 'pulse' gate set within Cirq, which includes gates like 'coupler_pulse', 'fsim', 'xy', 'z', 'xyz', 'meas', 'wait', and 'circuit'. The 'coupler_pulse' gate takes arguments related to coupling strength, hold time, rise time, and padding time, allowing definition of pulse-level control.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-google/cirq_google/devices/specifications/weber_2021_12_10_device_spec.proto.txt#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nvalid_gate_sets {\n  name: \"pulse\"\n  valid_gates {\n    id: \"coupler_pulse\"\n    number_of_qubits: 2\n    valid_args {\n      name: \"coupling_mhz\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"hold_time_ns\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"rise_time_ns\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"padding_time_ns\"\n      type: FLOAT\n    }\n    valid_targets: \"2_qubit_targets\"\n  }\n  valid_gates {\n    id: \"fsim\"\n    number_of_qubits: 2\n    valid_args {\n      name: \"theta\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"phi\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"phase_match\"\n      type: STRING\n    }\n    valid_targets: \"2_qubit_targets\"\n  }\n  valid_gates {\n    id: \"xy\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"axis_half_turns\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"half_turns\"\n      type: FLOAT\n    }\n    gate_duration_picos: 25000\n  }\n  valid_gates {\n    id: \"z\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"half_turns\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"type\"\n      type: STRING\n    }\n  }\n  valid_gates {\n    id: \"xyz\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"x_exponent\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"z_exponent\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"axis_phase_exponent\"\n      type: FLOAT\n    }\n    gate_duration_picos: 25000\n  }\n  valid_gates {\n    id: \"meas\"\n    valid_args {\n      name: \"key\"\n      type: STRING\n    }\n    valid_args {\n      name: \"invert_mask\"\n      type: REPEATED_BOOLEAN\n    }\n    gate_duration_picos: 4000000\n    valid_targets: \"meas_targets\"\n  }\n  valid_gates {\n    id: \"wait\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"nanos\"\n      type: FLOAT\n    }\n  }\n  valid_gates {\n    id: \"circuit\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Quantum Simulation with Observables\nDESCRIPTION: This snippet seems to focus on quantum simulation, potentially utilizing observables to extract information from the simulation. The variables likely represent different configurations, time steps, or parameters within the simulation. A potential dependency could involve a numerical library like NumPy to manage the calculations of the expectation values.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_17\n\nLANGUAGE: Python\nCODE:\n```\nbhzkHBI9zEeT4SGDgBCh52VhQ87IyYI/wE0OHvy1/+8qBO/Jd/+ZeyePHiQX3Ha5kpeNg9QsHDzsjLOSh4eNk7tM0VAhQ87NgpeNgZ+SEHBQ8/eGlwNlLwsPOi4GFnFA05KHjYvUzBw84o3DkoeISbOM9HAgMnQMHDzoqCh50Rc4SfAEZr7Ny5c1AnXrZsmXzsYx8b1He8lpmCh90jFDzsjLycg4KHl71D21whQMHDjp2Ch52RH3JQ8PCDlwZnIwUPOy8KHnZG0ZCDgofdyxQ87IzCnYOCR7iJ83wkMHACFDzsrCh42BkxR3gJdHV1yYc+9CFpb28f1IljY2P1tFYJCQmD+p6XMlPwsHuDgoedkZdzUPDwsndomysEKHjYsVPwsDPyQw4KHn7w0uBspOBh50XBw84oGnJQ8LB7mYKHnVG4c1DwCDdxno8EBk6AgoedFQUPOyPmCC+BvXv3yg9+8IMhnfTP//zPZcWKFUP6rhe+RMHD7gUKHnZGXs5BwcPL3qFtrhCg4GHHTsHDzsgPOSh4+MFLg7ORgoedFwUPO6NoyEHBw+5lCh52R\n```\n\n----------------------------------------\n\nTITLE: Calculating Estimated Memory Usage of Contraction\nDESCRIPTION: This code calculates the estimated memory usage during the tensor network contraction based on the largest intermediate tensor size. It multiplies `path_info.largest_intermediate` (which is the size in complex128 entries) by 128 bits (size of a complex128 number), then divides by 8 to get bytes, then successively divides by 1024 three times to convert from bytes to kilobytes, megabytes and gigabytes.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\npath_info.largest_intermediate * 128 / 8 / 1024 / 1024 / 1024 # gb\n```\n\n----------------------------------------\n\nTITLE: Graph Datasets with Fidelity Plots, Python\nDESCRIPTION: This Python code snippet uses `matplotlib` to create a figure with subplots. It iterates through fidelity datasets (`fitted_fidelities`), axes, and titles, applying the `_p_gen` function to plot the data on each axis and adding extras like labels and titles. The `fig.tight_layout()` ensures the plots fit nicely within the figure, and `fig.show()` displays the plot.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfig, axes = plt.subplots(2, 2, figsize=(18, 13))\nfor fidelities, ax, title in zip(fitted_fidelities, axes.flat, noise_titles):\n    fidelities.apply(_p_gen(ax), axis=1)\n    extras(ax, title)\n\nfig.tight_layout()\nfig.show()\n```\n\n----------------------------------------\n\nTITLE: Transform Circuit for Hardware Qubit\nDESCRIPTION: Transforms a circuit to use an available hardware qubit by applying a lambda function to map qubits to a valid qubit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/start.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nhw_circuit = circuit.transform_qubits(lambda q: valid_qubit)\n\nprint(hw_circuit)\n```\n\n----------------------------------------\n\nTITLE: Running Pytest\nDESCRIPTION: This command runs the pytest test suite for the Cirq project. It executes all tests within the current directory and its subdirectories. Requires pytest to be installed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n./check/pytest .\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq using pip\nDESCRIPTION: This snippet attempts to import the cirq library and verifies that the cirq version is greater than 0.9. If the import or version check fails, it installs cirq using pip.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/getting_started.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\n    version = cirq.__version__.split(\".\")\n    assert int(version[0]) > 0 or int(version[1]) > 9, \"Cirq version >0.9 required\"\nexcept (ImportError, AssertionError):\n    print(\"Installing Cirq...\")\n    !pip install --quiet cirq\n    print(\"Cirq installed.\")\n```\n\n----------------------------------------\n\nTITLE: Defining a RotX Layer in Cirq\nDESCRIPTION: This function defines a layer of X rotations on a square grid of qubits.  It takes the length of the grid and the rotation amount (in half-turns) as input. It yields `cirq.XPowGate` operations for each qubit on the grid, parameterized by the `half_turns` argument.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/variational_algorithm.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef rot_x_layer(length, half_turns):\n    \"\"\"Yields X rotations by half_turns on a square grid of given length.\"\"\"\n\n    # Define the gate once and then re-use it for each Operation.\n    rot = cirq.XPowGate(exponent=half_turns)\n\n    # Create an X rotation Operation for each qubit in the grid.\n    for i in range(length):\n        for j in range(length):\n            yield rot(cirq.GridQubit(i, j))\n```\n\n----------------------------------------\n\nTITLE: Declaring mypy-protobuf Dependency for Proto Generation (Cirq-Google)\nDESCRIPTION: This line declares a dependency on the `mypy-protobuf` package, which provides support for generating mypy type stubs from `.proto` files. The version is pinned to `~=3.6`, meaning that the installed version should be compatible. This helps in ensuring type safety when working with protobuf-generated code in cirq-google.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/dev_tools/requirements/deps/protos.txt#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nmypy-protobuf~=3.6\n```\n\n----------------------------------------\n\nTITLE: Merging Upstream Main into Local Main\nDESCRIPTION: These commands switch to the main branch and merge the 'upstream/main' branch into your local 'main' branch. This synchronizes your local 'main' branch with the latest changes from the official Cirq repository. It requires git to be installed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ngit checkout main\n```\n\nLANGUAGE: shell\nCODE:\n```\ngit merge upstream/main\n```\n\n----------------------------------------\n\nTITLE: Setting IonQ API Key as Environment Variable in Bash\nDESCRIPTION: This snippet demonstrates how to set the `IONQ_API_KEY` environment variable in a Bash shell. This approach avoids storing the API key directly in the code, improving security. This command sets the environment variable for the current shell session.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/access.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport IONQ_API_KEY=tomyheart\n```\n\n----------------------------------------\n\nTITLE: Installing pre-release version of Cirq-Rigetti using pip\nDESCRIPTION: Installs the latest pre-release version of cirq-rigetti using pip. The ~= operator ensures that the latest compatible version is installed. This command allows users to access the newest features and bug fixes before the stable release.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-rigetti/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\npip install --upgrade cirq-rigetti~=1.0.dev\n```\n\n----------------------------------------\n\nTITLE: PauliStringPhasor Creation in Cirq\nDESCRIPTION: Shows how to create `PauliStringPhasor`s in Cirq, representing exponentials of Pauli strings. It covers cases where the result is a GateOperation or a PauliStringPhasor, and demonstrates the use of different bases with imaginary coefficients.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# When the PauliString simplifies to a single Pauli term, produce GateOperations\ntyprint(np.exp(1j * Xa))\ntyprint(np.exp(Xa * Za))  # XZ = -1j*Y\n# When the PauliString doesn't simplify to a single Pauli term, produce PauliStringPhasors\ntyprint(np.exp(1j * Xa * Xa))  # I doesn't count as a Pauli term\ntyprint(np.exp(1j * Xa * Zb))\n# All integer/float bases are supported with an imaginary-coefficient PauliString.\ntyprint(3 ** (1j * Xa * Zb))\n# Powers of unitary PauliStrings work...\ntyprint((Xa * Zb) ** 3)\n# but non-unitary PauliStrings don't.\ntry:\n    typrint((3j * Xa * Zb) ** 3)\nexcept TypeError as e:\n    print(e)\n```\n\n----------------------------------------\n\nTITLE: Generating ParamResolvers with Linspace in Cirq\nDESCRIPTION: This code shows how to use `cirq.Linspace` to create a sequence of `ParamResolver`s with equally spaced values for a given key. It iterates through the generated `ParamResolver`s and prints each one.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_65\n\nLANGUAGE: python\nCODE:\n```\nlinspace = cirq.Linspace(start=0, stop=1.0, length=11, key='x')\nfor p in linspace:\n    print(p)\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq Library in Python\nDESCRIPTION: This code snippet attempts to import the Cirq library. If Cirq is not installed, it installs it using pip.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/direct_fidelity_estimation.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Comparing Simulated and Theoretical Distributions\nDESCRIPTION: This code iterates through a range of run values and generates the simulated distribution of the random walk for each value. This allows for a visual comparison of how the simulated distribution converges towards the theoretical distribution as the number of runs increases.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/quantum_walks.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nrun_range = [50, 100, 500, 1000, 5000, 10000]\nfor run in run_range:\n    dist(run, N)\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq with pip\nDESCRIPTION: This code snippet attempts to import the Cirq library. If Cirq is not found, it installs it using pip and then imports it. The numpy and sympy libraries are also imported.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/operators.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n    \nimport numpy as np\nimport sympy.parsing.sympy_parser as sympy_parser\n```\n\n----------------------------------------\n\nTITLE: Inspecting Kraus operators of a channel\nDESCRIPTION: This snippet iterates through the Kraus operators of a bit-flip channel (created previously) and prints each operator. The `cirq.kraus` protocol is used to obtain the Kraus operators, providing a representation of the channel's effect on the density matrix.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfor i, kraus in enumerate(cirq.kraus(bit_flip)):\n    print(f\"Kraus operator {i + 1} is:\\n\", kraus, end=\"\\n\\n\")\n```\n\n----------------------------------------\n\nTITLE: Cirq Installation Check and Import\nDESCRIPTION: This code snippet checks if the cirq library is installed and installs it using pip if it is not found. It then imports the cirq library for use in subsequent code.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/simulation.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n```\n\n----------------------------------------\n\nTITLE: Install and Import Cirq\nDESCRIPTION: This snippet checks if the Cirq library is installed and installs it if it's not.  It then imports the Cirq library. This is a prerequisite for using any Cirq functionality.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/transformers.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    import cirq\n\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Running Circuit on AQT Local Simulator (Python)\nDESCRIPTION: This code snippet runs a given quantum circuit on the AQT local simulator for a specified number of repetitions (100 in this case). The circuit will be either ideal or noisy, depending on the simulator's configuration. The results of the simulation are printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/aqt/getting_started.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\naqt_sweep = aqt_sampler.run(circuit, repetitions=100)\nprint(aqt_sweep)\n```\n\n----------------------------------------\n\nTITLE: Initializing Z Stabilizer Circuit without Noise (Cirq)\nDESCRIPTION: This snippet initializes a Z stabilizer circuit using Cirq. It defines data qubits and a measure qubit, then constructs a circuit with CX gates from each data qubit to the measure qubit, followed by a measurement of the measure qubit. The purpose is to demonstrate a noiseless Z stabilizer where all qubits remain in the |0⟩ state.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndata_qubits = [cirq.NamedQubit('data_' + str(x)) for x in 'abcd']\nmeasure_qubit = cirq.NamedQubit('_meas')\nstabilizer_circuit = cirq.Circuit(\n    *[cirq.CX(data_qubit, measure_qubit) for data_qubit in data_qubits],\n    cirq.measure(measure_qubit, key='meas'),\n)\n\nprint(f'Z-stabilizer circuit:')\nprint('========================')\nprint(stabilizer_circuit)\n```\n\n----------------------------------------\n\nTITLE: Using Mixture Protocol with Unitary Gate\nDESCRIPTION: This code demonstrates that if an operator implements `SupportsUnitary` but not `SupportsMixture`, `cirq.mixture` falls back to the unitary representation. It prints the mixture and the result of `cirq.has_mixture` for the Pauli-Y gate, showing that it is treated as a mixture with probability 1 and the original unitary gate.  This illustrates the fallback behavior of the mixture protocol.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/protocols.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# cirq.Y has a unitary effect but does not implement SupportsMixture\n# thus mixture protocols will return ((1, cirq.unitary(Y)))\nprint(cirq.mixture(cirq.Y))\nprint(cirq.has_mixture(cirq.Y))\n```\n\n----------------------------------------\n\nTITLE: PauliString as SingleQubitPauliStringGateOperation\nDESCRIPTION: This code verifies that a `cirq.SingleQubitPauliStringGateOperation`, such as `Xa`, is also a `PauliString`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntyprint(Xa)\nprint(issubclass(Xa.__class__, cirq.PauliString))\n```\n\n----------------------------------------\n\nTITLE: Displaying Three Qubit Pow Gates in Cirq\nDESCRIPTION: This snippet uses the display_gates function to display documentation for the three qubit PowGates CCXPowGate and CCZPowGate. The display_gates function retrieves each gate from the cirq module and displays its docstring using IPython.display.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndisplay_gates(\"CCXPowGate\", \"CCZPowGate\")\n```\n\n----------------------------------------\n\nTITLE: Applying a Custom Qutrit Gate in Cirq\nDESCRIPTION: This snippet demonstrates how to create a `cirq.LineQid` with dimension 3 (a qutrit) and apply the custom `QutritPlusGate` to it within a `cirq.Circuit`. It then prints the circuit to show the gate acting on the qutrit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/qudits.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Here we create a qutrit for the gate to act on. \nq0 = cirq.LineQid(0, dimension=3)\n\n# We can now enact the gate on this qutrit.\ncircuit = cirq.Circuit(\n    QutritPlusGate().on(q0)\n)\n\n# When we print this out we see that the qutrit is labeled by its dimension.\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Using InsertStrategy.INLINE in Cirq with Python\nDESCRIPTION: This snippet demonstrates the `InsertStrategy.INLINE` strategy. After appending two initial `CZ` gates, it attempts to insert three Hadamard gates.  The H gate acting on q0 is placed inline (in the same moment as the two CZ gates from the previous moments), but the H gates acting on q1 and q2 cannot be placed inline (because they conflict with the existing CZ gates) so they are placed in a new moment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit()\ncircuit.append([cirq.CZ(q1, q2)])\ncircuit.append([cirq.CZ(q1, q2)])\ncircuit.append([cirq.H(q0), cirq.H(q1), cirq.H(q2)], strategy=InsertStrategy.INLINE)\n\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Visualizing all Hardcoded Placements in Cirq\nDESCRIPTION: This code visualizes all the hardcoded placements defined in `rainbow_mapping`. It iterates through the mappings, creates subplots for each placement, and uses `cirq.draw_placements` to display the mapping of the topology onto the device graph.  This provides a visual overview of all supported placements for the `HardcodedQubitPlacer`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/qubit-placement.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom math import ceil\n\nn_col = 3\nn_row = int(ceil(len(rainbow_mapping)/n_col))\nfig, axes = plt.subplots(n_row, n_col, figsize=(4*n_col, 3*n_row))\naxes = axes.reshape(-1)\nfor i, (topo, mapping) in enumerate(rainbow_mapping.items()):\n\n    axes[i].set_title(f'{topo.width}x{topo.height}')\n    cirq.draw_placements(rainbow_graph, topo.graph, [mapping],\n                         tilted=False, axes=axes[i:i+1])\n    \nfig.suptitle(\"All hardcoded placements\", fontsize=14)\nfig.tight_layout()\n```\n\n----------------------------------------\n\nTITLE: Compute multiplicative group modulo n in Python\nDESCRIPTION: This function calculates the multiplicative group modulo n, which consists of positive integers less than n that are relatively prime to n.  It iterates through numbers from 2 to n, checks if the greatest common divisor (GCD) with n is 1, and adds the number to the group if it is. The function takes an integer n as input and returns a list of integers representing the multiplicative group.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef multiplicative_group(n: int) -> List[int]:\n    \"\"\"Returns the multiplicative group modulo n.\n    \n    Args:\n        n: Modulus of the multiplicative group.\n    \"\"\"\n    assert n > 1\n    group = [1]\n    for x in range(2, n):\n        if math.gcd(x, n) == 1:\n            group.append(x)\n    return group\n```\n\n----------------------------------------\n\nTITLE: Single line code\nDESCRIPTION: This snippet showcases the string 'c'. The comment above suggests that it represents code and that it doesn't have a newline character at the end.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/dev_tools/requirements/test_data/sub/c.req.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nc\n```\n\n----------------------------------------\n\nTITLE: Initializing a Quantum Circuit with Cirq in Python\nDESCRIPTION: This snippet likely represents the initialization or use of a quantum circuit using the Cirq framework in Python.  It probably involves creating a circuit object and potentially defining qubits or operations to be added to the circuit. Further analysis would be needed to determine the specific actions taken.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nimport cirq\n# Code related to circuit initialization or usage\n# Further deobfuscation is needed to reveal the exact actions.\n```\n\n----------------------------------------\n\nTITLE: Sourcing Python Path Configuration\nDESCRIPTION: This command sources the 'dev_tools/pypath' script, which configures the Python path to include the development copy of Cirq and its subpackages. This allows you to import and use your local changes in Cirq without installing it. It requires the 'dev_tools/pypath' script to be present.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nsource dev_tools/pypath\n```\n\n----------------------------------------\n\nTITLE: Fetching Current Calibration\nDESCRIPTION: This snippet retrieves the latest calibration data from the IonQ service using the `get_current_calibration()` method.  It assumes that a `cirq_ionq.Service` object has been initialized and is available as `service`. Returns a `cirq_ionq.Calibration` object containing fidelity and timing information.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/calibrations.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncalibration = service.get_current_calibration()\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq with Pip\nDESCRIPTION: This snippet attempts to import the Cirq library. If Cirq is not found, it uses pip to install the library and then imports it. Matplotlib is also imported for plotting.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/state_histograms.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\nimport matplotlib.pyplot as plt\n```\n\n----------------------------------------\n\nTITLE: Importing Cirq and NumPy\nDESCRIPTION: This snippet imports the core Cirq library and the NumPy library. Cirq is used for quantum circuit construction and manipulation, while NumPy provides numerical computation capabilities required for various data processing and analysis tasks within the experiment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/isolated_xeb.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport numpy as np\n```\n\n----------------------------------------\n\nTITLE: Publishing a Development Package to Test PyPI\nDESCRIPTION: Shows the command to publish a development package to the test PyPI repository. It requires specifying the expected version and setting the `TEST_TWINE_USERNAME` and `TEST_TWINE_PASSWORD` environment variables.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\n./dev_tools/packaging/publish-dev-package.sh EXPECTED_VERSION --test\n```\n\n----------------------------------------\n\nTITLE: Example Docstring Format in Cirq\nDESCRIPTION: Demonstrates the Google-style docstring format used in Cirq, including Markdown and LaTeX support. This format includes a one-line summary, additional information, LaTeX equations, example code, arguments, return values, and raised exceptions.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ndef some_method(a: int, b: str) -> float:\n    r\"\"\"One line summary of method.\n\n    Additional information about the method, perhaps with some sort of LaTeX\n    equation to make it clearer:\n\n        $$\n        M = \\begin{bmatrix}\n                0 & 1 \\\\\n                1 & 0\n            \\end{bmatrix}\n        $$\n\n    Notice that this docstring is an r-string, since the LaTeX has backslashes.\n    We can also include example code:\n\n        print(cirq_google.Sycamore)\n\n    You can also do inline LaTeX like $y = x^2$ and inline code like\n    `cirq.unitary(cirq.X)`.\n\n    And of course there's the standard sections.\n\n    Args:\n        a: The first argument.\n        b: Another argument.\n\n    Returns:\n        An important value.\n\n    Raises:\n        ValueError: The value of `a` wasn't quite right.\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Install Dependencies from Requirements Files\nDESCRIPTION: This snippet installs dependencies specified in three different requirements files: `cirq-all.txt`, `pytest.txt`, and `notebook.txt`. The `-r` flag tells pip to install from a requirements file.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/dev_tools/requirements/notebooks.env.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n-r deps/cirq-all.txt\n-r deps/pytest.txt\n-r deps/notebook.txt\n```\n\n----------------------------------------\n\nTITLE: Classical Control with SymPy Indexed Objects in Cirq\nDESCRIPTION: This code demonstrates the usage of SymPy's indexed objects to create complex boolean functions as conditions for classical control in Cirq. The X gate on `q2` is applied if and only if the measurement of `q0` and `q1` results in two different bits. The circuit is simulated, and measurement results are printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/classical_control.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nm = sympy.IndexedBase('q0_q1')\nq0, q1, q2 = cirq.LineQubit.range(3)\nsympy_indexed_condition = sympy.Xor(m[0], m[1])\ncircuit = cirq.Circuit(\n    cirq.H.on_each(q0, q1),\n    cirq.measure(q0, q1, key='q0_q1'),\n    cirq.X(q2).with_classical_controls(sympy_indexed_condition),\n    cirq.measure(q2, key='q2'),\n)\nprint(circuit)\nresults = cirq.Simulator(seed=2).run(circuit, repetitions=8)\nprint(results.data)\n```\n\n----------------------------------------\n\nTITLE: Repeating and Mapping Qubits in CircuitOperation\nDESCRIPTION: This example shows how to create copies of a `CircuitOperation` with repetitions and qubit mappings.  It demonstrates repeating a subcircuit twice and then creating another copy that replaces qubit `q0` with `q2` using `with_qubit_mapping`. The modified subcircuits are then added to the main circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nsubcircuit_op = cirq.CircuitOperation(cirq.FrozenCircuit(cirq.CZ(q0, q1)))\n\n# Create a copy of subcircuit_op that repeats twice...\nrepeated_subcircuit_op = subcircuit_op.repeat(2)\n\n# ...and another copy that replaces q0 with q2 to perform CZ(q2, q1).\nmoved_subcircuit_op = subcircuit_op.with_qubit_mapping({q0: q2})\ncircuit = cirq.Circuit(repeated_subcircuit_op, moved_subcircuit_op)\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Initializing Cirq and IonQ Service in Python\nDESCRIPTION: This snippet initializes the Cirq and Cirq-IonQ libraries and instantiates the `Service` object, which is used to interact with the IonQ API. This is a necessary prerequisite for all subsequent code examples in the document.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/jobs.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport cirq_ionq as ionq\nservice = ionq.Service()\n```\n\n----------------------------------------\n\nTITLE: Ejecting Phased Pauli Gates in Cirq\nDESCRIPTION: This snippet utilizes the `cirq.eject_phased_paulis` optimizer to push `cirq.X`, `cirq.Y`, and `cirq.PhasedXPowGate` gates towards the end of the circuit. This helps in simplifying the circuit and potentially reducing its depth.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.eject_phased_paulis(circuit)\ncircuit\n```\n\n----------------------------------------\n\nTITLE: Validating the Routed Circuit (Python)\nDESCRIPTION: This snippet compiles the routed circuit using the Sycamore target gateset to ensures that all 2-qubit operations are physically adjacent. It then validates the compiled circuit against the device's constraints, confirming its suitability for execution.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/routing_transformer.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Compile the gates in routed_circuit to Sycamore gates (this is done because `validate_circuit` checks\n# that all 2-qubit operations are physically adjacent AND that all gates are part of the device's gateset).\nrouted_circuit = cirq.optimize_for_target_gateset(routed_circuit, gateset = cg.SycamoreTargetGateset())\n# Validate our circuit\ndevice.validate_circuit(routed_circuit)\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq and Cirq-Google\nDESCRIPTION: This snippet attempts to import the `cirq` and `cirq_google` libraries. If the import fails (indicating that the libraries are not installed), it uses `pip` to install them and then imports them.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/internal_gates.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\n    import cirq_google\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n    import cirq_google\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq if not present\nDESCRIPTION: This snippet attempts to import the `cirq` library. If it's not found, it installs Cirq using pip and prints confirmation messages. This ensures the notebook can run even if Cirq isn't already installed in the environment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_volume_routing.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Using Cirq Transformers to Optimize Circuits\nDESCRIPTION: This code snippet demonstrates how to use a Cirq transformer to optimize a quantum circuit. Specifically, it uses the cirq.merge_single_qubit_gates_to_phxz transformer to merge consecutive single-qubit gates into a single PhasedXZ operation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nq = cirq.GridQubit(1, 1)\nc = cirq.Circuit(cirq.X(q) ** 0.25, cirq.Y(q) ** 0.25, cirq.Z(q) ** 0.25)\nprint(c)\nc = cirq.merge_single_qubit_gates_to_phxz(c)\nprint(c)\n```\n\n----------------------------------------\n\nTITLE: Setting Plotting Styles\nDESCRIPTION: This snippet configures Matplotlib and Seaborn to customize the plot appearance, improving readability and visual appeal. It sets the plot style to 'ticks' using Seaborn and adjusts font sizes for axis labels, titles, tick labels, and legend elements using Matplotlib's rc parameters.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n%matplotlib inline\nfrom matplotlib import pyplot as plt\n\nimport seaborn as sns\nsns.set_style('ticks')\n\nplt.rc('axes', labelsize=16, titlesize=16)\nplt.rc('xtick', labelsize=14)\nplt.rc('ytick', labelsize=14)\nplt.rc('legend', fontsize=14, title_fontsize=16)\n```\n\n----------------------------------------\n\nTITLE: Installing pre-release cirq-web using pip\nDESCRIPTION: This command installs the latest pre-release version of the cirq-web package using the pip package manager. The `--upgrade` flag ensures any existing versions are updated, and the `~=` operator selects the newest compatible version within the 1.x.dev range. This provides access to the newest features, but may be less stable.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-web/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install --upgrade cirq-web~=1.0.dev\n```\n\n----------------------------------------\n\nTITLE: Creating and Simulating a Quantum Circuit in Cirq\nDESCRIPTION: This snippet creates a `cirq.NamedQubit`, constructs a simple quantum circuit with a Hadamard gate applied to the qubit, and simulates the circuit using `cirq.Simulator`. It then prints the circuit and the simulation results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/qubits.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nqubit = cirq.NamedQubit(\"myqubit\")\n\n# creates an equal superposition of |0> and |1> when simulated\ncircuit = cirq.Circuit(cirq.H(qubit))\n\n# see the \"myqubit\" identifier at the left of the circuit\nprint(circuit)\n\n# run simulation\nresult = cirq.Simulator().simulate(circuit)\n\nprint(\"result:\")\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Insert noise in a circuit with with_noise\nDESCRIPTION: Shows how to insert noise into a circuit using the `with_noise` method. The example generates a random noiseless circuit and then adds a depolarizing channel after every moment. The resulting noisy circuit is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# Define some noiseless circuit.\ncircuit = cirq.testing.random_circuit(qubits=3, n_moments=3, op_density=1, random_state=11)\n\n# Display the noiseless circuit.\nprint(\"Circuit without noise:\")\nprint(circuit)\n\n# Add noise to the circuit.\nnoisy = circuit.with_noise(cirq.depolarize(p=0.01))\n\n# Display it.\nprint(\"\\nCircuit with noise:\")\nprint(noisy)\n```\n\n----------------------------------------\n\nTITLE: Nested Requirement File Inclusion with Subdirectory\nDESCRIPTION: This snippet shows how to include a requirements file located in a subdirectory named `sub`. It includes `c.req.txt` using the `-r` option, effectively adding the dependencies defined in `c.req.txt`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/dev_tools/requirements/test_data/a.req.txt#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n-r sub/c.req.txt\n```\n\n----------------------------------------\n\nTITLE: Appending operations with InsertStrategy.NEW_THEN_INLINE\nDESCRIPTION: This snippet demonstrates the `InsertStrategy.NEW_THEN_INLINE` strategy in Cirq. It creates a circuit and appends a CZ gate using this strategy, then appends three H gates, also using the same strategy.  `NEW_THEN_INLINE` causes all three appended H gates to be placed in the same moment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Appending operations with InsertStrategy.NEW_THEN_INLINE.\"\"\"\n# Create an empty circuit.\ncircuit = cirq.Circuit()\n\n# Append an operation.\ncircuit.append([cirq.CZ(a, b)], strategy=cirq.InsertStrategy.NEW_THEN_INLINE)\n\n# Append more operations.\ncircuit.append([cirq.H(a), cirq.H(b), cirq.H(c)], strategy=cirq.InsertStrategy.NEW_THEN_INLINE)\n\n# Display the circuit.\nprint(\"Circuit:\\n\")\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Plotting HOG Probability vs. Error Rate\nDESCRIPTION: This snippet generates a plot of the heavy output generation (HOG) probability against the simulated error rate.  It calculates the mean HOG probability for each error rate and plots the results using matplotlib.  It also includes lines indicating the asymptotic ideal HOG probability and the HOG threshold.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_volume_errors.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom matplotlib import pyplot as plt\nimport statistics\n\ndef chunks(l, n):\n    \"\"\"Yield successive n-sized chunks from l.\"\"\"\n    for i in range(0, len(l), n):\n        yield l[i:i + n]\n        \nsplit = chunks([res.sampler_result for res in result], num_circuits)\nfig, axs = plt.subplots()\naxs.plot(errors,\n         [statistics.mean(chunk) for chunk in split])\n\n# Line markers for asymptotic ideal heavy output probability and the ideal Heavy\n# Output Generation threshold.\naxs.axhline((1 + np.log(2)) / 2,\n            color='tab:green',\n            label='Asymptotic ideal',\n            linestyle='dashed')\naxs.axhline(2 / 3, label='HOG threshold', color='k', linestyle='dotted')\nplt.xscale('log')\naxs.set_ybound(0.4, 1)\naxs.set_xlabel(\"error rate\")\naxs.set_ylabel(\"est. heavy output probability\")\nfig.suptitle(f'HOG probability by simulated error rate for d={depth}')\n```\n\n----------------------------------------\n\nTITLE: Checking for Lint\nDESCRIPTION: This command checks for linting issues in the Cirq project using pylint. It enforces code style and quality standards. It requires the 'check/pylint' script to be present. files-and-flags-for-pylint are optional arguments for specifying files and flags for pylint.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\n./check/pylint [files-and-flags-for-pylint]\n```\n\n----------------------------------------\n\nTITLE: Implementing Client Code and Bundle Name in Cirq with Python\nDESCRIPTION: This snippet shows how to implement the `get_client_code` and `get_widget_bundle_name` methods in your visualization class. These methods are responsible for returning the client-side Javascript/HTML code and the name of the Javascript bundle file respectively. `widget.Widget` is imported from the `cirq_web` package.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-web/cirq_web/README.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq_web import widget\n\nclass MyWidget(widget.Widget):\n    ...\n    def get_client_code(self) -> str:\n        return f\"\"\"\n            <script>\n            YOUR_CLIENT_CODE\n            </script>\n        \"\"\"\n\n    def get_widget_bundle_name(self) -> str:\n        return 'YOUR_BUNDLE_FILE.bundle.js'\n```\n\n----------------------------------------\n\nTITLE: Optimizing Circuit for IonQ Gate Set\nDESCRIPTION: This snippet demonstrates how to use `cirq.optimize_for_target_gateset` and `cirq_ionq.IonQTargetGateset` to convert a circuit with non-native gates into a circuit composed of IonQ-supported gates. It defines a circuit with a non-API gate (Hadamard raised to a power), and then it converts the circuit into one composed only of native IonQ gates.  The resulting optimized circuit is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/circuits.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nq0 = cirq.LineQubit(0)\ncircuit = cirq.Circuit(cirq.H(q0)**0.2)  # Non-API gate\ncircuit_for_ionq = cirq.optimize_for_target_gateset(\n    circuit,\n    gateset=ionq.IonQTargetGateset(),\n)\nprint(circuit_for_ionq)\n```\n\n----------------------------------------\n\nTITLE: Installing System Dependencies (Debian)\nDESCRIPTION: This snippet shows how to install system dependencies on Debian-based Linux systems that pip cannot handle. In this specific case, it installs texlive-latex-base to support PDF printing.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/install.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt install $(cat apt-system-requirements.txt)\n```\n\n----------------------------------------\n\nTITLE: Apache License 2.0 Header in Python\nDESCRIPTION: This code snippet includes the Apache 2.0 license header, specifying the terms and conditions under which the software is licensed, including permissions, limitations, and distribution guidelines.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n#@title Licensed under the Apache License, 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n```\n\n----------------------------------------\n\nTITLE: Cirq Installation and Setup\nDESCRIPTION: This code block installs the Cirq library if it's not already installed and imports necessary modules such as cirq, numpy, matplotlib.pyplot, and pandas. It also sets a seed for numpy for deterministic results and configures numpy printing options.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Initial setup to install Cirq and set up dependencies for the tutorial.\ntry:\n    import cirq\nexcept:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n\nfrom typing import Sequence, Tuple\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Sets a seed for deterministic results.  Uncomment for random results each run.\nnp.random.seed(2021)\nnp.set_printoptions(precision=3, suppress=True, linewidth=200)\n```\n\n----------------------------------------\n\nTITLE: Checking Code Formatting Incrementally\nDESCRIPTION: This command checks and optionally applies code formatting to changed lines in the Cirq project. It requires the 'check/format-incremental' script to be present and configured with a code formatter like black. BASE_REVISION is an optional argument specifying the commit to compare against.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n./check/format-incremental [--apply] [BASE_REVISION]\n```\n\n----------------------------------------\n\nTITLE: Importing Cirq and Installing if Necessary\nDESCRIPTION: This snippet attempts to import the Cirq library. If Cirq is not installed, it installs Cirq using pip and then imports it.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/qubits.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n```\n\n----------------------------------------\n\nTITLE: Initializing IonQ Service\nDESCRIPTION: This snippet initializes the `cirq_ionq.Service` object and imports `cirq` and `cirq_ionq`.  It's a necessary prerequisite for interacting with the IonQ API to fetch calibration data or submit jobs. Requires the `cirq` and `cirq_ionq` libraries to be installed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/calibrations.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport cirq_ionq as ionq\nservice = ionq.Service()\n```\n\n----------------------------------------\n\nTITLE: Defining Theme Colors\nDESCRIPTION: This code defines a set of color constants used for plotting and visualization within the notebook.  The colors are defined in hexadecimal format, making it easier to reference them throughout the notebook when creating figures or plots.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# theme colors\nQBLUE = '#1967d2'\nQRED = '#ea4335ff'\nQGOLD = '#fbbc05ff'\nQGREEN = '#34a853ff'\n\nQGOLD2 = '#ffca28'\nQBLUE2 = '#1e88e5'\n```\n\n----------------------------------------\n\nTITLE: Nested Requirement File Inclusion\nDESCRIPTION: This snippet demonstrates how to include another requirements file named `b.req.txt` using the `-r` option. The requirements listed in `b.req.txt` will be installed as dependencies.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/dev_tools/requirements/test_data/a.req.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n -r b.req.txt\n```\n\n----------------------------------------\n\nTITLE: Authenticate to Google Cloud with gcloud\nDESCRIPTION: This command authenticates your local environment with your Google Cloud account using the gcloud CLI, enabling you to access Google Cloud services.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/engine.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngcloud auth application-default login\n```\n\n----------------------------------------\n\nTITLE: Importing Cirq Modules\nDESCRIPTION: This snippet imports the Cirq library and the SVGCircuit module from cirq.contrib.svg.  SVGCircuit is used for visualizing quantum circuits as SVG images.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/svg/example.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nfrom cirq.contrib.svg import SVGCircuit\n```\n\n----------------------------------------\n\nTITLE: Fourier Transform Example in Python\nDESCRIPTION: Demonstrates the usage of the `fourier_transform_over_z2` function with different input arrays 'f'. It calculates and prints the Fourier transform 'f_hat' for each input array. The code initializes a numpy array 'f', calculates its Fourier transform using `fourier_transform_over_z2`, and prints both the original array and its transform.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nf = np.array([1, -1, 1, -1])\nf_hat = fourier_transform_over_z2(f)\nprint(f\"f: {list(f)} f_hat: {list(f_hat)}\")\n\nf = np.array([1, 1, 1, -1])\nf_hat = fourier_transform_over_z2(f)\nprint(f\"f: {list(f)} f_hat: {list(f_hat)}\")\n\nf = np.array([1, -1, -1, 1])\nf_hat = fourier_transform_over_z2(f)\nprint(f\"f: {list(f)} f_hat: {list(f_hat)}\")\n```\n\n----------------------------------------\n\nTITLE: Mixed State Simulation with DensityMatrixSimulator (Python)\nDESCRIPTION: This snippet demonstrates how to simulate a quantum circuit using `cirq.DensityMatrixSimulator`, which allows for simulating mixed states and noisy channels. It creates a circuit with a Hadamard gate and an amplitude damping channel, then runs the simulation and prints the histogram of measurement results to demonstrate the effect of the damping channel.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/simulation.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nq = cirq.NamedQubit('a')\ncircuit = cirq.Circuit(cirq.H(q), cirq.amplitude_damp(0.2)(q), cirq.measure(q))\nsimulator = cirq.DensityMatrixSimulator()\nresult = simulator.run(circuit, repetitions=100)\nprint(result.histogram(key='a'))\n```\n\n----------------------------------------\n\nTITLE: Parameterized Circuit Simulation with Symbol and ParamResolver (Python)\nDESCRIPTION: This snippet demonstrates how to define a parameterized quantum circuit using `sympy.Symbol` and simulate it using `cirq.ParamResolver` to assign values to the symbol at runtime. It iterates through a range of values for the symbol 'x', simulating the circuit for each value and printing the resulting state vector.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/simulation.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nrot_w_gate = cirq.X ** sympy.Symbol('x')\ncircuit = cirq.Circuit()\ncircuit.append([rot_w_gate(q0), rot_w_gate(q1)])\nprint(circuit)\nfor y in range(5):\n    resolver = cirq.ParamResolver({'x': y / 4.0})\n    result = simulator.simulate(circuit, resolver)\n    print(f\"params:{result.params}, state vector:{np.round(result.final_state_vector, 2)}\")\n```\n\n----------------------------------------\n\nTITLE: Setup Cirq Environment in Python\nDESCRIPTION: This code snippet attempts to import the Cirq library and installs it if it's not already installed. It also imports other necessary libraries like cirq_google, numpy, and matplotlib.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/qubit_picking.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# @title Setup\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n\nimport cirq_google\nimport numpy as np\nfrom matplotlib import pyplot as plt\n```\n\n----------------------------------------\n\nTITLE: SquareDevice Class Definition\nDESCRIPTION: This snippet defines a custom `SquareDevice` class that inherits from `cirq.Device`. It restricts allowed gates to H, CZ, and MeasurementGate and validates the location of qubits within a specified square grid.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_82\n\nLANGUAGE: python\nCODE:\n```\nclass SquareDevice(cirq.Device):\n    \"\"\"A Square Grid Device.\n\n    The device that only allows\n        1) Grid Qubits from (0, 0) to (grid_size - 1, grid_size - 1)\n        2) H, CZ and MeasurementGate gates.\n    \"\"\"\n\n    def __init__(self, grid_size):\n        self.qubits = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                self.qubits.append(cirq.GridQubit(i, j))\n\n    def validate_operation(self, operation: 'cirq.Operation') -> None:\n        if not isinstance(operation, cirq.GateOperation):\n            raise ValueError(f\"Unsupported operation {operation}\")\n        if not (\n            operation.gate in [cirq.H, cirq.CZ] or isinstance(operation.gate, cirq.MeasurementGate)\n        ):\n            raise ValueError(f\"Unsupported gate {operation.gate}\")\n        for qubit in operation.qubits:\n            if qubit not in self.qubits:\n                raise ValueError(f\"Qubit {qubit} not on device\")\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq-core (Stable)\nDESCRIPTION: This command installs the stable version of the `cirq-core` module using pip. It ensures that you have the production-ready version of the library.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install cirq-core\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq\nDESCRIPTION: This snippet attempts to import the Cirq library. If the import fails (ImportError), it executes a shell command to install Cirq using pip. The --quiet flag minimizes the output during the installation process.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/svg/example.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Testing with Multiple Random Problems\nDESCRIPTION: Tests the algorithm with 10 random problem instances, verifying that the quantum solution produces a correct result for each instance.  Uses find_interesting_problem to avoid trivial problems.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/hidden_linear_function.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfor _ in range(10):\n    test_problem(find_interesting_problem(8, 4))\nprint('OK')\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq in Python\nDESCRIPTION: This code snippet attempts to import the Cirq library and installs it if it's not already present. It first tries to import `cirq`, and if an `ImportError` occurs, it uses `pip` to install Cirq and then imports it again.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/representing_noise.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq\nDESCRIPTION: This code snippet attempts to import the Cirq library. If Cirq is not installed, it uses pip to install it. This ensures that the notebook can run even if Cirq is not already present in the environment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_volume.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Computing Incremental Coverage\nDESCRIPTION: This command computes incremental test coverage using only tests associated with changed files. This speeds up coverage analysis by focusing on relevant code. It requires the 'check/pytest-changed-files-and-incremental-coverage' script to be present. BASE_REVISION is an optional argument specifying the commit to compare against.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n./check/pytest-changed-files-and-incremental-coverage [BASE_REVISION]\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq and Quimb\nDESCRIPTION: This code snippet installs Cirq and Quimb libraries using pip if they are not already installed. It uses try-except blocks to handle potential ImportError exceptions, ensuring that the installation process only runs when necessary.  The !pip command executes shell commands within the notebook environment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport importlib.util\n\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n\ntry:\n    import quimb\nexcept ImportError:\n    print(\"installing cirq-core[contrib]...\")\n    !pip install --quiet 'cirq-core[contrib]'\n    print(\"installed cirq-core[contrib].\")\n```\n\n----------------------------------------\n\nTITLE: Retrieving Calibration Metrics from a Processor Using Cirq-Google\nDESCRIPTION: This code demonstrates how to retrieve calibration metrics from a quantum processor using the Cirq-Google library. It covers getting the latest calibration, a specific calibration by timestamp, a list of calibrations within a time frame, and the calibration used by a specific job. The snippet relies on `cirq_google` and environment variables for project and processor IDs.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/calibration.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cirq_google as cg\n\n# Create an Engine object to use.\n# Replace YOUR_PROJECT_ID with the id from your cloud project.\nengine = cg.Engine(project_id=YOUR_PROJECT_ID)\nprocessor = engine.get_processor(processor_id=PROCESSOR_ID)\n\n# Get the latest calibration metrics.\nlatest_calibration = processor.get_current_calibration()\n\n# If you know the timestamp of a previous calibration, you can retrieve the\n# calibration using the timestamp in epoch seconds.\nprevious_calibration = processor.get_calibration(CALIBRATION_SECONDS)\n\n# If you would like to find a calibration from a time-frame, use this.\ncalibration_list = processor.list_calibration(START_SECONDS, END_SECONDS)\n\n# If you know the job-id, you can retrieve the calibration that the job used.\njob = engine.get_job(\"projects/\" + PROJECT_ID\n                   + \"/programs/\"+PROGRAM_ID\n                   + \"/jobs/\" + JOB_ID)\njob_calibration = cg.EngineJob(cg.JobConfig(), job, engine).get_calibration()\n\n# The calibration can be iterated through using something like the following.\nfor metric_name in latest_calibration:\n  print(metric_name)\n  print('------')\n  for qubit_or_pair in latest_calibration[metric_name]:\n     # Note that although the value is often singular,\n     # the metric_value is of the type list and can have multiple values.\n     metric_value = latest_calibration[metric_name][qubit_or_pair]\n     print(f'{qubit_or_pair} = {metric_value}')\n```\n\n----------------------------------------\n\nTITLE: License Header\nDESCRIPTION: This code snippet is a license header, specifying the Apache License 2.0 under which the code is licensed. It informs users about the terms of use, redistribution, and modification of the code.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/gates.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n#@title Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n```\n\n----------------------------------------\n\nTITLE: Verifying a Published Package on Test PyPI\nDESCRIPTION: Illustrates how to verify a published package on the test PyPI repository. It requires the full version reported by the publish script.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\n./dev_tools/packaging/verify-published-package.sh FULL_VERSION_REPORTED_BY_PUBLISH_SCRIPT --test\n```\n\n----------------------------------------\n\nTITLE: Installing and Testing Cirq Package\nDESCRIPTION: Demonstrates installing the Cirq package using pip and then running example code to verify the installation and version.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_33\n\nLANGUAGE: bash\nCODE:\n```\npython -m pip install cirq\npython -c \"import cirq; print(cirq_google.Sycamore)\"\npython -c \"import cirq; print(cirq.__version__)\"\n```\n\n----------------------------------------\n\nTITLE: Check Inverse QFT Equality: Manual vs Built-in in Python\nDESCRIPTION: This code compares the unitary matrix of the manually defined inverse QFT (`iqft`) with the built-in inverse QFT (`iqft_cirq`) to confirm their functional equivalence.  It utilizes `cirq.unitary` to compute the unitary matrices, and `np.testing.assert_allclose` to verify that they are approximately equal, confirming the two approaches produce the same result.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Check equality of the 'manual' and 'built-in' inverse QFTs.\"\"\"\nnp.testing.assert_allclose(cirq.unitary(iqft), cirq.unitary(iqft_cirq))\n```\n\n----------------------------------------\n\nTITLE: Creating and Simulating Quantum Circuit (Python)\nDESCRIPTION: This code snippet creates a quantum circuit using Cirq. It defines a qubit, applies a square root of NOT gate (X gate raised to the power of 0.5), and measures the qubit. The circuit is then simulated multiple times using the Cirq simulator, and the results are printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/start.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Pick a qubit.\nqubit = cirq.GridQubit(0, 0)\n\n# Create a circuit that applies a square root of NOT gate, then measures the qubit.\ncircuit = cirq.Circuit(cirq.X(qubit) ** 0.5, cirq.measure(qubit, key='m'))\nprint(\"Circuit:\")\nprint(circuit)\n\n# Simulate the circuit several times.\nsimulator = cirq.Simulator()\nresult = simulator.run(circuit, repetitions=20)\nprint(\"Results:\")\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Creating a Quantum Circuit with Cirq in Python\nDESCRIPTION: This snippet creates a simple quantum circuit using Cirq. It defines three qubits, applies square root of NOT gates to each qubit, applies controlled-Z gates between the first and second, and second and third qubits, and then measures the third qubit.  The circuit is then printed to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/concepts.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nq0, q1, q2 = cirq.GridQubit.rect(1,3)\ncircuit = cirq.Circuit(\n    (cirq.X ** 0.5).on_each(q0, q1, q2),\n    cirq.CZ(q0, q1),\n    cirq.CZ(q1, q2),\n    cirq.measure(q2, key='m')\n)\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq\nDESCRIPTION: This snippet attempts to import the Cirq library and installs it using pip if it's not already installed. It handles the case where Cirq is not present in the environment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/named_topologies.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    \nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Installing Stable Cirq-IonQ with pip\nDESCRIPTION: This command installs the stable version of the cirq-ionq module using the pip package installer. It ensures that the module and its dependencies, including cirq-core, are installed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-ionq/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install cirq-ionq\n```\n\n----------------------------------------\n\nTITLE: Add Labels, Title and Legend to a Matplotlib Axis\nDESCRIPTION: This Python code defines a function `extras` that adds labels, a title, and a legend to a `matplotlib` axis object. It ensures unique legend handles and labels before creating the legend.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndef extras(ax, title):\n    \"\"\"Add labels, title and legend to an axis\"\"\"\n\n    ax.set_ylabel('Circuit fidelity')\n    ax.set_xlabel('Cycle Depth $d$')\n    ax.set_title(title)\n    # create a legend while making sure the handles are unique\n    handles, labels = ax.get_legend_handles_labels()\n    legend_items = dict(zip(labels, handles))\n    ax.legend(legend_items.values(), legend_items.keys(), loc='best')\n```\n\n----------------------------------------\n\nTITLE: Git Diff for Top-Level Object Changes\nDESCRIPTION: This shell command displays the changes made to the top-level objects and protocols by checking the history of the `__init__.py` file in the `cirq-core/cirq` directory between the previous version and the current HEAD.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/release.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\ngit diff <previous version>..HEAD cirq-core/cirq/__init__.py\n```\n\n----------------------------------------\n\nTITLE: Fourier Checking Algorithm Example\nDESCRIPTION: This code snippet demonstrates how to use the `fourier_checking_algorithm` function to create and print a Cirq circuit for the Fourier Checking algorithm. It initializes qubits, draws functions `fs` and `gs` from a forrelation set, and then creates a `cirq.Circuit` object. Finally, it prints the circuit to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nqubits = cirq.LineQubit.range(n)\nfs, gs, forrelation, correlation = draw_two_distribution_from_f_set(N)\ncircuit = cirq.Circuit(fourier_checking_algorithm(qubits, fs, gs))\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Installing stable cirq-web using pip\nDESCRIPTION: This command installs the stable version of the cirq-web package using the pip package manager. This ensures you are using a version that has been tested and is considered reliable.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-web/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install cirq-web\n```\n\n----------------------------------------\n\nTITLE: Verifying a Published Package on Production PyPI\nDESCRIPTION: Illustrates how to verify a published package on the production PyPI repository. It requires the full version reported by the publish script.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\n./dev_tools/packaging/verify-published-package.sh FULL_VERSION_REPORTED_BY_PUBLISH_SCRIPT --prod\n```\n\n----------------------------------------\n\nTITLE: Git Log for Contributing Authors\nDESCRIPTION: This shell command lists the contributing authors for the release by extracting author names from the git log, sorting them, removing duplicates, and formatting them as a comma-separated list.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/release.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\ngit log <previous version>..HEAD --pretty=\"%an\" | sort |\\\n  uniq | sed ':a;N;$!ba;s/\\n/, /g'\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Dependencies\nDESCRIPTION: This snippet shows how to specify dependencies in a requirements file. The `-r` flag includes the contents of other requirements files, which are resolved by pip during installation. The dependencies include pytest, cirq core libraries, IPython, and pylint.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/dev_tools/requirements/pytest-minimal.env.txt#_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n-r deps/pytest.txt\n\n# we could exclude the non-core requirements conditionally but that would\n# require reflecting in the PYTHONPATH as well conditioned on whether non-core\n# modules changed or not - for now we include all of them here too.\n\n-r deps/cirq-all-no-contrib.txt\n-r deps/ipython.txt\n\n# pylint is needed for invoking custom checkers\n\n-r deps/pylint.txt\n```\n\n----------------------------------------\n\nTITLE: Check for _kraus_ and _mixture_ Methods\nDESCRIPTION: This snippet checks if the `cirq.depolarize` channel has `_kraus_` and `_mixture_` methods implemented. It demonstrates that `cirq.depolarize` only implements `_mixture_` and that `cirq.kraus` can derive Kraus operators from the mixture.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_75\n\nLANGUAGE: python\nCODE:\n```\n# Get a depolarizing channel.\nd = cirq.depolarize(0.2)\n\n# Check if it has _kraus_ implemented.\nprint(f\"does cirq.depolarize(0.2) have _kraus_? {'yes' if getattr(d, '_kraus_', None) else 'no'}\")\n\n# Check if it has _mixture_ implemented.\nprint(\n    f\"does cirq.depolarize(0.2) have _mixture_? {'yes' if getattr(d, '_mixture_', None) else 'no'}\"\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing a Cirq Circuit with Operations\nDESCRIPTION: This example demonstrates initializing a Cirq circuit directly with Hadamard gates applied to qubits `q0` and `q1`. This is a concise way to create a circuit with initial operations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit(cirq.H(q0), cirq.H(q1))\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Accessing Gate Exponent - Python\nDESCRIPTION: This example showcases how to access and check the type of the exponent of a gate in a flattened circuit. It asserts that the exponent after flattening is a symbol and not an expression.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfirst_gate = c_flat[0][q0].gate\nprint(first_gate.exponent)\n# Note this is a symbol, not an expression\nprint(type(first_gate.exponent))\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries in Python\nDESCRIPTION: This snippet imports necessary libraries: matplotlib.pyplot for plotting, numpy for numerical operations, cirq for quantum circuit operations, and cirq_google for Google's Cirq extensions. These libraries are fundamental for quantum circuit design, simulation, and visualization.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport cirq\nimport cirq_google as cg\n```\n\n----------------------------------------\n\nTITLE: Validate Circuit against Device (Cirq-Google)\nDESCRIPTION: This code snippet retrieves a device from the Cirq Engine, creates a simple circuit with a CZ gate, and attempts to validate the circuit against the device. It demonstrates how to use the device specification to ensure that a circuit is compatible with the target hardware. It shows how an unsupported gate on the device will raise an error during validation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/specification.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport cirq_google as cg\n\n# Create an Engine object to use.\nengine = cg.Engine(project_id='your_project_id',\n                   proto_version=cirq_google.ProtoVersion.V2)\n\n# Replace the processor id to get the device with that id.\ndevice = engine.get_processor('processor_id').get_device()\n\nq0, q1 = cirq.LineQubit.range(2)\ncircuit = cirq.Circuit(cirq.CZ(q0, q1))\n\n# Raises a ValueError, since CZ is not a supported gate.\ndevice.validate_circuit(circuit)\n```\n\n----------------------------------------\n\nTITLE: Getting Job Results on Azure Quantum\nDESCRIPTION: This snippet waits for an asynchronous job to complete and retrieves the results using the `results` method of the `Job` object. It then prints the result which is a dictionary of lists.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_honeywell.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nresult = job.results()\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Verify Published Package on Test PyPI\nDESCRIPTION: This bash script runs an automated verification script `verify-published-package.sh` against the package published on Test PyPI to ensure it was uploaded correctly. The script requires the version to be verified as input.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/release.md#_snippet_9\n\nLANGUAGE: Bash\nCODE:\n```\n# NOTE: FIRST RUN MAY FAIL - PyPI might not have indexed the version yet\n./dev_tools/packaging/verify-published-package.sh \"${VER}\" --test\n```\n\n----------------------------------------\n\nTITLE: Checkout Main Branch\nDESCRIPTION: This bash script checks out the main branch, pulls the latest changes from the origin, and verifies that there are no pending changes. This is part of the preparation for a MINOR/MAJOR release.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/release.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\ngit checkout main\ngit pull origin main  # or upstream main\ngit status  # should be no pending changes\n```\n\n----------------------------------------\n\nTITLE: Generating a library of 2-qubit circuits using Cirq\nDESCRIPTION: This code snippet generates a library of 20 random, two-qubit quantum circuits using the `cirq.experiments.random_quantum_circuit_generation` module.  The circuits are created using the sqrt(ISWAP) gate between two specified GridQubits (4,4) and (4,5).  The number of generated circuits is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/isolated_xeb.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.experiments import random_quantum_circuit_generation as rqcg\n\ncircuits = rqcg.generate_library_of_2q_circuits(\n    n_library_circuits=20,\n    two_qubit_gate=cirq.ISWAP**0.5,\n    q0=cirq.GridQubit(4,4),\n    q1=cirq.GridQubit(4,5),\n)\nprint(len(circuits))\n```\n\n----------------------------------------\n\nTITLE: Stratified Circuit Alignment in Cirq\nDESCRIPTION: This snippet uses `cirq.stratified_circuit` to align operations into similar categories. In this case, it aligns single-qubit and two-qubit operations into separate moments, based on the number of qubits the operation acts on. This is achieved by using lambda functions in the `categories` parameter to define operation categories.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.stratified_circuit(\n    circuit, categories=[lambda op : len(op.qubits) == 1, lambda op : len(op.qubits) == 2]\n)\ncircuit\n```\n\n----------------------------------------\n\nTITLE: Unrolling Requirements File Content using reqs.py\nDESCRIPTION: Demonstrates how to unroll the contents of a requirements file using the `reqs.py` utility script. This is helpful for understanding the full set of dependencies included in a specific environment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\npython dev_tools/requirements/reqs.py dev_tools/requirements/dev.env.txt\n```\n\n----------------------------------------\n\nTITLE: Simulating the Deutsch-Jozsa Solution\nDESCRIPTION: This code simulates the Deutsch-Jozsa circuit (`dj_circuit`) with both constant and balanced oracles. The simulator is used to run the circuit 10 times for each oracle and the results are printed to the console. This allows verification of the correct implementation of the Deutsch-Jozsa algorithm.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_43\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Simulate the Deutsch-Jozsa circuit and check the results.\"\"\"\nprint(\"Result on constant functions:\")\nfor oracle in constant:\n    result = simulator.run(cirq.Circuit(dj_circuit(oracle)), repetitions=10)\n    print(result)\n\nprint(\"\\nResult on balanced functions:\")\nfor oracle in balanced:\n    result = simulator.run(cirq.Circuit(dj_circuit(oracle)), repetitions=10)\n    print(result)\n```\n\n----------------------------------------\n\nTITLE: Running Doctests\nDESCRIPTION: This command runs doctests, which are tests embedded in docstrings, within the Cirq project. It requires the 'check/doctest' script to be present and configured to discover and execute doctests.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n./check/doctest\n```\n\n----------------------------------------\n\nTITLE: Bump Main Version\nDESCRIPTION: This bash script creates a new branch from main named \"version_bump_${NEXT_VER}\", uses a python script to replace the old version with the next version, and pushes the changes to the origin. It's crucial that this only runs for minor/major releases, not patches.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/release.md#_snippet_6\n\nLANGUAGE: Bash\nCODE:\n```\ngit checkout main -b \"version_bump_${NEXT_VER}\"\npython dev_tools/modules.py replace_version --old ${VER}.dev0 --new ${NEXT_VER}.dev0\ngit add .\ngit commit -m \"Bump cirq version to ${NEXT_VER}\"\ngit push origin \"version_bump_${NEXT_VER}\"\n```\n\n----------------------------------------\n\nTITLE: License Header in Python\nDESCRIPTION: This code snippet specifies the Apache 2.0 license under which the code is distributed, detailing the permissions and limitations of its use.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/qubit_picking.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# @title Licensed under the Apache License, 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n```\n\n----------------------------------------\n\nTITLE: Running a Circuit via Service.run in Python\nDESCRIPTION: This snippet demonstrates how to run a quantum circuit on the IonQ API using the `service.run` method. It constructs a simple circuit, submits it to the IonQ QPU for 100 repetitions, and prints the result. It showcases the blocking nature of this method and the statistical nature of the returned results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/jobs.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nqubit = cirq.LineQubit(0)\ncircuit = cirq.Circuit(\n    cirq.X(qubit)**0.5,            # Square root of NOT.\n    cirq.measure(qubit, key='x')   # Measurement store in key 'x'\n)\n\nresult = service.run(circuit=circuit, repetitions=100, target='qpu')\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Validating an Operation against PasqalVirtualDevice\nDESCRIPTION: This code checks if applying a CZ gate between two qubits that are too far apart is valid on the `PasqalVirtualDevice`.  It attempts to validate the operation and expects a `ValueError` to be raised because the distance between the qubits exceeds the control radius of the device.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/pasqal/getting_started.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# It is impossible to add a multi-qubit gate if the qubits involved are too far away\ntry:\n    p_device.validate_operation(cirq.CZ(p_qubits[0], p_qubits[-1]))\nexcept ValueError as msg:\n    print(\"ERROR:\", msg)\nelse:\n    print(\"Failed to raise the expected ValueError.\")\n```\n\n----------------------------------------\n\nTITLE: Defining Valid Gates\nDESCRIPTION: This section defines the set of valid gate operations that can be performed within the quantum circuit. Each 'valid_gates' entry describes a specific gate type, including its name (if applicable) and its duration in picoseconds ('gate_duration_picos').  Some gates may not have a name or specified duration, indicating default or virtual operations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-google/cirq_google/devices/specifications/weber_2021_12_10_device_spec_for_grid_device.proto.txt#_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\nvalid_gates {\n  coupler_pulse {\n  }\n}\nvalid_gates {\n  cz {\n  }\n}\nvalid_gates {\n  gate_duration_picos: 4000000000\n  meas {\n  }\n}\nvalid_gates {\n  gate_duration_picos: 25000\n  phased_xz {\n  }\n}\nvalid_gates {\n  gate_duration_picos: 20000\n  physical_zpow {\n  }\n}\nvalid_gates {\n  gate_duration_picos: 32000\n  sqrt_iswap {\n  }\n}\nvalid_gates {\n  gate_duration_picos: 32000\n  sqrt_iswap_inv {\n  }\n}\nvalid_gates {\n  gate_duration_picos: 12000\n  syc {\n  }\n}\nvalid_gates {\n  virtual_zpow {\n  }\n}\nvalid_gates {\n  wait {\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning a Forked Cirq Repository\nDESCRIPTION: This command clones a forked repository to your local machine and navigates into the directory. It requires git to be installed and an internet connection to access the GitHub repository. Replace USERNAME with your GitHub username.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/USERNAME/Cirq.git\ncd Cirq\n```\n\n----------------------------------------\n\nTITLE: Generating LineQubits\nDESCRIPTION: This snippet demonstrates how to generate a sequence of `cirq.LineQubit` objects using the `range` method.  The `range` method creates a list of `cirq.LineQubit`s with integer indices starting from 0. The number of qubits to generate is passed as an argument to the method.  In this example it creates three qubits with indices 0, 1, and 2.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/circuits.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nq0, q1, q2 = cirq.LineQubit.range(3)\n```\n\n----------------------------------------\n\nTITLE: Running Simulation with Flattened Sweep - Python\nDESCRIPTION: This snippet shows how to run a simulation of a flattened circuit using the new sweep generated by flattening. The code simulates the flattened circuit for each parameter set in the sweep and prints the results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nsim = cirq.Simulator()\nresults = sim.run_sweep(c_flat, repetitions=20, params=new_sweep)\nfor result in results:\n    print(result.params, result)\n```\n\n----------------------------------------\n\nTITLE: Simplify Flipped CNOTs: Transformer (Empty Implementation) - Python\nDESCRIPTION: This snippet demonstrates the basic structure of a Cirq transformer designed to simplify circuits by replacing a CNOT gate surrounded by Hadamard gates. The initial implementation is intentionally left empty as an exercise.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_83\n\nLANGUAGE: python\nCODE:\n```\n# @title Attempt the solution here\n@cirq.transformer\ndef simplify_flipped_cnots(circuit, *, context=None):\n    # Use transformer primitives to simplify your circuit.\n    pass\n\n\n\"\"\"Test your optimizer on this circuit.\"\"\"\ncircuit = cirq.Circuit(\n    cirq.H.on_each(a, b, c), cirq.CNOT(a, b), cirq.H.on_each(a, b), cirq.CZ(a, b)\n)\nprint(simplify_flipped_cnots(circuit))\n```\n\n----------------------------------------\n\nTITLE: Sampling a Qutrit Circuit with Measurement in Cirq\nDESCRIPTION: This snippet creates a circuit with two `QutritPlusGate`s acting on two qutrits, measures them, and then samples from the circuit using `cirq.sample`. It prints the results, which will be integers from 0 to 2, representing the measurement outcomes for each qutrit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/qudits.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Create a circuit with three qutrit gates.\nq0, q1 = cirq.LineQid.range(2, dimension=3)\ncircuit = cirq.Circuit([\n    QutritPlusGate()(q0), \n    QutritPlusGate()(q1),\n    QutritPlusGate()(q1),\n    cirq.measure(q0, q1, key=\"x\")\n])\n\n# Sample from this circuit.\nresult = cirq.sample(circuit, repetitions=3)\n\n# See that the results are all integers from 0 to 2.\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq in Python\nDESCRIPTION: This snippet checks if the Cirq library is installed and installs it using pip if it's not present. It handles the potential `ImportError` when Cirq is not found.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/qudits.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Declaring typedunits Dependency for Proto Generation (Cirq-Google)\nDESCRIPTION: This line declares a dependency on the `typedunits` package, which facilitates working with physical units in a type-safe manner, often used in conjunction with protobufs.  While the exact version is not specified, its presence indicates the protobuf definitions may involve quantities with physical dimensions within cirq-google.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/dev_tools/requirements/deps/protos.txt#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ntypedunits\n```\n\n----------------------------------------\n\nTITLE: Generating Random Combinations for Device Graph in Python\nDESCRIPTION: This code snippet generates random combinations of two-qubit circuits for each interaction layer of the device graph using `cirq.experiments.random_quantum_circuit_generation.get_random_combinations_for_device`. It specifies the number of circuits in the library, the number of combinations to generate, the device graph, and a random state for reproducibility.  These combinations determine which circuits are applied to which qubit pairs in parallel.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ncombs_by_layer = rqcg.get_random_combinations_for_device(\n    n_library_circuits=len(circuit_library),\n    n_combinations=10,\n    device_graph=graph,\n    random_state=53,\n)\ncombs_by_layer\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq and qsim\nDESCRIPTION: This code snippet installs the `cirq_google` and `qsimcirq` libraries if they are not already installed. It uses `pip` to install the packages and then imports them. The `time` module is also imported for timing purposes.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_builder_code.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\n    import cirq_google\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq-google\n    print(\"installed cirq.\")\n    import cirq\n    import cirq_google\n\ntry:\n    import qsimcirq\nexcept ImportError:\n    print(\"installing qsimcirq...\")\n    !pip install --quiet qsimcirq\n    print(f\"installed qsimcirq.\")\n    import qsimcirq\n\nimport time\n```\n\n----------------------------------------\n\nTITLE: Running a Simple Circuit on Virtual Engine in Python\nDESCRIPTION: This snippet shows how to run a simple quantum circuit on the virtual engine. It selects a processor ('weber'), gets a sampler from it, and then runs a circuit that measures a specific qubit (`cirq.GridQubit(7, 2)`) for 10 repetitions. The result of the simulation is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/virtual_engine_interface.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Choose one of the (simulated) processors to run on.\nweber = engine.get_processor('weber')\nsampler = weber.get_sampler()\n\n# Run a simple circuit for ten repetitions\nresult = sampler.run(cirq.Circuit(cirq.measure(cirq.GridQubit(7, 2))), repetitions=10)\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Export Circuit to Quirk URL - Python\nDESCRIPTION: This code demonstrates exporting a Cirq circuit to a URL that can be opened in the Quirk quantum circuit simulator.  It uses the `circuit_to_quirk_url` function from `cirq.contrib.quirk.export_to_quirk` to generate the URL and then prints it. The circuit consists of Hadamard, CNOT, and CCZ gates applied to three qubits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_89\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Export a circuit to a Quirk URL.\"\"\"\nfrom cirq.contrib.quirk.export_to_quirk import circuit_to_quirk_url\n\nprint(circuit_to_quirk_url(circuit))\n```\n\n----------------------------------------\n\nTITLE: Build Phase Estimation Circuit (Inverse QFT and Measure) in Python\nDESCRIPTION: This code completes the phase estimation circuit by appending the inverse QFT and measurement operations.  The `make_qft_inverse` function is used to generate the inverse QFT circuit on the estimation qubits. Measurement gates are added to the end of the circuit to measure the estimation qubits, with measurement results stored under the key 'm'.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Build the last part of the circuit (inverse QFT) for phase estimation.\"\"\"\n# Do the inverse QFT.\nphase_estimator.append(make_qft_inverse(qubits[::-1]))\n\n# Add measurements to the end of the circuit\nphase_estimator.append(cirq.measure(*qubits, key='m'))\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Cirq Gateset\nDESCRIPTION: This code defines a custom `cirq.Gateset` that includes `cirq.XPowGate`, `cirq.YPowGate`, `cirq.ZPowGate`, and `cirq.CNOT`.  It then demonstrates how to check if a given gate or operation is a member of the gateset.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_60\n\nLANGUAGE: python\nCODE:\n```\ngateset = cirq.Gateset(cirq.XPowGate, cirq.YPowGate, cirq.ZPowGate, cirq.CNOT)\n\n# Valid gates and operations are accepted by the gateset.\nassert cirq.CNOT(*cirq.LineQubit.range(2)) in gateset\nassert cirq.X**0.5 in gateset\n\n# Arbitrary powers of cirq.CXPowGate are not part of the gateset.\nassert cirq.CNOT**0.5 not in gateset\n```\n\n----------------------------------------\n\nTITLE: Encoding with Stabilizer Code\nDESCRIPTION: This snippet creates a `StabilizerCode` instance, defines qubits, and encodes them into a circuit. It uses the `ZZI` and `ZIZ` stabilizer generators and specifies that the code can correct `X` errors. It then displays the generated quantum circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/stabilizer_code.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncode = sc.StabilizerCode(group_generators=['ZZI', 'ZIZ'], correctable_errors=['X'])\n\nadditional_qubits = [cirq.NamedQubit(str(i)) for i in range(code.n - code.k)]\nunencoded_qubits = [cirq.NamedQubit('c')]\nqubits = additional_qubits + unencoded_qubits\n\ncircuit = code.encode(additional_qubits, unencoded_qubits)\n\nSVGCircuit(circuit)\n```\n\n----------------------------------------\n\nTITLE: Using InsertStrategy.NEW_THEN_INLINE in Cirq with Python\nDESCRIPTION: This snippet demonstrates the `InsertStrategy.NEW_THEN_INLINE` strategy. It appends an H gate and then inserts a CZ and an H gate using the new strategy. The first gate `CZ` is placed in a new moment. The second gate `H` is added in the same moment as the first because the insert strategy switches to `INLINE` after the new moment has been created.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit()\ncircuit.append([cirq.H(q0)])\ncircuit.append([cirq.CZ(q1, q2), cirq.H(q0)], strategy=InsertStrategy.NEW_THEN_INLINE)\n\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Mapping TiltedSquareLattice to GridQubits (Manual)\nDESCRIPTION: This snippet demonstrates manual mapping of TiltedSquareLattice nodes to GridQubits on the SYC23 device, visualized using `cirq.draw_placements`. It creates a TiltedSquareLattice and maps some of its nodes to specified GridQubit locations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/named_topologies.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntopo = TiltedSquareLattice(4, 2)\n\ncirq.draw_placements(SYC23_GRAPH, topo.graph, [\n    topo.nodes_to_gridqubits(offset=(3,2)),\n    topo.nodes_to_gridqubits(offset=(5,3)),\n], tilted=False)\n```\n\n----------------------------------------\n\nTITLE: Converting Circuit to Dense State Vector\nDESCRIPTION: This snippet converts the quantum circuit into a dense state vector using both the `tensor_state_vector` function from `cirq.contrib.quimb` and the `final_state_vector` function from Cirq. The resulting state vectors from both methods are then compared using `np.testing.assert_allclose` to ensure they are equivalent within a certain tolerance.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Cirq-to-Tensor-Networks.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npsi_tn = ccq.tensor_state_vector(circuit, qubits)\npsi_cirq = cirq.final_state_vector(circuit, qubit_order=qubits)\nnp.testing.assert_allclose(psi_cirq, psi_tn, atol=1e-7)\n```\n\n----------------------------------------\n\nTITLE: PauliStringPhasor Power Operations in Cirq\nDESCRIPTION: Demonstrates how to take powers of `PauliStringPhasor`s to affect the exponent. It illustrates the usage of the exponentiation operator on PauliStringPhasors.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ntyprint(np.exp(1j * Xa * Xb))\ntyprint(np.exp(1j * Xa * Xb) ** 5)\n```\n\n----------------------------------------\n\nTITLE: Defining Sqrt Iswap Gate Set in Cirq\nDESCRIPTION: This configuration defines the 'sqrt_iswap' gate set in Cirq, which includes gates like 'fsim_pi_4', 'inv_fsim_pi_4', 'xy', 'z', 'xyz', 'meas', 'wait', and 'circuit'. It specifies parameters such as 'phase_match' for 'fsim_pi_4' and 'inv_fsim_pi_4', along with their types and gate durations. This setup configures a set of operations relevant to square root of iSWAP-based architectures.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-google/cirq_google/devices/specifications/weber_2021_12_10_device_spec.proto.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nvalid_gate_sets {\n  name: \"sqrt_iswap\"\n  valid_gates {\n    id: \"fsim_pi_4\"\n    number_of_qubits: 2\n    valid_args {\n      name: \"phase_match\"\n      type: STRING\n    }\n    gate_duration_picos: 32000\n    valid_targets: \"2_qubit_targets\"\n  }\n  valid_gates {\n    id: \"inv_fsim_pi_4\"\n    number_of_qubits: 2\n    valid_args {\n      name: \"phase_match\"\n      type: STRING\n    }\n    gate_duration_picos: 32000\n    valid_targets: \"2_qubit_targets\"\n  }\n  valid_gates {\n    id: \"xy\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"axis_half_turns\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"half_turns\"\n      type: FLOAT\n    }\n    gate_duration_picos: 25000\n  }\n  valid_gates {\n    id: \"z\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"half_turns\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"type\"\n      type: STRING\n    }\n  }\n  valid_gates {\n    id: \"xyz\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"x_exponent\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"z_exponent\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"axis_phase_exponent\"\n      type: FLOAT\n    }\n    gate_duration_picos: 25000\n  }\n  valid_gates {\n    id: \"meas\"\n    valid_args {\n      name: \"key\"\n      type: STRING\n    }\n    valid_args {\n      name: \"invert_mask\"\n      type: REPEATED_BOOLEAN\n    }\n    gate_duration_picos: 4000000\n    valid_targets: \"meas_targets\"\n  }\n  valid_gates {\n    id: \"wait\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"nanos\"\n      type: FLOAT\n    }\n  }\n  valid_gates {\n    id: \"circuit\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Single-Qubit Gates in Python\nDESCRIPTION: This code defines a set of single-qubit gates, specifically `cirq.PhasedXZGate`, with various exponents for Z rotations and axis phases. It utilizes `np.linspace` to create a range of exponents and `itertools.product` to generate all combinations of exponents for constructing the gates.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/xeb_theory.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nexponents = np.linspace(0, 7/4, 8)\nexponents\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq and Importing Libraries\nDESCRIPTION: This snippet attempts to import the cirq library. If cirq is not installed, it will install it using pip and then import it along with other necessary libraries such as random, numpy, matplotlib, and scipy.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/quantum_walks.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n\nimport random\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport scipy\nimport scipy.special\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq-Rigetti\nDESCRIPTION: This code snippet attempts to import the `cirq` and `cirq_rigetti` libraries. If the import fails due to an `ImportError`, it installs the `cirq-rigetti` package using pip and then attempts to import the libraries again. This ensures that the necessary dependencies are available before proceeding.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/rigetti/getting_started.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\n    import cirq_rigetti\nexcept ImportError:\n    print(\"installing cirq-rigetti...\")\n    !pip install --quiet cirq-rigetti\n    print(\"installed cirq-rigetti.\")\n    import cirq\n    import cirq_rigetti\n```\n\n----------------------------------------\n\nTITLE: Running Cirq Benchmarks with ASV\nDESCRIPTION: This bash script executes all Cirq performance benchmarks using Airspeed Velocity. It requires navigating to the root Cirq directory before execution.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/benchmarks/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./check/asv_run\n```\n\n----------------------------------------\n\nTITLE: Inline matplotlib configuration\nDESCRIPTION: Configures matplotlib to display plots inline in the notebook environment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/xeb_theory.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n%matplotlib inline\nfrom matplotlib import pyplot as plt\n```\n\n----------------------------------------\n\nTITLE: Serializing a Cirq object to JSON\nDESCRIPTION: This code snippet demonstrates how to serialize a Cirq object (in this case, a parameterized X gate) into a JSON string using the `cirq.to_json` function. It imports the necessary libraries (cirq and sympy), creates the object, serializes it, and prints the resulting JSON string.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/serialization.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport sympy\n\nobj = cirq.X**sympy.Symbol('t')\ntext = cirq.to_json(obj)\n\nprint(text)\n# prints:\n# {\n#   \"cirq_type\": \"XPowGate\",\n#   \"exponent\": {\n#     \"cirq_type\": \"sympy.Symbol\",\n#     \"name\": \"t\"\n#   },\n#   \"global_shift\": 0.0\n# }\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq in Python\nDESCRIPTION: This code snippet checks for the Cirq library and installs it if it's not found. It uses a try-except block to handle the ImportError, then uses pip to install cirq. It also prints messages to the console indicating whether Cirq is being installed or is already present.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/_template.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n```\n\n----------------------------------------\n\nTITLE: Inspecting Pauli Operator Probabilities in Python\nDESCRIPTION: This code snippet iterates through the Pauli traces from the intermediate results of the DFE and prints the probability and Pauli operator.  This helps in understanding which Pauli operators contribute significantly to the fidelity estimation.  It uses the `intermediate_results.pauli_traces` object to access the required information.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/direct_fidelity_estimation.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfor pauli_trace in intermediate_results.pauli_traces:\n    print('Probability %.3f\\tPauli: %s' % (pauli_trace.Pr_i, pauli_trace.P_i))\n```\n\n----------------------------------------\n\nTITLE: Creating Quantum Virtual Machine\nDESCRIPTION: This code snippet creates a Quantum Virtual Machine using `cirq_google.engine.create_default_noisy_quantum_virtual_machine`. It takes a `processor_id` as input (defaulting to \"rainbow\") which specifies the processor to simulate.  It then prints the qubit grid of the selected processor.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nprocessor_id = \"rainbow\"  # @param {type:\"string\"}\n\n# Instantiate the engine.\nsim_engine = cirq_google.engine.create_default_noisy_quantum_virtual_machine(\n    processor_id=processor_id, simulator_class=qsimcirq.QSimSimulator\n)\nprint(\n    \"Your quantum virtual machine\",\n    processor_id,\n    \"is ready, here is the qubit grid:\",\n    \"\\n========================\\n\",\n)\nprint(sim_engine.get_processor(processor_id).get_device())\n```\n\n----------------------------------------\n\nTITLE: Using custom channels\nDESCRIPTION: Demonstrates how to instantiate and use the custom channel, `BitAndPhaseFlipChannel`. It creates an instance of the channel with a specified probability and then iterates through the mixture to print the probabilities and corresponding Kraus operators. This highlights how custom channels can be used like other predefined channels in Cirq.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nbit_phase_flip = BitAndPhaseFlipChannel(p=0.05)\n\nfor prob, kraus in cirq.mixture(bit_phase_flip):\n    print(f\"With probability {prob}, apply\\n\", kraus, end=\"\\n\\n\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Quantum Circuit with Cirq in Python\nDESCRIPTION: This code snippet imports Cirq and creates a simple quantum circuit using CNOT, Z, and H gates on three qubits. It also uses SVGCircuit to visualize the created circuit. This requires Cirq to be installed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/direct_fidelity_estimation.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nfrom cirq.contrib.svg import SVGCircuit\nimport examples.direct_fidelity_estimation as dfe\n\nqubits = cirq.LineQubit.range(3)\ncircuit = cirq.Circuit(cirq.CNOT(qubits[0], qubits[2]),\n                       cirq.Z(qubits[0]),\n                       cirq.H(qubits[2]),\n                       cirq.CNOT(qubits[2], qubits[1]))\n\nSVGCircuit(circuit)\n```\n\n----------------------------------------\n\nTITLE: Checking Job Status on Azure Quantum\nDESCRIPTION: This snippet checks the status of an asynchronous job using the `status` method of the `Job` object.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_honeywell.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\njob.status()\n```\n\n----------------------------------------\n\nTITLE: Webpack Entry Configuration JavaScript\nDESCRIPTION: This code snippet demonstrates how to configure entry points in the `webpack.config.js` file for bundling Typescript visualizations.  It specifies the main entry point for each visualization, allowing Webpack to bundle the necessary files.  Replace `YOUR_VIZ_NAME` with the actual name of your visualization directory.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-web/cirq_ts/README.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nmodule.exports = {\n  entry: {\n    bloch_sphere: './src/bloch_sphere/main.ts',\n    ...\n    YOUR_VIZ_NAME: './src/YOUR_VIZ_NAME/main.ts',\n  },\n  ...\n};\n```\n\n----------------------------------------\n\nTITLE: Verify Published Package on Production PyPI\nDESCRIPTION: This bash script runs an automated verification script `verify-published-package.sh` against the package published on production PyPI to ensure it was uploaded correctly. The script requires the version to be verified as input.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/release.md#_snippet_15\n\nLANGUAGE: Bash\nCODE:\n```\n# NOTE: FIRST RUN WILL LIKELY FAIL - pypi might not have yet indexed the version\n./dev_tools/packaging/verify-published-package.sh \"${VER}\" --prod\n```\n\n----------------------------------------\n\nTITLE: Building Quantum Circuit and Observables with Cirq (Python)\nDESCRIPTION: This snippet constructs the overall quantum circuit by repeating the previously defined `step` multiple times. It also defines the observables used to measure the circuit's output.  The `all_steps` variable is a `CircuitOperation` that repeats the `step` circuit 5 times. The final circuit combines these steps with the initial X rotations. The observables are defined as Pauli strings (X, Y, and Z) acting on specific qubits and combined into a single observable. The theta values are defined for sweeping the X rotation angles. QSimOptions are set for performance tuning of the qsim simulator including CPU thread count and fused gate size. Finally, a QSimSimulator instance is created with the specified options.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_utility_sim_4a.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# The circuit used to generate Fig. 4a consists of 5 steps + final rotations.\n# Changing \"repetitions\" here will adjust the number of steps simulated.\nall_steps = cirq.CircuitOperation(step, repetitions=5)\ncircuit = cirq.Circuit(all_steps, x_rotations)\n\n# These are the component parts of the observable used in Fig. 4a.\nx_obs = cirq.DensePauliString('X' * 8).on(*(q[i] for i in [37, 41, 52, 56, 57, 58, 62, 79]))\ny_obs = cirq.DensePauliString('Y' * 8).on(*(q[i] for i in [38, 40, 42, 63, 72, 80, 90, 91]))\nz_obs = cirq.DensePauliString('Z').on(q[75])\nobservables = [x_obs * y_obs * z_obs]\n\n# These are approximately the values of theta plotted for experimental values\n# in Fig. 4a. Changing this list will adjust the simulation to test other\n# theta values.\ntheta_values = [0, 0.25, 0.5, 1, *np.linspace(1.2, 1.5, 7), np.pi / 2]\nparams = cirq.Points(key=\"theta\", points=theta_values)\n\n# These options are used to tune qsim performance.\n# On CPU, \"cpu_threads\" should be set to the number of cores available.\nopt = qsimcirq.QSimOptions(max_fused_gate_size=4, cpu_threads=24)\n# To use GPU instead, uncomment this line:\n# opt = qsimcirq.QSimOptions(use_gpu=True, gpu_mode=1)\nsimulator = qsimcirq.QSimSimulator(qsim_options=opt)\n```\n\n----------------------------------------\n\nTITLE: Creating Optimized Benchmark Circuit with Alignment in Cirq\nDESCRIPTION: This snippet creates a benchmark circuit with optimization and alignment enabled, using the `create_benchmark_circuit` function. The `with_optimization` and `with_alignment` parameters are set to `True`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\noptimized_circuit = create_benchmark_circuit(qubits, cycles=2, seed=1, with_optimization=True, with_alignment=True)\nprint(f\"Circuit with optimization + alignment ({len(optimized_circuit)} moments):\\n\")\noptimized_circuit\n```\n\n----------------------------------------\n\nTITLE: Drawing LineTopology\nDESCRIPTION: This snippet shows how to create and draw LineTopology instances with different numbers of nodes. It iterates through a range of node counts and generates corresponding LineTopology plots using matplotlib.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/named_topologies.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq import LineTopology\n\nlens = np.arange(3, 12+1, 3)\nl = len(lens)\nfig, axes = plt.subplots(1,l, figsize=(3.5*l, 3*1))\n\nfor ax, n_nodes in zip(axes, lens):\n    LineTopology(n_nodes).draw(ax=ax, tilted=False)\n    ax.set_title(f'n =  {n_nodes}')\n    \nfig.tight_layout()\n```\n\n----------------------------------------\n\nTITLE: Installing pyQuil QVM and Compiler (Linux Debian)\nDESCRIPTION: This bash script checks if the pyQuil QVM is installed and if not, installs it along with its dependencies (jq). It retrieves the latest Forest SDK version, downloads the SDK, extracts it, and runs the installation script. Finally, it verifies the installation by checking the versions of quilc and qvm.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/rigetti/getting_started.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n! [ -z \"$(which qvm)\" ] &&\\\n  apt update &&\\\n  apt install jq &&\\\n  export LATEST_FOREST_SDK_VERSION=$(curl -s https://downloads.rigetti.com/qcs-sdk/versions | jq -r '.versions[0].sdk') &&\\\n  curl -f https://downloads.rigetti.com/qcs-sdk/forest-sdk-$LATEST_FOREST_SDK_VERSION-linux-deb.tar.bz2 -o $PWD/forest-sdk-$LATEST_FOREST_SDK_VERSION-linux-deb.tar.bz2 &&\\\n  tar -xf forest-sdk-$LATEST_FOREST_SDK_VERSION-linux-deb.tar.bz2 &&\\\n  ./forest-sdk-$LATEST_FOREST_SDK_VERSION-linux-deb/forest-sdk-$LATEST_FOREST_SDK_VERSION-linux-deb.run &&\\\n  quilc --version &&\\\n  qvm --version\n```\n\n----------------------------------------\n\nTITLE: Creating a Circuit with Overlapping Two-Qubit Gates in Python\nDESCRIPTION: This code snippet demonstrates how Cirq handles overlapping operations by placing them in consecutive moments. It creates a circuit consisting of SWAP gates applied to adjacent line qubits. Since the SWAP gates act on overlapping qubits, they are placed in separate moments.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nprint(cirq.Circuit(cirq.SWAP(q, q + 1) for q in cirq.LineQubit.range(3)))\n```\n\n----------------------------------------\n\nTITLE: Decoding the Output\nDESCRIPTION: This snippet decodes the output of the circuit using the `decode` method of the StabilizerCode instance, and prints the decoded result.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/stabilizer_code.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndecoded = code.decode(qubits, ancillas, results.state_vector())\nprint('decoded=%s' % (decoded))\n```\n\n----------------------------------------\n\nTITLE: License Header\nDESCRIPTION: This code snippet is a standard Apache 2.0 license header, commonly used in open-source projects like Cirq. It specifies the terms and conditions under which the code can be used, modified, and distributed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/protocols.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#@title Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n```\n\n----------------------------------------\n\nTITLE: Building SQRT_ISWAP Gate from PhasedFSimGate in Python\nDESCRIPTION: This snippet demonstrates how to construct a `cirq.SQRT_ISWAP` gate using a `cirq.PhasedFSimGate`.  It initializes a `PhasedFSimGate` with specific parameters and verifies that its unitary matrix matches that of a standard `SQRT_ISWAP` gate using `np.testing.assert_allclose`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# build sqrt_iswap gate from a phased fsim gate\nsqrt_iswap_as_phased_fsim = cirq.PhasedFSimGate.from_fsim_rz(\n    theta=-np.pi / 4, phi=0, rz_angles_before=(0, 0), rz_angles_after=(0, 0)\n)\n\n# check that the unitaries are the same\nnp.testing.assert_allclose(\n    cirq.unitary(sqrt_iswap_as_phased_fsim), cirq.unitary(cirq.SQRT_ISWAP), atol=1e-8\n)\n```\n\n----------------------------------------\n\nTITLE: Simulating Z Stabilizer Circuit without Noise (Cirq)\nDESCRIPTION: This snippet simulates the Z stabilizer circuit initialized in the previous step using Cirq's Simulator. It runs the circuit for 100 repetitions and plots the state histogram of the measurement results.  The expected output is a histogram showing the measure qubit consistently in the |0⟩ state.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsimulator = cirq.Simulator()\nresult = simulator.run(stabilizer_circuit, repetitions=100)\nax = cirq.plot_state_histogram(result)\nplt.show(ax)\n```\n\n----------------------------------------\n\nTITLE: Resolve parameters in a Cirq circuit\nDESCRIPTION: This snippet shows how to resolve parameters in a parameterized Cirq circuit using `cirq.resolve_parameters`. It uses a dictionary to map symbolic parameters (e.g., 'theta') to specific numerical values (e.g., 0.5 or 0.25), effectively replacing the symbolic parameters with their assigned values to create a concrete circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# circuit1 has theta = 0.5\ncirq.resolve_parameters(circuit, {\"theta\": 0.5})\n# circuit2 has theta = 0.25\ncirq.resolve_parameters(circuit, {\"theta\": 0.25})\n```\n\n----------------------------------------\n\nTITLE: Plotting with Multiple Axes in Cirq using Matplotlib\nDESCRIPTION: This code snippet illustrates how to implement a `plot` method for classes that require multiple axes.  It takes an optional `axes` argument which is a list of `plt.Axes` instances. If `axes` is not provided, it creates the required number of axes. It validates that the provided list has the correct number of axes and raises a `ValueError` if not. The code includes logic to conditionally display the plot using `fig.show()` in interactive mode and returns the `axes` list.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/plotting.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    ...\n    def plot(self, axes: Optional[List[plt.Axes]]=None,\n             **plot_kwargs: Any) -> List[plt.Axes]:\n        show_plot = not axes\n        if axes is None:\n            fig, axes = plt.subplots(1, 2)  # or your favorite figure setup\n        elif len(axes) != 2:  # your required number of axes\n            raise ValueError('your error message')\n        # Call methods of the axes[i] objects to plot on it.\n        ...\n        if show_plot:\n            fig.show()\n        return axes\n```\n\n----------------------------------------\n\nTITLE: Displaying Bloch Vector of Message Qubit using Cirq\nDESCRIPTION: This snippet calculates and prints the Bloch vector of the message qubit after applying the initial gate. It constructs a Cirq circuit with the gate applied to the message qubit, then uses `final_state_vector` to get the state vector. Finally, it uses `bloch_vector_from_state_vector` to compute the Bloch vector and prints its rounded values.  Dependencies: `cirq` and `numpy`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Display the Bloch vector of the message qubit.\"\"\"\nmessage = cirq.Circuit(gate.on(cirq.NamedQubit(\"Message\"))).final_state_vector()\nmessage_bloch_vector = cirq.bloch_vector_from_state_vector(message, index=0)\nprint(\"Bloch vector of message qubit:\")\nprint(np.round(message_bloch_vector, 3))\n```\n\n----------------------------------------\n\nTITLE: Confusion Map Example in Cirq\nDESCRIPTION: This code demonstrates how to use the `confusion_map` parameter in a `cirq.measure` gate to model measurement errors. The `confusion_map` field maps qubit tuples to confusion matrices representing the probability of reporting incorrect results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/representing_noise.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nq0 = cirq.LineQubit(0)\n# 10% chance to report |0) as |1), 20% chance to report |1) as |0).\ncmap = {(0,): np.array([[0.9, 0.1], [0.2, 0.8]])}\ncircuit = cirq.Circuit(\n    cirq.X(q0),\n    cirq.measure(q0, key='result', confusion_map=cmap)\n)\nresult = cirq.Simulator(seed=0).run(circuit, repetitions=1000)\nprint(result.histogram(key='result'))\n```\n\n----------------------------------------\n\nTITLE: Classical Control with Transformers in Cirq\nDESCRIPTION: Demonstrates the use of classical control with Cirq transformers, specifically `defer_measurements`.  This transformer rearranges the circuit to defer measurements, potentially converting a classically-controlled circuit into a purely quantum circuit.  It requires Cirq and showcases its transformation capabilities.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/classical_control.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nq0 = cirq.LineQubit(0)\ncircuit = cirq.Circuit(\n    cirq.measure(q0, key='a'), cirq.X(q1).with_classical_controls('a'), cirq.measure(q1, key='b')\n)\ndeferred = cirq.defer_measurements(circuit)\nprint(\"Original circuit:\")\nprint(circuit)\nprint(\"Measurement deferred:\")\nprint(deferred)\n```\n\n----------------------------------------\n\nTITLE: Printing the Sycamore Device from Cirq-Google in Python\nDESCRIPTION: This code snippet prints the `cirq_google.Sycamore` device, which is a pre-packaged set of qubits representing a diamond-shaped grid with 54 qubits, mimicking early hardware released by Google. It showcases how to access and display device information in Cirq.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nprint(cirq_google.Sycamore)\n```\n\n----------------------------------------\n\nTITLE: Accessing Kraus Operators for a Depolarizing Channel in Cirq\nDESCRIPTION: This code demonstrates how to access the Kraus operators for a depolarizing channel using `cirq.kraus`. It iterates through the Kraus operators and prints each one. These operators describe the evolution of the density matrix due to the noise.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_69\n\nLANGUAGE: python\nCODE:\n```\nfor i, kraus in enumerate(cirq.kraus(cirq.depolarize(0.2))):\n    print(f\"Kraus operator {i} is:\", kraus, sep=\"\\n\", end=\"\\n\\n\")\n```\n\n----------------------------------------\n\nTITLE: Building and Running Cirq Docker Images\nDESCRIPTION: These commands build and run Docker images for both stable and pre-release versions of Cirq. They require Docker to be installed and configured on the system. The commands print the Sycamore23 device information from the cirq_google package.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker build -t cirq --target cirq_stable .\ndocker run -it cirq python -c \"import cirq_google; print(cirq_google.Sycamore23)\"\n```\n\nLANGUAGE: bash\nCODE:\n```\ndocker build -t cirq_pre --target cirq_pre_release .\ndocker run -it cirq_pre python -c \"import cirq_google; print(cirq_google.Sycamore23)\"\n```\n\n----------------------------------------\n\nTITLE: Transforming Sweep with Expression Map - Python\nDESCRIPTION: This snippet uses the `ExpressionMap` to transform a sweep over the original symbol to a sweep over the new symbols introduced during flattening. The transformed sweep contains the values of the original expressions evaluated at each point in the original sweep.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nsweep = cirq.Linspace(a, start=0, stop=3, length=4)\nprint(f\"Old {sweep}\")\n\nnew_sweep = expr_map.transform_sweep(sweep)\nprint(f\"New {new_sweep}\")\n```\n\n----------------------------------------\n\nTITLE: Manual Verification in Virtual Environment (Production PyPI)\nDESCRIPTION: This bash script creates a new virtual environment, installs the Cirq package from Production PyPI with the latest version, and then runs a python script to print the Cirq version. This allows for manual verification of the release.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/release.md#_snippet_16\n\nLANGUAGE: Bash\nCODE:\n```\nmkvirtualenv \"verify_${VER}\" --python=/usr/bin/python3\npip install cirq\npython -c \"import cirq; print(cirq.__version__)\"\n```\n\n----------------------------------------\n\nTITLE: Deserializing a Cirq object from a string\nDESCRIPTION: This code snippet shows how to deserialize a Cirq object from a JSON string using the `cirq.read_json` function. It takes the JSON string, `text`, as input and prints the deserialized object to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/serialization.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndeserialized_obj = cirq.read_json(json_text=text)\nprint(deserialized_obj)\n# prints:\n# X**t\n```\n\n----------------------------------------\n\nTITLE: Converting Noisy Circuit to Density Matrix Tensors\nDESCRIPTION: This snippet converts a noisy quantum circuit into a tensor network representation of its density matrix, using `circuit_to_density_matrix_tensors` from `cirq.contrib.quimb`. The `fix` variable allows for a circuit-like layout when visualizing the tensors. The tensor network is then visualized with color-coding for different tensor types.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Cirq-to-Tensor-Networks.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ntensors, qubit_frontier, fix = ccq.circuit_to_density_matrix_tensors(circuit=circuit, qubits=qubits)\ntn = qtn.TensorNetwork(tensors)\ntn.graph(fix=fix, color=['Q0', 'Q1', 'Q2', 'kQ1'], figsize=(8,8))\n```\n\n----------------------------------------\n\nTITLE: Creating Device Graph for Routing\nDESCRIPTION: This code snippet imports the `cirq.contrib.routing` module and creates a device graph from the grid qubits using `ccr.gridqubits_to_graph_device`. It then visualizes the device graph using `networkx`. The device graph represents the connectivity of the qubits on a quantum device, which is important for routing quantum circuits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_volume.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport cirq.contrib.routing as ccr\ndevice_graph = ccr.gridqubits_to_graph_device(qubits)\n\nimport networkx as nx\nnx.draw(device_graph)\n```\n\n----------------------------------------\n\nTITLE: Initializing AQT Local Simulator (Ideal) in Python\nDESCRIPTION: This snippet initializes the AQT local simulator in ideal mode (without noise) using `AQTSamplerLocalSimulator`. This allows users to simulate quantum circuits without the effects of noise, offering a clean simulation environment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/aqt/getting_started.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.aqt.aqt_sampler import AQTSamplerLocalSimulator\n\naqt_sampler = AQTSamplerLocalSimulator(simulate_ideal=True)\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries\nDESCRIPTION: This section imports necessary libraries for quantum circuit manipulation, numerical computation, and tensor network operations. Libraries such as NumPy, NetworkX, Cirq, Quimb, and Matplotlib are imported to facilitate circuit creation, manipulation, and visualization.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport networkx as nx\n\nimport cirq\nimport quimb\nimport quimb.tensor as qtn\nfrom cirq.contrib.svg import SVGCircuit\n\nimport cirq.contrib.quimb as ccq\n```\n\n----------------------------------------\n\nTITLE: Running Noisy Simulation of Stabilizer Circuit in Cirq\nDESCRIPTION: This code runs a noisy simulation of the optimized stabilizer grid circuit using a quantum simulator (`sim_engine`).  It runs the simulation for a specified number of repetitions and measures the execution time. It simulates the effect of hardware noise on the circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nrepetitions = 100\nstart = time.time()\nresults = sim_engine.get_sampler(processor_id).run(\n    test_stabilizer_grid_circuit, repetitions=repetitions\n)\nelapsed = time.time() - start\nprint(f'{repetitions} repetitions completed in {elapsed:.03f}s')\n```\n\n----------------------------------------\n\nTITLE: Creating asymmetric depolarizing channel\nDESCRIPTION: This code creates an asymmetric depolarizing channel with specified probabilities for X, Y, and Z errors (p_x=0.10, p_y=0.05, p_z=0.15). The channel is then applied to a qubit in a Cirq circuit, illustrating how to simulate asymmetric depolarization noise.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Get an asymmetric depolarizing channel.\"\"\"\ndepo = cirq.asymmetric_depolarize(p_x=0.10, p_y=0.05, p_z=0.15)\n\ncircuit = cirq.Circuit(depo(cirq.LineQubit(0)))\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Device Parameter Sweep in Cirq\nDESCRIPTION: This code sweeps the pi amplitude of qubit (4,8) from 0.0 to 1.0 in 0.02 increments using `cirq_google.study.DeviceParameter` and `cirq.Linspace`. It requires a Google sponsor to access the proper key names for the device parameters.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/devices.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndescriptor = cirq_google.study.DeviceParameter( [\"q4_8\", \"piAmp\"])\nsweep = cirq.Linspace(\"q4_8.piAmp\", 0, 1, 51, metadata=descriptor)\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq and Importing Libraries in Python\nDESCRIPTION: This code snippet first attempts to import the `cirq` library. If `cirq` is not found, it installs it using `pip` and then imports `cirq` and `numpy`. `numpy` is imported for numerical computations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n\nimport numpy as np\n```\n\n----------------------------------------\n\nTITLE: Bitwise Dot Product Calculation in Python\nDESCRIPTION: Computes the bitwise dot product of two integers. The function takes two integers as input, performs a bitwise AND operation, and counts the number of set bits in the result. It returns 1 if the count is odd, and 0 if the count is even, representing the dot product modulo 2.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef bitwise_dot(x: int, y: int) -> int:\n    \"\"\"Compute the dot product of two integers bitwise.\"\"\"\n    i = x & y\n\n    n = bin(i).count(\"1\")\n    return int(n % 2)\n```\n\n----------------------------------------\n\nTITLE: Install Azure Quantum Python Client with Cirq\nDESCRIPTION: This command installs the `azure-quantum` Python client package with the optional `cirq` dependencies. This allows users to connect to their Azure Quantum Workspace from Python and submit jobs using Cirq.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/access.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install 'azure-quantum[cirq]'\n```\n\n----------------------------------------\n\nTITLE: Creating DataFrame for Least Squares Minimization\nDESCRIPTION: This code creates a Pandas DataFrame from the records and calculates the values for numerator and denominator. These values are used in the least squares minimization to estimate the fidelity.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/xeb_theory.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\ndf = pd.DataFrame(records)\ndf['y'] = df['m_u'] - df['u_u']\ndf['x'] = df['e_u'] - df['u_u']\n\ndf['numerator'] = df['x'] * df['y']\ndf['denominator'] = df['x'] ** 2\ndf.head()\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq in Python\nDESCRIPTION: This code snippet attempts to import the Cirq library. If the import fails, it installs Cirq using pip and then prints a confirmation message.  It is a standard practice to ensure the necessary library is available before proceeding.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: NPM Command Execution via check Bash\nDESCRIPTION: This demonstrates how to execute npm commands from the top-level Cirq directory using the `check/npm` script. It specifies the prefix directory for the npm command, ensuring that it runs in the correct context.  This command requires the `check/npm` script to be available.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-web/cirq_ts/README.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\n# check/npm runs npm --prefix 'cirq-web/cirq_ts` and forwards arguments\ncheck/npm [YOUR_COMMAND]\n```\n\n----------------------------------------\n\nTITLE: Defining a ZZ Observable\nDESCRIPTION: This snippet defines a ZZ observable as the tensor product of two Z gates on specific qubits in the grid.  These qubits are determined by the `zz_inds` variable.  The observable will be used later for calculating expectation values.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nZZ = cirq.Z(cirq.GridQubit(*zz_inds[0])) * cirq.Z(cirq.GridQubit(*zz_inds[1]))\nZZ\n```\n\n----------------------------------------\n\nTITLE: Running a Cirq Circuit on Azure Quantum\nDESCRIPTION: This snippet runs a Cirq circuit on the Azure Quantum service using the `run` method. It takes the circuit and the number of repetitions as input, then returns a `cirq.Result` object containing the measurement results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_honeywell.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nresult = service.run(program=circuit, repetitions=100)\n```\n\n----------------------------------------\n\nTITLE: Printing the repr of a Cirq Circuit\nDESCRIPTION: This snippet showcases how to print the `repr` (representation) of a Cirq quantum circuit. The `repr` provides a detailed, though often less readable, string representation of the circuit's internal structure, useful for debugging and reproducing circuits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Print the repr of a circuit.\"\"\"\nprint(repr(circuit))\n```\n\n----------------------------------------\n\nTITLE: Initializing Widget Class in Cirq with Python\nDESCRIPTION: This code snippet demonstrates how to initialize the parent `Widget` class when creating a new visualization widget in Cirq.  It ensures that the new widget inherits the standard functionality of all Cirq visualization widgets. `widget.Widget` is assumed to be imported from the `cirq_web` package.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-web/cirq_web/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass MyWidget(widget.Widget):\n    def __init__(self,...):\n        ...\n        super().__init__()\n        ...\n```\n\n----------------------------------------\n\nTITLE: Installing stable version of Cirq-Rigetti using pip\nDESCRIPTION: Installs the stable version of the cirq-rigetti module using pip. This command downloads and installs the latest stable release from the Python Package Index (PyPI).\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-rigetti/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\npip install cirq-rigetti\n```\n\n----------------------------------------\n\nTITLE: Defining the ZZ Observable (Large Grid)\nDESCRIPTION: This snippet defines the ZZ observable for the larger grid circuit, similar to the earlier definition but using the `zz_inds` that are relevant to the larger graph size.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nZZ = cirq.Z(cirq.GridQubit(*zz_inds[0])) * cirq.Z(cirq.GridQubit(*zz_inds[1]))\nZZ\n```\n\n----------------------------------------\n\nTITLE: Controlling a Channel in Cirq\nDESCRIPTION: This snippet shows how to create a controlled version of a bit-flip channel using `bit_flip.controlled(num_controls=1)`. This controlled channel is then used in a circuit, demonstrating how to apply noise conditionally based on the state of a control qubit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Example of controlling a channel.\"\"\"\n# Get the controlled channel.\ncontrolled_bit_flip = bit_flip.controlled(num_controls=1)\n\n# Use it in a circuit.\ncircuit = cirq.Circuit(controlled_bit_flip(*cirq.LineQubit.range(2)))\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Adding Noise to the Circuit\nDESCRIPTION: This snippet adds noise to the quantum circuit using a depolarizing channel. It creates a `ConstantQubitNoiseModel` with a `DepolarizingChannel` and then applies it to the circuit's moments, creating a noisy circuit. The noisy circuit is then visualized.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Cirq-to-Tensor-Networks.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nnoise_model = cirq.ConstantQubitNoiseModel(cirq.DepolarizingChannel(p=1e-3))\ncircuit = cirq.Circuit(noise_model.noisy_moments(circuit.moments, qubits))\nSVGCircuit(circuit)\n```\n\n----------------------------------------\n\nTITLE: Circuit Creation with Sympy Expression - Python\nDESCRIPTION: This code snippet demonstrates how to create a Cirq circuit that includes a Sympy expression as an exponent for a gate. The circuit applies an X gate raised to the power of the 'expr' variable to qubit q0, followed by a measurement of q0.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit(cirq.X(q0)**expr, cirq.measure(q0))\nprint(f\"circuit:\\n{circuit}\")\n```\n\n----------------------------------------\n\nTITLE: List Modules (bash)\nDESCRIPTION: This bash command lists the available Cirq modules. It invokes the `dev_tools/modules.py` script with the `list` argument. Additional options for listing modules in different modes (e.g., folder, package-path) can be found by using the `--help` flag.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/modules.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npython dev_tools/modules.py list\n```\n\n----------------------------------------\n\nTITLE: Characterize Phased FSim Parameters with XEB\nDESCRIPTION: This Python code defines a function `characterization_result` that takes a sampled dataframe as input and performs coherent error characterization using `xeb_fitting.characterize_phased_fsim_parameters_with_xeb_by_pair`. It uses a multiprocessing pool to speed up the optimization process and sets relaxed tolerance values (`fatol` and `xatol`) for faster convergence.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ndef characterization_result(sampled_df):\n    # Run the characterization loop\n    return xeb_fitting.characterize_phased_fsim_parameters_with_xeb_by_pair(\n        sampled_df,\n        pcircuits,\n        cycle_depths,\n        options,\n        pool=pool,\n        # ease tolerance so it converges faster:\n        fatol=1e-2,\n        xatol=1e-2,\n    )\n```\n\n----------------------------------------\n\nTITLE: Display Unitary of Modular Exponential Gate (Conditional)\nDESCRIPTION: This snippet demonstrates how to display the unitary matrix of the `ModularExp` gate.  It includes a commented-out line due to the potential memory requirements for large values of `n`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Pick some element of the multiplicative group modulo n.\nx = 5\n\n# Display (part of) the unitary. Uncomment if n is small enough.\n# cirq.unitary(ModularExp(target, exponent, x, n))\n```\n\n----------------------------------------\n\nTITLE: Initializing Qubit Register with Cirq\nDESCRIPTION: This snippet initializes a qubit register in Cirq, representing the position vectors on a graph. It defines the number of qubits and creates a rectangular grid of qubits using `cirq.GridQubit.rect()`.  It then prints the created qubit register.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/quantum_walks.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nnumber_qubits = 7\nqubits = cirq.GridQubit.rect(1, number_qubits)\n\nprint(qubits)\n```\n\n----------------------------------------\n\nTITLE: Displaying Parity Gates in Cirq\nDESCRIPTION: This snippet uses the display_gates function to display documentation for the parity gates XXPowGate, YYPowGate, and ZZPowGate. The display_gates function retrieves each gate from the cirq module and displays its docstring using IPython.display.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndisplay_gates(\"XXPowGate\", \"YYPowGate\", \"ZZPowGate\")\n```\n\n----------------------------------------\n\nTITLE: Creating ThreeDQubits for Pasqal\nDESCRIPTION: This code creates a list of `ThreeDQubit` objects arranged in a 6x6x1 grid.  The `ThreeDQubit` class represents a qubit positioned in 3D space. It iterates through rows, columns, and layers to generate a list of qubits, fixing the depth to 1 to confine all qubits to the z=0 plane.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/pasqal/getting_started.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nwidth=6\nheight=6\ndepth=1\n# Creating p_qubits, a list of ThreeDQubits.\np_qubits=[ThreeDQubit(row, col, layer) \n          for row in range(width) \n          for col in range(height)\n          for layer in range(depth)]\n```\n\n----------------------------------------\n\nTITLE: Executing Cirq Circuit on Quantum Virtual Machine (QVM) in Python\nDESCRIPTION: This code snippet demonstrates how to execute a device-ready Cirq circuit on a Quantum Virtual Machine. It uses `sim_engine.get_sampler(processor_id).run(circuit, repetitions=repetitions)` to run the circuit with a specified number of repetitions. The code also measures the execution time and prints the results. Requires the `cirq` and `time` modules to be imported.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_basic_example.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# @title Execute your device ready circuit on the Quantum Virtual Machine\ncircuit = device_ready_ghz_circuit\n\nrepetitions = 3000\nstart = time.time()\nresults = sim_engine.get_sampler(processor_id).run(circuit, repetitions=repetitions)\nelapsed = time.time() - start\n\nprint('Circuit successfully executed on your quantum virtual machine', processor_id)\nprint(f'QVM runtime: {elapsed:.04g}s ({repetitions} repetitions)')\nprint('You can now print or plot \"results\"')\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq in Python\nDESCRIPTION: This snippet attempts to import the `cirq` library. If the import fails, it installs Cirq using pip and then imports it. This ensures that the Cirq library is available before proceeding.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/concepts.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n```\n\n----------------------------------------\n\nTITLE: Testing Plotting Functions in Cirq with Matplotlib\nDESCRIPTION: This code snippet provides an example of how to test a plotting function that follows the recommended guidelines.  It creates a `plt.Axes` object and passes it to the `plot` method. This approach avoids unwanted pop-up windows during testing. The axes can then be asserted upon to check the correctness of the plot.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/plotting.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef test_foo_plot():\n    # make a Foo instance foo\n    figure, ax = plt.subplots(1, 1)\n    foo.plot(ax)\n    # assert on the content of ax here if necessary.\n```\n\n----------------------------------------\n\nTITLE: Inspecting Moments within a Cirq Quantum Circuit\nDESCRIPTION: This snippet demonstrates how to iterate through the moments of a Cirq quantum circuit. Each moment represents a set of operations that can be executed simultaneously. The code iterates through the circuit's moments and prints each one.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Print out the moments in a circuit.\"\"\"\nprint(\"Circuit:\\n\")\nprint(circuit)\n\n# Inspecting individual moments.\nprint(\"\\nMoments in the circuit:\\n\")\nfor i, moment in enumerate(circuit):\n    print(f'Moment {i}: \\n{moment}')\n```\n\n----------------------------------------\n\nTITLE: Produce Package\nDESCRIPTION: This bash script checks out the release branch and executes the `produce-package.sh` script, which creates a binary distribution wheel in the `dist` directory. It then lists the contents of the directory to verify the output.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/release.md#_snippet_7\n\nLANGUAGE: Bash\nCODE:\n```\ngit checkout \"v${VER}-dev\"\n./dev_tools/packaging/produce-package.sh dist\nls dist  # should only contain one file, for each modules\n```\n\n----------------------------------------\n\nTITLE: Getting the Length of Result List\nDESCRIPTION: This snippet obtains the length of the measurement result list for a classical register named 'b'.  The key 'm_b' is used to access the list within the results dictionary. The length indicates the number of repetitions executed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_honeywell.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nlen(result[\"m_b\"])\n```\n\n----------------------------------------\n\nTITLE: Getting Unitary of a Custom Gate\nDESCRIPTION: This snippet shows how to obtain the unitary matrix representation of a custom gate, `RationalGate`, in Cirq. The `cirq.unitary()` function is used to retrieve the unitary matrix of the gate. It relies on the gate implementing the `_unitary_` method.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_51\n\nLANGUAGE: python\nCODE:\n```\nprint(cirq.unitary(rg))\n```\n\n----------------------------------------\n\nTITLE: Defining Measurement Targets in Cirq\nDESCRIPTION: This section defines the target ordering for measurement operations in Cirq. Specifically, 'meas_targets' uses 'SUBSET_PERMUTATION' ordering, meaning that any subset of the specified qubits can be measured in any order.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-google/cirq_google/devices/specifications/weber_2021_12_10_device_spec.proto.txt#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nvalid_targets {\n  name: \"meas_targets\"\n  target_ordering: SUBSET_PERMUTATION\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a bit-flip channel in Cirq\nDESCRIPTION: This code creates a single-qubit bit-flip channel using `cirq.bit_flip` with a probability parameter p=0.1. The bit-flip channel models noise where a qubit's state is flipped (0 becomes 1, and 1 becomes 0) with a given probability.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\n\n\"\"\"Get a single-qubit bit-flip channel.\"\"\"\nbit_flip = cirq.bit_flip(p=0.1)\n```\n\n----------------------------------------\n\nTITLE: Utility Function to Print Type and Value\nDESCRIPTION: This python function, `typrint`, is a utility to print the type and value of any number of arguments passed to it. It's used for debugging and illustrating the types of objects being created.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# A small utility function to print the type and value of any number of arguments.\ndef typrint(*xs):\n    for x in xs:\n        print(type(x), x)\n```\n\n----------------------------------------\n\nTITLE: Define Version Variables\nDESCRIPTION: This bash script defines environment variables for the version to be released (VER) and the next version (NEXT_VER). NEXT_VER is skipped for PATCH releases. These variables are crucial for subsequent scripts.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/release.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\nVER=VERSION_YOU_WANT_TO_RELEASE  # e.g. \"0.7.0\"\nNEXT_VER=NEXT_VERSION  # e.g. \"0.8.0\" (skip for PATCH releases)\n```\n\n----------------------------------------\n\nTITLE: Validating Operation on Sycamore Device in Cirq\nDESCRIPTION: This code attempts to validate an X gate operation on a specific GridQubit using the Sycamore device. It demonstrates how to use `validate_operation` to check if an operation is valid on the device and prints any exception raised if validation fails, because the specified qubit is not present in the device.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/devices.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nop1 = cirq.X(cirq.GridQubit(7, 7))\n\ntry:\n    my_device.validate_operation(op1)\nexcept Exception as e:\n    print(e)\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq (Python)\nDESCRIPTION: This code snippet attempts to import the cirq library. If it fails, it installs cirq using pip and then imports it. This ensures that the cirq library is available for the rest of the notebook.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/start.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    import cirq\n\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Importing Cirq and Cirq-IonQ\nDESCRIPTION: This snippet imports the cirq and cirq_ionq libraries, which are required for interacting with the IonQ API. Cirq provides the basic quantum programming functionalities, and cirq_ionq provides specific utilities for the IonQ platform.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/getting_started.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport cirq_ionq as ionq\n```\n\n----------------------------------------\n\nTITLE: Initializing a Quantum Circuit\nDESCRIPTION: This snippet initializes a quantum circuit using Cirq. It likely demonstrates creating a basic quantum circuit structure for further manipulation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_18\n\nLANGUAGE: JavaScript\nCODE:\n```\n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\n```\n\n----------------------------------------\n\nTITLE: Setting Up Active Qubit Pair Combinations in Cirq with Python\nDESCRIPTION: This code sets up combinations of active qubit pairs using `cirq.experiments.random_quantum_circuit_generation.get_random_combinations_for_device`.  This function selects random combinations of qubit pairs for use in benchmarking circuits, based on the defined device graph.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ncombs_by_layer = rqcg.get_random_combinations_for_device(\n    n_library_circuits=len(circuit_library),\n    n_combinations=10,\n    device_graph=graph,\n    random_state=RANDOM_SEED,\n)\n```\n\n----------------------------------------\n\nTITLE: Mapping TiltedSquareLattice to GridQubits (Automatic)\nDESCRIPTION: This snippet demonstrates automatic mapping of a TiltedSquareLattice topology to the SYC23 device using `cirq.get_placements`. It uses a subgraph monomorphism algorithm to find placements and visualizes a subset of the generated placements.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/named_topologies.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ntopo = TiltedSquareLattice(4, 2)\nplacements = cirq.get_placements(SYC23_GRAPH, topo.graph)\ncirq.draw_placements(SYC23_GRAPH, topo.graph, placements[::3])\nprint('...\\n')\nprint(f'{len(placements)} total placements')\n```\n\n----------------------------------------\n\nTITLE: PauliSumExponential Instantiation in Cirq\nDESCRIPTION: Shows how to instantiate `PauliSumExponential` in Cirq, representing exponentials of commuting Pauli operators. It covers instantiation with PauliStrings and PauliSums, and demonstrates the use of an exponent.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# Instantiated with PauliStrings.\ntyprint(cirq.PauliSumExponential(Xa))\ntyprint(cirq.PauliSumExponential(Xa * Zb, exponent=3))\n# Instantiated with PauliSums.\ntyprint(cirq.PauliSumExponential(Xa + Zb, exponent=3 + 5j))\ntyprint(cirq.PauliSumExponential(2 * (3 * Xa + 4 * Zb), exponent=3))\n# Doesn't work with other bases than e.\ntry:\n    typrint(6 ** (Xa + Xb))\nexcept TypeError as e:\n    print(e)\n```\n\n----------------------------------------\n\nTITLE: Creating a Larger Grid Graph\nDESCRIPTION: This code creates a larger 2D grid graph using NetworkX. It assigns random weights to the edges of the graph and sets up the nodes for calculating a ZZ observable's expectation value. The graph is then drawn, coloring the nodes.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nwidth = 8\nheight = 8\ngraph = nx.grid_2d_graph(width, height)\nrs = np.random.RandomState(52)\nnx.set_edge_attributes(graph, name='weight',\n                       values={e: np.round(rs.uniform(), 2) for e in graph.edges})\n\nzz_inds = ((width//2, (height//2-1)), (width//2, (height//2)))\nnx.draw_networkx(graph, \n                 pos={n:n for n in graph.nodes},\n                 node_color=[QRED if node in zz_inds else QBLUE for node in graph.nodes])\n```\n\n----------------------------------------\n\nTITLE: Running Specific Cirq Benchmarks with ASV\nDESCRIPTION: This bash script executes specific Cirq performance benchmarks using Airspeed Velocity. It allows passing arguments to the `asv run` command, such as specifying the benchmark file and Python version.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/benchmarks/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./check/asv_run --quick --bench bench_examples --python 3.10\n```\n\n----------------------------------------\n\nTITLE: Displaying Fermionic Gates in Cirq\nDESCRIPTION: This snippet uses the display_gates function to display documentation for the fermionic gates FSimGate and PhasedFSimGate. The display_gates function retrieves each gate from the cirq module and displays its docstring using IPython.display.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndisplay_gates(\"FSimGate\", \"PhasedFSimGate\")\n```\n\n----------------------------------------\n\nTITLE: Custom channel in a circuit\nDESCRIPTION: Illustrates the use of a custom channel within a Cirq circuit.  It applies the `BitAndPhaseFlipChannel` to each of three qubits in a line, showcasing how custom channels can be seamlessly integrated into circuit definitions.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit(bit_phase_flip.on_each(*cirq.LineQubit.range(3)))\ncircuit\n```\n\n----------------------------------------\n\nTITLE: Fetching AQT Resources in Python\nDESCRIPTION: This code snippet demonstrates how to fetch available quantum resources for a given AQT access token using the `AQTSampler.fetch_resources` method.  It requires a valid access token to be used.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/aqt/getting_started.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nAQTSampler.fetch_resources(access_token)\n```\n\n----------------------------------------\n\nTITLE: Checking if Metadata is a DeviceMetadata Subclass in Cirq\nDESCRIPTION: This snippet checks if the metadata object obtained from the Sycamore device is a subclass of `cirq.DeviceMetadata`. This confirms that the metadata conforms to the expected structure.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/devices.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nissubclass(type(metadata), cirq.DeviceMetadata)\n```\n\n----------------------------------------\n\nTITLE: Displaying Classical Permutation Gates in Cirq\nDESCRIPTION: This snippet uses the display_gates function to display documentation for the classical permutation gate QubitPermutationGate. The display_gates function retrieves each gate from the cirq module and displays its docstring using IPython.display.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndisplay_gates(\"QubitPermutationGate\")\n```\n\n----------------------------------------\n\nTITLE: Cloning Cirq Repository\nDESCRIPTION: This command clones the Cirq repository from GitHub to your local machine and navigates into the newly created directory. It requires git to be installed and an internet connection to access the GitHub repository.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/quantumlib/Cirq.git\ncd Cirq\n```\n\n----------------------------------------\n\nTITLE: Getting Job Results\nDESCRIPTION: This snippet retrieves the results from a completed job. It uses the `results` method of the job object, which blocks until the job is completed. The results are then printed to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/getting_started.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nresults = same_job.results()\nprint(results)\n```\n\n----------------------------------------\n\nTITLE: Displaying Pauli Rotation Gates in Cirq\nDESCRIPTION: This snippet uses the display_gates function to display documentation for the Pauli rotation gates Rx, Ry, and Rz.  The display_gates function retrieves each gate from the cirq module and displays its docstring using IPython.display.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndisplay_gates(\"Rx\", \"Ry\", \"Rz\")\n```\n\n----------------------------------------\n\nTITLE: Print Gate Durations from Device Specification (Cirq-Google)\nDESCRIPTION: This code snippet retrieves a device specification from the Cirq Engine, iterates through the valid gate sets, and prints the ID and duration of each gate supported by the device. It requires a Cirq Engine object with a valid project ID and processor ID.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/specification.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\n\n# Create an Engine object to use.\nengine = cirq_google.Engine(project_id='your_project_id')\n\n# Replace the processor id to get the device specification with that id.\nspec = engine.get_processor('processor_id').get_device_specification()\n\n# Iterate through each gate set valid on the device.\nfor gateset in spec.valid_gate_sets:\n    print(gateset.name)\n    print('-------')\n    # Prints each gate valid in the set with its duration\n    for gate in gateset.valid_gates:\n        print('%s %d' % (gate.id, gate.gate_duration_picos))\n```\n\n----------------------------------------\n\nTITLE: Running a Bell State Circuit with Quilc Compilation and Custom Transformation\nDESCRIPTION: This code snippet defines a custom transformation hook that inserts a Reset instruction and a Pragma statement for initial rewiring into the Quil program. It then configures the `RigettiQCSService` with a Quilc compilation executor and the custom transformation. Explicit qubit assignments are made using a qubit ID map. Finally, the Bell state circuit is run with these configurations, and the state histogram is plotted.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/rigetti/getting_started.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pyquil.quilbase import Reset, Pragma\n\ndef hook(program, measurement_id_map):\n    program._instructions.insert(0, Reset())\n    program._instructions.insert(1, Pragma('INITIAL_REWIRING', freeform_string='GREEDY'))\n    print(program)\n    return program, measurement_id_map\n\n# assign qubits explicitly to hardware or virtual machine qubits.\nqubit_id_map = {\n   qubits[0]: 4,\n   qubits[1]: 5,\n}\nexecutor = circuit_sweep_executors.with_quilc_compilation_and_cirq_parameter_resolution\ntransformer = circuit_transformers.build(qubit_id_map=qubit_id_map, qubits=qubits, post_transformation_hooks=[hook])\nservice = get_rigetti_qcs_service(SERVICE_NAME, as_qvm=True, executor=executor, transformer=transformer)\nresult = service.run(bell_circuit, repetitions=1000)\n\ncirq.plot_state_histogram(result.histogram(key='m'))\n```\n\n----------------------------------------\n\nTITLE: Profiling Cirq and Quimb Density Matrix Calculations\nDESCRIPTION: This snippet defines a function, `profile`, that benchmarks the performance of calculating the final density matrix using both Cirq's built-in function and the tensor network approach via `cirq.contrib.quimb`. It generates random circuits, adds noise, and measures the execution time of each method using the `timeit` module.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Cirq-to-Tensor-Networks.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nimport timeit\n\ndef profile(n_qubits: int, n_moments: int):\n    qubits = cirq.LineQubit.range(n_qubits)\n    circuit = cirq.testing.random_circuit(qubits, n_moments=n_moments, op_density=0.8)\n    noise_model = cirq.ConstantQubitNoiseModel(cirq.DepolarizingChannel(p=1e-3))\n    circuit = cirq.Circuit(noise_model.noisy_moments(circuit.moments, qubits))\n    circuit = cirq.drop_empty_moments(circuit)\n    n_moments = len(circuit)\n    variables = {'circuit': circuit, 'qubits': qubits}\n\n    setup1 = [\n        'import cirq',\n        'import numpy as np',\n    ]\n    n_call_cs, duration_cs = timeit.Timer(\n        stmt='cirq.final_density_matrix(circuit)',\n        setup='; '.join(setup1),\n        globals=variables).autorange()\n\n    setup2 = [\n        'from cirq.contrib.quimb import tensor_density_matrix',\n        'import numpy as np',\n    ]\n    n_call_t, duration_t = timeit.Timer(\n        stmt='tensor_density_matrix(circuit, qubits)',\n        setup='; '.join(setup2),\n        globals=variables).autorange()\n\n    return {\n        'n_qubits': n_qubits,\n        'n_moments': n_moments,\n        'duration_cirq': duration_cs,\n        'duration_quimb': duration_t,\n        'n_call_cirq': n_call_cs,\n        'n_call_quimb': n_call_t,\n    }\n```\n\n----------------------------------------\n\nTITLE: JSON Test Specification (Python)\nDESCRIPTION: This Python snippet defines the JSON test specification in `spec.py` for a Cirq module. It utilizes the `ModuleJsonTestSpec` class from `cirq.testing.json` to specify the packages to be tested, the path to test data, and the resolver cache. The `TestSpec` variable is then imported by the module's `__init__.py` for integration into the central test framework.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/modules.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport pathlib\nimport cirq_example\nfrom cirq_example.json_resolver_cache import _class_resolver_dictionary\n\nfrom cirq.testing.json import ModuleJsonTestSpec\n\nTestSpec = ModuleJsonTestSpec(\n    name=\"cirq_example\",\n    packages=[cirq_example],\n    test_data_path=pathlib.Path(__file__).parent,\n    not_yet_serializable=[],\n    should_not_be_serialized=[],\n    resolver_cache=_class_resolver_dictionary(),\n    deprecated={},\n )\n```\n\n----------------------------------------\n\nTITLE: Compute Unitary of an Adder Gate using Cirq\nDESCRIPTION: This snippet calculates and displays the unitary matrix representation of an Adder gate using Cirq. It uses `cirq.unitary` to compute the unitary and `.real` to extract the real part.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ncirq.unitary(\n    Adder(target_register=[2, 2],\n          input_register=1)\n).real\n```\n\n----------------------------------------\n\nTITLE: Creating Cirq Circuit with InternalGate\nDESCRIPTION: This snippet demonstrates how to create a `cirq.Circuit` using an `InternalGate` operation. It creates a circuit with the internal gate acting on two `cirq.LineQubit` instances.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/internal_gates.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncirq.Circuit(internal_gate(*cirq.LineQubit.range(2)))\n```\n\n----------------------------------------\n\nTITLE: Testing the Quantum Solution\nDESCRIPTION: Defines a function to test the quantum solution by repeatedly solving the problem and verifying that the result is a valid solution. This includes calling the brute force algorithm to precompute the solution space.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/hidden_linear_function.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef test_problem(problem):\n    problem.bruteforce_solve()\n    tries = 100\n    for _ in range(tries):\n        z = solve_problem(problem)\n        assert problem.is_z(z)\n    \ntest_problem(problem_10_64)\nprint('OK')\n```\n\n----------------------------------------\n\nTITLE: Define opt_einsum Dependency\nDESCRIPTION: Specifies opt_einsum as a dependency without any version constraint. This package is used for optimizing Einstein summation expressions, suggesting its use in numerical computations involving tensors.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/requirements.txt#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nopt_einsum\n```\n\n----------------------------------------\n\nTITLE: Install Cirq and ply Packages\nDESCRIPTION: This code installs both the `cirq` and `ply` Python packages using `pip`. The `ply` package is a requirement for importing circuits from OpenQASM.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/interop.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n!pip install --quiet cirq\n!pip install --quiet ply\n```\n\n----------------------------------------\n\nTITLE: Configuring PolyCollection Properties in Heatmap\nDESCRIPTION: This snippet shows how to modify the PolyCollection properties of a `cirq.TwoQubitInteractionHeatmap`. It updates the plot by setting custom edge colors and linewidths for the polygons representing qubit interactions.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/heatmaps.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n_, ax = plt.subplots(figsize=(8, 8))\n_ = two_qubit_interaction_heatmap.plot(ax,\n                                       title = 'Heatmap with modified PolyCollection',\n                                       collection_options = {\n                                           'edgecolors' : ('red', 'blue', 'blue', 'red'),\n                                           'linewidths' : 5,\n                                       })\n```\n\n----------------------------------------\n\nTITLE: Publishing a Development Package to Production PyPI\nDESCRIPTION: Shows the command to publish a development package to the production PyPI repository. It requires specifying the expected version and setting the `PROD_TWINE_USERNAME` and `PROD_TWINE_PASSWORD` environment variables.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\n./dev_tools/packaging/publish-dev-package.sh EXPECTED_VERSION --prod\n```\n\n----------------------------------------\n\nTITLE: Installing and Importing Cirq and Cirq-Google in Python\nDESCRIPTION: This code snippet attempts to import the Cirq and Cirq-Google libraries. If Cirq is not found, it installs Cirq using pip and then imports both libraries. This ensures that the necessary dependencies are available for the subsequent code.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n\nimport cirq_google\n```\n\n----------------------------------------\n\nTITLE: Fitting Exponential Decays to XEB Fidelities in Python\nDESCRIPTION: This code snippet fits exponential decay curves to the XEB fidelities obtained in the previous step using `cirq.experiments.xeb_fitting.fit_exponential_decays`. This provides a model for how the fidelity degrades with increasing circuit depth, which can be used to estimate error rates.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.experiments.xeb_fitting import fit_exponential_decays, exponential_decay\nfidelities = fit_exponential_decays(fids)\n```\n\n----------------------------------------\n\nTITLE: Printing Sycamore Device in Python\nDESCRIPTION: This snippet imports the `cirq_google` module and then prints the `Sycamore` attribute. This will print a diagram representing the layout of qubits on the Sycamore quantum processor, verifying that Cirq and its components have been properly installed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Test successful installation by printing out the Sycamore device.\"\"\"\nimport cirq_google\n\nprint(cirq_google.Sycamore)\n```\n\n----------------------------------------\n\nTITLE: Define ply Dependency\nDESCRIPTION: Specifies the ply (Python Lex-Yacc) package as a dependency with a minimum version of 3.6. This package is likely used for parsing or lexical analysis within the contrib module.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/requirements.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nply>=3.6\n```\n\n----------------------------------------\n\nTITLE: Initializing Noise Models and Samplers in Cirq with Python\nDESCRIPTION: This code initializes the coherent, incoherent, noiseless, and fused noise models. It then creates `cirq.DensityMatrixSimulator` instances for each noise model to simulate quantum circuits with the specified noise.  It then creates samplers using these simulators.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# create noise models\ncoherent_noise = cirq.devices.noise_model.GateSubstitutionNoiseModel(_sub_iswap)\nincoherent_noise = cirq.ConstantQubitNoiseModel(cirq.depolarize(5e-3))\nnoiseless = None\nfused_noise = FusedNoiseModel([coherent_noise, incoherent_noise])\n\n# create samplers by passing noise models to simulator constructor\ncoherent_sampler = cirq.DensityMatrixSimulator(noise=coherent_noise)\nincoherent_sampler = cirq.DensityMatrixSimulator(noise=incoherent_noise)\nnoiseless_sampler = cirq.DensityMatrixSimulator(noise=noiseless)\nfused_sampler = cirq.DensityMatrixSimulator(noise=fused_noise)\n\n# from here on out, all experiment steps will be performed on\n#   samplers and their results in the following order.\nsamplers = [coherent_sampler, incoherent_sampler, noiseless_sampler, fused_sampler]\nnoise_titles = ['Coherent', 'Incoherent', 'Noiseless', 'Fused']\n```\n\n----------------------------------------\n\nTITLE: Route Circuit on Device Graph\nDESCRIPTION: Maps a quantum circuit onto the grid of a quantum processor, accounting for its topology using `cirq.RouteCQC`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/start.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndevice_graph = device.metadata.nx_graph\nrouter = cirq.RouteCQC(device_graph)\nhw_circuit = router(circuit)\nprint(hw_circuit)\n```\n\n----------------------------------------\n\nTITLE: Get Sampler from Processor\nDESCRIPTION: Retrieves a Sampler object from the Processor object. Shows how to use optional `device_config_name` and `run_name` parameters.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/start.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsampler = processor.get_sampler(\n    # Get these values from an internal partner:\n    # device_config_name='layout_42',\n    # run_name='2023.11.06-1.0',\n)\n```\n\n----------------------------------------\n\nTITLE: Custom Histogram with Fold Function in Cirq\nDESCRIPTION: This example demonstrates how to use the `fold_func` parameter of `result.histogram()` to process measurement results and generate a customized histogram. It defines a function `count_ones` that calculates the parity of the number of ones in a measurement result and uses it to create a histogram of even/odd parities.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/state_histograms.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef count_ones(bits):\n    return 'even' if sum(bits) % 2 == 0 else 'odd'\n\nq = cirq.LineQubit.range(6)\n# Uniform superposition over all 2 ** 6 states.\ncircuit = cirq.Circuit([cirq.H.on_each(*q), cirq.measure(*q, key='measure_all')])\nresult = cirq.Simulator().run(circuit, repetitions=100)\n# Create a customized histogram by processing the measurement results using `fold_func`.\ncustom_histogram = result.histogram(key = 'measure_all', fold_func=count_ones)\n# Plot the custom histogram using cirq.plot_state_histogram\n_ = cirq.plot_state_histogram(custom_histogram, plt.subplot())\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Listing Honeywell Targets using AzureQuantumService\nDESCRIPTION: This snippet retrieves a list of available targets, filtered by the Honeywell provider, using the `targets` method of the `AzureQuantumService` object.  The `provider_id` parameter specifies the Honeywell provider.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_honeywell.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nservice.targets(provider_id=\"honeywell\")\n```\n\n----------------------------------------\n\nTITLE: Printing Gate Timings\nDESCRIPTION: This snippet demonstrates how to access and print the gate timings (t1, t2, 1q, 2q, readout, and reset) from the `cirq_ionq.Calibration` object using the `timings()` method. The timings are returned in seconds and give information on the speed of operations on the QPU. Requires a `cirq_ionq.Calibration` object named `calibration`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/calibrations.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nprint(calibration.timings())\n```\n\n----------------------------------------\n\nTITLE: Defining Two-Qubit Targets in Cirq\nDESCRIPTION: This defines valid two-qubit target pairs for gates within Cirq using the 'SYMMETRIC' ordering. The snippet lists specific pairs of qubits such as \"0_5\", \"0_6\" indicating where two-qubit gates can be applied.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-google/cirq_google/devices/specifications/weber_2021_12_10_device_spec.proto.txt#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nvalid_targets {\n  name: \"2_qubit_targets\"\n  target_ordering: SYMMETRIC\n  targets {\n    ids: \"0_5\"\n    ids: \"0_6\"\n  }\n  targets {\n    ids: \"0_5\"\n    ids: \"1_5\"\n  }\n  targets {\n    ids: \"0_6\"\n    ids: \"1_6\"\n  }\n  targets {\n    ids: \"1_4\"\n    ids: \"1_5\"\n  }\n  targets {\n    ids: \"1_4\"\n    ids: \"2_4\"\n  }\n  targets {\n    ids: \"1_5\"\n    ids: \"1_6\"\n  }\n  targets {\n    ids: \"1_5\"\n    ids: \"2_5\"\n  }\n  targets {\n    ids: \"1_6\"\n    ids: \"1_7\"\n  }\n  targets {\n    ids: \"1_6\"\n    ids: \"2_6\"\n  }\n  targets {\n    ids: \"1_7\"\n    ids: \"2_7\"\n  }\n  targets {\n    ids: \"2_4\"\n    ids: \"2_5\"\n  }\n  targets {\n    ids: \"2_4\"\n    ids: \"3_4\"\n  }\n  targets {\n    ids: \"2_5\"\n    ids: \"2_6\"\n  }\n  targets {\n    ids: \"2_5\"\n    ids: \"3_5\"\n  }\n  targets {\n    ids: \"2_6\"\n    ids: \"2_7\"\n  }\n  targets {\n    ids: \"2_6\"\n    ids: \"3_6\"\n  }\n  targets {\n    ids: \"2_7\"\n    ids: \"2_8\"\n  }\n  targets {\n    ids: \"2_7\"\n    ids: \"3_7\"\n  }\n  targets {\n    ids: \"2_8\"\n    ids: \"3_8\"\n  }\n  targets {\n    ids: \"3_2\"\n    ids: \"3_3\"\n  }\n  targets {\n    ids: \"3_2\"\n    ids: \"4_2\"\n  }\n  targets {\n    ids: \"3_3\"\n    ids: \"3_4\"\n  }\n  targets {\n    ids: \"3_3\"\n    ids: \"4_3\"\n  }\n  targets {\n    ids: \"3_4\"\n    ids: \"3_5\"\n  }\n  targets {\n    ids: \"3_4\"\n    ids: \"4_4\"\n  }\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-release Cirq with Optional Modules\nDESCRIPTION: Installs the latest pre-release version of Cirq with all optional modules. The ~= operator selects the latest version compatible with the 1.0.dev specification.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-ionq/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npip install --upgrade cirq~=1.0.dev\n```\n\n----------------------------------------\n\nTITLE: Displaying Syndrome Corrections\nDESCRIPTION: This snippet displays the mapping from syndromes to corrections defined in the StabilizerCode instance, allowing to verify the correction logic.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/stabilizer_code.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ncode.syndromes_to_corrections\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq Pre-release\nDESCRIPTION: This snippet shows how to install the pre-release version of Cirq using pip. This is required for notebooks that rely on unreleased features.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/notebooks.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install --upgrade cirq~=1.0.dev\n```\n\n----------------------------------------\n\nTITLE: Install Azure Quantum Cirq Dependencies\nDESCRIPTION: Installs the `azure-quantum` package with Cirq dependencies using pip. The `--quiet` flag suppresses output during installation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_ionq.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n!pip install 'azure-quantum[cirq]' --quiet\n```\n\n----------------------------------------\n\nTITLE: Handling Unitary Protocol Errors\nDESCRIPTION: This code demonstrates how to handle errors when an object does not support the `cirq.unitary` protocol. In this example, it attempts to get the unitary of a qubit `a`, which is not a unitary object, and catches the resulting exception.  This showcases how to gracefully handle situations where a protocol is not supported.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/protocols.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntry: \n    print(cirq.unitary(a)) ## error!\nexcept Exception as e: \n    print(\"As expected, a qubit does not have a unitary. The error: \")\n    print(e)\n    \n```\n\n----------------------------------------\n\nTITLE: Creating a Grid Graph with NetworkX\nDESCRIPTION: This code creates a 2D grid graph using NetworkX and assigns random weights to its edges. It then visualizes the graph, coloring nodes based on whether they belong to a specified set of indices (`zz_inds`). The `nx.draw_networkx` function is used to draw the graph with node colors determined by a list comprehension.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nwidth = 3\nheight = 4\ngraph = nx.grid_2d_graph(width, height)\nrs = np.random.RandomState(52)\nnx.set_edge_attributes(graph, name='weight',\n                       values={e: np.round(rs.uniform(), 2) for e in graph.edges})\n\nzz_inds = ((width//2, (height//2-1)), (width//2, (height//2)))\nnx.draw_networkx(graph, \n                 pos={n:n for n in graph.nodes},\n                 node_color=[QRED if node in zz_inds else QBLUE for node in graph.nodes])\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq Library in Python\nDESCRIPTION: This code snippet attempts to import the Cirq library. If Cirq is not installed, it installs Cirq using pip and then imports it. This ensures that the notebook has access to the Cirq library.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/xeb_theory.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    import cirq\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Uploading Package to PyPI with Twine\nDESCRIPTION: Shows how to upload the generated package files to PyPI using Twine.  It requires setting the `PROD_TWINE_USERNAME` and `PROD_TWINE_PASSWORD` environment variables.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\ntwine upload -u \"${PROD_TWINE_USERNAME}\" -p \"${PROD_TWINE_PASSWORD}\" dist/*\n```\n\n----------------------------------------\n\nTITLE: Printing the Cirq Result\nDESCRIPTION: This snippet prints the `cirq.Result` object obtained from running a circuit on Azure Quantum.  Note that the API validator only returns zeros.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_honeywell.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Installing Azure Quantum Cirq Dependencies\nDESCRIPTION: This snippet installs the `azure-quantum` package with Cirq dependencies using pip. The `--quiet` flag suppresses the output during installation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/azure-quantum/getting_started_honeywell.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n!pip install 'azure-quantum[cirq]' --quiet\n```\n\n----------------------------------------\n\nTITLE: Parameterize Circuit for Coherent Error Characterization\nDESCRIPTION: This Python code sets up the options and parameterizes the circuit for coherent error characterization. It initializes an `SqrtISwapXEBOptions` object, specifying that only the `phi` parameter should be characterized, and then parameterizes each circuit in `circuit_library` using the `xeb_fitting.parameterize_circuit` function.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# Set which angles to characterize (all)\noptions = xeb_fitting.SqrtISwapXEBOptions(\n    characterize_theta=False,\n    characterize_zeta=False,\n    characterize_chi=False,\n    characterize_gamma=False,\n    characterize_phi=True,\n)\n# Parameterize the sqrt(iswap)s in circuit library\npcircuits = [xeb_fitting.parameterize_circuit(circuit, options) for circuit in circuit_library]\n```\n\n----------------------------------------\n\nTITLE: Initializing IonQ Service\nDESCRIPTION: This snippet demonstrates how to import the necessary libraries (cirq and cirq_ionq) and instantiate a cirq_ionq.Service object, which is required to interact with the IonQ API. It assumes that the cirq and cirq_ionq libraries are installed. It sets up the environment for subsequent interactions with the IonQ service.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/ionq/circuits.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport cirq_ionq as ionq\nservice = ionq.Service()\n```\n\n----------------------------------------\n\nTITLE: Installing cirq_google and qsimcirq with pip\nDESCRIPTION: This code snippet attempts to import cirq and cirq_google. If the import fails due to the modules not being installed, it installs them using pip. After installation it attempts to import the modules again. The same process is then repeated for qsimcirq.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/qvm_stabilizer_example.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\n    import cirq_google\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq-google\n    print(\"installed cirq.\")\n    import cirq\n    import cirq_google\n\ntry:\n    import qsimcirq\nexcept ImportError:\n    print(\"installing qsimcirq...\")\n    !pip install --quiet qsimcirq\n    print(f\"installed qsimcirq.\")\n    import qsimcirq\n\n# Other modules used in this colab\nimport matplotlib.pyplot as plt\nimport time\nimport random\n```\n\n----------------------------------------\n\nTITLE: Wavefunction Simulator on Mixture Protocol\nDESCRIPTION: This snippet demonstrates using the wavefunction simulator on a channel that implements the mixture protocol. It shows that the unitary Kraus operators are applied stochastically, and multiple executions will produce different outputs.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_76\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit(cirq.depolarize(0.5).on(a), cirq.measure(a))\nsimulator = cirq.Simulator()\nresult = simulator.run(circuit, repetitions=10)\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: ConstantQubitNoiseModel Example in Cirq\nDESCRIPTION: This code demonstrates the `ConstantQubitNoiseModel` to apply noise after every gate in a Cirq circuit.  The noise is applied even after measurement gates. This model is useful for testing but is not very representative of real-world noise.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/representing_noise.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nq0 = cirq.LineQubit(0)\ncircuit = cirq.Circuit(\n    cirq.I(q0),\n    cirq.measure(q0, key='result_0'),\n    cirq.measure(q0, key='result_1'),\n)\n# Applies noise after every gate, even measurements.\nnoisy_circuit = circuit.with_noise(cirq.X)\nprint(noisy_circuit)\nresult = cirq.Simulator(seed=0).run(noisy_circuit, repetitions=20)\nprint(\"First measure:\", result.histogram(key='result_0'))\nprint(\"Second measure:\", result.histogram(key='result_1'))\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq in Python\nDESCRIPTION: This code snippet attempts to import the Cirq library. If the import fails (indicating Cirq is not installed), it executes a pip install command to install Cirq and then imports it. It also imports matplotlib and numpy.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n```\n\n----------------------------------------\n\nTITLE: Verifying Uploaded Package on Production PyPI\nDESCRIPTION: Illustrates how to verify the uploaded package on the production PyPI repository using the verification script.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_32\n\nLANGUAGE: bash\nCODE:\n```\n./dev_tools/packaging/verify-published-package.sh VERSION_YOU_UPLOADED --prod\n```\n\n----------------------------------------\n\nTITLE: Simulating Measurement with DensityMatrixSimulator\nDESCRIPTION: This snippet illustrates simulating a circuit with a measurement using the `DensityMatrixSimulator`. It highlights that the simulation of measurements is statistical and the final density matrix can vary between simulations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_73\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit(cirq.depolarize(0.5)(a), cirq.measure(a))\n\n# Simulate with the density matrix multiple times.\ndmat1 = simulator.simulate(circuit).final_density_matrix\ndmat2 = simulator.simulate(circuit).final_density_matrix\n\nprint(np.allclose(dmat1, dmat2))\n```\n\n----------------------------------------\n\nTITLE: Build Wheel Files Locally (bash)\nDESCRIPTION: This bash script builds wheel files for Cirq packages locally.  It uses the `produce-package.sh` script along with `generate-dev-version-id.sh` to generate the package files in the `./dist` directory.  It's part of the packaging process for Cirq modules.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/modules.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndev_tools/packaging/produce-package.sh ./dist `./dev_tools/packaging/generate-dev-version-id.sh`\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries\nDESCRIPTION: This snippet imports necessary libraries for the Loschmidt echo experiment. It imports typing for type hints, matplotlib for plotting, numpy for numerical operations, cirq for quantum circuit creation and simulation, and cirq_google for interacting with Google's Quantum Engine.  It also imports random_rotations_between_grid_interaction_layers_circuit from cirq.experiments.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/echoes.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional, Sequence\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport cirq\nimport cirq_google as cg\nfrom cirq.experiments import random_rotations_between_grid_interaction_layers_circuit\n```\n\n----------------------------------------\n\nTITLE: Using timezone-aware datetime objects (Python)\nDESCRIPTION: This snippet demonstrates how to create a timezone-aware datetime object using `datetime.datetime.now(tz=datetime.timezone.utc)`. This ensures consistency and avoids issues related to naive datetime objects. It emphasizes the use of timezone-aware datetimes in Cirq.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/style.md#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nimport datetime\ndt = datetime.datetime.now(tz=datetime.timezone.utc)\n```\n\n----------------------------------------\n\nTITLE: Displaying Pauli PowGates in Cirq\nDESCRIPTION: This snippet uses the display_gates function to display documentation for the Pauli PowGates XPowGate, YPowGate, and ZPowGate. The display_gates function retrieves each gate from the cirq module and displays its docstring using IPython.display.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/gatezoo.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndisplay_gates(\"XPowGate\", \"YPowGate\", \"ZPowGate\")\n```\n\n----------------------------------------\n\nTITLE: Performance Test\nDESCRIPTION: Demonstrates the performance of the quantum solver on a larger problem with n=200. This includes a timing analysis using the %%time magic command.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/hidden_linear_function.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n%%time\ntries = 200\nproblem = random_problem(tries, seed=0)\nsolve_problem(problem, print_circuit=False)\n```\n\n----------------------------------------\n\nTITLE: Hard-coded Initial Mapper (Python)\nDESCRIPTION: This code initializes a hard-coded initial mapping strategy to place logical qubits onto specific physical qubits. This provides a controlled placement for the routing process.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/routing_transformer.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Use a hard-coded initial mapping strategy of logical to physical that places q0, q1, q2, q3 onto\n# Grid(3, 5), Grid(3, 6), Grid(4, 5), Grid(4, 6), respectively\ngq = cirq.GridQubit(3, 5)\nhc_initial_mapper = cirq.HardCodedInitialMapper(\n    {q[0]: gq, q[1]: gq + (0, -1), q[2]: gq + (-1, 0), q[3]: gq + (-1, -1)}\n)\nprint(hc_initial_mapper)\n```\n\n----------------------------------------\n\nTITLE: Verifying Cirq Installation\nDESCRIPTION: This snippet verifies the Cirq installation by importing the `cirq_google` module and printing the `cirq_google.Sycamore` object. This confirms that Cirq and its dependencies are correctly installed and accessible.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/install.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npython -c 'import cirq_google; print(cirq_google.Sycamore)'\n```\n\n----------------------------------------\n\nTITLE: Generating Probability Distribution for Classical Walk\nDESCRIPTION: This function generates the probability distribution of the walker's position after multiple runs of the classical random walk. It takes the number of runs and the number of steps as input. It simulates the random walk for the specified number of runs, records the final positions, and then plots the distribution of these positions using matplotlib.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/quantum_walks.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef dist(runs, N):\n    \n    positions = range(-1*N, N+1)\n    instances = [0 for i in range(-1*N, N+1)]\n    \n    for k in range(runs):\n\n        result = random_walk(pr, N, i)\n        instances[positions.index(result)] += 1\n\n    plt.bar(positions, [n/runs for n in instances])\n    plt.show()\n    \ndist(10000, N)\n```\n\n----------------------------------------\n\nTITLE: Correlation and Forrelation Example in Python\nDESCRIPTION: Demonstrates the usage of `get_correlation` and `get_forrelation` functions with sample arrays. The code initializes two numpy arrays, 'f' and 'g', and calculates both the correlation and forrelation between them. It prints the results to demonstrate the difference between the two measures.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# let's see some examples to gain some insights of forrelation\nf = np.array([1, -1, 1, -1]) \ng = np.array([1, -1, 1, -1])\nprint(f\"Correlation: {get_correlation(f,g)}  Forrelation: {get_forrelation(f,g)}\")\n\nf = np.array([1, 1, 1, -1])\ng = np.array([-1, -1, -1, 1])\nprint(f\"Correlation: {get_correlation(f,g)}  Forrelation: {get_forrelation(f,g)}\")\n\nf = np.array([1, -1, -1, 1])\ng = np.array([1, 1, 1, 1])\nprint(f\"Correlation: {get_correlation(f,g)}  Forrelation: {get_forrelation(f,g)}\")\n```\n\n----------------------------------------\n\nTITLE: Define a Specific Problem Instance\nDESCRIPTION: Defines a specific instance of the Hidden Linear Function problem by setting the matrix A and vector b to particular values. This instance is used for later verification of the quantum solution.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/hidden_linear_function.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nA = np.array([[0, 1, 1, 0, 0, 1, 0, 0, 1, 1],\n              [0, 0, 0, 1, 1, 1, 1, 1, 1, 1],\n              [0, 0, 0, 0, 0, 0, 1, 1, 0, 1],\n              [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n              [0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n              [0, 0, 0, 0, 0, 0, 1, 1, 0, 0],\n              [0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n              [0, 0, 0, 0, 0, 0, 0, 0, 1, 1],\n              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])\nb = np.array([0, 0, 0, 0, 1, 1, 1, 0, 0, 1])\nproblem_10_64 = HiddenLinearFunctionProblem(A, b)\nproblem_10_64.bruteforce_solve()\nprint(\"Size of subspace L: %d\" % len(problem_10_64.L))\nprint(\"Number of solutions: %d\" % len(problem_10_64.all_zs))\n```\n\n----------------------------------------\n\nTITLE: Routing the Circuit (Python)\nDESCRIPTION: This code snippet applies the `RouteCQC` router to the previously defined quantum circuit, generating a routed circuit suitable for execution on the Sycamore device. The result is then printed to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/routing_transformer.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nrouted_circuit = router(circuit)\nprint(routed_circuit)\n```\n\n----------------------------------------\n\nTITLE: Checkout Patch Version Tag\nDESCRIPTION: This bash script fetches all tags from the origin, checks out the specific version tag intended for patching, and verifies that there are no pending changes. This is the first step for PATCH releases.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/release.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\ngit fetch origin # or upstream - to fetch all tags\ngit checkout <desired tag to patch>\ngit status  # should be no pending changes\n```\n\n----------------------------------------\n\nTITLE: Simulating a Quantum Circuit in Cirq using Python\nDESCRIPTION: This code snippet demonstrates how to create and simulate a simple quantum circuit using the Cirq library. It defines a qubit, creates a circuit with a square root of NOT gate and a measurement, and then simulates the circuit 20 times using the Cirq simulator. The output shows the circuit diagram and the measurement results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\n\n# Pick a qubit.\nqubit = cirq.GridQubit(0, 0)\n\n# Create a circuit.\ncircuit = cirq.Circuit(\n    cirq.X(qubit)**0.5,  # Square root of NOT.\n    cirq.measure(qubit, key='m')  # Measurement.\n)\nprint(\"Circuit:\")\nprint(circuit)\n\n# Simulate the circuit several times.\nsimulator = cirq.Simulator()\nresult = simulator.run(circuit, repetitions=20)\nprint(\"Results:\")\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Defining Pylint Dependency\nDESCRIPTION: This snippet defines the pylint dependency and its version constraint.  Pylint is used for static code analysis and linting within the Cirq project. The version specified is '~=3.3.1', meaning versions 3.3.1 and higher, but less than 4.0, are compatible.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/dev_tools/requirements/deps/pylint.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\npylint~=3.3.1\n```\n\n----------------------------------------\n\nTITLE: Sampling from Forrelated Distribution in Python\nDESCRIPTION: Defines a function `draw_two_distribution_from_f_set` to sample two forrelated distributions, 'fs' and 'gs', from the 'F' set. It generates random vectors 'vs' from a Gaussian distribution, calculates their Fourier transform 'vs_hat', and then takes the sign of each element in 'vs' and 'vs_hat' to obtain 'fs' and 'gs' respectively. A while loop ensures that the squared forrelation between 'fs' and 'gs' falls within a specified range before returning the distributions and their correlation/forrelation values. It also defines function `draw_two_distribution_from_u_set` that draws two functions that are uniformly random. A while loop ensures that the squared forrelation between `fs` and `gs` are not too forrelated.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef draw_two_distribution_from_f_set(N:int)-> Tuple[np.ndarray, np.ndarray, float, float]:\n    \"\"\"Samples two distributions from the 'F' set above.\n\n    Uses a while loop to guarantee a forrelated pair \"as promised\".\n\n    Returns:\n        A tuple that contains the two distributions, and the correlation/forrelation.\n    \"\"\"\n    sgn = lambda x: 1 if x >= 0 else -1\n    forrelation = 0.2\n    while (abs(forrelation)**2 < 0.05) and (abs(forrelation)**2 > 0.01):\n        vs = np.array([np.random.normal() for _ in range(N)])\n        vs_hat = fourier_transform_over_z2(vs)\n        fs = np.array([sgn(v) for v in vs])\n        gs = np.array([sgn(v_hat) for v_hat in vs_hat])\n        forrelation = get_forrelation(fs, gs)\n        correlation = get_correlation(fs, gs)\n    return fs, gs, forrelation, correlation\n\n\ndef draw_two_distribution_from_u_set(N:int)-> Tuple[np.ndarray, np.ndarray, float, float]:\n    \"\"\"Samples two distributions from the 'U' set above.\n\n    Uses a while loop to guarantee a forrelated pair \"as promised\".\n    \n    Returns:\n        A tuple that contains the two distributions, and the correlation/forrelation.\n    \"\"\"\n    sgn = lambda x: 1 if x >= 0 else -1\n    forrelation = 0.2\n    while (abs(forrelation)**2 < 0.05) and (abs(forrelation)**2 > 0.01):\n        vs = np.array([np.random.normal() for _ in range(N)])\n        fs = np.array([sgn(v) for v in vs])\n        us = np.array([np.random.normal() for _ in range(N)])\n        gs = np.array([sgn(u) for u in us])\n        forrelation = get_forrelation(fs, gs)\n        correlation = get_correlation(fs, gs)\n    return fs, gs, forrelation, correlation\n```\n\n----------------------------------------\n\nTITLE: NPX Command Execution via check Bash\nDESCRIPTION: This demonstrates how to execute npx commands from the top-level Cirq directory using the `check/npx` script.  It navigates to the relevant directory before running the command. This command requires the `check/npx` script to be available.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-web/cirq_ts/README.md#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\n# check/npx navigates to this directory and runs from there\ncheck/npx [YOUR_COMMAND]\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries in Python\nDESCRIPTION: This snippet imports the necessary libraries for numerical computation and plotting. `numpy` is used for array operations, and `matplotlib.pyplot` is used for creating visualizations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/qubit-placement.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nfrom matplotlib import pyplot as plt\n```\n\n----------------------------------------\n\nTITLE: Verifying Cirq Installation (Windows)\nDESCRIPTION: This snippet verifies the Cirq installation on Windows by importing the `cirq_google` module and printing the `cirq_google.Sycamore` object. The import statement is wrapped in double quotes to be compatible with Windows command line.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/install.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npython -c \"import cirq_google; print(cirq_google.Sycamore)\"\n```\n\n----------------------------------------\n\nTITLE: Deprecated class definition\nDESCRIPTION: This code snippet provides an example for deprecating a class in Cirq's json_test_data/spec.py file. It shows how to add an entry to the `deprecated` dictionary, associating a deprecated class name with a deprecation deadline.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/serialization.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndeprecated={\n 'DeprecatedClass': 'deprecation_deadline',\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq\nDESCRIPTION: This snippet installs the cirq library using pip. The `--quiet` flag suppresses the output.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-web/circuit_example.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n!pip install --quiet cirq\n```\n\n----------------------------------------\n\nTITLE: Installing the Stable Version of Cirq-AQT using pip\nDESCRIPTION: This snippet shows how to install the stable version of the Cirq-AQT module using pip. It installs the core Cirq module and its dependencies.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-aqt/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install cirq-aqt\n```\n\n----------------------------------------\n\nTITLE: HiddenLinearFunctionProblem Class\nDESCRIPTION: Defines a class representing an instance of the Hidden Linear Function problem. It initializes the problem with a matrix A and vector b, representing the coefficients of the quadratic form. It also implements methods to calculate the quadratic form's action on binary vectors, and to solve the problem using a brute-force approach.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/hidden_linear_function.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass HiddenLinearFunctionProblem:\n    \"\"\"Instance of Hidden Linear Function problem.\n    \n    The problem is defined by matrix A and vector b, which are\n    the coefficients of quadratic form, in which linear function\n    is \"hidden\".\n    \"\"\"\n    def __init__(self, A, b):\n        self.n = A.shape[0]\n        assert A.shape == (self.n, self.n)\n        assert b.shape == (self.n, )\n        for i in range(self.n):\n            for j in range(i+1):\n                assert A[i][j] == 0, 'A[i][j] can be 1 only if i<j'\n        \n        self.A = A\n        self.b = b\n        \n    def q(self, x):\n        \"\"\"Action of quadratic form on binary vector (modulo 4).\n        \n        Corresponds to `q(x)` in problem definition.\n        \"\"\"\n        assert x.shape == (self.n, )\n        return (2 * (x @ self.A @ x) + (self.b @ x)) % 4\n        \n    def bruteforce_solve(self):\n        \"\"\"Calculates, by definition, all vectors `z` which are solutions to the problem.\"\"\"\n        \n        # All binary vectors of length `n`.\n        all_vectors = [np.array([(m>>i) % 2 for i in range(self.n)]) for m in range(2**self.n)]\n\n        def vector_in_L(x):\n            for y in all_vectors:\n                if self.q( (x + y)%2 ) != (self.q(x) + self.q(y))%4:\n                    return False\n            return True\n\n        # L is subspace to which we restrict domain of quadratic form.\n        # Corresponds to `L_q` in the problem definition.\n        self.L = [x for x in all_vectors if vector_in_L(x)]\n        \n        # All vectors `z` which are solutions to the problem.\n        self.all_zs = [z for z in all_vectors if self.is_z(z)]\n    \n    def is_z(self, z):\n        \"\"\"Checks by definition, whether given vector `z` is solution to this problem.\"\"\"\n        assert z.shape == (self.n, )\n        assert self.L is not None\n        for x in self.L:\n            if self.q(x) != 2 * ((z @ x) % 2):\n                return False\n        return True\n```\n\n----------------------------------------\n\nTITLE: Creating Before and After Characterization Dataframe in Cirq\nDESCRIPTION: This snippet demonstrates how to create a dataframe comparing fidelities before and after the characterization process.  It utilizes the `before_and_after_characterization` function from `cirq.experiments.xeb_fitting`. The inputs are a list of fidelities (`fids`) and the `characterization_result` from the XEB fitting process.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.experiments.xeb_fitting import before_and_after_characterization\nbefore_after_df = before_and_after_characterization(fids, characterization_result)\nbefore_after_df\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries (Cirq, Quimb)\nDESCRIPTION: This snippet imports necessary libraries such as cirq for quantum circuit creation and simulation, numpy for numerical operations, and quimb for tensor network manipulation. It attempts to import cirq and quimb, installing them if they are not already present in the environment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Cirq-to-Tensor-Networks.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport importlib.util\n\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n\ntry:\n    import quimb\nexcept ImportError:\n    print(\"installing cirq-core[contrib]...\")\n    !pip install --quiet 'cirq-core[contrib]'\n    print(\"installed cirq-core[contrib].\")\n```\n\n----------------------------------------\n\nTITLE: Installing System Dependencies via Apt\nDESCRIPTION: This command installs system dependencies required for Cirq development using the apt package manager. It reads package names from two text files and installs them with sudo. It requires a Debian-based system with apt and root privileges.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncat apt-system-requirements.txt dev_tools/conf/apt-list-dev-tools.txt | xargs sudo apt-get install --yes\n```\n\n----------------------------------------\n\nTITLE: Initializing Quantum Circuit\nDESCRIPTION: This snippet seems to be related to initializing or defining a quantum circuit within Cirq. It might involve setting up qubits or defining the overall structure of the circuit. The obfuscated nature makes precise determination difficult.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_2\n\nLANGUAGE: Unidentified\nCODE:\n```\n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\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq in Python\nDESCRIPTION: This code snippet attempts to import the `cirq` library. If the import fails (due to the library not being installed), it uses `pip` to install Cirq and then prints a confirmation message. This ensures that the notebook can run even if Cirq is not already installed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Circuit Creation and Display in Python\nDESCRIPTION: This code creates a sample benchmark circuit using the `create_benchmark_circuit` function with specific qubits, ISWAP gates, cycles, and a seed. It then prints the generated circuit to the console, providing a visual representation of the quantum operations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Create an example circuit.\"\"\"\nqubits = cirq.GridQubit.rect(2, 3)  # [cirq.GridQubit(x, y) for (x, y) in [(3, 2), (4, 2), (4, 1), (5, 1), (6, 1), (6, 2), (5, 2)]]\ncircuit = create_benchmark_circuit(qubits, twoq_gate=cirq.ISWAP, cycles=3, seed=1)\n\nprint(\"Example benchmark circuit:\\n\")\ncircuit\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq Contrib Dependencies\nDESCRIPTION: This snippet shows how to install optional dependencies for features in the `cirq.contrib` module. These dependencies are not required for basic Cirq functionality, but are needed for certain contributed features.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/install.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython -m pip install 'cirq-core[contrib]'\n```\n\n----------------------------------------\n\nTITLE: Importing contrib modules in test code (Python)\nDESCRIPTION: This snippet illustrates importing modules within the `contrib` directory for test code, emphasizing the use of the highest possible level for imports when dealing with code outside the core framework. It clarifies import style for non-core parts of the Cirq library during testing.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/style.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nimport cirq\nfrom cirq import contrib\ncontrib.circuit_to_latex_using_qcircuit(cirq.Circuit())\n```\n\n----------------------------------------\n\nTITLE: Producing PyPI Artifacts using produce-package.sh\nDESCRIPTION: Demonstrates how to create PyPI artifacts using the `produce-package.sh` script. This script generates the necessary files for uploading the package to PyPI.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\n./dev_tools/packaging/produce-package.sh dist\n```\n\n----------------------------------------\n\nTITLE: Declaring grpcio-tools Dependency for Proto Generation (Cirq-Google)\nDESCRIPTION: This line declares a dependency on the `grpcio-tools` package, which includes the `protoc` tool used for compiling `.proto` files into Python code. The version is pinned to `~=1.62.3`, meaning any version compatible with 1.62.3 but less than 1.63 is acceptable. This ensures compatibility with the gRPC framework used by cirq-google.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/dev_tools/requirements/deps/protos.txt#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ngrpcio-tools~=1.62.3\n```\n\n----------------------------------------\n\nTITLE: Authenticate to Google Cloud in Colab\nDESCRIPTION: This snippet authenticates your Google Colab session with your Google Cloud account, allowing you to access Google Cloud services from within the Colab environment. It uses the `google.colab.auth` module.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/google/engine.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom google.colab import auth\nauth.authenticate_user(clear_output=False)\n```\n\n----------------------------------------\n\nTITLE: Flattening with Sweep - Python\nDESCRIPTION: This shows a simplified method of flattening the circuit and producing the updated sweep using `cirq.flatten_with_sweep`.  The result is the same as flattening them separately and then transforming the sweep.  It simplifies the calling.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nc_flat, new_sweep = cirq.flatten_with_sweep(circuit, sweep)\nprint(c_flat)\nprint(new_sweep)\n```\n\n----------------------------------------\n\nTITLE: Estimating Tensor Network Contraction Cost\nDESCRIPTION: This code determines the optimal contraction path for the tensor network and obtains path information, which is then used to estimate the computational cost (number of floating point operations) and memory requirements for the contraction. It calls the `contract` method on the tensor network with `get='path-info'` to get the path information.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Contract-a-Grid-Circuit.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\npath_info = tn.contract(get='path-info')\n```\n\n----------------------------------------\n\nTITLE: Push Changes to Fork - Git\nDESCRIPTION: This command pushes the changes from the local feature branch (`new_branch_name`) to the forked repository on GitHub.  `origin` refers to the remote repository where the changes will be pushed. This makes the changes available for creating a pull request.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngit push origin new_branch_name\n```\n\n----------------------------------------\n\nTITLE: Replace Version in Modules\nDESCRIPTION: This python script uses `dev_tools/modules.py` to replace the old version string with the new version string within the project. The changes are then staged, committed, and pushed to the origin.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/release.md#_snippet_5\n\nLANGUAGE: Bash\nCODE:\n```\npython dev_tools/modules.py replace_version --old ${VER}.dev0 --new ${VER}\ngit add .\ngit commit -m \"Removing ${VER}.dev0 -> ${VER}\"\ngit push origin \"v${VER}-dev\"\n```\n\n----------------------------------------\n\nTITLE: Defining Symmetric Two-Qubit Targets\nDESCRIPTION: This section defines valid two-qubit target pairs for operations, specifying their connectivity. The 'target_ordering: SYMMETRIC' indicates that the order of qubits within a target pair does not matter (i.e., applying a gate between qubits A and B is equivalent to applying it between B and A). Each 'targets' entry lists the IDs of the two qubits involved in the interaction.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-google/cirq_google/devices/specifications/weber_2021_12_10_device_spec_for_grid_device.proto.txt#_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nvalid_targets {\n  name: \"2_qubit_targets\"\n  target_ordering: SYMMETRIC\n  targets {\n    ids: \"0_5\"\n    ids: \"0_6\"\n  }\n  targets {\n    ids: \"0_5\"\n    ids: \"1_5\"\n  }\n  targets {\n    ids: \"0_6\"\n    ids: \"1_6\"\n  }\n  targets {\n    ids: \"1_4\"\n    ids: \"1_5\"\n  }\n  targets {\n    ids: \"1_4\"\n    ids: \"2_4\"\n  }\n  targets {\n    ids: \"1_5\"\n    ids: \"1_6\"\n  }\n  targets {\n    ids: \"1_5\"\n    ids: \"2_5\"\n  }\n  targets {\n    ids: \"1_6\"\n    ids: \"1_7\"\n  }\n  targets {\n    ids: \"1_6\"\n    ids: \"2_6\"\n  }\n  targets {\n    ids: \"1_7\"\n    ids: \"2_7\"\n  }\n  targets {\n    ids: \"2_4\"\n    ids: \"2_5\"\n  }\n  targets {\n    ids: \"2_4\"\n    ids: \"3_4\"\n  }\n  targets {\n    ids: \"2_5\"\n    ids: \"2_6\"\n  }\n  targets {\n    ids: \"2_5\"\n    ids: \"3_5\"\n  }\n  targets {\n    ids: \"2_6\"\n    ids: \"2_7\"\n  }\n  targets {\n    ids: \"2_6\"\n    ids: \"3_6\"\n  }\n  targets {\n    ids: \"2_7\"\n    ids: \"2_8\"\n  }\n  targets {\n    ids: \"2_7\"\n    ids: \"3_7\"\n  }\n  targets {\n    ids: \"2_8\"\n    ids: \"3_8\"\n  }\n  targets {\n    ids: \"3_2\"\n    ids: \"3_3\"\n  }\n  targets {\n    ids: \"3_2\"\n    ids: \"4_2\"\n  }\n  targets {\n    ids: \"3_3\"\n    ids: \"3_4\"\n  }\n  targets {\n    ids: \"3_3\"\n    ids: \"4_3\"\n  }\n  targets {\n    ids: \"3_4\"\n    ids: \"3_5\"\n  }\n  targets {\n    ids: \"3_4\"\n    ids: \"4_4\"\n  }\n  targets {\n    ids: \"3_5\"\n    ids: \"3_6\"\n  }\n  targets {\n    ids: \"3_5\"\n    ids: \"4_5\"\n  }\n  targets {\n    ids: \"3_6\"\n    ids: \"3_7\"\n  }\n  targets {\n    ids: \"3_6\"\n    ids: \"4_6\"\n  }\n  targets {\n    ids: \"3_7\"\n    ids: \"3_8\"\n  }\n  targets {\n    ids: \"3_7\"\n    ids: \"4_7\"\n  }\n  targets {\n    ids: \"3_8\"\n    ids: \"3_9\"\n  }\n  targets {\n    ids: \"3_8\"\n    ids: \"4_8\"\n  }\n  targets {\n    ids: \"3_9\"\n    ids: \"4_9\"\n  }\n  targets {\n    ids: \"4_1\"\n    ids: \"4_2\"\n  }\n  targets {\n    ids: \"4_1\"\n    ids: \"5_1\"\n  }\n  targets {\n    ids: \"4_2\"\n    ids: \"4_3\"\n  }\n  targets {\n    ids: \"4_2\"\n    ids: \"5_2\"\n  }\n  targets {\n    ids: \"4_3\"\n    ids: \"4_4\"\n  }\n  targets {\n    ids: \"4_3\"\n    ids: \"5_3\"\n  }\n  targets {\n    ids: \"4_4\"\n    ids: \"4_5\"\n  }\n  targets {\n    ids: \"4_4\"\n    ids: \"5_4\"\n  }\n  targets {\n    ids: \"4_5\"\n    ids: \"4_6\"\n  }\n  targets {\n    ids: \"4_5\"\n    ids: \"5_5\"\n  }\n  targets {\n    ids: \"4_6\"\n    ids: \"4_7\"\n  }\n  targets {\n    ids: \"4_6\"\n    ids: \"5_6\"\n  }\n  targets {\n    ids: \"4_7\"\n    ids: \"4_8\"\n  }\n  targets {\n    ids: \"4_7\"\n    ids: \"5_7\"\n  }\n  targets {\n    ids: \"4_8\"\n    ids: \"4_9\"\n  }\n  targets {\n    ids: \"4_8\"\n    ids: \"5_8\"\n  }\n  targets {\n    ids: \"5_0\"\n    ids: \"5_1\"\n  }\n  targets {\n    ids: \"5_1\"\n    ids: \"5_2\"\n  }\n  targets {\n    ids: \"5_1\"\n    ids: \"6_1\"\n  }\n  targets {\n    ids: \"5_2\"\n    ids: \"5_3\"\n  }\n  targets {\n    ids: \"5_2\"\n    ids: \"6_2\"\n  }\n  targets {\n    ids: \"5_3\"\n    ids: \"5_4\"\n  }\n  targets {\n    ids: \"5_3\"\n    ids: \"6_3\"\n  }\n  targets {\n    ids: \"5_4\"\n    ids: \"5_5\"\n  }\n  targets {\n    ids: \"5_4\"\n    ids: \"6_4\"\n  }\n  targets {\n    ids: \"5_5\"\n    ids: \"5_6\"\n  }\n  targets {\n    ids: \"5_5\"\n    ids: \"6_5\"\n  }\n  targets {\n    ids: \"5_6\"\n    ids: \"5_7\"\n  }\n  targets {\n    ids: \"5_6\"\n    ids: \"6_6\"\n  }\n  targets {\n    ids: \"5_7\"\n    ids: \"5_8\"\n  }\n  targets {\n    ids: \"5_7\"\n    ids: \"6_7\"\n  }\n  targets {\n    ids: \"6_1\"\n    ids: \"6_2\"\n  }\n  targets {\n    ids: \"6_2\"\n    ids: \"6_3\"\n  }\n  targets {\n    ids: \"6_2\"\n    ids: \"7_2\"\n  }\n  targets {\n    ids: \"6_3\"\n    ids: \"6_4\"\n  }\n  targets {\n    ids: \"6_3\"\n    ids: \"7_3\"\n  }\n  targets {\n    ids: \"6_4\"\n    ids: \"6_5\"\n  }\n  targets {\n    ids: \"6_4\"\n    ids: \"7_4\"\n  }\n  targets {\n    ids: \"6_5\"\n    ids: \"6_6\"\n  }\n  targets {\n    ids: \"6_5\"\n    ids: \"7_5\"\n  }\n  targets {\n    ids: \"6_6\"\n    ids: \"6_7\"\n  }\n  targets {\n    ids: \"6_6\"\n    ids: \"7_6\"\n  }\n  targets {\n    ids: \"7_2\"\n    ids: \"7_3\"\n  }\n  targets {\n    ids: \"7_3\"\n    ids: \"7_4\"\n  }\n  targets {\n    ids: \"7_3\"\n    ids: \"8_3\"\n  }\n  targets {\n    ids: \"7_4\"\n    ids: \"7_5\"\n  }\n  targets {\n    ids: \"7_4\"\n    ids: \"8_4\"\n  }\n  targets {\n    ids: \"7_5\"\n    ids: \"7_6\"\n  }\n  targets {\n    ids: \"7_5\"\n    ids: \"8_5\"\n  }\n  targets {\n    ids: \"8_3\"\n    ids: \"8_4\"\n  }\n  targets {\n    ids: \"8_4\"\n    ids: \"8_5\"\n  }\n  targets {\n    ids: \"8_4\"\n    ids: \"9_4\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing System Dependencies (MacOS)\nDESCRIPTION: This snippet shows how to install system dependencies on MacOS that pip cannot handle. In this specific case, it installs mactex to support PDF file writing.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/install.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbrew install --cask mactex\n```\n\n----------------------------------------\n\nTITLE: Import NumPy and Cirq\nDESCRIPTION: Imports the necessary libraries for numerical computation (NumPy) and quantum circuit design (Cirq). These libraries are fundamental for the implementation of the problem and its solution.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/hidden_linear_function.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Upload to Production PyPI\nDESCRIPTION: This bash script uploads the package(s) located in the `dist/` directory to the production PyPI server using `twine`. It requires the `CIRQ_PYPI_TOKEN` environment variable to be set for authentication.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/release.md#_snippet_14\n\nLANGUAGE: Bash\nCODE:\n```\ntwine upload --password=\"$CIRQ_PYPI_TOKEN\" \"dist/*\"\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq if not present in Python\nDESCRIPTION: This code snippet attempts to import the Cirq library. If it's not found, it installs Cirq using pip, suppressing output, and then imports it again. This ensures that Cirq is available for subsequent code execution. Dependencies: pip and internet access.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install cirq --quiet\n    import cirq\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Upload to Test PyPI\nDESCRIPTION: This bash script uploads the package(s) located in the `dist/` directory to the Test PyPI server using `twine`. It requires the `CIRQ_TEST_PYPI_TOKEN` environment variable to be set for authentication.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/release.md#_snippet_8\n\nLANGUAGE: Bash\nCODE:\n```\ntwine upload --repository-url=https://test.pypi.org/legacy/ \\\n  --password=\"$CIRQ_TEST_PYPI_TOKEN\" \"dist/*\"\n```\n\n----------------------------------------\n\nTITLE: License Header in Python\nDESCRIPTION: This code snippet represents the Apache 2.0 license header. It indicates the terms and conditions under which the code can be used, modified, and distributed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# @title Licensed under the Apache License, 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n```\n\n----------------------------------------\n\nTITLE: Looping Construct\nDESCRIPTION: Shows a `for` loop iterating over a range of numbers. This snippet exemplifies a basic looping construct to perform repetitive tasks in Python.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nfor i in range(10):\n    print(i)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Qubit Pair Heatmaps with Cirq and Matplotlib\nDESCRIPTION: This code snippet generates qubit pair heatmaps to visualize the by-cycle fidelity error using Matplotlib and Cirq. It iterates through the fitted fidelities and creates heatmaps representing the error for each qubit pair, plotting them on subplots.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(2, 2, figsize=(13, 13))\nfor fidelities, ax, title in zip(fitted_fidelities, axes.flat, noise_titles):\n    # pull out the by-layer/cycle fidelity and turn it into error with 1-fidelity.\n    heatmap_data = {\n        pair: (1.0 - layer_fid) for ((_, _, pair), layer_fid) in fidelities.layer_fid.items()\n    }\n    cirq.TwoQubitInteractionHeatmap(heatmap_data, vmin=0, vmax=0.025).plot(ax)\n\n    ax.set_title(title)\n\nfig.tight_layout()\nfig.show()\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq in Python\nDESCRIPTION: This snippet attempts to import the Cirq library. If Cirq is not installed, it installs it using pip and then imports it.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/variational_algorithm.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n    import cirq\n```\n\n----------------------------------------\n\nTITLE: Define pylatex Dependency\nDESCRIPTION: Specifies pylatex as a dependency with a version requirement approximately equal to 1.4. pylatex is a Python library for generating LaTeX documents, suggesting its usage for documentation or report generation within the contrib module.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/requirements.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\npylatex~=1.4\n```\n\n----------------------------------------\n\nTITLE: Plotting Coherent and Rescaled Fused Fidelities - Python\nDESCRIPTION: This code snippet plots the original and refit fidelities for both unscaled coherent error data and rescaled fused error data. It creates a figure with two subplots, sharing the y-axis, to compare the fidelities before and after the optimization process. The parameter `rescale` controls the data transformation for the fused error case, and it depends on the `matplotlib` library and the existence of `fitted_fidelities` and `result_fidelities` variables.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfig, axes = plt.subplots(1, 2, figsize=(18, 6.5), sharey=True)\nbefore_dfs = [fitted_fidelities[0], fitted_fidelities[3]]\nafter_dfs = [result_fidelities[0], result_fidelities[3]]\ntitles = [r'Unscaled Coherent', r'Rescaled Fused']\nfor before_df, after_df, ax, title, rescale in zip(\n    before_dfs, after_dfs, axes.flat, titles, [False, True]\n):\n    before_df.apply(\n        _p_gen(ax, color='green', label=r'Original Fidelities', rescale=rescale), axis=1\n    )\n    after_df.apply(_p_gen(ax, color='orange', label=r'Refit Fidelities', rescale=rescale), axis=1)\n    extras(ax, title)\n\nfig.tight_layout()\nfig.show()\n```\n\n----------------------------------------\n\nTITLE: Sympy Expression - Python\nDESCRIPTION: This snippet displays a Sympy expression involving cosine and exponentiation. It defines two Sympy symbols 'a' and 'b' and creates the expression cos(a)**b.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/params.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nprint(sympy.cos(sympy.Symbol(\"a\"))**sympy.Symbol(\"b\"))\n```\n\n----------------------------------------\n\nTITLE: Importing Seaborn for Data Visualization\nDESCRIPTION: This code imports the Seaborn library, which is commonly used for creating informative and aesthetically pleasing statistical graphics.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport seaborn as sns\n```\n\n----------------------------------------\n\nTITLE: Mapping LineTopology to GridQubits (Manual)\nDESCRIPTION: This snippet demonstrates manual mapping of a LineTopology to specific GridQubits on the SYC23 device. It creates a LineTopology and then explicitly defines a mapping from LineTopology node indices to GridQubits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/named_topologies.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ntopo = LineTopology(9)\n\ncirq.draw_placements(SYC23_GRAPH, topo.graph, [\n    {i: q for i, q in enumerate([\n        cirq.GridQubit(4, 1), cirq.GridQubit(4, 2), cirq.GridQubit(5, 2), \n        cirq.GridQubit(5, 3), cirq.GridQubit(6, 3), cirq.GridQubit(6, 4), \n        cirq.GridQubit(7, 4), cirq.GridQubit(7, 5), cirq.GridQubit(8, 5),                              \n    ])}\n], tilted=False)\n```\n\n----------------------------------------\n\nTITLE: Create Release Branch\nDESCRIPTION: This bash script creates a new branch named \"v${VER}-dev\" from the current HEAD. This isolates changes for the release.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/release.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\ngit checkout -b \"v${VER}-dev\"\n```\n\n----------------------------------------\n\nTITLE: Function Definition\nDESCRIPTION: Illustrates a basic function definition with arguments and a return type annotation. It showcases the structure and syntax for defining functions in Python, including parameter names, types, and the return type.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef my_function(arg1: int, arg2: str) -> bool:\n    return True\n```\n\n----------------------------------------\n\nTITLE: Creating a Two-Qubit Interaction Heatmap in Cirq\nDESCRIPTION: This snippet creates a `cirq.TwoQubitInteractionHeatmap` object with custom data mapping from tuples of `cirq.GridQubit` pairs to float values. It then generates a plot of the heatmap using Matplotlib and sets the annotation format and title.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/heatmaps.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntwo_qubit_interaction_heatmap = cirq.TwoQubitInteractionHeatmap({\n    (cirq.GridQubit(0, 0), cirq.GridQubit(0, 1)): 0.1,\n    (cirq.GridQubit(0, 1), cirq.GridQubit(0, 2)): 0.2,\n    (cirq.GridQubit(1, 0), cirq.GridQubit(0, 0)): 0.3,\n    (cirq.GridQubit(3, 3), cirq.GridQubit(3, 2)): 0.9,\n}, annotation_format=\"0.2f\", title = 'Example Two-Qubit Heatmap')\n\n_, ax = plt.subplots(figsize=(8, 8))\n_ = two_qubit_interaction_heatmap.plot(ax)\n```\n\n----------------------------------------\n\nTITLE: Declaring Python Package Requirements\nDESCRIPTION: This snippet declares the Python packages required for running and testing Cirq notebooks. It specifies version constraints for each package using the ~= operator (compatible release operator) and includes a reference to another requirements file.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/dev_tools/requirements/deps/notebook.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n-r ipython.txt\n\nnotebook~=7.0\n\nipykernel~=6.29\n\n# for executing notebooks in tests\npapermill~=2.6\n\n# for notebooks that do `pip install cirq-core[contrib]`\n-r ../../../cirq-core/cirq/contrib/requirements.txt\n\n# assumed to be part of colab\nseaborn~=0.12\n```\n\n----------------------------------------\n\nTITLE: Applying Quantum Operations to Qubits using Cirq in Python\nDESCRIPTION: This snippet likely represents the application of quantum gates or operations to specific qubits within a Cirq quantum circuit. This could involve using predefined gates or custom-defined operations to manipulate the quantum state. The precise details depend on the context of surrounding code.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nimport cirq\n# Code related to applying gates or operations to qubits\n# The specific gates and qubits are not clear without further analysis.\n```\n\n----------------------------------------\n\nTITLE: Plotting Original and Refit Circuit Fidelities - Python\nDESCRIPTION: This code snippet generates a figure with subplots to visualize original and refitted circuit fidelities by cycle. It utilizes `matplotlib` to plot the fidelities and exponential decay curves for each available dataset, comparing the original fidelities with the refitted fidelities after an optimization process. It depends on the `xeb_fitting` module, assumes the existence of `characterization_results`, `fitted_fidelities` and `noise_titles` variables.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/coherent_vs_incoherent_xeb.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfig, axes = plt.subplots(2, 2, figsize=(18, 13))\nresult_dfs = list(map(lambda x: x.fidelities_df, characterization_results))\nresult_fidelities = list(map(xeb_fitting.fit_exponential_decays, result_dfs))\nbefore_dfs = fitted_fidelities\nafter_dfs = result_fidelities\nfor before_df, after_df, ax, title in zip(before_dfs, after_dfs, axes.flat, noise_titles):\n    before_df.apply(_p_gen(ax, color='green', label=r'Original Fidelities'), axis=1)\n    after_df.apply(_p_gen(ax, color='orange', label=r'Refit Fidelities'), axis=1)\n    extras(ax, title)\n\nfig.tight_layout()\nfig.show()\n```\n\n----------------------------------------\n\nTITLE: Displaying Bloch Sphere in Jupyter with cirq-web\nDESCRIPTION: This Python code demonstrates how to display a 3D Bloch sphere visualization within a Jupyter notebook or Google Colab environment using the cirq-web module. It requires the cirq and cirq_web packages. It initializes a zero state, converts it to a valid state vector, creates a BlochSphere object, and then displays it using the `display` function, making the interactive visualization available directly in the notebook.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-web/README.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nfrom cirq_web import BlochSphere\n\n# Prepare a state\nzero_state = [1+0j, 0+0j]\nstate_vector = cirq.to_valid_state_vector(zero_state)\n\n# Create and display the Bloch sphere\nsphere = BlochSphere(state_vector=state_vector)\ndisplay(sphere)\n```\n\n----------------------------------------\n\nTITLE: Checking for mixture support\nDESCRIPTION: This code checks if the amplitude damping channel supports the `cirq.mixture` protocol. It uses `cirq.has_mixture` to determine if the channel has a `_mixture_` or `_unitary_` method defined, indicating whether it can be represented as a mixture of unitary operations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"The amplitude damping channel is an example of a channel without a mixture.\"\"\"\nchannel = cirq.amplitude_damp(0.1)\n\nif cirq.has_mixture(channel):\n    print(f\"Channel {channel} has a _mixture_ or _unitary_ method.\")\nelse:\n    print(f\"Channel {channel} does not have a _mixture_ or _unitary_ method.\")\n```\n\n----------------------------------------\n\nTITLE: Simulating Density Matrix in Cirq\nDESCRIPTION: This snippet simulates a quantum circuit and retrieves the final density matrix using the `DensityMatrixSimulator`. It demonstrates how to access the `final_density_matrix` attribute of the simulation result.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_72\n\nLANGUAGE: python\nCODE:\n```\nmatrix = simulator.simulate(circuit).final_density_matrix\nprint(f'Final density matrix:\\n{matrix}')\n```\n\n----------------------------------------\n\nTITLE: Fitting Exponential Decays to Fidelity Data\nDESCRIPTION: This snippet fits an exponential decay curve to the fidelity data using the `fit_exponential_decays` function from `cirq.experiments.xeb_fitting`. It adds a 'pair' column to the DataFrame before fitting the curve, then extracts the layer fidelity and its standard deviation from the fit results. The snippet assumes that `fids` and `e_depol` are defined previously. The fitted layer fidelity and a theoretical noise model fidelity are printed to the console.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/xeb_theory.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.experiments.xeb_fitting import fit_exponential_decays\n\n# Ordinarily, we'd use this function to fit curves for multiple pairs.\n# We add our qubit pair as a column.\nfids['pair'] = [(q0, q1)] * len(fids)\n\nfit_df = fit_exponential_decays(fids)\nfit_row = fit_df.iloc[0]\nprint(f\"Noise model fidelity: {(1-e_depol)**4:.3e}\")\nprint(f\"XEB layer fidelity:   {fit_row['layer_fid']:.3e} +- {fit_row['layer_fid_std']:.2e}\")\n```\n\n----------------------------------------\n\nTITLE: Webpack Development Server Configuration JavaScript\nDESCRIPTION: This snippet shows how to configure the `webpack-dev-server` within the `webpack.config.js` file.  It specifies the directory from which static files are served and the public URL for the development server. This configuration allows hot reloading and live updates during visualization development.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-web/cirq_ts/README.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nmodule.exports = {\n  ...\n  devServer: {\n    static: path.join(__dirname, 'dist'),\n    public: 'localhost:8080',\n  },\n  ...\n};\n```\n\n----------------------------------------\n\nTITLE: Example of multiplicative group modulo n in Python\nDESCRIPTION: This snippet demonstrates the usage of the `multiplicative_group` function. It sets n to 15, calls the function to compute the multiplicative group modulo 15, and prints the result to the console. This helps visualize the elements that form the multiplicative group for a specific modulus.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nn = 15\nprint(f\"The multiplicative group modulo n = {n} is:\")\nprint(multiplicative_group(n))\n```\n\n----------------------------------------\n\nTITLE: License Declaration Python\nDESCRIPTION: This code snippet declares the license under which the code is distributed, the Apache License 2.0.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/hidden_linear_function.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#@title Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n```\n\n----------------------------------------\n\nTITLE: License Header\nDESCRIPTION: This code block contains the Apache 2.0 license header, specifying the terms and conditions under which the code can be used, modified, and distributed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#@title Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n```\n\n----------------------------------------\n\nTITLE: No Code Snippets Found\nDESCRIPTION: No code snippets were found in the provided text.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_19\n\n\n\n----------------------------------------\n\nTITLE: Estimating PauliSum Observable Expectation Values in Cirq\nDESCRIPTION: Shows how to use `cirq.PauliSumCollector` to estimate the expectation value of a PauliSum observable. It demonstrates creating a collector, collecting samples, and estimating energy for different observables.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# A helper function to create a collector, collet, and estimate energy.\ndef show_energy(circuit, observable):\n    collector = cirq.PauliSumCollector(circuit=circuit, observable=observable, samples_per_term=100)\n    collector.collect(sampler=cirq.Simulator())\n    energy = collector.estimated_energy()\n    typrint(energy)\n\n\ncircuit = cirq.Circuit(cirq.H(a), cirq.CNOT(a, b))\nobservable = Za * Zb\nshow_energy(circuit, observable)\nobservable = 4 * Xa\nshow_energy(circuit, observable)\nobservable = Za * Zb + 4 * Xa\nshow_energy(circuit, observable)\n```\n\n----------------------------------------\n\nTITLE: Serialize/Deserialize Cirq Circuit to/from JSON in Python\nDESCRIPTION: This example serializes a simple Cirq circuit to a JSON string and then deserializes it back into a Cirq circuit. It showcases the usage of `cirq.to_json` to convert the circuit to JSON and `cirq.read_json` to load it back. The output prints both the serialized JSON string and the deserialized circuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/interop.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\n\n# Example circuit\ncircuit = cirq.Circuit(cirq.Z(cirq.GridQubit(1,1)))\n\n# Serialize to a JSON string\njson_string = cirq.to_json(circuit)\nprint('JSON string:')\nprint(json_string)\nprint()\n\n# Now, read back the string into a cirq object\n# cirq.read_json can also read from a file\nnew_circuit = cirq.read_json(json_text=json_string)\n\nprint(f'Deserialized object of type: {type(new_circuit)}:')\nprint(new_circuit)\n```\n\n----------------------------------------\n\nTITLE: Define equivalent noisy quantum circuits\nDESCRIPTION: Demonstrates the creation of two quantum circuits with equivalent behavior, incorporating noise via `bit_flip_mix` and `bit_flip` channels, along with Hadamard gates and measurement in the X-basis using Hadamard gates.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit(bit_flip_mix.on(q0), cirq.H(q0), x_meas.on(q0))\nequiv_circuit = cirq.Circuit(\n    cirq.bit_flip(0.1).on(q0),\n    cirq.H(q0),\n    # Measure in x-basis\n    cirq.H(q0),\n    cirq.measure(q0, key='x'),\n    cirq.H(q0),\n)\n```\n\n----------------------------------------\n\nTITLE: Simulating a Qutrit Circuit in Cirq\nDESCRIPTION: This example creates a circuit using the `QutritPlusGate` acting on a qutrit, simulates it using `cirq.Simulator`, and then verifies that the returned state is that of a qutrit by printing the `cirq.qid_shape` of the simulation result.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/qudits.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Create a circuit from the gate we defined above.\nq0 = cirq.LineQid(0, dimension=3)\ncircuit = cirq.Circuit(QutritPlusGate()(q0))\n\n# Run a simulation of this circuit.\nsim = cirq.Simulator()\nresult = sim.simulate(circuit)\n\n# Verify that the returned state is that of a qutrit.\nprint(cirq.qid_shape(result))\n```\n\n----------------------------------------\n\nTITLE: Simulating Deutsch's Algorithm with Cirq\nDESCRIPTION: This code snippet simulates the Deutsch's algorithm circuits defined previously using Cirq's simulator. It iterates through the oracles, runs the corresponding circuit 10 times, and prints the measurement results. This demonstrates how to use the Cirq simulator to verify the behavior of a quantum algorithm.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Simulate each of the circuits.\"\"\"\nsimulator = cirq.Simulator()\nfor key, oracle in oracles.items():\n    result = simulator.run(cirq.Circuit(deutsch_algorithm(oracle)), repetitions=10)\n    print(f'oracle: f_{key:<4} results: {result}')\n```\n\n----------------------------------------\n\nTITLE: Fetching from Upstream Remote\nDESCRIPTION: This command fetches branches and their commits from the 'upstream' remote repository. This updates the local git repository with the latest changes from the official Cirq repository. It requires git to be installed and the 'upstream' remote to be configured.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ngit fetch upstream\n```\n\n----------------------------------------\n\nTITLE: Creating Circuit with GridQubits\nDESCRIPTION: This snippet creates a quantum circuit using GridQubit. It defines qubits on a 2x2 grid and applies a series of CNOT gates between neighboring qubits. The circuit is then visualized using SVGCircuit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/svg/example.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nSVGCircuit(cirq.Circuit(\n    cirq.CNOT(cirq.GridQubit(0,0), cirq.GridQubit(0,1)),\n    cirq.CNOT(cirq.GridQubit(1,0), cirq.GridQubit(1,1)),\n    cirq.CNOT(cirq.GridQubit(0,0), cirq.GridQubit(1,0)),\n    cirq.CNOT(cirq.GridQubit(0,1), cirq.GridQubit(1,1)),\n    cirq.CNOT(cirq.GridQubit(0,0), cirq.GridQubit(0,1)),\n    cirq.CNOT(cirq.GridQubit(1,0), cirq.GridQubit(1,1)),\n    cirq.CNOT(cirq.GridQubit(0,0), cirq.GridQubit(1,0)),\n    cirq.CNOT(cirq.GridQubit(0,1), cirq.GridQubit(1,1)),\n))\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq with pip\nDESCRIPTION: This snippet attempts to import the cirq library. If cirq is not installed, it uses pip to install it and then imports it. It includes error handling for cases where cirq is not already present in the environment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/custom_transformers.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    import cirq\n\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq (if necessary)\nDESCRIPTION: This snippet checks if the Cirq library is installed. If not, it installs Cirq using pip and then imports it. This ensures the code can run even if Cirq is not already present in the environment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/classical_control.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    import cirq\n\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Plotting One-Qubit Gate Pauli Error in Cirq\nDESCRIPTION: This code snippet retrieves and plots the single-qubit Pauli error data for a specific gate (`cirq.PhasedXZGate`) from the noise properties.  It iterates through the `gate_pauli_errors` attribute of the `noise_props` object, filters for the specified gate type, and then generates a heatmap using `cirq.Heatmap` to visualize the Pauli error for each qubit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/hardware/qubit_picking.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nprint(f\"One qubit error data: gate_pauli_errors\")\nprint(f\"Supported Gates: {noise_props.single_qubit_gates()}\")\nfig, ax = plt.subplots(figsize=(10, 10))\ngate = cirq.PhasedXZGate\nmeasures = {\n    op_id.qubits: pauli_error\n    for op_id, pauli_error in noise_props.gate_pauli_errors.items()\n    if op_id.gate_type == gate\n}\nax.set_title(f\"{gate.__name__} Pauli error\")\n_ = cirq.Heatmap(measures).plot(ax)\nfig.show()\n```\n\n----------------------------------------\n\nTITLE: Routing with Advanced Options (Python)\nDESCRIPTION: This code routes the circuit using advanced options such as lookahead radius, tag inserted swaps and a hard-coded initial mapper to define the initial qubit placement. The routed circuit is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/routing_transformer.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nrouted_circuit = router(circuit, lookahead_radius = 5, tag_inserted_swaps=True, initial_mapper=hc_initial_mapper)\nprint(routed_circuit)\n```\n\n----------------------------------------\n\nTITLE: Deploying Triage Party with Skaffold\nDESCRIPTION: This command deploys the Triage Party application using Skaffold. It assumes that the `gcloud` CLI is configured to access the `cirq-infra` Kubernetes cluster in the `us-central1-a` zone. The Skaffold configuration is defined in `dev_tools/triage-party/skaffold.yaml`.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/dev_tools/triage-party/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngcloud container clusters get-credentials cirq-infra --zone us-central1-a\nskaffold run --force -f=dev_tools/triage-party/skaffold.yaml\n```\n\n----------------------------------------\n\nTITLE: Defining Xmon Gate Set in Cirq\nDESCRIPTION: This code defines the 'xmon' gate set within Cirq, comprising gates such as 'xy', 'z', 'xyz', 'cz', and 'meas'. Each gate has specific arguments, like 'half_turns' and 'phase_match' for 'cz'.  This represents a configuration for Xmon-based quantum hardware.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-google/cirq_google/devices/specifications/weber_2021_12_10_device_spec.proto.txt#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nvalid_gate_sets {\n  name: \"xmon\"\n  valid_gates {\n    id: \"xy\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"axis_half_turns\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"half_turns\"\n      type: FLOAT\n    }\n    gate_duration_picos: 25000\n  }\n  valid_gates {\n    id: \"z\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"half_turns\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"type\"\n      type: STRING\n    }\n  }\n  valid_gates {\n    id: \"xyz\"\n    number_of_qubits: 1\n    valid_args {\n      name: \"x_exponent\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"z_exponent\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"axis_phase_exponent\"\n      type: FLOAT\n    }\n    gate_duration_picos: 25000\n  }\n  valid_gates {\n    id: \"cz\"\n    number_of_qubits: 2\n    valid_args {\n      name: \"half_turns\"\n      type: FLOAT\n    }\n    valid_args {\n      name: \"phase_match\"\n      type: STRING\n    }\n    valid_targets: \"2_qubit_targets\"\n  }\n  valid_gates {\n    id: \"meas\"\n    valid_args {\n      name: \"key\"\n      type: STRING\n    }\n    valid_args {\n      name: \"invert_mask\"\n      type: REPEATED_BOOLEAN\n    }\n    gate_duration_picos: 4000000\n    valid_targets: \"meas_targets\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Colorbar Properties in Heatmap\nDESCRIPTION: This code demonstrates how to modify the colorbar properties of a `cirq.TwoQubitInteractionHeatmap`. It updates the plot to show the colorbar at the top, adjusting its size and padding, and enabling edges on the colorbar.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/heatmaps.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n_, ax = plt.subplots(figsize=(8, 8))\n_ = two_qubit_interaction_heatmap.plot(ax,\n                                       title = 'Heatmap with modified Colorbar',\n                                       plot_colorbar = True,\n                                       colorbar_position = 'top',\n                                       colorbar_size = '10%',\n                                       colorbar_pad = '10%',\n                                       colorbar_options = {\n                                           'drawedges' : True\n                                       })\n```\n\n----------------------------------------\n\nTITLE: Sweeping Parameters in a Cirq Circuit\nDESCRIPTION: This code snippet demonstrates how to perform a parameter sweep on a Cirq circuit. It defines a circuit with a symbolic parameter, creates a linear sweep of parameter values, simulates the circuit using the run_sweep() function, and then plots the results.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/basics.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\n# Perform an X gate with variable exponent\nq = cirq.GridQubit(1, 1)\ncircuit = cirq.Circuit(cirq.X(q) ** sympy.Symbol('t'), cirq.measure(q, key='m'))\n\n# Sweep exponent from zero (off) to one (on) and back to two (off)\nparam_sweep = cirq.Linspace('t', start=0, stop=2, length=200)\n\n# Simulate the sweep\ns = cirq.Simulator()\ntrials = s.run_sweep(circuit, param_sweep, repetitions=1000)\n\n# Plot all the results\nx_data = [trial.params['t'] for trial in trials]\ny_data = [trial.histogram(key='m')[1] / 1000.0 for trial in trials]\nplt.scatter('t', 'p', data={'t': x_data, 'p': y_data})\nplt.xlabel(\"trials\")\nplt.ylabel(\"frequency of qubit measured to be one\")\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq and Cirq-Google in Python\nDESCRIPTION: This code snippet attempts to import the Cirq and Cirq-Google libraries. If the import fails, it installs them using pip. This ensures that the required libraries are available before proceeding.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/colab.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\n    import cirq_google\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq-google\n    print(\"installed cirq.\")\n    import cirq\n    import cirq_google\n```\n\n----------------------------------------\n\nTITLE: Loading realistic noise models\nDESCRIPTION: Demonstrates how to load realistic noise models based on Google quantum hardware devices. It retrieves calibration data for a specific processor and converts it into noise properties for simulation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nimport cirq_google\n\nprocessor_id = \"rainbow\"  # or \"weber\"\n# Load the calibration data\ncal = cirq_google.engine.load_median_device_calibration(processor_id)\n# Turn calibration data into a noise properties object\nnoise_props = cirq_google.noise_properties_from_calibration(cal)\n```\n\n----------------------------------------\n\nTITLE: Creating Empty PauliStrings\nDESCRIPTION: This snippet demonstrates creating empty `cirq.PauliString` objects. It showcases that an empty `PauliString` is equivalent to the identity operation and that adding an identity operation to a `PauliString` does not change its qubits.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/pauli_observables.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# An empty PauliString\ntyprint(cirq.PauliString())\n# An equivalently empty PauliString built from an identity operation\nIa = cirq.I(a)\ntyprint(cirq.PauliString(Ia))\nprint(cirq.PauliString() == cirq.PauliString(Ia))\n# cirq.I is a PauliString.\ntyprint(Ia)\nprint(issubclass(Ia.__class__, cirq.PauliString))\n# cirq.I has qubits, but a PauliString drops qubits that are identity.\nprint(Ia.qubits)\nprint(cirq.PauliString(Ia).qubits)\n# Two consecutive Xa cancel to the identity and are dropped.\nprint(cirq.PauliString(Xa, Xa).qubits)\n```\n\n----------------------------------------\n\nTITLE: Deutsch-Jozsa Algorithm Circuit (Exercise)\nDESCRIPTION: This code provides a template for writing a quantum circuit to distinguish constant from balanced functions on two bits, as part of an exercise. It takes an oracle (a sequence of quantum operations) as input and should return a Cirq circuit that implements the Deutsch-Jozsa algorithm.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_40\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Exercise: Write a quantum circuit that can distinguish \nconstant from balanced functions on two bits.\n\"\"\"\n\n\ndef your_circuit(oracle):\n    # Your code here!\n    yield oracle\n    # Your code here!\n    yield cirq.measure(q2)\n```\n\n----------------------------------------\n\nTITLE: Single Qubit State Tomography - Python\nDESCRIPTION: This code demonstrates the use of `cirq.experiments` to perform single-qubit state tomography.  It creates a simple circuit applying Z and X gates to a qubit and then uses `cirq.experiments.single_qubit_state_tomography` to estimate the qubit's state. A simulator is used as the sampler, but this could point to real hardware.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_86\n\nLANGUAGE: python\nCODE:\n```\nqubit = cirq.LineQubit(0)\nresult = cirq.experiments.single_qubit_state_tomography(\n    sampler=cirq.Simulator(),  # In case of Google QCS or other hardware providers, sampler could point at real hardware.\n    qubit=qubit,\n    circuit=cirq.Circuit(cirq.Z(qubit), cirq.X(qubit)),\n    repetitions=1000,\n)\nresult.plot();\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq\nDESCRIPTION: This snippet attempts to import the cirq library. If the import fails, it installs cirq using pip and then prints a message indicating that cirq has been installed. This ensures that the code can run even if the cirq library is not already present in the environment.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n```\n\n----------------------------------------\n\nTITLE: Circuit Compilation with TransformerLogger\nDESCRIPTION: This code compiles a quantum circuit for the SqrtIswapTargetGateset. It also demonstrates the usage of the cirq.TransformerLogger to inspect the action of individual transformers during the compilation process.  The TransformerContext is used to pass the logger to the optimization function.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/transform/transformers.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ncontext = cirq.TransformerContext(logger=cirq.TransformerLogger())\ngateset = cirq.SqrtIswapTargetGateset()\nsqrt_iswap_circuit = cirq.optimize_for_target_gateset(circuit, gateset=gateset, context=context)\ncirq.testing.assert_circuits_with_terminal_measurements_are_equivalent(circuit, sqrt_iswap_circuit)\ncontext.logger.show()\n```\n\n----------------------------------------\n\nTITLE: Importing necessary libraries in Python\nDESCRIPTION: This snippet imports the necessary Python libraries for quantum circuit simulation and data visualization. It imports `cirq` for quantum circuit construction, `qsimcirq` for simulation, `matplotlib.pyplot` for plotting, `numpy` for numerical operations, and `sympy` for symbolic calculations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_utility_sim_4a.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport qsimcirq\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport sympy\n```\n\n----------------------------------------\n\nTITLE: Converting Circuit to Tensors\nDESCRIPTION: This snippet converts a Cirq quantum circuit into a tensor network representation using the `circuit_to_tensors` function from `cirq.contrib.quimb`. It generates tensors, qubit frontier information, and fix data for the tensor network. The tensor network is then created and visualized using Quimb. The `qubit_frontier` dictionary represents the time index for each qubit.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/cirq-core/cirq/contrib/quimb/Cirq-to-Tensor-Networks.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntensors, qubit_frontier, fix = ccq.circuit_to_tensors(circuit, qubits)\ntn = qtn.TensorNetwork(tensors)\nprint(qubit_frontier)\nfrom matplotlib import pyplot as plt\ntn.graph(fix=fix, color=['Q0', 'Q1', 'Q2'], figsize=(8,8))\n```\n\n----------------------------------------\n\nTITLE: QCS Object Retrieval in Python\nDESCRIPTION: This code retrieves Google Cloud Project ID and Processor ID from user input.  It then uses these IDs to fetch QCS objects (device sampler) using `get_qcs_objects_for_notebook` from `cirq_google.engine.qcs_notebook`. This allows the notebook to interact with the Quantum Computing Service.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\n# The Google Cloud Project id to use.\nproject_id = '' #@param {type:\"string\"}\nprocessor_id = \"\" #@param {type:\"string\"}\n\nfrom cirq_google.engine.qcs_notebook import get_qcs_objects_for_notebook\ndevice_sampler = get_qcs_objects_for_notebook(project_id, processor_id)\n```\n\n----------------------------------------\n\nTITLE: InsertionNoiseModel Example in Cirq\nDESCRIPTION: This code showcases the usage of `InsertionNoiseModel` to insert noise operations after specific gates in a Cirq circuit based on their identifiers. It applies bit flip noise after each X gate.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/representing_noise.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.devices import InsertionNoiseModel\n\nq0 = cirq.LineQubit(0)\ncircuit = cirq.Circuit(\n    cirq.I(q0),\n    cirq.X(q0),\n    cirq.measure(q0, key='result'),\n)\n# Apply bitflip noise after each X gate.\ntarget_op = cirq.OpIdentifier(cirq.XPowGate, q0)\ninsert_op = cirq.bit_flip(p=0.2).on(q0)\nnoise_model = InsertionNoiseModel(\n    ops_added={target_op: insert_op},\n    require_physical_tag=False,  # For use outside calibration-to-noise\n)\nnoisy_circuit = circuit.with_noise(noise_model)\nprint(noisy_circuit)\nresult = cirq.Simulator(seed=0).run(noisy_circuit, repetitions=1000)\nprint(result.histogram(key='result'))\n```\n\n----------------------------------------\n\nTITLE: Importing Modules in Normal Cirq Code (Python)\nDESCRIPTION: This code snippet demonstrates the preferred way of importing modules in Cirq's main implementation code. It favors importing the full module to aid mocking during tests. It shows the preferred and less preferred methods of importing modules in Cirq.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/style.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom cirq import ops\nqubit = ops.NamedQubit('a')\n```\n\n----------------------------------------\n\nTITLE: Sampling 2Q XEB Circuits using Cirq\nDESCRIPTION: This snippet uses the `cirq.experiments.xeb_sampling.sample_2q_xeb_circuits` function to sample the generated circuits at different cycle depths using the defined sampler. The resulting sampled data is stored in a pandas DataFrame `sampled_df` and displayed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/isolated_xeb.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.experiments.xeb_sampling import sample_2q_xeb_circuits\nsampled_df = sample_2q_xeb_circuits(\n    sampler=sampler,\n    circuits=circuits,\n    cycle_depths=cycle_depths,\n    repetitions=10_000,\n)\nsampled_df\n```\n\n----------------------------------------\n\nTITLE: Installing Cirq and qsimcirq in Python\nDESCRIPTION: This snippet attempts to import the `cirq` and `qsimcirq` libraries. If they are not installed, it uses `pip` to install them quietly. It prints messages to the console to indicate the installation status.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/examples/advanced/quantum_utility_sim_4a.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import cirq\nexcept ImportError:\n    print(\"installing cirq...\")\n    !pip install --quiet cirq\n    print(\"installed cirq.\")\n\ntry:\n    import qsimcirq\nexcept ImportError:\n    print(\"installing qsimcirq...\")\n    !pip install --quiet qsimcirq\n    print(f\"installed qsimcirq.\")\n```\n\n----------------------------------------\n\nTITLE: Create channel with Gate.with_probability\nDESCRIPTION: Demonstrates a convenient method for creating a simple channel directly from a `cirq.Gate` using the `with_probability` method. This example creates a channel equivalent to `BitAndPhaseFlip` using the Y gate, simplifying the process of defining basic noisy channels.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nchannel = cirq.Y.with_probability(probability=0.05)\n```\n\n----------------------------------------\n\nTITLE: Configuring Git Blame\nDESCRIPTION: This command configures git to ignore large refactoring revisions when using git blame. This simplifies the blame output by hiding changes that only refactor code without changing functionality. Requires git to be installed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/development.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit config blame.ignoreRevsFile .git-blame-ignore-revs\n```\n\n----------------------------------------\n\nTITLE: Get Operation Duration on Sycamore Device\nDESCRIPTION: This snippet calculates the duration of an X gate on the Sycamore device by iterating through the gate durations metadata and checking if the given operation is within any gate family.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_79\n\nLANGUAGE: python\nCODE:\n```\nop = cirq.X.on(cirq.GridQubit(5, 5))\ngate_durations = cirq_google.Sycamore.metadata.gate_durations\nfor gate_family in gate_durations:\n    if op in gate_family:\n        print(gate_durations[gate_family])\n```\n\n----------------------------------------\n\nTITLE: Using run_sweep to Simulate Parameterized Circuit in Cirq\nDESCRIPTION: This code demonstrates simulating a parameterized circuit using `cirq.run_sweep`. It defines a list of `ParamResolver`s, adds measurements to the circuit, and then runs the simulation with the defined parameters, printing the results for each set of parameters.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/start/intro.ipynb#_snippet_63\n\nLANGUAGE: python\nCODE:\n```\nnum_params = 5\nresolvers = [cirq.ParamResolver({'s': y / 8.0}) for y in range(num_params)]\n\n# Add measurements to the circuit.\ncircuit.append([cirq.measure(a), cirq.measure(b)])\n\n# Simulate the circuit using run_sweep.\nresults = simulator.run_sweep(program=circuit, params=resolvers, repetitions=10)\n\nfor i, result in enumerate(results):\n    print(f'params: {result.params.param_dict}\\n{result}\\n')\n```\n\n----------------------------------------\n\nTITLE: Appending More Operations to a Circuit in Cirq with Python\nDESCRIPTION: This snippet continues from the previous example, appending additional Hadamard and CZ gates to the existing circuit. This showcases how to build up a circuit incrementally by adding more operations.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/circuits.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ncircuit.append([cirq.H(q0), cirq.CZ(q1, q2)])\n\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Creating and Printing Cirq Operations in Python\nDESCRIPTION: This code snippet demonstrates how to create Cirq operations using named qubits and common gates (Hadamard, CNOT, and measurement). It initializes NamedQubit objects and then applies gates to these qubits, printing the resulting Operation objects. The snippet shows how to construct basic quantum operations in Cirq.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/build/gates.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# This examples uses named qubits to remain abstract.\n# However, we can also use LineQubits or GridQubits to specify a geometry\na = cirq.NamedQubit('a')\nb = cirq.NamedQubit('b')\nc = cirq.NamedQubit('c')\n\n# Example Operations, that correspond to the moments above\nprint(cirq.H(b))\nprint(cirq.CNOT(b, c))\nprint(cirq.CNOT(a, b))\nprint(cirq.H(a))\nprint(cirq.measure(a,b))\n```\n\n----------------------------------------\n\nTITLE: Define Phase Estimation Function in Python\nDESCRIPTION: This code defines a function `phase_estimation` that encapsulates the entire phase estimation algorithm. The function takes the phase `theta`, the number of bits `n_bits`, the number of repetitions `n_reps`, and an optional `prepare_eigenstate_gate` as input. It constructs the quantum circuit for phase estimation, simulates the circuit, and returns an array of theta estimates. This allows for easy experimentation with different parameters and eigenstates.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ndef phase_estimation(theta, n_bits, n_reps=10, prepare_eigenstate_gate=cirq.X):\n    \"\"\"Runs the phase estimate algorithm for unitary U=Z^{2θ} with n_bits qubits.\"\"\"\n    # Define qubit registers.\n    qubits = cirq.LineQubit.range(n_bits)\n    u_bit = cirq.NamedQubit('u')\n\n    # Define the unitary U.\n    U = cirq.Z ** (2 * theta)\n\n    # Your code here!\n    # ...\n    \n    # Gate to choose the initial state for the u_bit. Placing X here chooses the |1> state.\n    phase_estimator.insert(0, prepare_eigenstate_gate.on(u_bit))\n    \n    # You code here!\n    # theta_estimates = ...\n    \n    return theta_estimates\n```\n\n----------------------------------------\n\nTITLE: Using Reset Operation in Cirq (Python)\nDESCRIPTION: This code demonstrates the use of the `cirq.Reset` operation. It applies a bit flip channel to a qubit, then resets the qubit to the |0> state using `cirq.reset`.  Finally, it measures the qubit. The simulation runs 1000 times and prints the resulting histogram.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/representing_noise.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nq0 = cirq.LineQubit(0)\ncircuit = cirq.Circuit(\n    cirq.bit_flip(p=0.2).on(q0),\n    cirq.reset(q0),\n    cirq.measure(q0, key='result')\n)\nresult = cirq.Simulator(seed=0).run(circuit, repetitions=1000)\nprint(result.histogram(key='result'))\n```\n\n----------------------------------------\n\nTITLE: Comparing Moment Count in Cirq\nDESCRIPTION: This snippet calculates and prints the number of moments in the original circuit and the left-aligned circuit. This comparison helps demonstrate the effectiveness of the alignment in reducing the circuit's temporal depth.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/spin_echoes.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nprint(f\"Original circuit has {len(circuit)} moments.\")\nprint(f\"Aligned circuit has {len(left_aligned_circuit)} moments.\")\n```\n\n----------------------------------------\n\nTITLE: Check QFT Equality: Manual vs Built-in in Python\nDESCRIPTION: This snippet compares the unitary matrix of the manually created QFT (`qft`) and the built-in QFT (`qft_cirq`) to verify their equivalence. It uses `cirq.unitary` to obtain the unitary matrices and `np.testing.assert_allclose` to assert that the matrices are approximately equal. Requires the `numpy` library.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/textbook_algorithms.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Check equality of the 'manual' and 'built-in' QFTs.\"\"\"\nnp.testing.assert_allclose(cirq.unitary(qft), cirq.unitary(qft_cirq))\n```\n\n----------------------------------------\n\nTITLE: Correlation and Forrelation Calculation in Python\nDESCRIPTION: Defines two functions, `get_correlation` and `get_forrelation`, for calculating the classical correlation and forrelation between two numpy arrays. `get_correlation` computes the normalized dot product of two arrays. `get_forrelation` calculates the forrelation by first applying the `fourier_transform_over_z2` to the second array and then computing the normalized dot product with the first array.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef get_correlation(f: np.ndarray, g: np.ndarray) -> np.ndarray:\n    \"\"\"Returns the classical correlation between two 1-d numpy arrays.\"\"\"\n    return f.dot(g) / np.linalg.norm(f) / np.linalg.norm(g)\n\n\ndef get_forrelation(f: np.ndarray, g: np.ndarray) -> np.ndarray:\n    \"\"\"Returns the forrelation over Z^2 between two 1-d numpy arrays.\"\"\"\n    g_hat = fourier_transform_over_z2(g)\n    return f.dot(g_hat) / np.linalg.norm(f) / np.linalg.norm(g)\n```\n\n----------------------------------------\n\nTITLE: Executing Noisy and Pure Circuits\nDESCRIPTION: This code simulates the execution of the generated circuits with and without noise. It iterates through different `cycle_depths` and `circuits`, truncates each circuit to the current `cycle_depth`, simulates the truncated circuit using both a pure-state simulator (`pure_sim`) and a noisy density matrix simulator (`noisy_sim`), and records the resulting probabilities.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/xeb_theory.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\npure_sim = cirq.Simulator()\n\n# Pauli Error. If there is an error, it is either X, Y, or Z\n# with probability E_PAULI / 3\nE_PAULI = 5e-3\nnoisy_sim = cirq.DensityMatrixSimulator(noise=cirq.depolarize(E_PAULI))\n\n# These two qubit circuits have 2^2 = 4 probabilities\nDIM = 4\n\nrecords = []\nfor cycle_depth in cycle_depths:\n    for circuit_i, circuit in enumerate(circuits):\n        \n        # Truncate the long circuit to the requested cycle_depth\n        circuit_depth = cycle_depth * 2 + 1\n        assert circuit_depth <= len(circuit)\n        trunc_circuit = circuit[:circuit_depth]\n\n        # Pure-state simulation\n        psi = pure_sim.simulate(trunc_circuit).final_state_vector\n        pure_probs = np.abs(psi)**2\n\n        # Noisy execution\n        meas_circuit = trunc_circuit + cirq.measure(q0, q1)\n        sampled_inds = noisy_sim.sample(meas_circuit, repetitions=10_000).values[:,0]\n        sampled_probs = np.bincount(sampled_inds, minlength=DIM) / len(sampled_inds)\n\n        # Save the results\n        records += [{\n            'circuit_i': circuit_i,\n            'cycle_depth': cycle_depth,\n            'circuit_depth': circuit_depth,\n            'pure_probs': pure_probs,\n            'sampled_probs': sampled_probs,\n        }]\n        print('.', end='', flush=True)\n```\n\n----------------------------------------\n\nTITLE: Exponential Decay Fitting\nDESCRIPTION: This snippet defines a function `fit` to model the exponential decay of the survival probability and then uses `scipy.optimize.curve_fit` to fit this function to the experimental data for each qubit configuration. The fitting estimates the error per cycle for each configuration, which is then printed.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/echoes.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Fit an exponential decay to the collected data.\"\"\"\nfrom scipy.optimize import curve_fit\n\ndef fit(cycle, a, f):\n    return a * np.exp((f - 1.0) * cycle)\n\n\nfor i in range(len(qubit_sets)):\n    (a, f), _ = curve_fit(\n        fit,\n        xdata=cycle_values,\n        ydata=avg_probs[i],\n    )\n    print(f\"Error/cycle on qubit configuration {i}: {round((1 - f) * 100, 2)}%\")\n```\n\n----------------------------------------\n\nTITLE: Display Circuit and Measurement Outcomes in Cirq\nDESCRIPTION: This snippet demonstrates how to display a quantum circuit in Cirq and print the measurement outcomes after running the circuit. It showcases the use of `cirq.sample` to obtain measurement data.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/shor.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Display it.\nprint(\"Circuit:\\n\")\nprint(circ)\n\n# Print the measurement outcomes.\nprint(\"\\n\\nMeasurement outcomes:\\n\")\nprint(cirq.sample(circ, repetitions=5).data)\n```\n\n----------------------------------------\n\nTITLE: Fourier Checking Algorithm Circuit\nDESCRIPTION: This snippet defines the `fourier_checking_algorithm` function, which constructs the quantum circuit for the Fourier Checking algorithm using Cirq. It applies Hadamard gates, the `oracle` operation for functions `fs` and `gs`, another set of Hadamard gates, and finally measures the qubits. The function takes the qubits `qubits`, and the function arrays `fs`, and `gs` as input and returns a Cirq `Circuit` representing the quantum algorithm.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/experiments/fourier_checking.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndef fourier_checking_algorithm(qubits, fs, gs):\n    \"\"\"Returns the circuit for Fourier Checking algorithm given an input.\"\"\"\n    yield cirq.parallel_gate_op(cirq.H, *qubits)\n    yield oracle(fs, qubits)\n    yield cirq.parallel_gate_op(cirq.H, *qubits)\n    yield oracle(gs, qubits)\n    yield cirq.parallel_gate_op(cirq.H, *qubits)\n    yield cirq.measure(*qubits)\n```\n\n----------------------------------------\n\nTITLE: Density matrix simulation\nDESCRIPTION: Demonstrates simulating a noisy circuit using the `cirq.DensityMatrixSimulator`. The example creates a circuit with an X gate and an amplitude damping channel, simulates it, and then prints the resulting final density matrix.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/noisy_simulation.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# Get a circuit.\nqbit = cirq.GridQubit(0, 0)\ncircuit = cirq.Circuit(cirq.X(qbit), cirq.amplitude_damp(0.1).on(qbit))\n\n# Display it.\nprint(\"Simulating circuit:\")\nprint(circuit)\n\n# Simulate with the density matrix simulator.\ndsim = cirq.DensityMatrixSimulator()\nrho = dsim.simulate(circuit).final_density_matrix\n\n# Display the final density matrix.\nprint(\"\\nFinal density matrix:\")\nprint(rho)\n```\n\n----------------------------------------\n\nTITLE: Choosing a Processor ID for QVM\nDESCRIPTION: This snippet sets the `processor_id` variable to either \"rainbow\" or \"weber\", representing different Google quantum processors. This choice determines the hardware noise model used in the simulation.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/simulate/quantum_virtual_machine.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Choose a processor (\"rainbow\" or \"weber\")\nprocessor_id = \"weber\"\n```\n\n----------------------------------------\n\nTITLE: Connecting to QCS\nDESCRIPTION: This snippet connects to the Quantum Computing Service using the provided project ID and processor ID. It uses the `get_qcs_objects_for_notebook` function from `cirq_google.engine.qcs_notebook` to retrieve the device sampler, allowing the user to execute quantum circuits on the specified processor.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/tutorials/google/echoes.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# The Google Cloud Project id to use.\nproject_id = '' #@param {type:\"string\"}\nprocessor_id = \"\" #@param {type:\"string\"}\n\nfrom cirq_google.engine.qcs_notebook import get_qcs_objects_for_notebook\ndevice_sampler = get_qcs_objects_for_notebook(project_id, processor_id)\n```\n\n----------------------------------------\n\nTITLE: Register Resolver Cache (Python)\nDESCRIPTION: This Python snippet registers the resolver cache for JSON serialization in the `<top_level_package>/__init__.py` file. It imports the `_register_resolver` function from `cirq.protocols.json_serialization` and the `_class_resolver_dictionary` from the module's `json_resolver_cache.py`. It's crucial for enabling JSON serialization within the module.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/dev/modules.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Registers cirq_example's public classes for JSON serialization.\nfrom cirq.protocols.json_serialization import _register_resolver\nfrom cirq_example.json_resolver_cache import _class_resolver_dictionary\n_register_resolver(_class_resolver_dictionary)\n```\n\n----------------------------------------\n\nTITLE: Accessing Final Parameters after Characterization in Cirq\nDESCRIPTION: This snippet shows how to access the final parameters of the characterized phased FSim gate after running the characterization loop.  The `characterization_result` object stores the fitted parameters.  Dependencies include `characterize_phased_fsim_parameters_with_xeb_by_pair` and the dataframes used by this function.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ncharacterization_result.final_params\n```\n\n----------------------------------------\n\nTITLE: Creating a Multiprocessing Pool in Python\nDESCRIPTION: This code snippet creates a multiprocessing pool using `multiprocessing.get_context('spawn').Pool()`. This pool can be used to parallelize computationally intensive tasks, such as optimizing circuit parameters.\nSOURCE: https://github.com/quantumlib/cirq/blob/main/docs/noise/qcvv/parallel_xeb.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nimport multiprocessing\npool = multiprocessing.get_context('spawn').Pool()\n```"
  }
]