[
  {
    "owner": "opsani",
    "repo": "statesman",
    "content": "TITLE: Implementing a Process Lifecycle State Machine in Python with Statesman\nDESCRIPTION: A complete example of a process lifecycle state machine that manages a process from starting to termination. It demonstrates state definitions, event transitions, and state tracking with proper data modeling.\nSOURCE: https://github.com/opsani/statesman/blob/main/README.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional, List\nimport statesman\n\n\nclass ProcessLifecycle(statesman.StateMachine):\n    class States(statesman.StateEnum):\n        starting = \"Starting...\"\n        running = \"Running...\"\n        stopping = \"Stopping...\"\n        stopped = \"Terminated.\"\n\n    # Track state about the process we are running\n    command: Optional[str] = None\n    pid: Optional[int] = None\n    logs: List[str] = []\n\n    # initial state entry point\n    @statesman.event(None, States.starting)\n    async def start(self, command: str) -> None:\n        \"\"\"\"Start a process.\"\"\"\n        self.command = command\n        self.pid = 31337\n        self.logs.clear()  # Flush logs between runs\n\n    @statesman.event(source=States.starting, target=States.running)\n    async def run(self, transition: statesman.Transition) -> None:\n        \"\"\"Mark the process as running.\"\"\"\n        self.logs.append(f\"Process pid {self.pid} is now running (command=\\\"{self.command}\\\")\")\n\n    @statesman.event(source=States.running, target=States.stopping)\n    async def stop(self) -> None:\n        \"\"\"Stop a running process.\"\"\"\n        self.logs.append(f\"Shutting down pid {self.pid} (command=\\\"{self.command}\\\")\")\n\n    @statesman.event(source=States.stopping, target=States.stopped)\n    async def terminate(self) -> None:\n        \"\"\"Terminate a running process.\"\"\"\n        self.logs.append(f\"Terminated pid {self.pid} (\\\"{self.command}\\\")\")\n        self.command = None\n        self.pid = None\n\n    @statesman.enter_state(States.stopping)\n    async def _print_status(self) -> None:\n        print(\"Entering stopped status!\")\n\n    @statesman.after_event(\"run\")\n    async def _after_run(self) -> None:\n        print(\"running...\")\n\n    async def after_transition(self, transition: statesman.Transition) -> None:\n        if transition.event and transition.event.name == \"stop\":\n            await self.terminate()\n\n\nasync def _examples():\n    # Let's play.\n    state_machine = ProcessLifecycle()\n    await state_machine.start(\"ls -al\")\n    assert state_machine.command == \"ls -al\"\n    assert state_machine.pid == 31337\n    assert state_machine.state == ProcessLifecycle.States.starting\n\n    await state_machine.run()\n    assert state_machine.logs == ['Process pid 31337 is now running (command=\"ls -al\")']\n\n    await state_machine.stop()\n    assert state_machine.logs == [\n        'Process pid 31337 is now running (command=\"ls -al\")',\n        'Shutting down pid 31337 (command=\"ls -al\")',\n        'Terminated pid 31337 (\"ls -al\")',\n    ]\n\n    # Or start in a specific state\n    state_machine = ProcessLifecycle(state=ProcessLifecycle.States.running)\n\n    # Transition to a specific state\n    await state_machine.enter_state(ProcessLifecycle.States.stopping)\n\n    # Trigger an event\n    await state_machine.trigger_event(\"stop\", key=\"value\")\n```\n\n----------------------------------------\n\nTITLE: Defining and Triggering Events in Statesman\nDESCRIPTION: Shows how to define state transition events using the statesman.event decorator with source and target states. Demonstrates different ways to reference states including special sentinels like __any__ and __active__, and how to trigger events.\nSOURCE: https://github.com/opsani/statesman/blob/main/README.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport statesman\n\n\nclass StateMachine(statesman.StateMachine):\n    class States(statesman.StateEnum):\n        waiting = 'Waiting'\n        running = 'Running'\n        stopped = 'Stopped'\n        aborted = 'Aborted'\n\n    @statesman.event(None, States.waiting)\n    async def start(self) -> None:\n        ...\n\n    @statesman.event(States.waiting, States.running)\n    async def run(self) -> None:\n        ...\n\n    @statesman.event(States.running, States.stopped)\n    async def stop(self) -> None:\n        ...\n\n    @statesman.event(States.__any__, States.aborted)\n    async def abort(self) -> None:\n        ...\n\n    @statesman.event(\n        States.__any__,\n        States.__active__,\n        type=statesman.Transition.Types.self\n    )\n    async def check(self) -> None:\n        print(\"Exiting and reentering active state!\")\n\n\nasync def _example() -> None:\n    state_machine = await StateMachine.create()\n    await state_machine.trigger_event(\"start\")\n    await state_machine.run()\n    await state_machine.trigger_event(state_machine.stop)\n```\n\n----------------------------------------\n\nTITLE: Configuring Initial States in Statesman State Machines\nDESCRIPTION: Example showing different ways to define and set initial states in a Statesman state machine. This includes using the InitialState class, initializing with a specific state, and transitioning to initial states via events.\nSOURCE: https://github.com/opsani/statesman/blob/main/README.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport statesman\n\n\n# Describe the initial state with `statesman.InitialState`\nclass StateMachine(statesman.StateMachine):\n    class States(statesman.StateEnum):\n        starting = 'Starting...'\n        running = 'Running...'\n        stopping = 'Stopping...'\n        stopped = statesman.InitialState('Terminated.')\n\n    @statesman.event(None, States.starting)\n    def start(self) -> None:\n        ...\n\n\nasync def _example() -> None:\n    # Set at initialization time\n    state_machine = StateMachine(state=StateMachine.States.stopping)\n\n    # Enter a state directly\n    state_machine = StateMachine()\n    await state_machine.enter_state(StateMachine.States.running)\n\n    # Via an event\n    state_machine = StateMachine()\n    await state_machine.start()\n```\n\n----------------------------------------\n\nTITLE: State and Event Actions in Statesman\nDESCRIPTION: Demonstrates how to define and attach actions to states and events in a Statesman state machine. Shows different action types for states (entry, exit) and events (guard, before, on, after) and various ways to define them.\nSOURCE: https://github.com/opsani/statesman/blob/main/README.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport random\nimport statesman\n\n\nclass StateMachine(statesman.StateMachine):\n    class States(statesman.StateEnum):\n        starting = 'Starting...'\n        running = 'Running...'\n        stopping = 'Stopping...'\n        stopped = statesman.InitialState('Terminated.')\n\n    @statesman.event(States.stopped, States.starting)\n    async def start(self) -> None:\n        ...\n\n    @statesman.enter_state(States.starting)\n    async def _announce_start(self) -> None:\n        print(\"enter:starting\")\n\n    def _can_run(self) -> bool:\n        return False\n\n    @statesman.event(States.starting, States.running, guard=_can_run)\n    async def run(self) -> None:\n        ...\n\n    @statesman.event(States.running, States.stopping)\n    async def stop(self) -> None:\n        ...\n\n    @statesman.after_event(stop)\n    async def _announce_stop(self) -> None:\n        print(\"after:stop\")\n\n    @statesman.event(\n        States.stopping,\n        States.stopped,\n        guard=lambda: random.choice([True, False])\n    )\n    async def terminate(self) -> None:\n        ...\n```\n\n----------------------------------------\n\nTITLE: Passing Data to State Machine Transitions\nDESCRIPTION: Shows how to pass data to state machine transitions using typed arguments and variadic parameters. Demonstrates event decoration and transition method signatures with different parameter types.\nSOURCE: https://github.com/opsani/statesman/blob/main/README.md#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport statesman\n\nclass StateMachine(statesman.StateMachine):\n    class States(statesman.StateEnum):\n        starting = 'Starting...'\n        running = 'Running...'\n        stopping = 'Stopping...'\n        stopped = statesman.InitialState('Terminated.')\n\n    @statesman.event(States.stopped, States.starting)\n    async def start(self, process_name: str) -> None:\n        ...\n\n    @statesman.event(States.starting, States.running)\n    async def run(self, uid: int, gid: int) -> None:\n        ...\n\n    @statesman.event(States.running, States.stopping)\n    async def stop(self, *args, all: bool = False, **kwargs) -> None:\n        ...\n\nasync def _example() -> None:\n    state_machine = await StateMachine.create()\n    await state_machine.start(\"servox\")\n    await state_machine.run(0, 31337)\n    await state_machine.stop(\"one\", \"two\", all=True, this=\"That\")\n```\n\n----------------------------------------\n\nTITLE: Implementing State Machine History Tracking\nDESCRIPTION: Shows how to add transition history tracking to a state machine using the HistoryMixin class. Demonstrates state transitions and history access.\nSOURCE: https://github.com/opsani/statesman/blob/main/README.md#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nimport statesman\n\nclass StateMachine(statesman.HistoryMixin, statesman.StateMachine):\n    class States(statesman.StateEnum):\n        ready = statesman.InitialState(\"Ready\")\n        analyzing = \"Analyzing\"\n\n        awaiting_description = \"Awaiting Description\"\n        awaiting_measurement = \"Awaiting Measurement\"\n        awaiting_adjustment = \"Awaiting Adjustment\"\n\n        done = \"Done\"\n        failed = \"Failed\"\n\nasync def _example() -> None:\n    state_machine = StateMachine()\n    await state_machine.enter_state(StateMachine.States.analyzing)\n    await state_machine.enter_state(StateMachine.States.awaiting_measurement)\n    await state_machine.enter_state(StateMachine.States.done)\n    await state_machine.enter_state(StateMachine.States.failed)\n\n    print(f\"The history is: {state_machine.history}\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Sequential State Transitions\nDESCRIPTION: Demonstrates how to implement sequential state transitions using the SequencingMixin class. Shows defining transition sequences and executing them step by step.\nSOURCE: https://github.com/opsani/statesman/blob/main/README.md#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import List\nimport statesman\n\nclass StateMachine(statesman.SequencingMixin, statesman.StateMachine):\n    class States(statesman.StateEnum):\n        ready = statesman.InitialState(\"Ready\")\n        analyzing = \"Analyzing\"\n\n        awaiting_description = \"Awaiting Description\"\n        awaiting_measurement = \"Awaiting Measurement\"\n        awaiting_adjustment = \"Awaiting Adjustment\"\n\n        done = \"Done\"\n        failed = \"Failed\"\n\n    @statesman.event([States.ready, States.analyzing], States.awaiting_description)\n    async def request_description(self) -> None:\n        \"\"\"Request a Description of application state from the servo.\"\"\"\n        ...\n\n    @statesman.event([States.ready, States.analyzing], States.awaiting_measurement)\n    async def request_measurement(self, metrics: List[str]) -> None:\n        \"\"\"Request a Measurement from the servo.\"\"\"\n        ...\n\n    @statesman.event([States.ready, States.analyzing], States.awaiting_adjustment)\n    async def recommend_adjustments(self, adjustments: List[str]) -> None:\n        \"\"\"Recommend Adjustments to the Servo.\"\"\"\n        ...\n\nasync def _example() -> None:\n    state_machine = StateMachine()\n    state_machine.sequence(\n        state_machine.request_description(),\n        state_machine.request_measurement(metrics=[...]),\n        state_machine.recommend_adjustments([...]),\n        state_machine.request_measurement(metrics=[...]),\n        state_machine.recommend_adjustments([...]),\n    )\n\n    while True:\n        transition = state_machine.next_transition()\n        print(f\"Executed transition: {repr(transition)}\")\n        if not transition:\n            break\n```\n\n----------------------------------------\n\nTITLE: Configuring Guard Behavior in Python State Machine\nDESCRIPTION: Demonstrates how to configure guard callback behavior in a state machine using the guard_with configuration option. The example shows setting up states and configuring the guard to raise exceptions on failure.\nSOURCE: https://github.com/opsani/statesman/blob/main/README.md#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport statesman\n\nclass StateMachine(statesman.StateMachine):\n    class States(statesman.StateEnum):\n        starting = 'Starting...'\n        running = 'Running...'\n        stopping = 'Stopping...'\n        stopped = statesman.InitialState('Terminated.')\n\n    class Config:\n        guard_with = statesman.Guard.exception\n```\n\n----------------------------------------\n\nTITLE: Configuring Transition Return Values in Statesman\nDESCRIPTION: Demonstrates how to configure and use different return value types from state transitions. Shows how to specify return_type when triggering events or entering states and how the return values are affected.\nSOURCE: https://github.com/opsani/statesman/blob/main/README.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport statesman\n\n\nclass StateMachine(statesman.StateMachine):\n    class States(statesman.StateEnum):\n        starting = 'Starting'\n        running = 'Running'\n        stopping = 'Stopping'\n        stopped = 'Stopped'\n\n    @statesman.event(None, States.starting, return_type=bool)\n    async def start(self) -> int:\n        return 31337\n\n\nasync def _example() -> None:\n    state_machine = await StateMachine.create()\n    bool_result = await state_machine.trigger_event(\"start\")\n    int_result = await state_machine.start(return_type=object)\n    transition = await state_machine.enter_state(\n        StateMachine.States.stopped,\n        return_type=statesman.Transition\n    )\n    print(\n        f\"Return Values: state_machine={state_machine}\\n\"\n        f\"bool_result={bool_result}\\n\"\n        f\"int_result={int_result}\\n\"\n        f\"transition={transition}\"\n    )\n```\n\n----------------------------------------\n\nTITLE: Entering States Directly in Statesman\nDESCRIPTION: Shows how to directly enter states in a Statesman state machine using the enter_state method. States can be referenced by name or by State object instance, which triggers a transition between states.\nSOURCE: https://github.com/opsani/statesman/blob/main/README.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport statesman\n\n\nclass StateMachine(statesman.HistoryMixin, statesman.StateMachine):\n    class States(statesman.StateEnum):\n        first = \"1\"\n        second = \"2\"\n        third = \"3\"\n\n\nasync def _example() -> None:\n    state_machine = StateMachine()\n    await state_machine.enter_state(StateMachine.States.first)\n    await state_machine.enter_state(StateMachine.States.second)\n    await state_machine.enter_state(StateMachine.States.third)\n```\n\n----------------------------------------\n\nTITLE: Implementing Inheritable State Machine Callbacks\nDESCRIPTION: Demonstrates the implementation of inheritable transition lifecycle callbacks in a state machine. Shows method signatures for guard, before, on, and after transition hooks.\nSOURCE: https://github.com/opsani/statesman/blob/main/README.md#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport statesman\n\nclass InheritableStateMachine(statesman.StateMachine):\n    async def guard_transition(self, transition: statesman.Transition, *args, **kwargs) -> bool:\n        return True\n\n    async def before_transition(self, transition: statesman.Transition, *args, **kwargs) -> None:\n        ...\n\n    async def on_transition(self, transition: statesman.Transition, *args, **kwargs) -> None:\n        ...\n\n    async def after_transition(self, transition: statesman.Transition, *args, **kwargs) -> None:\n        ...\n```\n\n----------------------------------------\n\nTITLE: Introspecting State in Statesman State Machine\nDESCRIPTION: Demonstrates how to check and compare the state of a Statesman state machine. Shows comparing against StateEnum objects and string values.\nSOURCE: https://github.com/opsani/statesman/blob/main/README.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport statesman\n\n\nclass StateMachine(statesman.StateMachine):\n    class States(statesman.StateEnum):\n        starting = 'Starting...'\n        running = 'Running...'\n        stopping = 'Stopping...'\n        stopped = 'Terminated.'\n\n\nasync def _example() -> None:\n    state_machine = StateMachine(state=StateMachine.States.stopping)\n    state_machine.state == StateMachine.States.stopping  # => True\n    state_machine.state == \"stopping\"  # => True\n    state_machine.state == StateMachine.States.running  # => False\n    state_machine.state == \"stopped\"  # => False\n```\n\n----------------------------------------\n\nTITLE: Configuring State Entry Restrictions\nDESCRIPTION: Demonstrates how to configure state entry behavior to restrict when the enter_state method can be used. Shows configuration using the state_entry option.\nSOURCE: https://github.com/opsani/statesman/blob/main/README.md#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport statesman\n\nclass StateMachine(statesman.StateMachine):\n    class States(statesman.StateEnum):\n        starting = 'Starting...'\n        running = 'Running...'\n        stopping = 'Stopping...'\n        stopped = statesman.InitialState('Terminated.')\n\n    class Config:\n        state_entry = statesman.Entry.forbid\n```\n\n----------------------------------------\n\nTITLE: Async State Machine Initialization\nDESCRIPTION: Shows how to asynchronously initialize a state machine with predefined states using the create class method.\nSOURCE: https://github.com/opsani/statesman/blob/main/README.md#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport statesman\n\nclass States(statesman.StateEnum):\n    starting = 'Starting'\n    running = 'Running'\n    stopping = 'Stopping'\n    stopped = 'Stopped'\n\nasync def _example() -> None:\n    state_machine = await statesman.StateMachine.create(\n        states=statesman.State.from_enum(States)\n    )\n    print(f\"Initialized state machine: {repr(state_machine)}\")\n```"
  }
]