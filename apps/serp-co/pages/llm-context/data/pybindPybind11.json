[
  {
    "owner": "pybind",
    "repo": "pybind11",
    "content": "TITLE: Defining Python Module Entry Points with Pybind11 in C++\nDESCRIPTION: Demonstrates the transition from the deprecated PYBIND11_PLUGIN macro to the preferred PYBIND11_MODULE macro for creating Python module entry points using Pybind11. The snippet shows how to define a module and add functions with more modern syntax. Dependencies include pybind11 headers and a compatible Python development environment. The input is module and function definitions, and the output is a compiled Python extension module. This new macro improves code clarity and integration with Python.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/upgrade.rst#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// old\nPYBIND11_PLUGIN(example) {\n    py::module m(\"example\", \"documentation string\");\n\n    m.def(\"add\", [](int a, int b) { return a + b; });\n\n    return m.ptr();\n}\n\n// new\nPYBIND11_MODULE(example, m) {\n    m.doc() = \"documentation string\"; // optional\n\n    m.def(\"add\", [](int a, int b) { return a + b; });\n}\n```\n\n----------------------------------------\n\nTITLE: Including pybind11 and Declaring Namespace Alias (C++)\nDESCRIPTION: These two lines include the primary pybind11 header and create a namespace alias 'py' for simpler references in binding code. They are required at the top of all C++ source or header files that use pybind11 functionality. No parameters or outputs are involved, but pybind11/pybind11.h must be the first include as it transitively includes Python.h.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/basics.rst#_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include <pybind11/pybind11.h>\n\nnamespace py = pybind11;\n```\n\n----------------------------------------\n\nTITLE: Exposing Matrix Buffer Protocol with pybind11 - C++\nDESCRIPTION: This binding code exposes the Matrix class to Python as a buffer-compatible type using pybind11. The .def_buffer method provides a lambda returning py::buffer_info that describes the raw data, element size, memory layout, shape, and strides. Dependencies: pybind11 main library. Inputs: Matrix instance; Outputs: A Python buffer view. Allows zero-copy data sharing, for example with NumPy arrays. Requires linking with pybind11 and correct compilation options.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\npy::class_<Matrix>(m, \"Matrix\", py::buffer_protocol())\n   .def_buffer([](Matrix &m) -> py::buffer_info {\n        return py::buffer_info(\n            m.data(),                               /* Pointer to buffer */\n            sizeof(float),                          /* Size of one scalar */\n            py::format_descriptor<float>::format(), /* Python struct-style format descriptor */\n            2,                                      /* Number of dimensions */\n            { m.rows(), m.cols() },                 /* Buffer dimensions */\n            { sizeof(float) * m.cols(),             /* Strides (in bytes) for each index */\n              sizeof(float) }\n        );\n    });\n```\n\n----------------------------------------\n\nTITLE: Creating Python Extensions with setuptools and pybind11 Helpers\nDESCRIPTION: A Python setup.py example showing how to use pybind11's setup helpers to create extension modules. It demonstrates the use of Pybind11Extension to simplify extension module configuration.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom glob import glob\nfrom setuptools import setup\nfrom pybind11.setup_helpers import Pybind11Extension\n\next_modules = [\n    Pybind11Extension(\n        \"python_example\",\n        sorted(glob(\"src/*.cpp\")),  # Sort source files for reproducibility\n    ),\n]\n\nsetup(..., ext_modules=ext_modules)\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting a Simple C++ Function with pybind11 (C++)\nDESCRIPTION: This snippet defines a C++ function 'add' that takes two integers and returns their sum, then exposes it to Python as the module 'example' with a docstring using the PYBIND11_MODULE macro. Dependencies: pybind11 headers installed; compiled with C++11 support. Key parameters are the module name (example), and the add function. Input: two integers from Python; Output: sum as an integer. Limitation: implementation and binding are in the same file, not the norm for larger projects.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/basics.rst#_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <pybind11/pybind11.h>\n\nint add(int i, int j) {\n    return i + j;\n}\n\nPYBIND11_MODULE(example, m) {\n    m.doc() = \"pybind11 example plugin\"; // optional module docstring\n\n    m.def(\"add\", &add, \"A function that adds two numbers\");\n}\n```\n\n----------------------------------------\n\nTITLE: Building a pybind11 Extension Module with Modern CMake - CMake\nDESCRIPTION: This CMake script demonstrates how to set up and build a pybind11 extension module using interface targets for modularity and flexibility. It requires CMake 3.15 or newer, the pybind11 package (via find_package or add_subdirectory), and a C++ source file (main.cpp). The script creates a module target, links with pybind11 and various optimization targets, applies platform-specific strip/visibility properties, and uses pybind11's helper functions. Parameters include the project name, source files, and build type. The build is designed for portability with configurations for MSVC, Linux, and macOS. Constraints include the need to ensure correct compiler flags for coverage and code optimization.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_16\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15...4.0)\nproject(example LANGUAGES CXX)\n\nfind_package(pybind11 REQUIRED)  # or add_subdirectory(pybind11)\n\nadd_library(example MODULE main.cpp)\n\ntarget_link_libraries(example PRIVATE pybind11::module pybind11::lto pybind11::windows_extras)\n\npybind11_extension(example)\nif(NOT MSVC AND NOT ${CMAKE_BUILD_TYPE} MATCHES Debug|RelWithDebInfo)\n    # Strip unnecessary sections of the binary on Linux/macOS\n    pybind11_strip(example)\nendif()\n\nset_target_properties(example PROPERTIES CXX_VISIBILITY_PRESET \"hidden\"\n                                         CUDA_VISIBILITY_PRESET \"hidden\")\n```\n\n----------------------------------------\n\nTITLE: Preventing Argument Conversion in pybind11 Using noconvert()\nDESCRIPTION: Demonstrates how to use the .noconvert() method on py::arg to prevent automatic type conversion of function arguments. Shows the difference between functions that allow conversion (floats_preferred) and those that don't (floats_only).\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/functions.rst#_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nm.def(\"floats_only\", [](double f) { return 0.5 * f; }, py::arg(\"f\").noconvert());\nm.def(\"floats_preferred\", [](double f) { return 0.5 * f; }, py::arg(\"f\"));\n```\n\n----------------------------------------\n\nTITLE: Binding Polymorphic C++ Classes with Pybind11 (C++)\nDESCRIPTION: This code snippet demonstrates how to bind polymorphic C++ classes using pybind11.  It defines a base class `PolymorphicPet` with a virtual destructor and a derived class `PolymorphicDog` with a specific `bark` method. pybind11 automatically recognizes the polymorphism and allows downcasting in Python. It depends on the pybind11 library.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nstruct PolymorphicPet {\n    virtual ~PolymorphicPet() = default;\n};\n\nstruct PolymorphicDog : PolymorphicPet {\n    std::string bark() const { return \"woof!\"; }\n};\n\n// Same binding code\npy::class_<PolymorphicPet>(m, \"PolymorphicPet\");\npy::class_<PolymorphicDog, PolymorphicPet>(m, \"PolymorphicDog\")\n    .def(py::init<>())\n    .def(\"bark\", &PolymorphicDog::bark);\n\n// Again, return a base pointer to a derived instance\nm.def(\"pet_store2\", []() { return std::unique_ptr<PolymorphicPet>(new PolymorphicDog); });\n```\n\n----------------------------------------\n\nTITLE: Manually Building a pybind11 Extension Module on Linux - Bash\nDESCRIPTION: This Bash command manually compiles a C++ file into a shared extension module compatible with Python using pybind11. It assumes pybind11 is installed (pip or conda) and Python is available. The $(python3 -m pybind11 --includes) argument automatically retrieves compiler include paths. The resulting shared object’s name uses python3-config to get the correct extension suffix. Key flags: -O3 for optimization, -Wall for warnings, -shared for the shared object, -std=c++11 for C++ standard, and -fPIC for position independent code. No linker against libpython required; symbols are resolved at load time. Inputs: C++ source file (example.cpp). Output: Python extension module (.so).\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_18\n\nLANGUAGE: Bash\nCODE:\n```\nc++ -O3 -Wall -shared -std=c++11 -fPIC $(python3 -m pybind11 --includes) example.cpp -o example$(python3-config --extension-suffix)\n```\n\n----------------------------------------\n\nTITLE: Calling Python functions from C++ (C++)\nDESCRIPTION: This set of snippets demonstrates calling Python classes, functions, and methods from C++ using the `operator()` on a function or object obtained through pybind11. The first shows constructing a Python Decimal object. The second demonstrates using `os.makedirs`. The third shows using an obtained function from the result of a Python function call.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/object.rst#_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n// Construct a Python object of class Decimal\npy::object pi = Decimal(\"3.14159\");\n```\n\nLANGUAGE: cpp\nCODE:\n```\n// Use Python to make our directories\npy::object os = py::module_::import(\"os\");\npy::object makedirs = os.attr(\"makedirs\");\nmakedirs(\"/tmp/path/to/somewhere\");\n```\n\nLANGUAGE: cpp\nCODE:\n```\npy::function f = <...>;\npy::object result_py = f(1234, \"hello\", some_instance);\nMyClass &result = result_py.cast<MyClass>();\n```\n\n----------------------------------------\n\nTITLE: Casting between C++ and Python (C++)\nDESCRIPTION: This pair of code snippets illustrates how to cast C++ objects to Python objects and back using pybind11's `py::cast` and the `.cast<>()` method. The first part shows converting a C++ pointer (`MyClass *cls`) to a Python object (`py::object obj`). The second part shows converting a Python object (`py::object obj`) back to a C++ pointer (`MyClass *cls`). These are necessary for interoperation between C++ and Python.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/object.rst#_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nMyClass *cls = ...;\npy::object obj = py::cast(cls);\n```\n\nLANGUAGE: cpp\nCODE:\n```\npy::object obj = ...;\nMyClass *cls = obj.cast<MyClass *>();\n```\n\n----------------------------------------\n\nTITLE: Initializing Embedded Python Interpreter with pybind11 in C++\nDESCRIPTION: Demonstrates how to create a basic C++ executable embedding the Python interpreter using pybind11. It includes initializing the interpreter with the RAII-guarded ``scoped_interpreter`` object that ensures proper startup and shutdown of the interpreter. Key dependency is pybind11 with embedding support. The snippet shows minimal code to print a message from Python code with interpreter lifetime managed automatically.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/embedding.rst#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <pybind11/embed.h> // everything needed for embedding\nnamespace py = pybind11;\n\nint main() {\n    py::scoped_interpreter guard{}; // start the interpreter and keep it alive\n\n    py::print(\"Hello, World!\"); // use the Python API\n}\n```\n\n----------------------------------------\n\nTITLE: Catching Python Exceptions Thrown via `py::eval`\nDESCRIPTION: This example demonstrates how to catch a Python exception raised using `py::eval`.  It illustrates that when Python raises an exception during a call to `py::eval`, the C++ code catches a `py::error_already_set` exception. C++ exceptions like `py::value_error` are not automatically translated into Python exceptions when caught.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/exceptions.rst#_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\ntry {\n    py::eval(\"raise ValueError('The Ring')\");\n} catch (py::value_error &boromir) {\n    // Boromir never gets the ring\n    assert(false);\n} catch (py::error_already_set &frodo) {\n    // Frodo gets the ring\n    py::print(\"I will take the ring\");\n}\n\ntry {\n    // py::value_error is a request for pybind11 to raise a Python exception\n    throw py::value_error(\"The ball\");\n} catch (py::error_already_set &cat) {\n    // cat won't catch the ball since\n    // py::value_error is not a Python exception\n    assert(false);\n} catch (py::value_error &dog) {\n    // dog will catch the ball\n    py::print(\"Run Spot run\");\n    throw;  // Throw it again (pybind11 will raise ValueError)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing keep_alive Policy for List Append Method in C++\nDESCRIPTION: Shows how to use keep_alive policy to tie the lifetime of a newly added list element to its container, preventing the element from being garbage collected while the list exists.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/functions.rst#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\npy::class_<List>(m, \"List\")\n    .def(\"append\", &List::append, py::keep_alive<1, 2>());\n```\n\n----------------------------------------\n\nTITLE: Constructing a Matrix from a Python Buffer Using Eigen and pybind11 - C++\nDESCRIPTION: This example demonstrates a pybind11 custom constructor for an Eigen matrix type (MatrixXd) that initializes from a Python buffer object. It performs format and dimension checks, calculates memory strides, and maps the buffer data without copying, creating a new Eigen matrix from the result. Dependencies: Eigen, pybind11. Inputs: Python buffer (typically a NumPy array); Outputs: Eigen Matrix instance. Any incompatible input format or shape raises a runtime exception.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\ntypedef Eigen::MatrixXd Matrix;\n\ntypedef Matrix::Scalar Scalar;\nconstexpr bool rowMajor = Matrix::Flags & Eigen::RowMajorBit;\n\npy::class_<Matrix>(m, \"Matrix\", py::buffer_protocol())\n    .def(py::init([](py::buffer b) {\n        typedef Eigen::Stride<Eigen::Dynamic, Eigen::Dynamic> Strides;\n\n        /* Request a buffer descriptor from Python */\n        py::buffer_info info = b.request();\n\n        /* Some basic validation checks ... */\n        if (info.format != py::format_descriptor<Scalar>::format())\n            throw std::runtime_error(\"Incompatible format: expected a double array!\");\n\n        if (info.ndim != 2)\n            throw std::runtime_error(\"Incompatible buffer dimension!\");\n\n        auto strides = Strides(\n            info.strides[rowMajor ? 0 : 1] / (py::ssize_t)sizeof(Scalar),\n            info.strides[rowMajor ? 1 : 0] / (py::ssize_t)sizeof(Scalar));\n\n        auto map = Eigen::Map<Matrix, 0, Strides>(\n            static_cast<Scalar *>(info.ptr), info.shape[0], info.shape[1], strides);\n\n        return Matrix(map);\n    }));\n```\n\n----------------------------------------\n\nTITLE: Binding STL Containers using py::bind_vector and py::bind_map C++\nDESCRIPTION: pybind11 code demonstrating the use of `py::bind_vector` and `py::bind_map` from `pybind11/stl_bind.h`. These convenience functions automatically create Python classes for the specified opaque STL containers (`std::vector<int>` bound as \"VectorInt\", `std::map<std::string, double>` bound as \"MapStringDouble\"), providing comprehensive bindings that mimic native Python list and dictionary behavior.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/stl.rst#_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\n// later in binding code:\npy::bind_vector<std::vector<int>>(m, \"VectorInt\");\npy::bind_map<std::map<std::string, double>>(m, \"MapStringDouble\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Type Caster for Point2D\nDESCRIPTION: This C++ code implements the custom type caster for the `user_space::Point2D` type using the `pybind11::detail::type_caster` template. This code defines how to convert a `Point2D` instance into a Python tuple of floats and how to convert a Python sequence of floats into a `Point2D` instance. It handles the mapping between C++ and Python data structures. The `PYBIND11_TYPE_CASTER` macro is used to set up type hints.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/custom.rst#_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nnamespace pybind11 {\nnamespace detail {\n\ntemplate <>\nstruct type_caster<user_space::Point2D> {\n    // This macro inserts a lot of boilerplate code and sets the type hint.\n    // `io_name` is used to specify different type hints for arguments and return values.\n    // The signature of our negate function would then look like:\n    // `negate(Sequence[float]) -> tuple[float, float]`\n    PYBIND11_TYPE_CASTER(user_space::Point2D, io_name(\"Sequence[float]\", \"tuple[float, float]\"));\n\n    // C++ -> Python: convert `Point2D` to `tuple[float, float]`. The second and third arguments\n    // are used to indicate the return value policy and parent object (for\n    // return_value_policy::reference_internal) and are often ignored by custom casters.\n    // The return value should reflect the type hint specified by the second argument of `io_name`.\n    static handle\n    cast(const user_space::Point2D &number, return_value_policy /*policy*/, handle /*parent*/) {\n        return py::make_tuple(number.x, number.y).release();\n    }\n\n    // Python -> C++: convert a `PyObject` into a `Point2D` and return false upon failure. The\n    // second argument indicates whether implicit conversions should be allowed.\n    // The accepted types should reflect the type hint specified by the first argument of\n    // `io_name`.\n    bool load(handle src, bool /*convert*/) {\n        // Check if handle is a Sequence\n        if (!py::isinstance<py::sequence>(src)) {\n            return false;\n        }\n        auto seq = py::reinterpret_borrow<py::sequence>(src);\n        // Check if exactly two values are in the Sequence\n        if (seq.size() != 2) {\n            return false;\n        }\n        // Check if each element is either a float or an int\n        for (auto item : seq) {\n            if (!py::isinstance<py::float_>(item) && !py::isinstance<py::int_>(item)) {\n                return false;\n            }\n        }\n        value.x = seq[0].cast<double>();\n        value.y = seq[1].cast<double>();\n        return true;\n    }\n};\n\n} // namespace detail\n} // namespace pybind11\n\n// Bind the negate function\nPYBIND11_MODULE(docs_advanced_cast_custom, m) { m.def(\"negate\", user_space::negate); }\n```\n\n----------------------------------------\n\nTITLE: Initializing dict in pybind11 (C++)\nDESCRIPTION: This snippet demonstrates how to initialize a Python dictionary from within C++ using the pybind11 library. It utilizes the `py::dict` constructor and the `_a` literal from `pybind11::literals` to specify key-value pairs. The key is a string literal, and the values are `py::none()` and an integer.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/object.rst#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nusing namespace pybind11::literals; // to bring in the `_a` literal\npy::dict d(\"spam\"_a=py::none(), \"eggs\"_a=42);\n```\n\n----------------------------------------\n\nTITLE: Implementing Keyword-only Arguments in PyBind11\nDESCRIPTION: Demonstrates how to define Python keyword-only arguments in C++ bindings using the py::kw_only() marker between positional and keyword-only argument annotations.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/functions.rst#_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nm.def(\"f\", [](int a, int b) { /* ... */ },\n      py::arg(\"a\"), py::kw_only(), py::arg(\"b\"));\n```\n\n----------------------------------------\n\nTITLE: Implementing keep_alive Policy for Constructor in C++\nDESCRIPTION: Demonstrates how to use keep_alive policy in a constructor to ensure that a Patient object passed to a Nurse constructor remains alive as long as the Nurse object exists.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/functions.rst#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\npy::class_<Nurse>(m, \"Nurse\")\n    .def(py::init<Patient &>(), py::keep_alive<1, 2>());\n```\n\n----------------------------------------\n\nTITLE: Specializing pybind11 Type Caster for Boost Optional C++\nDESCRIPTION: Defines a custom `type_caster` specialization within the `pybind11::detail` namespace for `boost::optional<T>`. This allows pybind11 to automatically convert `boost::optional` types to and from Python objects, similar to `std::optional`. This code should be placed in a header file included in all translation units where automatic conversion is needed for `boost::optional`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/stl.rst#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// `boost::optional` as an example -- can be any `std::optional`-like container\nnamespace PYBIND11_NAMESPACE { namespace detail {\n    template <typename T>\n    struct type_caster<boost::optional<T>> : optional_caster<boost::optional<T>> {};\n}}\n```\n\n----------------------------------------\n\nTITLE: Binding Function with Default Arguments Using pybind11 (C++)\nDESCRIPTION: This exposes the add function to Python via pybind11, explicitly specifying default argument values using py::arg. Dependencies: pybind11 headers and a C++ function with default arguments. Input: integers with optional specification; Outputs: sum, with defaults of 1 and 2. Limitation: defaults must be provided in the binding code.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/basics.rst#_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"add\", &add, \"A function which adds two numbers\",\n      py::arg(\"i\") = 1, py::arg(\"j\") = 2);\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake to Build C++ Executable with Embedded Python Interpreter Using pybind11\nDESCRIPTION: Provides the minimal CMake configuration required to find pybind11 and link its embed component to the target executable. It specifies version requirements for CMake and adds the pybind11::embed target as a private library to the executable. This setup is essential for enabling pybind11 embedding features during compilation and linking.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/embedding.rst#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15...4.0)\nproject(example)\n\nfind_package(pybind11 REQUIRED)  # or `add_subdirectory(pybind11)`\n\nadd_executable(example main.cpp)\ntarget_link_libraries(example PRIVATE pybind11::embed)\n```\n\n----------------------------------------\n\nTITLE: Binding Overloaded Methods with Pybind11 (C++)\nDESCRIPTION: This code snippet shows how to bind overloaded C++ methods using pybind11, specifically the `set` method of the `Pet` class that takes either an integer or a string. It uses `static_cast` to disambiguate between the overloads or `py::overload_cast` if you have a C++14 compatible compiler. The resulting Python binding will have overloaded set methods. Relies on pybind11.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Pet {\n    Pet(const std::string &name, int age) : name(name), age(age) { }\n\n    void set(int age_) { age = age_; }\n    void set(const std::string &name_) { name = name_; }\n\n    std::string name;\n    int age;\n};\n\npy::class_<Pet>(m, \"Pet\")\n   .def(py::init<const std::string &, int>())\n   .def(\"set\", static_cast<void (Pet::*)(int)>(&Pet::set), \"Set the pet's age\")\n   .def(\"set\", static_cast<void (Pet::*)(const std::string &)>(&Pet::set), \"Set the pet's name\");\n```\n\n----------------------------------------\n\nTITLE: Defining Point2D Struct\nDESCRIPTION: This C++ snippet defines a simple struct named `Point2D` within the `user_space` namespace. The struct contains two double-precision floating-point members, `x` and `y`. It's a simple data structure to represent a 2D point.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/custom.rst#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nnamespace user_space {\n\nstruct Point2D {\n    double x;\n    double y;\n};\n\nPoint2D negate(const Point2D &point) { return Point2D{-point.x, -point.y}; }\n\n} // namespace user_space\n```\n\n----------------------------------------\n\nTITLE: Calling Python methods from C++ (C++)\nDESCRIPTION: This code provides examples of how to call Python methods from C++ via pybind11's `attr` accessors.  It demonstrates calling a bound method and creating and calling an unbound method.  The first example calls the `exp()` method on a `Decimal` object. The second example uses a loop with the `Decimal.attr(\"exp\")` method with each number from 0 to 4.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/object.rst#_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n// Calculate e^π in decimal\npy::object exp_pi = pi.attr(\"exp\")();\npy::print(py::str(exp_pi));\n```\n\nLANGUAGE: cpp\nCODE:\n```\npy::object decimal_exp = Decimal.attr(\"exp\");\n\n// Compute the e^n for n=0..4\nfor (int n = 0; n < 5; n++) {\n    py::print(decimal_exp(Decimal(n));\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Binding Conflict When Exposing External Classes Globally in Multiple pybind11 Modules in C++\nDESCRIPTION: This snippet illustrates the problematic scenario when two unrelated modules bind the same external C++ class globally (without py::module_local), causing an import-time conflict due to duplicate registrations of the same Python type. It includes examples of binding a pets::Pet class in two separate modules, each with different method bindings. This code highlights a common pitfall when integrating external libraries into multiple Python extension modules using pybind11 and motivates the use of module-local bindings to avoid such issues.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_31\n\nLANGUAGE: C++\nCODE:\n```\n// dogs.cpp\n\n// Binding for external library class:\npy::class_<pets::Pet>(m, \"Pet\")\n    .def(\"name\", &pets::Pet::name);\n\n// Binding for local extension class:\npy::class_<Dog, pets::Pet>(m, \"Dog\")\n    .def(py::init<std::string>());\n\n// cats.cpp\n\n// Binding for external library class:\npy::class_<pets::Pet>(m, \"Pet\")\n    .def(\"get_name\", &pets::Pet::name);\n\n// Binding for local extending class:\npy::class_<Cat, pets::Pet>(m, \"Cat\")\n    .def(py::init<std::string>());\n```\n\n----------------------------------------\n\nTITLE: Binding Factory Functions as Constructors in pybind11\nDESCRIPTION: Demonstrates binding a static factory function or lambda returning a new C++ object as a Python constructor. Supports creating instances from functions that return by value, pointer, or smart holder, enabling flexible object creation patterns.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_17\n\nLANGUAGE: C++\nCODE:\n```\nclass Example {\nprivate:\n    Example(int); // private constructor\npublic:\n    // Factory function:\n    static Example create(int a) { return Example(a); }\n};\n\npy::class_<Example>(m, \"Example\")\n    .def(py::init(&Example::create));\n```\n\nLANGUAGE: C++\nCODE:\n```\nclass Example {\nprivate:\n    Example(int); // private constructor\npublic:\n    // Factory function - returned by value:\n    static Example create(int a) { return Example(a); }\n\n    // These constructors are publicly callable:\n    Example(double);\n    Example(int, int);\n    Example(std::string);\n};\n\npy::class_<Example>(m, \"Example\")\n    // Bind the factory function as a constructor:\n    .def(py::init(&Example::create))\n    // Bind a lambda function returning a pointer wrapped in a holder:\n    .def(py::init([](std::string arg) {\n        return std::unique_ptr<Example>(new Example(arg));\n    }))\n    // Return a raw pointer:\n    .def(py::init([](int a, int b) { return new Example(a, b); }))\n    // You can mix the above with regular C++ constructor bindings as well:\n    .def(py::init<double>());\n```\n\n----------------------------------------\n\nTITLE: Executing Python Code in Embedded Interpreter Using pybind11 in C++\nDESCRIPTION: Shows usage of ``py::exec`` to run multi-line Python code inside an embedded interpreter. The example creates Python variables in a dict, formats a string with Python's .format method, and prints the message. It requires an active ``scoped_interpreter`` and demonstrates embedding both script execution and variable passing via Python code strings within C++.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/embedding.rst#_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include <pybind11/embed.h>\nnamespace py = pybind11;\n\nint main() {\n    py::scoped_interpreter guard{};\n\n    py::exec(R\"(\n        kwargs = dict(name=\"World\", number=42)\n        message = \"Hello, {name}! The answer is {number}\".format(**kwargs)\n        print(message)\n    )\");\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Exceptions in Python\nDESCRIPTION: This snippet demonstrates how to chain exceptions in Python, providing context for the C++ implementation.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/exceptions.rst#_snippet_10\n\nLANGUAGE: py\nCODE:\n```\ntry:\n    print(1 / 0)\nexcept Exception as exc:\n    raise RuntimeError(\"could not divide by zero\") from exc\n```\n\n----------------------------------------\n\nTITLE: Registering Global Exception Translator\nDESCRIPTION: This code snippet demonstrates how to register a global exception translator in pybind11 to handle `std::invalid_argument` exceptions. It registers a translator that sets a Python `ArgumentError` when `std::invalid_argument` is caught.  The order in which modules register these translators influences which translator will be applied.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/exceptions.rst#_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\npy::register_exception_translator([](std::exception_ptr p) {\n  try {\n      if (p) std::rethrow_exception(p);\n  } catch (const std::invalid_argument &e) {\n      py::set_error(PyExc_ArgumentError, \"module1 handled this\");\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Python Print Function in C++ with pybind11\nDESCRIPTION: This snippet demonstrates using the `py::print` function from pybind11 to write output to Python's `sys.stdout`. This ensures consistent output behavior when mixing C++ and Python code. The function accepts variable arguments and supports optional keyword arguments like `sep`, `end`, `file`, and `flush`, mirroring the behavior of Python's print function. Input is the values to be printed and any optional keyword arguments. Output is to stdout.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/utilities.rst#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\npy::print(1, 2.0, \"three\"); // 1 2.0 three\npy::print(1, 2.0, \"three\", \"sep\"_a=\"-\"); // 1-2.0-three\n\nauto args = py::make_tuple(\"unpacked\", true);\npy::print(\"->\", *args, \"end\"_a=\"<-\"); // -> unpacked True <-\n\n```\n\n----------------------------------------\n\nTITLE: Defining a pybind11 Class with Custom Constructors in C++\nDESCRIPTION: This snippet shows how to bind a C++ class 'Foo' using pybind11, including custom constructor definitions. Multiple return strategies are demonstrated, such as raw pointers, std::unique_ptr, or by-value construction. It provides the basic pattern for exposing C++ classes to Python.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/upgrade.rst#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\npy::class<Foo>(m, \"Foo\")\n    .def(py::init([](...) { // Note: no `self` argument\n        return new Foo(...); // return by raw pointer\n        // or: return std::make_unique<Foo>(...); // return by holder\n        // or: return Foo(...); // return by value (move constructor)\n    }));\n```\n\n----------------------------------------\n\nTITLE: Example of Inheritance Binding with C++ in pybind11\nDESCRIPTION: This code binds a base class `Pet` and a derived class `Dog` in pybind11, showing two methods: specifying the base class as a template parameter and referencing a previously bound class object. It illustrates how inheritance relationships are exposed and how objects behave with base and derived methods.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\npy::class_<Pet>(m, \"Pet\")\n   .def(py::init<const std::string &>)\n   .def_readwrite(\"name\", &Pet::name);\n\n// Method 1: via template parameter\npy::class_<Dog, Pet>(m, \"Dog\")\n    .def(py::init<const std::string &>)\n    .def(\"bark\", &Dog::bark);\n```\n\nLANGUAGE: C++\nCODE:\n```\n// Method 2: via class_ reference\npy::class_<Pet> pet(m, \"Pet\");\npet.def(py::init<const std::string &>())\n   .def_readwrite(\"name\", &Pet::name);\n\npy::class_<Dog>(m, \"Dog\", pet)\n    .def(py::init<const std::string &>)\n    .def(\"bark\", &Dog::bark);\n```\n\n----------------------------------------\n\nTITLE: Forced Initialization of Trampoline Classes via py::init_alias\nDESCRIPTION: Describes how to ensure that trampoline classes are always initialized when creating instances by replacing 'py::init' with 'py::init_alias'. This is useful for adding extra setup or interface features in the trampoline classes beyond virtual dispatch.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_15\n\n\n\n----------------------------------------\n\nTITLE: Configuration for meson-python with pyproject.toml\nDESCRIPTION: A pyproject.toml configuration for using meson-python as a build backend for pybind11 modules. This defines the build requirements and specifies meson-python as the build backend.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[build-system]\nrequires = [\"meson-python\", \"pybind11\"]\nbuild-backend = \"mesonpy\"\n```\n\n----------------------------------------\n\nTITLE: setuptools with C++ Standard Detection for pybind11\nDESCRIPTION: A setup.py configuration that automatically detects the highest supported C++ standard for pybind11 extensions. It uses the build_ext command override provided by pybind11's setup helpers.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom glob import glob\nfrom setuptools import setup\nfrom pybind11.setup_helpers import Pybind11Extension, build_ext\n\next_modules = [\n    Pybind11Extension(\n        \"python_example\",\n        sorted(glob(\"src/*.cpp\")),\n    ),\n]\n\nsetup(..., cmdclass={\"build_ext\": build_ext}, ext_modules=ext_modules)\n```\n\n----------------------------------------\n\nTITLE: Example with virtual function inheritance\nDESCRIPTION: This code shows a more complex inheritance example with a derived `Dog` class and methods `go()` and `name()`. It shows the correct ways to implement trampolines for both the base `Animal` and derived `Dog` classes, covering inheritance.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nclass Animal {\npublic:\n    virtual std::string go(int n_times) = 0;\n    virtual std::string name() { return \"unknown\"; }\n};\nclass Dog : public Animal {\npublic:\n    std::string go(int n_times) override {\n        std::string result;\n        for (int i=0; i<n_times; ++i)\n            result += bark() + \" \";\n        return result;\n    }\n    virtual std::string bark() { return \"woof!\"; }\n};\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Python Extension Module with pybind11_add_module in CMake\nDESCRIPTION: Function signature for pybind11_add_module that simplifies creating Python extension modules in CMake. This wrapper function handles Python-specific compiler and linker flags automatically.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\npybind11_add_module(<name> [MODULE | SHARED] [EXCLUDE_FROM_ALL]\n                    [NO_EXTRAS] [THIN_LTO] [OPT_SIZE] source1 [source2 ...])\n```\n\n----------------------------------------\n\nTITLE: Correct way to Bind Class Methods\nDESCRIPTION: Demonstrates that in the `py::class_` definition for Animal,  the method binding must point towards the C++ base class method, `Animal::go` and not the `PyAnimal::go`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\npy::class_<Animal, PyAnimal /* <--- trampoline */, py::smart_holder>(m, \"Animal\");\n    .def(py::init<>())\n    .def(\"go\", &Animal::go); /* <--- DO NOT USE &PyAnimal::go HERE */\n\n```\n\n----------------------------------------\n\nTITLE: Importing Python Modules in Embedded pybind11 Interpreter in C++\nDESCRIPTION: Shows how to import standard or local Python modules using ``py::module_::import`` within an embedded interpreter. Includes example importing the \"sys\" module and accessing its attributes, as well as importing a local Python file named calc.py with an add function, demonstrating calling and casting results back to C++ types.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/embedding.rst#_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\npy::module_ sys = py::module_::import(\"sys\");\npy::print(sys.attr(\"path\"));\n```\n\nLANGUAGE: cpp\nCODE:\n```\npy::module_ calc = py::module_::import(\"calc\");\npy::object result = calc.attr(\"add\")(1, 2);\nint n = result.cast<int>();\nassert(n == 3);\n```\n\n----------------------------------------\n\nTITLE: Converting Python List to C++ std::vector and Printing Elements Using pybind11\nDESCRIPTION: This C++ snippet illustrates how pybind11 converts a native Python list into a C++ std::vector<int> by copying the contents. The function accepts a const reference to the std::vector<int> container and prints each element on a new line. This represents a full data copy-based conversion from Python to C++. Requires standard C++ containers and pybind11 configuration for seamless container conversion.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/overview.rst#_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nvoid print_vector(const std::vector<int> &v) {\n    for (auto item : v)\n        std::cout << item << \"\\n\";\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Running pybind11 Test Cases on Linux/macOS (Bash)\nDESCRIPTION: These shell commands set up a build directory, configure the project using CMake, and invoke parallel compilation and test execution for pybind11 test cases. Required dependencies include cmake and python-dev/python3-dev on Linux, and only cmake on macOS. No input parameters are required; users must run these commands from the project root directory. Outputs include compiled binaries and test results visible in the terminal.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/basics.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmkdir build\ncd build\ncmake ..\nmake check -j 4\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running pybind11 Tests on Windows (Batch)\nDESCRIPTION: These batch commands create a build directory, configure the project with CMake, and build plus run the test target using Visual Studio 2017 or newer on Windows. Required dependencies are Visual Studio 2017+, Python, and CMake. No input parameters are needed, and the script builds a Visual Studio project and runs the test suite. Output is a compiled test binary and results in the command prompt.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/basics.rst#_snippet_1\n\nLANGUAGE: batch\nCODE:\n```\nmkdir build\ncd build\ncmake ..\ncmake --build . --config Release --target check\n```\n\n----------------------------------------\n\nTITLE: Registering Structured C++ Types for NumPy via PYBIND11_NUMPY_DTYPE - C++\nDESCRIPTION: This snippet shows how to register C++ structs ('A' and 'B') as NumPy-compatible record types for use as py::array_t template arguments. The PYBIND11_NUMPY_DTYPE macro registers field offsets, allowing pybind11 to map instances to NumPy structured dtypes. Requires including pybind11/numpy.h. Structures must be 'plain' (trivially copyable) types. Limitations: Pointers and non-arithmetic fields are not supported.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nstruct A {\n    int x;\n    double y;\n};\n\nstruct B {\n    int z;\n    A a;\n};\n\n// ...\nPYBIND11_MODULE(test, m) {\n    // ...\n\n    PYBIND11_NUMPY_DTYPE(A, x, y);\n    PYBIND11_NUMPY_DTYPE(B, z, a);\n    /* now both A and B can be used as template arguments to py::array_t */\n}\n```\n\n----------------------------------------\n\nTITLE: Using find_package with pybind11 in CMake\nDESCRIPTION: Example CMake configuration that uses find_package to detect and use an external pybind11 installation. This approach requires pybind11 to be properly installed on the system.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_13\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15...4.0)\nproject(example LANGUAGES CXX)\n\nfind_package(pybind11 REQUIRED)\npybind11_add_module(example example.cpp)\n```\n\n----------------------------------------\n\nTITLE: Creating a Human-Readable `__repr__` Using a Lambda Function in pybind11\nDESCRIPTION: This code shows how to bind a Python `__repr__` method to provide a custom string representation for the `Pet` class using a lambda function. It captures the `Pet` instance and returns a formatted string with the pet's name, enhancing Python's print output.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\npy::class_<Pet>(m, \"Pet\")\n    .def(py::init<const std::string &>)\n    .def(\"setName\", &Pet::setName)\n    .def(\"getName\", &Pet::getName)\n    .def(\"__repr__\",\n        [](const Pet &a) {\n            return \"<example.Pet named '\" + a.name + \">'\";\n        }\n    );\n```\n\n----------------------------------------\n\nTITLE: Implicit Casting with pybind11 (C++)\nDESCRIPTION: This snippet shows how to use implicit conversions with Python types accessed through pybind11, specifically for subclasses.  It demonstrates accessing OS-related functions and numpy operations.  It uses the `os` and `os.path` modules and `numpy` for an array, all imported from python, and displays a print of some of these interactions. This example showcases how implicit casting can be used to make the code more readable, without needing `obj.cast()`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/object.rst#_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\n#include <pybind11/numpy.h>\nusing namespace pybind11::literals;\n\npy::module_ os = py::module_::import(\"os\");\npy::module_ path = py::module_::import(\"os.path\");  // like 'import os.path as path'\npy::module_ np = py::module_::import(\"numpy\");  // like 'import numpy as np'\n\npy::str curdir_abs = path.attr(\"abspath\")(path.attr(\"curdir\"));\npy::print(py::str(\"Current directory: \") + curdir_abs);\npy::dict environ = os.attr(\"environ\");\npy::print(environ[\"HOME\"]);\npy::array_t<float> arr = np.attr(\"ones\")(3, \"dtype\"_a=\"float32\");\npy::print(py::repr(arr + py::int_(1)));\n```\n\n----------------------------------------\n\nTITLE: Help Output for Overloaded Methods in Python\nDESCRIPTION: This Python snippet demonstrates how the help function displays the signatures of the overloaded methods that are created using pybind11. Requires the module 'example' to be created with the `Pet` class with overloaded methods.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> help(example.Pet)\n\nclass Pet(__builtin__.object)\n |  Methods defined here:\n |  \n |  __init__(...)\n |      Signature : (Pet, str, int) -> NoneType\n |\n |  set(...)\n |      1. Signature : (Pet, int) -> NoneType\n |\n |      Set the pet's age\n |\n |      2. Signature : (Pet, str) -> NoneType\n |\n |      Set the pet's name\n```\n\n----------------------------------------\n\nTITLE: Combining exec and pybind11 API for Mixed Python Code Execution in Embedded Interpreter\nDESCRIPTION: Combines use of ``py::exec`` with explicit locals dictionary binding. Constructs a Python dict in C++ and passes it as locals to exec, then extracts a formatted message variable back into C++ for output. This approach enables seamless communication and data exchange between C++ and embedded Python code.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/embedding.rst#_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n#include <pybind11/embed.h>\n#include <iostream>\n\nnamespace py = pybind11;\nusing namespace py::literals;\n\nint main() {\n    py::scoped_interpreter guard{};\n\n    auto locals = py::dict(\"name\"_a=\"World\", \"number\"_a=42);\n    py::exec(R\"(\n        message = \"Hello, {name}! The answer is {number}\".format(**locals())\n    )\", py::globals(), locals);\n\n    auto message = locals[\"message\"].cast<std::string>();\n    std::cout << message;\n}\n```\n\n----------------------------------------\n\nTITLE: Modified pybind11 Bindings using Trampoline\nDESCRIPTION: This snippet shows how to adapt the binding code to make use of the trampoline helper class `PyAnimal`. The `PyAnimal` is specified as a template argument to `py::class_`, enabling override capabilities from Python.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nPYBIND11_MODULE(example, m) {\n    py::class_<Animal, PyAnimal /* <--- trampoline */, py::smart_holder>(m, \"Animal\")\n        .def(py::init<>())\n        .def(\"go\", &Animal::go);\n\n    py::class_<Dog, Animal, py::smart_holder>(m, \"Dog\")\n        .def(py::init<>());\n\n    m.def(\"call_go\", &call_go);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Class with std::shared_ptr as Holder\nDESCRIPTION: This snippet shows how to use std::shared_ptr as a holder type for a pybind11 class. This involves passing std::shared_ptr<Example> as a template argument to py::class_. However, it has disadvantages compared to py::smart_holder such as potential runtime errors. This is due to the inability to pass std::unique_ptr from C++ to Python.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/smart_ptrs.rst#_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\npy::class_<Example, std::shared_ptr<Example> /* <- holder type */>(m, \"Example\");\n```\n\n----------------------------------------\n\nTITLE: Binding C++ Operator Overloads to Python Using pybind11 Operators Header (C++)\nDESCRIPTION: Shows how to expose overloaded C++ operators to Python using pybind11's operators header. For a Vector2 class supporting vector addition, scalar multiplication, and related operators, bindings use py::self syntax for concise operator exposure. Also illustrates that equivalent custom operator binding can be done via lambdas with py::is_operator() to indicate operator functions that return NotImplemented on invalid arguments. The snippet requires including pybind11/operators.h and demonstrates binding operators +, +=, *=, multiplication with float from left and right, unary -, and __repr__ for string conversion.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_24\n\nLANGUAGE: cpp\nCODE:\n```\n#include <pybind11/operators.h>\n\nPYBIND11_MODULE(example, m) {\n    py::class_<Vector2>(m, \"Vector2\")\n        .def(py::init<float, float>())\n        .def(py::self + py::self)\n        .def(py::self += py::self)\n        .def(py::self *= float())\n        .def(float() * py::self)\n        .def(py::self * float())\n        .def(-py::self)\n        .def(\"__repr__\", &Vector2::toString);\n}\n```\n\n----------------------------------------\n\nTITLE: Binding C++ Template Functions in pybind11\nDESCRIPTION: Shows how to bind C++ functions with template parameters in pybind11. Since C++ templates cannot be instantiated at runtime, each template instantiation must be bound separately.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/functions.rst#_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\n// BROKEN (this will not compile)\nm.def(\"set\", &set);\n```\n\nLANGUAGE: C++\nCODE:\n```\nm.def(\"set\", &set<int>);\nm.def(\"set\", &set<std::string>);\n```\n\nLANGUAGE: C++\nCODE:\n```\nm.def(\"setInt\", &set<int>);\nm.def(\"setString\", &set<std::string>);\n```\n\n----------------------------------------\n\nTITLE: Calling C++ Function Returning Raw Bytes and Receiving bytes in Python\nDESCRIPTION: Python example calling the C++ function returning bytes representation of binary data and displaying it as Python bytes literal with escape sequences. Demonstrates that pybind11 does not implicitly convert std::string to bytes, requiring explicit py::bytes return.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/strings.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> example.return_bytes()\nb'\\xba\\xd0\\xba\\xd0'\n```\n\n----------------------------------------\n\nTITLE: Sharing Arbitrary C++ Objects via Capsules Between pybind11 Modules (C++)\nDESCRIPTION: This snippet details retrieving and setting shared data pointers between extension modules at runtime using pybind11's capsule machinery. The code checks for existing data associated with a key ('mydata'), and if absent, creates and stores a new object. This mechanism is essential for global state or for sharing objects between modules but requires all modules to be built with the same version of pybind11 for compatibility.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/misc.rst#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nauto data = reinterpret_cast<MyData *>(py::get_shared_data(\"mydata\"));\nif (!data)\n    data = static_cast<MyData *>(py::set_shared_data(\"mydata\", new MyData(42)));\n```\n\n----------------------------------------\n\nTITLE: Passing Python UTF-8 Strings and Bytes to C++ Functions Using pybind11 in Python\nDESCRIPTION: Demonstrates calling the previously exposed C++ functions from Python with UTF-8 Unicode strings and emoji characters. Shows that Python str is transmitted as UTF-8 and printed correctly. Highlights terminal font and UTF-8 support caveats.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/strings.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> utf8_test(\"🎂\")\nutf-8 is icing on the cake.\n🎂\n\n>>> utf8_charptr(\"🍕\")\nMy favorite food is\n🍕\n```\n\n----------------------------------------\n\nTITLE: Redirecting std::cout to Python sys.stdout with pybind11\nDESCRIPTION: This C++ code snippet uses `py::scoped_ostream_redirect` to redirect the output of `std::cout` to Python's `sys.stdout`. This is useful when a C++ library uses `std::cout` for printing, and you want that output to be redirected to the Python environment.  The `py::scoped_ostream_redirect` is a scoped guard; when it goes out of scope, the redirection is removed. This requires the `<pybind11/iostream.h>` header. The main input is the C++ standard output stream and the Python output stream. The output is redirected to Python's stdout, and is flushed when the guard is destroyed.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/utilities.rst#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <pybind11/iostream.h>\n\n...\n\n// Add a scoped redirect for your noisy code\nm.def(\"noisy_func\", []() {\n    py::scoped_ostream_redirect stream(\n        std::cout,                               // std::ostream&\n        py::module_::import(\"sys\").attr(\"stdout\") // Python output\n    );\n    call_noisy_func();\n});\n```\n\n----------------------------------------\n\nTITLE: Declaring STL Vector as Opaque Type pybind11 C++\nDESCRIPTION: Uses the `PYBIND11_MAKE_OPAQUE` macro to inform pybind11 that `std::vector<int>` should not use the automatic template-based conversion. This makes the type 'opaque' to pybind11's default conversion mechanism, enabling it to be passed by reference and avoiding costly copies. This macro must be used at the top level before any binding code that uses `std::vector<int>`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/stl.rst#_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nPYBIND11_MAKE_OPAQUE(std::vector<int>)\n```\n\n----------------------------------------\n\nTITLE: Accessing pybind11-Exported Module Attributes in Python (Pycon)\nDESCRIPTION: This interactive session shows accessing Python-visible module attributes created from C++ using pybind11. Requires: module with m.attr exports to be built and importable. Inputs: import statement; Outputs: printed primitive and string values.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/basics.rst#_snippet_13\n\nLANGUAGE: pycon\nCODE:\n```\n>>> import example\n>>> example.the_answer\n42\n>>> example.what\n'World'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Potential Memory Errors in Python with Raw Pointers\nDESCRIPTION: This Python snippet demonstrates the potential memory error that can occur when using the C++ code that returns raw pointers, leading to segmentation faults or similar issues. It shows that the returned raw pointer can become invalid when the original shared pointer goes out of scope. Requires a module named 'example' to be built based on the C++ code.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom example import Parent\n\nprint(Parent().get_child())\n```\n\n----------------------------------------\n\nTITLE: Instantiating tuple in pybind11 (C++)\nDESCRIPTION: This snippet shows how to create a Python tuple from C++ using pybind11's `py::make_tuple` function. The tuple contains a mix of data types, including an integer, `py::none()`, and a string. Each element is implicitly converted to its corresponding Python type during construction.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/object.rst#_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\npy::tuple tup = py::make_tuple(42, py::none(), \"spam\");\n```\n\n----------------------------------------\n\nTITLE: Enabling Pickling Support for a C++ Class in pybind11 (C++)\nDESCRIPTION: Illustrates the initial setup to add pickling support to a pybind11-bound C++ class Pickleable by binding __setstate__ and __getstate__ methods internally using py::pickle(). The class stores a string and an int with getters and setters. The snippet shows the definition of the Pickleable class and begins the binding code with py::class_ and the constructor binding. To fully enable pickling, py::pickle() with state serialization and restoration lambdas must be provided; this snippet represents the starting point. Requirements include pybind11 and possibly further methods to ensure complete serialization.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_25\n\nLANGUAGE: cpp\nCODE:\n```\nclass Pickleable {\npublic:\n    Pickleable(const std::string &value) : m_value(value) { }\n    const std::string &value() const { return m_value; }\n\n    void setExtra(int extra) { m_extra = extra; }\n    int extra() const { return m_extra; }\nprivate:\n    std::string m_value;\n    int m_extra = 0;\n};\n\npy::class_<Pickleable>(m, \"Pickleable\")\n    .def(py::init<std::string>())\n```\n\n----------------------------------------\n\nTITLE: Brace Initialization with pybind11's py::init<> for Implicit Constructors in C++\nDESCRIPTION: Shows how to use pybind11's py::init<> template constructor which internally uses C++11 brace initialization to bind constructors, including implicit ones such as for aggregate structs with public members. This technique binds the Aggregate struct with members int a and std::string b by specifying constructor argument types in py::init. It highlights that constructor overloads accepting std::initializer_list may take precedence, with a suggestion to use lambdas to disambiguate if needed. This pattern requires C++11 support.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_19\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Aggregate {\n    int a;\n    std::string b;\n};\n\npy::class_<Aggregate>(m, \"Aggregate\")\n    .def(py::init<int, const std::string &>());\n```\n\n----------------------------------------\n\nTITLE: Registering Simple Exception Translator in C++\nDESCRIPTION: Shows how to register a simple exception translator that converts a C++ exception into a new Python exception using the C++ exception's what() method.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/exceptions.rst#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\npy::register_exception<CppExp>(module, \"PyExp\");\n```\n\n----------------------------------------\n\nTITLE: Deprecation of Old py::object APIs in pybind11\nDESCRIPTION: This snippet outlines the deprecated old-style APIs of 'py::object' which emit warnings. The new preferred syntax replaces 'obj.call()', 'obj.str()', and other methods with modern equivalents like 'obj(args...)', 'py::str(obj)', and 'py::hasattr()'. These changes improve consistency and compatibility across pybind11 versions.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/upgrade.rst#_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\n+------------------------------+------------------------------+\n|  Old syntax                  |  New syntax                  |\n+==============================+==============================+\n| obj.call(args...)            | obj(args...)                 |\n| obj.str()                    | py::str(obj)                 |\n| auto l = py::list(obj); l.check() | py::isinstance<py::list>(obj) |\n| py::object(ptr, true)        | py::reinterpret_borrow<py::object>(ptr) |\n| py::object(ptr, false)       | py::reinterpret_steal<py::object>(ptr) |\n| if (obj.attr(\"foo\"))        | if (py::hasattr(obj, \"foo\")) |\n| if (obj[\"bar\"])             | if (obj.contains(\"bar\"))   |\n+------------------------------+------------------------------+\n```\n\n----------------------------------------\n\nTITLE: Unpacking arguments in pybind11 (C++)\nDESCRIPTION: This code presents techniques for unpacking arguments like `*args` and `**kwargs` when calling Python functions from C++ via pybind11.  It includes examples of `*` unpacking using a tuple and `**` unpacking using a dict, as well as a mixed example with both, plus unpacking with PEP448.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/object.rst#_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n// * unpacking\npy::tuple args = py::make_tuple(1234, \"hello\", some_instance);\nf(*args);\n```\n\nLANGUAGE: cpp\nCODE:\n```\n// ** unpacking\npy::dict kwargs = py::dict(\"number\"_a=1234, \"say\"_a=\"hello\", \"to\"_a=some_instance);\nf(**kwargs);\n```\n\nLANGUAGE: cpp\nCODE:\n```\n// mixed keywords, * and ** unpacking\npy::tuple args = py::make_tuple(1234);\npy::dict kwargs = py::dict(\"to\"_a=some_instance);\nf(*args, \"say\"_a=\"hello\", **kwargs);\n```\n\nLANGUAGE: cpp\nCODE:\n```\npy::dict kwargs1 = py::dict(\"number\"_a=1234);\npy::dict kwargs2 = py::dict(\"to\"_a=some_instance);\nf(**kwargs1, \"say\"_a=\"hello\", **kwargs2);\n```\n\n----------------------------------------\n\nTITLE: Once with Double-Checked Locking and Atomic - C++\nDESCRIPTION: This snippet demonstrates the \"double-locking\" optimization for the \"once\" initialization pattern. It improves upon the naive approach by first checking the initialization flag without acquiring the lock. If the flag is already set, the function returns immediately. Otherwise, it acquires the lock, checks the flag again (to handle the case where another thread initialized it concurrently), and performs the initialization if needed, using acquire/release semantics to ensure visibility of operations. Dependencies: `absl/synchronization.h`, `absl/base/const_init.h`, and `<atomic>`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/deadlock.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\n// The \"once\" mechanism:\nconstinit absl::Mutex mu(absl::kConstInit);\nconstinit std::atomic<bool> init_done = false;\n\n// The operation of interest:\nvoid f();\n\nvoid InitOnceWithFastPath() {\n  if (!init_done.load(std::memory_order_acquire)) {\n    absl::MutexLock lock(&mu);\n    if (!init_done.load(std::memory_order_relaxed)) {\n      f();\n      init_done.store(true, std::memory_order_release);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Embedding Python Interpreter using pybind11 in C++\nDESCRIPTION: Demonstrates basic Python interpreter embedding in a C++ application using pybind11. It utilizes `py::scoped_interpreter` to manage the interpreter's lifecycle and `py::print` to execute Python functionality from C++. Requires including the `pybind11/embed.h` header.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_53\n\nLANGUAGE: cpp\nCODE:\n```\n#include <pybind11/embed.h>\nnamespace py = pybind11;\n\nint main() {\n    py::scoped_interpreter guard{}; // start the interpreter and keep it alive\n\n    py::print(\"Hello, World!\"); // use the Python API\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Constructors with Pybind11 Using py::init Instead of Placement-New in C++\nDESCRIPTION: Shows the recommended replacement of deprecated placement-new style custom constructors in Pybind11 with safer factory function constructs using py::init(). This approach improves type safety by preventing multiple initializations and incompatible types that placement-new might allow. This snippet requires a C++14 or later compiler and Pybind11 headers, and it modifies the class binding construction for Python exposure. Inputs are constructor arguments, outputs are initialized Python class instances that enforce correct construction behavior.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/upgrade.rst#_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n// old -- deprecated (runtime warning shown only in debug mode)\npy::class<Foo>(m, \"Foo\")\n    .def(\"__init__\", [](Foo &self, ...) {\n        new (&self) Foo(...); // uses placement-new\n    });\n```\n\n----------------------------------------\n\nTITLE: Simplifying GIL-Release with call_guard Policy in pybind11 (C++)\nDESCRIPTION: This snippet shows the use of the py::call_guard policy with pybind11 function definitions to automatically handle GIL release around C++ functions invoked from Python. By passing py::call_guard<py::gil_scoped_release> as a function policy, it is ensured that the GIL is released only for the duration of the bound function call and correctly reacquired afterward, simplifying manual lock handling. This is particularly useful for exposing parallelizable or blocking C++ computations safely to Python.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/misc.rst#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nm.def(\"call_go\", &call_go, py::call_guard<py::gil_scoped_release>());\n```\n\n----------------------------------------\n\nTITLE: Handling Python Exceptions in C++\nDESCRIPTION: This snippet shows how to catch Python exceptions raised during Python function calls from C++ using `py::error_already_set`. It attempts to open and read a file, catching `FileNotFoundError` and `PermissionError` specifically. The `e.matches()` method checks if the caught exception matches a particular Python exception type.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/exceptions.rst#_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\ntry {\n    // open(\"missing.txt\", \"r\")\n    auto file = py::module_::import(\"io\").attr(\"open\")(\"missing.txt\", \"r\");\n    auto text = file.attr(\"read\")();\n    file.attr(\"close\")();\n} catch (py::error_already_set &e) {\n    if (e.matches(PyExc_FileNotFoundError)) {\n        py::print(\"missing.txt not found\");\n    } else if (e.matches(PyExc_PermissionError)) {\n        py::print(\"missing.txt found but not accessible\");\n    } else {\n        throw;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Python UTF-8 Strings to C++ Using pybind11 in C++\nDESCRIPTION: Defines C++ functions exposed to Python that accept UTF-8 encoded Python str arguments as std::string or char pointers. pybind11 automatically encodes the Python str to UTF-8 when passing to C++ functions. The example demonstrates printing passed strings, supporting both std::string & and const char * parameters. This snippet requires a pybind11 module definition context and std::cout output. Unicode or emoji characters are passed transparently but depend on terminal UTF-8 support.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/strings.rst#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nm.def(\"utf8_test\",\n    [](const std::string &s) {\n        cout << \"utf-8 is icing on the cake.\\n\";\n        cout << s;\n    }\n);\nm.def(\"utf8_charptr\",\n    [](const char *s) {\n        cout << \"My favorite food is\\n\";\n        cout << s;\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Declaring Custom Smart Pointer Holder Type with Macro\nDESCRIPTION: The provided code snippet describes how to declare a custom smart pointer holder for use with pybind11. It uses the PYBIND11_DECLARE_HOLDER_TYPE macro to enable transparent conversions between C++ and Python for custom smart pointer types like `SmartPtr<T>`. The first argument is a placeholder name. The second argument should be the actual smart pointer type, such as `SmartPtr<T>`. An optional third argument can be set to true for intrusive reference counting.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/smart_ptrs.rst#_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nPYBIND11_DECLARE_HOLDER_TYPE(T, SmartPtr<T>)\n```\n\n----------------------------------------\n\nTITLE: Binding Overloaded Methods using py::detail::overload_cast_impl (C++11)\nDESCRIPTION: This C++ snippet shows how to bind overloaded methods when only C++11 is available. It utilizes `pybind11::detail::overload_cast_impl` to achieve the same functionality as `py::overload_cast`. Requires the `overload_cast_` alias template definition and pybind11.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <typename... Args>\nusing overload_cast_ = pybind11::detail::overload_cast_impl<Args...>;\n\npy::class_<Pet>(m, \"Pet\")\n    .def(\"set\", overload_cast_<int>()(&Pet::set), \"Set the pet's age\")\n    .def(\"set\", overload_cast_<const std::string &>()(&Pet::set), \"Set the pet's name\");\n```\n\n----------------------------------------\n\nTITLE: Instantiating Python Enum from Underlying Value (Python)\nDESCRIPTION: Shows how to create an instance of the `Colors` enum (presumably bound from C++) by passing the C++ underlying enum value (0 in this case) to the Python enum constructor. This illustrates a feature of pybind11-bound enums.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nred = Colors(0)\n```\n\n----------------------------------------\n\nTITLE: Exporting C++ Types for Cross-Module Usage with pybind11 (C++)\nDESCRIPTION: This snippet shows the use of the PYBIND11_EXPORT macro to explicitly export C++ types when using hidden symbol visibility (such as with -fvisibility=hidden) that otherwise prevents types from being shared between extension modules. Proper exporting is necessary to allow access to class types across Python C++ binding modules built with pybind11, ensuring inheritance and object referencing function as expected.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/misc.rst#_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nclass PYBIND11_EXPORT Dog : public Animal {\n    ...\n};\n```\n\n----------------------------------------\n\nTITLE: Returning Eigen Matrices with Different Return Value Policies\nDESCRIPTION: Example class showing different methods of returning Eigen matrices to Python, including copying, references, and views with appropriate return value policies.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/eigen.rst#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nclass MyClass {\n    Eigen::MatrixXd big_mat = Eigen::MatrixXd::Zero(10000, 10000);\npublic:\n    Eigen::MatrixXd &getMatrix() { return big_mat; }\n    const Eigen::MatrixXd &viewMatrix() { return big_mat; }\n};\n\n// Later, in binding code:\npy::class_<MyClass>(m, \"MyClass\")\n    .def(py::init<>())\n    .def(\"copy_matrix\", &MyClass::getMatrix) // Makes a copy!\n    .def(\"get_matrix\", &MyClass::getMatrix, py::return_value_policy::reference_internal)\n    .def(\"view_matrix\", &MyClass::viewMatrix, py::return_value_policy::reference_internal)\n    ;\n```\n\n----------------------------------------\n\nTITLE: Safe Static Initialization Using `absl::call_once` and Atomic Flag (C++)\nDESCRIPTION: Presents a robust solution using `absl::call_once` to ensure one-time initialization and control lock order. The GIL is released before `call_once`, and the initialization lambda reacquires the GIL (`PyGILState_Ensure`) before calling `CreateWidget` and releases it (`PyGILState_Release`) afterwards. An atomic `init_done` flag implements double-checked locking to minimize overhead on subsequent calls. This enforces the correct lock order: guard mutex (internal to `call_once`) first, then GIL.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/deadlock.md#_snippet_7\n\nLANGUAGE: c++\nCODE:\n```\n// CPython callback, assumes that the GIL is held on entry.\nPyObject* InvokeWidget(PyObject* self) {\n  static constinit PyObject* impl = nullptr;\n  static constinit std::atomic<bool> init_done = false;\n  static constinit absl::once_flag init_flag;\n\n  if (!init_done.load(std::memory_order_acquire)) {\n    Py_BEGIN_ALLOW_THREADS                       // releases GIL\n    absl::call_once(init_flag, [&]() {\n      PyGILState_STATE s = PyGILState_Ensure();  // acquires GIL\n      impl = CreateWidget();\n      PyGILState_Release(s);                     // releases GIL\n      init_done.store(true, std::memory_order_release);\n    });\n    Py_END_ALLOW_THREADS                         // acquires GIL\n  }\n\n  return PyObject_CallOneArg(impl, self);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Automatic Downcasters for Non-Polymorphic Classes in C++\nDESCRIPTION: Demonstrates how to provide automatic downcasting behavior for class hierarchies that don't use standard C++ polymorphism by specializing the pybind11::polymorphic_type_hook template.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_39\n\nLANGUAGE: cpp\nCODE:\n```\nenum class PetKind { Cat, Dog, Zebra };\nstruct Pet {   // Not polymorphic: has no virtual methods\n    const PetKind kind;\n    int age = 0;\n  protected:\n    Pet(PetKind _kind) : kind(_kind) {}\n};\nstruct Dog : Pet {\n    Dog() : Pet(PetKind::Dog) {}\n    std::string sound = \"woof!\";\n    std::string bark() const { return sound; }\n};\n\nnamespace PYBIND11_NAMESPACE {\n    template<> struct polymorphic_type_hook<Pet> {\n        static const void *get(const Pet *src, const std::type_info*& type) {\n            // note that src may be nullptr\n            if (src && src->kind == PetKind::Dog) {\n                type = &typeid(Dog);\n                return static_cast<const Dog*>(src);\n            }\n            return src;\n        }\n    };\n} // namespace PYBIND11_NAMESPACE\n```\n\n----------------------------------------\n\nTITLE: Exposing 2D C++ Buffer as Memory View (C++)\nDESCRIPTION: Demonstrates creating a Python `memoryview` object from a raw 2D C++ buffer using `py::memoryview::from_buffer`. This exposes the buffer directly without copying, specifying its shape and strides. The C++ code remains responsible for the buffer's lifetime management. Requires `pybind11/pybind11.h`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\nconst uint8_t buffer[] = {\n    0, 1, 2, 3,\n    4, 5, 6, 7\n};\nm.def(\"get_memoryview2d\", []() {\n    return py::memoryview::from_buffer(\n        buffer,                                    // buffer pointer\n        { 2, 4 },                                  // shape (rows, cols)\n        { sizeof(uint8_t) * 4, sizeof(uint8_t) }   // strides in bytes\n    );\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Ctrl-C in Long-Running C++ Functions (C++)\nDESCRIPTION: Demonstrates how to make a long-running C++ function interruptible from Python using `PyErr_CheckSignals()`. This function checks for pending Python signals (like a `KeyboardInterrupt` from Ctrl-C). If a signal is detected, `py::error_already_set()` is thrown, propagating the Python error back to the interpreter. Requires `pybind11/pybind11.h`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/faq.rst#_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nPYBIND11_MODULE(example, m)\n{\n    m.def(\"long running_func\", []()\n    {\n        for (;;) {\n            if (PyErr_CheckSignals() != 0)\n                throw py::error_already_set();\n            // Long running iteration\n        }\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Overloaded Methods using py::overload_cast (C++14)\nDESCRIPTION: This C++ snippet shows how to bind overloaded methods in pybind11 using `py::overload_cast` which requires C++14 or later.  It binds two versions of `Pet::set`, one taking an `int` and the other a `std::string`. Relies on pybind11.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\npy::class_<Pet>(m, \"Pet\")\n    .def(\"set\", py::overload_cast<int>(&Pet::set), \"Set the pet's age\")\n    .def(\"set\", py::overload_cast<const std::string &>(&Pet::set), \"Set the pet's name\");\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Embedded Python Binary Modules with PYBIND11_EMBEDDED_MODULE in C++\nDESCRIPTION: Illustrates how to create embedded Python binary modules directly in C++ using the ``PYBIND11_EMBEDDED_MODULE`` macro at global scope. Defines functions exposed to Python code and demonstrates importing and calling these functions from the embedded interpreter. Multiple such modules can be defined with unique names, enabling rich interoperation between Python scripts and C++ code.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/embedding.rst#_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n#include <pybind11/embed.h>\nnamespace py = pybind11;\n\nPYBIND11_EMBEDDED_MODULE(fast_calc, m) {\n    // `m` is a `py::module_` which is used to bind functions and classes\n    m.def(\"add\", [](int i, int j) {\n        return i + j;\n    });\n}\n\nint main() {\n    py::scoped_interpreter guard{};\n\n    auto fast_calc = py::module_::import(\"fast_calc\");\n    auto result = fast_calc.attr(\"add\")(1, 2).cast<int>();\n    assert(result == 3);\n}\n```\n\n----------------------------------------\n\nTITLE: Specializing pybind11 Type Caster for Boost Variant C++\nDESCRIPTION: Defines custom `type_caster` and `visit_helper` specializations for `boost::variant<Ts...>` within `pybind11::detail`. The `type_caster` enables automatic conversion of `boost::variant` types. The `visit_helper` is necessary to tell pybind11 how to visit the variant alternatives (here, using `boost::apply_visitor` instead of the default `visit`). Requires Boost 1.56+ and should be placed in a common header.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/stl.rst#_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n// `boost::variant` as an example -- can be any `std::variant`-like container\nnamespace PYBIND11_NAMESPACE { namespace detail {\n    template <typename... Ts>\n    struct type_caster<boost::variant<Ts...>> : variant_caster<boost::variant<Ts...>> {};\n\n    // Specifies the function used to visit the variant -- `apply_visitor` instead of `visit`\n    template <>\n    struct visit_helper<boost::variant> {\n        template <typename... Args>\n        static auto call(Args &&...args) -> decltype(boost::apply_visitor(args...)) {\n            return boost::apply_visitor(args...);\n        }\n    };\n}} // namespace PYBIND11_NAMESPACE::detail\n```\n\n----------------------------------------\n\nTITLE: Executing Python Code Using pybind11's API With C++ Literals and Format in Embedded Interpreter\nDESCRIPTION: Demonstrates an alternative to ``py::exec`` by using pybind11's Python API from C++ to construct a Python dict and format strings using Python literal suffixes. This allows for embedding Python-like constructs directly in C++ code for more integrated and type-safe scripting without inline Python source strings.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/embedding.rst#_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <pybind11/embed.h>\nnamespace py = pybind11;\nusing namespace py::literals;\n\nint main() {\n    py::scoped_interpreter guard{};\n\n    auto kwargs = py::dict(\"name\"_a=\"World\", \"number\"_a=42);\n    auto message = \"Hello, {name}! The answer is {number}\"_s.format(**kwargs);\n    py::print(message);\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Virtual-Function Classes with pybind11 Shapes\nDESCRIPTION: Shows how to register classes and their trampoline counterparts with pybind11, enabling Python subclasses to override virtual methods. Demonstrates registration of 'Animal', 'Dog', and 'Husky' with appropriate trampoline classes.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\npy::class_<Animal, PyAnimal<>, py::smart_holder> animal(m, \"Animal\");\npy::class_<Dog, Animal, PyDog<>, py::smart_holder> dog(m, \"Dog\");\npy::class_<Husky, Dog, PyDog<Husky>, py::smart_holder> husky(m, \"Husky\");\n```\n\n----------------------------------------\n\nTITLE: Passing NumPy Array Slices to Eigen Functions\nDESCRIPTION: Python code demonstrating how to pass a NumPy array slice to an Eigen function that uses EigenDRef.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/eigen.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n# a = np.array(...)\nscale_by_2(myarray[0::2, 2:9:3])\n```\n\n----------------------------------------\n\nTITLE: Binding Class with Trampoline (New Syntax) - C++ pybind11\nDESCRIPTION: This snippet shows the new syntax (v2.0.0-rc1 and later) for binding a C++ class (`MyClass`) and its Python trampoline class (`TrampolineClass`) for virtual method overriding. Both classes are now passed as template arguments to `py::class_`, replacing the older `.alias()` method. This updated scheme has zero overhead if virtual methods are not overridden.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_60\n\nLANGUAGE: cpp\nCODE:\n```\npy::class_<MyClass, TrampolineClass>(\"MyClass\")\n  ....\n```\n\n----------------------------------------\n\nTITLE: C++ Function Accepting std::string Parameter Demonstrating bytes-to-str Implicit Conversion Asymmetry in pybind11\nDESCRIPTION: Defines a C++ function accepting std::string which can receive bytes or str from Python. However, the return value, being std::string, is implicitly converted to Python str by decoding UTF-8, which can cause UnicodeDecodeError if input bytes are non-UTF-8. Highlights pybind11 asymmetry: bytes to std::string conversion has no encoding, but std::string to bytes conversion requires explicit py::bytes.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/strings.rst#_snippet_8\n\nLANGUAGE: c++\nCODE:\n```\nm.def(\"asymmetry\",\n    [](std::string s) {  // Accepts str or bytes from Python\n        return s;  // Looks harmless, but implicitly converts to str\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Advanced Custom Exception Translator in C++\nDESCRIPTION: Demonstrates how to create a complex exception translator that can handle multiple exception types with custom logic and map them to appropriate Python exceptions.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/exceptions.rst#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nPYBIND11_CONSTINIT static py::gil_safe_call_once_and_store<py::object> exc_storage;\nexc_storage.call_once_and_store_result(\n    [&]() { return py::exception<MyCustomException>(m, \"MyCustomError\"); });\npy::register_exception_translator([](std::exception_ptr p) {\n    try {\n        if (p) std::rethrow_exception(p);\n    } catch (const MyCustomException &e) {\n        py::set_error(exc_storage.get_stored(), e.what());\n    } catch (const OtherException &e) {\n        py::set_error(PyExc_RuntimeError, e.what());\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Defining C++ Class with STL Vector Member C++\nDESCRIPTION: Defines a simple C++ class `MyClass` that contains a `std::vector<int>` member named `contents`. This class is used in subsequent examples to illustrate how exposing an STL container member using `py::def_readwrite` behaves under automatic conversion.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/stl.rst#_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n/* ... definition ... */\n\nclass MyClass {\n    std::vector<int> contents;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Buffer Protocol for Eigen-Based Matrix via pybind11 - C++\nDESCRIPTION: This code shows the .def_buffer() implementation for an Eigen matrix type bound to Python with pybind11. The lambda builds a py::buffer_info with shape and strides determined according to row-major or column-major layout, supporting efficient zero-copy interop with NumPy. Dependencies: Eigen, pybind11. Inputs: Eigen matrix; Outputs: Python buffer description. Assumes that memory layout is compatible and type Scalar is correctly resolved.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n.def_buffer([](Matrix &m) -> py::buffer_info {\n    return py::buffer_info(\n        m.data(),                                /* Pointer to buffer */\n        sizeof(Scalar),                          /* Size of one scalar */\n        py::format_descriptor<Scalar>::format(), /* Python struct-style format descriptor */\n        2,                                       /* Number of dimensions */\n        { m.rows(), m.cols() },                  /* Buffer dimensions */\n        { sizeof(Scalar) * (rowMajor ? m.cols() : 1),\n          sizeof(Scalar) * (rowMajor ? 1 : m.rows()) }\n                                             /* Strides (in bytes) for each index */\n    );\n })\n```\n\n----------------------------------------\n\nTITLE: C++ Functions Accepting and Returning Character Literals with pybind11\nDESCRIPTION: Defines simple C++ functions taking char and wchar_t as arguments and returning them, demonstrating pybind11 maps Python single-character str input to C++ character literals and converts returned chars to Python str. Shows the importance of passing single Unicode characters instead of longer strings and not passing integer values directly for character arguments.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/strings.rst#_snippet_11\n\nLANGUAGE: c++\nCODE:\n```\nm.def(\"pass_char\", [](char c) { return c; });\nm.def(\"pass_wchar\", [](wchar_t w) { return w; });\n```\n\n----------------------------------------\n\nTITLE: Registering Local Exception Translator in C++\nDESCRIPTION: Demonstrates how to register a local exception translator that only applies within the current module.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/exceptions.rst#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\npy::register_local_exception<CppExp>(module, \"PyExp\");\n```\n\n----------------------------------------\n\nTITLE: Enabling Implicit Type Conversions Between pybind11-Bound C++ Classes (C++)\nDESCRIPTION: Shows how to enable implicit conversions from one bound custom C++ type A to another type B in pybind11, mirroring C++ implicit constructor conversions in Python. After binding classes A and B (with B having a constructor from A), calling py::implicitly_convertible<A, B>() allows Python functions expecting B to accept A instances directly. This only applies if both A and B are pybind11 exposed types and prevents recursive infinite conversions. This snippet is minimal and builds upon prior class bindings.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_22\n\nLANGUAGE: cpp\nCODE:\n```\npy::implicitly_convertible<A, B>();\n```\n\n----------------------------------------\n\nTITLE: Controlling None Arguments in pybind11 with none()\nDESCRIPTION: Demonstrates how to use the .none() method on py::arg to explicitly allow or prohibit None arguments for C++ function parameters that take pointers or shared holders to class instances.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/functions.rst#_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\npy::class_<Dog>(m, \"Dog\").def(py::init<>());\npy::class_<Cat>(m, \"Cat\").def(py::init<>());\nm.def(\"bark\", [](Dog *dog) -> std::string {\n    if (dog) return \"woof!\"; /* Called with a Dog instance */\n    else return \"(no dog)\"; /* Called with None, dog == nullptr */\n}, py::arg(\"dog\").none(true));\nm.def(\"meow\", [](Cat *cat) -> std::string {\n    // Can't be called with None argument\n    return \"meow\";\n}, py::arg(\"cat\").none(false));\n```\n\n----------------------------------------\n\nTITLE: Implementing Virtual Function Trampoline Method for 'bark' in C++\nDESCRIPTION: Defines a trampoline override for the 'bark' virtual method in C++ using PYBIND11_OVERRIDE. It handles a function with no arguments returning a std::string, noting the need for a trailing comma for parameter list consistency.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nstd::string bark() override { PYBIND11_OVERRIDE(std::string, Dog, bark, ); }\n```\n\n----------------------------------------\n\nTITLE: Registering callback functions with pybind11 module\nDESCRIPTION: This snippet shows how to include pybind11's functional header and define Python bindings for the earlier C++ functions, making them accessible in Python under the module 'example'.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/functional.rst#_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <pybind11/functional.h>\n\nPYBIND11_MODULE(example, m) {\n    m.def(\"func_arg\", &func_arg);\n    m.def(\"func_ret\", &func_ret);\n    m.def(\"func_cpp\", &func_cpp);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Python Class with Static Property Using pybind11 in C++\nDESCRIPTION: This snippet shows how to declare a Python class 'Foo' in C++ using pybind11, with a static property 'foo'. The first version emits a deprecation warning and requires the 'py::metaclass()' attribute, whereas the updated version removes it, simplifying static property declaration. Dependencies include the pybind11 library, and the class should inherit from 'py::class_<Foo>'.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/upgrade.rst#_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\n// old -- emits a deprecation warning\npy::class_<Foo>(m, \"Foo\", py::metaclass())\n    .def_property_readonly_static(\"foo\", ...);\n```\n\nLANGUAGE: C++\nCODE:\n```\n// new -- static properties work without the attribute\npy::class_<Foo>(m, \"Foo\")\n    .def_property_readonly_static(\"foo\", ...);\n```\n\n----------------------------------------\n\nTITLE: Using EigenDRef to Handle Non-Contiguous Arrays\nDESCRIPTION: Example of using py::EigenDRef to handle numpy array slices, allowing operations on non-contiguous memory layouts.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/eigen.rst#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nm.def(\"scale\", [](py::EigenDRef<Eigen::MatrixXd> m, double c) { m *= c; });\n```\n\n----------------------------------------\n\nTITLE: Binding C++ Function with Reference Arg using Lambda Wrapper (C++)\nDESCRIPTION: Shows how to bind the C++ function `foo` using pybind11. A lambda function wraps the call to `foo`, capturing both the original return value and the modified argument. It then returns them as a Python tuple (`std::make_tuple`), providing a workaround for the inability to modify immutable Python arguments directly. Requires pybind11 headers and `<tuple>`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/faq.rst#_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"foo\", [](int i) { int rv = foo(i); return std::make_tuple(rv, i); });\n```\n\n----------------------------------------\n\nTITLE: Alternative std::cout Redirection with Call Guard\nDESCRIPTION: This snippet demonstrates the usage of `py::call_guard` to redirect both `std::cout` and `std::cerr` to Python streams.  It uses `py::scoped_ostream_redirect` and `py::scoped_estream_redirect` which is the same as  `py::scoped_ostream_redirect` but redirects `std::cerr` to `sys.stderr`. The function `noisy_func` is guarded by the redirectors.  The input is the `std::cout` and `std::cerr` stream, and redirects output to the corresponding Python streams.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/utilities.rst#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n// Alternative: Call single function using call guard\nm.def(\"noisy_func\", &call_noisy_function,\n      py::call_guard<py::scoped_ostream_redirect,\n                     py::scoped_estream_redirect>());\n```\n\n----------------------------------------\n\nTITLE: Defining Python Pickling Support for a C++ Class with pybind11 in C++\nDESCRIPTION: This snippet demonstrates how to add Python pickle serialization support to a C++ class using pybind11's py::pickle interface. The __getstate__ lambda returns a tuple representing the state of the object (value and extra attributes), while __setstate__ reconstructs an instance from the tuple, ensuring the state tuple has exactly two elements. The snippet includes error checking and handling of state restoration. Required dependencies include pybind11 and the Pickleable C++ class definition with value and extra members. This enables serialization and deserialization of Pickleable instances from Python with standard pickle protocols, improving interoperability and usability.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_26\n\nLANGUAGE: C++\nCODE:\n```\n.def(\"value\", &Pickleable::value)\n.def(\"extra\", &Pickleable::extra)\n.def(\"setExtra\", &Pickleable::setExtra)\n.def(py::pickle(\n    [](const Pickleable &p) { // __getstate__\n        /* Return a tuple that fully encodes the state of the object */\n        return py::make_tuple(p.value(), p.extra());\n    },\n    [](py::tuple t) { // __setstate__\n        if (t.size() != 2)\n            throw std::runtime_error(\"Invalid state!\");\n\n        /* Create a new C++ instance */\n        Pickleable p(t[0].cast<std::string>());\n\n        /* Assign any additional state */\n        p.setExtra(t[1].cast<int>());\n\n        return p;\n    }\n))\n```\n\n----------------------------------------\n\nTITLE: Creating an Example Object using unique_ptr in C++\nDESCRIPTION: This snippet presents a function `create_example` that constructs an instance of a class `Example` using std::unique_ptr. It illustrates the basic usage of unique_ptr for managing object ownership. The function is then bound to the Python environment through pybind11, making it accessible from Python code. It will work as expected when using py::class_<Example>.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/smart_ptrs.rst#_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nstd::unique_ptr<Example> create_example() { return std::unique_ptr<Example>(new Example()); }\n```\n\n----------------------------------------\n\nTITLE: Selecting Overloaded Functions with pybind11 using py::overload_cast in C++\nDESCRIPTION: Demonstrates how to use the py::overload_cast operator introduced in pybind11 to select among multiple function overloads when binding C++ functions to Python. This feature requires a C++14-capable compiler and enables concise disambiguation of overloaded member functions within the class_ binding syntax. The snippet shows binding two overloaded 'set' methods of a Pet class, one accepting an int and the other a const std::string&. This improves clarity and removes prior ambiguity in bindings.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_61\n\nLANGUAGE: cpp\nCODE:\n```\npy::class_<Pet>(m, \"Pet\")\n    .def(\"set\", py::overload_cast<int>(&Pet::set), \"Set the pet's age\")\n    .def(\"set\", py::overload_cast<const std::string &>(&Pet::set), \"Set the pet's name\");\n```\n\n----------------------------------------\n\nTITLE: Initializing a Class with py::class_ and smart_holder\nDESCRIPTION: This snippet demonstrates how to replace the default holder type with py::smart_holder when defining a pybind11 class.  It simplifies the use of safer and more versatile smart pointer handling. The primary change involves replacing py::class_<T> with py::class_<T, py::smart_holder> or its shorthand py::classh<T>.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/smart_ptrs.rst#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n* ``py::class_<T>`` to\n\n* ``py::class_<T, py::smart_holder>``.\n```\n\n----------------------------------------\n\nTITLE: Overriding Virtual Methods with Macros in pybind11 (C++)\nDESCRIPTION: This snippet highlights the limitations of C preprocessor macros with template types that contain commas, such as with pybind11's PYBIND11_OVERRIDE macro. It provides an example of the problematic usage and offers two solutions: defining type aliases for template arguments before macro invocation, or wrapping template types with the PYBIND11_TYPE macro to avoid incorrect macro argument splitting. These patterns are necessary when binding C++ template-based return types or parent classes to Python using pybind11.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/misc.rst#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nPYBIND11_OVERRIDE(MyReturnType<T1, T2>, Class<T3, T4>, func)\n```\n\nLANGUAGE: C++\nCODE:\n```\n// Version 1: using a type alias\nusing ReturnType = MyReturnType<T1, T2>;\nusing ClassType = Class<T3, T4>;\nPYBIND11_OVERRIDE(ReturnType, ClassType, func);\n```\n\nLANGUAGE: C++\nCODE:\n```\n// Version 2: using the PYBIND11_TYPE macro:\nPYBIND11_OVERRIDE(PYBIND11_TYPE(MyReturnType<T1, T2>),\n                  PYBIND11_TYPE(Class<T3, T4>), func)\n```\n\n----------------------------------------\n\nTITLE: Wrapping Native Python List with pybind11 in C++\nDESCRIPTION: This C++ snippet demonstrates wrapping a native Python list in a pybind11 py::list proxy object within C++ code. The function iterates over the Python list items and outputs each element to the standard output stream. The Python list is not converted or copied; it is accessed via the py::list wrapper, which retains reference counting and Python object semantics. Requires including pybind11 headers and using pybind11 namespace features. Input is a Python list object; output is printed elements to the console.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/overview.rst#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvoid print_list(py::list my_list) {\n    for (auto item : my_list)\n        std::cout << item << \" \";\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a C++ Class with Multiple Inheritance Bindings in pybind11 in C++\nDESCRIPTION: This snippet illustrates how to define a pybind11 binding for a C++ class that inherits from multiple base classes by listing all base types as template parameters to py::class_. It shows the flexibility to list base types in any order and combine them with alias or holder types. If only one base type is specified but multiple inheritance is present in the C++ class, the multiple_inheritance tag must be added to avoid undefined behavior. The snippet requires pybind11 and properly defined C++ base classes. This enables comprehensive Python bindings for complex C++ class hierarchies.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_28\n\nLANGUAGE: C++\nCODE:\n```\npy::class_<MyType, BaseType1, BaseType2, BaseType3>(m, \"MyType\")\n   ...\n```\n\n----------------------------------------\n\nTITLE: Shorthand for Default Arguments in pybind11 Bindings (C++)\nDESCRIPTION: This snippet shows both standard and shorthand literal notation for default arguments in pybind11 bindings. Inputs: two integers (optional, with defaults). Outputs: sum. This is purely binding syntax, actual function implementation is not shown here.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/basics.rst#_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\n// regular notation\nm.def(\"add1\", &add, py::arg(\"i\") = 1, py::arg(\"j\") = 2);\n// shorthand\nm.def(\"add2\", &add, \"i\"_a=1, \"j\"_a=2);\n```\n\n----------------------------------------\n\nTITLE: Binding the create_example Function with pybind11\nDESCRIPTION: This snippet demonstrates how to bind the create_example function to Python using pybind11. The `m.def()` function is used to expose the C++ function to Python with the name \"create_example\". This enables Python code to call the C++ create_example function, receiving the returned unique_ptr.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/smart_ptrs.rst#_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"create_example\", &create_example);\n```\n\n----------------------------------------\n\nTITLE: Binding Overloaded Methods with Constness using py::overload_cast\nDESCRIPTION: This C++ snippet demonstrates how to bind overloaded methods differentiated by constness using `py::overload_cast` and `py::const_`. It shows a class `Widget` with two versions of `foo`, one const and one mutable, and how to expose both to Python. Relies on pybind11.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Widget {\n    int foo(int x, float y);\n    int foo(int x, float y) const;\n};\n\npy::class_<Widget>(m, \"Widget\")\n   .def(\"foo_mutable\", py::overload_cast<int, float>(&Widget::foo))\n   .def(\"foo_const\",   py::overload_cast<int, float>(&Widget::foo, py::const_));\n```\n\n----------------------------------------\n\nTITLE: Initial pybind11 Bindings for Classes\nDESCRIPTION: This snippet shows the basic pybind11 bindings for the `Animal` and `Dog` classes, including the function `call_go`. These initial bindings are not extensible as `Animal` cannot be constructed directly.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nPYBIND11_MODULE(example, m) {\n    py::class_<Animal>(m, \"Animal\")\n        .def(\"go\", &Animal::go);\n\n    py::class_<Dog, Animal>(m, \"Dog\")\n        .def(py::init<>());\n\n    m.def(\"call_go\", &call_go);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Once Using call_once - C++\nDESCRIPTION: This snippet utilizes `absl::call_once`, the ready-made solution for \"once\" initialization provided by the Abseil library (and similar to `std::call_once`). It takes an `once_flag` and a function `f` as arguments.  The `call_once` function ensures that `f` is executed only once across all threads. The `once_flag` itself is a lightweight type, often more efficient than mutex-based solutions. Requires including `<absl/synchronization.h>`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/deadlock.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\n// The \"once\" mechanism:\nconstinit absl::once_flag init_flag;\n\n// The operation of interest:\nvoid f();\n\nvoid InitOnceWithCallOnce() {\n  absl::call_once(once_flag, f);\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Class Methods with Template Parameters in C++\nDESCRIPTION: Demonstrates binding class methods that have template parameters by explicitly specifying each template instantiation that should be exposed to Python.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_38\n\nLANGUAGE: cpp\nCODE:\n```\ntypename <typename T>\nstruct MyClass {\n    template <typename V>\n    T fn(V v);\n};\n\npy::class_<MyClass<int>>(m, \"MyClassT\")\n    .def(\"fn\", &MyClass<int>::fn<std::string>);\n```\n\n----------------------------------------\n\nTITLE: Handling Methods with Output Arguments Using get_override in pybind11\nDESCRIPTION: Explains using 'get_override' within trampoline methods to invoke Python overrides for C++ methods with reference output arguments, facilitating return of different data types (e.g., None or int) in Python for complex signatures.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_16\n\nLANGUAGE: C++\nCODE:\n```\nbool MyClass::myMethod(int32_t& value)\n{\n    pybind11::gil_scoped_acquire gil;  // Acquire the GIL while in this scope.\n    pybind11::function override = pybind11::get_override(this, \"myMethod\");\n    if (override) {  // method is found\n        auto obj = override(value);  // Call the Python function.\n        if (py::isinstance<py::int_>(obj)) {  // check if it returned a Python integer type\n            value = obj.cast<int32_t>();  // Cast it and assign it to the value.\n            return true;  // Return true; value should be used.\n        } else {\n            return false;  // Python returned none, return false.\n        }\n    }\n    return false;  // Alternatively return MyClass::myMethod(value);\n}\n```\n\n----------------------------------------\n\nTITLE: NumPy Ellipsis Slicing with pybind11 (C++)\nDESCRIPTION: Shows how to replicate Python's ellipsis slicing for NumPy arrays within C++ using `py::ellipsis()` and `py::make_tuple`. This allows accessing elements of a `py::array` using mixed integer indices and ellipsis. Requires `pybind11/pybind11.h` and `pybind11/numpy.h`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\npy::array a = /* A NumPy array */;\npy::array b = a[py::make_tuple(0, py::ellipsis(), 0)];\n```\n\n----------------------------------------\n\nTITLE: Defining a C++ Class and Function with Safe Global Interpreter Lock Handling (pybind11, C++)\nDESCRIPTION: This snippet demonstrates declaring a trampoline (wrapper) class for virtual method overriding with pybind11 and illustrates registering a factory and a function in a Python module. The function call_go is exported such that it explicitly releases the GIL to allow parallel execution of long-running C++ code segments. The snippet emphasizes the importance of acquiring and releasing the GIL when C++ code may access Python state, and how to safeguard these operations when integrating Python and C++ threading via pybind11.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/misc.rst#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nclass PyAnimal : public Animal, py::trampoline_self_life_support {\npublic:\n    /* Inherit the constructors */\n    using Animal::Animal;\n\n    /* Trampoline (need one for each virtual function) */\n    std::string go(int n_times) {\n        /* PYBIND11_OVERRIDE_PURE will acquire the GIL before accessing Python state */\n        PYBIND11_OVERRIDE_PURE(\n            std::string, /* Return type */\n            Animal,      /* Parent class */\n            go,          /* Name of function */\n            n_times      /* Argument(s) */\n        );\n    }\n};\n\nPYBIND11_MODULE(example, m) {\n    py::class_<Animal, PyAnimal, py::smart_holder> animal(m, \"Animal\");\n    animal\n        .def(py::init<>())\n        .def(\"go\", &Animal::go);\n\n    py::class_<Dog, py::smart_holder>(m, \"Dog\", animal)\n        .def(py::init<>());\n\n    m.def(\"call_go\", [](Animal *animal) -> std::string {\n        // GIL is held when called from Python code. Release GIL before\n        // calling into (potentially long-running) C++ code\n        py::gil_scoped_release release;\n        return call_go(animal);\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Binding C++ Enumerations with custom Python enum type name and docstring\nDESCRIPTION: This code snippet binds the C++ enum `Pet::Kind` to the Python type `enum.IntEnum` and provides a class docstring. `py::native_enum` allows the enum values to be exported into the parent scope, if desired. Depends on pybind11.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\npy::native_enum<Pet::Kind>(pet, \"Kind\", \"enum.IntEnum\", \"Constant specifying the kind of pet\")\n```\n\n----------------------------------------\n\nTITLE: Summing/Incrementing 3D Array with Unchecked Access (C++)\nDESCRIPTION: Demonstrates using `unchecked<N>` and `mutable_unchecked<N>` for high-performance, bounds-check-free access to NumPy array elements in C++. Defines two lambda functions bound via pybind11: `sum_3d` reads a 3D array using `unchecked<3>` for summation, and `increment_3d` modifies a 3D array using `mutable_unchecked<3>`. Requires `pybind11/pybind11.h` and `pybind11/numpy.h`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"sum_3d\", [](py::array_t<double> x) {\n    auto r = x.unchecked<3>(); // x must have ndim = 3; can be non-writeable\n    double sum = 0;\n    for (py::ssize_t i = 0; i < r.shape(0); i++)\n        for (py::ssize_t j = 0; j < r.shape(1); j++)\n            for (py::ssize_t k = 0; k < r.shape(2); k++)\n                sum += r(i, j, k);\n    return sum;\n});\nm.def(\"increment_3d\", [](py::array_t<double> x) {\n    auto r = x.mutable_unchecked<3>(); // Will throw if ndim != 3 or flags.writeable is false\n    for (py::ssize_t i = 0; i < r.shape(0); i++)\n        for (py::ssize_t j = 0; j < r.shape(1); j++)\n            for (py::ssize_t k = 0; k < r.shape(2); k++)\n                r(i, j, k) += 1.0;\n}, py::arg().noconvert());\n```\n\n----------------------------------------\n\nTITLE: Implementing __getstate__ and __setstate__ for Pickling in pybind11\nDESCRIPTION: This snippet illustrates the transition from deprecated to preferred pickling pattern in pybind11. The old style uses explicit __getstate__ and __setstate__ functions, while the new method employs py::pickle() with lambda functions for serialization and deserialization, enhancing compatibility and clarity.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/upgrade.rst#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n// old -- deprecated (runtime warning shown only in debug mode)\npy::class<Foo>(m, \"Foo\")\n    ...\n    .def(\"__getstate__\", [](const Foo &self) {\n        return py::make_tuple(self.value1(), self.value2(), ...);\n    })\n    .def(\"__setstate__\", [](Foo &self, py::tuple t) {\n        new (&self) Foo(t[0].cast<std::string>(), ...);\n    });\n\n// new\npy::class<Foo>(m, \"Foo\")\n    ...\n    .def(py::pickle(\n        [](const Foo &self) { // __getstate__\n            return py::make_tuple(self.value1(), self.value2(), ...); // unchanged\n        },\n        [](py::tuple t) { // __setstate__, note: no `self` argument\n            return new Foo(t[0].cast<std::string>(), ...);\n            // or: return std::make_unique<Foo>(...); // return by holder\n            // or: return Foo(...); // return by value (move constructor)\n        }\n    ));\n```\n\n----------------------------------------\n\nTITLE: Inheriting from Multiple C++ Bases in Python using pybind11\nDESCRIPTION: Illustrates how a Python class can inherit from multiple C++ base classes exposed via pybind11. The example defines `PyDerived` inheriting from `CppBase1` and `CppBase2`, showing the requirement to explicitly call the respective base class `__init__` methods.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_54\n\nLANGUAGE: python\nCODE:\n```\nfrom cpp_module import CppBase1, CppBase2\n\n\nclass PyDerived(CppBase1, CppBase2):\n    def __init__(self):\n        CppBase1.__init__(self)  # C++ bases must be initialized explicitly\n        CppBase2.__init__(self)\n```\n\n----------------------------------------\n\nTITLE: Binding a Vectorized Function for NumPy Array Inputs Using pybind11 - C++\nDESCRIPTION: This code exposes a C++ function, my_func, as a vectorized Python function using py::vectorize. When called from Python with array arguments, the function is evaluated elementwise over the inputs, producing a NumPy array output. Requires pybind11/numpy.h and my_func definition. Inputs: int/float/double or arrays thereof; Output: NumPy array of doubles. No manual loops needed.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nm.def(\"vectorized_func\", py::vectorize(my_func));\n```\n\n----------------------------------------\n\nTITLE: Binding Classes with Template Parameters in C++\nDESCRIPTION: Shows how to properly bind C++ templated classes by explicitly binding each template instantiation separately, as templates can only be instantiated at compile time.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_37\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Cat {};\nstruct Dog {};\n\ntemplate <typename PetType>\nstruct Cage {\n    Cage(PetType& pet);\n    PetType& get();\n};\n\n// ok\npy::class_<Cage<Cat>>(m, \"CatCage\")\n    .def(\"get\", &Cage<Cat>::get);\n\n// ok\npy::class_<Cage<Dog>>(m, \"DogCage\")\n    .def(\"get\", &Cage<Dog>::get);\n```\n\n----------------------------------------\n\nTITLE: Template-Based Virtual Method Trampoline Class for Generic Virtual Overrides in C++\nDESCRIPTION: Defines template trampoline classes 'PyAnimal' and 'PyDog' for reusing overriding logic across base classes. This approach minimizes duplication by using template parameters and reduces the number of trampoline methods needed for each virtual function.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\ntemplate <class AnimalBase = Animal>\nclass PyAnimal : public AnimalBase, py::trampoline_self_life_support {\npublic:\n    using AnimalBase::AnimalBase; // Inherit constructors\n    std::string go(int n_times) override { PYBIND11_OVERRIDE_PURE(std::string, AnimalBase, go, n_times); }\n    std::string name() override { PYBIND11_OVERRIDE(std::string, AnimalBase, name, ); }\n};\n\ntemplate <class DogBase = Dog>\nclass PyDog : public PyAnimal<DogBase>, py::trampoline_self_life_support {\npublic:\n    using PyAnimal<DogBase>::PyAnimal; // Inherit constructors\n    // Override PyAnimal's pure virtual go() with a non-pure one:\n    std::string go(int n_times) override { PYBIND11_OVERRIDE(std::string, DogBase, go, n_times); }\n    std::string bark() override { PYBIND11_OVERRIDE(std::string, DogBase, bark, ); }\n};\n```\n\n----------------------------------------\n\nTITLE: Tagging a Single-Base C++ pybind11 Class to Support Multiple Inheritance in C++\nDESCRIPTION: This snippet demonstrates the addition of the py::multiple_inheritance() tag when binding a C++ class with multiple bases but only specifying one base type in the pybind11 binding declaration. This tag signals pybind11 that multiple inheritance applies, preventing undefined behavior. This snippet depends on pybind11 and a C++ class with multiple inheritance. It ensures correct binding semantics for classes with complex base hierarchies when not all base classes are exposed in bindings.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_29\n\nLANGUAGE: C++\nCODE:\n```\npy::class_<MyType, BaseType2>(m, \"MyType\", py::multiple_inheritance());\n```\n\n----------------------------------------\n\nTITLE: Including Pybind11 in CMake Projects\nDESCRIPTION: Two methods for incorporating Pybind11 into CMake projects. The first approach uses add_subdirectory to include Pybind11 directly into the build, while the second uses find_package to locate an installed Pybind11 package.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/cmake/index.rst#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(extern/pybind11)\n```\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(pybind11 CONFIG)\n```\n\n----------------------------------------\n\nTITLE: Adding NumPy Arrays with Manual Buffer Access (C++)\nDESCRIPTION: Defines a C++ function `add_arrays` using pybind11 to add two 1D NumPy arrays of doubles. It manually requests buffer information (`py::buffer_info`), checks dimensions and shapes, allocates a result array, accesses raw data pointers (`.ptr`), performs element-wise addition, and returns the new NumPy array. Requires `pybind11/pybind11.h` and `pybind11/numpy.h` headers.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\n#include <pybind11/pybind11.h>\n#include <pybind11/numpy.h>\n\nnamespace py = pybind11;\n\npy::array_t<double> add_arrays(py::array_t<double> input1, py::array_t<double> input2) {\n    py::buffer_info buf1 = input1.request(), buf2 = input2.request();\n\n    if (buf1.ndim != 1 || buf2.ndim != 1)\n        throw std::runtime_error(\"Number of dimensions must be one\");\n\n    if (buf1.size != buf2.size)\n        throw std::runtime_error(\"Input shapes must match\");\n\n    /* No pointer is passed, so NumPy will allocate the buffer */\n    auto result = py::array_t<double>(buf1.size);\n\n    py::buffer_info buf3 = result.request();\n\n    double *ptr1 = static_cast<double *>(buf1.ptr);\n    double *ptr2 = static_cast<double *>(buf2.ptr);\n    double *ptr3 = static_cast<double *>(buf3.ptr);\n\n    for (size_t idx = 0; idx < buf1.shape[0]; idx++)\n        ptr3[idx] = ptr1[idx] + ptr2[idx];\n\n    return result;\n}\n\nPYBIND11_MODULE(test, m) {\n    m.def(\"add_arrays\", &add_arrays, \"Add two NumPy arrays\");\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Vectorizable Function in C++\nDESCRIPTION: This snippet shows a typical C++ function prototype that can be vectorized for Python-side use via pybind11. The function takes primitive arguments and returns a double. No dependencies; intended to illustrate a vectorization use case.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\ndouble my_func(int x, float y, double z);\n```\n\n----------------------------------------\n\nTITLE: Modifying a Vector by Reference in C++\nDESCRIPTION: Function that demonstrates modifying an Eigen vector passed by reference, which will directly modify the underlying NumPy array when called from Python.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/eigen.rst#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvoid scale_by_2(Eigen::Ref<Eigen::VectorXd> v) {\n    v *= 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Binding C++ Classes with Private or Protected Destructors Using py::nodelete in pybind11 (C++)\nDESCRIPTION: Illustrates how to bind C++ classes with non-public (private or protected) destructors using pybind11 by specifying a custom holder type: std::unique_ptr with the py::nodelete deleter. This approach disables pybind11's automatic destructor calls and requires manual instance lifetime management to avoid memory leaks. The snippet defines a class MyClass with a private destructor and binds it with the custom holder to allow successful compilation. The example depends on including pybind11 and using std::unique_ptr with the nodelete policy.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_20\n\nLANGUAGE: cpp\nCODE:\n```\n/* ... definition ... */\n\nclass MyClass {\nprivate:\n    ~MyClass() { }\n};\n\n/* ... binding code ... */\n\npy::class_<MyClass, std::unique_ptr<MyClass, py::nodelete>>(m, \"MyClass\")\n    .def(py::init<>())\n```\n\n----------------------------------------\n\nTITLE: Chaining Exceptions with `py::raise_from`\nDESCRIPTION: This snippet shows how to chain exceptions in pybind11 using `py::raise_from`. It catches a `py::error_already_set` exception, sets a new Python exception using `py::raise_from` linking it to the original exception, and then re-throws the exception. This will create a chained exception in Python using the `raise ... from ...` syntax.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/exceptions.rst#_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\ntry {\n    py::eval(\"print(1 / 0\");\n} catch (py::error_already_set &e) {\n    py::raise_from(e, PyExc_RuntimeError, \"could not divide by zero\");\n    throw py::error_already_set();\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Raw Binary Data from C++ to Python as bytes with pybind11\nDESCRIPTION: Defines a C++ function that returns raw non-UTF-8 data encapsulated as py::bytes object, thereby returning Python bytes without any encoding or decoding. Useful when std::string does not represent text data. Shows how to create a std::string with invalid UTF-8 byte sequences and return it as bytes explicitly.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/strings.rst#_snippet_6\n\nLANGUAGE: c++\nCODE:\n```\nm.def(\"return_bytes\",\n    []() {\n        std::string s(\"\\xba\\xd0\\xba\\xd0\");  // Not valid UTF-8\n        return py::bytes(s);  // Return the data without transcoding\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Python Example of Subclassing the C++ 'Dog' Class\nDESCRIPTION: Provides a Python example where a class 'ShihTzu' inherits from the bound C++ 'Dog' class and overrides the 'bark' method to return a specific string. Enables Python customization of C++ virtual methods.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\nclass ShihTzu(Dog):\n    def bark(self):\n        return \"yip!\"\n```\n\n----------------------------------------\n\nTITLE: Naive Static Initialization in CPython Callback (C++)\nDESCRIPTION: Demonstrates a simple CPython callback function initializing a static `PyObject*` using `CreateWidget`. This approach is potentially unsafe because the GIL is held on entry, and the implicit static variable guard mutex is acquired subsequently. This can lead to deadlocks if `CreateWidget` releases and reacquires the GIL, violating the required lock order.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/deadlock.md#_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\n// CPython callback, assumes that the GIL is held on entry.\nPyObject* InvokeWidget(PyObject* self) {\n  static PyObject* impl = CreateWidget();\n  return PyObject_CallOneArg(impl, self);\n}\n```\n\n----------------------------------------\n\nTITLE: Command-line Options for Python Version Selection in CMake\nDESCRIPTION: Examples of command-line options for specifying the target Python version or executable when building pybind11 projects with CMake. Useful for environments with multiple Python installations.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ncmake -DPYBIND11_PYTHON_VERSION=3.8 ..\n\n# Another method:\ncmake -DPYTHON_EXECUTABLE=/path/to/python ..\n\n# This often is a good way to get the current Python, works in environments:\ncmake -DPYTHON_EXECUTABLE=$(python3 -c \"import sys; print(sys.executable)\") ..\n```\n\n----------------------------------------\n\nTITLE: PyAnimal and PyDog Trampoline Class Definitions\nDESCRIPTION: This code snippet shows the trampoline classes for both `Animal` and `Dog` classes with both `go()` and `name()` method overrides, crucial for virtual function overriding through inheritance. It correctly handles overridden functions in parent and child classes when creating python bindings.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nclass PyAnimal : public Animal, py::trampoline_self_life_support {\npublic:\n    using Animal::Animal; // Inherit constructors\n    std::string go(int n_times) override { PYBIND11_OVERRIDE_PURE(std::string, Animal, go, n_times); }\n    std::string name() override { PYBIND11_OVERRIDE(std::string, Animal, name, ); }\n};\nclass PyDog : public Dog, py::trampoline_self_life_support {\npublic:\n    using Dog::Dog; // Inherit constructors\n    std::string go(int n_times) override { PYBIND11_OVERRIDE(std::string, Dog, go, n_times); }\n    std::string name() override { PYBIND11_OVERRIDE(std::string, Dog, name, ); }\n};\n\n```\n\n----------------------------------------\n\nTITLE: Returning UTF-8 std::string to Python as str Using pybind11 in C++\nDESCRIPTION: Defines a C++ function returning a UTF-8 encoded std::string which pybind11 converts automatically to a Python str by decoding the UTF-8 bytes. If decoding fails, a UnicodeDecodeError is raised. This snippet assumes valid UTF-8 data and null-terminated C strings. It demonstrates a zero-argument lambda returning a constant std::string in the pybind11 module context.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/strings.rst#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nm.def(\"std_string_return\",\n    []() {\n        return std::string(\"This string needs to be UTF-8 encoded\");\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Setting C++ Standard in CMake for pybind11 Projects\nDESCRIPTION: Example showing how to explicitly set the C++ standard for pybind11 modules in CMake. This ensures compatibility and enables modern C++ features as needed for the project.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\nset(CMAKE_CXX_STANDARD 14 CACHE STRING \"C++ version selection\")  # or 11, 14, 17, 20\nset(CMAKE_CXX_STANDARD_REQUIRED ON)  # optional, ensure standard is supported\nset(CMAKE_CXX_EXTENSIONS OFF)  # optional, keep compiler extensions off\n```\n\n----------------------------------------\n\nTITLE: Adding ostream Redirect for Python Context Manager\nDESCRIPTION: This snippet shows how to add a context manager in Python for redirecting streams using `py::add_ostream_redirect`.  This allows C++ output to be redirected to Python's standard output and standard error streams. The name defaults to \"ostream_redirect\". It allows you to selectively redirect either `stdout` or `stderr` using keyword arguments. This enables context-managed stream redirection in Python. Input is the module where the context manager is to be added. Output is the creation of a Python context manager.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/utilities.rst#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\npy::add_ostream_redirect(m, \"ostream_redirect\");\n```\n\n----------------------------------------\n\nTITLE: Defining a Python-Compatible 'Husky' Class in C++ with Virtual Overrides\nDESCRIPTION: Creates a derived class 'PyHusky' from 'Husky' with Python bindings, overriding virtual methods 'go', 'name', and 'bark' via PYBIND11_OVERRIDE macros to enable Python subclassing. This trampoline class ensures proper virtual method dispatch in Python.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nclass PyHusky : public Husky, py::trampoline_self_life_support {\npublic:\n    using Husky::Husky; // Inherit constructors\n    std::string go(int n_times) override { PYBIND11_OVERRIDE_PURE(std::string, Husky, go, n_times); }\n    std::string name() override { PYBIND11_OVERRIDE(std::string, Husky, name, ); }\n    std::string bark() override { PYBIND11_OVERRIDE(std::string, Husky, bark, ); }\n};\n```\n\n----------------------------------------\n\nTITLE: Python Usage Example for pybind11 C++ Wrapped List Function\nDESCRIPTION: This pycon snippet shows how the previously defined C++ function accepting a py::list is called from Python. The Python list [1, 2, 3] is passed directly to the C++ wrapped function, which iterates and prints each element. This illustrates seamless passing of Python native lists without conversion to C++ native containers.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/overview.rst#_snippet_1\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print_list([1, 2, 3])\n1 2 3\n```\n\n----------------------------------------\n\nTITLE: Binding C++ Class with Vector Member using def_readwrite C++\nDESCRIPTION: pybind11 code to bind the `MyClass` C++ class. It exposes the `contents` member, which is a `std::vector<int>`, using `py::def_readwrite`. This allows Python code to read and write the entire vector property, but does not enable in-place modifications from the Python side due to copying.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/stl.rst#_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n/* ... binding code ... */\n\npy::class_<MyClass>(m, \"MyClass\")\n    .def(py::init<>())\n    .def_readwrite(\"contents\", &MyClass::contents);\n```\n\n----------------------------------------\n\nTITLE: Importing and accessing Python Libraries (C++)\nDESCRIPTION: These code snippets demonstrate importing Python modules and accessing their attributes (like classes and functions) from C++ using pybind11. The first snippet imports the `decimal` module and retrieves the `Decimal` class, simulating an equivalent of `from decimal import Decimal` in Python.  The second snippet attempts to import scipy.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/object.rst#_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n// Equivalent to \"from decimal import Decimal\"\npy::object Decimal = py::module_::import(\"decimal\").attr(\"Decimal\");\n```\n\nLANGUAGE: cpp\nCODE:\n```\n// Try to import scipy\npy::object scipy = py::module_::import(\"scipy\");\nreturn scipy.attr(\"__version__\");\n```\n\n----------------------------------------\n\nTITLE: Enhancements to py::init and Error Checking\nDESCRIPTION: This snippet emphasizes stricter compile-time checks for constructor bindings using py::init. It prevents improper overloads, such as binding non-const lvalue references to rvalues, catching errors early during compilation rather than at runtime.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/upgrade.rst#_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\n// Example of strict py::init usage\nstruct Example {\n    Example(int &);\n};\n\npy::class_<Example>(m, \"Example\")\n    .def(py::init<int &>()); // OK\n    // .def(py::init<int>()); // compile-time error\n```\n\n----------------------------------------\n\nTITLE: Python class Cat example\nDESCRIPTION: This Python code demonstrates how to override the `go()` method of the bound `Animal` class in Python, and use the bound C++ function `call_go()` on a Python created `Cat` instance.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_6\n\nLANGUAGE: pycon\nCODE:\n```\n>>> from example import *\n>>> d = Dog()\n>>> call_go(d)\n'woof! woof! woof! '\n>>> class Cat(Animal):\n...     def go(self, n_times):\n...         return \"meow! \" * n_times\n...\n>>> c = Cat()\n>>> call_go(c)\n'meow! meow! meow! '\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Limitations of Handling Unicode Grapheme Clusters in C++ Character Literals with pybind11\nDESCRIPTION: Shows Python examples illustrating the problem of passing combined Unicode grapheme clusters (multiple Unicode code points forming one visual character) as a single character literal parameter to C++ char/wchar_t, which truncates or loses the combining character. Suggests pre-normalizing strings with unicodedata.normalize to NFC form to improve compatibility. Explains the inability to capture certain grapheme clusters that are not single Unicode code points.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/strings.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> example.pass_wchar(\"é\")\n'é'\n\n>>> combining_e_acute = \"e\" + \"\\u0301\"\n\n>>> combining_e_acute\n'é'\n\n>>> combining_e_acute == \"é\"\nFalse\n\n>>> example.pass_wchar(combining_e_acute)\n'e'\n\n>>> example.pass_wchar(unicodedata.normalize(\"NFC\", combining_e_acute))\n'é'\n```\n\n----------------------------------------\n\nTITLE: Creating Module-Local Class Bindings to Avoid Conflicts Between pybind11 Modules in C++\nDESCRIPTION: This snippet shows how to use the py::module_local() attribute in pybind11 bindings to localize class bindings per module, thus avoiding conflicts when multiple modules bind the same external C++ class with different interfaces. By passing py::module_local() to the py::class_ constructor, classes with the same C++ type in different modules become distinct Python classes, allowing both modules to coexist without import errors. This approach circumvents the generic_type registration conflict, with the tradeoff that module-local classes are distinct on the Python side and external modules cannot share instances unless they provide their own local bindings. This pattern depends on pybind11 and the external C++ class definitions.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_30\n\nLANGUAGE: C++\nCODE:\n```\n// Pet binding in dogs.cpp:\npy::class_<pets::Pet>(m, \"Pet\", py::module_local())\n    .def(\"name\", &pets::Pet::name);\n\n// Pet binding in cats.cpp:\npy::class_<pets::Pet>(m, \"Pet\", py::module_local())\n    .def(\"get_name\", &pets::Pet::name);\n```\n\n----------------------------------------\n\nTITLE: Explicit Conversion of Non-UTF-8 std::string to Python str Using Python C API in pybind11 C++\nDESCRIPTION: Provides an example where a C++ std::string encoded in Latin-1 is manually converted to a Python unicode string by invoking PyUnicode_DecodeLatin1 from the Python C API. The py::reinterpret_steal template is used to cast the returned Python object to a py::str with proper reference management. This allows returning non-UTF-8 data as Python str explicitly. Requires Python C API linked and error handling using py::error_already_set.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/strings.rst#_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\n// This uses the Python C API to convert Latin-1 to Unicode\nm.def(\"str_output\",\n    []() {\n        std::string s = \"Send your r\\xe9sum\\xe9 to Alice in HR\"; // Latin-1\n        py::handle py_s = PyUnicode_DecodeLatin1(s.data(), s.length(), nullptr);\n        if (!py_s) {\n            throw py::error_already_set();\n        }\n        return py::reinterpret_steal<py::str>(py_s);\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Python Usage Example for C++ Function Converting Python List to std::vector\nDESCRIPTION: The pycon snippet demonstrates passing a native Python list [1, 2, 3] to a C++ function that expects a std::vector<int>. pybind11 automatically constructs the vector from the list by copying elements. The function then prints each integer on its own line, validating the conversion and round-trip interoperability.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/overview.rst#_snippet_3\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print_vector([1, 2, 3])\n1\n2\n3\n```\n\n----------------------------------------\n\nTITLE: Specifying Base Class for Exception Translation in C++\nDESCRIPTION: Shows how to specify a base class for the translated Python exception using the third parameter handle.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/exceptions.rst#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\npy::register_exception<CppExp>(module, \"PyExp\", PyExc_RuntimeError);\npy::register_local_exception<CppExp>(module, \"PyExp\", PyExc_RuntimeError);\n```\n\n----------------------------------------\n\nTITLE: Registering Another Global Exception Translator\nDESCRIPTION: This code snippet demonstrates another global exception translator that similarly handles `std::invalid_argument` exceptions by setting a Python `ArgumentError`. The purpose of demonstrating two translators is to highlight the order of application based on module import.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/exceptions.rst#_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\npy::register_exception_translator([](std::exception_ptr p) {\n  try {\n      if (p) std::rethrow_exception(p);\n  } catch (const std::invalid_argument &e) {\n      py::set_error(PyExc_ArgumentError, \"module2 handled this\");\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Custom Smart Pointer Holder Type with Intrusive Ref Counting\nDESCRIPTION: This code snippet demonstrates the use of the optional third argument, set to true, within the PYBIND11_DECLARE_HOLDER_TYPE macro.  This configuration is essential when the `SmartPtr<T>` can always be initialized from a `T*` without the risk of inconsistency, such as in intrusive reference counting.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/smart_ptrs.rst#_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nPYBIND11_DECLARE_HOLDER_TYPE(T, SmartPtr<T>, true)\n```\n\n----------------------------------------\n\nTITLE: Handling Unraisable Exceptions\nDESCRIPTION: This snippet demonstrates how to handle unraisable exceptions in a `noexcept` C++ function.  It catches `py::error_already_set` exceptions and uses `eas.discard_as_unraisable(__func__)` to discard the Python error. It also catches and logs standard C++ exceptions.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/exceptions.rst#_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nvoid nonthrowing_func() noexcept(true) {\n    try {\n        // ...\n    } catch (py::error_already_set &eas) {\n        // Discard the Python error using Python APIs, using the C++ magic\n        // variable __func__. Python already knows the type and value and of the\n        // exception object.\n        eas.discard_as_unraisable(__func__);\n    } catch (const std::exception &e) {\n        // Log and discard C++ exceptions.\n        third_party::log(e);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecation of py::object Pointer Comparison Operators\nDESCRIPTION: This snippet indicates the transition from using operator== to obj1.is(obj2) for comparing py::object pointers. The change clarifies that Python's 'is' semantics are used explicitly, improving code clarity and future compatibility.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/upgrade.rst#_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\n// Usage change:\n// Old: obj1 == obj2\n// New: obj1.is(obj2) // Python 'is' equivalent\n```\n\n----------------------------------------\n\nTITLE: Enabling Copy and Deepcopy Support for a Simple C++ Class with pybind11 in C++\nDESCRIPTION: This snippet shows how to implement Python __copy__ and __deepcopy__ methods for a C++ class using pybind11. By defining __copy__ and __deepcopy__ to invoke the class's copy constructor, shallow and deep copies of the object can be created efficiently from Python's copy module. The __deepcopy__ method takes a Python dictionary memo argument as per Python's deepcopy convention. Dependencies include pybind11 and a C++ Copyable class with a proper copy constructor. Dynamic attributes are not copied in this example, and the approach suits simple classes that are copyable by constructor.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_27\n\nLANGUAGE: C++\nCODE:\n```\npy::class_<Copyable>(m, \"Copyable\")\n    .def(\"__copy__\",  [](const Copyable &self) {\n        return Copyable(self);\n    })\n    .def(\"__deepcopy__\", [](const Copyable &self, py::dict) {\n        return Copyable(self);\n    }, \"memo\"_a);\n```\n\n----------------------------------------\n\nTITLE: Binding C++ Enumerations and Internal Types with Pybind11 (C++)\nDESCRIPTION: This code snippet demonstrates how to bind C++ enumerations and internal types using pybind11's `py::native_enum`. It defines a `Pet` class with an internal `Kind` enum and an `Attributes` struct. `py::native_enum` is used to expose the enum to Python. Depends on pybind11.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Pet {\n    enum Kind {\n        Dog = 0,\n        Cat\n    };\n\n    struct Attributes {\n        float age = 0;\n    };\n\n    Pet(const std::string &name, Kind type) : name(name), type(type) { }\n\n    std::string name;\n    Kind type;\n    Attributes attr;\n};\n\n#include <pybind11/native_enum.h> // Not already included with pybind11.h\n\npy::class_<Pet> pet(m, \"Pet\");\n\npet.def(py::init<const std::string &, Pet::Kind>())\n    .def_readwrite(\"name\", &Pet::name)\n    .def_readwrite(\"type\", &Pet::type)\n    .def_readwrite(\"attr\", &Pet::attr);\n\npy::native_enum<Pet::Kind>(pet, \"Kind\", \"enum.Enum\")\n    .value(\"Dog\", Pet::Kind::Dog)\n    .value(\"Cat\", Pet::Kind::Cat)\n    .export_values()\n    .finalize();\n\npy::class_<Pet::Attributes>(pet, \"Attributes\")\n    .def(py::init<>())\n    .def_readwrite(\"age\", &Pet::Attributes::age);\n```\n\n----------------------------------------\n\nTITLE: Using Sphinx with pybind11 for Automatic Documentation Generation\nDESCRIPTION: This snippet explains how pybind11 can generate documentation with Sphinx by inspecting signatures and docstrings, emphasizing the importance of avoiding tabs in docstrings and using raw string literals for multi-line comments. It also shows how to disable automatic signature generation or enum member documentation using the options class.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/misc.rst#_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nm.def(\"foo\", &foo, R\"mydelimiter(\n    The foo function\n\n    Parameters\n    ----------\n)mydelimiter\");\n```\n\nLANGUAGE: C++\nCODE:\n```\nPYBIND11_MODULE(example, m) {\n    py::options options;\n    options.disable_function_signatures();\n\n    m.def(\"add\", [](int a, int b) { return a + b; }, \"A function which adds two numbers\");\n}\n```\n\nLANGUAGE: C++\nCODE:\n```\n// Disabling enum member documentation\npy::options options;\noptions.disable_enum_members_docstring();\n```\n\nLANGUAGE: C++\nCODE:\n```\n// Disabling user-defined docstrings for module, class, and enum bindings\npy::options options;\noptions.disable_user_defined_docstrings();\n```\n\n----------------------------------------\n\nTITLE: Exposing Protected Methods with the Publicist Pattern in C++\nDESCRIPTION: A technique to expose C++ protected methods to Python by creating a helper 'Publicist' class that inherits from the primary class and changes the access modifier of the protected method.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_34\n\nLANGUAGE: cpp\nCODE:\n```\nclass A {\nprotected:\n    int foo() const { return 42; }\n};\n\nclass Publicist : public A { // helper type for exposing protected functions\npublic:\n    using A::foo; // inherited with different access modifier\n};\n\npy::class_<A>(m, \"A\") // bind the primary class\n    .def(\"foo\", &Publicist::foo); // expose protected methods via the publicist\n```\n\n----------------------------------------\n\nTITLE: Creating and Configuring pybind11 Test Modules in CMake\nDESCRIPTION: Iterates through a list of test targets (initially `pybind11_tests`, potentially extended). For each target, it creates a Python module using `pybind11_add_module`, applies warnings using `pybind11_enable_warnings`, links dependencies like Eigen (`Eigen3::Eigen`), Boost (`Boost::headers`), and the detected filesystem library (`STD_FS_LIB`) if they were found. It configures the output directory, handles MSVC-specific compile options (`/utf-8`), adds installation rules for SKBuild, and applies special compile options (`-fno-exceptions`) for specific targets like `exo_planet_c_api`. It also includes logic to handle CUDA tests by setting the source file language to CUDA if `PYBIND11_CUDA_TESTS` is enabled.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nset(test_targets pybind11_tests)\n\n# Check if any tests need extra targets by iterating through the mappings registered.\nforeach(i ${PYBIND11_TEST_EXTRA_TARGETS})\n  foreach(needle ${PYBIND11_TEST_EXTRA_TARGETS_NEEDLES_${i}})\n    if(needle IN_LIST PYBIND11_PYTEST_FILES)\n      # Add all the additional targets to the test list. List join in newer cmake.\n      foreach(extra_target ${PYBIND11_TEST_EXTRA_TARGETS_ADDITION_${i}})\n        list(APPEND test_targets ${extra_target})\n      endforeach()\n      break() # Breaks out of the needle search, continues with the next mapping.\n    endif()\n  endforeach()\nendforeach()\n\n# Support CUDA testing by forcing the target file to compile with NVCC\nif(PYBIND11_CUDA_TESTS)\n  set_property(SOURCE ${PYBIND11_TEST_FILES} PROPERTY LANGUAGE CUDA)\nendif()\n\nforeach(target ${test_targets})\n  set(test_files ${PYBIND11_TEST_FILES})\n  if(NOT \"${target}\" STREQUAL \"pybind11_tests\")\n    set(test_files \"\")\n  endif()\n\n  # Support CUDA testing by forcing the target file to compile with NVCC\n  if(PYBIND11_CUDA_TESTS)\n    set_property(SOURCE ${target}.cpp PROPERTY LANGUAGE CUDA)\n  endif()\n\n  # Create the binding library\n  pybind11_add_module(${target} THIN_LTO ${target}.cpp ${test_files} ${PYBIND11_HEADERS})\n  pybind11_enable_warnings(${target})\n\n  if(NOT CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_CURRENT_BINARY_DIR)\n    get_property(\n      suffix\n      TARGET ${target}\n      PROPERTY SUFFIX)\n    set(source_output \"${CMAKE_CURRENT_SOURCE_DIR}/${target}${suffix}\")\n    if(suffix AND EXISTS \"${source_output}\")\n      message(WARNING \"Output file also in source directory; \"\n                      \"please remove to avoid confusion: ${source_output}\")\n    endif()\n  endif()\n\n  if(MSVC)\n    target_compile_options(${target} PRIVATE /utf-8)\n  endif()\n\n  if(EIGEN3_FOUND)\n    target_link_libraries(${target} PRIVATE Eigen3::Eigen)\n    target_compile_definitions(${target} PRIVATE -DPYBIND11_TEST_EIGEN)\n  endif()\n\n  if(Boost_FOUND)\n    target_link_libraries(${target} PRIVATE Boost::headers)\n    target_compile_definitions(${target} PRIVATE -DPYBIND11_TEST_BOOST)\n  endif()\n\n  target_link_libraries(${target} PRIVATE ${STD_FS_LIB})\n\n  # Always write the output file directly into the 'tests' directory (even on MSVC)\n  if(NOT CMAKE_LIBRARY_OUTPUT_DIRECTORY)\n    set_target_properties(${target} PROPERTIES LIBRARY_OUTPUT_DIRECTORY\n                                               \"${CMAKE_CURRENT_BINARY_DIR}\")\n\n    if(DEFINED CMAKE_CONFIGURATION_TYPES)\n      foreach(config ${CMAKE_CONFIGURATION_TYPES})\n        string(TOUPPER ${config} config)\n        set_target_properties(${target} PROPERTIES LIBRARY_OUTPUT_DIRECTORY_${config}\n                                                   \"${CMAKE_CURRENT_BINARY_DIR}\")\n      endforeach()\n    endif()\n  endif()\n  if(SKBUILD)\n    install(TARGETS ${target} LIBRARY DESTINATION .)\n  endif()\n\n  if(\"${target}\" STREQUAL \"exo_planet_c_api\")\n    if(CMAKE_CXX_COMPILER_ID MATCHES \"(GNU|Intel|Clang|NVHPC)\")\n      target_compile_options(${target} PRIVATE -fno-exceptions)\n    endif()\n  endif()\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Verifying Returned std::string Is Python str Using pybind11 in Python\nDESCRIPTION: Shows a Python snippet calling the C++ function that returns std::string and verifies the return is a Python str type. Ensures the automatic UTF-8 decoding was successful.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/strings.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> isinstance(example.std_string_return(), str)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Combining Publicist Pattern with Trampoline for Overriding Protected Virtual Methods in C++\nDESCRIPTION: Extension of the publicist pattern that allows Python to override protected virtual methods by combining it with a trampoline class for virtual method dispatching.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_35\n\nLANGUAGE: cpp\nCODE:\n```\nclass A {\npublic:\n    virtual ~A() = default;\n\nprotected:\n    virtual int foo() const { return 42; }\n};\n\nclass Trampoline : public A, py::trampoline_self_life_support {\npublic:\n    int foo() const override { PYBIND11_OVERRIDE(int, A, foo, ); }\n};\n\nclass Publicist : public A {\npublic:\n    using A::foo;\n};\n\npy::class_<A, Trampoline, py::smart_holder>(m, \"A\") // <-- `Trampoline` here\n    .def(\"foo\", &Publicist::foo); // <-- `Publicist` here, not `Trampoline`!\n```\n\n----------------------------------------\n\nTITLE: Separate Binding File 2 (C++)\nDESCRIPTION: A separate C++ file (`ex2.cpp`) containing an initialization function `init_ex2`. Similar to `ex1.cpp`, it takes a `py::module_` reference and defines bindings for another part of the module, such as the `sub` function. This modular approach improves project organization and build performance. Requires `pybind11/pybind11.h`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/faq.rst#_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nvoid init_ex2(py::module_ &m) {\n    m.def(\"sub\", [](int a, int b) { return a - b; });\n}\n```\n\n----------------------------------------\n\nTITLE: C++ Function with Reference Argument and Return Value\nDESCRIPTION: Defines a C++ function `foo` that takes an integer by mutable reference, increments it, and returns an integer value. This function is used to demonstrate a common pattern that requires special handling when bound to Python due to Python's immutability of basic types.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/faq.rst#_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nint foo(int &i) { i++; return 123; }\n```\n\n----------------------------------------\n\nTITLE: Special 'typed' wrappers in typing.h\nDESCRIPTION: Special 'typed' wrappers are now available in `typing.h` to annotate tuple, dict, list, set, and function types. This enables more fine-grained type annotations in Python.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_18\n\n\n\n----------------------------------------\n\nTITLE: Using Inner Type Hints for Collections in pybind11\nDESCRIPTION: This snippet shows how to specify inner type hints for list or dict parameters using pybind11's typing wrappers, which improves the readability of generated docstrings by indicating element types. These hints do not enforce runtime type checks.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/misc.rst#_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\npy::def(\"pass_list_of_str\", [](py::typing::List<py::str> arg) {\n    // arg can be used just like py::list\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a pybind11 Extension Module in CMake\nDESCRIPTION: This snippet creates a shared library that will be the Python module. The `add_library` command creates a module that uses `../main.cpp` as the source. It links the created library with `pybind11::module` and sets the output name to `test_cmake_build` and removes the prefix for the extension file. Dependencies include pybind11 package and a C++ source file.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/installed_target/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(test_installed_target MODULE ../main.cpp)\n\ntarget_link_libraries(test_installed_target PRIVATE pybind11::module)\nset_target_properties(test_installed_target PROPERTIES OUTPUT_NAME test_cmake_build)\n\n# Make sure result is, for example, test_installed_target.so, not libtest_installed_target.dylib\npybind11_extension(test_installed_target)\n```\n\n----------------------------------------\n\nTITLE: Defining a C++ function with Python named parameters using py::cpp_function\nDESCRIPTION: This code shows how to create a Python callable that wraps a C++ lambda, allowing for named parameters in Python calls via py::cpp_function. The 'func_cpp' returns a lambda that adds one to its input, with 'number' as a named argument.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/functional.rst#_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\npy::cpp_function func_cpp() {\n    return py::cpp_function([](int i) { return i+1; },\n       py::arg(\"number\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Function Accepting NumPy Arrays with Fixed Type via py::array_t - C++\nDESCRIPTION: This function declaration shows how to write a C++ binding using pybind11 so that only NumPy arrays of double precision values (py::array_t<double>) are accepted. If another type is passed, pybind11 attempts to cast or raise an error. Requires including pybind11/numpy.h in the source file. Input: NumPy array of doubles; Output: none (void). Limitation: Only works with arrays convertible to double type.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvoid f(py::array_t<double> array);\n```\n\n----------------------------------------\n\nTITLE: Local STL Container Bindings Using py::module_local\nDESCRIPTION: This snippet discusses the shift from global to module-local STL container bindings like std::vector and std::map within pybind11. It improves modularity by preventing conflicts when multiple modules export identical container types, and explains how to restore global bindings if necessary.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/upgrade.rst#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\n// Example of default global binding for STL types\n// To avoid conflicts, py::bind_vector and py::bind_map now bind as py::module_local\n// if their element types are builtins, not explicitly bound, or bound as module_local.\n// To restore global binding:\n// py::class_<std::vector<int>>(...).py::module_local(false);\n```\n\n----------------------------------------\n\nTITLE: Binding Static Properties with py::metaclass()\nDESCRIPTION: Binding classes with static properties no longer requires explicitly setting the py::metaclass attribute. The default behavior is now sufficient, with an optional single-parameter constructor for custom metaclasses, simplifying class binding syntax.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/upgrade.rst#_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\n// Usage example of py::metaclass() with default and custom metaclasses\npy::class_<MyClass>(m, \"MyClass\")\n    // .def_property_static(\"property\", getter, setter); // example static property\n    ;\n```\n\n----------------------------------------\n\nTITLE: py::initialize_interpreter() using PyConfig_InitPythonConfig()\nDESCRIPTION: `py::initialize_interpreter()` using `PyConfig_InitPythonConfig()` instead of `PyConfig_InitIsolatedConfig()`, to obtain complete `sys.path`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_47\n\n\n\n----------------------------------------\n\nTITLE: Handling C++ Types in pybind11 Docstrings\nDESCRIPTION: This snippet discusses how C++ type names are represented in generated docstrings when the types are not yet exposed via pybind11. It suggests registering C++ classes with pybind11 before they are used as parameters or return types to improve signature clarity.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/misc.rst#_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nPYBIND11_MODULE(example, m) {\n\n    auto pyFoo = py::class_<ns::Foo>(m, \"Foo\");\n    auto pyBar = py::class_<ns::Bar>(m, \"Bar\");\n\n    pyFoo.def(py::init<const ns::Bar&>());\n    pyBar.def(py::init<const ns::Foo&>());\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Executable in CMake\nDESCRIPTION: This snippet demonstrates how to explicitly specify the Python executable for CMake when the automatic detection fails or finds the wrong version. This can be done by deleting `CMakeCache.txt` and adding `-DPYTHON_EXECUTABLE=$(which python)` to the CMake configure line.  Replace `$(which python)` with the full path to your desired python executable.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/faq.rst#_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\n-DPYTHON_EXECUTABLE=$(which python)\n```\n\n----------------------------------------\n\nTITLE: Finding pybind11 Package and Setting Up Project CMake\nDESCRIPTION: This snippet sets up the CMake environment for the project. It specifies the minimum CMake version required. It then declares the project name and specifies the C++ compiler. It finds the pybind11 package and displays its version and include directories. It's a dependency for other snippets and establishes the necessary environment for the project.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/installed_target/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15...4.0)\n\nproject(test_installed_target CXX)\n\nfind_package(pybind11 CONFIG REQUIRED)\nmessage(STATUS \"Found pybind11 v${pybind11_VERSION}: ${pybind11_INCLUDE_DIRS}\")\n```\n\n----------------------------------------\n\nTITLE: Don't require libs component on CMake 3.18+\nDESCRIPTION: The libs component is not required on CMake 3.18+ when using PYBIND11_FINDPYTHON (fixes manylinux builds).  This reduces requirements on the build system.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_26\n\n\n\n----------------------------------------\n\nTITLE: Enforce single line docstring signatures\nDESCRIPTION: Enforced single-line docstring signatures.  This maintains consistency in the documentation style.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_17\n\n\n\n----------------------------------------\n\nTITLE: Demonstrating def_readwrite Pass-by-Reference Issue Python\nDESCRIPTION: Python code showing that when a `std::vector` member of a C++ class is exposed using `py::def_readwrite`, modifying the vector in-place from Python (e.g., using `append`) does not affect the underlying C++ vector. Assigning a new list (`m.contents = [...]`) does work, but `append` fails because it operates on a temporary copy.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/stl.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> m = MyClass()\n>>> m.contents = [5, 6]\n>>> print(m.contents)\n[5, 6]\n>>> m.contents.append(7)\n>>> print(m.contents)\n[5, 6]\n```\n\n----------------------------------------\n\nTITLE: Defining CMake Function to Create Build and Test Targets for pybind11\nDESCRIPTION: This snippet defines a CMake function 'pybind11_add_build_test' that sets up a custom build and test target for a given module, configuring build options based on arguments and environment variables such as Python paths and compiler standards. It establishes dependencies and integrates with CTest for automated testing.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(pybind11_add_build_test name)\n  cmake_parse_arguments(ARG \"INSTALL\" \"\" \"\" ${ARGN})\n\n  set(build_options \"-DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}\")\n\n  list(APPEND build_options \"-DPYBIND11_FINDPYTHON=${PYBIND11_FINDPYTHON}\")\n  if(PYBIND11_FINDPYTHON)\n    if(DEFINED Python_ROOT_DIR)\n      list(APPEND build_options \"-DPython_ROOT_DIR=${Python_ROOT_DIR}\")\n    endif()\n\n    list(APPEND build_options \"-DPython_EXECUTABLE=${Python_EXECUTABLE}\")\n  else()\n    list(APPEND build_options \"-DPYTHON_EXECUTABLE=${PYTHON_EXECUTABLE}\")\n  endif()\n\n  if(DEFINED CMAKE_CXX_STANDARD)\n    list(APPEND build_options \"-DCMAKE_CXX_STANDARD=${CMAKE_CXX_STANDARD}\")\n  endif()\n\n  if(NOT ARG_INSTALL)\n    list(APPEND build_options \"-Dpybind11_SOURCE_DIR=${pybind11_SOURCE_DIR}\")\n  else()\n    list(APPEND build_options \"-DCMAKE_PREFIX_PATH=${pybind11_BINARY_DIR}/mock_install\")\n  endif()\n\n  add_custom_target(\n    test_build_${name}\n    ${CMAKE_CTEST_COMMAND}\n    --build-and-test\n    \"${CMAKE_CURRENT_SOURCE_DIR}/${name}\"\n    \"${CMAKE_CURRENT_BINARY_DIR}/${name}\"\n    --build-config\n    Release\n    --build-noclean\n    --build-generator\n    ${CMAKE_GENERATOR}\n    $<$<BOOL:${CMAKE_GENERATOR_PLATFORM}>:--build-generator-platform>\n    ${CMAKE_GENERATOR_PLATFORM}\n    --build-makeprogram\n    ${CMAKE_MAKE_PROGRAM}\n    --build-target\n    check_${name}\n    --build-options\n    ${build_options})\n  if(ARG_INSTALL)\n    add_dependencies(test_build_${name} mock_install)\n  endif()\n  add_dependencies(test_cmake_build test_build_${name})\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Calling Latin-1 Converted Function and Displaying Unicode String in Python\nDESCRIPTION: Python snippet invoking the C++ function that returns a Latin-1 decoded Python str. Shows that the accented characters are correctly represented as Unicode in Python output.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/strings.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> str_output()\n'Send your résumé to Alice in HR'\n```\n\n----------------------------------------\n\nTITLE: Use PyObject_VisitManagedDict/ClearManagedDict\nDESCRIPTION: The code now uses `PyObject_VisitManagedDict()` and `PyObject_ClearManagedDict()` on Python 3.13 and newer versions. This improves the way managed dictionaries are handled.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_11\n\n\n\n----------------------------------------\n\nTITLE: Keyword arguments in pybind11 (C++)\nDESCRIPTION: This snippet illustrates how to pass keyword arguments to Python functions from C++ using pybind11.  It shows how to call a Python function `f` with positional and keyword arguments, using the `_a` literal to represent the keyword. The corresponding python example is also provided in the surrounding text.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/object.rst#_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nusing namespace pybind11::literals; // to bring in the `_a` literal\nf(1234, \"say\"_a=\"hello\", \"to\"_a=some_instance); // keyword call in C++\n```\n\n----------------------------------------\n\nTITLE: Binding Eigen::Ref Matrix Arguments with pybind11 in C++\nDESCRIPTION: Demonstrates binding of C++ class methods and standalone functions that take Eigen::Ref<const MatrixType> arguments using pybind11. It specifically shows how to prevent automatic copying of data by applying the noconvert() attribute to arguments that require exact matching between numpy arrays and Eigen matrix types. Dependencies include pybind11 with Eigen support, and careful use of pybind11's argument annotations to control binding behaviors. The snippet includes the definition of a C++ class and a free function, then shows how to bind them to Python such that some arguments disallow copying while others allow it. It expects Eigen matrix objects or numpy arrays compatible in layout and dtype, and throws RuntimeError on incompatible input if copying is forbidden.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/eigen.rst#_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\n    // The method and function to be bound:\n    class MyClass {\n        // ...\n        double some_method(const Eigen::Ref<const MatrixXd> &matrix) { /* ... */ }\n    };\n    float some_function(const Eigen::Ref<const MatrixXf> &big,\n                        const Eigen::Ref<const MatrixXf> &small) {\n        // ...\n    }\n\n    // The associated binding code:\n    using namespace pybind11::literals; // for \"arg\"_a\n    py::class_<MyClass>(m, \"MyClass\")\n        // ... other class definitions\n        .def(\"some_method\", &MyClass::some_method, py::arg().noconvert());\n\n    m.def(\"some_function\", &some_function,\n        \"big\"_a.noconvert(), // <- Don't allow copying for this arg\n        \"small\"_a            // <- This one can be copied if needed\n    );\n```\n\n----------------------------------------\n\nTITLE: Accessing Underlying Value of Python Enum Instance (Python)\nDESCRIPTION: Demonstrates retrieving the underlying value of a Python enum instance (`red`) using the `.value` property. This value corresponds to the C++ enum's underlying type and can be cast back if needed.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nunderlying = red.value\n```\n\n----------------------------------------\n\nTITLE: Fixing bind_map with using declarations\nDESCRIPTION: A bug in `bind_map` functionality when used with `using` declarations was fixed. This improves the usability and correctness of the library in scenarios utilizing `using` directives.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_8\n\n\n\n----------------------------------------\n\nTITLE: Adding pybind11/type_caster_pyobject_ptr.h\nDESCRIPTION: `pybind11/type_caster_pyobject_ptr.h` was added to support automatic wrapping of APIs that make use of `PyObject *`. This header needs to be included explicitly.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_42\n\n\n\n----------------------------------------\n\nTITLE: Defining Static Properties in pybind11 Using C++ Lambda Getters (C++)\nDESCRIPTION: Demonstrates how to define a static property on a pybind11 bound class by using def_property_readonly_static with a lambda that ignores the implicit self argument representing the Python type object. The example uses the class Foo and creates a static read-only property named \"foo\" returning a Foo instance. Dependencies include pybind11 and a class Foo already bound or defined.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_23\n\nLANGUAGE: cpp\nCODE:\n```\npy::class_<Foo>(m, \"Foo\")\n    .def_property_readonly_static(\"foo\", [](py::object /* self */) { return Foo(); });\n```\n\n----------------------------------------\n\nTITLE: Update make_static_property_type() compatibility\nDESCRIPTION: `make_static_property_type()` was updated to ensure compatibility with Python 3.13. This ensures that static properties function as expected in the latest Python version.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_12\n\n\n\n----------------------------------------\n\nTITLE: Configuring pybind11 Installation Files in CMake\nDESCRIPTION: When `PYBIND11_INSTALL` is enabled, this block installs the pybind11 headers, defines the installation directory for CMake configuration files, determines the include directory path (`pybind11_INCLUDEDIR`) relative to the package prefix for use in config files, configures/installs `pybind11Config.cmake` and `pybind11ConfigVersion.cmake`, and installs associated CMake utility scripts. It depends on variables like `pybind11_INCLUDE_DIR`, `CMAKE_INSTALL_PREFIX`, `CMAKE_INSTALL_DATAROOTDIR`, `PROJECT_NAME`, and `PROJECT_VERSION`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(PYBIND11_INSTALL)\n  install(DIRECTORY ${pybind11_INCLUDE_DIR}/pybind11 DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n  set(PYBIND11_CMAKECONFIG_INSTALL_DIR\n      \"${CMAKE_INSTALL_DATAROOTDIR}/cmake/${PROJECT_NAME}\"\n      CACHE STRING \"install path for pybind11Config.cmake\")\n\n  if(IS_ABSOLUTE \"${CMAKE_INSTALL_INCLUDEDIR}\")\n    set(pybind11_INCLUDEDIR \"${CMAKE_INSTALL_FULL_INCLUDEDIR}\")\n  else()\n    # Escaped for correct evaluation within the generated config file\n    set(pybind11_INCLUDEDIR \"\\${PACKAGE_PREFIX_DIR}/${CMAKE_INSTALL_INCLUDEDIR}\")\n  endif()\n\n  configure_package_config_file(\n    tools/${PROJECT_NAME}Config.cmake.in \"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake\"\n    INSTALL_DESTINATION ${PYBIND11_CMAKECONFIG_INSTALL_DIR})\n\n  # CMake natively supports header-only libraries\n  write_basic_package_version_file(\n    ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}ConfigVersion.cmake\n    VERSION ${PROJECT_VERSION}\n    COMPATIBILITY AnyNewerVersion ARCH_INDEPENDENT)\n\n  install(\n    FILES ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake\n          ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}ConfigVersion.cmake\n          tools/FindPythonLibsNew.cmake\n          tools/pybind11Common.cmake\n          tools/pybind11Tools.cmake\n          tools/pybind11NewTools.cmake\n          tools/pybind11GuessPythonExtSuffix.cmake\n    DESTINATION ${PYBIND11_CMAKECONFIG_INSTALL_DIR})\n```\n\n----------------------------------------\n\nTITLE: PYBIND11_NO_ASSERT_GIL_HELD_INCREF_DECREF\nDESCRIPTION: `PYBIND11_NO_ASSERT_GIL_HELD_INCREF_DECREF` is now provided as an option for disabling the default-on `PyGILState_Check()`'s in `pybind11::handle`'s `inc_ref()` & `dec_ref()`\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_38\n\n\n\n----------------------------------------\n\nTITLE: Python Example of None Argument Handling\nDESCRIPTION: Shows the Python behavior when calling functions with None arguments. The bark function accepts None while the meow function raises a TypeError when called with None.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/functions.rst#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\n>>> from animals import Dog, Cat, bark, meow\n>>> bark(Dog())\n'woof!'\n>>> meow(Cat())\n'meow'\n>>> bark(None)\n'(no dog)'\n>>> meow(None)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: meow(): incompatible function arguments. The following argument types are supported:\n    1. (cat: animals.Cat) -> str\n\nInvoked with: None\n```\n\n----------------------------------------\n\nTITLE: Detecting Required C++ Filesystem Library in CMake\nDESCRIPTION: Determines the correct library to link against for C++17 `std::filesystem` support. It skips the check if the C++ standard is less than 17 or if using MSVC. Otherwise, it uses `try_compile` to check if linking is needed without extra flags, with `-lstdc++fs`, or with `-lc++fs`. The result is stored in the `STD_FS_LIB` variable, which will be used later when linking test targets.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\n# Check if we need to add -lstdc++fs or -lc++fs or nothing\nif(DEFINED CMAKE_CXX_STANDARD AND CMAKE_CXX_STANDARD LESS 17)\n  set(STD_FS_NO_LIB_NEEDED TRUE)\nelseif(MSVC)\n  set(STD_FS_NO_LIB_NEEDED TRUE)\nelse()\n  file(\n    WRITE ${CMAKE_CURRENT_BINARY_DIR}/main.cpp\n    \"#include <filesystem>\\nint main(int argc, char ** argv) {\\n  std::filesystem::path p(argv[0]);\\n  return p.string().length();\\n}\"\n  )\n  try_compile(\n    STD_FS_NO_LIB_NEEDED ${CMAKE_CURRENT_BINARY_DIR}\n    SOURCES ${CMAKE_CURRENT_BINARY_DIR}/main.cpp\n    COMPILE_DEFINITIONS -std=c++17)\n  try_compile(\n    STD_FS_NEEDS_STDCXXFS ${CMAKE_CURRENT_BINARY_DIR}\n    SOURCES ${CMAKE_CURRENT_BINARY_DIR}/main.cpp\n    COMPILE_DEFINITIONS -std=c++17\n    LINK_LIBRARIES stdc++fs)\n  try_compile(\n    STD_FS_NEEDS_CXXFS ${CMAKE_CURRENT_BINARY_DIR}\n    SOURCES ${CMAKE_CURRENT_BINARY_DIR}/main.cpp\n    COMPILE_DEFINITIONS -std=c++17\n    LINK_LIBRARIES c++fs)\nendif()\n\nif(${STD_FS_NEEDS_STDCXXFS})\n  set(STD_FS_LIB stdc++fs)\nelif(${STD_FS_NEEDS_CXXFS})\n  set(STD_FS_LIB c++fs)\nelif(${STD_FS_NO_LIB_NEEDED})\n  set(STD_FS_LIB \"\")\nelse()\n  message(WARNING \"Unknown C++17 compiler - not passing -lstdc++fs\")\n  set(STD_FS_LIB \"\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining pybind11 Modules using PYBIND11_MODULE vs PYBIND11_PLUGIN in C++\nDESCRIPTION: Compares the modern `PYBIND11_MODULE` macro (preferred) with the deprecated `PYBIND11_PLUGIN` macro for defining pybind11 extension module entry points. The `PYBIND11_MODULE` approach simplifies definition by implicitly handling module object creation and return.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_55\n\nLANGUAGE: cpp\nCODE:\n```\n// new\nPYBIND11_MODULE(example, m) {\n    m.def(\"add\", [](int a, int b) { return a + b; });\n}\n```\n\nLANGUAGE: cpp\nCODE:\n```\n// old\nPYBIND11_PLUGIN(example) {\n    py::module m(\"example\");\n    m.def(\"add\", [](int a, int b) { return a + b; });\n    return m.ptr();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Module Cleanup with C++ Capsules in pybind11\nDESCRIPTION: This snippet demonstrates how to set up cleanup callbacks that are invoked when a pybind11 module is destroyed. It uses capsules and weak references to perform cleanup tasks at destruction, highlighting considerations like object lifetime and avoiding unwanted attribute exposure.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/misc.rst#_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nauto cleanup_callback = []() {\n    // perform cleanup here -- this function is called with the GIL held\n};\n\nm.add_object(\"_cleanup\", py::capsule(cleanup_callback));\n```\n\nLANGUAGE: C++\nCODE:\n```\nauto cleanup_callback = []() { /* ... */ };\nm.attr(\"BaseClass\").attr(\"_cleanup\") = py::capsule(cleanup_callback);\n```\n\nLANGUAGE: C++\nCODE:\n```\n// Register a callback function that is invoked when the BaseClass object is collected\npy::cpp_function cleanup_callback(\n    [](py::handle weakref) {\n        // perform cleanup here -- this function is called with the GIL held\n        weakref.dec_ref(); // release weak reference\n    }\n);\n\n// Create a weak reference with a cleanup callback and initially leak it\n(py::weakref(m.attr(\"BaseClass\"), cleanup_callback)).release();\n```\n\nLANGUAGE: C++\nCODE:\n```\n// Using atexit for cleanup in environments where GC does not trigger\nauto atexit = py::module_::import(\"atexit\");\natexit.attr(\"register\")(py::cpp_function([]() {\n    // perform cleanup here -- this function is called with the GIL held\n}));\n```\n\n----------------------------------------\n\nTITLE: Cast errors include Python type information\nDESCRIPTION: Cast errors now always include Python type information, even if `PYBIND11_DETAILED_ERROR_MESSAGES` is not defined. This improves the informative value of cast errors.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_48\n\n\n\n----------------------------------------\n\nTITLE: Overriding Module Local Binding for STL Container C++\nDESCRIPTION: Demonstrates how to override pybind11's default behavior for binding STL containers using `py::bind_vector` or `py::bind_map`. By default, these bindings are often module-local. Passing `py::module_local(false)` explicitly makes the binding global, allowing other modules to potentially share the same bound type, but introducing a risk of conflicts if another module also tries to bind the same type globally.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/stl.rst#_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\npy::bind_vector<std::vector<int>>(m, \"VectorInt\", py::module_local(false));\n```\n\n----------------------------------------\n\nTITLE: Python Example Showing Pickling of a pybind11-Wrapped C++ Object in Python\nDESCRIPTION: This Python snippet demonstrates pickling a C++ object bound with pybind11 from Python code. It creates an instance of the Pickleable class, sets an extra integer attribute, and serializes it into a byte string using pickle.dumps with version 2 or higher. The snippet requires the Pickleable class exposed to Python with appropriate pickle methods defined in C++. This code exemplifies usage of the bindings on the Python side and highlights the version requirement for the pickle protocol to avoid memory corruption.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_33\n\nLANGUAGE: Python\nCODE:\n```\nimport pickle\n\np = Pickleable(\"test_value\")\np.setExtra(15)\ndata = pickle.dumps(p)\n```\n\n----------------------------------------\n\nTITLE: Updating Class Declarations for Version 2.0 Compatibility in pybind11\nDESCRIPTION: This snippet describes necessary syntax changes for pybind11 class definitions to be compatible with version 2.0, including the addition of 'py::buffer_protocol()' for buffer support, specifying 'py::metaclass()' for static properties, and updating trampoline class syntax by including the trampoline class as a template argument instead of using 'alias<>()'. This improves efficiency and supports new features, with dependencies on pybind11.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/upgrade.rst#_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\npy::class_<Matrix>(\"Matrix\", py::buffer_protocol())\n    .def(py::init<...>())\n    .def_buffer(...);\n```\n\nLANGUAGE: cpp\nCODE:\n```\n// new syntax for trampoline class\npy::class_<MyClass, TrampolineClass>(\"MyClass\")\n    ...;\n```\n\n----------------------------------------\n\nTITLE: Using FindPython with pybind11 in CMake\nDESCRIPTION: Example showing how to use modern CMake's FindPython module with pybind11. This approach leverages improved Python search algorithms and modern targets available in CMake 3.18.2+.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_15\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15...4.0)\nproject(example LANGUAGES CXX)\n\nfind_package(Python 3.8 COMPONENTS Interpreter Development REQUIRED)\nfind_package(pybind11 CONFIG REQUIRED)\n# or add_subdirectory(pybind11)\n\npybind11_add_module(example example.cpp)\n```\n\n----------------------------------------\n\nTITLE: Defining Function to Enable Compiler Warnings in CMake\nDESCRIPTION: Defines a CMake function `pybind11_enable_warnings` that accepts a target name. It applies a set of common warning flags (`/W4` for MSVC, `-Wall -Wextra -Wconversion` etc. for GCC/Clang/Intel) to the specified target using `target_compile_options`. If the `PYBIND11_WERROR` variable is set, it also adds flags (`/WX`, `-Werror`, `-Werror-all`, or sets `COMPILE_WARNING_AS_ERROR` property depending on CMake version and compiler) to treat warnings as errors, with specific exclusions for certain compiler/standard combinations.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\n# Compile with compiler warnings turned on\nfunction(pybind11_enable_warnings target_name)\n  if(MSVC)\n    target_compile_options(${target_name} PRIVATE /W4 /wd4189)\n  elseif(CMAKE_CXX_COMPILER_ID MATCHES \"(GNU|Intel|Clang)\" AND NOT PYBIND11_CUDA_TESTS)\n    target_compile_options(\n      ${target_name}\n      PRIVATE -Wall\n              -Wextra\n              -Wconversion\n              -Wcast-qual\n              -Wdeprecated\n              -Wundef\n              -Wnon-virtual-dtor)\n    if(DEFINED CMAKE_CXX_STANDARD AND NOT CMAKE_CXX_STANDARD VERSION_LESS 20)\n      target_compile_options(${target_name} PRIVATE -Wpedantic)\n    endif()\n  endif()\n\n  if(PYBIND11_WERROR)\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Intel\")\n      if(CMAKE_CXX_STANDARD EQUAL 17) # See PR #3570\n        target_compile_options(${target_name} PRIVATE -Wno-conversion)\n      endif()\n      # \"Inlining inhibited by limit max-size\", \"Inlining inhibited by limit max-total-size\"\n      target_compile_options(${target_name} PRIVATE -diag-disable 11074,11076)\n    endif()\n\n    if(CMAKE_VERSION VERSION_LESS \"3.24\")\n      if(MSVC)\n        target_compile_options(${target_name} PRIVATE /WX)\n      elseif(PYBIND11_CUDA_TESTS)\n        target_compile_options(${target_name} PRIVATE \"SHELL:-Werror all-warnings\")\n      elseif(CMAKE_CXX_COMPILER_ID MATCHES \"(GNU|Clang|IntelLLVM)\")\n        target_compile_options(${target_name} PRIVATE -Werror)\n      elseif(CMAKE_CXX_COMPILER_ID STREQUAL \"Intel\")\n        target_compile_options(${target_name} PRIVATE -Werror-all)\n      endif()\n    else()\n      set_target_properties(${target_name} PROPERTIES COMPILE_WARNING_AS_ERROR ON)\n    endif()\n  endif()\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Detecting Memory Leaks with while True and top (Python)\nDESCRIPTION: This snippet demonstrates how to use a `while True` loop and the `top` command in Linux/macOS to detect memory leaks in pybind11 bindings. By inserting `while True` at the beginning of a test function and monitoring the process's RES (Resident Memory Size) with `top`, you can observe if memory usage increases continuously, indicating a leak. Ctrl-C to exit the infinite loop to avoid system instability.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/faq.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef test_return_list_pyobject_ptr_reference():\n  while True:\n     vec_obj = m.return_list_pyobject_ptr_reference(ValueHolder)\n     assert [e.value for e in vec_obj] == [93, 186]\n     # Commenting out the next `assert` will leak the Python references.\n     # An easy way to see evidence of the leaks:\n     # Insert `while True:` as the first line of this function and monitor the\n     # process RES (Resident Memory Size) with the Unix top command.\n     # assert m.dec_ref_each_pyobject_ptr(vec_obj) == 2\n```\n\n----------------------------------------\n\nTITLE: Once Initialization with Static Variable - C++\nDESCRIPTION: This example showcases a concise approach to \"once\" initialization using a static variable within a function. The C++ standard guarantees that the initialization of a static variable within a function occurs only once, even with concurrent access. This approach implicitly handles synchronization, potentially avoiding the need for explicit mutexes. It leverages the language's guarantees regarding thread-safe initialization. Note that the initializer (in this case `f()`) should not itself attempt to lock any other mutexes or initialize other static variables if potential deadlock scenarios need to be avoided.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/deadlock.md#_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\n// The operation of interest:\nvoid f();\n\nvoid InitOnceWithStatic() {\n  static int unused = (f(), 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Separate Binding File 1 (C++)\nDESCRIPTION: A separate C++ file (`ex1.cpp`) containing an initialization function `init_ex1`. This function takes a `py::module_` reference and defines bindings for a specific part of the module, such as the `add` function. This file can be compiled independently, contributing to faster incremental builds. Requires `pybind11/pybind11.h`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/faq.rst#_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nvoid init_ex1(py::module_ &m) {\n    m.def(\"add\", [](int a, int b) { return a + b; });\n}\n```\n\n----------------------------------------\n\nTITLE: Monitoring Memory Usage with top (Bash)\nDESCRIPTION: This snippet shows how to use the `top` command in a separate terminal to monitor the memory usage (RES column) of a Python process, particularly when debugging memory leaks in pybind11 code.  It is intended to be used in conjunction with the Python snippet that causes the infinite loop.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/faq.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ntop\n```\n\n----------------------------------------\n\nTITLE: Specifying Factory Functions in pybind11 for C++ Class Initialization\nDESCRIPTION: Demonstrates different ways to specify factory functions in pybind11 to construct instances or alias instances of a C++ class. It includes examples of providing a single factory returning a base instance, two factory callbacks to manage aliasing, and always returning an alias instance using factory lambdas. This snippet depends on defining trampoline classes for lifetime management and uses py::init() overloads. It expects the class Example with a derived trampoline subclass PyExample and shows usage of py::init with factory lambdas returning new objects for correct Python bindings.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_18\n\nLANGUAGE: cpp\nCODE:\n```\n#include <pybind11/factory.h>\nclass Example {\npublic:\n    // ...\n    virtual ~Example() = default;\n};\nclass PyExample : public Example, py::trampoline_self_life_support {\npublic:\n    using Example::Example;\n    PyExample(Example &&base) : Example(std::move(base)) {}\n};\npy::class_<Example, PyExample, py::smart_holder>(m, \"Example\")\n    // Returns an Example pointer.  If a PyExample is needed, the Example\n    // instance will be moved via the extra constructor in PyExample, above.\n    .def(py::init([]() { return new Example(); }))\n    // Two callbacks:\n    .def(py::init([]() { return new Example(); } /* no alias needed */,\n                  []() { return new PyExample(); } /* alias needed */))\n    // *Always* returns an alias instance (like py::init_alias<>())\n    .def(py::init([]() { return new PyExample(); }))\n    ;\n```\n\n----------------------------------------\n\nTITLE: Calling Vectorized pybind11 Function (Python)\nDESCRIPTION: Illustrates calling a C++ function exposed to Python via pybind11 and vectorized using `py::vectorize`. Demonstrates automatic NumPy array type conversion (int64 to int32, float64 to float32) and scalar argument broadcasting.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> result = vectorized_func(x, y, z)\n```\n\n----------------------------------------\n\nTITLE: Adding a Custom Target to Test\nDESCRIPTION: This snippet defines a custom target named `check_subdirectory_target`. This target runs a Python script to test the build. It uses the Python executable, project source directory, and the test file to do this. It sets the PYTHONPATH and dependencies so that cmake knows the execution requirements.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/subdirectory_target/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(\n  check_subdirectory_target\n  ${CMAKE_COMMAND}\n  -E\n  env\n  PYTHONPATH=$<TARGET_FILE_DIR:test_subdirectory_target>\n  ${_Python_EXECUTABLE}\n  ${PROJECT_SOURCE_DIR}/../test.py\n  ${PROJECT_NAME}\n  DEPENDS test_subdirectory_target)\n```\n\n----------------------------------------\n\nTITLE: Interactive Python session calling bound functions\nDESCRIPTION: An example showing how to import the 'example' module in Python, define a square function, and call the C++ bound functions to demonstrate passing functions, capturing, and named parameter usage from Python, illustrating typical callback interactions.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/functional.rst#_snippet_4\n\nLANGUAGE: pycon\nCODE:\n```\n$ python\n>>> import example\n>>> def square(i):\n...     return i * i\n...\n>>> example.func_arg(square)\n100\n>>> square_plus_1 = example.func_ret(square)\n>>> square_plus_1(4)\n17\n>>> plus_1 = func_cpp()\n>>> plus_1(number=43)\n44\n```\n\n----------------------------------------\n\nTITLE: Configuring a pybind11 Module Build and Test in CMake\nDESCRIPTION: This CMakeLists.txt file configures the build process for a Python extension module named `test_installed_function` using pybind11. It requires CMake version 3.15 or higher, finds the pybind11 package, and builds the module from `../main.cpp` using `pybind11_add_module`, renaming the output to `test_cmake_build`. It also defines a custom target `check_installed_function` which executes the Python script `../test.py` to test the module, ensuring the built module's directory is added to `PYTHONPATH`. Requires pybind11 to be installed and findable by CMake, and a Python executable to be available.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/installed_function/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15...4.0)\n\nproject(test_installed_function CXX)\n\nfind_package(pybind11 CONFIG REQUIRED)\nmessage(\n  STATUS \"Found pybind11 v${pybind11_VERSION} ${pybind11_VERSION_TYPE}: ${pybind11_INCLUDE_DIRS}\")\n\npybind11_add_module(test_installed_function SHARED NO_EXTRAS ../main.cpp)\nset_target_properties(test_installed_function PROPERTIES OUTPUT_NAME test_cmake_build)\n\nif(DEFINED Python_EXECUTABLE)\n  set(_Python_EXECUTABLE \"${Python_EXECUTABLE}\")\nelseif(DEFINED PYTHON_EXECUTABLE)\n  set(_Python_EXECUTABLE \"${PYTHON_EXECUTABLE}\")\nelse()\n  message(FATAL_ERROR \"No Python executable defined (should not be possible at this stage)\")\nendif()\n\nadd_custom_target(\n  check_installed_function\n  ${CMAKE_COMMAND}\n  -E\n  env\n  PYTHONPATH=$<TARGET_FILE_DIR:test_installed_function>\n  ${_Python_EXECUTABLE}\n  ${PROJECT_SOURCE_DIR}/../test.py\n  ${PROJECT_NAME}\n  DEPENDS test_installed_function)\n```\n\n----------------------------------------\n\nTITLE: Defining a Python Class with Custom Metaclass in pybind11 in C++\nDESCRIPTION: This snippet demonstrates creating a pybind11 class 'Bar' with a custom Python metaclass specified via 'py::metaclass()'. This advanced feature allows overriding the default metaclass, useful for metaprogramming or advanced class behaviors. Dependencies include pybind11, and the class declaration must include the custom metaclass argument.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/upgrade.rst#_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\npy::class_<Bar>(m, \"Bar\", py::metaclass(custom_python_type))\n    ...;\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Constructors for pybind11 Classes in C++\nDESCRIPTION: Shows how to define custom constructors for C++ classes exposed to Python using pybind11's `py::init` factory function adapter. This example binds both a standard constructor (`Example(std::string)`) and a custom lambda-based constructor that takes an integer and returns a `std::unique_ptr<Example>`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_56\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Example {\n    Example(std::string);\n};\n\npy::class_<Example>(m, \"Example\")\n    .def(py::init<std::string>()) // existing constructor\n    .def(py::init([](int n) { // custom constructor\n        return std::make_unique<Example>(std::to_string(n));\n    }));\n```\n\n----------------------------------------\n\nTITLE: Exporting and Installing Embedded pybind11 Library with CMake - CMake\nDESCRIPTION: This snippet creates a shared/static library 'test_embed_lib' from '../embed.cpp', links it to 'pybind11::embed', and installs the library with custom export settings for reuse in other CMake projects. The target is exported using the specified export group, and installation locations for archive, library, and runtime artifacts are defined. Dependencies: Requires pybind11 configured, ../embed.cpp source available, and appropriate install permissions. Expects no user input other than installation path. Output includes built library and CMake export files. Limitations: Relies on correct export/import mechanics and compatible environments.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/subdirectory_embed/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(test_embed_lib ../embed.cpp)\ntarget_link_libraries(test_embed_lib PRIVATE pybind11::embed)\n\ninstall(\n  TARGETS test_embed_lib\n  EXPORT test_export\n  ARCHIVE DESTINATION bin\n  LIBRARY DESTINATION lib\n  RUNTIME DESTINATION lib)\ninstall(EXPORT test_export DESTINATION lib/cmake/test_export/test_export-Targets.cmake)\n\n```\n\n----------------------------------------\n\nTITLE: Generating and Installing pybind11 pkg-config File\nDESCRIPTION: Configures and installs a `pybind11.pc` file to enable discovery of pybind11 via the pkg-config tool. It calculates the appropriate installation prefix (`prefix_for_pc_file`) and include directory (`includedir_for_pc_file`) for the `.pc` file, handling both absolute and relative installation paths and adapting behavior for CMake versions before 3.20. This relies on the `pybind11.pc.in` template file and is conditional on `PYBIND11_INSTALL` being true.\nSOURCE: https://github.com/pybind/pybind11/blob/master/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\n  # ... inside if(PYBIND11_INSTALL)\n  # pkg-config support\n  if(NOT prefix_for_pc_file)\n    if(IS_ABSOLUTE \"${CMAKE_INSTALL_DATAROOTDIR}\")\n      set(prefix_for_pc_file \"${CMAKE_INSTALL_PREFIX}\")\n    else()\n      set(pc_datarootdir \"${CMAKE_INSTALL_DATAROOTDIR}\")\n      if(CMAKE_VERSION VERSION_LESS 3.20)\n        set(prefix_for_pc_file \"\\${pcfiledir}/..\")\n        while(pc_datarootdir)\n          get_filename_component(pc_datarootdir \"${pc_datarootdir}\" DIRECTORY)\n          string(APPEND prefix_for_pc_file \"/..\")\n        endwhile()\n      else()\n        cmake_path(RELATIVE_PATH CMAKE_INSTALL_PREFIX BASE_DIRECTORY CMAKE_INSTALL_DATAROOTDIR\n                   OUTPUT_VARIABLE prefix_for_pc_file)\n      endif()\n    endif()\n  endif()\n  # Note: join_paths is likely a custom macro/function defined elsewhere\n  join_paths(includedir_for_pc_file \"\\${prefix}\" \"${CMAKE_INSTALL_INCLUDEDIR}\")\n  configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/tools/pybind11.pc.in\"\n                 \"${CMAKE_CURRENT_BINARY_DIR}/pybind11.pc\" @ONLY)\n  install(FILES \"${CMAKE_CURRENT_BINARY_DIR}/pybind11.pc\"\n          DESTINATION \"${CMAKE_INSTALL_DATAROOTDIR}/pkgconfig/\")\n```\n\n----------------------------------------\n\nTITLE: Creating pybind11_extension\nDESCRIPTION: This command calls the pybind11_extension macro. This function ensures that result is, for example, test_installed_target.so, not libtest_installed_target.dylib. This macro is responsible for properly setting the extension of the generated library file to match the OS standards.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/subdirectory_target/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\npybind11_extension(test_subdirectory_target)\n```\n\n----------------------------------------\n\nTITLE: Configuring pybind11 Embedded Build Environment with CMake - CMake\nDESCRIPTION: This snippet sets up a CMake-based build system that integrates pybind11 as a subdirectory and configures embedding of Python within a C++ project. Key features include enabling pybind11 installation, specifying Python executable handling, and adding subdirectory for pybind11 source. Dependencies: Requires CMake 3.15 or newer, pybind11 source available, and a C++ compiler. Main parameters include PYBIND11_INSTALL, PYBIND11_EXPORT_NAME, and detection of Python executables. No direct input/output beyond build configuration; customization possible via CMake cache/variables. Limitations: Assumes a compatible C++ project structure and presence of necessary pybind11/C++ sources.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/subdirectory_embed/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15...4.0)\n\nproject(test_subdirectory_embed CXX)\n\nset(PYBIND11_INSTALL\n    ON\n    CACHE BOOL \"\")\nset(PYBIND11_EXPORT_NAME test_export)\n\n# Allow PYTHON_EXECUTABLE if in FINDPYTHON mode and building pybind11's tests\n# (makes transition easier while we support both modes).\nif(DEFINED PYTHON_EXECUTABLE AND NOT DEFINED Python_EXECUTABLE)\n  set(Python_EXECUTABLE \"${PYTHON_EXECUTABLE}\")\nendif()\n\nadd_subdirectory(\"${pybind11_SOURCE_DIR}\" pybind11)\n\n```\n\n----------------------------------------\n\nTITLE: Handling Potentially Uninitialized Python Module Extension Variable\nDESCRIPTION: This snippet calls a macro to handle cases where 'PYTHON_MODULE_EXTENSION' might be uninitialized, setting default values or managing dependencies related to Python modules. It ensures safe variable usage in subsequent build logic.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\npossibly_uninitialized(PYTHON_MODULE_EXTENSION Python_INTERPRETER_ID)\n```\n\n----------------------------------------\n\nTITLE: Building Python Extension Modules with Meson\nDESCRIPTION: A Meson build configuration for creating Python extension modules with pybind11. This sets up project parameters, locates Python and pybind11 dependencies, and defines the extension module.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_2\n\nLANGUAGE: meson\nCODE:\n```\nproject(\n    'example',\n    'cpp',\n    version: '0.1.0',\n    default_options: [\n        'cpp_std=c++11',\n    ],\n)\n\npy = import('python').find_installation(pure: false)\npybind11_dep = dependency('pybind11')\n\npy.extension_module('example',\n    'example.cpp',\n    install: true,\n    dependencies : [pybind11_dep],\n)\n```\n\n----------------------------------------\n\nTITLE: Installing pybind11 Globally via PyPI - Bash\nDESCRIPTION: Installs pybind11 package globally, exposing its header and CMake files system-wide by specifying the 'global' extra. Requires administrative privileges and pip. Useful for advanced cases, it adds pybind11 files into directories like '/usr/local/include/pybind11'. Not recommended for system Python due to possible file conflicts unless using a contained environment.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/installing.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install \"pybind11[global]\"\n```\n\n----------------------------------------\n\nTITLE: Cloning and Installing pybind11 via vcpkg - Bash\nDESCRIPTION: Shows a sequence of shell commands for cloning the vcpkg repository, bootstrapping it, integrating with the system, and installing pybind11 using vcpkg. Requires Git and Bash, and is primarily for Windows or cross-platform C++ developers. Ensures pybind11 integration for Visual Studio/MSBuild and compatible platforms; useful for automated or large C++ projects.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/installing.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.sh\n./vcpkg integrate install\nvcpkg install pybind11\n```\n\n----------------------------------------\n\nTITLE: Building and Testing Embedded pybind11 Executable with CMake - CMake\nDESCRIPTION: This snippet creates a CMake executable target 'test_subdirectory_embed' built from '../embed.cpp', links it to 'pybind11::embed' for Python embedding, sets a custom output name, and defines a check target to run the built executable with a specific Python script. Dependencies: Requires pybind11 integrated as subdirectory, C++ source file at ../embed.cpp, and compatible Python installation. Primary inputs are source file and optional test script; outputs include built executable and test results. Limitations: Assumes standard file layout and that pybind11::embed is available.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/subdirectory_embed/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(test_subdirectory_embed ../embed.cpp)\ntarget_link_libraries(test_subdirectory_embed PRIVATE pybind11::embed)\nset_target_properties(test_subdirectory_embed PROPERTIES OUTPUT_NAME test_cmake_build)\n\nadd_custom_target(\n  check_subdirectory_embed\n  $<TARGET_FILE:test_subdirectory_embed> \"${PROJECT_SOURCE_DIR}/../test.py\"\n  DEPENDS test_subdirectory_embed)\n\n```\n\n----------------------------------------\n\nTITLE: Global Installation of pybind11 via Homebrew - Bash\nDESCRIPTION: Installs pybind11 globally using Homebrew or Linuxbrew, suitable for macOS or Linux environments. Requires the brew/linubre package manager and appropriate system permissions. Downloads and installs the latest stable release of pybind11 with a single command, adding its C++ headers and utilities to standard include locations.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/installing.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nbrew install pybind11\n```\n\n----------------------------------------\n\nTITLE: Enabling std::shared_ptr Support in pybind11 v2.0+\nDESCRIPTION: This snippet indicates that support for 'std::shared_ptr' is now built-in in pybind11, removing the need for explicit 'PYBIND11_DECLARE_HOLDER_TYPE' declarations. It automatically enables shared pointer conversions, simplifying the class bindings involving shared ownership.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/upgrade.rst#_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\n// No code needed; support is enabled by default. Previously declared with:\n// PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)\n```\n\n----------------------------------------\n\nTITLE: Configuring pybind11 Build Options and Compiler Definitions - CMake\nDESCRIPTION: This snippet defines various build options controlling installation, testing, Python integration, ABI versioning, and GIL (Global Interpreter Lock) management within pybind11. Depending on option values, corresponding compile definitions are added to influence compilation behavior. It also manages detection of cross-compiling states and controls Python discovery modes, facilitating flexible and configurable builds aligned with user or environment requirements.\nSOURCE: https://github.com/pybind/pybind11/blob/master/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\noption(PYBIND11_INSTALL \"Install pybind11 header files?\" ${PYBIND11_MASTER_PROJECT})\noption(PYBIND11_TEST \"Build pybind11 test suite?\" ${PYBIND11_MASTER_PROJECT})\noption(PYBIND11_NOPYTHON \"Disable search for Python\" OFF)\noption(PYBIND11_DISABLE_HANDLE_TYPE_NAME_DEFAULT_IMPLEMENTATION\n       \"To enforce that a handle_type_name<> specialization exists\" OFF)\noption(PYBIND11_SIMPLE_GIL_MANAGEMENT\n       \"Use simpler GIL management logic that does not support disassociation\" OFF)\nset(PYBIND11_INTERNALS_VERSION\n    \"\"\n    CACHE STRING \"Override the ABI version, may be used to enable the unstable ABI.\")\noption(PYBIND11_USE_CROSSCOMPILING \"Respect CMAKE_CROSSCOMPILING\" OFF)\n\nif(PYBIND11_DISABLE_HANDLE_TYPE_NAME_DEFAULT_IMPLEMENTATION)\n  add_compile_definitions(PYBIND11_DISABLE_HANDLE_TYPE_NAME_DEFAULT_IMPLEMENTATION)\nendif()\nif(PYBIND11_SIMPLE_GIL_MANAGEMENT)\n  add_compile_definitions(PYBIND11_SIMPLE_GIL_MANAGEMENT)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding pybind11 Module with CMake\nDESCRIPTION: This snippet adds the pybind11 subdirectory and then creates a Python extension module using `pybind11_add_module`.  It links the module to a C++ source file (main.cpp). The `set_target_properties` command changes the output name of the generated library.  Dependencies on pybind11 are implicitly handled here.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/subdirectory_function/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(\"${pybind11_SOURCE_DIR}\" pybind11)\npybind11_add_module(test_subdirectory_function ../main.cpp)\nset_target_properties(test_subdirectory_function PROPERTIES OUTPUT_NAME test_cmake_build)\n```\n\n----------------------------------------\n\nTITLE: Defining pybind11 Project and Setting Build Policies - CMake\nDESCRIPTION: This snippet sets up the pybind11 project within CMake by specifying the required minimum CMake version, adjusting policy CMP0148 depending on CMake version availability, and declaring the project using detected version information. It includes essential CMake modules for installation directory management and package configuration helpers. This ensures that pybind11's build system uses modern CMake features and setup conventions while maintaining backward compatibility.\nSOURCE: https://github.com/pybind/pybind11/blob/master/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT CMAKE_VERSION VERSION_LESS \"3.27\")\n  cmake_policy(GET CMP0148 _pybind11_cmp0148)\nendif()\n\ncmake_minimum_required(VERSION 3.15...4.0)\n\nif(_pybind11_cmp0148)\n  cmake_policy(SET CMP0148 ${_pybind11_cmp0148})\n  unset(_pybind11_cmp0148)\nendif()\n\nproject(\n  pybind11\n  LANGUAGES CXX\n  VERSION \"${PYBIND11_VERSION_MAJOR}.${PYBIND11_VERSION_MINOR}.${PYBIND11_VERSION_PATCH}\")\n\ninclude(GNUInstallDirs)\ninclude(CMakePackageConfigHelpers)\ninclude(CMakeDependentOption)\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Uninstall Target in CMake\nDESCRIPTION: If pybind11 is being built as the main project (`PYBIND11_MASTER_PROJECT`) and installation is enabled (`PYBIND11_INSTALL`), this configures an `uninstall` target using a generated `cmake_uninstall.cmake` script (from `tools/cmake_uninstall.cmake.in`). This allows users to easily remove the installed files using `make uninstall` or equivalent.\nSOURCE: https://github.com/pybind/pybind11/blob/master/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\n  # ... inside if(PYBIND11_INSTALL)\n  # Uninstall target\n  if(PYBIND11_MASTER_PROJECT)\n    configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/tools/cmake_uninstall.cmake.in\"\n                   \"${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake\" IMMEDIATE @ONLY)\n\n    add_custom_target(uninstall COMMAND ${CMAKE_COMMAND} -P\n                                        ${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake)\n  endif()\nendif() # End of PYBIND11_INSTALL block\n```\n\n----------------------------------------\n\nTITLE: Throwing Python Exceptions from C API Calls\nDESCRIPTION: This snippet shows how to throw a Python exception after calling the Python C API directly. If the C API call results in an error, `py::set_error` is used to set the Python error indicator, and `throw py::error_already_set()` is called to propagate the exception to Python. Alternatively, `throw py::type_error()` can be used to simplify the process.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/exceptions.rst#_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\npy::set_error(PyExc_TypeError, \"C API type error demo\");\nthrow py::error_already_set();\n\n// But it would be easier to simply...\nthrow py::type_error(\"pybind11 wrapper type error\");\n```\n\n----------------------------------------\n\nTITLE: Installing pybind11 with CMake\nDESCRIPTION: Commands for building and installing pybind11 on a system, showing both traditional and modern CMake approaches. Required before using find_package in external projects.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n# Classic CMake\ncd pybind11\nmkdir build\ncd build\ncmake ..\nmake install\n\n# CMake 3.15+\ncd pybind11\ncmake -S . -B build\ncmake --build build -j 2  # Build on 2 cores\ncmake --install build\n```\n\n----------------------------------------\n\nTITLE: Evaluating Python Expressions and Statements with pybind11\nDESCRIPTION: This C++ code uses `py::eval`, `py::exec`, and `py::eval_file` to evaluate Python expressions, sequences of statements, and Python files from within C++. The code demonstrates how to import the `__main__` module and access its dictionary (`__dict__`) as a scope for evaluation. It shows how to evaluate an isolated expression, a sequence of statements, and a file. It leverages C++11 raw string literals for cleaner multi-line string handling.  The input consists of Python code (expressions, statements, or filenames), and the output is the result of the evaluation in the provided scope. It depends on `<pybind11/eval.h>`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/utilities.rst#_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n// At beginning of file\n#include <pybind11/eval.h>\n\n...\n\n// Evaluate in scope of main module\npy::object scope = py::module_::import(\"__main__\").attr(\"__dict__\");\n\n// Evaluate an isolated expression\nint result = py::eval(\"my_variable + 10\", scope).cast<int>();\n\n// Evaluate a sequence of statements\npy::exec(\n    \"print('Hello')\\n\"\n    \"print('world!');\",\n    scope);\n\n// Evaluate the statements in an separate Python file on disk\npy::eval_file(\"script.py\", scope);\n```\n\n----------------------------------------\n\nTITLE: Enabling Parallel Compilation with pybind11 Setup Helpers\nDESCRIPTION: A setup.py snippet showing how to enable parallel compilation for pybind11 extensions using ParallelCompile helper. This provides a lightweight replacement for NumPy's parallel compilation tool.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pybind11.setup_helpers import ParallelCompile\n\n# Optional multithreaded build\nParallelCompile(\"NPY_NUM_BUILD_JOBS\").install()\n\nsetup(...)\n```\n\n----------------------------------------\n\nTITLE: Importing NumPy submodules\nDESCRIPTION: The `pybind11/numpy.h` header now imports NumPy's `multiarray` and `_internal` submodules. The import paths are determined by the installed NumPy version to maintain compatibility with NumPy 2.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Extracting pybind11 Project Version Using CMake - CMake\nDESCRIPTION: This snippet extracts the major, minor, and patch version numbers of pybind11 by parsing a header file with CMake's file(STRINGS) and regular expressions. It matches lines defining version macros and assigns these to CMake variables used further in the project version declaration. This enables automatic version synchronization between code and build metadata. It requires the pybind11 'common.h' header to be present at the specified relative path.\nSOURCE: https://github.com/pybind/pybind11/blob/master/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(STRINGS \"${CMAKE_CURRENT_SOURCE_DIR}/include/pybind11/detail/common.h\"\n     pybind11_version_defines REGEX \"#define PYBIND11_VERSION_(MAJOR|MINOR|PATCH) \")\n\nforeach(ver ${pybind11_version_defines})\n  if(ver MATCHES [[#define PYBIND11_VERSION_(MAJOR|MINOR|PATCH) +([^ ]+)$]])\n    set(PYBIND11_VERSION_${CMAKE_MATCH_1} \"${CMAKE_MATCH_2}\")\n  endif()\nendforeach()\n\nif(PYBIND11_VERSION_PATCH MATCHES [[\\.([a-zA-Z0-9]+)$]])\n  set(pybind11_VERSION_TYPE \"${CMAKE_MATCH_1}\")\nendif()\nstring(REGEX MATCH \"^[0-9]+\" PYBIND11_VERSION_PATCH \"${PYBIND11_VERSION_PATCH}\")\n```\n\n----------------------------------------\n\nTITLE: Optimizing Rebuilds for Development with pybind11\nDESCRIPTION: A setup.py snippet showing how to optimize rebuilds during development by only recompiling modified files. Uses the naive_recompile function to skip rebuilding if an object file is newer than its source.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pybind11.setup_helpers import ParallelCompile, naive_recompile\n\nParallelCompile(\"NPY_NUM_BUILD_JOBS\", needs_recompile=naive_recompile).install()\n```\n\n----------------------------------------\n\nTITLE: Initializing Once Naively with Mutex - C++\nDESCRIPTION: This snippet implements a simple \"once\" initialization mechanism using a mutex and a boolean flag. It guarantees that the initialization function `f()` is executed only once, even in a concurrent environment.  It locks the mutex, checks the `init_done` flag, executes `f()` if it's false, sets the flag to true, and unlocks. Dependencies include `absl/synchronization.h` and `absl/base/const_init.h`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/deadlock.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n// The \"once\" mechanism:\nconstinit absl::Mutex mu(absl::kConstInit);\nconstinit bool init_done = false;\n\n// The operation of interest:\nvoid f();\n\nvoid InitOnceNaive() {\n  absl::MutexLock lock(&mu);\n  if (!init_done) {\n    f();\n    init_done = true;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating pybind11 Headers-Only Library Target - CMake\nDESCRIPTION: This snippet defines the headers-only INTERFACE library target pybind11_headers, which provides include paths, compile features, and optional compile definitions for consuming projects. It ensures the target is created only once and provides alias targets for ease of use. The target enforces modern C++ standards and includes all header files in the configured include directory, preparing pybind11 for consuming projects without compiling any source files.\nSOURCE: https://github.com/pybind/pybind11/blob/master/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT TARGET pybind11_headers)\n  add_library(pybind11_headers INTERFACE)\n  add_library(pybind11::pybind11_headers ALIAS pybind11_headers)\n  add_library(pybind11::headers ALIAS pybind11_headers)\n\n  target_include_directories(\n    pybind11_headers ${pybind11_system} INTERFACE $<BUILD_INTERFACE:${pybind11_INCLUDE_DIR}>\n                                                  $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>)\n\n  target_compile_features(pybind11_headers INTERFACE cxx_inheriting_constructors cxx_user_literals\n                                                     cxx_right_angle_brackets)\n  if(NOT \"${PYBIND11_INTERNALS_VERSION}\" STREQUAL \"\")\n    target_compile_definitions(\n      pybind11_headers INTERFACE \"PYBIND11_INTERNALS_VERSION=${PYBIND11_INTERNALS_VERSION}\")\n  endif()\nelse()\n  set(PYBIND11_INSTALL OFF)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Catching Python Exceptions in C++ Destructors to Avoid std::terminate in pybind11 (C++)\nDESCRIPTION: Provides a pattern for safe C++ destructors that invoke Python functions using pybind11. Since Python exceptions thrown during C++ destructors cause std::terminate, this example shows how to catch py::error_already_set exceptions and call discard_as_unraisable with contextual information, preventing program termination. The example class MyClass destructor prints and executes Python code that raises a ValueError; the exception is safely handled. This requires including pybind11 and its error handling mechanisms. Note that pybind11 does not support C++ destructors marked noexcept(false).\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_21\n\nLANGUAGE: cpp\nCODE:\n```\nclass MyClass {\npublic:\n    ~MyClass() {\n        try {\n            py::print(\"Even printing is dangerous in a destructor\");\n            py::exec(\"raise ValueError('This is an unraisable exception')\");\n        } catch (py::error_already_set &e) {\n            // error_context should be information about where/why the occurred,\n            // e.g. use __func__ to get the name of the current function\n            e.discard_as_unraisable(__func__);\n        }\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Binding Inheritance Relationships Across Multiple pybind11 Extension Modules (C++)\nDESCRIPTION: This snippet demonstrates two approaches for defining inheritance relationships in pybind11 bindings when the parent class is declared in a separate extension module. The first approach queries the previously declared class object by importing the Python module and then referencing its attribute, while the second approach specifies the base class as a template parameter to py::class_, after calling py::module_::import to ensure initialization. Both methods are required for establishing class hierarchies across extension modules but depend on explicit module initialization and are subject to cyclic dependency limitations.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/misc.rst#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\npy::object pet = (py::object) py::module_::import(\"basic\").attr(\"Pet\");\n\npy::class_<Dog>(m, \"Dog\", pet)\n    .def(py::init<const std::string &>())\n    .def(\"bark\", &Dog::bark);\n```\n\nLANGUAGE: C++\nCODE:\n```\npy::module_::import(\"basic\");\n\npy::class_<Dog, Pet>(m, \"Dog\")\n    .def(py::init<const std::string &>())\n    .def(\"bark\", &Dog::bark);\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Test Target with CMake\nDESCRIPTION: This creates a custom target named 'check_subdirectory_function' to run Python tests.  It uses `add_custom_target` to execute a Python script ('test.py') with the compiled module. It also sets the PYTHONPATH environment variable so the Python script finds the compiled module. This tests the compiled module through the integration with Python.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/subdirectory_function/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(\n  check_subdirectory_function\n  ${CMAKE_COMMAND}\n  -E\n  env\n  PYTHONPATH=$<TARGET_FILE_DIR:test_subdirectory_function>\n  ${_Python_EXECUTABLE}\n  ${PROJECT_SOURCE_DIR}/../test.py\n  ${PROJECT_NAME}\n  DEPENDS test_subdirectory_function)\n```\n\n----------------------------------------\n\nTITLE: Find and Verify Catch Testing Framework\nDESCRIPTION: This code locates the Catch testing framework version 2.13.10. If found, it confirms that interpreter tests will be built with the specified version. Otherwise, it outputs a message indicating that tests will be skipped and suggests manual or automatic installation.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_embed/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(Catch 2.13.10)\n\nif(CATCH_FOUND)\n  message(STATUS \"Building interpreter tests using Catch v${CATCH_VERSION}\")\nelse()\n  message(STATUS \"Catch not detected. Interpreter tests will be skipped. Install Catch headers\"\n                 \" manually or use `cmake -DDOWNLOAD_CATCH=ON` to fetch them automatically.\")\n  return()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Example `CreateWidget` Releasing and Reacquiring GIL (C++)\nDESCRIPTION: Shows an example `CreateWidget` function that temporarily releases the GIL using `Py_BEGIN_ALLOW_THREADS` to perform expensive work unrelated to the Python runtime, and then reacquires it using `Py_END_ALLOW_THREADS`. If called within a C++ static initializer while the GIL is already held, this pattern can create a deadlock scenario.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/deadlock.md#_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\n// Assumes that the GIL is held on entry.\n// Ensures that the GIL is held on exit.\nPyObject* CreateWidget() {\n  // ...\n  Py_BEGIN_ALLOW_THREADS  // releases GIL\n  // expensive work, not accessing the Python runtime\n  Py_END_ALLOW_THREADS    // acquires GIL, #!\n  // ...\n  return result;\n}\n```\n\n----------------------------------------\n\nTITLE: Processing and Filtering Test Files in CMake\nDESCRIPTION: Logic to handle test files with different processing for pure Python tests (.py), pure C++ tests (.cpp), and tests with both components (no extension). Supports filtering and test overrides.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# Now that the test filtering is complete, we need to split the list into the test for PYTEST\n# and the list for the cpp targets.\nset(PYBIND11_CPPTEST_FILES \"\")\nset(PYBIND11_PYTEST_FILES \"\")\n\nforeach(test_name ${PYBIND11_TEST_FILES})\n  if(test_name MATCHES \"\\\\.py$\") # Ends in .py, purely python test.\n    list(APPEND PYBIND11_PYTEST_FILES ${test_name})\n  elseif(test_name MATCHES \"\\\\.cpp$\") # Ends in .cpp, purely cpp test.\n    list(APPEND PYBIND11_CPPTEST_FILES ${test_name})\n  elseif(NOT test_name MATCHES \\\"\\\\.\\\") # No extension specified, assume both, add extension.\n    list(APPEND PYBIND11_PYTEST_FILES ${test_name}.py)\n    list(APPEND PYBIND11_CPPTEST_FILES ${test_name}.cpp)\n  else()\n    message(WARNING \"Unhanded test extension in test: ${test_name}\")\n  endif()\nendforeach()\nset(PYBIND11_TEST_FILES ${PYBIND11_CPPTEST_FILES})\nlist(SORT PYBIND11_PYTEST_FILES)\n```\n\n----------------------------------------\n\nTITLE: Installing pybind11 via PyPI - Bash\nDESCRIPTION: Provides the command to install pybind11 from the Python Package Index (PyPI) using pip, placing the package in the current Python environment. Requires pip and Python. Installs pybind11 as a standard package, making its CMake files and sources available to local builds. Intended for virtual environments or editable roots; does not modify system directories.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/installing.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install pybind11\n```\n\n----------------------------------------\n\nTITLE: Attempting Deadlock Avoidance by Releasing GIL Before Static (C++)\nDESCRIPTION: Illustrates an attempt to fix the deadlock issue by explicitly releasing the GIL before the static variable initialization and reacquiring it afterward. While this avoids the deadlock by ensuring the static guard mutex is acquired first, it introduces performance overhead by unnecessarily releasing and acquiring the GIL on every call, even after the variable is initialized.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/deadlock.md#_snippet_6\n\nLANGUAGE: c++\nCODE:\n```\n// CPython callback, assumes that the GIL is held on entry.\nPyObject* InvokeWidget(PyObject* self) {\n  Py_BEGIN_ALLOW_THREADS  // releases GIL\n  static PyObject* impl = CreateWidget();\n  Py_END_ALLOW_THREADS    // acquires GIL\n\n  return PyObject_CallOneArg(impl, self);\n}\n```\n\n----------------------------------------\n\nTITLE: Example C++ function declaration returning a static data pointer\nDESCRIPTION: This snippet shows a simple function returning a pointer to a static data structure, highlighting the need to choose the correct return value policy to prevent crashes or undefined behavior when binding with pybind11.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/functions.rst#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n/* Function declaration */\nData *get_data() { return _data; /* (pointer to a static data structure) */ }\n...\n\n/* Binding code */\nm.def(\"get_data\", &get_data); // <-- KABOOM, will cause crash when called from Python\n```\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"get_data\", &get_data, py::return_value_policy::reference);\n```\n\n----------------------------------------\n\nTITLE: Creating a Macro for Filtering Test Files in CMake\nDESCRIPTION: A macro that filters out specified test files from a list and optionally displays a status message when files are filtered. It handles file extensions by comparing base filenames.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nmacro(pybind11_filter_tests LISTNAME)\n  cmake_parse_arguments(ARG \"\" \"MESSAGE\" \"\" ${ARGN})\n  set(PYBIND11_FILTER_TESTS_FOUND OFF)\n  # Make a list of the test without any extensions, for easier filtering.\n  set(_TMP_ACTUAL_LIST \"${${LISTNAME}};\") # enforce ';' at the end to allow matching last item.\n  string(REGEX REPLACE \"\\\\.[^.;]*;\" \";\" LIST_WITHOUT_EXTENSIONS \"${_TMP_ACTUAL_LIST}\")\n  foreach(filename IN LISTS ARG_UNPARSED_ARGUMENTS)\n    string(REGEX REPLACE \"\\\\.[^.]*$\" \"\" filename_no_ext ${filename})\n    # Search in the list without extensions.\n    list(FIND LIST_WITHOUT_EXTENSIONS ${filename_no_ext} _FILE_FOUND)\n    if(_FILE_FOUND GREATER -1)\n      list(REMOVE_AT ${LISTNAME} ${_FILE_FOUND}) # And remove from the list with extensions.\n      list(REMOVE_AT LIST_WITHOUT_EXTENSIONS ${_FILE_FOUND}\n      )# And our search list, to ensure it is in sync.\n      set(PYBIND11_FILTER_TESTS_FOUND ON)\n    endif()\n  endforeach()\n  if(PYBIND11_FILTER_TESTS_FOUND AND ARG_MESSAGE)\n    message(STATUS \"${ARG_MESSAGE}\")\n  endif()\nendmacro()\n```\n\n----------------------------------------\n\nTITLE: Manually Building a pybind11 Extension Module on macOS - Bash\nDESCRIPTION: This Bash command compiles a C++ file into a shared extension for Python on macOS, with specifics for dynamic symbol lookup. It is similar to the Linux build but adds the '-undefined dynamic_lookup' flag required on macOS to avoid missing symbol errors during module load. Like in Linux, $(python3 -m pybind11 --includes) provides require headers and python3-config ensures the output file has the appropriate extension. Inputs: A C++ source file (example.cpp). Outputs: A Python-importable shared object module. Prerequisites: pybind11 and Python installed; compilers supporting C++11. Limitations: Only works when not statically linking against libpython.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_19\n\nLANGUAGE: Bash\nCODE:\n```\nc++ -O3 -Wall -shared -std=c++11 -undefined dynamic_lookup $(python3 -m pybind11 --includes) example.cpp -o example$(python3-config --extension-suffix)\n```\n\n----------------------------------------\n\nTITLE: Binding a Protected Member Function in a C++ Class Using pybind11 in C++ (Error Example)\nDESCRIPTION: This snippet demonstrates that pybind11 cannot directly expose protected member functions to Python by attempting to bind such a function, which results in a compilation error. The example defines a class A with a protected method foo and tries to bind it with .def(\"foo\", &A::foo), showing that this causes an error because foo is protected. This highlights a limitation of pybind11 and C++ accessibility that must be addressed with workarounds such as wrapper classes or friend declarations. The snippet requires basic C++ and pybind11. It serves as an instructional example of access restrictions in binding code.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_32\n\nLANGUAGE: C++\nCODE:\n```\nclass A {\nprotected:\n    int foo() const { return 42; }\n};\n\npy::class_<A>(m, \"A\")\n    .def(\"foo\", &A::foo); // error: 'foo' is a protected member of 'A'\n```\n\n----------------------------------------\n\nTITLE: Creating Build Tests for Subdirectory Modules in pybind11\nDESCRIPTION: This code invokes the previously defined function to add build tests for subdirectory modules, ensuring they are configured with proper build options. It also conditionally skips tests for certain interpreters like PyPy or GraalPy based on extension matching and interpreter ID.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\npybind11_add_build_test(subdirectory_function)\npybind11_add_build_test(subdirectory_target)\nif(\"${PYTHON_MODULE_EXTENSION}\" MATCHES \"pypy\" \n   OR \"${Python_INTERPRETER_ID}\" STREQUAL \"PyPy\" \n   OR \"${PYTHON_MODULE_EXTENSION}\" MATCHES \"graalpy\")\n  message(STATUS \"Skipping embed test on PyPy or GraalPy\")\nelse()\n  pybind11_add_build_test(subdirectory_embed)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Linking test_subdirectory_target with pybind11\nDESCRIPTION: This line links the \"test_subdirectory_target\" library with the \"pybind11::module\" target.  This specifies that the \"test_subdirectory_target\" will depend on the functionality of the pybind11 module. The PRIVATE keyword ensures that only test_subdirectory_target has the dependency.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/subdirectory_target/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(test_subdirectory_target PRIVATE pybind11::module)\n```\n\n----------------------------------------\n\nTITLE: Setting up Header Inclusion in CMake\nDESCRIPTION: This snippet is used to avoid header conflicts between Python release and debug headers. It uses `set_target_properties` to mark headers from the imported target as not system headers. The `NO_SYSTEM_FROM_IMPORTED` property is used for this purpose and helps resolve conflicts.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/installed_target/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Do not treat includes from IMPORTED target as SYSTEM (Python headers in pybind11::module).\n# This may be needed to resolve header conflicts, e.g. between Python release and debug headers.\nset_target_properties(test_installed_target PROPERTIES NO_SYSTEM_FROM_IMPORTED ON)\n```\n\n----------------------------------------\n\nTITLE: Installing and Exporting pybind11 CMake Targets\nDESCRIPTION: Defines the export name for CMake targets (defaulting to `pybind11Targets` if `PYBIND11_EXPORT_NAME` is not set) and installs the `pybind11_headers` target. It then exports this target set under the `pybind11::` namespace to the configured CMake installation directory (`PYBIND11_CMAKECONFIG_INSTALL_DIR`), allowing other projects to find and use pybind11 via `find_package`. This snippet is conditional on `PYBIND11_INSTALL` being true.\nSOURCE: https://github.com/pybind/pybind11/blob/master/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\n  # ... inside if(PYBIND11_INSTALL)\n  if(NOT PYBIND11_EXPORT_NAME)\n    set(PYBIND11_EXPORT_NAME \"${PROJECT_NAME}Targets\")\n  endif()\n\n  install(TARGETS pybind11_headers EXPORT \"${PYBIND11_EXPORT_NAME}\")\n\n  install(\n    EXPORT \"${PYBIND11_EXPORT_NAME}\"\n    NAMESPACE \"pybind11::\"\n    DESTINATION ${PYBIND11_CMAKECONFIG_INSTALL_DIR})\n```\n\n----------------------------------------\n\nTITLE: Defining Python Executable Dependency in CMake\nDESCRIPTION: This section defines the Python executable based on existing definitions, providing flexibility for different build environments.  It checks if either `Python_EXECUTABLE` or `PYTHON_EXECUTABLE` is set and sets `_Python_EXECUTABLE` accordingly. If neither is found, it throws a fatal error. This ensures the correct Python interpreter is used when running the tests. This is crucial for the correct execution of tests dependent on the Python environment.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/subdirectory_function/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(DEFINED Python_EXECUTABLE)\n  set(_Python_EXECUTABLE \"${Python_EXECUTABLE}\")\nelseif(DEFINED PYTHON_EXECUTABLE)\n  set(_Python_EXECUTABLE \"${PYTHON_EXECUTABLE}\")\nelse()\n  message(FATAL_ERROR \"No Python executable defined (should not be possible at this stage)\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Upgrade maximum supported CMake version\nDESCRIPTION: Upgraded the maximum supported CMake version to 3.27 to fix CMP0148 warnings.  This ensures compatibility with newer CMake releases.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_30\n\n\n\n----------------------------------------\n\nTITLE: Handling Eigen Dependency for pybind11 Tests in CMake\nDESCRIPTION: Checks if Eigen test files (`test_eigen_matrix.cpp`, `test_eigen_tensor.cpp`) are present in the list of test files. If so, it attempts to find an installed Eigen library (version 3.2.7+) using `find_package` in CONFIG mode first, then falling back to MODULE mode. If `DOWNLOAD_EIGEN` is set, it uses `FetchContent` to download Eigen from a specified Git repository and version. It sets `EIGEN3_FOUND`, `EIGEN3_INCLUDE_DIR`, `EIGEN3_VERSION`, and defines an imported interface target `Eigen3::Eigen`. If Eigen is not found or downloaded, the corresponding test files are removed from the build list.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\n# keep it in PYBIND11_PYTEST_FILES, so that we get the \"eigen is not installed\"\n# skip message).\nlist(FIND PYBIND11_TEST_FILES test_eigen_matrix.cpp PYBIND11_TEST_FILES_EIGEN_I)\nif(PYBIND11_TEST_FILES_EIGEN_I EQUAL -1)\n  list(FIND PYBIND11_TEST_FILES test_eigen_tensor.cpp PYBIND11_TEST_FILES_EIGEN_I)\nendif()\nif(PYBIND11_TEST_FILES_EIGEN_I GREATER -1)\n  # Try loading via newer Eigen's Eigen3Config first (bypassing tools/FindEigen3.cmake).\n  # Eigen 3.3.1+ exports a cmake 3.0+ target for handling dependency requirements, but also\n  if(DOWNLOAD_EIGEN)\n    if(CMAKE_VERSION VERSION_LESS 3.18)\n      set(_opts)\n    else()\n      set(_opts SOURCE_SUBDIR no-cmake-build)\n    endif()\n    include(FetchContent)\n    FetchContent_Declare(\n      eigen\n      GIT_REPOSITORY \"${PYBIND11_EIGEN_REPO}\"\n      GIT_TAG \"${PYBIND11_EIGEN_VERSION_HASH}\"\n      ${_opts})\n    FetchContent_MakeAvailable(eigen)\n    if(NOT CMAKE_VERSION VERSION_LESS 3.18)\n      set(EIGEN3_INCLUDE_DIR \"${eigen_SOURCE_DIR}\")\n    endif()\n\n    set(EIGEN3_INCLUDE_DIR ${eigen_SOURCE_DIR})\n    set(EIGEN3_FOUND TRUE)\n    # When getting locally, the version is not visible from a superprojet,\n    # so just force it.\n    set(EIGEN3_VERSION \"${PYBIND11_EIGEN_VERSION_STRING}\")\n\n  else()\n    find_package(Eigen3 3.2.7 QUIET CONFIG)\n\n    if(NOT EIGEN3_FOUND)\n      # Couldn't load via target, so fall back to allowing module mode finding, which will pick up\n      # tools/FindEigen3.cmake\n      find_package(Eigen3 3.2.7 QUIET)\n    endif()\n  endif()\n\n  if(EIGEN3_FOUND)\n    if(NOT TARGET Eigen3::Eigen)\n      add_library(Eigen3::Eigen IMPORTED INTERFACE)\n      set_property(TARGET Eigen3::Eigen PROPERTY INTERFACE_INCLUDE_DIRECTORIES\n                                                 \"${EIGEN3_INCLUDE_DIR}\")\n    endif()\n\n    # Eigen 3.3.1+ cmake sets EIGEN3_VERSION_STRING (and hard codes the version when installed\n    # rather than looking it up in the cmake script); older versions, and the\n    # tools/FindEigen3.cmake, set EIGEN3_VERSION instead.\n    if(NOT EIGEN3_VERSION AND EIGEN3_VERSION_STRING)\n      set(EIGEN3_VERSION ${EIGEN3_VERSION_STRING})\n    endif()\n    message(STATUS \"Building tests with Eigen v${EIGEN3_VERSION}\")\n\n    if(NOT (CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 5.0))\n      tests_extra_targets(\"test_eigen_tensor.py\" \"eigen_tensor_avoid_stl_array\")\n    endif()\n\n  else()\n    list(FIND PYBIND11_TEST_FILES test_eigen_matrix.cpp PYBIND11_TEST_FILES_EIGEN_I)\n    if(PYBIND11_TEST_FILES_EIGEN_I GREATER -1)\n      list(REMOVE_AT PYBIND11_TEST_FILES ${PYBIND11_TEST_FILES_EIGEN_I})\n    endif()\n\n    list(FIND PYBIND11_TEST_FILES test_eigen_tensor.cpp PYBIND11_TEST_FILES_EIGEN_I)\n    if(PYBIND11_TEST_FILES_EIGEN_I GREATER -1)\n      list(REMOVE_AT PYBIND11_TEST_FILES ${PYBIND11_TEST_FILES_EIGEN_I})\n    endif()\n    message(STATUS \"Building tests WITHOUT Eigen, use -DDOWNLOAD_EIGEN=ON to download\")\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Finding and Configuring Boost Dependency in CMake\nDESCRIPTION: Uses `find_package(Boost 1.56)` to locate the Boost library, requiring at least version 1.56 for `boost::variant` support in some tests. If Boost is found (`Boost_FOUND` is TRUE), it defines an imported interface library target `Boost::headers`. This target standardizes access to Boost headers by setting its `INTERFACE_INCLUDE_DIRECTORIES` or `INTERFACE_LINK_LIBRARIES` property depending on the CMake version and how `FindBoost` was configured.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\n# Optional dependency for some tests (boost::variant is only supported with version >= 1.56)\nfind_package(Boost 1.56)\n\nif(Boost_FOUND)\n  if(NOT TARGET Boost::headers)\n    add_library(Boost::headers IMPORTED INTERFACE)\n    if(TARGET Boost::boost)\n      # Classic FindBoost\n      set_property(TARGET Boost::headers PROPERTY INTERFACE_LINK_LIBRARIES Boost::boost)\n    else()\n      # Very old FindBoost, or newer Boost than CMake in older CMakes\n      set_property(TARGET Boost::headers PROPERTY INTERFACE_INCLUDE_DIRECTORIES\n                                                  ${Boost_INCLUDE_DIRS})\n    endif()\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Embedding the Python Interpreter using pybind11 in a C++ Executable - CMake\nDESCRIPTION: This CMake build script configures a C++ executable project that embeds the Python interpreter via pybind11's embed interface target. It requires CMake 3.15+ and the pybind11 library, with at least one C++ source (main.cpp). The main executable is linked against pybind11::embed, which ensures Python headers and libraries are attached as needed. No manual compiler settings are necessary thanks to the interface target. The result is a C++ binary capable of running or scripting Python directly. Ensure the Python development packages are available on your system.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_17\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15...4.0)\nproject(example LANGUAGES CXX)\n\nfind_package(pybind11 REQUIRED)  # or add_subdirectory(pybind11)\n\nadd_executable(example main.cpp)\ntarget_link_libraries(example PRIVATE pybind11::embed)\n```\n\n----------------------------------------\n\nTITLE: Managing Build Dependencies and Subdirectory Inclusion\nDESCRIPTION: The code sets up dependency relationships between main build and test targets, ensuring 'test_cmake_build' depends on 'check'. It also includes subdirectories for targeted build configurations, excluding them from default build targets to organize project components systematically.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_dependencies(check test_cmake_build)\n\nadd_subdirectory(subdirectory_target EXCLUDE_FROM_ALL)\nadd_subdirectory(subdirectory_embed EXCLUDE_FROM_ALL)\n```\n\n----------------------------------------\n\nTITLE: Guard against crashes caused by MSVC versions\nDESCRIPTION: Safeguards were implemented to prevent crashes and corruption caused by modules built with different MSVC versions. This ensures the robustness of the library across various compiler configurations.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_7\n\n\n\n----------------------------------------\n\nTITLE: Set 'external_module' Dependencies for Testing\nDESCRIPTION: This snippet adds a dependency so that the 'cpptest' target depends on the successful build of the 'external_module', ensuring proper build order before running tests.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_embed/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nadd_dependencies(check cpptest)\n```\n\n----------------------------------------\n\nTITLE: Binding Opaque STL Vector using py::class_ C++\nDESCRIPTION: pybind11 code demonstrating how to manually bind an opaque `std::vector<int>` (declared opaque using `PYBIND11_MAKE_OPAQUE`) as a Python class named \"IntVector\". Since automatic conversion is disabled, explicit definitions are required for methods like `clear`, `pop_back`, `__len__`, and `__iter__` to provide Python list-like behavior. `py::keep_alive` is used to manage object lifetimes when exposing iterators.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/stl.rst#_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\npy::class_<std::vector<int>>(m, \"IntVector\")\n    .def(py::init<>())\n    .def(\"clear\", &std::vector<int>::clear)\n    .def(\"pop_back\", &std::vector<int>::pop_back)\n    .def(\"__len__\", [](const std::vector<int> &v) { return v.size(); })\n    .def(\"__iter__\", [](std::vector<int> &v) {\n       return py::make_iterator(v.begin(), v.end());\n    }, py::keep_alive<0, 1>()) /* Keep vector alive while iterator is used */\n    // ....\n```\n\n----------------------------------------\n\nTITLE: Manually Building and Uploading Pybind11 Packages\nDESCRIPTION: These commands build the sdist and wheel packages for pybind11 using the 'nox build' session. The 'twine upload dist/*' command then uploads all built packages found in the 'dist/' directory to the configured package index, typically PyPI. This is an alternative to automated CI uploads.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/release.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnox -s build\ntwine upload dist/*\n```\n\n----------------------------------------\n\nTITLE: Compilation Environment Setup in Bash\nDESCRIPTION: Shows the compiler version and compilation flags used for the benchmark. The flags enable optimization for size, shared library creation, and C++14 standard with hidden visibility for symbols.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/benchmark.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nApple LLVM version 7.0.2 (clang-700.1.81)\n```\n\n----------------------------------------\n\nTITLE: Using unique_ptr with a Function and py::class_\nDESCRIPTION: This code snippet shows the potential issue that may arise when using std::unique_ptr within a function when working with a pybind11 class. While the create_example function might function fine using py::class_<Example>, this function will cause problems and fail with py::class_<Example>. It indicates an issue with the underlying holder type and is fixed when using py::class_<Example, py::smart_holder>.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/smart_ptrs.rst#_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nvoid do_something_with_example(std::unique_ptr<Example> ex) { ... }\n```\n\n----------------------------------------\n\nTITLE: Use new PyCode API on Python 3.12+\nDESCRIPTION: The library was updated to utilize the new PyCode API on Python 3.12 and later versions, ensuring compatibility and leveraging the latest features provided by the Python interpreter.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_10\n\n\n\n----------------------------------------\n\nTITLE: Compilation Flags for Benchmark in Bash\nDESCRIPTION: The specific compilation flags used for both pybind11 and Boost.Python during the benchmark. These flags enable size optimization, shared library creation, and other settings for fair comparison.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/benchmark.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ng++ -Os -shared -rdynamic -undefined dynamic_lookup -fvisibility=hidden -std=c++14\n```\n\n----------------------------------------\n\nTITLE: Binding Class with Trampoline (Old Syntax) - C++ pybind11\nDESCRIPTION: This snippet shows the old syntax (pre v2.0.0-rc1) for binding a C++ class (`MyClass`) that uses a Python trampoline class (`TrampolineClass`) for overriding virtual methods. It involves using `py::class_<TrampolineClass>` followed by `.alias<MyClass>()`. This syntax is deprecated as of v2.0.0-rc1.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_59\n\nLANGUAGE: cpp\nCODE:\n```\npy::class_<TrampolineClass>(\"MyClass\")\n  .alias<MyClass>()\n  ....\n```\n\n----------------------------------------\n\nTITLE: PyGILState_Check() enabled by default\nDESCRIPTION: `PyGILState_Check()`'s in `pybind11::handle`'s `inc_ref()` & `dec_ref()` are now enabled by default again.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_46\n\n\n\n----------------------------------------\n\nTITLE: Bumping Pybind11 Homebrew Formula\nDESCRIPTION: This command uses the Homebrew 'bump-formula-pr' utility to create a pull request to update the pybind11 formula. It fetches the new release tarball from the provided URL, calculates checksums, and generates the necessary changes for a PR in the Homebrew/homebrew-core repository.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/release.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbrew bump-formula-pr --url https://github.com/pybind/pybind11/archive/vX.Y.Z.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Skip empty PYBIND11_PYTHON_EXECUTABLE_LAST\nDESCRIPTION: Empty `PYBIND11_PYTHON_EXECUTABLE_LAST` entries are now skipped for the first CMake run. This improves build process efficiency.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_21\n\n\n\n----------------------------------------\n\nTITLE: Organizing Header Files in IDEs using CMake source_group\nDESCRIPTION: Uses the `source_group` command with the `TREE` option to create a virtual folder named \"Header Files\" in IDE projects (like Visual Studio or Xcode). This group contains all pybind11 header files specified in the `PYBIND11_HEADERS` variable, sourced relatively from the `../include` directory, improving code organization within the IDE.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\n# Provide nice organisation in IDEs\nsource_group(\n  TREE \"${CMAKE_CURRENT_SOURCE_DIR}/../include\"\n  PREFIX \"Header Files\"\n  FILES ${PYBIND11_HEADERS})\n```\n\n----------------------------------------\n\nTITLE: Example of Raw Pointer Usage Leading to Memory Errors (C++)\nDESCRIPTION: This C++ snippet illustrates a potential pitfall when using raw pointers with pybind11. The `Parent` class holds a `shared_ptr` to a `Child` object, but the `get_child` method returns a raw pointer.  This can lead to double-free or heap-use-after-free errors in Python if the lifetime of the returned pointer is not carefully managed. Depends on pybind11.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nclass Child { };\n\nclass Parent {\npublic:\n   Parent() : child(std::make_shared<Child>()) { }\n   Child *get_child() { return child.get(); }  /* DANGER */\nprivate:\n    std::shared_ptr<Child> child;\n};\n\nPYBIND11_MODULE(example, m) {\n    py::class_<Child, std::shared_ptr<Child>>(m, \"Child\");\n\n    py::class_<Parent, std::shared_ptr<Parent>>(m, \"Parent\")\n       .def(py::init<>())\n       .def(\"get_child\", &Parent::get_child);  /* PROBLEM */\n}\n```\n\n----------------------------------------\n\nTITLE: Enforcing Minimum Compiler Versions in pybind11 v2.1\nDESCRIPTION: The code enforces minimum compiler versions such as GCC >= 4.8, clang >= 3.3, MSVC >= 2015u3, and Intel C++ >= 15.0 at compile time to ensure compatibility and proper feature support.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/upgrade.rst#_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\n// Compile-time version checks are implemented internally in pybind11; no user code snippet provided.\n```\n\n----------------------------------------\n\nTITLE: Fixed base_enum.__str__ docstring\nDESCRIPTION: Corrected the docstring for `base_enum.__str__`. This improves documentation accuracy for enum string representation.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_16\n\n\n\n----------------------------------------\n\nTITLE: buffer_info gained item_type_is_equivalent_to()\nDESCRIPTION: `buffer_info` gained an `item_type_is_equivalent_to<T>()` member function.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_44\n\n\n\n----------------------------------------\n\nTITLE: Using Embedded Modules with Local Python Scripts in Embedded pybind11 Interpreter\nDESCRIPTION: Demonstrates interaction between embedded C++ modules and locally loaded Python scripts. Defines an embedded module exposing a variable, imports a Python script that uses it, and executes Python code that performs calculations and string formatting, illustrating natural integration and data sharing across boundaries.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/embedding.rst#_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n#include <pybind11/embed.h>\nnamespace py = pybind11;\n\nPYBIND11_EMBEDDED_MODULE(cpp_module, m) {\n    m.attr(\"a\") = 1;\n}\n\nint main() {\n    py::scoped_interpreter guard{};\n\n    auto py_module = py::module_::import(\"py_module\");\n\n    auto locals = py::dict(\"fmt\"_a=\"{} + {} = {}\", **py_module.attr(\"__dict__\"));\n    assert(locals[\"a\"].cast<int>() == 1);\n    assert(locals[\"b\"].cast<int>() == 2);\n\n    py::exec(R\"(\n        c = a + b\n        message = fmt.format(a, b, c)\n    )\", py::globals(), locals);\n\n    assert(locals[\"c\"].cast<int>() == 3);\n    assert(locals[\"message\"].cast<std::string>() == \"1 + 2 = 3\");\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling a pybind11 C++ Extension Module on Linux (Bash)\nDESCRIPTION: This shell command compiles the example.cpp file with pybind11 bindings into a shared object suitable for Python import. Dependencies: c++ compiler, pybind11 installed, python3 available. Key parameters include optimization flags, pybind11 include path, and Python extension suffixes. Input: example.cpp; Output: binary module example<suffix>. Limitation: designed for Linux/macOS; flags may differ on Windows.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/basics.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nc++ -O3 -Wall -shared -std=c++11 -fPIC $(python3 -m pybind11 --includes) example.cpp -o example$(python3 -m pybind11 --extension-suffix)\n```\n\n----------------------------------------\n\nTITLE: Adding pybind11 as a Git Submodule - Bash\nDESCRIPTION: This snippet demonstrates how to add the pybind11 repository as a Git submodule within your project, allowing for easy dependency management and integration. Requires Git and a working repository. The first command adds pybind11 as a submodule (using the 'stable' branch) within the 'extern/' directory, and the second initializes and fetches submodule content. The relative URL is suitable for GitHub-based projects but can be replaced with a full HTTPS or SSH path for other platforms.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/installing.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit submodule add -b stable ../../pybind/pybind11 extern/pybind11\ngit submodule update --init\n```\n\n----------------------------------------\n\nTITLE: Defining a C++ Matrix Class with Raw Data Access - C++\nDESCRIPTION: This code defines a simple Matrix class in C++ that allocates a contiguous array of floats on the heap to represent a 2D matrix. The class exposes methods to get the data pointer as well as the number of rows and columns. This forms the basis for later Python bindings that enable efficient sharing of matrix data. No external dependencies are required beyond the standard library.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nclass Matrix {\npublic:\n    Matrix(size_t rows, size_t cols) : m_rows(rows), m_cols(cols) {\n        m_data = new float[rows*cols];\n    }\n    float *data() { return m_data; }\n    size_t rows() const { return m_rows; }\n    size_t cols() const { return m_cols; }\nprivate:\n    size_t m_rows, m_cols;\n    float *m_data;\n};\n```\n\n----------------------------------------\n\nTITLE: Python_ADDITIONAL_VERSIONS includes 3.12\nDESCRIPTION: `Python_ADDITIONAL_VERSIONS` (classic search) now includes 3.12, expanding the range of supported Python versions in build configurations.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_23\n\n\n\n----------------------------------------\n\nTITLE: Binding Base Class Methods via Derived Class in C++ using pybind11\nDESCRIPTION: This C++ snippet demonstrates how pybind11 allows binding a method defined in a base class (`Base::foo`) directly through a derived class (`Derived`) using `py::class_<Derived>.def()`, even if the `Base` class itself is not explicitly bound. This showcases improved member function deduction introduced in pybind11.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_57\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Base {\n    int foo() { return 42; }\n}\n\nstruct Derived : Base {}\n\n// Now works, but previously required also binding `Base`\npy::class_<Derived>(m, \"Derived\")\n    .def(\"foo\", &Derived::foo); // function is actually from `Base`\n```\n\n----------------------------------------\n\nTITLE: Binding C++ Function with Named Arguments for Python (C++)\nDESCRIPTION: This snippet exposes the add function with explicit argument names using py::arg, making Python calls more readable and allowing keyword argument usage. Dependencies: pybind11 headers. Inputs: two integers (keywords supported, e.g., i=1, j=2). Output: sum as integer. Limitation: positional and keyword arguments must match parameter names.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/basics.rst#_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"add\", &add, \"A function which adds two numbers\",\n      py::arg(\"i\"), py::arg(\"j\"));\n```\n\n----------------------------------------\n\nTITLE: Correctly detect CMake FindPython removal\nDESCRIPTION: Correctly detect CMake FindPython removal when used as a subdirectory. This ensures the build system functions as expected within projects.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_25\n\n\n\n----------------------------------------\n\nTITLE: Adding Custom Target for Testing in CMake\nDESCRIPTION: This snippet adds a custom target named `check_installed_target` for testing the installed Python extension. It uses the `CMAKE_COMMAND` to execute a shell command which sets the `PYTHONPATH` environment variable to point to the output directory of the built module. It then calls the Python executable to run `../test.py`. The `DEPENDS` keyword specifies the built module `test_installed_target` as a dependency. The script tests the built module.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/installed_target/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(\n  check_installed_target\n  ${CMAKE_COMMAND}\n  -E\n  env\n  PYTHONPATH=$<TARGET_FILE_DIR:test_installed_target>\n  ${_Python_EXECUTABLE}\n  ${PROJECT_SOURCE_DIR}/../test.py\n  ${PROJECT_NAME}\n  DEPENDS test_installed_target)\n```\n\n----------------------------------------\n\nTITLE: Shorthand Syntax for Argument Naming in pybind11 (C++)\nDESCRIPTION: This snippet demonstrates the regular py::arg and shorthand 'literals' notation for specifying named arguments in bindings. The using directive exposes C++11 literal operators for cleaner code. Only the pybind11::literals namespace contents (_a) are imported. Inputs/outputs match previous examples, but syntax is shorter.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/basics.rst#_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n// regular notation\nm.def(\"add1\", &add, py::arg(\"i\"), py::arg(\"j\"));\n// shorthand\nusing namespace pybind11::literals;\nm.def(\"add2\", &add, \"i\"_a, \"j\"_a);\n```\n\n----------------------------------------\n\nTITLE: PYBIND11_ASSERT_GIL_HELD_INCREF_DECREF disabled\nDESCRIPTION: `PYBIND11_ASSERT_GIL_HELD_INCREF_DECREF` was disabled for PyPy in general (not just PyPy Windows).\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_39\n\n\n\n----------------------------------------\n\nTITLE: Implementing Positional-only Arguments in PyBind11\nDESCRIPTION: Shows how to define Python positional-only arguments in C++ bindings using the py::pos_only() marker, which prevents arguments from being passed by keyword.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/functions.rst#_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nm.def(\"f\", [](int a, int b) { /* ... */ },\n      py::arg(\"a\"), py::pos_only(), py::arg(\"b\"));\n```\n\n----------------------------------------\n\nTITLE: Enabling Dynamic Attributes in pybind11 Classes\nDESCRIPTION: This snippet shows how to activate dynamic attribute support for C++ classes in pybind11 by passing `py::dynamic_attr()` as a constructor argument. It allows adding attributes at runtime directly on C++ bound objects, similar to native Python classes.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\npy::class_<Pet>(m, \"Pet\", py::dynamic_attr())\n    .def(py::init<>())\n    .def_readwrite(\"name\", &Pet::name);\n```\n\n----------------------------------------\n\nTITLE: Main Module File for Split Bindings (C++)\nDESCRIPTION: The main C++ file for a pybind11 module named `example`. It declares initialization functions (`init_ex1`, `init_ex2`, etc.) from other source files and calls them within the `PYBIND11_MODULE` macro. This structure allows splitting binding code across multiple compilation units to reduce build times and memory usage.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/faq.rst#_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nvoid init_ex1(py::module_ &);\nvoid init_ex2(py::module_ &);\n/* ... */\n\nPYBIND11_MODULE(example, m) {\n    init_ex1(m);\n    init_ex2(m);\n    /* ... */\n}\n```\n\n----------------------------------------\n\nTITLE: Render typed iterators for make_iterator\nDESCRIPTION: Typed iterators were rendered for `make_iterator`, `make_key_iterator`, and `make_value_iterator`.  This improves the clarity of the typing in these iterator implementations.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_13\n\n\n\n----------------------------------------\n\nTITLE: Function Restricting to Dense C-Style NumPy Arrays with Forced Casting - C++\nDESCRIPTION: This function demonstrates constraining argument acceptance to dense, C-contiguous (row-major) NumPy arrays of doubles using py::array_t and py::array::c_style | py::array::forcecast. The forcecast flag automatically casts non-conforming inputs. Requires pybind11/numpy.h. Input: NumPy array (preferably double, C-style); Output: none. Non-C-style or wrong-type arrays are coerced or cause failure.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nvoid f(py::array_t<double, py::array::c_style | py::array::forcecast> array);\n```\n\n----------------------------------------\n\nTITLE: Defining Buffer Descriptor Structure - C++\nDESCRIPTION: This snippet defines the py::buffer_info structure used to communicate buffer details between Python and C++. The structure stores pointer information, element size, format description string, dimensionality, shape, and strides. It is essential for exposing custom buffer-compatible types. No dependencies beyond pybind11; typically used internally when writing .def_buffer() lambdas.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nstruct buffer_info {\n    void *ptr;\n    py::ssize_t itemsize;\n    std::string format;\n    py::ssize_t ndim;\n    std::vector<py::ssize_t> shape;\n    std::vector<py::ssize_t> strides;\n};\n```\n\n----------------------------------------\n\nTITLE: Setting pybind11_FOUND Cache Variable in CMake\nDESCRIPTION: Sets the internal cache variable `pybind11_FOUND` to TRUE when pybind11 is being included as a subproject (i.e., `PYBIND11_MASTER_PROJECT` is false). This provides a consistent way for the parent project to know that pybind11 components are available, similar to how `find_package(pybind11 CONFIG)` would set this variable.\nSOURCE: https://github.com/pybind/pybind11/blob/master/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\n# Better symmetry with find_package(pybind11 CONFIG) mode.\nif(NOT PYBIND11_MASTER_PROJECT)\n  set(pybind11_FOUND\n      TRUE\n      CACHE INTERNAL \"True if pybind11 and all required components found on the system\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining C++ Function with Default Arguments (C++)\nDESCRIPTION: This code defines a C++ function add with default values for both parameters. No pybind11 binding yet shown—this purely demonstrates the function implementation. Inputs: zero, one, or two integers; Outputs: their sum. Limitations: pybind11 cannot auto-extract default values, which must be set manually in bindings.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/basics.rst#_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nint add(int i = 1, int j = 2) {\n    return i + j;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Using a pybind11-Exposed Function in Python (Pycon)\nDESCRIPTION: This Python console session demonstrates importing the compiled example module and calling the add function. Prerequisites: compiled example module present in the current directory. Input: import and function call with two integers; Output: result of addition printed to standard output.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/basics.rst#_snippet_5\n\nLANGUAGE: pycon\nCODE:\n```\n$ python\nPython 3.9.10 (main, Jan 15 2022, 11:48:04)\n[Clang 13.0.0 (clang-1300.0.29.3)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import example\n>>> example.add(1, 2)\n3\n>>>\n```\n\n----------------------------------------\n\nTITLE: Evaluating Python Code Using Raw String Literals\nDESCRIPTION: This snippet utilizes C++11 raw string literals to make the in-line Python code more readable when evaluating sequences of Python statements using `py::exec`.  It passes the Python code as a single string to `py::exec`, and it relies on the presence of the scope object to act as the evaluation context. The input is the python code enclosed in a raw string and the scope, the output is the execution of the Python code.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/utilities.rst#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\npy::exec(R\"(\n    x = get_answer()\n    if x == 42:\n        print('Hello World!')\n    else:\n        print('Bye!')\n    )\", scope\n);\n```\n\n----------------------------------------\n\nTITLE: Custom Type Setup for Garbage Collection in C++ with pybind11\nDESCRIPTION: Advanced example showing how to directly manipulate the PyHeapTypeObject to enable garbage collection support for classes that own Python objects.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_41\n\nLANGUAGE: cpp\nCODE:\n```\nstruct OwnsPythonObjects {\n    py::object value = py::none();\n};\npy::class_<OwnsPythonObjects> cls(\n    m, \"OwnsPythonObjects\", py::custom_type_setup([](PyHeapTypeObject *heap_type) {\n        auto *type = &heap_type->ht_type;\n        type->tp_flags |= Py_TPFLAGS_HAVE_GC;\n        type->tp_traverse = [](PyObject *self_base, visitproc visit, void *arg) {\n            auto &self = py::cast<OwnsPythonObjects&>(py::handle(self_base));\n            Py_VISIT(self.value.ptr());\n            return 0;\n        };\n        type->tp_clear = [](PyObject *self_base) {\n            auto &self = py::cast<OwnsPythonObjects&>(py::handle(self_base));\n            self.value = py::none();\n            return 0;\n        };\n    }));\ncls.def(py::init<>());\ncls.def_readwrite(\"value\", &OwnsPythonObjects::value);\n```\n\n----------------------------------------\n\nTITLE: Exporting C++ Variables to Python Using pybind11 (C++)\nDESCRIPTION: This code assigns a C++ integer and a string (via py::cast) as Python-accessible module attributes. Requires: PYBIND11_MODULE context, pybind11 included. Inputs: primitive or object values; Outputs: accessible Python module attributes. Limitation: demonstration code, doesn't show full module context.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/basics.rst#_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\nPYBIND11_MODULE(example, m) {\n    m.attr(\"the_answer\") = 42;\n    py::object world = py::cast(\"World\");\n    m.attr(\"what\") = world;\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Skipping for PyPy and GraalPy Interpreters\nDESCRIPTION: This snippet checks the interpreter extension and ID to detect PyPy or GraalPy environments. If detected, it skips embedding tests by creating a dummy target. It also skips embedding if required targets are missing, ensuring compatibility.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_embed/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\npossibly_uninitialized(PYTHON_MODULE_EXTENSION Python_INTERPRETER_ID)\n\nif(\"${PYTHON_MODULE_EXTENSION}\" MATCHES \"pypy\" \n   OR \"${Python_INTERPRETER_ID}\" STREQUAL \"PyPy\" \n   OR \"${PYTHON_MODULE_EXTENSION}\" MATCHES \"graalpy\")\n  message(STATUS \"Skipping embed test on PyPy or GraalPy\")\n  add_custom_target(cpptest) # Dummy target on PyPy or GraalPy. Embedding is not supported.\n  set(_suppress_unused_variable_warning \"${DOWNLOAD_CATCH}\")\n  return()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining _Python_EXECUTABLE Variable\nDESCRIPTION: This block defines the _Python_EXECUTABLE variable based on the defined Python executable. First, it checks if Python_EXECUTABLE is defined. If it is, it sets _Python_EXECUTABLE to its value. If not, it checks if PYTHON_EXECUTABLE is defined and sets _Python_EXECUTABLE to that value. Otherwise, it throws an error if neither are defined. This is to ensure the test runs against the right python executable.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/subdirectory_target/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nif(DEFINED Python_EXECUTABLE)\n  set(_Python_EXECUTABLE \"${Python_EXECUTABLE}\")\nelseif(DEFINED PYTHON_EXECUTABLE)\n  set(_Python_EXECUTABLE \"${PYTHON_EXECUTABLE}\")\nelse()\n  message(FATAL_ERROR \"No Python executable defined (should not be possible at this stage)\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Initializing Aggregate Structs with pybind11 py::init in C++\nDESCRIPTION: This C++ code illustrates binding the implicit constructor of an aggregate struct (`Aggregate`) using pybind11. The `py::init<int, const std::string &>()` definition leverages C++11 brace initialization semantics (introduced in pybind11 pull #1015) to construct instances, allowing seamless binding of simple data structures without explicit constructors.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_58\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Aggregate {\n    int a;\n    std::string b;\n};\n\npy::class_<Aggregate>(m, \"Aggregate\")\n    .def(py::init<int, const std::string &>());\n```\n\n----------------------------------------\n\nTITLE: Optimized Static Initialization with `absl::call_once` and Non-Atomic Flag (C++)\nDESCRIPTION: Provides an optimized version using `absl::call_once` where the `init_done` flag is non-atomic. This optimization is possible because the GIL is held during the initial check of `init_done`, effectively serializing access to it. The core GIL management logic (release before `call_once`, acquire/release within the lambda, acquire after `call_once`) remains crucial for preventing deadlocks. This might offer a minor performance gain on some architectures.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/deadlock.md#_snippet_8\n\nLANGUAGE: c++\nCODE:\n```\n// CPython callback, assumes that the GIL is held on entry, and indeed anywhere\n// directly in this function (i.e. the GIL can be released inside CreateWidget,\n// but must be reaqcuired when that call returns).\nPyObject* InvokeWidget(PyObject* self) {\n  static constinit PyObject* impl = nullptr;\n  static constinit bool init_done = false;       // guarded by GIL\n  static constinit absl::once_flag init_flag;\n\n  if (!init_done) {\n    Py_BEGIN_ALLOW_THREADS                       // releases GIL\n                                                 // (multiple threads may enter here)\n    absl::call_once(init_flag, [&]() {\n                                                 // (only one thread enters here)\n      PyGILState_STATE s = PyGILState_Ensure();  // acquires GIL\n      impl = CreateWidget();\n      init_done = true;                          // (GIL is held)\n      PyGILState_Release(s);                     // releases GIL\n    });\n\n    Py_END_ALLOW_THREADS                         // acquires GIL\n  }\n\n  return PyObject_CallOneArg(impl, self);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Pybind11 Module with Split Bindings (Python)\nDESCRIPTION: An example of interacting with a pybind11 module compiled from split C++ files within a Python interpreter. It demonstrates importing the combined module (`example`) and successfully calling functions (`add`, `sub`) that were defined across multiple C++ binding files. Requires the module to be built and available in the Python environment.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/faq.rst#_snippet_7\n\nLANGUAGE: pycon\nCODE:\n```\n>>> import example\n>>> example.add(1, 2)\n3\n>>> example.sub(1, 1)\n0\n```\n\n----------------------------------------\n\nTITLE: PyAnimal Trampoline Class Definition\nDESCRIPTION: This code introduces the `PyAnimal` class, which inherits from `Animal` and `py::trampoline_self_life_support`. The `PyAnimal` class provides a trampoline for the `go()` virtual function using `PYBIND11_OVERRIDE_PURE`, allowing Python to override the method.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nclass PyAnimal : public Animal, py::trampoline_self_life_support {\npublic:\n    /* Inherit the constructors */\n    using Animal::Animal;\n\n    /* Trampoline (need one for each virtual function) */\n    std::string go(int n_times) override {\n        PYBIND11_OVERRIDE_PURE(\n            std::string, /* Return type */\n            Animal,      /* Parent class */\n            go,          /* Name of function in C++ (must match Python name) */\n            n_times      /* Argument(s) */\n        );\n    }\n};\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Matrix Methods from Python\nDESCRIPTION: Python code showing how to access matrices returned by C++ with different policies and their resulting behavior with regard to writability and data ownership.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/eigen.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\na = MyClass()\nm = a.get_matrix()  # flags.writeable = True,  flags.owndata = False\nv = a.view_matrix()  # flags.writeable = False, flags.owndata = False\nc = a.copy_matrix()  # flags.writeable = True,  flags.owndata = True\n# m[5,6] and v[5,6] refer to the same element, c[5,6] does not.\n```\n\n----------------------------------------\n\nTITLE: Preparing to Bind STL Containers with stl_bind C++\nDESCRIPTION: Includes the `pybind11/stl_bind.h` header, which provides convenience functions for binding opaque STL containers. It also uses `PYBIND11_MAKE_OPAQUE` for `std::vector<int>` and `std::map<std::string, double>` to disable automatic conversion, making them eligible for binding using the `stl_bind` functions.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/stl.rst#_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n// Don't forget this\n#include <pybind11/stl_bind.h>\n\nPYBIND11_MAKE_OPAQUE(std::vector<int>)\nPYBIND11_MAKE_OPAQUE(std::map<std::string, double>)\n```\n\n----------------------------------------\n\nTITLE: Binding a Custom C++ Class `Pet` with pybind11 in C++\nDESCRIPTION: This snippet demonstrates how to create a Python binding for a C++ `Pet` struct, including construction, method bindings, and usage of `py::class_`. It creates a Python class `Pet` with constructor, `setName`, and `getName` methods, enabling interaction with C++ objects from Python.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <pybind11/pybind11.h>\n\nnamespace py = pybind11;\n\nPYBIND11_MODULE(example, m) {\n    py::class_<Pet>(m, \"Pet\")\n        .def(py::init<const std::string &>())\n        .def(\"setName\", &Pet::setName)\n        .def(\"getName\", &Pet::getName);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Polymorphic Classes in Python\nDESCRIPTION: This Python snippet shows how to use the bound polymorphic classes. The example calls a function to get a `PolymorphicPet` and verifies that it is actually a `PolymorphicDog` and can call its specific `bark` method. Requires that the C++ code is built into a python module named 'example'.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> p = example.pet_store2()\n>>> type(p)\nPolymorphicDog  # automatically downcast\n>>> p.bark()\n'woof!'\n```\n\n----------------------------------------\n\nTITLE: Calling pybind11 Function with Keyword Arguments in Python (Pycon)\nDESCRIPTION: This interactive Python session shows calling a pybind11 function using keyword arguments and viewing the function signature in help. Requires a module with keyword-exposed arguments as described above. Inputs: integers specified as keywords. Outputs: operation result and auto-generated documentation with parameter names and types.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/basics.rst#_snippet_7\n\nLANGUAGE: pycon\nCODE:\n```\n>>> import example\n>>> example.add(i=1, j=2)\n3L\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> help(example)\n\n....\n\nFUNCTIONS\n    add(...)\n        Signature : (i: int, j: int) -> int\n\n        A function which adds two numbers\n```\n\n----------------------------------------\n\nTITLE: Managing Test Dependencies with Extra Targets in CMake\nDESCRIPTION: A macro for defining additional test targets that should be built when certain test files are included. It tracks needle tests (triggers) and their associated additional test targets.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nmacro(tests_extra_targets needles additions)\n  # Add the index for this relation to the index extra targets map.\n  list(LENGTH PYBIND11_TEST_EXTRA_TARGETS PYBIND11_TEST_EXTRA_TARGETS_LEN)\n  list(APPEND PYBIND11_TEST_EXTRA_TARGETS ${PYBIND11_TEST_EXTRA_TARGETS_LEN})\n  # Add the test names to look for, and the associated test target additions.\n  set(PYBIND11_TEST_EXTRA_TARGETS_NEEDLES_${PYBIND11_TEST_EXTRA_TARGETS_LEN} ${needles})\n  set(PYBIND11_TEST_EXTRA_TARGETS_ADDITION_${PYBIND11_TEST_EXTRA_TARGETS_LEN} ${additions})\nendmacro()\n```\n\n----------------------------------------\n\nTITLE: Defining Animal and Dog Classes\nDESCRIPTION: This code defines the base class `Animal` with a pure virtual function `go()` and a derived class `Dog` that overrides the `go()` function. It establishes the C++ class structure that will be used as a base for creating Python bindings.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nclass Animal {\npublic:\n    virtual ~Animal() { }\n    virtual std::string go(int n_times) = 0;\n};\n\nclass Dog : public Animal {\npublic:\n    std::string go(int n_times) override {\n        std::string result;\n        for (int i=0; i<n_times; ++i)\n            result += \"woof! \";\n        return result;\n    }\n};\n\n```\n\n----------------------------------------\n\nTITLE: Setting Python Executable in CMake\nDESCRIPTION: This snippet attempts to find the Python executable. It checks for the existence of either `Python_EXECUTABLE` or `PYTHON_EXECUTABLE` variables. If none of them is defined, the build fails with an error message. It ensures that a Python executable is available for the test stage later on in the file.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/installed_target/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(DEFINED Python_EXECUTABLE)\n  set(_Python_EXECUTABLE \"${Python_EXECUTABLE}\")\nelseif(DEFINED PYTHON_EXECUTABLE)\n  set(_Python_EXECUTABLE \"${PYTHON_EXECUTABLE}\")\nelse()\n  message(FATAL_ERROR \"No Python executable defined (should not be possible at this stage)\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Catch2-Based C++ Tests with Pybind11 in CMake\nDESCRIPTION: This CMake snippet locates the Catch2 testing framework, sets up logic based on its presence, and configures a C++ test executable named \"smart_holder_poc_test\" with Pybind11 and Catch2 headers. It creates a custom target to run pure C++ tests and manages dependencies between targets. Dependencies include the Catch2 (>=2.13.10) and Pybind11 CMake packages, along with the smart_holder_poc_test.cpp source file. Key variables: CATCH_FOUND, CATCH_VERSION. Outputs are target executables and test targets. Tests are skipped if Catch2 is unavailable; manual download or CMake download option is provided as remediation.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/pure_cpp/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(Catch 2.13.10)\n\nif(CATCH_FOUND)\n  message(STATUS \"Building pure C++ tests (not depending on Python) using Catch v${CATCH_VERSION}\")\nelse()\n  message(STATUS \"Catch not detected. Interpreter tests will be skipped. Install Catch headers\"\n                 \" manually or use `cmake -DDOWNLOAD_CATCH=ON` to fetch them automatically.\")\n  return()\nendif()\n\nadd_executable(smart_holder_poc_test smart_holder_poc_test.cpp)\npybind11_enable_warnings(smart_holder_poc_test)\ntarget_link_libraries(smart_holder_poc_test PRIVATE pybind11::headers Catch2::Catch2)\n\nadd_custom_target(\n  test_pure_cpp\n  COMMAND \"$<TARGET_FILE:smart_holder_poc_test>\"\n  WORKING_DIRECTORY \"${CMAKE_CURRENT_BINARY_DIR}\")\n\nadd_dependencies(check test_pure_cpp)\n```\n\n----------------------------------------\n\nTITLE: Defining Inter-module Test Dependencies in CMake\nDESCRIPTION: Configuration for test files that require additional modules to be built. These dependencies are only built if the corresponding test files are included in the test suite.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# Contains the set of test files that require pybind11_cross_module_tests to be\n# built; if none of these are built (i.e. because TEST_OVERRIDE is used and\n# doesn't include them) the second module doesn't get built.\ntests_extra_targets(\"test_exceptions.py;test_local_bindings.py;test_stl.py;test_stl_binders.py\"\n                    \"pybind11_cross_module_tests\")\n\n# And add additional targets for other tests.\ntests_extra_targets(\"test_exceptions.py\" \"cross_module_interleaved_error_already_set\")\ntests_extra_targets(\"test_gil_scoped.py\" \"cross_module_gil_utils\")\ntests_extra_targets(\"test_cpp_conduit.py\"\n                    \"exo_planet_pybind11;exo_planet_c_api;home_planet_very_lonely_traveler\")\n```\n\n----------------------------------------\n\nTITLE: Exposing 1D C++ Buffer as Memory View (C++)\nDESCRIPTION: Shows how to create a Python `memoryview` from a simple, contiguous 1D C++ buffer using `py::memoryview::from_memory`. This provides direct read/write access to the C++ memory region from Python. The C++ code must manage the buffer's lifetime. Requires `pybind11/pybind11.h`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_17\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"get_memoryview1d\", []() {\n    return py::memoryview::from_memory(\n        buffer,               // buffer pointer\n        sizeof(uint8_t) * 8   // buffer size\n    );\n});\n```\n\n----------------------------------------\n\nTITLE: Skip Embedding if Embed Libraries are Not Available\nDESCRIPTION: This snippet checks for the presence of 'Python::Module' target and the absence of 'Python::Python'. If embeddable Python libraries are not found, it skips embedding tests by creating a dummy target, maintaining build stability.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_embed/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(TARGET Python::Module AND NOT TARGET Python::Python)\n  message(STATUS \"Skipping embed test since no embed libs found\")\n  add_custom_target(cpptest) # Dummy target since embedding is not supported.\n  set(_suppress_unused_variable_warning \"${DOWNLOAD_CATCH}\")\n  return()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating Python Enum with Functional API (Python)\nDESCRIPTION: Demonstrates how to create a Python `enum.Enum` named \"Colors\" using the functional API, mapping string names (\"Red\", \"Green\") to integer values (0, 1). This is shown as context for how pybind11-bound C++ enums can behave similarly.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nColors = enum.Enum(\"Colors\", ((\"Red\", 0), (\"Green\", 1)))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Auto Conversion Pass-by-Reference Issue Python\nDESCRIPTION: Python code demonstrating that when a Python list is automatically converted to a C++ `std::vector` and passed by reference, modifications made to the vector in C++ (like `push_back`) are not reflected in the original Python list. This is because the automatic conversion involves a copy.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/stl.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> v = [5, 6]\n>>> append_1(v)\n>>> print(v)\n[5, 6]\n```\n\n----------------------------------------\n\nTITLE: Calculating Relative Python Include Directory in CMake\nDESCRIPTION: Determines the relative path from the CMake installation prefix (`CMAKE_INSTALL_PREFIX`) to the Python include directory (`Python_INCLUDE_DIRS` or `PYTHON_INCLUDE_DIR`). This is used when `USE_PYTHON_INCLUDE_DIR` is enabled to set `CMAKE_INSTALL_INCLUDEDIR`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# Relative directory setting\nif(USE_PYTHON_INCLUDE_DIR AND DEFINED Python_INCLUDE_DIRS)\n  file(RELATIVE_PATH CMAKE_INSTALL_INCLUDEDIR ${CMAKE_INSTALL_PREFIX} ${Python_INCLUDE_DIRS})\nelseif(USE_PYTHON_INCLUDE_DIR AND DEFINED PYTHON_INCLUDE_DIR)\n  file(RELATIVE_PATH CMAKE_INSTALL_INCLUDEDIR ${CMAKE_INSTALL_PREFIX} ${PYTHON_INCLUDE_DIRS})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing pybind11 with conda-forge - Bash\nDESCRIPTION: Uses the conda package manager to install pybind11 from the conda-forge channel, making the headers and integration files immediately available in the conda environment. Requires conda and access to conda-forge. Ensures correct dependency resolution and environment isolation, ideal for scientific and multi-language workflows.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/installing.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nconda install -c conda-forge pybind11\n```\n\n----------------------------------------\n\nTITLE: Defining a function that accepts a std::function<int(int)> and calls it with 10\nDESCRIPTION: This C++ function 'func_arg' receives any callable matching the signature 'int -> int' and executes it with the input 10, returning the result. It demonstrates the use of std::function for flexible callback handling.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/functional.rst#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nint func_arg(const std::function<int(int)> &f) {\n    return f(10);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a stateful lambda that returns a modified version of input function\nDESCRIPTION: This snippet defines 'func_ret', which takes a callback function and returns a new lambda that adds 1 to the result of the original function. It demonstrates capturing a callback in a closure to create layered functions.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/functional.rst#_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nstd::function<int(int)> func_ret(const std::function<int(int)> &f) {\n    return [f](int i) {\n        return f(i) + 1;\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Pybind11 Embedded Executable with CMake in C++\nDESCRIPTION: This snippet configures a CMake project for building a C++ executable that links against pybind11's embed target. It specifies the required CMake version, locates the pybind11 package, creates an executable from the 'embed.cpp' source file, and links it with pybind11 for embedded Python support. Additionally, it sets output properties, modifies include treatment to prevent system include flagging on imported targets to avoid header conflicts, and defines a custom build target 'check_installed_embed' which depends on the executable and runs a Python test script. This setup requires a functioning pybind11 installation and CMake 3.15 or newer.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/installed_embed/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15...4.0)  \n\nproject(test_installed_embed CXX)  \n\nfind_package(pybind11 CONFIG REQUIRED)  \nmessage(STATUS \"Found pybind11 v${pybind11_VERSION}: ${pybind11_INCLUDE_DIRS}\")  \n\nadd_executable(test_installed_embed ../embed.cpp)  \ntarget_link_libraries(test_installed_embed PRIVATE pybind11::embed)  \nset_target_properties(test_installed_embed PROPERTIES OUTPUT_NAME test_cmake_build)  \n\n# Do not treat includes from IMPORTED target as SYSTEM (Python headers in pybind11::embed).  \n# This may be needed to resolve header conflicts, e.g. between Python release and debug headers.  \nset_target_properties(test_installed_embed PROPERTIES NO_SYSTEM_FROM_IMPORTED ON)  \n\nadd_custom_target(  \n  check_installed_embed  \n  $<TARGET_FILE:test_installed_embed> ${PROJECT_SOURCE_DIR}/../test.py  \n  DEPENDS test_installed_embed)\n```\n\n----------------------------------------\n\nTITLE: Binding Final Classes in C++ with pybind11\nDESCRIPTION: Demonstrates how to use the py::is_final attribute to prevent Python inheritance from specific C++ classes, even if they aren't declared final in C++.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_36\n\nLANGUAGE: cpp\nCODE:\n```\nclass IsFinal final {};\n\npy::class_<IsFinal>(m, \"IsFinal\", py::is_final());\n```\n\n----------------------------------------\n\nTITLE: Python Error Example for Non-Converting Arguments\nDESCRIPTION: Shows the Python interpreter behavior when calling functions with and without the noconvert() option. The floats_preferred function accepts an integer argument, while the floats_only function raises a TypeError.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/functions.rst#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\n>>> floats_preferred(4)\n2.0\n>>> floats_only(4)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: floats_only(): incompatible function arguments. The following argument types are supported:\n    1. (f: float) -> float\n\nInvoked with: 4\n```\n\n----------------------------------------\n\nTITLE: Function call_go() Definition\nDESCRIPTION: The `call_go()` function accepts a pointer to an `Animal` object and calls its `go()` method. This highlights how to work with the base class and use polymorphism, which is important for overriding functions in derived classes when using Python bindings.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nstd::string call_go(Animal *animal) {\n    return animal->go(3);\n}\n\n```\n\n----------------------------------------\n\nTITLE: BibTeX Citation Template\nDESCRIPTION: This snippet provides a BibTeX template for citing pybind11 in scientific publications. It includes the author names, year of publication, project URL, and title of the project.  This template is provided for academic integrity purposes.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/faq.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n@misc{pybind11,\n   author = {Wenzel Jakob and Jason Rhinelander and Dean Moldovan},\n   year = {2017},\n   note = {https://github.com/pybind/pybind11},\n   title = {pybind11 -- Seamless operability between C++11 and Python}\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling CMake's FindPython Module\nDESCRIPTION: This snippet showcases an alternative approach to finding Python in CMake, using the `PYBIND11_FINDPYTHON=ON` option to activate CMake's FindPython module instead of pybind11's custom search.  Requires CMake 3.18.2 or newer.  This is set before finding or adding pybind11 in `CMakeLists.txt`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/faq.rst#_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\n-DPYBIND11_FINDPYTHON=ON\n```\n\n----------------------------------------\n\nTITLE: Binding `name` Field as Read/Write Property in pybind11\nDESCRIPTION: This snippet demonstrates how to expose a `name` field of the `Pet` class directly as a read/write attribute in Python, allowing direct access and modification of `name` from Python code, assuming `name` is a public member.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\npy::class_<Pet>(m, \"Pet\")\n    .def(py::init<const std::string &>)\n    .def_readwrite(\"name\", &Pet::name);\n```\n\n----------------------------------------\n\nTITLE: Binding `name` Property via Getter and Setter in pybind11\nDESCRIPTION: This code binds the `name` property of `Pet` class using getter and setter methods through `def_property`, enabling attribute-like access in Python with automatic calls to the C++ functions, even if `name` is private.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\npy::class_<Pet>(m, \"Pet\")\n    .def(py::init<const std::string &>)\n    .def_property(\"name\", &Pet::getName, &Pet::setName);\n```\n\n----------------------------------------\n\nTITLE: Processing Python Dictionary in C++ Function with PyBind11\nDESCRIPTION: Demonstrates how to iterate over a Python dictionary in C++ code using PyBind11's py::dict wrapper class, converting keys and values to strings.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/functions.rst#_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvoid print_dict(const py::dict& dict) {\n    /* Easily interact with Python types */\n    for (auto item : dict)\n        std::cout << \"key=\" << std::string(py::str(item.first)) << \", \"\n                  << \"value=\" << std::string(py::str(item.second)) << std::endl;\n}\n\nm.def(\"print_dict\", &print_dict);\n```\n\n----------------------------------------\n\nTITLE: Initializing Uninitialized Variables in CMake\nDESCRIPTION: A utility macro that initializes variables if they haven't been defined yet. It iterates through provided variable names and sets them to an empty string if they don't have a value.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nmacro(possibly_uninitialized)\n  foreach(VARNAME ${ARGN})\n    if(NOT DEFINED \"${VARNAME}\")\n      set(\"${VARNAME}\" \"\")\n    endif()\n  endforeach()\nendmacro()\n```\n\n----------------------------------------\n\nTITLE: Copy Python Scripts if Building Out-of-Source\nDESCRIPTION: This code copies specific Python scripts into the binary directory when source and build directories differ, ensuring necessary scripts are available for testing or embedding purposes.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_embed/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_CURRENT_BINARY_DIR)\n  file(COPY test_interpreter.py test_trampoline.py DESTINATION \"${CMAKE_CURRENT_BINARY_DIR}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Python Executable if in FINDPYTHON Mode\nDESCRIPTION: This conditional statement checks if PYTHON_EXECUTABLE is defined but Python_EXECUTABLE isn't, and if so, it assigns PYTHON_EXECUTABLE to Python_EXECUTABLE.  This allows easier transition while supporting both modes. It aims to align the Python executable paths.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/subdirectory_target/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(DEFINED PYTHON_EXECUTABLE AND NOT DEFINED Python_EXECUTABLE)\n  set(Python_EXECUTABLE \"${PYTHON_EXECUTABLE}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining CMake Project with CXX Language\nDESCRIPTION: This snippet defines the project named \"test_subdirectory_target\" and specifies that it uses CXX (C++) as the language. This is a fundamental step to tell CMake about the project and the language used for it. It sets up the build environment for C++ code.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/subdirectory_target/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(test_subdirectory_target CXX)\n```\n\n----------------------------------------\n\nTITLE: Vectorized Function Usage Example in Python Console - Python\nDESCRIPTION: This Python console example shows how to call the vectorized C++ function from Python using NumPy arrays and scalars. Inputs: NumPy arrays x and y, scalar z; Outputs: NumPy array result. Demonstrates vectorization behavior achieved by the corresponding pybind11 binding.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\n>>> x = np.array([[1, 3], [5, 7]])\n>>> y = np.array([[2, 4], [6, 8]])\n>>> z = 3\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Required Version\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.15 to 4.0. This ensures compatibility with the CMake features used in the project.  It's a standard practice at the beginning of a CMakeLists.txt file to declare the minimum version needed to build the project correctly.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/subdirectory_target/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15...4.0)\n```\n\n----------------------------------------\n\nTITLE: Building a Python Extension Module with CMake and pybind11\nDESCRIPTION: A minimal CMake configuration to build a Python extension module with pybind11. It sets up the project, finds Python, locates the pybind11 package, and creates a module from a C++ source file.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15...4.0)\nproject(example LANGUAGES CXX)\n\nset(PYBIND11_FINDPYTHON ON)\nfind_package(pybind11 CONFIG REQUIRED)\n\npybind11_add_module(example example.cpp)\ninstall(TARGETS example DESTINATION .)\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Arguments with Custom Preview in PyBind11\nDESCRIPTION: Shows how to define default arguments for Python-exposed C++ functions, with control over the string representation shown in the function signature using arg_v.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/functions.rst#_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\npy::class_<MyClass>(\"MyClass\")\n    .def(\"myFunction\", py::arg_v(\"arg\", SomeType(123), \"SomeType(123)\"));\n```\n\n----------------------------------------\n\nTITLE: Creating the test_subdirectory_target Library (MODULE)\nDESCRIPTION: This code snippet adds a library target named \"test_subdirectory_target\". It specifies that the library is a module and links to the source file `../main.cpp`. This creates the compiled library for the project.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/subdirectory_target/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(test_subdirectory_target MODULE ../main.cpp)\nset_target_properties(test_subdirectory_target PROPERTIES OUTPUT_NAME test_cmake_build)\n```\n\n----------------------------------------\n\nTITLE: Adding pybind11 Subdirectory\nDESCRIPTION: This snippet adds the pybind11 subdirectory to the current project. It utilizes the `add_subdirectory` command to include pybind11 in the build process. This includes any build files that pybind11 depends on, in preparation to create python bindings.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/subdirectory_target/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(\"${pybind11_SOURCE_DIR}\" pybind11)\n```\n\n----------------------------------------\n\nTITLE: Handling *args and **kwargs in C++ with PyBind11\nDESCRIPTION: Shows how to implement a C++ function that accepts arbitrary positional and keyword arguments using PyBind11's py::args and py::kwargs classes.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/functions.rst#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvoid generic(py::args args, const py::kwargs& kwargs) {\n    /// .. do something with args\n    if (kwargs)\n        /// .. do something with kwargs\n}\n\n/// Binding code\nm.def(\"generic\", &generic);\n```\n\n----------------------------------------\n\nTITLE: Instantiating SimpleNamespace (C++)\nDESCRIPTION: This code snippet demonstrates how to create a `SimpleNamespace` object from within C++ using pybind11. It imports the `types` module and accesses the `SimpleNamespace` class. Then, it instantiates a `SimpleNamespace` and populates attributes with key-value pairs similar to the previous dictionary example.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/object.rst#_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nusing namespace pybind11::literals;  // to bring in the `_a` literal\npy::object SimpleNamespace = py::module_::import(\"types\").attr(\"SimpleNamespace\");\npy::object ns = SimpleNamespace(\"spam\"_a=py::none(), \"eggs\"_a=42);\n```\n\n----------------------------------------\n\nTITLE: Dachshund class Example\nDESCRIPTION: Illustrates how to ensure the C++ portion of the derived class is properly initialized within the derived class's constructor and how to avoid common inheritance pitfalls.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass Dachshund(Dog):\n    def __init__(self, name):\n        Dog.__init__(self)  # Without this, a TypeError is raised.\n        self.name = name\n\n    def bark(self):\n        return \"yap!\"\n\n```\n\n----------------------------------------\n\nTITLE: Configuration for scikit-build-core with pyproject.toml\nDESCRIPTION: A pyproject.toml configuration for building pybind11 modules with scikit-build-core. This defines the build system requirements and basic project metadata needed for Python packaging.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[build-system]\nrequires = [\"scikit-build-core\", \"pybind11\"]\nbuild-backend = \"scikit_build_core.build\"\n\n[project]\nname = \"example\"\nversion = \"0.1.0\"\n```\n\n----------------------------------------\n\nTITLE: Creating Build Requirements with pyproject.toml for setuptools\nDESCRIPTION: A pyproject.toml configuration for setuptools that ensures pybind11 is available during compilation. This implements PEP 517 to correctly handle build dependencies.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n[build-system]\nrequires = [\"setuptools\", \"pybind11\"]\nbuild-backend = \"setuptools.build_meta\"\n```\n\n----------------------------------------\n\nTITLE: Require Threads Package\nDESCRIPTION: This line ensures that the Threads package is found and required for subsequent target linking, providing necessary thread support for test execution.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_embed/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(Threads REQUIRED)\n```\n\n----------------------------------------\n\nTITLE: Replacing py::base<T>() with Template Arguments in pybind11 v2.0+\nDESCRIPTION: This snippet shows transitioning from 'py::base<T>()' to using 'T' as a template argument in 'py::class_'. This change supports multiple inheritance and simplifies class declarations in pybind11. The class type must be the first template argument, while base classes and other options can appear in any order afterward.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/upgrade.rst#_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\n// old version\npy::class_<Derived>(\"Derived\", py::base<Base>());\n```\n\nLANGUAGE: cpp\nCODE:\n```\n// new version\npy::class_<Derived, Base>(\"Derived\");\n```\n\nLANGUAGE: cpp\nCODE:\n```\n// multiple inheritance\npy::class_<Derived, Base1, Base2>(\"Derived\");\n```\n\n----------------------------------------\n\nTITLE: Python Interaction with Single Character Arguments in pybind11 Bound C++ Functions\nDESCRIPTION: Example Python usage showing correct passing of single-character strings to C++ char parameters, TypeError arising from integer inputs, usage of chr() to convert integers to characters, and note on using int8_t or uint8_t for 8-bit integer parameters instead of char.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/strings.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> example.pass_char(\"A\")\n'A'\n\n>>> example.pass_char(0x65)\nTypeError\n\n>>> example.pass_char(chr(0x65))\n'A'\n```\n\n----------------------------------------\n\nTITLE: Example Class and Binding Code in C++\nDESCRIPTION: Shows an example of a dummy class with four methods and how it's bound to Python using pybind11. The class has methods with randomly generated signatures containing various return values and parameters.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/benchmark.rst#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n...\nclass cl034 {\npublic:\n    cl279 *fn_000(cl084 *, cl057 *, cl065 *, cl042 *);\n    cl025 *fn_001(cl098 *, cl262 *, cl414 *, cl121 *);\n    cl085 *fn_002(cl445 *, cl297 *, cl145 *, cl421 *);\n    cl470 *fn_003(cl200 *, cl323 *, cl332 *, cl492 *);\n};\n...\n\nPYBIND11_MODULE(example, m) {\n    ...\n    py::class_<cl034>(m, \"cl034\")\n        .def(\"fn_000\", &cl034::fn_000)\n        .def(\"fn_001\", &cl034::fn_001)\n        .def(\"fn_002\", &cl034::fn_002)\n        .def(\"fn_003\", &cl034::fn_003)\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Type Objects in C++ with pybind11\nDESCRIPTION: Shows how to obtain the Python type object from a C++ class that has already been registered with pybind11.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/classes.rst#_snippet_40\n\nLANGUAGE: cpp\nCODE:\n```\npy::type T_py = py::type::of<T>();\n```\n\n----------------------------------------\n\nTITLE: Create handle_type_name specialization\nDESCRIPTION: Created `handle_type_name` specialization to type-hint variable length tuples. This feature enhances the library's ability to work with variable-length tuples within Python.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_19\n\n\n\n----------------------------------------\n\nTITLE: Render py::function as Callable\nDESCRIPTION: The docstring rendering for `py::function` was modified to display it as `Callable`, improving the clarity and accuracy of function type representation in documentation.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Creating Column-Major NumPy Arrays for Eigen\nDESCRIPTION: Python code showing how to create NumPy arrays with Fortran-style column-major ordering to match Eigen's default storage order.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/eigen.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nmyarray = np.array(source, order=\"F\")\n```\n\n----------------------------------------\n\nTITLE: Adding format_descriptor<> & npy_format_descriptor<> specializations\nDESCRIPTION: `format_descriptor<>` & `npy_format_descriptor<>` `PyObject *` specializations were added. The latter enables `py::array_t<PyObject *>` to/from-python conversions.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_43\n\n\n\n----------------------------------------\n\nTITLE: Python Calls Demonstrating UnicodeDecodeError When Passing Invalid UTF-8 Bytes to C++ std::string Parameter\nDESCRIPTION: Python snippet illustrating that passing invalid UTF-8 bytes to a C++ std::string parameter results in a UnicodeDecodeError during pybind11 implicit conversion on the return value. Shows usage of isinstance to confirm return type and example error raising.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/strings.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> isinstance(example.asymmetry(b\"have some bytes\"), str)\nTrue\n\n>>> example.asymmetry(b\"\\xba\\xd0\\xba\\xd0\")  # invalid utf-8 as bytes\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xba in position 0: invalid start byte\n```\n\n----------------------------------------\n\nTITLE: Adding py::typing::Iterator/Iterable\nDESCRIPTION: Introduced `py::typing::Iterator<T>` and `py::typing::Iterable<T>` to the library, providing type hinting capabilities for iterators and iterables.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Get rid of recursive template instantiations\nDESCRIPTION: Got rid of recursive template instantiations for concatenating type signatures on C++17 and higher, increasing build efficiency.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_52\n\n\n\n----------------------------------------\n\nTITLE: Setting PYBIND11_FINDPYTHON to OFF\nDESCRIPTION: Setting `PYBIND11_FINDPYTHON` to `OFF` forces the old FindPythonLibs mechanism to be used, providing compatibility and flexibility.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_20\n\n\n\n----------------------------------------\n\nTITLE: Bumping PYBIND11_INTERNALS_VERSION\nDESCRIPTION: The `PYBIND11_INTERNALS_VERSION` was bumped for MSVC, unlocking new features without introducing compatibility issues.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_6\n\n\n\n----------------------------------------\n\nTITLE: Remove upper bound in example pyproject.toml\nDESCRIPTION: Removed the upper bound in the example `pyproject.toml` for setuptools. This expands the range of supported dependencies.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_32\n\n\n\n----------------------------------------\n\nTITLE: Support DEBUG_POSFIX correctly\nDESCRIPTION: Correctly supports `DEBUG_POSFIX` for debug builds. This configures the build process based on the build type.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_28\n\n\n\n----------------------------------------\n\nTITLE: Test on PyPy 3.10\nDESCRIPTION: Tests were added for PyPy 3.10 to increase coverage and validation of the library.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_34\n\n\n\n----------------------------------------\n\nTITLE: Fix to grammar in functions.rst\nDESCRIPTION: Made a small fix to the grammar in `functions.rst`. This enhances the clarity of the documentation.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_31\n\n\n\n----------------------------------------\n\nTITLE: The capsule API gained user-friendly constructor\nDESCRIPTION: The `capsule` API gained a user-friendly constructor (`py::capsule(ptr, \"name\", dtor)``).\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_45\n\n\n\n----------------------------------------\n\nTITLE: Demonstrating Point2D Usage in Python\nDESCRIPTION: This Python snippet showcases how the C++ `negate` function (bound using pybind11) is intended to be used from the Python side. It imports the module `docs_advanced_cast_custom`, creates a list `point1`, calls the `negate` function, and asserts that the result is correct.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/custom.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom my_math_module import docs_advanced_cast_custom as m\n\npoint1 = [1.0, -1.0]\npoint2 = m.negate(point1)\nassert point2 == (-1.0, 1.0)\n```\n\n----------------------------------------\n\nTITLE: Link Libraries to Test Executable\nDESCRIPTION: This snippet links the 'test_embed' executable with pybind11's embedding library, Catch2 testing framework, and Threads support, integrating all dependencies required for testing embedded Python modules.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_embed/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(test_embed PRIVATE pybind11::embed Catch2::Catch2 Threads::Threads)\n```\n\n----------------------------------------\n\nTITLE: Assigning C++ Constants to Python Module Attributes via pybind11 in C++\nDESCRIPTION: Illustrates the enhanced capability in pybind11 wherein C++ types are automatically cast to Python types during attribute assignment without explicit py::cast calls. This snippet shows assigning an integer constant to a Python module attribute using pybind11's module attribute interface. Previously, explicit casting to py::object was needed to avoid compilation errors. This change simplifies code and improves interoperability by leveraging implicit conversions introduced in newer pybind11 versions.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_62\n\nLANGUAGE: cpp\nCODE:\n```\npy::module m = /* ... */\nm.attr(\"constant\") = 123;\n```\n\n----------------------------------------\n\nTITLE: Implementing call_guard Policy in C++\nDESCRIPTION: Shows how to use call_guard to wrap a function call with a scope guard, which can be useful for managing thread states or resources during function execution.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/functions.rst#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nm.def(\"foo\", foo, py::call_guard<T>());\n```\n\n----------------------------------------\n\nTITLE: Configuring Project with CMake\nDESCRIPTION: This snippet initializes the CMake project and sets the minimum CMake version.  It defines the project name as 'test_subdirectory_function' and specifies CXX as the language. It also conditionally sets Python_EXECUTABLE if PYTHON_EXECUTABLE is defined for compatibility. This is a fundamental setup for the rest of the build process, establishing the project's foundation and enabling the use of pybind11 library.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/subdirectory_function/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15...4.0)\n\nproject(test_subdirectory_function CXX)\n\n# Allow PYTHON_EXECUTABLE if in FINDPYTHON mode and building pybind11's tests\n# (makes transition easier while we support both modes).\nif(DEFINED PYTHON_EXECUTABLE AND NOT DEFINED Python_EXECUTABLE)\n  set(Python_EXECUTABLE \"${PYTHON_EXECUTABLE}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mutable Arguments in C++\nDESCRIPTION: Shows two simple C++ functions, `increment` and `increment_ptr`, that modify an integer argument passed by reference or pointer. This serves as a contrast to Python's handling of immutable types, illustrating a challenge when binding such C++ functions.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/faq.rst#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvoid increment(int &i) { i++; }\nvoid increment_ptr(int *i) { (*i)++; }\n```\n\n----------------------------------------\n\nTITLE: Working with Wide Character Strings in pybind11 C++ Bindings\nDESCRIPTION: Provides example binding functions accepting std::wstring and returning std::wstring, interoperating with Windows APIs such as SetWindowText and GetWindowText. Shows how pybind11 converts Python str to UTF-16 or UTF-32 appropriately depending on platform for wide strings, and decodes returned wide strings back to Python str. Requires Windows.h include and UNICODE definition.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/cast/strings.rst#_snippet_10\n\nLANGUAGE: c++\nCODE:\n```\n#define UNICODE\n#include <windows.h>\n\nm.def(\"set_window_text\",\n    [](HWND hwnd, std::wstring s) {\n        // Call SetWindowText with null-terminated UTF-16 string\n        ::SetWindowText(hwnd, s.c_str());\n    }\n);\nm.def(\"get_window_text\",\n    [](HWND hwnd) {\n        const int buffer_size = ::GetWindowTextLength(hwnd) + 1;\n        auto buffer = std::make_unique< wchar_t[] >(buffer_size);\n\n        ::GetWindowText(hwnd, buffer.data(), buffer_size);\n\n        std::wstring text(buffer.get());\n\n        // wstring will be converted to Python str\n        return text;\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Immutable Arguments in Python\nDESCRIPTION: A Python function intended to increment an integer argument. Due to Python's immutable integers, the operation `i += 1` creates a new object and does not modify the original variable passed to the function. This illustrates the limitation when binding C++ functions that rely on modifying arguments in place.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/faq.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef increment(i):\n    i += 1  # nope..\n```\n\n----------------------------------------\n\nTITLE: Importing pybind11.setup_helpers with Submodule Setup in Python\nDESCRIPTION: Example code showing how to properly import Pybind11Extension from setup_helpers when pybind11 is included as a submodule. This approach modifies the sys.path temporarily to locate the module.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/compiling.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nDIR = os.path.abspath(os.path.dirname(__file__))\n\nsys.path.append(os.path.join(DIR, \"extern\", \"pybind11\"))\nfrom pybind11.setup_helpers import Pybind11Extension  # noqa: E402\n\ndel sys.path[-1]\n```\n\n----------------------------------------\n\nTITLE: Define Custom Target for Running Tests\nDESCRIPTION: This snippet creates a custom build target 'cpptest' that executes the 'test_embed' executable. It depends on the test executable and sets its working directory, facilitating convenient test runs within the build system.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_embed/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(\n  cpptest\n  COMMAND \"$<TARGET_FILE:test_embed>\"\n  DEPENDS test_embed\n  WORKING_DIRECTORY \"${CMAKE_CURRENT_BINARY_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Adding py::set_error functions\nDESCRIPTION: Two new functions, `py::set_error()`, were added to the library and the documentation was updated. This involved deprecating `py::exception<>::operator()` and updating documentation to avoid potential undefined behavior.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Conditional Installation Build Targets for pybind11 Components\nDESCRIPTION: This snippet creates an installation target 'mock_install' if the 'PYBIND11_INSTALL' option is enabled, directing CMake to a specified install prefix. It conditionally adds build tests for installed functions, targets, and embed modules based on the interpreter extension and ID, managing dependencies for environment-specific setups.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_cmake_build/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(PYBIND11_INSTALL)\n  add_custom_target(\n    mock_install ${CMAKE_COMMAND} \"-DCMAKE_INSTALL_PREFIX=${pybind11_BINARY_DIR}/mock_install\" -P\n                 \"${pybind11_BINARY_DIR}/cmake_install.cmake\")\n\n  if(NOT \"${PYTHON_MODULE_EXTENSION}\" MATCHES \"graalpy\")\n    pybind11_add_build_test(installed_function INSTALL)\n  endif()\n  pybind11_add_build_test(installed_target INSTALL)\n  if(NOT\n     (\"${PYTHON_MODULE_EXTENSION}\" MATCHES \"pypy\"\n      OR \"${Python_INTERPRETER_ID}\" STREQUAL \"PyPy\"\n      OR \"${PYTHON_MODULE_EXTENSION}\" MATCHES \"graalpy\"))\n    pybind11_add_build_test(installed_embed INSTALL)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Enforcement of Symbol Visibility for pybind11 Modules\nDESCRIPTION: This section explains pybind11’s stricter enforcement of symbol hiding using -fvisibility=hidden and related build configurations. It aims to reduce symbol clashes, produce smaller binaries, and ensure module independence, especially important for shared library modules built with different pybind11 versions.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/upgrade.rst#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(mymodule PRIVATE pybind11::module)\n\ntarget_compile_options(restore_default_visibility INTERFACE -fvisibility=default)\ntarget_link_libraries(mymodule PRIVATE restore_default_visibility)\n```\n\n----------------------------------------\n\nTITLE: Conditionally Including Test Suite in CMake Build\nDESCRIPTION: Includes the `tests` subdirectory based on configuration flags and project context. If pybind11 is the master project (`PYBIND11_MASTER_PROJECT`), the standard `BUILD_TESTING` variable controls test inclusion. Otherwise (when included as a subproject), the `PYBIND11_TEST` variable is used. In either case, tests are skipped and a fatal error occurs if the `_pybind11_nopython` variable is true.\nSOURCE: https://github.com/pybind/pybind11/blob/master/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\n# BUILD_TESTING takes priority, but only if this is the master project\nif(PYBIND11_MASTER_PROJECT AND DEFINED BUILD_TESTING)\n  if(BUILD_TESTING)\n    if(_pybind11_nopython)\n      message(FATAL_ERROR \"Cannot activate tests in NOPYTHON mode\")\n    else()\n      add_subdirectory(tests)\n    endif()\n  endif()\nelse()\n  if(PYBIND11_TEST)\n    if(_pybind11_nopython)\n      message(FATAL_ERROR \"Cannot activate tests in NOPYTHON mode\")\n    else()\n      add_subdirectory(tests)\n    endif()\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Fix FindPython mode exports\nDESCRIPTION: Fixed FindPython mode exports and avoided the use of `pkg_resources` if `importlib.metadata` is available. This improves the library's dependency handling and performance.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_22\n\n\n\n----------------------------------------\n\nTITLE: Add 'external_module' Python Module with LTO\nDESCRIPTION: This section creates a Python module target named 'external_module' with Thin LTO optimization, compiling from 'external_module.cpp'. It sets output directories for various configurations to ensure build consistency and dependencies.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_embed/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\npybind11_add_module(external_module THIN_LTO external_module.cpp)\nset_target_properties(external_module PROPERTIES LIBRARY_OUTPUT_DIRECTORY\n                                                 \"${CMAKE_CURRENT_BINARY_DIR}\")\nforeach(config ${CMAKE_CONFIGURATION_TYPES})\n  string(TOUPPER ${config} config)\n  set_target_properties(external_module PROPERTIES LIBRARY_OUTPUT_DIRECTORY_${config}\n                                                   \"${CMAKE_CURRENT_BINARY_DIR}\")\nendforeach()\nadd_dependencies(cpptest external_module)\n```\n\n----------------------------------------\n\nTITLE: Support for Negative Buffer Strides in pybind11\nDESCRIPTION: Modifications to pybind11's buffer interface accommodate negative strides by changing stride types to signed integers. This change helps prevent compiler warnings and ensures compatibility with numpy arrays and other buffer objects that may use negative strides.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/upgrade.rst#_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\n// No specific code snippet provided; describes interface change.\n// Users should use static_cast to handle signed conversions where needed.\n```\n\n----------------------------------------\n\nTITLE: NumPy Ellipsis Slicing (Python)\nDESCRIPTION: Standard Python example using the ellipsis notation (`...`) to perform multidimensional slicing on a NumPy array. Extracts elements where the first and last indices are 0.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/pycpp/numpy.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\na = ...  # a NumPy array\nb = a[0, ..., 0]\n```\n\n----------------------------------------\n\nTITLE: Improve compatibility with nvcc compiler\nDESCRIPTION: Improvements were made to enhance compatibility with the nvcc compiler, specifically targeting CUDA versions 12.1 and 12.2. This likely involved addressing specific compiler issues or limitations.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Specializing holder_helper for Custom Smart Pointers\nDESCRIPTION: This snippet illustrates the specialization of pybind11's holder_helper for custom smart pointer types. It's necessary when a custom smart pointer doesn't provide a standard '.get()' member function to retrieve the underlying raw pointer. The code defines a template specialization for holder_helper<SmartPtr<T>>, providing a static get() function to access the raw pointer through the custom interface getPointer().\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/advanced/smart_ptrs.rst#_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n// Always needed for custom holder types\nPYBIND11_DECLARE_HOLDER_TYPE(T, SmartPtr<T>)\n\n// Only needed if the type's `.get()` goes by another name\nnamespace PYBIND11_NAMESPACE { namespace detail {\n    template <typename T>\n    struct holder_helper<SmartPtr<T>> { // <-- specialization\n        static const T *get(const SmartPtr<T> &p) { return p.getPointer(); }\n    };\n}}\n```\n\n----------------------------------------\n\nTITLE: pybind11_strip no longer automatically applied\nDESCRIPTION: `pybind11_strip` is no longer automatically applied when `CMAKE_BUILD_TYPE` is unset. This affects the build configuration based on CMake settings.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_27\n\n\n\n----------------------------------------\n\nTITLE: Allow lambda noexcept(true) in C++17\nDESCRIPTION: Allow lambda specified to function definition to be `noexcept(true)` in C++17. This increases flexibility in defining function behavior.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_51\n\n\n\n----------------------------------------\n\nTITLE: Change docstring render for buffer/sequence/handle\nDESCRIPTION: Modified the docstring rendering for `py::buffer`, `py::sequence`, and `py::handle` to display them as `Buffer`, `Sequence`, and `Any` respectively.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_15\n\n\n\n----------------------------------------\n\nTITLE: Specializing type_caster_enum_type_enabled for Custom Enum Casters (C++)\nDESCRIPTION: Provides a C++ template specialization for `pybind11::detail::type_caster_enum_type_enabled`. This specialization is needed to disable default pybind11 enum handling for a specific C++ enum (`FancyEnum`) when a custom type caster is implemented, especially if the custom caster is templated. The `PYBIND11_HAS_NATIVE_ENUM` preprocessor guard ensures compatibility with older pybind11 versions.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/classes.rst#_snippet_20\n\nLANGUAGE: cpp\nCODE:\n```\n#if defined(PYBIND11_HAS_NATIVE_ENUM)\nnamespace pybind11::detail {\ntemplate <typename FancyEnum>\nstruct type_caster_enum_type_enabled<\n    FancyEnum,\n    std::enable_if_t<is_fancy_enum<FancyEnum>::value>> : std::false_type {};\n}\n#endif\n```\n\n----------------------------------------\n\nTITLE: Adding new self._pybind11_conduit_v1_() method\nDESCRIPTION: A new `self._pybind11_conduit_v1_()` method is automatically added to all `py::class_`-wrapped types to enable interoperability between different Python/C++ bindings systems, including pybind11 versions with different `PYBIND11_INTERNALS_VERSION`'s. Supported on pybind11 2.11.2, 2.12.1, and 2.13.6+.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_37\n\n\n\n----------------------------------------\n\nTITLE: Introduce recursive_container_traits\nDESCRIPTION: Introduced `recursive_container_traits` to pybind11, likely used to improve support for recursive data structures.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_41\n\n\n\n----------------------------------------\n\nTITLE: Adding several missing type name specializations\nDESCRIPTION: Added several missing type name specializations. This extends support for more data types to improve interoperability within the binding.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_14\n\n\n\n----------------------------------------\n\nTITLE: Create Test Executable and Enable Warnings with pybind11\nDESCRIPTION: This section creates an executable named 'test_embed' from source files 'catch.cpp' and 'test_interpreter.cpp'. It also enables warnings specific to pybind11 for this target, preparing it for testing embedded Python modules.\nSOURCE: https://github.com/pybind/pybind11/blob/master/tests/test_embed/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(test_embed catch.cpp test_interpreter.cpp)\npybind11_enable_warnings(test_embed)\n```\n\n----------------------------------------\n\nTITLE: Setter return values not converted to Python\nDESCRIPTION: Setter return values (which are inaccessible for all practical purposes) are no longer converted to Python (only to be discarded).\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_50\n\n\n\n----------------------------------------\n\nTITLE: Defining Pybind11 C++ Version Macros\nDESCRIPTION: This snippet shows how to define the major, minor, and patch version numbers using C++ preprocessor macros. It illustrates the format for development versions ('.dev1'). This code is part of the pybind11 source and must match the Python version when packaging.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/release.rst#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#define PYBIND11_VERSION_MAJOR X\n#define PYBIND11_VERSION_MINOR Y\n#define PYBIND11_VERSION_PATCH Z.dev1\n```\n\n----------------------------------------\n\nTITLE: pybind11.pc is now relocatable by default\nDESCRIPTION: `pybind11.pc` is now relocatable by default as long as install destinations are not absolute paths. This enhances portability and installation flexibility.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_24\n\n\n\n----------------------------------------\n\nTITLE: Introducing pybind11::detail::is_move_constructible trait\nDESCRIPTION: The newly added `pybind11::detail::is_move_constructible` trait can be specialized for cases in which `std::is_move_constructible` does not work as needed. This is very similar to the long-established `pybind11::detail::is_copy_constructible`.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_40\n\n\n\n----------------------------------------\n\nTITLE: CI: Update NVHPC to 23.5 and Ubuntu 20.04\nDESCRIPTION: The Continuous Integration (CI) environment was updated to use NVHPC 23.5 and Ubuntu 20.04, improving the testing environment.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_33\n\n\n\n----------------------------------------\n\nTITLE: Fixing std::array-list caster docstring\nDESCRIPTION: The docstring generation for the `std::array`-list caster was fixed to conform with PEP 593. Tooling for processing docstrings may need to be updated.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_49\n\n\n\n----------------------------------------\n\nTITLE: Rendering builtins collections in docstrings\nDESCRIPTION: Built-in collection names (list, set, dict, tuple) in docstrings are now consistently rendered in lowercase, in alignment with PEP 585. This ensures consistency in documentation formatting.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Hardcode lto/thin lto for Emscripten cross-compiles\nDESCRIPTION: Hardcoded lto/thin lto for Emscripten cross-compiles to optimize build processes for specific architectures.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_29\n\n\n\n----------------------------------------\n\nTITLE: Qualify py::detail::concat usage\nDESCRIPTION: Usage of `py::detail::concat` was qualified to prevent potential conflicts from other libraries, specifically addressing an issue with modernjson's concat.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_9\n\n\n\n----------------------------------------\n\nTITLE: Use Ruff formatter instead of Black\nDESCRIPTION: Switched to the Ruff formatter in place of Black for code formatting.  This ensures consistency in coding style.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_35\n\n\n\n----------------------------------------\n\nTITLE: Add assert() to help Coverty\nDESCRIPTION: An `assert()` was added to help Coverty avoid generating a false positive, improving the code's safety.\nSOURCE: https://github.com/pybind/pybind11/blob/master/docs/changelog.rst#_snippet_36\n\n"
  }
]