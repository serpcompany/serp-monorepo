[
  {
    "owner": "justinsdk",
    "repo": "dotscad",
    "content": "TITLE: Basic Usage of shape_liquid_splitting in OpenSCAD\nDESCRIPTION: Demonstrates the basic usage of the `shape_liquid_splitting` module. It imports the module, sets global `$fn`, defines `radius` and `centre_dist`, calls the function to get shape points, and then renders the resulting 2D shape using the built-in `polygon` module. Depends on the `shape_liquid_splitting.scad` library file.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_liquid_splitting.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_liquid_splitting.scad>\n\n$fn = 36;\n\nradius = 10;\ncentre_dist = 30;\n\nshape_pts = shape_liquid_splitting(radius, centre_dist);\npolygon(shape_pts);\n```\n\n----------------------------------------\n\nTITLE: Path Scaling Sections Example 3 - Rotated Sections\nDESCRIPTION: This example introduces rotation to the scaled sections. It uses `shape_taiwan.scad`, `path_scaling_sections.scad`, `sweep.scad`, `bezier_curve.scad`, and `ptf/ptf_rotate.scad`. After creating the Bezier curve edge path and obtaining the scaled sections, it iterates through the sections and rotates each point within each section by a progressively increasing angle.  The amount of rotation is controlled by `twist` and `twist_step`, creating a twisting effect along the extrusion.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-path_scaling_sections.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n\tuse <shape_taiwan.scad>\n\tuse <path_scaling_sections.scad>\n\tuse <sweep.scad>\n\tuse <bezier_curve.scad>\n\tuse <ptf/ptf_rotate.scad>\n\n\ttaiwan = shape_taiwan(100);\n\tfst_pt = [13, 0, 0];\n\n\tedge_path = bezier_curve(0.05, [\n\t\tfst_pt,\n\t\tfst_pt + [0, 0, 10],\n\t\tfst_pt + [10, 0, 20],\n\t\tfst_pt + [8, 0, 30],\n\t\tfst_pt + [12, 0, 40],\n\t\tfst_pt + [0, 0, 50],\n\t\tfst_pt + [0, 0, 60]\n\t]);\n\n\tleng = len(edge_path);\n\ttwist = -90;\n\ttwist_step = twist / leng;\n\tsections = path_scaling_sections(taiwan, edge_path);\n\n\trotated_sections = [\n\t\tfor(i = [0:leng - 1]) \n\t\t[\n\t\t\tfor(p = sections[i]) \n\t\t\t\tptf_rotate(p, twist_step * i)        \n\t\t]\n\t];\n\n\tsweep(rotated_sections);\n```\n\n----------------------------------------\n\nTITLE: Using loft function for 3D shape creation with multiple cross sections in OpenSCAD\nDESCRIPTION: This script demonstrates how to create complex 3D models by lofting between various 2D cross-sections using the 'loft' module in OpenSCAD. It defines parameters for the cross sections and number of slices to interpolate between them, employing helper functions like 'shape_star' and 'shape_circle' to generate different geometries. The examples include generating multiple star-shaped sections with varying sizes and a difference operation to create composite shapes, illustrating the capacity to produce smoothly connected forms.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-loft.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# loft\n\nWhen having uniform cross sections, you can use [sweep](https://openhome.cc/eGossip/OpenSCAD/lib3x-sweep.html) to create a model. The `loft` here is best when you have a body with multiple crosssections with different geometries. \n\n**Since:** 2.3\n\n## Parameters\n\n- `sections` : A list of cross-sections, The points must be count-clockwise indexes.\n- `slices` : Defines the number of intermediate points between two sections. Default to 1.\n\n## Examples\n\n\tuse <shape_star.scad>\n\tuse <shape_circle.scad>\n\tuse <ptf/ptf_rotate.scad>\n\tuse <loft.scad>\n\t\n\tsects = [\n\t\tfor(i = 10; i >= 4; i = i - 1)\n\t\t[\n\t\t\tfor(p = shape_star(15, 12, i % 2 == 1 ? i : i - 1)) ptf_rotate([p.x, p.y, 5 * (i - 4)], i * 10)\n\t\t]\n\t];\n\tloft(sects, slices = 3);\n\n\ttranslate([30, 0, 0])\n\tdifference() {\n\t\tloft(\n\t\t\t[\n\t\t\t\t[for(p = shape_circle(10, $fn = 3)) [p.x, p.y, 15]],\n\t\t\t\t[for(p = shape_circle(15, $fn = 24)) [p.x, p.y, 0]]        \n\t\t\t],\n\t\t\tslices = 4\n\t\t);\n\n\t\tloft(\n\t\t\t[\n\t\t\t\t[for(p = shape_circle(8, $fn = 3)) [p.x, p.y, 15.1]],\n\t\t\t\t[for(p = shape_circle(13, $fn = 24)) [p.x, p.y, -0.1]]        \n\t\t\t],\n\t\t\tslices = 4\n\t\t);    \n\t}\n\n![loft](images/lib3x-loft-1.JPG)\n```\n\n----------------------------------------\n\nTITLE: Applying 3D Torus Transformation to Voronoi Cells in OpenSCAD\nDESCRIPTION: This snippet demonstrates the use of the vrn2_cells_space function to generate Voronoi cells over a rectangular space, then applies a 3D torus transformation to each polygon vertex of the cells using the ptf_torus module. It uses polyline_join to visualize the polygons as connected lines, with spheres placed on the paths for 3D markers. Required dependencies include 'polyline_join.scad', 'ptf/ptf_torus.scad' for torus vertex calculation, and 'voronoi/vrn2_cells_space.scad' for cell generation. The parameters 'size' and 'grid_w' define the area and grid spacing, while '$fn' sets sphere resolution. Outputs include transformed 3D polygons and visual cues, suitable for advanced geometry modeling.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vrn2_cells_space.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline_join.scad>\nuse <ptf/ptf_torus.scad>\nuse <voronoi/vrn2_cells_space.scad>\n\nsize = [40, 80];\ngrid_w = 5;\ncells = vrn2_cells_space(size, grid_w);\n\n$fn = 4;\n\nfor(cell = cells) {\n    cell_poly = [for(p = cell[1]) ptf_torus(size, p, [10, 5], [360, 360])];\n\n    polyline_join(cell_poly)\n\t    sphere(.5);\n}\n```\n\n----------------------------------------\n\nTITLE: 2D Shape Generation Functions in OpenSCAD DotSCADE Library\nDESCRIPTION: This set provides functions to create points on various 2D geometric shapes including arcs, circles, polygons, ellipses, and specialized shapes like pentagrams and stars. These functions return point arrays suitable for 2D rendering or further processing. They depend on detailed documentation URLs and are essential for creating and manipulating 2D profiles.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_4\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**shape_arc**(radius, angle, width[, width_mode])](https://openhome.cc/eGossip/OpenSCAD/lib3x-shape_arc.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**shape_circle**(radius, n)](https://openhome.cc/eGossip/OpenSCAD/lib3x-shape_circle.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**shape_cyclicpolygon**(sides, circle_r, corner_r)](https://openhome.cc/eGossip/OpenSCAD/lib3x-shape_cyclicpolygon.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**shape_ellipse**(axes)](https://openhome.cc/eGossip/OpenSCAD/lib3x-shape_ellipse.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**shape_liquid_splitting**(radius, centre_dist[, tangent_angle, t_step])](https://openhome.cc/eGossip/OpenSCAD/lib3x-shape_liquid_splitting.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**shape_path_extend**(stroke_pts, path_pts[, scale, closed])](https://openhome.cc/eGossip/OpenSCAD/lib3x-shape_path_extend.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**shape_pentagram**(r)](https://openhome.cc/eGossip/OpenSCAD/lib3x-shape_pentagram.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**shape_pie**(radius, angle)](https://openhome.cc/eGossip/OpenSCAD/lib3x-shape_pie.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**shape_square**(size[, corner_r])](https://openhome.cc/eGossip/OpenSCAD/lib3x-shape_square.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**shape_star**([outer_radius, inner_radius, n])](https://openhome.cc/eGossip/OpenSCAD/lib3x-shape_star.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**shape_superformula**(phi_step, m1, m2, n1, [n2, n3, a, b])](https://openhome.cc/eGossip/OpenSCAD/lib3x-shape_superformula.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**shape_taiwan**(h[, distance])](https://openhome.cc/eGossip/OpenSCAD/lib3x-shape_taiwan.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**shape_trapezium**(length, h[, corner_r])](https://openhome.cc/eGossip/OpenSCAD/lib3x-shape_trapezium.html)\n```\n\n----------------------------------------\n\nTITLE: Creating a basic 3D polyline with default end-caps in OpenSCAD\nDESCRIPTION: This snippet demonstrates how to define a list of 3D points and generate a polyline with default end-cap styles and specified diameter. It requires the polyline3d module and generates a 3D line connecting the points with optional smoothness specified by `$fn`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polyline3d.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline3d.scad>\n\npolyline3d(\n    points = [\n        [1, 2, 1], \n        [-5, -4, 2], \n        [-5, 3, 3], \n        [5, 5, 4]\n    ], \n    diameter = 1,\n    $fn = 24\n);\n```\n\n----------------------------------------\n\nTITLE: Advanced Usage with Bezier Curves and path_extrude in OpenSCAD\nDESCRIPTION: Demonstrates combining shape_path_extend with bezier_curve and path_extrude to create a 3D object. This example creates a wavy 3D path by extruding a shape generated from a zigzag stroke along a Bezier curve path with scaling.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_path_extend.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <bezier_curve.scad>\nuse <shape_path_extend.scad>\nuse <path_extrude.scad>\n\nt_step = 0.1;\nwidth = 2;\n\np0 = [0, 0];\np1 = [40, 60];\np2 = [50, 90];\np3 = [0, 200];\n\npath = bezier_curve(t_step, \n\t[p0, p1, p2, p3]\n);\n\nstroke = [[-5, 2.5], [-2.5, 0], [0, 2.5], [2.5, 0], [5, 2.5]];\n\npath_extrude(\n\tshape_path_extend(stroke, path, scale = 5), \n\tpath,\n\tscale = 0.1\n);\n```\n\n----------------------------------------\n\nTITLE: Using sf_thickenT to Thicken Parametric Surface in OpenSCAD\nDESCRIPTION: This OpenSCAD snippet demonstrates how to apply sf_thickenT to thicken a triangular mesh surface generated from a parametric function. It defines points on the surface using polar coordinates, calculates their z-values from the function f(x, y), and applies sf_thickenT with a specified thickness parameter. Dependencies include the surface/sf_thickenT.scad library. The input is a list of 3D points and a thickness float, outputting a thickened polyhedron. No explicit triangulation is provided, so the function relies on 2D Delaunay triangulation based on xy-coordinates internally.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_thickenT.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <surface/sf_thickenT.scad>\n\nthickness = .2;\na_step = 15;\nr_step = 0.2;\n\nfunction f(x, y) = (y ^ 2 - x ^ 2) / 4;\n\npoints = [\n\tfor(a = [a_step:a_step:360], r = [r_step:r_step:2])\n\tlet(\n\t\tx = r * cos(a), \n\t\ty = r * sin(a)\n\t)\n\t[x, y, f(x, y)] \n];\n\nsf_thickenT(points, thickness);\n```\n\n----------------------------------------\n\nTITLE: Applying sf_thickenT with Delaunay Triangulation in OpenSCAD\nDESCRIPTION: This snippet shows how to use sf_thickenT with a precomputed triangulation to thicken a parametric toroidal surface. It generates points on the surface using parameters u and v, then computes the triangular mesh using the tri_delaunay function from the triangle/tri_delaunay.scad library. The triangles parameter explicitly defines mesh connectivity, ensuring proper thickening aligned with the triangulated surface. Inputs include the points array, thickness value, and the triangulation array. This enables correct mesh thickening along specified directions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_thickenT.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <triangle/tri_delaunay.scad>\nuse <surface/sf_thickenT.scad>\n\nu_step = 10;\nv_step = 0.2;\nthickness = .2;\n\npoints = [\n\tfor(u = [0:u_step:360], v = [-1:v_step:1])\n\tlet(\n\t\tx = (1 + v / 2 * cos(u / 2)) * cos(u),\n\t\ty = (1 + v / 2 * cos(u / 2)) * sin(u),\n\t\tz = v / 2 * sin(u / 2)\n\t)\n\t[x, y, z]\n];\n\ntriangles = tri_delaunay([\n\tfor(u = [0:u_step:360])\n\t\tfor(v = [-1:v_step:1])\n\t\t[v, u]\n]);\n\nsf_thickenT(points, thickness, triangles);\n```\n\n----------------------------------------\n\nTITLE: Creating a Box with Circle in OpenSCAD\nDESCRIPTION: This OpenSCAD snippet utilizes the `box_extrude` function to create a 3D box from a 2D circle.  It sets the height of the box to 30 and the shell thickness to 2.  The `circle` function, with a radius of 30, defines the 2D shape extruded into the box. No additional dependencies are required beyond the `box_extrude.scad` library. The expected output is a 3D box with a circular base.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-box_extrude.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <box_extrude.scad>\n\n\tbox_extrude(height = 30, shell_thickness = 2) \n\t    circle(r = 30);\n```\n\n----------------------------------------\n\nTITLE: Using Binary Search with Vector Comparison in OpenSCAD\nDESCRIPTION: Example demonstrating how to use the `bsearch` function with sorted points. It searches for specific vector values and also shows how to search using custom comparison functions based on x or y coordinates.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-bsearch.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/sort.scad>\nuse <util/bsearch.scad>\n\npoints = [[1, 1], [3, 4], [7, 2], [5, 2]];\nsorted = sort(points, by = \"vt\"); //  [[1, 1], [5, 2], [7, 2], [3, 4]]\n\nassert(bsearch(sorted, [7, 2]) == 2);\n\nxIs5 = function(elem) elem[0] - 5;\nassert(bsearch(sorted, xIs5) == 1);\n\nyIs4 = function(elem) elem[1] - 4;\nassert(bsearch(sorted, yIs4) == 3);\n```\n\n----------------------------------------\n\nTITLE: Generate Clamped B-spline Curve (OpenSCAD)\nDESCRIPTION: Demonstrates how to generate a clamped B-spline curve, which starts and ends at the first and last control points, respectively. This is achieved by providing a `knots` vector where the first and last `degree + 1` values are identical. Control points are visualized in red, and curve points are displayed.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-bspline_curve.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <bspline_curve.scad>\n\t\t\n\tpoints = [\n\t\t[-10, 0],\n\t\t[-5,  5],\n\t\t[ 5, -5],\n\t\t[ 10, 0]\n\t];\n\n\t// For a clamped B-spline curve, the first `degree + 1` and the last `degree + 1` knots must be identical.\n\tknots = [0, 0, 0, 1, 2, 2, 2];\n\n\tcolor(\"red\") \n\tfor(p = points) {\n\t\ttranslate(p) \n\t\t\tsphere(0.5);\n\t}\n\n\tfor(p = bspline_curve(0.01, 2, points, knots)) {\n\t\ttranslate(p) \n\t\t\tsphere(0.1);\n\t}\n```\n\n----------------------------------------\n\nTITLE: Sphere Spiral Extrusion Function Usage in OpenSCAD\nDESCRIPTION: This snippet demonstrates how to use the sphere_spiral_extrude function in OpenSCAD to extrude a 2D shape (such as a pentagram) along a spherical spiral path. It showcases the definition of shape points and parameter setup for the extrusion process, including radius, steps, angles, direction, and scale.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sphere_spiral_extrude.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\npoints_triangles = shape_pentagram(2);\n\nsphere_spiral_extrude(\n\tshape_pts = points_triangles,\n\tradius = 40, \n\tza_step = 2, \n\tz_circles = 20, \n\tbegin_angle = 90, \n\tend_angle = 450,\n\tvt_dir = \"SPI_UP\",\n\tscale = 5\n);\n```\n\n----------------------------------------\n\nTITLE: Sorting a List of Numbers in Descending Order in OpenSCAD\nDESCRIPTION: This snippet demonstrates sorting a list of numbers in descending order by setting the `reverse` parameter to `true`. It asserts that the sorted list matches the expected descending order. The default comparison operator is used with reversed comparison.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sorted.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nassert([6, 5, 4, 3, 2, 1] == sorted([1, 6, 2, 5, 4, 3], reverse = true));\n```\n\n----------------------------------------\n\nTITLE: Sorting Lists in OpenSCAD with util/sorted\nDESCRIPTION: Replacement for the deprecated util/sort function. Sorts a list with optional custom comparator, key function, and reverse option.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/RELEASE.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\ninclude <dotscad/util/sorted.scad>\n\n// Example usage:\nmy_list = [3, 1, 4, 1, 5, 9];\nsorted_list = sorted(my_list);\n// Result: [1, 1, 3, 4, 5, 9]\n\n// With reverse parameter\nreversed_list = sorted(my_list, reverse=true);\n// Result: [9, 5, 4, 3, 1, 1]\n```\n\n----------------------------------------\n\nTITLE: Using some Utility Function in OpenSCAD\nDESCRIPTION: This snippet demonstrates how to use the 'some' utility function in OpenSCAD to test if any element of a given list passes a specified predicate function. It shows importing the utility, defining an 'isOdd' predicate to test for odd numbers, and asserts that the list contains at least one odd value. Prerequisite: the util/some.scad file must be available in the library path. Parameters include 'lt', the list to test, and 'test', the predicate. The output of 'some' is boolean. The function expects the test predicate to take a single argument and return a boolean value.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-some.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/some.scad>;\n\nisOdd = function(elem) elem % 2 == 1;\nassert(some([1, 30, 39, 29, 10, 13], isOdd));\n```\n\n----------------------------------------\n\nTITLE: Creating voxel intersection and difference with vx_difference in OpenSCAD\nDESCRIPTION: This snippet demonstrates the use of vx_difference to subtract a sphere from a cylinder, creating a complex voxel shape. It highlights dependency on other voxel operations such as vx_cylinder and vx_sphere, and visualizes the resulting shape by translating each voxel into a cube.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_difference.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# vx_difference\n\nIt' slow, in case you want to create a difference of two lists of points directly. \n\n**Since:** 2.4\n\n## Parameters\n\n- `points1` : A list of points.\n- `points2` : A list of points.\n\n## Examples\n\n\tuse <voxel/vx_difference.scad>\n\tuse <voxel/vx_cylinder.scad>\n\tuse <voxel/vx_sphere.scad>\n\n\tvoxels = vx_difference(\n\t\tvx_cylinder(6, 3, filled = true),\n\t\tvx_sphere(3, filled = true)\n\t);\n\n\tfor(pt = voxels) {\n\t\ttranslate(pt)\n\t\t\tcube(1, center = true);\n\t}\n\n![vx_difference](images/lib3x-vx_difference-1.JPG)\n```\n\n----------------------------------------\n\nTITLE: Check if list contains element in OpenSCAD\nDESCRIPTION: This snippet demonstrates the usage of the `contains` function. It uses `vx_circle` to generate a list of points, and then asserts whether specific points are present within the generated list, effectively checking for containment.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-contains.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voxel/vx_circle.scad>\nuse <util/contains.scad>\n\npts = vx_circle(10);\nassert(contains(pts, [2, -10])); \nassert(!contains(pts, [0, 0]));  \n```\n\n----------------------------------------\n\nTITLE: Documentation and example usage of sf_splines function in OpenSCAD\nDESCRIPTION: This snippet documents the sf_splines function, illustrating how to generate surfaces from control points using spline functions. It includes examples with Bezier and B-spline curves, showing parameter definitions, control points, and visualization with thicknessing. Dependencies include bezier_curve.scad, bspline_curve.scad, sf_thicken.scad, and surface modules.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_splines.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# sf_splines\n\nGiven a set of control points and spline functions, the `sf_splines` function returns surface points.\n\n**Since:** 3.1\n\n## Parameters\n\n- `ctrl_pts` : A set of control points. See examples below.\n- `row_spline` : The spline function for row points.\n- `column_spline` : The spline function for columns points. Default to `row_spline`.\n\n## Examples\n\nIf you want to make a bezier surface:\n\n\tuse <bezier_curve.scad>\n\tuse <surface/sf_splines.scad>\n\tuse <surface/sf_thicken.scad>\n\n\tctrl_pts = [\n\t\t[[0, 0, 20],  [60, 0, -35],   [90, 0, 60],    [200, 0, 5]],\n\t\t[[0, 50, 30], [100, 60, -25], [120, 50, 120], [200, 50, 5]],\n\t\t[[0, 100, 0], [60, 120, 35],  [90, 100, 60],  [200, 100, 45]],\n\t\t[[0, 150, 0], [60, 150, -35], [90, 180, 60],  [200, 150, 45]]\n\t];\n\n\tthickness = 2;\n\tt_step = 0.05;\n\n\tbezier = function(points) bezier_curve(t_step, points);\n\n\tsf_thicken(sf_splines(ctrl_pts, bezier), thickness);\n\n![sf_splines](images/lib3x-sf_splines-1.JPG)\n\nThe following figure shows controll points and bazier curves around the surface.\n\n![sf_splines](images/lib3x-sf_splines-2.JPG)\n\nIf you want to make a bspline surface:\n\n\tuse <bspline_curve.scad>\n\tuse <surface/sf_thicken.scad>\n\tuse <surface/sf_splines.scad>\n\n\tctrl_pts = [\n\t\t[[0, 0, 20],  [60, 0, -35],   [90, 0, 60],    [200, 0, 5]],\n\t\t[[0, 50, 30], [100, 60, -25], [120, 50, 120], [200, 50, 5]],\n\t\t[[0, 100, 0], [60, 120, 35],  [90, 100, 60],  [200, 100, 45]],\n\t\t[[0, 150, 0], [60, 150, -35], [90, 180, 60],  [200, 150, 45]]\n\t];\n\n\tthickness = 2;\n\tt_step = 0.05;\n\tdegrees = 2;\n\n\tb_spline = function(points) bspline_curve(t_step, degrees, points);\n\n\tsf_thicken(sf_splines(ctrl_pts, bspline), thickness);\n\n![sf_splines](images/lib3x-sf_splines-3.JPG)\n```\n\n----------------------------------------\n\nTITLE: Sorting a List of Strings in OpenSCAD\nDESCRIPTION: This snippet demonstrates sorting a list of strings in ascending order using the `sorted` function. The default string comparison is used.  The result is compared against an expected sorted list of strings using `assert`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sorted.md#_snippet_3\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nassert([\"b\", \"c\", \"d\", \"m\", \"x\"] == sorted([\"x\", \"c\", \"b\", \"d\", \"m\"]));\n```\n\n----------------------------------------\n\nTITLE: Generating a 4x4 Scaling Matrix Using m_scaling in OpenSCAD\nDESCRIPTION: This snippet defines how to produce a scaling transformation matrix with the m_scaling function for scaling 3D objects in OpenSCAD. The example showcases applying the matrix via multmatrix to a cube, demonstrating non-uniform scaling based on the provided vector parameter.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-m_scaling.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# m_scaling\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <matrix/m_scaling.scad>\n\ncube(10);\ntranslate([15, 0, 0]) \nmultmatrix(m_scaling([0.5, 1, 2]))\n    cube(10);\n```\n\n----------------------------------------\n\nTITLE: Using the 'every' function in OpenSCAD\nDESCRIPTION: This snippet shows how to use the 'every' function in OpenSCAD.  It requires the util/every.scad library. A test function 'biggerThanZero' is defined and applied to a list to verify that all elements are greater than zero.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-every.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/every.scad>\n   \nbiggerThanZero = function(elem) elem > 0;\nassert(every([1, 30, 39, 29, 10, 13], biggerThanZero));\n```\n\n----------------------------------------\n\nTITLE: Finding the Intersection of Two Line Segments in OpenSCAD\nDESCRIPTION: This code provides the lines_intersection function, which determines the intersection point between two line segments in 2D or 3D space. It accepts two lines, each defined by a pair of point coordinates, and offers optional parameters such as 'ext' for extending finite segments into infinite lines, and 'epsilon' to control floating point precision. Returns the intersection point as an array or an empty array if no intersection is found; designed for geometric validation and computational modeling in OpenSCAD.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-lines_intersection.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <lines_intersection.scad>\\n\\nline1 = [[0, 0], [0, 10]];\\nline2 = [[5, 0], [-5, 5]];\\nline3 = [[5, 0], [2.5, 5]];\\n\\nassert(lines_intersection(line1, line2) == [0, 2.5]);\\nassert(lines_intersection(line1, line3, ext = true) == [0, 10]);\\n\\nline4 = [[0, 0, 0], [10, 10, 10]];\\nline5 = [[10, 0, 0], [0, 10, 10]];\\nassert(lines_intersection(line4, line5) == [5, 5, 5]);\n```\n\n----------------------------------------\n\nTITLE: Midpoint Smoothing Example - OpenSCAD\nDESCRIPTION: This example demonstrates how to use the `midpt_smooth` function with a predefined shape (`shape_taiwan`) to create a smoothed version. It utilizes `polyline_join` to visualize both the original and smoothed shapes using circles at each point. It requires the `polyline_join.scad`, `shape_taiwan.scad`, and `midpt_smooth.scad` modules.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-midpt_smooth.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline_join.scad>\nuse <shape_taiwan.scad>\nuse <midpt_smooth.scad>\n\ntaiwan = shape_taiwan(50);  \nsmoothed = midpt_smooth(taiwan, 20, true);\n\ntranslate([0, 0, 0]) \npolyline_join(taiwan) \n    circle(.125); \n\n#translate([10, 0, 0]) \npolyline_join(smoothed) \n    circle(.125);\n```\n\n----------------------------------------\n\nTITLE: Constructing 3D Polylines Using footprints3 Module in OpenSCAD\nDESCRIPTION: This usage example demonstrates how to construct a complex 3D polyline using the footprints3 module by providing a list of turtle commands including forward motions, turns, pitches, and rolls. It includes calls to the xy_arc_cmds helper to append arc segments. The generated polyline is then rendered with polyline_join for visualizing the connected segments, capped with spheres at vertices. Dependencies: polyline_join module and footprints3 module must be imported. Inputs are command arrays specifying sequential movements and rotations. Output is a 3D shape representing the resultant path.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-footprints3.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline_join.scad>\nuse <turtle/footprints3.scad>\n\npoly = footprints3(\n    [\n        [\"forward\", 10],\n        [\"turn\", 90],\n        [\"forward\", 10],\n        each xy_arc_cmds(5, 180, 12),\n        [\"pitch\", 90],\n        [\"forward\", 10],\n        [\"roll\", 90],\n        each xy_arc_cmds(5, 180, 12),\n        [\"forward\", 10]\n    ]\n);\n\npolyline_join(poly)\n    sphere(.5);\n```\n\n----------------------------------------\n\nTITLE: Extruding Circle with ellipse_extrude - OpenSCAD\nDESCRIPTION: This OpenSCAD snippet demonstrates the use of `ellipse_extrude` to extrude a circle. The code first defines the `semi_minor_axis`. Then, the `ellipse_extrude` function is called with the `semi_minor_axis` parameter and a `circle` with a diameter equal to the minor axis multiplied by two is extruded. The output is a 3D shape formed by extruding the circle along an ellipse path.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-ellipse_extrude.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <ellipse_extrude.scad>\n\n\tsemi_minor_axis = 5;\n\t \n\tellipse_extrude(semi_minor_axis) \n\t    circle(semi_minor_axis * 2);\n```\n\n----------------------------------------\n\nTITLE: Creating a 3D Bowl Shape with shape_liquid_splitting in OpenSCAD\nDESCRIPTION: Illustrates using `shape_liquid_splitting` points to create a 3D shape resembling a bowl or dish. The generated 2D profile is extruded using `rotate_extrude`, and a `difference` operation is used to hollow out the interior by subtracting a rectangular prism. Requires the `shape_liquid_splitting.scad` library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_liquid_splitting.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_liquid_splitting.scad>\n\n$fn = 36;\n\nradius = 10;\ncentre_dist = 30;\n\nshape_pts = shape_liquid_splitting(radius, centre_dist);\nwidth = centre_dist / 2 + radius;\n\nrotate_extrude() \ndifference() {    \n    polygon(shape_pts);    \n\n    translate([-width, -radius]) \n        square([width, radius * 2]);\n}\n```\n\n----------------------------------------\n\nTITLE: Using vx_line for 3D Voxel Line in OpenSCAD\nDESCRIPTION: This snippet illustrates the use of the vx_line module to generate a 3D voxel line between two points and visualize it using OpenSCAD's cube primitive. The code iterates through the points returned by vx_line, translating a cube to each point, effectively creating a 3D line. It requires the `vx_line.scad` module from the voxel library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_line.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voxel/vx_line.scad>\n\nfor(pt = vx_line([-10, 0, -10], [20, 50, 10])) {\n\ttranslate(pt) \n\t\tcube(1, center = true);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Fibonacci Sequence Utility in OpenSCAD\nDESCRIPTION: Demonstrates how to import the 'fibseq' utility from the 'util/fibseq.scad' module and invoke it to generate a Fibonacci sequence from the 1st to the 10th element. This snippet requires OpenSCAD, and the 'util/fibseq.scad' must be accessible. The key parameters are 'from' (the starting index, 1-based) and 'to' (the ending index), and the output is an array containing the corresponding Fibonacci numbers. Users should ensure module path correctness and be aware that index boundaries determine sequence length.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-fibseq.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/fibseq.scad>\necho(fibseq(1, 10));  // ECHO: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n```\n\n----------------------------------------\n\nTITLE: Using pp_disk module - OpenSCAD\nDESCRIPTION: This code snippet demonstrates how to use the `pp_disk` module in OpenSCAD to generate random points within a disk and then display them as small circles.  It requires the `pp_disk.scad` library. The output visualizes the random point distribution.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-pp_disk.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <pp/pp_disk.scad>\n\nnumber = 10000;\nradius = 2;\n\npoints = pp_disk(radius, number);\n\nfor(p = points) {\n    translate(p)\n        circle(.01);\n}\n```\n\n----------------------------------------\n\nTITLE: Using the bend module in OpenSCAD to create an arc shape\nDESCRIPTION: This example shows how to import the 'bend' module and generate an arc-shaped 3D object using specified size parameters. It demonstrates setting dimensions, applying the bend with default fragmentation, and visualizing the result via linear extrusion of text. The code is intended for users familiar with OpenSCAD for 3D modeling.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-bend.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <bend.scad>\n\nx = 9.25;\ny = 9.55;\nz = 1;\n\n%cube(size = [x, y, z]);\nlinear_extrude(z) text(\"A\");\n```\n\n----------------------------------------\n\nTITLE: Creating a line with specified start and end points in OpenSCAD\nDESCRIPTION: This snippet demonstrates the use of the line2d function to generate a 2D line between two points with optional parameters for width and end-cap styles. It also shows how to set the $fn variable for circle module customization and includes examples with different end cap styles. The purpose is to facilitate customizable line drawing in OpenSCAD projects.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-line2d.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# line2d module creates a line between two points with optional styling\\n\\nuse <line2d.scad>\\n\\n$fn = 24;\\n\\n// Basic line between (0,0) and (5,0) with default width and style\\nline2d(p1 = [0, 0], p2 = [5, 0], width = 1);\\n\\n// Line with end caps as round, translated downward for visual separation\\ntranslate([0, -2, 0]) \\n    line2d(p1 = [0, 0], p2 = [5, 0], width = 1, \\n           p1Style = \"CAP_ROUND\", p2Style = \"CAP_ROUND\");\\n\\n// Line with end caps as butt style, further translated for variation\\ntranslate([0, -4, 0]) \\n    line2d(p1 = [0, 0], p2 = [5, 0], width = 1, \\n           p1Style = \"CAP_BUTT\", p2Style = \"CAP_BUTT\");\n```\n\n----------------------------------------\n\nTITLE: Generating a 1D Perlin Noise Plot in OpenSCAD\nDESCRIPTION: This example demonstrates how to use the `nz_perlin1` function to generate a 1D Perlin noise graph. It utilizes `rand` to create a seed and iterates through x-coordinates, calculating the corresponding noise value with `nz_perlin1`. The resulting points `[x, noise_value]` are visualized using `polyline_join` with small circles at each point. Requires including `polyline_join.scad`, `util/rand.scad`, and `noise/nz_perlin1.scad`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-nz_perlin1.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline_join.scad>\nuse <util/rand.scad>\nuse <noise/nz_perlin1.scad>\n\nseed = rand(0, 255);\npolyline_join([for(x = [0:.1:10]) [x, nz_perlin1(x, seed)]])\n\tcircle(.05);\n```\n\n----------------------------------------\n\nTITLE: Creating a 2D Polygon from Arc Points in OpenSCAD\nDESCRIPTION: This snippet demonstrates the basic usage of `shape_arc` to generate points for a semi-circular arc with a specific radius and width. These points are then passed to the built-in `polygon` module to create a 2D shape. It requires the `shape_arc.scad` library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_arc.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_arc.scad>\n\nshape_pts = shape_arc(radius = 10, angle = [-90, 90], width = 5);\npolygon(shape_pts);\n```\n\n----------------------------------------\n\nTITLE: Generating Voxel Polyline in OpenSCAD\nDESCRIPTION: Creates a series of voxel points connecting multiple points in order, forming a polyline shape in voxel style. Depend on voxel functions for point output.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_19\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoxel/vx_polyline(points)\n```\n\n----------------------------------------\n\nTITLE: Using Voxel ASCII for Strings with Inversion\nDESCRIPTION: This code snippet showcases using `vx_ascii` to generate voxel points for a string. It iterates through the characters of the string \"dotSCAD\" and uses the `invert` parameter to invert the character's voxel representation. The resulting voxels are rendered as spheres.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_ascii.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voxel/vx_ascii.scad>\n\nt = \"dotSCAD\";\n \nfor(i = [0:len(t) - 1]) {\n    translate([i * 8, 0]) \n    for(pt = vx_ascii(t[i], invert = true)) {\n        translate(pt)\n            sphere(0.5, $fn = 24);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Gray Level List to Coordinate-Level List Conversion Function in JavaScript\nDESCRIPTION: This snippet defines a function that transforms a list of grayscale intensity values (0-255) into `[x, y, level]` coordinate data. It includes parameters for centering the object, inverting levels, and normalizing levels to a [0,1] range, enabling flexible representation of grayscale images. Dependencies are minimal, requiring only standard JavaScript operations, and the function is suitable for image processing in graphics applications.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_gray.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n# Given a list of numbers (0 ~ 255) that represent a gray image. This function translates them into a list of `[x, y, level]`s.\n\n/**\n * Converts a list of grayscale levels into coordinate-level pairs.\n * @param {number[]} levels - List of grayscale levels (0-255).\n * @param {boolean} center - If true, object is centered; otherwise, placed in the positive quadrant.\n * @param {boolean} invert - If true, inverts the level values.\n * @param {boolean} normalize - If true, normalizes level values to range [0, 1].\n * @returns {Array} Array of `[x, y, level]` tuples.\n */\nfunction levelsToCoords(levels, center=false, invert=false, normalize=false) {\n    const size = Math.sqrt(levels.length); // Assuming square image for coordinate mapping\n    const coords = [];\n    for(let i = 0; i < levels.length; i++) {\n        let level = levels[i];\n        if(invert) {\n            level = 255 - level;\n        }\n        if(normalize) {\n            level = level / 255;\n        }\n        const x = i % size;\n        const y = Math.floor(i / size);\n        coords.push([\n            center ? x - size/2 : x,\n            center ? y - size/2 : y,\n            level\n        ]);\n    }\n    return coords;\n}\n```\n\n----------------------------------------\n\nTITLE: Applying bend module with specific size and angle parameters\nDESCRIPTION: This snippet demonstrates how to specify the size and the bending angle for the 'bend' module to produce an arc shape. It shows setting the size parameters based on a cube and applying the bend with an explicit angle, resulting in a smoother arc. The example uses linear extrusion to visualize the bent text object.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-bend.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <bend.scad>\n\nx = 9.25;\ny = 9.55;\nz = 1;\n\n*cube(size = [x, y, z]);\nbend(size = [x, y, z], angle = 270)\nlinear_extrude(z) text(\"A\");\n```\n\n----------------------------------------\n\nTITLE: Adding Elements to Hashsets in OpenSCAD\nDESCRIPTION: Defines the function hashset_add to add a specified element to an existing hashset and return a new set including that element. It optionally accepts an equality function to compare elements and a hash function to generate hash keys, defaulting to string conversion and equality operator when omitted. This function is used to extend an existing set immutably in OpenSCAD environments with utilization of the hashset library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-hashset_add.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/set/hashset.scad>\nuse <util/set/hashset_add.scad>\nuse <util/set/hashset_has.scad>\n\ns1 = hashset([1, 2, 3, 4, 5]);\ns2 = hashset_add(s1, 9);\nassert(hashset_has(s2, 9));\n```\n\n----------------------------------------\n\nTITLE: Generating Multiple Polar Zonohedra in OpenSCAD\nDESCRIPTION: This OpenSCAD example demonstrates how to use the `polar_zonohedra` module. It first includes the required module file using `use <polyhedra/polar_zonohedra.scad>`. Then, it iterates through values of `n` from 3 to 8 using a `for` loop. Inside the loop, it generates a `polar_zonohedra` with the current `n` value and translates it horizontally using `translate` to arrange the shapes side-by-side.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polyhedra_polar_zonohedra.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n\tuse <polyhedra/polar_zonohedra.scad>\n\n\tfor(n = [3:8]) {\n\t\ttranslate([0.5 * n * (n - 3), 0, 0])\n\t\t\tpolar_zonohedra(n);\n\t}\n```\n\n----------------------------------------\n\nTITLE: Generating Isosceles Trapezium Shape Points in OpenSCAD\nDESCRIPTION: Defines a module 'shape_trapezium' that outputs 2D points representing an isosceles trapezium. Accepts parameters for base lengths (single length or vector [bottom, top]), height, and corner radius to create rounded corners. Additional fragment control parameters ($fa, $fs, $fn) influence the resolution of arcs on rounded corners, matching OpenSCAD's circle module behavior. The shape points can be directly used with OpenSCAD's polygon module or extrusion modules like 'xxx_extrude' and 'path_extrude'.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_trapezium.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_trapezium.scad>\n\npolygon(\n\tshape_trapezium([40, 20], \n\th = 20,\n\tcorner_r = 2)\n);\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_trapezium.scad>\nuse <path_extrude.scad>\nuse <bezier_curve.scad>\n\nt_step = 0.05;\nwidth = 2;\n\nshape_pts = shape_trapezium(\n\t[40, 20], \n\th = 20, \n\tcorner_r = 2\n);\n\np0 = [0, 0, 0];\np1 = [40, 60, 35];\np2 = [-50, 70, 45];\np3 = [20, 150, 55];\np4 = [80, 50, 60];\n\npath_pts = bezier_curve(t_step, \n\t[p0, p1, p2, p3, p4]\n);\n\npath_extrude(shape_pts, path_pts);\n```\n\n----------------------------------------\n\nTITLE: Using cone.scad to Create a Cone with Void Cavity in OpenSCAD\nDESCRIPTION: This example illustrates how to create a cone with an internal cavity by setting the void parameter to true. Requires part/cone.scad and uses inputs such as radius, spacing, length, and sets void=true for differencing. Outputs a cone shape with an internal hollow for applications like mold-making or nesting. All other parameters function as in the standard cone.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-cone.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n%cone(\n\tradius = radius, \n\tspacing = spacing,\n    length = 2,\n    void = true\n);\n```\n\n----------------------------------------\n\nTITLE: Creating 3D starbursts with OpenSCAD\nDESCRIPTION: Example demonstrating how to use the starburst module to create various 3D starburst shapes with different parameters. The example creates four starbursts with different numbers of vertices and heights.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-starburst.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <starburst.scad>\n\nstarburst(10, 5, 5, 5);\ntranslate([20, 0, 0]) starburst(10, 5, 6, 5);\ntranslate([40, 0, 0]) starburst(10, 5, 12, 10);\ntranslate([60, 0, 0]) starburst(10, 5, 4, 3);\n```\n\n----------------------------------------\n\nTITLE: Using cone.scad to Create a Void Double-Ended Cone in OpenSCAD\nDESCRIPTION: This snippet shows how to combine the ends and void parameters to create a double-ended cone with a central cavity. Requires part/cone.scad and inputs: radius, spacing, length, with both void and ends set to true. The void flag generates an internal hollow while ends=true produces symmetry, resulting in a double-ended hollow cone shape.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-cone.md#_snippet_3\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n%cone(\n\tradius = radius, \n\tspacing = spacing,\n    length = 2,\n    void = true,\n    ends = true\n);\n```\n\n----------------------------------------\n\nTITLE: Generating Basic Polyline OpenSCAD\nDESCRIPTION: This snippet demonstrates the basic usage of the polyline2d module. It imports the module, sets the fragmentation variable $fn for curved surfaces, and creates a polyline using a list of points with the default width and cap styles (CAP_SQUARE).\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polyline2d.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline2d.scad>\n\n$fn = 24;\n\tpolyline2d(points = [[1, 2], [-5, -4], [-5, 3], [5, 5]], width = 1);\n```\n\n----------------------------------------\n\nTITLE: Generating Filled Voxel Polygon - OpenSCAD\nDESCRIPTION: This snippet demonstrates how to use the `vx_polygon` function with the `filled = true` parameter to generate points for a filled voxel polygon. It uses the same input pentagram shape as the outline example but renders a solid area by including all internal points generated by `vx_polygon`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_polygon.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voxel/vx_polygon.scad>;\n\tuse <shape_pentagram.scad>;\n\n\tpentagram = [\n\t\tfor(pt = shape_pentagram(15))\n\t\t\t[round(pt.x), round(pt.y)]\n\t];\n\ntranslate([30, 0])\n        for(pt = vx_polygon(pentagram, filled = true)) {\n            translate(pt)\n\t\t\tlinear_extrude(1, scale = 0.5)\n\t\t\t\tsquare(1, center = true);\n        }\n```\n\n----------------------------------------\n\nTITLE: Extruding an Arc Shape Along a Bezier Curve Path in OpenSCAD\nDESCRIPTION: This example shows how to combine `shape_arc` with other modules. It generates points for an arc shape, defines a complex 3D path using `bezier_curve`, and then extrudes the arc shape along this path using `path_extrude`. It requires `shape_arc.scad`, `path_extrude.scad`, and `bezier_curve.scad` libraries.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_arc.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_arc.scad>\nuse <path_extrude.scad>\nuse <bezier_curve.scad>\n\nt_step = 0.05;\nwidth = 2;\n\nshape_pts = shape_arc(radius = 10, angle = [180, 360], width = 5);\n\np0 = [0, 0, 0];\np1 = [40, 60, 35];\np2 = [-50, 70, 45];\np3 = [20, 150, 55];\np4 = [80, 50, 60];\n\npath_pts = bezier_curve(t_step, \n    [p0, p1, p2, p3, p4]\n);\n\npath_extrude(shape_pts, path_pts);\n```\n\n----------------------------------------\n\nTITLE: 3D Worley Noise Function Implementation in OpenSCAD\nDESCRIPTION: This snippet defines a function named `nz_worley3` that computes the 3D Worley noise value at given coordinates (x, y, z) for use in procedural modeling. It divides space into a grid with specified width (`grid_w`), determines the nearest cell centers based on a distance metric (`dist`), and returns the cell indices along with the noise value. Dependencies include the OpenSCAD environment and the required input parameters to customize the noise characteristics, such as seed and grid size. The output is an array `[cell_x, cell_y, cell_z, noise]`, representing the cell location and the noise value, useful for generating organic textures or noise-based effects.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-nz_worley3.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# nz_worley3\n\nReturns the 3D [Worley noise](https://en.wikipedia.org/wiki/Worley_noise) value `[cell_x, cell_y, cell_z, noise]` at the (x, y, z) coordinate. \n\nIt divides the space into grids. The nucleus of each cell is randomly placed in a grid. \n\n**Since:** 2.3\n\n## Parameters\n\n- `x` : The x coordinate.\n- `y` : The y coordinate.\n- `z` : The z coordinate.\n- `seed` : The random seed.\n- `grid_w` : The grid width. Default to 10. Smaller `grid_w` makes more cells.\n- `dist` : The noise value of each point is based on its distance to other cells. Different distance strategies make different noises. The `dist` parameter accepts `\"euclidean\"`, `\"manhattan\"`, `\"chebyshev\"` or `\"border\"`.\n\n## Examples\n\n    use <voxel/vx_sphere.scad>\n    use <noise/nz_worley3.scad>\n\n    grid_w = 10;\n    dist = \"border\"; // [euclidean, manhattan, chebyshev, border] \n    seed = 51;\n\n    points = vx_sphere(20);\n\n    cells = [for(p = points) nz_worley3(p.x, p.y, p.z, seed, grid_w, dist)];\n\n    max_dist = max([for(c = cells) c[3]]);\n    for(i = [0:len(cells) - 1]) {\n        c = cells[i][3] / max_dist * 1.5;\n        color([c > 1 ? 1 : c, 0, 0])\n        translate(points[i])\n            cube(1);\n    }\n\n![nz_worley3](images/lib3x-nz_worley3-1.JPG)\n```\n\n----------------------------------------\n\nTITLE: Using cone.scad to Create a Standard Cone in OpenSCAD\nDESCRIPTION: This example demonstrates how to include the cone.scad module and create a standard cone by specifying radius, length, and spacing parameters. The $fn variable is used to control resolution. Required dependencies: part/cone.scad file. Inputs include radius (the base radius), spacing, and length (the height of the cone). Outputs a single cone geometry. By default, creates a single-ended solid cone.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-cone.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <part/cone.scad>;\nradius = 2.5;\nlength = 2;\nspacing = 0.5;\n$fn = 48;\ncone(\n\tradius = radius, \n\tspacing = spacing,\n    length = 2\n);\n```\n\n----------------------------------------\n\nTITLE: Creating 3D Voronoi Diagram with Space in Octant in OpenSCAD\nDESCRIPTION: Produces a 3D Voronoi diagram within the first octant for constrained or tiled designs, based on size and grid parameters, using Voronoi functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_52\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoronoi/vrn3_space(size, grid_w[, seed, spacing])\n```\n\n----------------------------------------\n\nTITLE: Comparing AXIS_ANGLE and EULER_ANGLE for Closed Path Extrusion in OpenSCAD\nDESCRIPTION: Compares `path_extrude` using `AXIS_ANGLE` and `EULER_ANGLE` methods on a closed path generated by `torus_knot`. Shows that `EULER_ANGLE` naturally closes the loop smoothly, while `AXIS_ANGLE` might require manual `twist` adjustment for a perfect closure. Requires `shape_pentagram.scad`, `path_extrude.scad`, and `torus_knot.scad`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-path_extrude.md#_snippet_8\n\nLANGUAGE: openscad\nCODE:\n```\n\tuse <shape_pentagram.scad>\n\tuse <path_extrude.scad>\n\tuse <torus_knot.scad>\n\n\tp = 2;\n\tq = 3;\n\tphi_step = 0.05;\n\tstar_radius = 0.5;\n\n\tpts = torus_knot(p, q, phi_step);\n\n\tshape_pentagram_pts = shape_pentagram(star_radius);\n\n\t// not closed perfectly\n\ttranslate([-8, 0, 0]) \n\t\tpath_extrude(\n\t\t\tshape_pentagram_pts, \n\t\t\t[each pts, pts[0]], \n\t\t\tclosed = true,\n\t\t\tmethod = \"AXIS_ANGLE\"\n\t\t);\n\n\t// adjust it \n\tpath_extrude(\n\t\tshape_pentagram_pts, \n\t\t[each pts, pts[0]], \n\t\tclosed = true,\n\t\ttwist = 188,\n\t\tmethod = \"AXIS_ANGLE\"\n\t);\n\n\t// \"EULER_ANGLE\" is easy in this situation\n\ttranslate([0, 8, 0]) \n\t\tpath_extrude(\n\t\t\tshape_pentagram_pts, \n\t\t\t[each pts, pts[0]], \n\t\t\tclosed = true,\n\t\t\tmethod = \"EULER_ANGLE\"\n\t\t);\n```\n\n----------------------------------------\n\nTITLE: Generating and Visualizing 3D Worley Noise in OpenSCAD\nDESCRIPTION: This OpenSCAD example demonstrates how to use the `nz_worley3s` function to generate 3D Worley noise. It first includes necessary modules (`voxel/vx_sphere.scad` and `noise/nz_worley3s.scad`). It then defines parameters for the noise generation (`grid_w`, `dist`, `seed`). Points forming a sphere are generated using `vx_sphere`, and `nz_worley3s` calculates the noise values for these points. Finally, it iterates through the resulting noise data (`cells`) and the original points, translating and coloring cubes based on the noise magnitude to visualize the pattern.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-nz_worley3s.md#_snippet_0\n\nLANGUAGE: openscad\nCODE:\n```\nuse <voxel/vx_sphere.scad>\nuse <noise/nz_worley3s.scad>\n\ngrid_w = 10;\ndist = \"euclidean\"; // [euclidean, manhattan, chebyshev, border] \nseed = 51;\n\npoints = vx_sphere(20);\ncells = nz_worley3s(points, seed, grid_w, dist);\n\nfor(i = [0:len(cells) - 1]) {\n    c = (norm([cells[i].x, cells[i].y, cells[i].z]) % 20) / 20;\n    color([c, c, c])\n    translate(points[i])\n        cube(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Using cone.scad to Create a Double-Ended Cone in OpenSCAD\nDESCRIPTION: This example demonstrates generating a double-ended cone geometry by setting the ends parameter to true. Requires part/cone.scad, and takes radius, spacing, and length as primary inputs. The ends=true setting causes cones to be mirrored across the base, creating a symmetric double-ended result. Outputs a double-ended solid cone, suitable for ornaments or structural connectors.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-cone.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\ncone(\n\tradius = radius, \n\tspacing = spacing,\n    length = 2,\n    ends = true\n);\n```\n\n----------------------------------------\n\nTITLE: Combining shape_cyclicpolygon with ring_extrude in OpenSCAD\nDESCRIPTION: This example shows how to use shape_cyclicpolygon with ring_extrude to create a 3D object. It creates a pentagonal shape with rounded corners and extrudes it along a ring path with rotation and twist effects.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_cyclicpolygon.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_cyclicpolygon.scad>\nuse <ring_extrude.scad>\n\nshape_pts = shape_cyclicpolygon(\n    sides = 5, \n    circle_r = 10, \n    corner_r = 3\n);\n\nring_extrude(shape_pts, radius = 20, angle = 180, twist = 90);\n```\n\n----------------------------------------\n\nTITLE: Defining a Bezier Curve Path in OpenSCAD\nDESCRIPTION: Defines a Bezier curve using the `bezier_curve` function. The first argument calculates a step value based on the length of the first element in the `levels` array, likely controlling the curve's resolution. The second argument is a list of 3D control points defining the curve's shape. The resulting path is stored in the `curve_path` variable.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_curve.md#_snippet_0\n\nLANGUAGE: openscad\nCODE:\n```\ncurve_path = bezier_curve(1 / len(levels[0]) * 0.5, \n    [\n        [-20, 0, 0],\n        [40, 20, 155],\n        [50, 50, -30],\n        [-20, 0, 35],\n        [130, -70, -20],\n        [150, 0, 100],\n        [180, 30, 0]\n    ]\n);\n```\n\n----------------------------------------\n\nTITLE: Generating 3D Perlin Noise Values at Coordinates using nz_perlin3s in OpenSCAD\nDESCRIPTION: This snippet calculates 3D Perlin noise values at specified (x, y, z) points in OpenSCAD. It defines a list of coordinate points, applies the nz_perlin3s function to compute noise values at those points, and demonstrates how to visualize the noise by creating colored cubes along the z-axis where noise values are positive. Dependencies include util/rand.scad, noise/nz_perlin2s.scad, and noise/nz_perlin3s.scad. Key parameters are 'points' for coordinate input and 'seed' for randomness control. The output is a visual representation of noise over a 3D grid, useful for procedural terrain or surface modeling.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-nz_perlin3s.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# nz_perlin3s\n\nReturns 3D [Perlin noise](https://en.wikipedia.org/wiki/Perlin_noise) values at (x, y, z) coordinates.\n\n**Since:** 2.3\n\n## Parameters\n\n- `points` : A list of `[x, y, z]` coordinates.\n- `seed` : The random seed. If it's ignored, a randomized value will be used.\n\n## Examples\n\n    use <util/rand.scad>\n    use <noise/nz_perlin2s.scad>\n    use <noise/nz_perlin3s.scad>\n\n    points = [\n        for(y = [0:.2:10])\n            [\n                for(x = [0:.2:10])\n                [x, y]\n            ]\n    ];\n\n    seed = rand(0, 256);\n\n    points_with_h = [\n            for(ri = [0:len(points) - 1])\n            let(ns = nz_perlin2s(points[ri], seed))\n            [\n                for(ci = [0:len(ns) - 1])\n                    [points[ri][ci][0], points[ri][ci][1], ns[ci] + 1]\n            ]\n        ];\n\n    h_scale = 1.5;\n    for(row = points_with_h) {        \n        for(i = [0:len(row) - 1]) {\n            p = row[i];\n            pts = [\n                for(z = [0:.2:p[2] * h_scale]) [p.x, p.y, z]\n            ];\n            noise = nz_perlin3s(pts, seed);\n            for(j = [0:len(pts) - 1]) {\n                if(noise[j] > 0) {\n                    color(\n                        pts[j][2] < 1 ? \"green\" : \n                        pts[j][2] < 1.5 ? \"Olive\" : \"white\")\n                    translate(pts[j])\n                        cube(.2);\n                }           \n            }\n        }\n    }\n\n    color(\"LimeGreen\")\n    linear_extrude(.2)\n        square(10);\n```\n\n----------------------------------------\n\nTITLE: Using angle_between function in OpenSCAD\nDESCRIPTION: Examples demonstrating how to use the angle_between function to calculate angles between vectors in both 2D and 3D space. The function returns angles in degrees.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-angle_between.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <angle_between.scad>\n\nassert(angle_between([0, 1], [1, 0]) == 90);\nassert(angle_between([0, 1, 0], [1, 0, 0]) == 90);\nassert(round(angle_between([1, 1, 0], [1, 1, sqrt(2)])) == 45);\n```\n\n----------------------------------------\n\nTITLE: Defining and calling a deterministic L-system in OpenSCAD\nDESCRIPTION: This snippet demonstrates the creation of a deterministic 2D L-system named \"fern\" using the lsystem2 function in OpenSCAD. It specifies the initial axiom, production rules, and parameters such as iteration times, turning angle, and line length to generate a plant-like fractal pattern. The resulting line segments are drawn via the line2d module with round caps. Dependencies include the turtle/lsystem2.scad module and the line2d.scad module for rendering. Inputs include the axiom string and rule list; outputs are a list of line coordinates representing the L-system geometry.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-lsystem2.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <turtle/lsystem2.scad>\\nuse <line2d.scad>\\n\\nfor(line = fern()) {\\n\\tline2d(\\n\\t\\tline[0],\\n\\t\\tline[1],\\n\\t\\t.2,\\n\\t\\tp1Style = \"CAP_ROUND\", \\n\\t\\tp2Style =  \"CAP_ROUND\"\\n\\t);\\n}\\n\\nfunction fern(n = 8, angle = 4, leng = 1, heading = 0, start = [0, 0]) = \\n\\tlet(\\n\\t\\taxiom = \"EEEA\",\\n\\t\\trules = [\\n\\t\\t\\t[\"A\", \"[++++++++++++++EC]B+B[--------------ED]B+BA\"],\\n\\t\\t\\t[\"C\", \"[---------EE][+++++++++EE]B+C\"],\\n\\t\\t\\t[\"D\", \"[---------EE][+++++++++EE]B-D\"]\\n\\t\\t]\\n\\t)\\n\\tlsystem2(axiom, rules, n, angle, leng, heading, start, forward_chars = \"ABCDE\");\n```\n\n----------------------------------------\n\nTITLE: Implementation and usage example of `trim_shape` function in OpenSCAD\nDESCRIPTION: This snippet provides a detailed implementation of the `trim_shape` function for trimming tangled-edge shapes to non-tangled shapes, including example code showing how it integrates with other shape processing functions like `bijection_offset` and `midpt_smooth`. It illustrates the input parameters, usage context, dependencies on other modules, and visualization of results.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-trim_shape.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# trim_shape\n\nGiven a tangled-edge shape. This function trims the shape to a non-tangled shape. It's intended to be a helper function after using `bijection_offset`. \n\n**Since:** 1.3.\n\n## Parameters\n\n- `shape_pts` : The shape points.\n- `from` : The index of the start point you want to trim.\n- `to` : The index of the last point you want to trim.\n- `epsilon` : An upper bound on the relative error due to rounding in floating point arithmetic. Default to 0.0001.\n\n## Examples\n\n    use <polyline_join.scad>\n    use <trim_shape.scad>\n    use <shape_taiwan.scad>\n    use <bijection_offset.scad>\n    use <midpt_smooth.scad>\n\n    taiwan = shape_taiwan(50);\n    offseted = bijection_offset(taiwan, -2);\n    trimmed = trim_shape(offseted, 3, len(offseted) - 6);\n    smoothed = midpt_smooth(trimmed, 3);\n\n    #polyline_join(taiwan)\n\t    circle(.05); \n    %translate([25, 0, 0]) \n\t polyline_join(offseted)\n\t\tcircle(.1);\n    polyline_join(smoothed)\n\t    circle(.05); \n\n![trim_shape](images/lib3x-trim_shape-1.JPG)\n```\n\n----------------------------------------\n\nTITLE: Extruding Heart with Twist and Slices - OpenSCAD\nDESCRIPTION: This OpenSCAD snippet demonstrates the use of `twist` and `slices` parameters with the `ellipse_extrude` function. The code sets `semi_minor_axis` to 10. The `ellipse_extrude` is called with `twist` set to 30 and `slices` set to 10 and a heart symbol. This produces a more complex extrusion with the twist and slice effects applied.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-ellipse_extrude.md#_snippet_3\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <ellipse_extrude.scad>\n\n\tsemi_minor_axis = 10;\n\t \n\tellipse_extrude(semi_minor_axis, twist = 30, slices = 10) \n\t    text(\"♥\", size = 40, valign = \"center\", halign = \"center\");\n```\n\n----------------------------------------\n\nTITLE: Using ptf_circle for Transformation in OpenSCAD\nDESCRIPTION: This OpenSCAD code demonstrates the usage of the `ptf_circle` function.  It takes a `size` parameter (a 2-element array representing the rectangle's dimensions) and a `point` parameter (the point to transform). The code iterates through rows and columns, applying `ptf_circle` to transform each point within the defined size and then joins the transformed points with `polyline_join`, rendering a series of spheres to visualize the transformation result. Dependencies include `polyline_join.scad` and `ptf_circle.scad`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-ptf_circle.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline_join.scad>\nuse <ptf/ptf_circle.scad>\n\nsize = [10, 10];\n\nrows = [\n    for(y = [0:size.y])\n        [for(x = [0:size.x]) [x, y]]\n];\n\ncolumns = [\n    for(x = [0:size.x])\n        [for(y = [0:size.y]) [x, y]]\n];\n\nfor(line = rows) {\n    transformed = [for(p = line) ptf_circle(size, p)];\n    polyline_join(transformed)\n\t    sphere(.05);\n}\n\nfor(line = columns) {\n    transformed = [for(p = line) ptf_circle(size, p)];\n    polyline_join(transformed)\n\t    sphere(.05);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Icosahedron Geometry in OpenSCAD\nDESCRIPTION: Defines the icosahedron module which generates a 3D icosahedron mesh. It requires the 'radius' parameter specifying the size of the shape, and an optional 'detail' parameter that increases vertex count when greater than zero, thus refining the mesh beyond a pure icosahedron. The module relies on OpenSCAD's polyhedra capabilities and can be included via 'use <polyhedra/icosahedron.scad>'. This snippet is designed for 3D modeling within the OpenSCAD environment.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polyhedra_icosahedron.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyhedra/icosahedron.scad>\n\nfor(i = [0:5]) {\n\ttranslate([i * 2, 0])\n\t\ticosahedron(radius = 1, detail = i);\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Rectangle Grid Points to Sphere Surface in OpenSCAD\nDESCRIPTION: This OpenSCAD code snippet demonstrates how to use the ptf_sphere module to map each point of a rectangular grid (defined by the 'size' parameter) onto a sphere with a specified radius and mapping angles. It depends on the external modules 'polyline_join.scad' and 'ptf/ptf_sphere.scad'. The transformation is applied separately to all row-wise and column-wise points; each result is connected visually using polyline_join, and a small sphere is rendered at each transformed location. Required parameters are 'size' (2-value array for rectangle dimensions), 'radius' (sphere radius), and 'angle' ([za, xa] array for mapping angles). Expected input is a grid of 2D points; output is a series of polylines mapped onto a sphere. This approach is suitable for visualizing spherical coordinate transformations and creating curved geometries.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-ptf_sphere.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline_join.scad>\nuse <ptf/ptf_sphere.scad>\n\nsize = [20, 10];\nradius = 5;\nangle = [180, 270];\n\nrows = [\n    for(y = [0:size.y])\n        [for(x = [0:size.x]) [x, y]]\n];\n\ncolumns = [\n    for(x = [0:size.x])\n        [for(y = [0:size.y]) [x, y]]\n];\n\nfor(line = rows) {\n    transformed = [for(p = line) ptf_sphere(size, p, radius, angle)];\n    polyline_join(transformed)\n        sphere(.25);\n}\n\nfor(line = columns) {\n    transformed = [for(p = line) ptf_sphere(size, p, radius, angle)];\n    polyline_join(transformed)\n        sphere(.25);\n}\n```\n\n----------------------------------------\n\nTITLE: sf_thicken with Function-Generated Surface\nDESCRIPTION: Illustrates how to use sf_thicken with a surface generated by a function.  The surface is created using nested loops that evaluate a function f(x, y) to determine the z-coordinate for each point. The example depends on sf_thicken.scad and demonstrates a more complex surface generation.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_thicken.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n\tuse <surface/sf_thicken.scad>\n\n\tfunction f(x, y) = \n        let(leng = norm([x, y]))\n\t\t30 * (cos(leng) + cos(3 * leng));\n\n\tthickness = 3;\n\tmin_value =  -200;\n\tmax_value = 200;\n\tresolution = 10;\n\n\tsurface1 = [\n\t\tfor(y = [min_value:resolution:max_value])\n\t\t[\n\t\t\tfor(x = [min_value:resolution:max_value]) \n\t\t\t\t[x, y, f(x, y) + 100]\n\t\t]\n\t];\n\tsf_thicken(surface1, thickness);\n```\n\n----------------------------------------\n\nTITLE: Using shape_star Module to Create Star Polygons in OpenSCAD\nDESCRIPTION: This example demonstrates how to use the shape_star module to create star polygons in OpenSCAD. It shows creating a default pentagram and an 8-pointed star placed next to each other. The shape_star function returns points that are used with the polygon function.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_star.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_star.scad>\n\npolygon(shape_star());\ntranslate([3, 0, 0]) \n    polygon(shape_star(n = 8));\n```\n\n----------------------------------------\n\nTITLE: Path Scaling Sections Example 2 - Bezier Curve Edge Path\nDESCRIPTION: This example extends the first example by using a Bezier curve for the edge path.  It relies on  `polyline_join.scad`, `shape_taiwan.scad`, `path_scaling_sections.scad`, `sweep.scad`, and `bezier_curve.scad`. The edge path is now created using the `bezier_curve` function, which smooths the path based on the input points. The rest of the code remains similar, using `sweep` and `path_scaling_sections` to generate the final shape.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-path_scaling_sections.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n\tuse <polyline_join.scad>\n\tuse <shape_taiwan.scad>\n\tuse <path_scaling_sections.scad>\n\tuse <sweep.scad>\n\tuse <bezier_curve.scad>\n\n\ttaiwan = shape_taiwan(100);\n\tfst_pt = [13, 0, 0];\n\n\tedge_path = bezier_curve(0.05, [\n\t\tfst_pt,\n\t\tfst_pt + [0, 0, 10],\n\t\tfst_pt + [10, 0, 20],\n\t\tfst_pt + [8, 0, 30],\n\t\tfst_pt + [12, 0, 40],\n\t\tfst_pt + [0, 0, 50],\n\t\tfst_pt + [0, 0, 60]\n\t]);\n\n\t#polyline_join(edge_path) \n\t    sphere(.5);\n\tsweep(path_scaling_sections(taiwan, edge_path));\n```\n\n----------------------------------------\n\nTITLE: Cross-Section Extrusion Example - OpenSCAD\nDESCRIPTION: This example demonstrates how to use the `cross_sections` module in conjunction with the `sweep` module to create an extrusion along an Archimedean spiral path. It defines a rectangular shape, generates points and angles along the spiral, and then uses `sweep` to extrude the shape along the path with the given twist and scale. It depends on the `sweep.scad` and `archimedean_spiral.scad` libraries.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-cross_sections.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <sweep.scad>\nuse <cross_sections.scad>\nuse <archimedean_spiral.scad>\n\nshape_pts = [\n\t[-2, -10],\n\t[-2, 10],\n\t[2, 10],\n\t[2, -10]\n];\n\npts_angles = archimedean_spiral(\n\tarm_distance = 20,\n\tinit_angle = 180,\n\tpoint_distance = 5,\n\tnum_of_points = 100 \n);\n\npts = [for(pt_angle = pts_angles) pt_angle[0]];\nangles = [\n\tfor(i = [0:len(pts_angles) - 1]) [90, 0, pts_angles[i][1]]\n];\n\nsweep(\n\tcross_sections(shape_pts, pts, angles, twist = 180, scale = 0.1)\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Rounded Cylinder with Tapered Top in OpenSCAD\nDESCRIPTION: Demonstrates how to use the rounded_extrude module to create a cylindrical object with rounded edges, followed by a tapered cylinder on top. The example sets fragment count to 48 for smooth curves and creates a total object with a round transition.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-rounded_extrude.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <rounded_extrude.scad>\n\n$fn = 48;\n\ncircle_r = 10;\nround_r = 5;\n\nrounded_extrude(circle_r * 2, round_r) \n\tcircle(circle_r);\n\t\ntranslate([0, 0, round_r]) \n\tcylinder(h = 20, r1 = circle_r + round_r, r2 = 0);\n```\n\n----------------------------------------\n\nTITLE: Using vx_contour and vx_ascii to Outline Text in OpenSCAD\nDESCRIPTION: This OpenSCAD example demonstrates how to use the `vx_contour` function to generate an outline for text characters. It first includes the necessary `voxel/vx_ascii.scad` and `voxel/vx_contour.scad` modules. It then iterates through a string `t`, generates point sets for each character using `vx_ascii`, visualizes these points as small squares, and finally uses `vx_contour` on the character point sets to create polygon outlines (contours) for each character, extruded slightly less than the squares.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_contour.md#_snippet_0\n\nLANGUAGE: openscad\nCODE:\n```\nuse <voxel/vx_ascii.scad>\nuse <voxel/vx_contour.scad>\n\nt = \"dotSCAD\";\n\ncolor(\"white\")\nlinear_extrude(2)\nfor(i = [0:len(t) - 1]) {\n    translate([i * 8, 0]) \n    for(pt = vx_ascii(t[i])) {\n        translate(pt)\n            square(1, center = true);\n    }\n}\n\ncolor(\"black\")\nlinear_extrude(1)\nfor(i = [0:len(t) - 1]) {\n    translate([i * 8, 0]) \n        polygon(vx_contour(vx_ascii(t[i])));\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Perlin Noise and Visualizing in OpenSCAD\nDESCRIPTION: This OpenSCAD snippet calculates Perlin noise values across a 2D grid using the `nz_perlin2` function. It generates a set of points where the z-coordinate is the Perlin noise value at the x and y coordinate. The generated points are then thickened using `sf_thicken` and also used to generate contour lines. The code uses `rand` to create a seed for the noise generation.  The output is a 3D object formed by using the generated points.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-nz_perlin2.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/rand.scad>\nuse <polyline_join.scad>\nuse <surface/sf_thicken.scad>\nuse <noise/nz_perlin2.scad>\nuse <contours.scad>\n\nseed = rand(0, 255);\npoints = [\n    for(y = [0:.1:10])\n    [\n        for(x = [0:.1:10])\n        [x, y, nz_perlin2(x, y, seed)]\n    ]\n];\n\nsf_thicken(points, .1);\n\ntranslate([11, 0])\nfor(isoline = contours(points, 0)) {\n    polyline_join(isoline)\n\t    circle(.05);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Surface Points and Contours in OpenSCAD\nDESCRIPTION: Demonstrates how to generate 3D surface points from a sine/cosine function and create both isolines and isobands using the contours library. The example shows three uses: rendering the original surface, creating stacked isolines, and creating extruded isobands.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-contours.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline_join.scad>\nuse <surface/sf_thicken.scad>\nuse <contours.scad>\n\nmin_value =  1;\nmax_value = 360;\nresolution = 10;\n\nfunction f(x, y) = sin(x) * cos(y) * 30;\n\npoints = [\n    for(y = [min_value:resolution:max_value])\n    [\n        for(x = [min_value:resolution:max_value]) \n            [x, y, f(x, y)]\n    ]\n];\n\nsf_thicken(points, 1);\n\ntranslate([max_value, 0, 0]) \nfor(z = [-30:5:30]) {\n    translate([0, 0, z])\n    linear_extrude(1)\n    for(isoline = contours(points, z)) {\n        polyline_join(isoline)\n            circle(.5);\n    }    \n}\n\ntranslate([0, max_value]) \nfor(z = [-30:5:30]) {\n    linear_extrude(35 + z)\n    for(isoband = contours(points, [z, z + 5])) {\n        polygon([for(p = isoband) [p[0], p[1]]]);\n    } \n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating OpenSCAD zip function\nDESCRIPTION: This OpenSCAD snippet demonstrates the usage of the 'zip' function with and without a custom combine function. It requires the 'util/zip.scad' and 'util/sum.scad' modules. It defines three lists (xs, ys, zs) and uses 'assert' to verify the output of the 'zip' function in both basic and combined scenarios.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-zip.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/zip.scad>;\nuse <util/sum.scad>;\n\nxs = [10, 20, 30];\nys = [5, 15, 25];\nzs = [2.5, 7.5, 12.4];\n\nassert(zip([xs, ys, zs]) == [[10, 5, 2.5], [20, 15, 7.5], [30, 25, 12.4]]);\n\nsum_up = function(elems) sum(elems);\nassert(zip([xs, ys, zs], sum_up) == [17.5, 42.5, 67.4]);\n```\n\n----------------------------------------\n\nTITLE: Creating a Textured Sphere Surface Using sf_sphere in OpenSCAD\nDESCRIPTION: This code demonstrates how to use the sf_sphere module to create a textured spherical surface based on a 2D array of grayscale values. It defines parameters for radius, thickness, depth, angle, and whether to invert the surface, then provides a large 2D array of values representing a grayscale height map.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_sphere.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n// The code of the above picture.\nuse <surface/sf_sphere.scad>\n\nradius = 50;\nthickness = 10;\ndepth = 5;\nangle = [180, 180];\ninvert = false;\nlevels = [\n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 180, 219, 255, 255, 224, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 85, 62, 173, 255, 255, 222, 154, 168, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 147, 16, 73, 166, 190, 8, 17, 99, 97, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 151, 11, 26, 153, 111, 61, 58, 40, 128, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 137, 73, 74, 154, 131, 24, 18, 95, 192, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 217, 153, 162, 152, 97, 82, 120, 155, 66, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 194, 146, 146, 131, 118, 96, 75, 46, 46, 191, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 185, 139, 130, 117, 99, 78, 53, 38, 64, 168, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 194, 108, 102, 95, 74, 60, 38, 47, 89, 85, 153, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 101, 77, 67, 52, 38, 48, 82, 109, 73, 48, 222, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 225, 70, 40, 42, 57, 84, 107, 92, 62, 38, 164, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 215, 100, 89, 102, 115, 91, 72, 44, 47, 105, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 112, 114, 102, 86, 68, 51, 41, 66, 101, 94, 140, 194, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]\n```\n\n----------------------------------------\n\nTITLE: Generating 3D Perlin Noise with nz_perlin3 in OpenSCAD\nDESCRIPTION: This example demonstrates how to use the `nz_perlin3` module to generate 3D Perlin noise in OpenSCAD. It iterates through x, y, and z coordinates, calculates the noise value, and creates cubes at locations where the noise value exceeds 0.2. It depends on the `rand.scad` and `nz_perlin3.scad` modules, which provide random number generation and the Perlin noise function, respectively. The `seed` variable is used for controlling the noise pattern.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-nz_perlin3.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/rand.scad>\nuse <noise/nz_perlin3.scad>\n\nseed = rand(0, 255);\nnoised = [\n    for(z = [0:.2:5], y = [0:.2:5], x = [0:.2:5])\n    [x, y, z, nz_perlin3(x, y, z, seed)]\n];    \n\nfor(nz = noised) {\n    if(nz[3] > 0.2) {\n        translate([nz.x, nz.y, nz.z])\n            cube(.2);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Maze Tiles from Cells in OpenSCAD\nDESCRIPTION: This snippet contains a function to convert maze cell data into tile data with positional coordinates and tile index. It prepares the data for visualization, aligning tiles based on maze structure with optional borders. Dependencies include maze cell data and functions for maze grid creation.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-mz_tiles.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# mz_tiles\n\nIt turns maze cells into tiles. The retured tiles have a data structure `[x, y, n]`, where `n` is a tile index 0 ~ 15 of the tileset.\n\n![mz_tiles](images/lib3x-mz_tiles-1.JPG)\n\nJust replace the tiles with your own path designs.\n\n**Since:** 3.3\n\n## Parameters\n\n- `cells` : Maze cells.\n- `left_border` : Default to `true`. Create the leftmost border of the maze.\n- `bottom_border` : Default to `true`. Create the bottommost border of the maze.\n\n## Examples\n\n\tuse <maze/mz_square.scad>\n\tuse <maze/mz_tiles.scad>\n\n\trows = 10;\n\tcolumns = 10;\n\n\tcells = mz_square(rows, columns);\n\n\ttiles = mz_tiles(cells);\n\n\ttile_width = 30;\n\tfor(tile = tiles) {\n\t\ttranslate([tile.x, tile.y] * tile_width)\n\t\t\ttile(tile[2], tile_width);\n\t}\n\n\tmodule tile(type, width) {\n\t\t// true 表示該方向有通道\n\t\troads = [\n\t\t\t[false, false, false, false],\n\t\t\t[true, false, false, false],\n\t\t\t[false, true, false, false],\n\t\t\t[true, true, false, false],\n\t\t\t[false, false, true, false],\n\t\t\t[true, false, true, false],\n\t\t\t[false, true, true, false],\n\t\t\t[true, true, true, false],\n\t\t\t[false, false, false, true],\n\t\t\t[true, false, false, true],\n\t\t\t[false, true, false, true],\n\t\t\t[true, true, false, true],\n\t\t\t[false, false, true, true],\n\t\t\t[true, false, true, true],\n\t\t\t[false, true, true, true],\n\t\t\t[true, true, true, true]\n\t\t];\n\n\t\tdifference() {\n\t\t\tsquare(width, center = true);\n\t\t\t\n\t\t\tfor(i = [0:3]) {\n\t\t\t\tif(roads[type][i]) {\n\t\t\t\t\trotate(-90 * i)\n\t\t\t\t\ttranslate([-width / 4, -width / 4])\n\t\t\t\t\t\tsquare([width / 2, width]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Including sorted.scad in OpenSCAD\nDESCRIPTION: This snippet includes the `sorted.scad` file, which presumably contains the implementation of the `sorted` function. This inclusion makes the function available for use in the current OpenSCAD file. It is a necessary step before using the sorted function.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sorted.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/sorted.scad>\n```\n\n----------------------------------------\n\nTITLE: Solidifying Two Surfaces in OpenSCAD\nDESCRIPTION: Combines two surface objects into a solid shape with optional slicing, enabling complex surface merging. Requires surface library functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_27\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nsurface/sf_solidify(surface1, surface2[, slicing])\n```\n\n----------------------------------------\n\nTITLE: Using nz_perlin1s for 1D Perlin Noise\nDESCRIPTION: This example demonstrates how to use the `nz_perlin1s` module to generate 1D Perlin noise values for a given set of x coordinates, and then uses these values to create a polyline. It depends on `polyline_join.scad` and `noise/nz_perlin1s.scad`. The module takes x coordinates `xs` and generates corresponding y values `ys` which are then used to construct a list of `points` suitable for creating a polyline.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-nz_perlin1s.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline_join.scad>\nuse <noise/nz_perlin1s.scad>\n\nxs = [for(x = [0:.1:10]) x];\nys = nz_perlin1s(xs);\npoints = [for(i = [0:len(xs) - 1]) [xs[i], ys[i]]];\n\npolyline_join(points)\n\tcircle(.05);\n```\n\n----------------------------------------\n\nTITLE: Defining the Size of a 2D Shape for bend_extrude in OpenSCAD\nDESCRIPTION: Demonstrates how to define the dimensions of a square that contains a 2D text shape, which will be used as the 'size' parameter for bend_extrude.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-bend_extrude.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nx = 9.25;\ny = 9.55;\n\n%square(size = [x, y]);\ntext(\"A\");\n```\n\n----------------------------------------\n\nTITLE: Applying Shear Transformations to Child Elements in OpenSCAD\nDESCRIPTION: Demonstrates use of the 'shear' macro to transform child elements along the X, Y, or Z axis in OpenSCAD. Dependencies include the shear macro (imported using use <shear.scad>) and standard OpenSCAD primitives such as cube(), color(), and translate(). Parameters sx, sy, and sz accept a two-element array to define the shear factors; the code visually distinguishes results using colors, stacking, and translations. The input to each shear is a child geometry, such as cube(1), and the output is the sheared version of that geometry. Limitations: requires OpenSCAD version supporting 'use' and provided macros, and only demonstrates basic shearing on unit cubes for illustration.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shear.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shear.scad>\n\ncolor(\"red\") {\n\tshear(sx = [1, 0])\n\t\tcube(1);\n\t\t\n\ttranslate([2, 0, 0]) shear(sx = [0, 1])\n\t\tcube(1);\n\t\t\n\ttranslate([4, 0, 0]) shear(sx = [1, 1])\n\t\tcube(1);\n}\n\ntranslate([0, -3, 0]) color(\"green\") {\n\tshear(sy = [1, 0])\n\t\tcube(1);\n\t\t\n\ttranslate([2, 0, 0]) shear(sy = [0, 1])\n\t\tcube(1);\n\t\t\n\ttranslate([4, 0, 0]) shear(sy = [1, 1])\n\t\tcube(1);\n}\n\ntranslate([0, -5, 0]) color(\"blue\") {\n\tshear(sz = [1, 0])\n\t\tcube(1);\n\t\t\n\ttranslate([2, 0, 0]) shear(sz = [0, 1])\n\t\tcube(1);\n\t\t\n\ttranslate([4, 0, 0]) shear(sz = [1, 1])\n\t\tcube(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Using ptf_y_twist in OpenSCAD\nDESCRIPTION: This OpenSCAD code demonstrates the usage of the `ptf_y_twist` function to twist points along the y-axis.  It takes a size, a point, and an angle as parameters to apply the transformation. The code iterates through rows and columns of points, applying the twist to each point and then rendering the result using `polyline_join`.  The `polyline_join` function, alongside the `sphere` function with a radius of 0.05, creates and visualizes the twisted lines within the grid.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-ptf_y_twist.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline_join.scad>\nuse <ptf/ptf_y_twist.scad>\n\nsize = [10, 20];\n\nrows = [\n    for(y = [0:size.y])\n        [for(x = [0:size.x]) [x, y]]\n];\n\ncolumns = [\n    for(x = [0:size.x])\n        [for(y = [0:size.y]) [x, y]]\n];\n\nfor(line = rows) {\n    twisted = [for(p = line) ptf_y_twist(size, p, 90)];\n    polyline_join(twisted)\n\t    sphere(.05);\n}\n\nfor(line = columns) {\n    twisted = [for(p = line) ptf_y_twist(size, p, 90)];\n    polyline_join(twisted)\n\t    sphere(.05);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Outward Arc in OpenSCAD\nDESCRIPTION: Shows how to create an arc using the `arc` module with `width_mode` set to \"LINE_OUTWARD\". This mode makes the arc extend outwards from the specified radius by the given width. Requires the `arc.scad` library. `$fn` controls the smoothness of the curve.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-arc.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <arc.scad>\n\n$fn = 24;\narc(radius = 20, angle = [45, 290], width = 2, width_mode = \"LINE_OUTWARD\");\n%circle(r = 20);\n```\n\n----------------------------------------\n\nTITLE: Example Usage of sf_solidify in OpenSCAD\nDESCRIPTION: Demonstrates how to use the `sf_solidify` module to create a solid from two surfaces defined by point lists. It defines a function `f(x, y)` to generate z-coordinates, creates two surfaces (`surface1`, `surface2`) using nested list comprehensions based on this function and specified bounds/resolution, and then calls `sf_solidify` to connect them. Requires the `surface/sf_solidify.scad` library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_solidify.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <surface/sf_solidify.scad>\n\nfunction f(x, y) = \n30 * (\n    cos(sqrt(pow(x, 2) + pow(y, 2))) + \n    cos(3 * sqrt(pow(x, 2) + pow(y, 2)))\n);\n\nthickness = 2;\nmin_value =  -200;\nmax_value = 200;\nresolution = 10;\n\nsurface1 = [\n    for(y = [min_value:resolution:max_value])\n    [\n        for(x = [min_value:resolution:max_value]) \n            [x, y, f(x, y) + 100]\n    ]\n];\n\nsurface2 = [\n    for(y = [min_value:resolution:max_value])\n    [\n        for(x = [min_value:resolution:max_value]) \n            [x, y, -f(x, y) - 100]\n    ]\n];\n\nsf_solidify(surface1, surface2);\n```\n\n----------------------------------------\n\nTITLE: Generating Polyline Rounded Start and End Caps OpenSCAD\nDESCRIPTION: This snippet illustrates creating a polyline where both the starting and ending caps are rounded. It imports the polyline2d module, sets $fn, and calls the module with 'CAP_ROUND' specified for both startingStyle and endingStyle parameters.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polyline2d.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline2d.scad>\n    \n    $fn = 24;\n\tpolyline2d(\n        points = [[1, 2], [-5, -4], [-5, 3], [5, 5]], \n        width = 1,\n        startingStyle = \"CAP_ROUND\", \n        endingStyle = \"CAP_ROUND\"\n    );\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Bent Surface Parameters in OpenSCAD\nDESCRIPTION: This OpenSCAD snippet defines parameters for constructing a bent surface, including radius, thickness, depth, angle, and orientation inversion. The most significant input is the 'levels' 2D array representing grayscale pixel intensities (0-255) arranged in rows. This array likely controls the height or depth variations of the surface, enabling detailed surface modeling. The snippet depends on an external surface module '<surface/sf_bend.scad>' that provides the core bending and surface shaping functionality.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_bend.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n// The code of the above picture.\nuse <surface/sf_bend.scad>\n\nradius = 50;\nthickness = 10;\ndepth = 8;\nangle = 180;\ninvert = false;\nlevels = [\n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 180, 219, 255, 255, 224, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 85, 62, 173, 255, 255, 222, 154, 168, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 147, 16, 73, 166, 190, 8, 17, 99, 97, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 151, 11, 26, 153, 111, 61, 58, 40, 128, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 137, 73, 74, 154, 131, 24, 18, 95, 192, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 217, 153, 162, 152, 97, 82, 120, 155, 66, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 194, 146, 146, 131, 118, 96, 75, 46, 46, 191, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 185, 139, 130, 117, 99, 78, 53, 38, 64, 168, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 194, 108, 102, 95, 74, 60, 38, 47, 89, 85, 153, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 101, 77, 67, 52, 38, 48, 82, 109, 73, 48, 222, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 215, 100, 89, 102, 115, 91, 72, 44, 47, 105, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 112, 114, 102, 86, 68, 51, 41, 66, 101, 94, 140, 194, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]\n]\n```\n\n----------------------------------------\n\nTITLE: Custom Sized Centered Rounded Cube in OpenSCAD\nDESCRIPTION: Creating a centered rounded cube with custom dimensions. This example creates a 50×25×15 cube with 5mm rounded corners centered at the origin.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-rounded_cube.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <rounded_cube.scad>\n\nrounded_cube(\n    size = [50, 25, 15], \n    corner_r = 5,\n    center = true\n);\n```\n\n----------------------------------------\n\nTITLE: Path Scaling Sections Example 4 - Dynamic First Point and Rotation\nDESCRIPTION: This example demonstrates how to dynamically set the first point of the edge path based on the shape and also incorporate rotation using `ptf_rotate`. It requires `polyline_join.scad`, `shape_taiwan.scad`, `path_scaling_sections.scad`, `sweep.scad`, and `ptf/ptf_rotate.scad`. The first point is calculated from the first point of the taiwan shape, and the subsequent edge path points are rotated using `ptf_rotate` to align with the shape's initial orientation.  This creates an extrusion that starts aligned with the shape.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-path_scaling_sections.md#_snippet_3\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n\tuse <polyline_join.scad>\n\tuse <shape_taiwan.scad>\n\tuse <path_scaling_sections.scad>\n\tuse <sweep.scad>\n    use <ptf/ptf_rotate.scad>\n\n\ttaiwan = shape_taiwan(100);\n\n    /* \n\t    You can use any point as the first point of the edge path.\n\t\tJust remember that your edge path radiates from the origin.\n\t*/\n\tfst_pt = [taiwan[0][0], taiwan[0][1], 0];//[13, 0, 0];\n    a = atan2(fst_pt[1], fst_pt[0]);\n\tedge_path = [\n\t\tfst_pt,\n\t\tfst_pt + ptf_rotate([0, 0, 10], a),\n\t\tfst_pt + ptf_rotate([10, 0, 20], a),\n\t\tfst_pt + ptf_rotate([8, 0, 30], a),\n\t\tfst_pt + ptf_rotate([10, 0, 40], a),\n\t\tfst_pt + ptf_rotate([0, 0, 50], a),\n\t\tfst_pt + ptf_rotate([0, 0, 60], a)\n\t];\n\n\t#polyline_join(edge_path) \n\t    sphere(.5);\n\tsweep(path_scaling_sections(taiwan, edge_path));\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of shape_path_extend with Circle Path in OpenSCAD\nDESCRIPTION: Demonstrates extending a stroke along a circular path. This example creates a wavy circular shape by extending a zigzag stroke along a circle path generated by shape_circle.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_path_extend.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_path_extend.scad>\nuse <shape_circle.scad>\nuse <archimedean_spiral.scad>\n\n$fn = 96;\n\nstroke1 = [[-5, 2.5], [-2.5, 0], [0, 2.5], [2.5, 0], [5, 2.5]];\npath_pts1 = shape_circle(50, 60);\npolygon(\n    shape_path_extend(stroke1, path_pts1)\n);\n```\n\n----------------------------------------\n\nTITLE: Generating a helical 3D polyline in OpenSCAD\nDESCRIPTION: This example creates a spiral or helix by calculating points along a circle with specified radius and height using trigonometric functions. The points are then connected with the polyline3d function, illustrating dynamic and parametric point generation for complex shapes.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polyline3d.md#_snippet_3\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline3d.scad>\n\nr = 20;\nh = 5;\nfa = 15;\ncircles = 10;\n\npoints = [\n    for(a = [0:fa:360 * circles]) \n        [r * cos(a), r * sin(a), h / (360 / fa) * (a / fa)]\n];\npolyline3d(points, diameter = 1, $fn = 24);\n```\n\n----------------------------------------\n\nTITLE: Example Usage of helix_extrude with Shape Points and Upward Spiral\nDESCRIPTION: Demonstrates how to generate a helical extrusion of a specified 2D shape using shape points, with radius set to 40, across 5 levels, spaced 10 units apart, spiraling upward. The example illustrates the function call with specific parameters, showcasing typical usage.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-helix_extrude.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <helix_extrude.scad>\n\nshape_pts = [\n\t[5, -2],\n\t[5, 2], \n\t[4, 2],\n\t[4, 0],\n\t[-4, 0],\n\t[-4, 2],    \n\t[-5, 2],    \n\t[-5, -2]\n];\n\nhelix_extrude(shape_pts, \n\tradius = 40, \n\tlevels = 5, \n\tlevel_dist = 10,\n\tv_dir = \"SPI_UP\"\n);\n```\n\n----------------------------------------\n\nTITLE: Visualizing Delaunay Triangulation and Voronoi Diagram using `tri_delaunay_indices` in OpenSCAD\nDESCRIPTION: This OpenSCAD example demonstrates generating a Delaunay triangulation from random points using `tri_delaunay`. It then uses `tri_delaunay_indices` to retrieve the indices of the triangle vertices, reconstructs the triangles using these indices and the original points, and visualizes them via `linear_extrude` and `polygon`. Additionally, it shows how to use `tri_delaunay_shapes` and `tri_delaunay_voronoi` to visualize the triangle shapes (offset polygons) and the Voronoi diagram (circles at vertices of joined polylines) derived from the same Delaunay object. Required dependencies include various `triangle` library modules and `polyline_join.scad`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-tri_delaunay_indices.md#_snippet_0\n\nLANGUAGE: openscad\nCODE:\n```\n\tuse <triangle/tri_delaunay.scad>\n\tuse <triangle/tri_delaunay_indices.scad>\n\tuse <triangle/tri_delaunay_shapes.scad>\n\tuse <triangle/tri_delaunay_voronoi.scad>\n\tuse <polyline_join.scad>\n\n\tpoints = [for(i = [0:20]) rands(-100, 100, 2)]; \n\n\tdelaunay = tri_delaunay(points, ret = \"DELAUNAY\");\n\n\ttris = [for(ti = tri_delaunay_indices(delaunay)) [for(i = ti) points[i]]];\n\tlinear_extrude(1)\n\tfor(t = tris) {\n\t\tpolygon(t);\n\t}\t\n\n\tcolor(\"black\")\n\tlinear_extrude(2)\n\tfor(t = tri_delaunay_shapes(delaunay)) {\n\t\toffset(-1)\n\t\t\tpolygon(t);\n\t}\t\n\n\tcolor(\"red\")\n\tlinear_extrude(3)\n\tfor(t = tri_delaunay_voronoi(delaunay)) {\n\t\tpolyline_join([each t, t[0]])\n\t\t    circle(1);\n\t}\n```\n\n----------------------------------------\n\nTITLE: Creating a Dodecahedron in OpenSCAD\nDESCRIPTION: This snippet demonstrates how to create multiple dodecahedron objects with varying detail levels in OpenSCAD. It uses the 'dodecahedron' module with parameters for radius and detail, translating each shape along the x-axis. The example illustrates the usage of the module and produces a series of dodecahedra with increasing complexity.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polyhedra_dodecahedron.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyhedra/dodecahedron.scad>\n\nfor(i = [0:5]) {\n\ttranslate([i * 2, 0])\n\t\tdodecahedron(radius = 1, detail = i);\n}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of helix_extrude with Variable Radii and Upward Spiral\nDESCRIPTION: Shows how to create a helical extrusion with a shape defined by points, varying radius from 40 to 20, over 5 levels with 10 units spacing, spiraling upward. It includes a commented-out cylinder for reference and demonstrates parameter customization.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-helix_extrude.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <helix_extrude.scad>\n\nr1 = 40;\nr2 = 20;\nlevels = 5;\nlevel_dist = 10;\n\nshape_pts = [\n\t[10, -2],\n\t[10, 2],\n\t[9, 2],\n\t[9, 0],\n\t[1, 0],\n\t[1, 2],\n\t[0, 2],\n\t[0, -2],\n];\n\nhelix_extrude(shape_pts, \n\tradius = [r1, r2], \n\tlevels = levels, \n\tlevel_dist = level_dist,\n\tv_dir = \"SPI_UP\"\n);\n\n// Optional cylinder for reference\n// cylinder(h = levels * level_dist, r1 = r1, r2 = r2);\n```\n\n----------------------------------------\n\nTITLE: Using hexahedron Module in a Loop - OpenSCAD\nDESCRIPTION: This example demonstrates how to import and use the `hexahedron` module. It creates six hexahedrons arranged in a row, using a loop to vary the `detail` parameter from 0 to 5, illustrating the effect of increasing the detail level on the resulting shape.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polyhedra_hexahedron.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyhedra/hexahedron.scad>\n\nfor(i = [0:5]) {\n\ttranslate([i * 2, 0])\n\t\thexahedron(radius = 1, detail = i);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Voronoi Cells with Specified Size and Grid Width in OpenSCAD\nDESCRIPTION: This snippet defines and uses the function vrn2_cells_space to create Voronoi cell shapes inside a rectangular area defined by the parameter 'size' and grid width 'grid_w'. The function places cell centers randomly within each grid section, enabling seamless Voronoi diagrams if grid width divides size evenly. The snippet also illustrates extrusion and color application to the polygons formed by these cells. Dependencies include 'polyline_join.scad' for polyline merging. Key parameters include 'size' (a two-element array for rectangle dimensions), 'grid_w' (width of the grid sections), and an optional 'seed' for the random number generator to produce repeatable outputs. Outputs are lists of cell points and their polygon vertices suitable for 2D and 3D rendering.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vrn2_cells_space.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline_join.scad>\nuse <voronoi/vrn2_cells_space.scad>\n\nsize = [20, 20];\ngrid_w = 5;\ncells = vrn2_cells_space(size, grid_w);\n\nfor(cell = cells) {\n    cell_pt = cell[0];\n    cell_poly = cell[1];\n\n    linear_extrude(1)\n\tpolyline_join([each cell_poly, cell_poly[0]])\n\t\tcircle(.5);\n    \n    color(rands(0, 1, 3))\n    translate(cell_pt)    \n    linear_extrude(2, scale = 0.8)\n    translate(-cell_pt)    \n        polygon(cell_poly);  \n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Turtle Spiral using t2d with command list\nDESCRIPTION: Alternative implementation of the spiral pattern using the t2d module with a list of commands. This approach demonstrates the fluent API by combining multiple turtle commands in a single call.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-t2d.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <line2d.scad>\nuse <turtle/t2d.scad>\n\nmodule turtle_spiral(t, times, side_leng, angle, width) {\n\t$fn = 24;\n\tif(times != 0) {\n\t\tt1 = t2d(t, [\n\t\t\t[\"turn\", angle],\n\t\t\t[\"forward\", side_leng]\n\t\t]);\n\t\t\n\t\tline2d(\n\t\t\tt2d(t, \"point\"),\n\t\t\tt2d(t1, \"point\"),\n\t\t\twidth,\n\t\t\tp1Style = \"CAP_ROUND\", \n\t\t\tp2Style =  \"CAP_ROUND\"\n\t\t);\n\n\t\tturtle_spiral(t1, times - 1, side_leng, angle, width);\n\t}\n}\n\nturtle_spiral(\n\tt2d(point = [0, 0], angle = 0), \n\ttimes = 5, \n\tside_leng = 10, \n\tangle = 144, \n\twidth = 1\n);\n```\n\n----------------------------------------\n\nTITLE: Basic Path Extrusion with Bezier Curve in OpenSCAD\nDESCRIPTION: Demonstrates the basic usage of `path_extrude` to extrude a solid 2D shape defined by `shape_pts` along a path generated using `bezier_curve`. Requires `path_extrude.scad` and `bezier_curve.scad`. Uses the default `triangles = \"SOLID\"` setting.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-path_extrude.md#_snippet_0\n\nLANGUAGE: openscad\nCODE:\n```\n\tuse <path_extrude.scad>\n\tuse <bezier_curve.scad>\n\n\tt_step = 0.05;\n\twidth = 2;\n\n\tp0 = [0, 0, 0];\n\tp1 = [40, 60, 35];\n\tp2 = [-50, 70, 0];\n\tp3 = [20, 150, -35];\n\tp4 = [30, 50, -3];\n\n\tshape_pts = [   \n\t\t[5, -5],\n\t\t[3, 4],\n\t\t[0, 5],\n\t\t[-5, -5] \n\t];\n\n\tpath_pts = bezier_curve(t_step, \n\t\t[p0, p1, p2, p3, p4]\n\t);\n\n\tpath_extrude(shape_pts, path_pts);\n```\n\n----------------------------------------\n\nTITLE: In-Shape Function to Check Point Inside Shape in OpenSCAD\nDESCRIPTION: Defines a function 'in_shape' that determines if a given point lies inside a shape based on shape points and a tolerance. It supports configurable edge inclusion. Dependencies include other shape or polygon modules, and the function is used to classify points relative to the shape boundary with considerations for rounding errors.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-in_shape.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# in_shape\n\nChecks whether a point is inside a shape.\n\n**Since:** 1.3\n\n## Parameters\n\n- `shapt_pts` : The shape points.\n- `pt` : The point to be checked.\n- `include_edge` : If a point is on the edge of the shape, the function is default to return `false`. If `include_edge` is `true`, the function returns `true`.\n- `epsilon` : An upper bound on the relative error due to rounding in floating point arithmetic. Default to 0.0001.\n\n## Examples\n\n    use <shape_taiwan.scad>\n    use <in_shape.scad>\n\n    points = shape_taiwan(30);\n\n    %polygon(points);\n\n    n = 200;\n    xs = rands(-9, 9, n);\n    ys = rands(-16, 16, n);\n\n    pts = [\n        for(i = [0:n - 1]) \n            let(p = [xs[i], ys[i]]) \n            if(in_shape(points, p, true))\n            p\n        ]; \n\n    for(p = pts) {\n        translate(p) \n            circle(.2); \n    }\n\n![in_shape](images/lib3x-in_shape-1.JPG)\n```\n\n----------------------------------------\n\nTITLE: Creating 3D Spiral with Superformula Cross-section in OpenSCAD\nDESCRIPTION: Shows how to combine shape_superformula with golden_spiral_extrude to create a 3D spiral object. The shape points generated by the Superformula are used as a cross-section profile that is extruded along a golden spiral path.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_superformula.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_superformula.scad> \nuse <golden_spiral_extrude.scad>  \n    \nphi_step = 0.05;\n\nm = 16;\nn = 0.5;\nn3 = 16;\n\nshape_pts = shape_superformula(phi_step, m, m, n, n, n3);\n\ngolden_spiral_extrude(\n    shape_pts, \n    from = 5, \n    to = 10, \n    point_distance = 2,\n    scale = 10\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing a stochastic 2D L-system with probability rules in OpenSCAD\nDESCRIPTION: This snippet implements a stochastic L-system named \"weed\" that generates plant-like fractal structures with probabilistic rule applications. It sets up an initial axiom and a list of production rules with associated probabilities to control randomness in substitutions. The lsystem2 function is called with these parameters, generating varied geometrical patterns on each run unless a seed is fixed. Dependencies include turtle/lsystem2.scad and line2d.scad for L-system interpretation and rendering respectively. The inputs are strings representing symbols, iteration count, angle, length, and rule probabilities, with output being a set of coordinate lines.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-lsystem2.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <turtle/lsystem2.scad>\\nuse <line2d.scad>\\n\\nfor(line = weed()) {\\n\\tline2d(\\n\\t\\tline[0],\\n\\t\\tline[1],\\n\\t\\t.2,\\n\\t\\tp1Style = \"CAP_ROUND\", \\n\\t\\tp2Style =  \"CAP_ROUND\"\\n\\t);\\n}\\n\\nfunction weed(n = 6, angle = 22.5, leng = 1, heading = 0, start = [0, 0]) = \\n\\tlet(\\n\\t\\taxiom = \"F\",\\n\\t\\trules = [\\n\\t\\t\\t[\"F\", \"FF-[XY]+[XY]\"],\\n\\t\\t\\t[\"X\", \"+FY\"],\\n\\t\\t\\t[\"Y\", \"-FX\"]\\n\\t\\t]\\n\\t)\\n\\tlsystem2(axiom, rules, n, angle, leng, heading, start, rule_prs = [0.8, 0.8, 0.8]);\n```\n\n----------------------------------------\n\nTITLE: Converting Cartesian Coordinates to Spherical Coordinates in OpenSCAD\nDESCRIPTION: This code snippet implements a function that converts Cartesian coordinates to spherical coordinates. It requires the input point as a list of three values and returns a list containing radius, theta, and phi. It also includes an example demonstrating how to use the function and validate the output with assertions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-spherical_coordinate.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# spherical_coordinate\n\nConverts from Cartesian to Spherical coordinates (used in mathematics). It returns `[radius, theta, phi]`.\n\n**Since:** 3.0\n\n## Parameters\n\n- `point` : The Cartesian coordinates of a point.\n\n## Examples\n\n    use <util/spherical_coordinate.scad>\n    \n\tcoord = spherical_coordinate([100, 100, 100]);\n\tr = round(coord[0]);\n\ttheta = round(coord[1]);\n\tphi = round(coord[2]);\n    assert([r, theta, phi] == [173, 45, 55]);\n```\n\n----------------------------------------\n\nTITLE: Path Extrusion with Custom Triangles in OpenSCAD\nDESCRIPTION: Illustrates extruding a shape with custom triangulation using `path_extrude`. The `triangles` parameter is provided with explicit indices referencing vertices in `shape_pts` to define the surface mesh. Requires `path_extrude.scad` and `bezier_curve.scad`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-path_extrude.md#_snippet_2\n\nLANGUAGE: openscad\nCODE:\n```\n\tuse <path_extrude.scad>\n\tuse <bezier_curve.scad>\n\t\n\tt_step = 0.05;\n\t\n\tp0 = [0, 0, 0];\n\tp1 = [40, 60, 35];\n\tp2 = [-50, 70, 0];\n\tp3 = [20, 150, -5];\n\tp4 = [50, 50, -3];\n\t\n\tshape_pts = [\n\t    // outer\n        [10, 0],\n        [-5, 10],\n\t    [-10, 0],\n\t    // inner\n        [7, 1],\n        [-4, 8],\n\t    [-7, 1]\n\t];\n\t\n\tpath_pts = bezier_curve(t_step, \n\t    [p0, p1, p2, p3, p4]\n\t);\n\t\n\tpath_extrude(\n\t    shape_pts, \n\t    path_pts, \t   \n\t    triangles = [\n            [0, 4, 3],\n            [0, 1, 4],\n            [1, 5, 4],\n            [1, 2, 5],\n            [2, 3, 5],\n            [2, 0, 3]\n        ]\n\t);\n```\n\n----------------------------------------\n\nTITLE: Documentation for shuffle(list, seed) function in OpenSCAD\nDESCRIPTION: This snippet documents the shuffle function that randomizes the order of elements in a list. It specifies the required parameters, lt (the list to shuffle) and seed (the random seed), and provides an example usage. The purpose of this utility is to facilitate randomized ordering in OpenSCAD scripts.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shuffle.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# shuffle\n\nRandomizes the order of the elements of a list.\n\n**Since:** 3.0\n\n## Parameters\n\n- `lt` : The list to shuffle.\n- `seed` : Random seed value.\n\n## Examples\n\n    use <util/shuffle.scad>\n    \n    echo(shuffle([1, 2, 3, 4]));\n```\n\n----------------------------------------\n\nTITLE: Rendering and Transforming a Grid of Spheres in OpenSCAD\nDESCRIPTION: This snippet iterates over a provided list of points (possibly generated by manipulating a nested matrix array) and renders spheres of radius 0.5 at each translated location using the translate and sphere primitives in OpenSCAD. Prerequisites include defining 'pts' as a list of 3D coordinates beforehand, and optionally setting sphere resolution with the $fn parameter. Inputs are expected as array-like point data; it outputs the visual representation of spheres at those coordinates. Limitations include the requirement that 'pts' is defined in a compatible format and that OpenSCAD primitives are available.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_from.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nfor(pt = pts) {\n    translate(pt) sphere(.5, $fn = 24);\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting element from OpenSCAD Hashset\nDESCRIPTION: This OpenSCAD snippet demonstrates how to use the `hashset_del` function. It first creates a hash set, then calls `hashset_del` to create a new set with a specific element removed, and finally uses `hashset_has` to assert that the element is no longer present in the new set. It requires `use` statements for the necessary hashset modules.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-hashset_del.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/set/hashset.scad>;\nuse <util/set/hashset_del.scad>;\nuse <util/set/hashset_has.scad>;\n\ns1 = hashset([1, 2, 3, 4, 5]);\ns2 = hashset_del(s1, 3);\nassert(!hashset_has(s2, 3));\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Square Maze Cell Constants in OpenSCAD\nDESCRIPTION: Declares constant values used to represent the wall and mask states of maze cells in OpenSCAD. These constants (NO_WALL, TOP_WALL, RIGHT_WALL, TOP_RIGHT_WALL, MASK) simplify code readability and maintenance by assigning clear integer values to structural features. They are used both to define and interpret the third element of each cell data array.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-mz_square_cells.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nNO_WALL = 0;          // the cell has no wall\nTOP_WALL = 1;         // the cell has a top wall\nRIGHT_WALL = 2;       // the cell has a right wall\nTOP_RIGHT_WALL = 3;   // the cell has a top wall and a right wall\nMASK = 4;             // the cell is masked.\n```\n\n----------------------------------------\n\nTITLE: Generating Rotated Point Arrays with ptf_rotate in OpenSCAD\nDESCRIPTION: This code creates a series of rotated 3D points along a parametric path using ptf_rotate. Each point is generated by rotating an initial vector with angles derived from the loop variable for progressive placement. The snippet requires ptf_rotate.scad and uses for comprehensions and array math to build points, then iterates through them to position multiple spheres, optionally displaying the base sphere for reference.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-ptf_rotate.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <ptf/ptf_rotate.scad>\n\nradius = 40;\nstep_angle = 10;\nz_circles = 20;\n\npoints = [for(a = [0:step_angle:90 * z_circles]) \n    ptf_rotate(\n        [radius, 0, 0], \n        [0, -90 + 2 * a / z_circles, a]\n    )\n];\n\nfor(p = points) {\n    translate(p) \n        sphere(1);\n}\n\n%sphere(radius);\n```\n\n----------------------------------------\n\nTITLE: Using ptf_rotate for Coordinate Axis Rotation in OpenSCAD\nDESCRIPTION: This snippet demonstrates how to rotate a given 3D point with ptf_rotate, mirroring the behavior of the standard rotate module in OpenSCAD. The a parameter specifies rotation degrees for each axis, and the rotated point is used in translation and combined with explicit rotate for visualizing resulting geometry. Requires inclusion of ptf_rotate.scad, and expects points and angles as arrays. Resulting output is displayed using hull() and translated spheres.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-ptf_rotate.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <ptf/ptf_rotate.scad>\n\npoint = [20, 0, 0];\na = [0, -45, 45];\n\nhull() {\n    sphere(1);\n    translate(ptf_rotate(point, a))    \n\trotate(a)  \n\t\tsphere(1);   \n}  \n```\n\n----------------------------------------\n\nTITLE: Creating a 3D Surface with sf_square in OpenSCAD\nDESCRIPTION: This code imports the sf_square module and uses it to create a 3D surface based on a grayscale height map. The surface parameters include thickness, depth, x and y twist angles, and a large 2D array of height values that define the surface geometry.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_square.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <surface/sf_square.scad>\n\nthicnkess = 10;\ndepth = 5;\nx_twist = 90;\ny_twist = 90;\ninvert = false;\nlevels = [\n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 180, 219, 255, 255, 224, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 85, 62, 173, 255, 255, 222, 154, 168, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 147, 16, 73, 166, 190, 8, 17, 99, 97, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 151, 11, 26, 153, 111, 61, 58, 40, 128, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]\n```\n\n----------------------------------------\n\nTITLE: Defining the 'pie' module in OpenSCAD\nDESCRIPTION: This snippet defines the 'pie' module for creating pie or circular sector shapes in OpenSCAD. It accepts parameters such as radius, angle, and optional polygon resolution parameters ($fa, $fs, $fn). Dependencies include the circle module from OpenSCAD. The module computes a sector of a circle based on the provided angles and radius, allowing customization of the shape's detail level.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-pie.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# pie\n\nCreates a pie (circular sector). Its `$fa`, `$fs` and `$fn` are consistent with the `circle` module.\n\n## Parameters\n\n- `radius` : The radius of the circle.\n- `angle` : A single value or a 2 element vector which defines the central angle. The first element of the vector is the beginning angle in degrees, and the second element is the ending angle.\n- `$fa`, `$fs`, `$fn` : Check [the circle module](https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Using_the_2D_Subsystem#circle) for more details.\n\n## Examples\n\n    use <pie.scad>\n\n    pie(radius = 20, angle = [210, 310]);   \n    translate([-15, 0, 0]) \n        pie(radius = 20, angle = [45, 135]);  \n    translate([15, 0, 0]) \n        pie(radius = 20, angle = [45, 135], $fn = 12);  \n\n![pie](images/lib3x-pie-1.JPG)\n```\n\n----------------------------------------\n\nTITLE: Calculating Hashmap Length using hashmap_len in OpenSCAD\nDESCRIPTION: This code snippet defines a hashmap with three key-value pairs and uses the 'hashmap_len' function to determine its size. It demonstrates the process of importing the hashmap library, creating a hashmap, and asserting the expected length. Dependencies include the util/map/hashmap library; the main function 'hashmap_len' takes a hashmap as input and returns its entry count.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-hashmap_len.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/map/hashmap.scad>\nuse <util/map/hashmap_len.scad>\n\nm = hashmap([[\"k1\", 10], [\"k2\", 20], [\"k3\", 30]]);\nassert(hashmap_len(m) == 3);\n```\n\n----------------------------------------\n\nTITLE: Transforming and Rendering Rectangular Grid to Ring Using ptf_ring in OpenSCAD\nDESCRIPTION: This OpenSCAD snippet demonstrates how to use the ptf_ring function to transform points from a rectangular grid (defined by the size array) into a ring shape, applying a twist for added effect. It shows how to prepare rows and columns of points, apply the transformation with specified radius, angle, and twist, and render the results using polyline_join and sphere for visualization. Required dependencies are polyline_join.scad and ptf/ptf_ring.scad. Inputs include the rectangle size, radius, central angle, and twist amount. Outputs are the constructed 3D ring/tile structures.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-ptf_ring.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline_join.scad>\nuse <ptf/ptf_ring.scad>\n\nsize = [20, 10];\nradius = 5;\n\nrows = [\n    for(y = [0:size.y])\n        [for(x = [0:size.x]) [x, y]]\n];\n\ncolumns = [\n    for(x = [0:size.x])\n        [for(y = [0:size.y]) [x, y]]\n];\n\nfor(line = rows) {\n    transformed = [for(p = line) ptf_ring(size, p, radius, 360, 180)];\n\tpolyline_join(transformed)\n\t    sphere(.25);\n}\n\nfor(line = columns) {\n    transformed = [for(p = line) ptf_ring(size, p, radius, 360, 180)];\n\tpolyline_join(transformed)\n\t    sphere(.25);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic 3D Line in OpenSCAD\nDESCRIPTION: Creates a 3D line from point [0,0,0] to [10,2,10] with a diameter of 1 and default circle end-caps. Uses $fn=24 for smoother circular resolution.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-line3d.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <line3d.scad>\n\nline3d(\n    p1 = [0, 0, 0], \n    p2 = [10, 2, 10], \n    diameter = 1,\n    $fn = 24\n);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Hashmap Entries in OpenSCAD\nDESCRIPTION: This code snippet demonstrates the usage of the `hashmap_entries` function to retrieve all key-value pairs stored within a hashmap.  It initializes a hashmap with some key-value pairs and then calls the `hashmap_entries` function. The expected output is a list of `[key, value]` pairs. The example uses external libraries for hashmap creation.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-hashmap_entries.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/map/hashmap.scad>\nuse <util/map/hashmap_entries.scad>\n\nm = hashmap([[\"k1\", 10], [\"k2\", 20], [\"k3\", 30]]);\necho(hashmap_entries(m));    // a list contains [\"k1\", 10], [\"k2\", 20], [\"k3\", 30]\n```\n\n----------------------------------------\n\nTITLE: Linear Interpolation Example (lerp)\nDESCRIPTION: Demonstrates the use of the `lerp` function to linearly interpolate between two 3D vectors. The `assert` statement verifies the correct interpolation result for an amount of 0.5.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-lerp.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/lerp.scad>\n\nassert(lerp([0, 0, 0], [100, 100, 100], 0.5) == [50, 50, 50]);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating `tetrahedron` module usage with varying detail in OpenSCAD\nDESCRIPTION: This example code snippet shows how to include the `tetrahedron.scad` library using the `use` statement and then utilizes a `for` loop to instantiate the `tetrahedron` module multiple times. Each instance is translated to a different position and rendered with an incrementally increasing `detail` parameter to demonstrate its effect.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polyhedra_tetrahedron.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyhedra/tetrahedron.scad>\n\n\tfor(i = [0:5]) {\n\t\ttranslate([i * 2, 0])\n\t\t\ttetrahedron(radius = 1, detail = i);\n\t}\n```\n\n----------------------------------------\n\nTITLE: Smoothing an Open 3D Path with bezier_smooth in OpenSCAD\nDESCRIPTION: This example demonstrates using `bezier_smooth` to smooth an open 3D path defined by `path_pts`. It requires `polyline_join.scad` and `bezier_smooth.scad`. The original path is visualized using `polyline_join` with spheres, and the smoothed path, generated by `bezier_smooth` with a specified `round_d`, is displayed alongside in red, also using `polyline_join`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-bezier_smooth.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n\tuse <polyline_join.scad>\n\tuse <bezier_smooth.scad>\n\n\twidth = 2;\n\tround_d = 15;\n\n\tpath_pts = [\n\t\t[0, 0, 0],\n\t\t[40, 60, 10],\n\t\t[-50, 90, 30],\n\t\t[-10, -10, 50]\n\t];\n\n\tpolyline_join(path_pts)\n\t    sphere(width / 2);\n\n\tsmoothed_path_pts = bezier_smooth(path_pts, round_d);\n\n\tcolor(\"red\") \n\ttranslate([30, 0, 0]) \n\tpolyline_join(smoothed_path_pts) \n\t    sphere(width / 2);\n```\n\n----------------------------------------\n\nTITLE: Path Extrusion with AXIS_ANGLE on Vertical Path in OpenSCAD\nDESCRIPTION: Demonstrates that the default `AXIS_ANGLE` method in `path_extrude` handles near-vertical paths correctly, avoiding the abrupt twist seen with `EULER_ANGLE`. Requires `path_extrude.scad`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-path_extrude.md#_snippet_7\n\nLANGUAGE: openscad\nCODE:\n```\n\tuse <path_extrude.scad>\n\n\tshape_pts = [[5, -5], [5, 5], [-5, 5], [-5, -5]];\n\n\tpath_pts = [\n\t\t[20, 20, 0], \n\t\t[18.2, 18.2, 2], \n\t\t[16.8, 16.8, 4], \n\t\t[15.8, 15.8, 6], \n\t\t[15.2, 15.2, 8], \n\t\t[15, 15, 10], \n\t\t[15.2, 15.2, 12], \n\t\t[15.8, 15.8, 14], \n\t\t[16.8, 16.8, 16], \n\t\t[18.2, 18.2, 18], \n\t\t[20, 20, 20]\n\t];\n\n\tpath_extrude(shape_pts, path_pts, method = \"AXIS_ANGLE\");\n```\n\n----------------------------------------\n\nTITLE: Retrieving a value from a hashmap using hashmap_get in OpenSCAD\nDESCRIPTION: This example demonstrates how to use the hashmap_get function to retrieve a value from a hashmap by its key. It creates a hashmap with three key-value pairs and then retrieves the value for key 'k2'.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-hashmap_get.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/map/hashmap.scad>\nuse <util/map/hashmap_get.scad>\n\nm = hashmap([[\"k1\", 10], [\"k2\", 20], [\"k3\", 30]]);\nassert(hashmap_get(m, \"k2\") == 20);\n```\n\n----------------------------------------\n\nTITLE: Triangle Subdivision in OpenSCAD\nDESCRIPTION: Subdivides a triangle n times, useful for creating more detailed triangular meshes.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/RELEASE.md#_snippet_5\n\nLANGUAGE: OpenSCAD\nCODE:\n```\ninclude <dotscad/triangle/tri_subdivide.scad>\n\n// Example usage:\ntriangle_points = [[0, 0], [10, 0], [5, 8.66]];\nsubdivided = tri_subdivide(triangle_points, n=2);\n// Returns points of the subdivided triangle\n```\n\n----------------------------------------\n\nTITLE: Creating Generalized Spline Surface from Control Points in OpenSCAD\nDESCRIPTION: Generates a surface based on control points with options for row and column splines, allowing complex freeform surface modeling. Requires surface library functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_32\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nsurface/sf_splines(ctrl_pts, row_spline, column_spline)\n```\n\n----------------------------------------\n\nTITLE: Drawing an Outline Voxel Circle in OpenSCAD\nDESCRIPTION: Creates an outline voxel-style circle with a radius of 10 units by placing squares at each point returned by vx_circle(). Each square represents one voxel of the circle outline.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_circle.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voxel/vx_circle.scad>\n\nfor(pt = vx_circle(10)) {\n\ttranslate(pt)\n\t\tsquare(1, center = true);\n}\n```\n\n----------------------------------------\n\nTITLE: Modeling from Image Binary Data OpenSCAD\nDESCRIPTION: This OpenSCAD code snippet utilizes the `vx_from` function, but this time the array data passed to it is far larger, showing more complex shapes could be modeled using the method. It also implies that an external tool, like img2binary, could be used to build this binary data from an image, making it easier to convert images into models.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_from.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voxel/vx_from.scad>\n\npts = vx_from([\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],\n    [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1],\n    [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1],\n    [1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1],\n    [1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1],\n    [1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1],\n    [1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n]);\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of shape_cyclicpolygon in OpenSCAD\nDESCRIPTION: This example demonstrates creating multiple cyclic polygons with different numbers of sides. It creates two rows of shapes with varying side counts (3-5 and 4-6), each having the same circle radius and corner radius.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_cyclicpolygon.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_cyclicpolygon.scad>\n\ncircle_r = 10;\ncorner_r = 3;\n\n$fn = 24;\n\nfor(i = [0:2]) {\n    translate([i * circle_r * 2, 0, 0]) \n        polygon(\n            shape_cyclicpolygon(\n                sides = 3 + i, \n                circle_r = circle_r, \n                corner_r = corner_r\n            )\n        );\n}\n\nfor(i = [0:2]) {\n    translate([i * circle_r * 2, -circle_r * 2, 0]) \n        polygon(\n            shape_cyclicpolygon(\n                sides = 4 + i, \n                circle_r = circle_r , \n                corner_r = corner_r\n            )\n        );\n}\n```\n\n----------------------------------------\n\nTITLE: Rotating Points Around an Arbitrary Axis Using m_rotation\nDESCRIPTION: This example shows how to rotate a point around an arbitrary axis using m_rotation. It creates points in a circular pattern around the vector [10, 10, 10] by applying rotations at 20-degree intervals from 0 to 340 degrees.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-m_rotation.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <matrix/m_rotation.scad>\n\nv = [10, 10, 10];\n\nhull() {\n\tsphere(1);\n\ttranslate(v)\n\t    sphere(1);   \n}\n\np = [10, 10, 0];\nfor(i = [0:20:340]) {\n\tmultmatrix(m_rotation(a = i, v = v))\n\ttranslate(p) \n\t\tsphere(1);  \n}\n```\n\n----------------------------------------\n\nTITLE: Generating Surface Torus Model with sf_torus.scad in OpenSCAD\nDESCRIPTION: This OpenSCAD code snippet demonstrates the import and usage of the sf_torus.scad surface module to create a torus geometry. It defines key parameters such as radius (an array of the major and minor radii), thickness, depth, angle (an array specifying angular extents), twist (defining a twist angle), and invert (a boolean flag to invert geometry). The levels parameter is a nested array that represents detailed surface characteristics, possibly controlling the resolution or coloring applied to the torus surface. The snippet requires the sf_torus.scad file to be accessible and expects these parameters to control the torus shape's size, complexity, and visual features, outputting a parametric 3D model.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_torus.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n// The code of the above picture.\nuse <surface/sf_torus.scad>\n\nradius = [100, 50];\nthickness = 10;\ndepth = 5;\nangle = [90, 180];\ntwist = -90;\ninvert = false;\nlevels = [\n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 180, 219, 255, 255, 224, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 85, 62, 173, 255, 255, 222, 154, 168, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 147, 16, 73, 166, 190, 8, 17, 99, 97, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 151, 11, 26, 153, 111, 61, 58, 40, 128, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 137, 73, 74, 154, 131, 24, 18, 95, 192, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 217, 153, 162, 152, 97, 82, 120, 155, 66, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 194, 146, 146, 131, 118, 96, 75, 46, 46, 191, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 185, 139, 130, 117, 99, 78, 53, 38, 64, 168, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 194, 108, 102, 95, 74, 60, 38, 47, 89, 85, 153, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 101, 77, 67, 52, 38, 48, 82, 109, 73, 48, 222, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 225, 70, 40, 42, 57, 84, 107, 92, 62, 38, 164, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 215, 100, 89, 102, 115, 91, 72, 44, 47, 105, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n    [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 112, 114, 102, 86, 68, 51, 41, 66, 101, 94, 140, 194, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]\n]\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of rails2sections with Static Rails in OpenSCAD\nDESCRIPTION: Defines four rails as lists of 3D points, then uses the `rails2sections` module to generate cross-sections along these rails. The resulting sections are passed to the `sweep` module to create a 3D model. It also includes code to visualize the original rails using `polyline_join`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-rails2sections.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <rails2sections.scad>\nuse <polyline_join.scad>\nuse <sweep.scad>\n\nrails = [\n    [[5, 0, 5], [15, 10, 10], [25, 20, 5]],\n    [[-5, 0, 5], [-15, 10, 10], [-25, 20, 5]],\n    [[-5, 0, -5], [-15, 10, -10], [-25, 20, -5]],  \n    [[5, 0, -5], [15, 10, -10], [25, 20, -5]]\n];\n\nsections = rails2sections(rails);\n\nsweep(sections);\n\n#for(path = rails) {\n    polyline_join(path)\n\t    sphere(.25);\n}\n```\n\n----------------------------------------\n\nTITLE: Extruding Rectangular Shape along Golden Spiral (OpenSCAD)\nDESCRIPTION: This OpenSCAD snippet demonstrates the use of the `golden_spiral_extrude` module. It defines a rectangular 2D shape using a list of points and extrudes it along a clockwise golden spiral path. Key parameters like start/end Fibonacci numbers (`from`/`to`), `point_distance`, `rt_dir` (clockwise), `twist`, and `scale` are configured. This requires the `golden_spiral_extrude.scad` module.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-golden_spiral_extrude.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <golden_spiral_extrude.scad>\n\nshape_pts = [\n\t\t[2, -10],\n\t\t[2, 10],\n\t\t[-2, 10],\n\t\t[-2, -10]\n\t];\n\ngolden_spiral_extrude(\n\t\tshape_pts,\n\t\tfrom = 3,\n\t\tto = 10,\n\t\tpoint_distance = 1,\n\t\trt_dir = \"CLK\",\n\t\ttwist = 180,\n\t\tscale = 0.1\n\t);\n```\n\n----------------------------------------\n\nTITLE: Sampling Multiple 2D Perlin Noise Values in OpenSCAD\nDESCRIPTION: Generates an array of Perlin noise values at multiple (x, y) points, enabling complex procedural textures. Uses noise library functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_40\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nnoise/nz_perlin2s(points[, seed])\n```\n\n----------------------------------------\n\nTITLE: Extruding Heart with ellipse_extrude and Mirror - OpenSCAD\nDESCRIPTION: This OpenSCAD snippet illustrates how to extrude a heart shape using `ellipse_extrude`.  The code defines `semi_minor_axis` and uses `ellipse_extrude` to extrude the heart symbol, placing it within the extruded path.  A mirrored copy is also created using the `mirror()` function, mirroring the extruded heart across the Z-axis.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-ellipse_extrude.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <ellipse_extrude.scad>\n\n\tsemi_minor_axis = 5;\n\t \n\tellipse_extrude(semi_minor_axis) \n\t    text(\"♥\", size = 40, valign = \"center\", halign = \"center\");\n\t\t\n\tmirror([0, 0, 1]) \n\tellipse_extrude(semi_minor_axis) \n\t    text(\"♥\", size = 40, valign = \"center\", halign = \"center\");\n```\n\n----------------------------------------\n\nTITLE: Generating Fibonacci Lattice Points on a Sphere in OpenSCAD\nDESCRIPTION: This code generates 'n' evenly spaced points on the surface of a sphere with a specified radius using the Fibonacci lattice algorithm. Parameters include the number of points, sphere radius, and direction of point ordering. The snippet primarily provides the function for point calculation and usage examples, with dependencies on the 'fibonacci_lattice.scad' library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-fibonacci_lattice.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nn = 200;\nradius = 20;\npts = fibonacci_lattice(n, radius);\n\nfor(p = pts) {\n    translate(p)\n        sphere(1);\n}\n\nsphere(radius);\n```\n\n----------------------------------------\n\nTITLE: Creating a Small Sphere in OpenSCAD\nDESCRIPTION: Creates a simple sphere with a radius of 2.5 units using the `sphere()` function. The preceding commented-out line `#polyline_join(curve_path)` suggests this sphere might be intended as a marker or visualization aid, possibly related to the points of the `curve_path`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_curve.md#_snippet_2\n\nLANGUAGE: openscad\nCODE:\n```\n#polyline_join(curve_path)\n\tsphere(2.5);\n```\n\n----------------------------------------\n\nTITLE: Defining Multi-dimensional Array for Image Pixel Data in JavaScript\nDESCRIPTION: This snippet initializes a JavaScript variable as a two-dimensional array containing numeric pixel data. Each inner array represents a row of pixel intensity values, potentially corresponding to color channel values (e.g., RGBA) for an image. The data consists of integers ranging from 0 to 255 and appears to be formatted as raw pixel values for further processing or rendering within a graphical or canvas-based context. There are no explicit dependencies, but this raw data likely requires interpretation by image processing or visualization code to be useful. Input consists of arrays of integers, output depends on usage context; the snippet itself only declares the data structure.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_square.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n[        [255, 255, 255, 226, 228, 227, 224, 222, 216, 209, 204, 196, 185, 174, 163, 153, 134, 115, 151, 255, 209, 157, 103, 67, 216, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 228, 217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 94, 0, 1, 2, 0, 3, 1, 0, 2, 0, 1, 1, 25, 220, 255, 203, 147, 63, 7, 0, 1, 2, 8, 35, 198, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],         [255, 255, 255, 215, 211, 211, 203, 209, 202, 196, 188, 178, 172, 165, 150, 138, 125, 105, 151, 255, 184, 133, 86, 66, 156, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 91, 5, 0, 0, 5, 2, 2, 5, 0, 0, 5, 0, 42, 255, 255, 200, 134, 46, 0, 2, 3, 2, 49, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],         [255, 255, 255, 194, 182, 172, 197, 193, 185, 185, 174, 169, 161, 149, 145, 126, 114, 94, 131, 200, 162, 118, 79, 68, 129, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 93, 0, 0, 0, 3, 0, 0, 0, 2, 6, 0, 4, 52, 206, 210, 176, 98, 19, 5, 3, 0, 53, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],         [255, 255, 255, 198, 111, 36, 182, 173, 177, 163, 164, 157, 143, 135, 129, 112, 101, 83, 82, 177, 135, 97, 62, 84, 138, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 162, 0, 1, 3, 0, 1, 5, 0, 0, 4, 2, 2, 60, 141, 158, 129, 86, 2, 0, 6, 74, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],         [255, 255, 255, 229, 143, 2, 165, 165, 159, 152, 63, 61, 135, 123, 115, 104, 89, 70, 59, 128, 113, 79, 66, 103, 160, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 196, 8, 0, 0, 1, 2, 0, 4, 5, 0, 1, 0, 48, 124, 81, 88, 45, 5, 3, 105, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],         [255, 255, 255, 255, 164, 7, 111, 147, 146, 140, 41, 28, 123, 112, 99, 87, 75, 60, 63, 87, 89, 65, 80, 131, 210, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 73, 2, 2, 0, 3, 0, 0, 2, 0, 3, 0, 38, 149, 142, 74, 0, 0, 103, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],         [255, 255, 255, 255, 255, 44, 60, 132, 126, 129, 43, 11, 103, 96, 90, 73, 61, 62, 71, 100, 90, 93, 128, 192, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 107, 46, 11, 0, 2, 4, 0, 0, 1, 2, 8, 100, 50, 5, 14, 136, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],         [255, 255, 255, 255, 255, 147, 21, 115, 114, 106, 64, 3, 71, 83, 70, 58, 56, 73, 92, 112, 144, 177, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 188, 118, 56, 17, 6, 2, 10, 0, 3, 3, 11, 169, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],         [255, 255, 255, 255, 255, 255, 48, 68, 95, 94, 72, 2, 33, 68, 53, 64, 73, 91, 114, 136, 163, 211, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 186, 127, 58, 8, 2, 25, 169, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],         [255, 255, 255, 255, 255, 255, 210, 102, 76, 69, 67, 12, 14, 53, 67, 77, 89, 108, 138, 158, 206, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 204, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],         [255, 255, 255, 255, 255, 255, 255, 255, 229, 139, 79, 57, 0, 58, 90, 102, 116, 140, 158, 212, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],         [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 228, 169, 135, 124, 128, 136, 167, 198, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],         [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],         [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],         [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],         [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]    ];\n```\n\n----------------------------------------\n\nTITLE: Using shape_path_extend with Archimedean Spiral in OpenSCAD\nDESCRIPTION: Shows how to extend a triangular stroke along an Archimedean spiral path. The example creates a spiral shape with triangular protrusions using the archimedean_spiral function to generate path points.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_path_extend.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nstroke2 = [[-4, 0], [0, 4], [4, 0]];\npts_angles = archimedean_spiral(\n    arm_distance = 17,\n    init_angle = 180,\n    point_distance = 5,\n    num_of_points = 85 \n); \n\ntranslate([120, 0, 0]) \n    polygon(\n        shape_path_extend(\n            stroke2, \n            [for(pa = pts_angles) pa[0]]\n        )\n    );\n```\n\n----------------------------------------\n\nTITLE: Using find_index in OpenSCAD\nDESCRIPTION: This code snippet demonstrates how to use the `find_index` function. It imports the `find_index.scad` file and then uses the `find_index` function to find the index of the first element in a list that is greater than 10. It asserts that the returned index is 1. The `find_index` function requires a list and a testing function as input and returns the index or -1.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-find_index.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/find_index.scad>\n\nassert(find_index([10, 20, 30, 40], function(e) e > 10) == 1);\n```\n\n----------------------------------------\n\nTITLE: Checking Point Position on Polyline Using OpenSCAD\nDESCRIPTION: This snippet defines the usage of the in_polyline function from the in_polyline.scad module, which checks whether a given point lies on a polyline defined by a series of points. The function accepts three parameters: 'line_pts' representing the polyline vertices, 'pt' as the test point, and an optional 'epsilon' for floating point tolerance defaulting to 0.0001. It returns a boolean indicating if the point lies on any segment of the polyline. The snippet includes examples of assertions to verify points lying on or off the polyline in both 2D and 3D spaces.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-in_polyline.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <in_polyline.scad>\\n\\npts = [\\n    [0, 0],\\n    [10, 0],\\n    [10, 10]\\n];\\n\\nassert(!in_polyline(pts, [-2, -3])); \\nassert(in_polyline(pts, [5, 0]));    \\nassert(in_polyline(pts, [10, 5]));   \\nassert(!in_polyline(pts, [10, 15]));\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <in_polyline.scad>\\n\\npts = [\\n    [10, 0, 10],\\n    [20, 0, 10],\\n    [20, 10, 10]\\n]; \\n\\nassert(in_polyline(pts, [10, 0, 10]));  \\nassert(in_polyline(pts, [15, 0, 10]));  \\nassert(!in_polyline(pts, [15, 1, 10])); \\nassert(!in_polyline(pts, [20, 11, 10]));\n```\n\n----------------------------------------\n\nTITLE: Using tri_ear_clipping with TRI_SHAPES return type in OpenSCAD\nDESCRIPTION: Example showing how to triangulate a 2D shape and visualize the result by getting triangle shapes directly. The function returns the actual triangle coordinates which can be used directly with the polygon function.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-tri_ear_clipping.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <triangle/tri_ear_clipping.scad> \n\nshape = [\n    [0, 0],\n    [10, 0],\n    [12, 5],\n    [5, 10],\n    [10, 15],\n    [0, 20],\n    [-5, 18],\n    [-18, 3],\n    [-4, 10]\n];\n\ntris = tri_ear_clipping(shape, ret = \"TRI_SHAPES\");\n\nfor(tri = tris) {\n    offset(-.1)\n        polygon(tri);\n}\n```\n\n----------------------------------------\n\nTITLE: Using radians function in OpenSCAD\nDESCRIPTION: This code snippet demonstrates how to use the radians function in OpenSCAD. It includes the radians.scad file and then asserts that the result of converting 180 degrees to radians equals PI.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-radians.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/radians.scad>\n\nassert(radians(180) == PI);\n```\n\n----------------------------------------\n\nTITLE: Using Hexagon Module with Different Levels in OpenSCAD\nDESCRIPTION: This snippet demonstrates how to utilize the hexagons module in OpenSCAD with specified parameters for radius, spacing, and levels. It shows two examples with varying levels to generate layered hexagon patterns, which are visualized with embedded images. The snippets assume the presence of the 'hexagons.scad' module and set parameters before calling the function.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-hexagons.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nradius = 20;\nspacing = 2;\nlevels = 2;\n\nhexagons(radius, spacing, levels);\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nradius = 20;\nspacing = 2;\nlevels = 3;\n\nhexagons(radius, spacing, levels);\n```\n\n----------------------------------------\n\nTITLE: Example Usage of star() Function in OpenSCAD\nDESCRIPTION: This code snippet demonstrates how to generate multiple star shapes by iterating over a range of point counts from 3 to 6, translating each star into different positions along the x-axis. It includes an example of how to call the star() module with a varying 'n' parameter to produce different polygons, useful for visual analysis or design variations.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polyhedra_star.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyhedra/star.scad>\n\nfor(i = [3:6]) {\n\ttranslate([(i - 3) * 2, 0])\n\t\tstar(n = i);\n}\n```\n\n----------------------------------------\n\nTITLE: Curve Drawing Function Using Centripetal Catmull-Rom Spline in OpenSCAD\nDESCRIPTION: Defines a function that draws a smooth, curved line from a set of control points using the Centripetal Catmull-Rom spline algorithm. It accepts parameters for step size (t_step), control points, and tightness to adjust the curve's shape and smoothness. The implementation is suitable for 3D modeling and visualization where precise control of curves is required.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-curve.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# curve\n\n// Draws a smooth curve based on control points using Centripetal Catmull-Rom spline\n// Parameters:\n// t_step: float (0 to 1), controls the sampling distance between points\n// points: list of [x, y] or [x, y, z], control points\n// tightness: float, adjusts the tightness of the curve (0 to 1), default 0.0\n// Note: The curve connects from the 2nd to the second-last control point\n\ndef curve(t_step=0.05, points=[], tightness=0):\n    // Implementation details would go here\n    // This placeholder represents the core function logic\n    // Actual code is not provided in the snippet\n    // Usually involves calculating spline points and drawing lines between them\n\n```\n\n----------------------------------------\n\nTITLE: Sorting a List of Strings in Descending Order in OpenSCAD\nDESCRIPTION: This snippet demonstrates sorting a list of strings in descending order. The `reverse` parameter is set to `true` to achieve reverse sorting.  The assertion checks for correctness against the expected outcome.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sorted.md#_snippet_4\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nassert([\"x\", \"m\", \"d\", \"c\", \"b\"] == sorted([\"x\", \"c\", \"b\", \"d\", \"m\"], reverse = true));\n```\n\n----------------------------------------\n\nTITLE: Defining and Visualizing Bijection Offset in OpenSCAD\nDESCRIPTION: This snippet demonstrates how to apply the bijection_offset function to a simple convex polygon and visualize the offset shapes with different colors for positive and negative offset values. It showcases the basic usage of the function with a set of shape points, providing visual insights into shape dilation or contraction.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-bijection_offset.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# bijection_offset\n\nMove 2D outlines outward or inward by a given amount. Each point of the offsetted shape is paired with exactly one point of the original shape.\n\n**Since:** 1.2.\n\n## Parameters\n\n- `pts` : Points of a shape.\n- `d` : Amount to offset the shape. When negative, the shape is offset inwards. \n- `epsilon` : An upper bound on the relative error due to rounding in floating point arithmetic. Default to 0.0001. **Since:** 1.3.\n\n## Examples\n\n\tuse <bijection_offset.scad>\n\n\tshape = [\n\t\t[15, 0],\n\t\t[15, 30],\n\t\t[0, 20],\n\t\t[-15, 40],\n\t\t[-15, 0]\n\t];\n\n\tcolor(\"red\")    polygon(bijection_offset(shape, 3));\n\tcolor(\"orange\") polygon(bijection_offset(shape, 2));\n\tcolor(\"yellow\") polygon(bijection_offset(shape, 1));\n\tcolor(\"green\")  polygon(shape);\n\tcolor(\"blue\")   polygon(bijection_offset(shape, -1));\n\tcolor(\"indigo\") polygon(bijection_offset(shape, -2));\n\tcolor(\"purple\") polygon(bijection_offset(shape, -3));\n\n![bijection_offset](images/lib3x-bijection_offset-1.JPG)\n\nuse <bijection_offset.scad>\nuse <path_extrude.scad>\nuse <bezier_curve.scad>\n\nshape = [\n\t[5, 0],\n\t[3, 9],\n\t[0, 10],    \n\t[-5, 0]\n];\noffsetted = bijection_offset(shape, 1);\noffsetted2 = bijection_offset(shape, 2);\noffsetted3 = bijection_offset(shape, 3);\n\n\nt_step = 0.05;\n\n\tp0 = [0, 0, 0];\n\tp1 = [40, 60, 35];\n\tp2 = [-50, 70, 0];\n\tp3 = [20, 150, -35];\n\tp4 = [30, 50, -3];\n\n\tpath_pts = bezier_curve(t_step, \n\t\t[p0, p1, p2, p3, p4]\n\t);\n\n\tpath_extrude(concat(offsetted, shape), path_pts, \"HOLLOW\");\n\tpath_extrude(concat(offsetted3, offsetted2), path_pts, \"HOLLOW\");\n\n![bijection_offset](images/lib3x-bijection_offset-2.JPG)\n```\n\n----------------------------------------\n\nTITLE: Using tri_ear_clipping with TRI_INDICES return type in OpenSCAD\nDESCRIPTION: Example showing how to triangulate a 2D shape and visualize the result by getting triangle indices. The function returns indices of the shape points which are then used to create individual triangles with a small offset to visualize them.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-tri_ear_clipping.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <triangle/tri_ear_clipping.scad> \n\nshape = [\n    [0, 0],\n    [10, 0],\n    [12, 5],\n    [5, 10],\n    [10, 15],\n    [0, 20],\n    [-5, 18],\n    [-18, 3],\n    [-4, 10]\n];\n\nall_indices = tri_ear_clipping(shape);\n\nfor(tri_indices = all_indices) {\n    offset(-.1)\n        polygon([for(i = tri_indices) shape[i]]);\n}\n```\n\n----------------------------------------\n\nTITLE: Path Extrusion along Helix Points (Euler Angle Method) in OpenSCAD\nDESCRIPTION: Shows the result of using `path_extrude` with `method = \"EULER_ANGLE\"` on points generated by `helix`. This method guesses rotation differently and might produce results closer to user expectation in some cases, but has known limitations. Requires `helix.scad` and `path_extrude.scad`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-path_extrude.md#_snippet_5\n\nLANGUAGE: openscad\nCODE:\n```\n\tuse <helix.scad>\n\tuse <path_extrude.scad>\n\n\tshape_pts = [\n\t\t[0,0],\n\t\t[3, 1],\n\t\t[0, 2]\n\t];\n\n\tpoints = helix( \n\t\tradius = 5, \n\t\tlevels = 5, \n\t\tlevel_dist = 3,\n\t\tvt_dir = \"SPI_UP\"\n\t);\n\n\tpath_extrude(shape_pts, points, method = \"EULER_ANGLE\");\n```\n\n----------------------------------------\n\nTITLE: Sorting a List of Numbers in OpenSCAD\nDESCRIPTION: This snippet demonstrates sorting a list of numbers in ascending order using the `sorted` function. It compares the sorted list with the expected result using the `assert` function, ensuring the sorting is correct. The default comparison operator is used.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sorted.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nassert([1, 2, 3, 4, 5, 6] == sorted([1, 6, 2, 5, 4, 3]));\n```\n\n----------------------------------------\n\nTITLE: Computing 3D Perlin Noise at a Point in OpenSCAD\nDESCRIPTION: Returns a Perlin noise value at a 3D coordinate (x, y, z), suitable for volumetric textures and terrain modeling. Uses noise library functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_41\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nnoise/nz_perlin3(x, y, z[, seed])\n```\n\n----------------------------------------\n\nTITLE: Visualizing a Golden Spiral with Spheres in OpenSCAD\nDESCRIPTION: Example demonstrating how to use the 'golden_spiral' module in OpenSCAD. It includes the module, calls the 'golden_spiral' function to get points and angles between the 3rd and 10th Fibonacci numbers with a point distance of 1, and then iterates through the results to place spheres at each point on the spiral path.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-golden_spiral.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <golden_spiral.scad>\n        \npts_angles = golden_spiral(\n    from = 3, \n    to = 10, \n    point_distance = 1\n);\n\nfor(pt_angle = pts_angles) {\n    translate(pt_angle[0]) \n        sphere(0.5);\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Degrees Conversion Utility in OpenSCAD\nDESCRIPTION: This OpenSCAD code demonstrates how to include and use the 'degrees' function for converting radians to degrees. The snippet requires the 'util/degrees.scad' file to be available and imported. Given a value in radians (such as PI), the 'degrees' function returns the equivalent in degrees, enabling assertions and further calculations for CAD purposes. The expected output of the assertion is 'true' if the conversion works correctly, and no error is thrown.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-degrees.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/degrees.scad>\n\nassert(degrees(PI) == 180);\n```\n\n----------------------------------------\n\nTITLE: Choosing a Random Value Using DotSCAD Utility in OpenSCAD\nDESCRIPTION: Demonstrates importing the choose utility from the DotSCAD library and using it to echo a randomly selected element from an array. Dependencies include the DotSCAD 'choose.scad' file and OpenSCAD 2.5 or later. Key parameters are 'choices' (an array of items to select from) and optionally 'seed' (to ensure reproducibility). The input is an array and optional seed; output is a randomly selected element from the array. Selection is limited to the supplied array and repeats if called multiple times without a seed.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-choose.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/choose.scad>\n\necho(choose([1, 2, 3, 4]));\n```\n\n----------------------------------------\n\nTITLE: Generating and Rendering Square Maze Cells with mz_square_cells in OpenSCAD\nDESCRIPTION: Demonstrates how to generate maze cells with mz_square_cells and render their walls using line2d. This snippet initializes maze parameters, retrieves a cell list, and iterates through each cell to draw top and right walls based on the cell's type field. The code requires the maze/mz_square_cells.scad and line2d.scad libraries for cell generation and drawing, and expects wall and maze dimensions as input variables. The script finishes by drawing the maze's left and bottom border walls.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-mz_square_cells.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <maze/mz_square_cells.scad>\nuse <line2d.scad>\n\nrows = 10;\ncolumns = 10;\ncell_width = 5;\nwall_thickness = 2;\n\nNO_WALL = 0;       \nTOP_WALL = 1;    \nRIGHT_WALL = 2;    \nTOP_RIGHT_WALL = 3; \nMASK = 4;\n\ncells = mz_square_cells(rows, columns);\n\nfor(cell = cells) {\n\ttype = cell[2];\n\t\n\ttranslate([cell.x, cell.y] * cell_width) {\n\t\tif(type == TOP_WALL || type == TOP_RIGHT_WALL) {\n\t\t\tline2d([0, cell_width], [cell_width, cell_width], wall_thickness);\n\t\t}\n\t\t\n\t\tif(type == RIGHT_WALL || type == TOP_RIGHT_WALL) {\n\t\t\tline2d([cell_width, cell_width], [cell_width, 0], wall_thickness);\n\t\t}\t\n\t}\n}\n\nline2d([0, 0], [cell_width * columns, 0], wall_thickness);\nline2d([0, 0], [0, cell_width * rows], wall_thickness);\n```\n\n----------------------------------------\n\nTITLE: Creating Voronoi cells from points in OpenSCAD\nDESCRIPTION: This code snippet demonstrates how to generate Voronoi cell shapes from a list of random points using the 'vrn2_cells_from' module in OpenSCAD. It imports the necessary libraries, creates random points, computes Voronoi cells, and visualizes each cell by extruding and coloring them, resulting in a visual representation of the Voronoi diagram.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vrn2_cells_from.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# use <polyline_join.scad>\n# use <voronoi/vrn2_cells_from.scad>\n\npoints = [for(i = [0:50]) rands(-100, 100, 2)]; \n\ncells = vrn2_cells_from(points);\nfor(i = [0:len(points) - 1]) {\n    pt = points[i];\n    cell = cells[i];\n    \n    linear_extrude(1)\n    polyline_join([each cell, cell[0]])\n        circle(.5);\n    \n    color(rands(0, 1, 3))\n    translate(pt)    \n    linear_extrude(2, scale = 0.8)\n    translate(-pt)    \n        polygon(cell);\n}\n\n![vrn2_cells_from](images/lib3x-vrn2_cells_from-1.JPG)\n```\n\n----------------------------------------\n\nTITLE: Rotating Around Arbitrary Axis with ptf_rotate in OpenSCAD\nDESCRIPTION: This snippet demonstrates rotation of a point about an arbitrary vector axis using the v argument in ptf_rotate. The code visualizes the path by translating and placing spheres along the rotation, while also showing the axis endpoints using hull and sphere for additional context. Requires ptf_rotate.scad, and expects a base point, rotation angle, and 3D vector; only applicable when a is a scalar angle.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-ptf_rotate.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <ptf/ptf_rotate.scad>\n\nv = [10, 10, 10];\n\nhull() {\n\tsphere(1);\n\ttranslate(v)\n\t    sphere(1);   \n}\n\np = [10, 10, 0];\nfor(i = [0:20:340]) {\n\ttranslate(ptf_rotate(p, a = i, v = v)) \n\t\tsphere(1);  \n}\n\n```\n\n----------------------------------------\n\nTITLE: Sorting a List of Lists in OpenSCAD\nDESCRIPTION: This snippet shows sorting a list of lists.  Each sublist contains numbers. The `sorted` function is used with default comparison to sort based on the sublists.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sorted.md#_snippet_5\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nassert(\n    [[2, 0, 0], [5, 0, 0], [7, 0, 0], [9, 0, 0], [10, 0, 0]] == \n    sorted([[2, 0, 0], [5, 0, 0], [7, 0, 0], [9, 0, 0], [10, 0, 0]])\n);\n```\n\n----------------------------------------\n\nTITLE: Generating ASCII Voxel Array\nDESCRIPTION: This code snippet demonstrates how to iterate through a range of ASCII characters and generate voxel points for each character using the `vx_ascii` module. It uses nested loops to position and render each voxel as a small square using `linear_extrude`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_ascii.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voxel/vx_ascii.scad>\n\nfor(i = [0:94]) {\n    translate([8 * (i % 10), -8 * floor(i / 10), 0]) \n    for(p = vx_ascii(chr(i + 32))) {\n        translate(p) \n        linear_extrude(1, scale = 0.8) \n            square(1);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Worley Noise to Generate Cell Values in OpenSCAD\nDESCRIPTION: This example demonstrates importing the nz_cell and golden_spiral modules, generating a grid, and calculating the noise values for each grid cell. Feature points are generated with golden_spiral, shifted to center, and the nz_cell function is used to assign a noise value to each location. The noise values are then visualized as grayscale extrusions by normalizing and coloring each square proportionally to the noise, with the option to use different distance metrics (\"euclidean\", \"manhattan\", etc). Required dependencies are dotSCAD's noise/nz_cell.scad and golden_spiral.scad. Key parameters are the points array, pixel coordinates, and the distance metric. Expected output is a visualized 2D grid of extruded squares, whose heights correspond to noise values.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-nz_cell.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <noise/nz_cell.scad>\nuse <golden_spiral.scad>\n\nsize = [100, 50];\nhalf_size = size / 2;\n\npts_angles = golden_spiral(\n    from = 3, \n    to = 10, \n    point_distance = 3\n);\n\nfeature_points = [for(pt_angle = pts_angles) pt_angle[0] + half_size];\nnoised = [\n    for(y = [0:size.y - 1], x = [0:size.x - 1]) \n    [x, y, nz_cell(feature_points, [x, y])]\n];\n\nmax_dist = max([for(n = noised) n[2]]);\n\nfor(n = noised) {\n    c = abs(n[2] / max_dist);\n    color([c, c, c])\n    linear_extrude(n[2] + 0.1)\n    translate([n[0], n[1]])\n        square(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Using m_replace to Modify an OpenSCAD Matrix Element\nDESCRIPTION: This OpenSCAD example demonstrates the usage of the `m_replace` function. It defines an original matrix (`original_m`), uses `m_replace` to change the element at row 1, column 2 (zero-indexed) to 70, and stores the result in `actual`. Finally, it uses `assert` to verify that the modified matrix (`actual`) matches the `expected` result. This example requires the `matrix/m_replace.scad` module to be included.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-m_replace.md#_snippet_0\n\nLANGUAGE: openscad\nCODE:\n```\nuse <matrix/m_replace.scad>\n\noriginal_m = [\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10, 11, 12]\n];\n\nexpected = [\n    [1, 2, 3, 4],\n    [5, 6, 70, 8],\n    [9, 10, 11, 12]\n];\n\nactual = m_replace(original_m, 1, 2, 70);\n\nassert(actual == expected);\n```\n\n----------------------------------------\n\nTITLE: Visualizing Fibonacci Lattice Points with Spheres and Spirals in OpenSCAD\nDESCRIPTION: This snippet visualizes the Fibonacci lattice points on a sphere by placing small spheres at each point and also creates spirals connecting points based on their indices. It utilizes the 'polyline_join.scad' library for connecting points with lines, and parameters influence the number of points, sphere size, and spiral arrangement. The code demonstrates complex visualization of spatial point distribution with spirals on the sphere's surface.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-fibonacci_lattice.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nn = 200;\nradius = 20;\npts = fibonacci_lattice(n, radius);\n\nfor(p = pts) {\n    translate(p)\n        sphere(1);\n}\n\nsphere(radius * 0.9);\n\n// You can pick spirals from points.\nspirals = [for(j = [0:20]) \n    [for(i = j; i < len(pts); i = i + 21) pts[i]]\n];\n\nfor(spiral = spirals) {\n    polyline_join(spiral)\n        sphere(.25); \n}\n```\n\n----------------------------------------\n\nTITLE: Generating 4x4 Shearing Transformation Matrices in OpenSCAD\nDESCRIPTION: Defines the m_shearing function which produces a 4x4 transformation matrix usable by OpenSCAD's multmatrix function to shear 3D geometries along the X, Y, or Z axes based on specified shear parameters. Dependencies include OpenSCAD environment and the multmatrix operation. The sx, sy, and sz parameters are arrays controlling the shearing factors for respective axes, transforming child element coordinates accordingly. Output is a matrix that modifies child object positions by shearing, allowing complex geometric distortions. Limitations include the need to use arrays of two shear factors per axis and the expected usage inside a multmatrix call.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-m_shearing.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <matrix/m_shearing.scad>\n\ncolor(\"red\") {\n\tmultmatrix(m_shearing(sx = [1, 0]))\n\t\tcube(1);\n\t\t\n\ttranslate([2, 0, 0]) \n\tmultmatrix(m_shearing(sx = [0, 1]))\n\t\tcube(1);\n\t\t\n\ttranslate([4, 0, 0]) \n\tmultmatrix(m_shearing(sx = [1, 1]))\n\t\tcube(1);\n}\n\ntranslate([0, -3, 0]) color(\"green\") {\n\tmultmatrix(m_shearing(sy = [1, 0]))\n\t\tcube(1);\n\t\t\n\ttranslate([2, 0, 0]) \n\tmultmatrix(m_shearing(sy = [0, 1]))\n\t\tcube(1);\n\t\t\n\ttranslate([4, 0, 0]) \n\tmultmatrix(m_shearing(sy = [1, 1]))\n\t\tcube(1);\n}\n\ntranslate([0, -5, 0]) color(\"blue\") {\n\tmultmatrix(m_shearing(sz = [1, 0]))\n\t\tcube(1);\n\t\t\n\ttranslate([2, 0, 0]) \n\tmultmatrix(m_shearing(sz = [0, 1]))\n\t\tcube(1);\n\t\t\n\ttranslate([4, 0, 0]) \n\tmultmatrix(m_shearing(sz = [1, 1]))\n\t\tcube(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Using tri_subdivide with shape_circle in OpenSCAD\nDESCRIPTION: Demonstrates how to create a triangle using shape_circle and subdivide it multiple times. The example creates a base triangle and then shows the result of 1, 2, and 3 subdivisions, displaying them side by side with slight offsets for visibility.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-tri_subdivide.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_circle.scad>\nuse <triangle/tri_subdivide.scad>\n\nradius = 10;\ntri = shape_circle(radius, $fn = 3);\n\npolygon(tri);\n\nfor(n = [1:3]) {\n    subdivided = tri_subdivide(tri, n);\n    translate([radius * 2 * n, 0])\n    for(t = subdivided) {\n        offset(-.1)\n            polygon(t);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: 2D Pixel Array in JavaScript\nDESCRIPTION: A two-dimensional array containing grayscale pixel values (0-255). Each sub-array represents a row of pixels in the image, with each number representing the brightness value of a single pixel.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_gray.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n[\n        [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 227, 222, 226, 226, 226, 226, 216, 134, 130, 127, 130, 118, 76, 42, 54, 92, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n        [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 225, 226, 223, 228, 225, 228, 221, 182, 131, 131, 129, 128, 112, 41, 56, 95, 182, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], \n        [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 202, 212, 209, 212, 220, 225, 225, 153, 129, 125, 127, 130, 120, 86, 118, 208, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]\n        // Additional rows omitted for brevity\n]\n```\n\n----------------------------------------\n\nTITLE: Using polyhedron_hull Module in OpenSCAD\nDESCRIPTION: Example demonstrating how to use the polyhedron_hull module to create a complex 3D shape by providing a list of 3D coordinates. The function generates a convex hull that encloses all the given points.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polyhedron_hull.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyhedron_hull.scad>\n\npolyhedron_hull([\n\t[1, 1, 1],\n\t[1, 1, 0],\n\t[-1, 1, 0],\n\t[-1, -1, 0],\n\t[1, -1, 0],\n\t[0, 0, 1],\n\t[0, 0, -1]\n]);\n```\n\n----------------------------------------\n\nTITLE: Modeling with vx_from OpenSCAD\nDESCRIPTION: This snippet uses the `vx_from` function to generate a 3D model. It defines an array of points (`pts`) which represent the coordinates of the model. The code then iterates through these points and translates and draws a square at each point. It demonstrates a basic usage of `vx_from` to create a model using array data.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_from.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voxel/vx_from.scad>\n\npts = vx_from([\n    [0,0,0,0,0,0,0,0],\n    [0,0,0,1,1,0,0,0],\n    [0,0,1,1,1,1,0,0],\n    [0,1,1,0,0,1,1,0],\n    [0,1,1,0,0,1,1,0],\n    [0,1,1,1,1,1,1,0],\n    [0,1,1,0,0,1,1,0],\n    [0,0,0,0,0,0,0,0]\n]);\n            \nfor(pt = pts) {\n    translate(pt) \n        square(1);\n}\n\ntranslate([8, 0]) for(pt = pts) {\n    translate(pt) \n        text(\"A\", font=\"Arial Black\", 1);\n}\n```\n\n----------------------------------------\n\nTITLE: shape_pie Example with helix_extrude\nDESCRIPTION: Demonstrates how to use the shape_pie module in conjunction with the helix_extrude module to create a 3D helix. It includes the 'use' statements to import both shape_pie and helix_extrude modules. The example defines a pie shape and then extrudes it along a helix path.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_pie.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n    use <shape_pie.scad>\n    use <helix_extrude.scad>\n\n    shape_pts = shape_pie(10, [45, 315], $fn = 8);\n\n    helix_extrude(shape_pts, \n        radius = 40, \n        levels = 5, \n        level_dist = 20\n    );\n```\n\n----------------------------------------\n\nTITLE: Path Scaling Sections Example 1 - Linear Edge Path\nDESCRIPTION: This example demonstrates the basic usage of `path_scaling_sections` with a linear edge path. It defines a Taiwan shape and a straight path, then uses these to create a scaled extrusion. Dependencies include `polyline_join.scad`, `shape_taiwan.scad`, `path_scaling_sections.scad`, and `sweep.scad`. The `fst_pt` variable defines the starting point of the edge path, and the path is constructed by adding offsets to this point. The `#polyline_join` and `sphere` lines are commented out to prevent rendering issues; they are intended for visualizing the edge path.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-path_scaling_sections.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n\tuse <polyline_join.scad>\n\tuse <shape_taiwan.scad>\n\tuse <path_scaling_sections.scad>\n\tuse <sweep.scad>\n\n\ttaiwan = shape_taiwan(100);\n\tfst_pt = [13, 0, 0];\n\n\tedge_path = [\n\t\tfst_pt,\n\t\tfst_pt + [0, 0, 10],\n\t\tfst_pt + [10, 0, 20],\n\t\tfst_pt + [8, 0, 30],\n\t\tfst_pt + [12, 0, 40],\n\t\tfst_pt + [0, 0, 50],\n\t\tfst_pt + [0, 0, 60]\n\t];\n\n\t#polyline_join(edge_path) \n\t    sphere(.5);\n\tsweep(path_scaling_sections(taiwan, edge_path));\n```\n\n----------------------------------------\n\nTITLE: Voronoi Diagram with Bend Extrude and Difference in OpenSCAD\nDESCRIPTION: This snippet demonstrates a more advanced use case involving the `vrn2_space` module, combining it with `bend_extrude` and `difference` operations. It creates a Voronoi diagram within a square and then subtracts it from the square using `difference`.  The result is then extruded along a circular path using `bend_extrude`. It requires both `bend_extrude.scad` and `vrn2_space.scad` libraries.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vrn2_space.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <bend_extrude.scad>\nuse <voronoi/vrn2_space.scad>\n\nsize = [60, 20];\n\nbend_extrude(size = size, thickness = 1, angle = 360) \n    difference() {\n        square(size);\n        vrn2_space(\n            size = size,\n            grid_w = 5,\n            seed = 1\n        );\n    \n```\n\n----------------------------------------\n\nTITLE: Using dedup with and without eq in OpenSCAD\nDESCRIPTION: This snippet demonstrates the use of the `dedup` function, both with and without a custom equality function.  It uses the `assert` function to verify the functionality, ensuring the output of `dedup` matches the expected result after removing duplicates. The first assertion uses the default equality check, while the second explicitly provides the `eq` function defined in the previous snippet. This highlights how to specify custom equality and the expected outcome when duplicates are present.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-dedup.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\npoints = [[1, 1, 2], [3, 4, 2], [7, 2, 2], [3, 4, 2], [1, 2, 3]];\nassert(\n    dedup([[1, 1, 2], [3, 4, 2], [7, 2, 2], [3, 4, 2], [1, 2, 3]]) \n        == [[1, 1, 2], [3, 4, 2], [7, 2, 2], [1, 2, 3]]\n);\n\nassert(\n    dedup([[1, 1, 2], [3, 4, 2], [7, 2, 2], [3, 4, 2], [1, 2, 3]], eq = eq) \n        == [[1, 1, 2], [3, 4, 2], [7, 2, 2], [1, 2, 3]]\n);\n```\n\n----------------------------------------\n\nTITLE: Hollow Voronoi Sphere with Specified Thickness in OpenSCAD\nDESCRIPTION: Creates a hollow sphere with a Voronoi pattern by using difference operations. The code generates random points on a sphere, creates a 3D Voronoi diagram, and then creates a shell with specified thickness by subtracting both the Voronoi cells and a smaller sphere from the original sphere.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vrn3_from.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voronoi/vrn3_from.scad>\n\nr = 30;\nthickness = 2;\n\nzas = rands(0, 359, 12);\nyas = rands(0, 179, 12);\n\npoints = [\n    for(i = [0:len(zas) - 1])\n    [\n        r * cos(yas[i]) * cos(zas[i]), \n        r * cos(yas[i]) * sin(zas[i]), \n        r * sin(yas[i])\n    ]\n];\n\ndifference() {\n    sphere(r);\n    \n    render()\n    scale(1.01) \n    intersection() {\n        sphere(r);\n        vrn3_from(points);\n    }\n    \n    sphere(r - thickness);\n}\n```\n\n----------------------------------------\n\nTITLE: Using polyline_join for 2D Shapes in OpenSCAD\nDESCRIPTION: Demonstrates how to use the `polyline_join` module with a list of 2D points. The first example places a `square(1)` at each point. The second example places different shapes (`square(1)`, `circle(1)`, `square(1)`, `circle(2)`) sequentially at the points of the polyline. Requires including the `polyline_join.scad` library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polyline_join.md#_snippet_0\n\nLANGUAGE: openscad\nCODE:\n```\nuse <polyline_join.scad>\n\npolyline_join([[0, 0], [10, 0], [10, 10], [0, 10]]) \n    square(1);\n```\n\nLANGUAGE: openscad\nCODE:\n```\npolyline_join([[15, 0], [25, 0], [25, 10], [15, 10]]) {\n    square(1);\n    circle(1);\n    square(1);\n    circle(2);\n}\n```\n\n----------------------------------------\n\nTITLE: Extruding a Pentagram Along a Torus Knot Path in OpenSCAD\nDESCRIPTION: Demonstrates using the `torus_knot` module to generate points for a (2,3) torus knot path with a specified step (`phi_step`). It then defines a pentagram shape using `shape_pentagram` and extrudes this shape along the generated knot path (plus the starting point to close it) using `path_extrude`, employing the EULER_ANGLE method. This example requires the `shape_pentagram.scad`, `path_extrude.scad`, and `torus_knot.scad` modules.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-torus_knot.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n\tuse <shape_pentagram.scad>\n\tuse <path_extrude.scad>\n\tuse <torus_knot.scad>\n\n\tp = 2;\n\tq = 3;\n\tphi_step = 0.05;\n\tstar_radius = 0.5;\n\n\tpts = torus_knot(p, q, phi_step);\n\n\tshape_pentagram_pts = shape_pentagram(star_radius);\n\n\tpath_extrude(\n\t\tshape_pentagram_pts, \n        [each pts, pts[0]], \n\t\tclosed = true,\n\t\tmethod = \"EULER_ANGLE\"\n\t);\n```\n\n----------------------------------------\n\nTITLE: Generating Rounded Square Points for dotSCAD in OpenSCAD\nDESCRIPTION: Defines the shape_square module that returns shape points representing a rounded square or rectangle for use within dotSCAD. It accepts a size parameter which can be a single value for squares or a two-value array for rectangles, the corner_r parameter to specify the radius of the rounded corners expressed as a quadrant of a circle, and optional OpenSCAD $fa, $fs, $fn variables to control circle segment resolution. The output is an array of points suitable for polygons or extrusions. This module requires OpenSCAD environment with dotSCAD libraries and supports precise control over corner smoothness and dimensions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_square.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_square.scad>\n\npolygon(\n\tshape_square(size = 50, corner_r = 5)\n);\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_square.scad>\nuse <ring_extrude.scad>\n\n$fn = 36;\n\nshape_pts = shape_square(\n\tsize = [20, 10],\n\tcorner_r = 2\n);\n\nring_extrude(\n\tshape_pts, \n\tradius = 50, angle = 180, twist = 180, scale = 2\n);\n```\n\n----------------------------------------\n\nTITLE: Importing and Testing List Slice Function in OpenSCAD\nDESCRIPTION: Demonstrates the import of the 'slice' utility and provides assertions to verify expected behavior. Requires 'util/slice.scad' from the dotscad project. The code shows usage with a character list generated from a string using a for loop comprehension. The first assertion slices the list from index 0 to 5, while the second omits the end index to retrieve elements from 5 to the end of the list. Both examples compare the result to an explicit array using assert(). Expected input: a list and numeric indices; output: a sublist corresponding to the specified range. Constraints: indices must be within list bounds.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-slice.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/slice.scad>\n\nassert(slice([for(c = \"helloworld\") c], 0, 5) == [\"h\", \"e\", \"l\", \"l\", \"o\"]);\nassert(slice([for(c = \"helloworld\") c], 5) == [\"w\", \"o\", \"r\", \"l\", \"d\"]);\n```\n\n----------------------------------------\n\nTITLE: Pixel Data Array in JSON Format\nDESCRIPTION: A two-dimensional array containing pixel values for an image. Each subarray represents a row of pixels, with values ranging from 0-255 representing pixel intensities. The data appears to be a grayscale or single-channel image representation.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_torus.md#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n[\n        [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 227, 222, 229, 226, 218, 134, 128, 144, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 132, 7, 2, 5, 3, 1, 2, 1, 3, 11, 40, 160, 178, 175, 188, 189, 190, 184, 172, 159, 150, 145, 143, 142, 140, 135, 129, 126, 123, 118, 113, 109, 104, 100, 94, 89, 84, 78, 70, 64, 59, 72, 57, 60, 70, 85, 99, 112, 128, 158, 90, 2, 8, 0, 0, 1, 2, 1, 1, 1, 0, 0, 31, 48, 0, 51, 255, 255],\n        [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 226, 225, 226, 223, 199, 132, 125, 178, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 207, 53, 0, 4, 2, 3, 3, 3, 1, 7, 1, 5, 8, 122, 159, 170, 175, 174, 176, 176, 175, 175, 174, 169, 159, 150, 141, 136, 130, 125, 120, 114, 107, 103, 99, 94, 87, 82, 78, 71, 62, 57, 53, 56, 60, 76, 81, 91, 108, 127, 151, 177, 25, 9, 4, 0, 5, 1, 2, 1, 0, 5, 7, 42, 104, 145, 47, 12, 255, 255],\n        [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 225, 227, 224, 227, 167, 131, 130, 215, 255, 255, 255, 255, 255, 255, 255, 255, 255, 148, 6, 5, 4, 1, 1, 2, 0, 1, 1, 0, 4, 7, 6, 59, 139, 154, 160, 168, 168, 167, 165, 165, 166, 164, 158, 153, 150, 148, 143, 137, 131, 124, 117, 112, 105, 100, 93, 87, 80, 70, 61, 56, 53, 56, 69, 80, 92, 111, 124, 144, 160, 116, 11, 3, 0, 0, 0, 1, 1, 5, 3, 4, 103, 98, 177, 146, 79, 5, 255, 255]\n```\n\n----------------------------------------\n\nTITLE: Checking Vector Presence with Optional Binary Search in OpenSCAD\nDESCRIPTION: A function that tests if a list of vectors `lt` contains the vector `elem`. It accepts a boolean parameter `sorted` which, when true, enables an optimized binary search assuming the input list is sorted by zyx order. This improves performance for repeated membership tests. The function relies on standard OpenSCAD vector and list operations. Inputs include `lt`, a list of vector coordinates; `elem`, a vector coordinate to find; and `sorted`, a flag indicating whether to use binary search. Outputs a boolean indicating presence. The function is suited for geometric element presence checking and requires the lists to be sorted if binary search is enabled.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-has.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voxel/vx_circle.scad>\nuse <util/sort.scad>\nuse <util/has.scad>\n\npts = vx_circle(10);\nassert(has(pts, [2, -10])); \nassert(!has(pts, [0, 0]));  \n\nsorted_pts = sort(pts, by = \"vt\");\nassert(has(sorted_pts, [2, -10]));\nassert(!has(sorted_pts, [0, 0]));\n```\n\n----------------------------------------\n\nTITLE: Using polyline_join for 3D Shapes in OpenSCAD\nDESCRIPTION: Shows the application of `polyline_join` with 3D points. The first example places a `cube(1)` at each vertex. The second example places a sequence of different 3D shapes (`cube(1)`, `sphere(1)`, `cube(1)`, `sphere(2)`) at the vertices of the 3D polyline. This requires including the `polyline_join.scad` library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polyline_join.md#_snippet_1\n\nLANGUAGE: openscad\nCODE:\n```\nuse <polyline_join.scad>\n    \npolyline_join([[0, 0, 0], [10, 0, 0], [10, 0, 10], [10, 10, 10]]) \n    cube(1);\n```\n\nLANGUAGE: openscad\nCODE:\n```\npolyline_join([[15, 0, 0], [25, 0, 0], [25, 0, 10], [25, 10, 10]]) {\n    cube(1);\n    sphere(1);\n    cube(1);\n    sphere(2);\n}\n```\n\n----------------------------------------\n\nTITLE: Translating and Creating a Custom Angular Shell Segment in OpenSCAD\nDESCRIPTION: This snippet positions a crystal ball segment at [36, 0, 0], using vector-valued theta and phi parameters to control both start and end angles for azimuth and polar angles respectively, and creates a shell of thickness 2. The theta and phi vectors allow defining arbitrary wedges or slices of the sphere. The example assumes crystal_ball.scad is imported. This configuration is suitable for modeling shells or partial spheres with precise angular boundaries.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-crystal_ball.md#_snippet_3\n\nLANGUAGE: OpenSCAD\nCODE:\n```\ntranslate([36, 0, 0]) \n\tcrystal_ball(\n\t\tradius = 6, \n\t\ttheta = [-30, 270],\n\t\tphi = [30, 60],\n\t\tthickness = 2\n\t);\n```\n\n----------------------------------------\n\nTITLE: Calculating Matrix Determinant with m_determinant in OpenSCAD\nDESCRIPTION: Examples demonstrating how to use the m_determinant function to calculate determinants of square matrices of different sizes. The examples show calculations for 2x2, 3x3, and 4x4 matrices along with their expected results.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-m_determinant.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <matrix/m_determinant.scad>\n\nassert(\n    m_determinant([\n        [3, 8],\n        [4, 6]\n    ]) == -14\n);\n\nassert(\n    m_determinant([\n        [6,  1, 1],\n        [4, -2, 5],\n        [2,  8, 7]\n    ]) == -306\n);\n\nassert(\n    m_determinant([\n        [0,  4, 0, -3],\n        [1,  1, 5,  2],\n        [1, -2, 0,  6],\n        [3,  0, 0,  1]\n    ]) == -250\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Square Maze with Walls using mz_squarewalls in OpenSCAD\nDESCRIPTION: This example demonstrates how to generate a square maze and render its walls using mz_squarewalls and polyline2d. It creates a 10x10 maze with cell width of 5 and wall thickness of 2, then renders each wall segment using polyline2d with miter joints.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-mz_squarewalls.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <maze/mz_square.scad>\nuse <maze/mz_squarewalls.scad>\nuse <polyline2d.scad>\n\nrows = 10;\ncolumns = 10;\ncell_width = 5;\nwall_thickness = 2;\n\ncells = mz_square(rows, columns);\nwalls = mz_squarewalls(cells, cell_width);\n\nfor(wall = walls) {\n\tpolyline2d(wall, wall_thickness, joinStyle = \"JOIN_MITER\");\n}\n```\n\n----------------------------------------\n\nTITLE: Function to compute 2D coordinates from angle and radius in OpenSCAD\nDESCRIPTION: This function calculates Cartesian coordinates from polar coordinates given an angle theta and radius r. It is used for positioning maze cell walls accurately in a circular maze layout.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-mz_theta_cells.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nfunction vt_from_angle(theta, r) = [r * cos(theta), r * sin(theta)];\n```\n\n----------------------------------------\n\nTITLE: Hollow Path Extrusion with Bezier Curve in OpenSCAD\nDESCRIPTION: Shows how to create a hollow extrusion using `path_extrude` by setting `triangles = \"HOLLOW\"`. The `shape_pts` define both outer and inner contours, and the path is generated by `bezier_curve`. Requires `path_extrude.scad` and `bezier_curve.scad`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-path_extrude.md#_snippet_1\n\nLANGUAGE: openscad\nCODE:\n```\n\tuse <path_extrude.scad>\n\tuse <bezier_curve.scad>\n\n\tt_step = 0.05;\n\n\tp0 = [0, 0, 0];\n\tp1 = [40, 60, 35];\n\tp2 = [-50, 70, 0];\n\tp3 = [20, 150, -35];\n\tp4 = [30, 50, -3];\n\n\tshape_pts = [\n\t\t// outer\n\t\t[5, 0],\n\t\t[3, 9],\n\t\t[0, 10],    \n\t\t[-5, 0],\n\t\t// inner\n\t\t[3, 2],\n\t\t[2, 7],\n\t\t[0, 7],\n\t\t[-3, 2]\n\t];\n\n\tpath_pts = bezier_curve(t_step, \n\t\t[p0, p1, p2, p3, p4]\n\t);\n\n\tpath_extrude(shape_pts, path_pts, triangles = \"HOLLOW\");\n```\n\n----------------------------------------\n\nTITLE: Using `footprints2` and `arc_cmds` in OpenSCAD\nDESCRIPTION: This OpenSCAD example demonstrates how to use the `footprints2` function to create a path by combining straight lines and an arc. It defines a helper function `arc_cmds` to generate the command sequence for an arc segment. The main part calls `footprints2` with a list mixing direct commands and the generated arc commands. Finally, it uses `polyline_join` to visualize the resulting path. Requires `<polyline_join.scad>` and `<turtle/footprints2.scad>`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-footprints2.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline_join.scad>\nuse <turtle/footprints2.scad>\n\nfunction arc_cmds(radius, angle, steps) = \n\tlet(\n\t\tfa = angle / steps,\n\t\tta = fa / 2,\n\t\tleng = sin(ta) * radius * 2\n\t)\n    [\n        [\"turn\", ta],\n        each [\n\t\t\tfor(i = [0:steps - 2])\n\t\t\teach [[\"forward\", leng], [\"turn\", fa]]\n\t\t],\n        [\"forward\", leng], \n        [\"turn\", ta]\n    ];\n\t\t\npoly = footprints2(\n    [\n        [\"forward\", 10],\n\t    [\"turn\", 90],\n\t\t[\"forward\", 10],\n        each arc_cmds(5, 180, 12),\n        [\"turn\", -90],\n        [\"forward\", 10],\n        [\"turn\", 90],\n        [\"forward\", 10],\n        [\"turn\", 90],\n        [\"forward\", 10]\n    ]\n);\n\npolyline_join(poly)\n    circle(.5);\n```\n\n----------------------------------------\n\nTITLE: Visualizing maze walls based on cell data using OpenSCAD\nDESCRIPTION: This script iterates over maze cell data to draw walls for each cell based on its type, using angular measurements and circle primitives. It calculates inner and outer vertex positions for walls and renders them accordingly, including outermost boundary walls for the maze.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-mz_theta_cells.md#_snippet_3\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n// draw cell walls\nfor(rows = maze, cell = rows) { \n\tri = cell[0];\n\tci = cell[1];\n\ttype = cell[2];\n\tthetaStep = 360 / len(maze[ri]);\n\tinnerR = (ri + 1) * cell_width;\n\touterR = (ri + 2) * cell_width;\n\ttheta1 = thetaStep * ci;\n\ttheta2 = thetaStep * (ci + 1);\n\n\tinnerVt1 = vt_from_angle(theta1, innerR);\n\tinnerVt2 = vt_from_angle(theta2, innerR);\n\touterVt2 = vt_from_angle(theta2, outerR);\n\n\tif(type == INWARD_WALL || type == INWARD_CCW_WALL) {\n\t\tpolyline_join([innerVt1, innerVt2])\n\t\t\tcircle(wall_thickness / 2);\n\t}\n\n\tif(type == CCW_WALL || type == INWARD_CCW_WALL) {\n\t\tpolyline_join([innerVt2, outerVt2])\n\t\t\tcircle(wall_thickness / 2);\n\t}\n}\n\n// outmost walls\nthetaStep = 360 / len(maze[rows - 1]);\n r = cell_width * (rows + 1);\n for(theta = [0:thetaStep:360 - thetaStep]) {\n\tvt1 = vt_from_angle(theta, r);\n\tvt2 = vt_from_angle(theta + thetaStep, r);\n\tpolyline_join([vt1, vt2])\n\tcircle(wall_thickness / 2);\n}\n```\n\n----------------------------------------\n\nTITLE: Extruding an Ellipse Shape Along a Helix in OpenSCAD\nDESCRIPTION: This OpenSCAD example demonstrates generating ellipse points with shape_ellipse and extruding them using the helix_extrude module from dotSCAD. Both shape_ellipse.scad and helix_extrude.scad must be imported. The shape_pts variable holds ellipse points with defined axes; the helix_extrude function extrudes these points along a helical path with specified radius, number of levels, vertical distance per level, and a rotation direction ('CLK'). The $fn variable is overridden locally to influence segmentation. Inputs are ellipse axes and helix parameters; output is a 3D helical extrusion of the original 2D ellipse.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_ellipse.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_ellipse.scad>\nuse <helix_extrude.scad>\n\n$fn = 8;\n\t\nshape_pts = shape_ellipse([20, 10]);\n\nhelix_extrude(shape_pts, \n\tradius = 40, \n\tlevels = 5, \n\tlevel_dist = 20,\n    rt_dir = \"CLK\"\n);\n```\n\n----------------------------------------\n\nTITLE: Definition and usage of hashset_len function in OpenSCAD\nDESCRIPTION: This code snippet demonstrates how to calculate the length (number of elements) of a HashSet in OpenSCAD. It depends on the util/set/hashset library and provides an example of creating a HashSet and asserting its length. The snippet benefits users needing to determine set sizes in models.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-hashset_len.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# hashset_len\n\nReturns the length of the elements in a [util/set/hashset](https://openhome.cc/eGossip/OpenSCAD/lib3x-hashset.html).\n\n**Since:** 3.0\n\n## Parameters\n\n- `set` : The set.\n\n## Examples\n\n    use <util/set/hashset.scad>\n    use <util/set/hashset_len.scad>\n\n    s = hashset([1, 2, 3, 4, 5]);\n    assert(hashset_len(s) == 5);\n```\n\n----------------------------------------\n\nTITLE: Extruding a 2D Shape Along an Archimedean Spiral Path in OpenSCAD\nDESCRIPTION: Demonstrates how to use the 'archimedean_spiral_extrude' module to extrude a custom 2D shape, defined by a list of points, along an Archimedean spiral in OpenSCAD. Requires the 'archimedean_spiral_extrude.scad' file and optionally dependencies like 'sweep' for custom triangulation. The main parameters let you control the shape, spiral geometry (arm_distance, angle, point_distance, number of points), scale, twist, and whether the extrusion is solid or hollow. Outputs a 3D object modeled along the computed spiral.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-archimedean_spiral_extrude.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <archimedean_spiral_extrude.scad>\n\nshape_pts = [\n\t[5, 0],\n\t[5, 4],\n\t[4, 4], \n\t[4, 2], \n\t[-4, 2],\n\t[-4, 4],\n\t[-5, 4],\n\t[-5, 0]\n];\n\narchimedean_spiral_extrude(\n\tshape_pts,\n\tarm_distance = 15,  \n\tinit_angle = 180, \n\tpoint_distance = 5,\n\tnum_of_points = 100,\n\tscale = [1, 5]\n);\n```\n\n----------------------------------------\n\nTITLE: OpenSCAD Hashmap Keys Example\nDESCRIPTION: Illustrates how to use the `hashmap_keys` module to extract keys from a hashmap. It requires the `util/map/hashmap.scad` and `util/map/hashmap_keys.scad` libraries. The example initializes a hashmap `m` and then prints its keys to the console.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-hashmap_keys.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/map/hashmap.scad>\nuse <util/map/hashmap_keys.scad>\n\nm = hashmap([[\"k1\", 10], [\"k2\", 20], [\"k3\", 30]]);\n\necho(hashmap_keys(m));    // a list contains \"k1\", \"k2\", \"k3\"\n```\n\n----------------------------------------\n\nTITLE: Generating 3D Turtle Commands for footprints3 in OpenSCAD\nDESCRIPTION: Defines a function xy_arc_cmds to generate a list of turtle commands approximating a circular arc in 3D space by dividing the arc into steps with turns and forwards. This helper function uses trigonometric calculations to determine segment lengths and turn angles. It supports modular construction of arcs by returning an array of commands compatible with footprints3. Dependencies include OpenSCAD's built-in arithmetic and trigonometric functions. Inputs include radius, angle of arc in degrees, and number of steps, while output is an array of commands for turtle movement and rotation.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-footprints3.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nfunction xy_arc_cmds(radius, angle, steps) = \n\tlet(\n\t\tfa = angle / steps,\n\t\tta = fa / 2,\n\t\tleng = sin(ta) * radius * 2\n\t)\n        [\n            [\"turn\", ta],\n            each [\n\t\t\tfor(i = [0:steps - 2])\n\t\t\teach [[\"forward\", leng], [\"turn\", fa]]\n\t\t],\n            [\"forward\", leng], \n            [\"turn\", ta]\n        ];\n```\n\n----------------------------------------\n\nTITLE: Extruding along a Helix using helix_extrude in OpenSCAD\nDESCRIPTION: Provides an example of using `helix_extrude` as a more suitable alternative to `path_extrude` when extruding along a precisely defined helix. Requires `helix_extrude.scad`. Shows extrusion with specified radius, levels, and level distance.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-path_extrude.md#_snippet_3\n\nLANGUAGE: openscad\nCODE:\n```\n\tuse <helix_extrude.scad>\n\n\tshape_pts = [\n\t\t[0,0],\n\t\t[3, 1],\n\t\t[0, 2]\n\t];\n\n\thelix_extrude(shape_pts, \n\t\tradius = 5, \n\t\tlevels = 5, \n\t\tlevel_dist = 3,\n\t\tvt_dir = \"SPI_UP\"\n\t);\n```\n\n----------------------------------------\n\nTITLE: Using stereographic_extrude and text in OpenSCAD\nDESCRIPTION: This OpenSCAD snippet demonstrates the use of the `stereographic_extrude` function to project a text character onto a sphere. It uses a given dimension to control the size. The `text` module is used to define the 2D polygon which will be projected. The `$fa`, `$fs` or `$fn` parameters control the sphere resolution.  The output will be a 3D shape representing the text character projected onto a sphere.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-stereographic_extrude.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <stereographic_extrude.scad>\n\ndimension = 100;\n\nstereographic_extrude(shadow_side_leng = dimension, convexity = 10)\n   text(\n            \"M\", size = dimension, \n            valign = \"center\", \n            halign = \"center\"\n       );\n   \ncolor(\"black\") \n   text(\n            \"M\", size = dimension, \n            valign = \"center\", \n            halign = \"center\"\n       );\n```\n\n----------------------------------------\n\nTITLE: Placing Circles Along a Spiral Path Using archimedean_spiral in OpenSCAD\nDESCRIPTION: This example shows how to generate points and angles along a spiral path using archimedean_spiral and then render a small circle at each calculated point. This usage lets users visualize or mark spiral coordinates, especially useful for debugging or design annotation. The code has dependencies on the archimedean_spiral.scad library and assumes 'circle' is available from standard OpenSCAD. Parameters let the user set the spiral spacing, start angle, and total number of points; each circle is drawn at a computed spiral position.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-archimedean_spiral.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <archimedean_spiral.scad>\n\npoints_angles = archimedean_spiral(\n    arm_distance = 10,  \n    init_angle = 180, \n    point_distance = 5,\n    num_of_points = 100 \n); \n\nfor(pa = points_angles) {\n    translate(pa[0]) \n        circle(2);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Voronoi diagram from points in OpenSCAD\nDESCRIPTION: This snippet illustrates generating a Voronoi diagram from a list of points with options to customize cell spacing, outline movements, and cell shape types. The code utilizes parameters such as 'points', 'spacing', 'r', 'delta', and 'region_type' for flexible diagram creation. It includes example usage with random points and visualization of results, including circular cells. Dependencies include 'voronoi/vrn2_from.scad'.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vrn2_from.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# vrn2_from\n\nCreate a [Voronoi diagram](https://en.wikipedia.org/wiki/Voronoi_diagram) from a list of points. \n\n**Since:** 2.4\n\n## Parameters\n\n- `points` : Points for each cell. \n- `spacing` : Distance between cells. Default to 1.\n- `r`, `delta`, `chamfer` : The outlines of each cell can be moved outward or inward. These parameters have the same effect as [`offset`](https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Transformations#offset). \n- `region_type` : The initial shape for each cell can be `\"square\"` or `\"circle\"`. Default to `\"square\"`.\n\n## Examples\n\n    use <voronoi/vrn2_from.scad>\n\n    points = [for(i = [0:50]) rands(-20, 20, 2)];\n\n    vrn2_from(points);\n    translate([80, 0, 0]) \n        vrn2_from(points, region_type = \"circle\");\n\n![vrn2_from](images/lib3x-vrn2_from-1.JPG)\n\n    use <voronoi/vrn2_from.scad>\n    use <hollow_out.scad>\n\n    xs = rands(0, 40, 50);\n    ys = rands(0, 20, 50);\n\n    points = [for(i = [0:len(xs) - 1]) [xs[i], ys[i]]];\n\n    difference() {\n        square([40, 20]);\n        vrn2_from(points);\n    }\n    hollow_out(shell_thickness = 1) square([40, 20]);\n    \n![vrn2_from](images/lib3x-vrn2_from-2.JPG)\n```\n\n----------------------------------------\n\nTITLE: Generating 3D Poisson Disk Sample Points in OpenSCAD\nDESCRIPTION: This snippet demonstrates the usage of the pp_poisson3 function from the pp_poisson3.scad library to generate points distributed inside a 3D cube with minimum spacing constraints. It requires importing the pp_poisson3 module and specifies the cubic dimensions and minimum point distance. The example iterates through the generated points and renders spheres at each location to visualize the sampling. Parameters include 'size' for cube dimensions and 'r' for minimum distance between sample points. This approach enables spatially uniform distributions suitable for geometric modeling and procedural generation.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-pp_poisson3.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <pp/pp_poisson3.scad>\n\npoints = pp_poisson3([50, 50, 50], 10);\nfor(p = points) {\n    translate(p)\n        sphere(5, $fn = 48);\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Elements from Hashset in OpenSCAD\nDESCRIPTION: This snippet demonstrates how to use the `hashset_elems` function to get all elements from a hashset created using the `hashset` function. It requires importing both the `hashset.scad` and `hashset_elems.scad` modules. It creates a hashset from a list and then uses `hashset_elems` to retrieve the elements, asserting that the result matches the original list.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-hashset_elems.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/set/hashset.scad>\nuse <util/set/hashset_elems.scad>\n\ns = hashset([1, 2, 3, 4, 5]);\nassert(hashset_elems(s) == [1, 2, 3, 4, 5]);\n```\n\n----------------------------------------\n\nTITLE: Using Theta-Maze Cell Helper in OpenSCAD for Maze Geometry Generation\nDESCRIPTION: This example demonstrates the usage of the mz_theta_get helper function and related OpenSCAD libraries to calculate and render the geometry of walls in a theta-maze. Dependencies include mz_theta_cells, mz_theta_get, and polyline_join OpenSCAD files. Parameters such as rows, cell width, and starting index must be specified. The code iterates through maze cells, queries for each cell's row index (ri), column index (ci), and wall type, then relies on polar transformations and conditional logic to construct wall segments using polyline_join and circle geometries. Inputs are maze structure and rendering parameters; outputs are rendered maze wall segments. The code requires the external helper libraries to be present, and all parameters should be defined to achieve proper maze generation.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-mz_theta_get.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <maze/mz_theta_cells.scad>\nuse <maze/mz_theta_get.scad>\nuse <polyline_join.scad>\n\nrows = 8;\nbeginning_number = 8;\ncell_width = 10;\nwall_thickness = 2;\n\nfunction vt_from_angle(theta, r) = [r * cos(theta), r * sin(theta)];\n\nmaze = mz_theta_cells(rows, beginning_number);\nfor(rows = maze, cell = rows) {\n\tri = mz_theta_get(cell, \"r\");\n\tci = mz_theta_get(cell, \"c\");\n\ttype = mz_theta_get(cell, \"t\");\n\tthetaStep = 360 / len(maze[ri]);\n\tinnerR = (ri + 1) * cell_width;\n\touterR = (ri + 2) * cell_width;\n\ttheta1 = thetaStep * ci;\n\ttheta2 = thetaStep * (ci + 1);\n\t\n\tinnerVt1 = vt_from_angle(theta1, innerR);\n\tinnerVt2 = vt_from_angle(theta2, innerR);\n\touterVt2 = vt_from_angle(theta2, outerR);\n\t\n\tif(type == \"INWARD_WALL\" || type == \"INWARD_CCW_WALL\") {\n\t\tpolyline_join([innerVt1, innerVt2])\n\t\t\tcircle(wall_thickness / 2);\n\t}\n\n\tif(type == \"CCW_WALL\" || type == \"INWARD_CCW_WALL\") {\n\t\tpolyline_join([innerVt2, outerVt2])\n\t\t\tcircle(wall_thickness / 2);\n\t}\n}\n\nthetaStep = 360 / len(maze[rows - 1]);\nr = cell_width * (rows + 1);\nfor(theta = [0:thetaStep:360 - thetaStep]) {\n\tvt1 = vt_from_angle(theta, r);\n\tvt2 = vt_from_angle(theta + thetaStep, r);\n\tpolyline_join([vt1, vt2])\n\t\tcircle(wall_thickness / 2);\n} \n```\n\n----------------------------------------\n\nTITLE: Creating a smoother arc with increased fragment count in OpenSCAD\nDESCRIPTION: This example illustrates how to increase the number of fragments ('frags') to produce a more refined and smoother arc shape with the 'bend' module. It sets size parameters, applies the bend with a high fragment count (e.g., 360), and visualizes the resulting curved object through linear extrusion.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-bend.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <bend.scad>\n\nx = 9.25;\ny = 9.55;\nz = 1;\n\nbend(size = [x, y, z], angle = 270, frags = 360)\nlinear_extrude(z) text(\"A\");\n```\n\n----------------------------------------\n\nTITLE: Using hashmap_del OpenSCAD\nDESCRIPTION: Demonstrates the usage of `hashmap_del` in OpenSCAD. It imports the necessary modules, creates a sample hashmap, uses `hashmap_del` to remove a key, and then verifies the removal using `hashmap_get` and `assert`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-hashmap_del.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/map/hashmap.scad>;\nuse <util/map/hashmap_get.scad>;\nuse <util/map/hashmap_del.scad>;\n\nm1 = hashmap([[\"k1\", 10], [\"k2\", 20], [\"k3\", 30]]);\nm2 = hashmap_del(m1, \"k1\");\nassert(hashmap_get(m2, \"k1\") == undef);\n```\n\n----------------------------------------\n\nTITLE: Creating a 2D Star Polygon using shape_starburst in OpenSCAD\nDESCRIPTION: This example demonstrates how to use the `shape_starburst` function to generate the vertices for a 6-pointed star with an outer radius of 30 and an inner radius of 12. The generated points are then passed directly to the built-in OpenSCAD `polygon` module to create a flat, 2D star shape. It requires the `shape_starburst.scad` library to be included.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_starburst.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_starburst.scad>\n\npolygon(shape_starburst(30, 12, 6));\n```\n\n----------------------------------------\n\nTITLE: Extruding Concentric Circles along Golden Spiral (OpenSCAD)\nDESCRIPTION: This OpenSCAD snippet illustrates another application of `golden_spiral_extrude`, extruding a shape made of two concentric circles. It uses `shape_circle` to define the 2D profile (requires `shape_circle.scad`). The extrusion follows a golden spiral path from the 5th to 10th Fibonacci number, applying a large scale factor and setting `triangles` to \"HOLLOW\" for a shell-like structure. The `$fn` variable controls circle resolution. Requires `shape_circle.scad` and `golden_spiral_extrude.scad`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-golden_spiral_extrude.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_circle.scad>\n\tuse <golden_spiral_extrude.scad>\n\n\t$fn = 12;\n\n\tshape_pts = concat(\n\t\tshape_circle(radius = 3),\n\t\tshape_circle(radius = 2)\n\t);\n\n\tgolden_spiral_extrude(\n\t\tshape_pts,\n\t\tfrom = 5,\n\t\tto = 10,\n\t\tpoint_distance = 1,\n\t\tscale = 10,\n\t\ttriangles = \"HOLLOW\"\n\t);\n```\n\n----------------------------------------\n\nTITLE: Function Definition for tri_circumcenter in OpenSCAD\nDESCRIPTION: The snippet defines the tri_circumcenter function that computes and returns the coordinates of the circumcenter of a given 2D triangle based on its vertices. It requires the input vertices array and performs geometric calculations to find the center point; the output is a 2D coordinate. This function depends on basic geometric principles and is used within OpenSCAD scripts for positional calculations.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-tri_circumcenter.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nfunction tri_circumcenter(shape_pts) = \n    let (a = shape_pts[0], b = shape_pts[1], c = shape_pts[2]) \n    let (d = 2 * (a[0] * (b[1] - c[1]) +\n                 b[0] * (c[1] - a[1]) +\n                 c[0] * (a[1] - b[1]))) \n    [\n        ((a[0] * a[0] + a[1] * a[1]) * (b[1] - c[1]) + \n         (b[0] * b[0] + b[1] * b[1]) * (c[1] - a[1]) + \n         (c[0] * c[0] + c[1] * c[1]) * (a[1] - b[1])) / d,\n        ((a[0] * a[0] + a[1] * a[1]) * (c[0] - b[0]) + \n         (b[0] * b[0] + b[1] * b[1]) * (a[0] - c[0]) + \n         (c[0] * c[0] + c[1] * c[1]) * (b[0] - a[0])) / d\n    ]\n```\n\n----------------------------------------\n\nTITLE: Defining a Rounded Cylinder Module in OpenSCAD\nDESCRIPTION: This snippet shows how to use the rounded_cylinder module by importing it and specifying parameters like radius (single number or 2-element vector for bottom and top radius), height (h), and the rounding radius of edges (round_r). It demonstrates positional control over the cylinder's z-axis by center parameter and polygon resolution via convexity, $fa, $fs, and $fn variables. The snippet expects the user to have the rounded_cylinder.scad file available for inclusion and compiles a 3D model with rounded edges for enhanced aesthetics.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-rounded_cylinder.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <rounded_cylinder.scad>\n\nrounded_cylinder(\n\tradius = [20, 10], \n\th = 25, \n\tround_r = 3\n);\n```\n\n----------------------------------------\n\nTITLE: Solidifying Surfaces with sf_solidifyT Example\nDESCRIPTION: This OpenSCAD snippet demonstrates the usage of `sf_solidifyT` function to solidify two surfaces. It first generates a set of 2D points and triangulates them using `tri_delaunay`. Then, it creates two sets of 3D points, one above and one below. Finally, it calls `sf_solidifyT` to create a solid object using the generated points and triangles. The code requires the `triangle/tri_delaunay.scad` and `surface/sf_solidifyT.scad` libraries.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_solidifyT.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n    use <triangle/tri_delaunay.scad>\n    use <surface/sf_solidifyT.scad>\n\n    points = [for(i = [0:50]) rands(-300, 300, 2)]; \n    triangles = tri_delaunay(points);\n\n    pts = [for(p = points) [p.x, p.y, rands(100, 150, 1)[0]]];\n    pts2 = [for(p = pts) [p.x, p.y, p.z - 100]];\n\n    sf_solidifyT(pts, pts2, triangles = triangles);\n```\n\n----------------------------------------\n\nTITLE: Using rails2sections with Bezier Curve Rails in OpenSCAD\nDESCRIPTION: Generates four rails using the `bezier_curve` module with a specified step (`t_step`). These dynamically generated rails are then fed into the `rails2sections` module to create sections. The `sweep` module uses these sections for model generation, and the Bezier curve rails are visualized using `polyline_join`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-rails2sections.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <bezier_curve.scad>\nuse <rails2sections.scad>\nuse <polyline_join.scad>\nuse <sweep.scad>\n\nt_step = 0.05;\n\nrails = [\n    bezier_curve(t_step, \n        [[1.25, 0, 5], [5, 20, 5], [16, 20, -2], [18, 20, 10], [30, 15, 8]]\n    ),\n    bezier_curve(t_step, \n        [[-1.25, 0, 5], [0, 20, 5],  [16, 22, -2], [18, 20, 10], [30, 25, 8]]\n    ),\n    bezier_curve(t_step, \n        [[-1.25, 0, -5], [0, 20, -5], [16, 20, 1], [18, 27, -3], [20, 27, -5]]\n    ),\n    bezier_curve(t_step, \n        [[1.25, 0, -5], [5, 20, -5], [16, 20, 1], [18, 17.5, -3], [20, 17.5, -5]]\n    )\n];\n\n\nsections = rails2sections(rails);\n\nsweep(sections);\n\n#for(path = rails) {\n    polyline_join(path)\n\t    sphere(.25);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a mirror transformation matrix in OpenSCAD\nDESCRIPTION: This snippet defines the `m_mirror` function that constructs a 4x4 matrix to mirror an object across a plane specified by its normal vector `v`. The matrix can be passed into `multmatrix` to perform the mirror operation, enabling reflection of child objects on a specified plane through the origin. It includes example usage demonstrating the application of `multmatrix` and `rotate` on a cube, along with visual documentation.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-m_mirror.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# m_mirror\n\nGenerate a 4x4 transformation matrix which can pass into `multmatrix` to mirror the child element on a plane through the origin. \n\n**Since:** 1.1\n\n## Parameters\n\n- `v` : The normal vector of a plane intersecting the origin through which to mirror the object.\n\n## Examples\n\n\tuse <matrix/m_mirror.scad>\n\n\trotate([0, 0, 10]) \n\t\tcube([3, 2, 1]);\n\t\n\tmultmatrix(m_mirror([1, 1, 0]))\n\trotate([0, 0, 10]) \n\t\tcube([3, 2, 1]);\n\n![m_mirror](images/lib3x-m_mirror-1.JPG)\n```\n\n----------------------------------------\n\nTITLE: Generating Taiwan Shape Points for Extrusion in OpenSCAD\nDESCRIPTION: Defines the shape_taiwan module which returns the 2D boundary points of Taiwan as a list of coordinate pairs. The module accepts parameters 'h' for the height value (used for extrusion height) and 'distance' for optional simplification of points by filtering based on spatial proximity. These shape points serve as input to polygon or extrusion modules within dotSCAD. Dependencies include the dotSCAD environment and compatibility with polygon or extrusion modules such as xxx_extrude. The module simplifies shape detail if a distance threshold is specified, otherwise returns the full outline. Output is a list of 2D points usable directly for shape construction in 3D modeling.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_taiwan.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_taiwan.scad>\n\n// Basic polygon from Taiwan shape points with height 10\npolygon(shape_taiwan(10));\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_taiwan.scad>\nuse <golden_spiral_extrude.scad>\n\n// Mirror Taiwan shape points across the Y axis\nmirror_taiwan = [for(pt = shape_taiwan(15)) [pt[0] * -1, pt[1]]];\n\ngolden_spiral_extrude(\n\tmirror_taiwan, \n\tfrom = 1,  \n\tto = 10, \n\tpoint_distance = 2.5,\n\tscale = 10\n);\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_taiwan.scad>\nuse <helix_extrude.scad>\n\nr1 = 15;\nr2 = 100;\nlevels = 3;\nlevel_dist = 50;\n\nhelix_extrude(shape_taiwan(80), \n\tradius = [r1, r2], \n\tlevels = levels, \n\tlevel_dist = level_dist,\n\tvt_dir = \"SPI_DOWN\",\n\trt_dir = \"CLK\",\n\tscale = 0.1\n);\n```\n\n----------------------------------------\n\nTITLE: Thickening a Surface in OpenSCAD\nDESCRIPTION: Adds thickness to a surface defined by points, to produce volumetric shapes from flat surfaces. Useful in surface modeling; depends on surface functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_33\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nsurface/sf_thicken(points, thickness, ...)\n```\n\n----------------------------------------\n\nTITLE: Voxel Cylinder Point Generation Function in OpenSCAD\nDESCRIPTION: This code snippet defines a function that returns points to draw a voxel-style cylinder or cone, based on specified radii, height, fill state, and thickness. It is intended for use within OpenSCAD scripts to facilitate voxel modeling; dependencies include voxel or 3D modeling libraries, and parameters include radius, height, fill option, and thickness. The function outputs a list of points suitable for visualization or further processing.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_cylinder.md#_snippet_0\n\nLANGUAGE: scad\nCODE:\n```\n# vx_cylinder\n\nReturns points that can be used to draw a voxel-style cylinder.\n\n**Since:** 2.4\n\n## Parameters\n\n- `radius` : The radius of the cylinder. It also accepts a vector `[r1, r2]`. `r1` is the bottom radius and `r2` is the top radius of a cone. Values must be an integer.\n- `h` : The height of the cylinder or cone.\n- `filled` : Default to `false`. Set it `true` if you want a filled cylinder.\n- `thickness`: Default to 1. The thickness when `filled` is `false`. The value must be an integer.\n\n## Examples\n\n\tuse <voxel/vx_cylinder.scad>\n\n\tfor(pt = vx_cylinder([10, 15], 10)) {\n\t\ttranslate(pt)\n\t\t\tcube(1, center = true);\n\t}\n\n![vx_cylinder](images/lib3x-vx_cylinder-1.JPG)\n\n\tuse <voxel/vx_cylinder.scad>\n\n\tfor(pt = vx_cylinder([20, 15], h = 10, thickness = 3)) {\n\t\ttranslate(pt)\n\t\t\tcube(1, center = true);\n\t}\n\n![vx_cylinder](images/lib3x-vx_cylinder-2.JPG)\n```\n\n----------------------------------------\n\nTITLE: Using ptf_bend to Arc Text in OpenSCAD\nDESCRIPTION: This OpenSCAD example demonstrates how to use the `ptf_bend` function to arrange points representing characters of a string (`t`) along an arc. It iterates through the characters, retrieves their point representations using `vx_ascii`, applies the `ptf_bend` transformation with specified size, radius, and angle, and then places a small sphere at each transformed point. Requires `voxel/vx_ascii.scad` and `ptf/ptf_bend.scad` modules.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-ptf_bend.md#_snippet_0\n\nLANGUAGE: openscad\nCODE:\n```\nuse <voxel/vx_ascii.scad>\nuse <ptf/ptf_bend.scad>\n\nt = \"dotSCAD\";\nsize = [len(t) * 8, 8];\nradius = 20;\nangle = 180;\n\nfor(i = [0:len(t) - 1], pt = vx_ascii(t[i], invert = true)) {\n    bended = ptf_bend(size, pt + [i * 8, 0], radius, angle);\n    translate(bended)\n        sphere(0.5, $fn = 24);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Points and Rendering Polyline with archimedean_spiral in OpenSCAD\nDESCRIPTION: This snippet demonstrates how to generate a sequence of points and angles on an Archimedean spiral using the archimedean_spiral function, and renders them into a 2D polyline using the polyline2d module. It requires the archimedean_spiral.scad and polyline2d.scad libraries to be included. The user sets arm_distance, init_angle, point_distance, and num_of_points to control spiral geometry and sampling, and the polyline2d function takes the extracted points to visualize the spiral. Output is a spiral polyline with nearly constant spacing between points.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-archimedean_spiral.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline2d.scad>\nuse <archimedean_spiral.scad>\n\npoints_angles = archimedean_spiral(\n    arm_distance = 10,\n    init_angle = 180,\n    point_distance = 5,\n    num_of_points = 100 \n); \n\npoints = [for(pa = points_angles) pa[0]];\n\npolyline2d(points, width = 1);\n```\n\n----------------------------------------\n\nTITLE: sf_thicken with Direction Vector\nDESCRIPTION: Shows how to specify a direction vector for the thickening process using sf_thicken. This example generates a surface based on a simple function and then thickens it in a specific direction. It requires sf_thicken.scad and demonstrates directional thickening.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_thicken.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n\tuse <surface/sf_thicken.scad>\n\n\tfunction f(x, y) = x + y;\n\n\tthickness = 20;\n\tmin_value = -50;\n\tmax_value = 50;\n\tresolution = 5;\n\n\tsurface1 = [\n\t\tfor(y = [min_value:resolution:max_value])\n\t\t[\n\t\t\tfor(x = [min_value:resolution:max_value]) \n\t\t\t\t[x, y, f(x, y) + 100]\n\t\t]\n\t];\n\tsf_thicken(surface1, thickness, direction = [1, 1, -1]);\n```\n\n----------------------------------------\n\nTITLE: Using bend_extrude Module with Text in OpenSCAD\nDESCRIPTION: Shows how to use the bend_extrude module to transform a 2D text object into a curved 3D object with specified thickness and bend angle.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-bend_extrude.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <bend_extrude.scad>\n\nx = 9.25;\ny = 9.55;\n\nbend_extrude(size = [x, y], thickness = 1, angle = 270) \n\ttext(\"A\");\n```\n\n----------------------------------------\n\nTITLE: Transposing a Matrix Using m_transpose in OpenSCAD\nDESCRIPTION: This snippet illustrates importing the m_transpose module and using the m_transpose function in OpenSCAD to transpose a given matrix. The example creates an original matrix, defines the expected transposed result, computes the actual transposed matrix using m_transpose, and asserts that the result matches the expectation. Requires OpenSCAD 3.1 or later and the matrix/m_transpose.scad file available in the include path.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-m_transpose.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <matrix/m_transpose.scad>;\n\noriginal_m = [\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10, 11, 12]\n];\n\ntraget = [\n    [1, 5, 9],\n    [2, 6, 10],\n    [3, 7, 11],\n    [4, 8, 12]\n];\n\ntransposed = m_transpose(original_m);\n\nassert(transposed == traget);\n```\n\n----------------------------------------\n\nTITLE: Using multi_line_text Module in OpenSCAD\nDESCRIPTION: This snippet demonstrates how to generate a block of multi-line text in OpenSCAD using the multi_line_text module. The function accepts a list of text lines and multiple parameters including line_spacing, valign, and halign, where line_spacing determines the vertical distance between lines, and valign/halign specifies vertical and horizontal alignment. The input is a list of strings, and the output is a rendered text object composed of those lines, spaced and aligned as specified. Requires inclusion of multi_line_text.scad and OpenSCAD 2015 or newer for the text() function.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-multi_line_text.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <multi_line_text.scad>;\n\nmulti_line_text(\n\t[\"Welcome\", \"to\", \"Taiwan\"],\n\tline_spacing = 15,    \n\tvalign = \"center\", \n\thalign = \"center\"\n);\n```\n\n----------------------------------------\n\nTITLE: Basic Superformula 2D Shapes in OpenSCAD\nDESCRIPTION: Demonstrates how to create various 2D Superformula shapes using the shape_superformula function and polygon module. Different parameter combinations generate distinct geometric patterns.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_superformula.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_superformula.scad>   \n    \nphi_step = 0.05;\n\npolygon(shape_superformula(phi_step, 3, 3, 4.5, 10, 10));\n\ntranslate([3, 0]) \n    polygon(shape_superformula(phi_step, 4, 4, 12, 15, 15));\n\ntranslate([6, 0]) \n    polygon(shape_superformula(phi_step, 7, 7, 10, 6, 6));\n\ntranslate([9, 0]) \n    polygon(shape_superformula(phi_step, 5, 5, 4, 4, 4));\n    \ntranslate([0, -4]) \nscale(0.8) \n    polygon(shape_superformula(phi_step, 5, 5, 2, 7, 7));\n\ntranslate([3, -4]) \nscale(0.25) \n    polygon(shape_superformula(phi_step, 5, 5, 2, 13, 13));\n\ntranslate([6, -4]) \n    polygon(shape_superformula(phi_step, 4, 4, 1, 1, 1));\n\ntranslate([9, -4]) \nscale(0.3) \n    polygon(shape_superformula(phi_step, 4, 4, 1, 7, 8));\n```\n\n----------------------------------------\n\nTITLE: Creating a Single-Ended Connector Peg and Void in OpenSCAD\nDESCRIPTION: Demonstrates using the `connector_peg` module from `part/connector_peg.scad` to create a standard (single-ended) connector peg and its corresponding void (cavity). It defines `radius` and `spacing`, sets the fragment number `$fn`, and calls `connector_peg` for the peg, and again with `void = true` (using `%` for visual debugging) to create the void.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-connector_peg.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <part/connector_peg.scad>\n\nradius = 2.5;\nspacing = 0.5;\n\n$fn = 48;\n\nconnector_peg(\n    radius = radius, \n    spacing = spacing\n);\n\n%connector_peg(\n    radius = radius, \n    spacing = spacing,\n    void = true\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Sierpinski Triangle using t2d\nDESCRIPTION: Implementation of a Sierpinski triangle fractal using the t2d turtle graphics module. The code recursively generates triangles at different scales, demonstrating complex pattern generation with turtle graphics.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-t2d.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline_join.scad>\nuse <turtle/t2d.scad>\n\nside_leng = 100;\nmin_leng = 4;\nthickness = 0.5; \n\nsierpinski_triangle(\n    t2d(point = [0, 0], angle = 0),\n    side_leng, min_leng, thickness, $fn = 3\n);\n\nmodule triangle(t, side_leng, thickness) {    \n    t2 = t2d(t, \"forward\", leng = side_leng);\n    t3 = t2d(t2, [\n        [\"turn\", 120],\n        [\"forward\", side_leng]\n    ]);\n\n    polyline_join([for(turtle = [t, t2, t3, t]) t2d(turtle, \"point\")]) \n\t    circle(thickness / 2);\n}\n\nmodule sierpinski_triangle(t, side_leng, min_leng, thickness) {\n    triangle(t, side_leng, thickness);\n\n    if(side_leng >= min_leng) { \n        half_leng = side_leng / 2;\n        t2 = t2d(t, \"forward\", leng = half_leng); \n        t3 = t2d(t, [\n            [\"turn\", 60],\n            [\"forward\", half_leng],\n            [\"turn\", -60]\n        ]);\n\n        for(turtle = [t, t2, t3]) {\n            sierpinski_triangle(turtle, half_leng, min_leng, thickness);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Triangle Incenter with tri_incenter in OpenSCAD\nDESCRIPTION: The tri_incenter function accepts the vertices of a 2D or 3D triangle and returns the coordinates of its incenter, the point where the angle bisectors intersect. It requires the input as a list of three points representing the triangle vertices, and outputs a coordinate vector of the incenter location. This function is useful for geometric computations involving triangles in OpenSCAD. Dependencies include the OpenSCAD environment with the triangle library. Input: list of three 2D or 3D points; output: coordinate vector of the incenter. Assumes the input points form a valid triangle.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-tri_incenter.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <triangle/tri_incenter.scad>\n\nassert(tri_incenter([[0, 0], [15, 0], [0, 20]]) ==  [5, 5]);\n```\n\n----------------------------------------\n\nTITLE: Importing and Using the flat Function in OpenSCAD\nDESCRIPTION: This example demonstrates how to import the flat utility and use it with various nested list structures. The code shows flattening at different depth levels (default 1, explicit 2, and explicit 3).\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-flat.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/flat.scad>\n\nvt = [[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]];\n\nassert(\n\tflat([1, 2, [3, 4]]) == [1, 2, 3, 4]\n);\n\nassert(\n\tflat([[1, 2], [3, 4]]) == [1, 2, 3, 4]\n);\n\nassert(\n\tflat([[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]]) == [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n);\n\nassert(\n\tflat([[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]], 2) == [[1, 2], [3, 4], [5, 6], [7, 8]]\n);\n\nassert(\n\tflat([[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]], 3) == [1, 2, 3, 4, 5, 6, 7, 8]\n);\n```\n\n----------------------------------------\n\nTITLE: Spiral Text Rendering with archimedean_spiral and Custom Text in OpenSCAD\nDESCRIPTION: In this advanced example, the archimedean_spiral function is used to generate a path for placing characters of a long numeric string (representing pi) along a spiral. Each character is positioned at a computed point and rotated to align with the spiral angle plus 90 degrees, thus maintaining a readable orientation. Required dependencies are archimedean_spiral.scad and OpenSCAD's built-in text module. Parameters allow user control over spiral geometry and the length of text mapped along the spiral; outputs a spiraling sequence of text elements each centered at their respective spiral locations.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-archimedean_spiral.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <archimedean_spiral.scad>\n\nt = \"3.141592653589793238462643383279502884197169399375105820974944592307816406286\";\n\npoints_angles = archimedean_spiral(\n    arm_distance = 15,\n    init_angle = 450, \n    point_distance = 12, \n    num_of_points = len(t) \n); \n\nfor(i = [0: len(points_angles) - 1]) {\n    translate(points_angles[i][0])          \n    rotate(points_angles[i][1] + 90)  \n        text(t[i], valign = \"center\", halign = \"center\");\n}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of the Curved Line Module in OpenSCAD\nDESCRIPTION: Demonstrates how to define control points, set curve parameters, generate the curve points, and visualize the curve with spheres at points using OpenSCAD. The example showcases practical application, with control points in 3D space and different visual markers to understand the curve's shape. Dependencies include 'curve.scad' and 'polyline_join.scad'.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-curve.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <curve.scad>\nuse <polyline_join.scad>\n\npts = [\n    [28, 2, 1],\n    [15, 8, -10],\n    [2, 14, 5],\n    [28, 14, 2],\n    [15, 21, 9],\n    [2, 28, 0]\n];\n\nt_step = 0.05;\n\n// Generate the curve points\npoints = curve(t_step, pts, 0);\n\n// Render the curve as a polyline with small spheres\npolyline_join(points)\n    sphere(0.5);\n\n// Visualize control points with larger spheres\nfor(pt = pts) {\n    translate(pt)\n        sphere(1);\n}\n\n// Optionally, connect control points with small spheres\n// polyline_join(pts)\n//     sphere(0.05);\n```\n\n----------------------------------------\n\nTITLE: Creating a Connector Peg in OpenSCAD\nDESCRIPTION: Creates a connector peg with specified radius and height, with optional spacing, void, and end features for modular assembly models. Uses part library functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_23\n\nLANGUAGE: OpenSCAD\nCODE:\n```\npart/connector_peg(radius, height[, spacing, void, ends])\n```\n\n----------------------------------------\n\nTITLE: Extracting Substrings with sub_str in OpenSCAD\nDESCRIPTION: This snippet demonstrates the use of the sub_str function to extract substrings from a given string, with support for specifying the starting and (optional) ending indices. It requires the util/sub_str.scad library to be imported. The function accepts a string parameter 't', a beginning index 'begin', and optionally an ending index 'end'. The returned value is a substring from 'begin' (inclusive) up to 'end' (exclusive) or to the string's end when 'end' is omitted. Example assertions validate correct functionality.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sub_str.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/sub_str.scad>\n\nassert(sub_str(\"helloworld\", 0, 5) == \"hello\");\nassert(sub_str(\"helloworld\", 5) == \"world\");\n```\n\n----------------------------------------\n\nTITLE: Solidifying Surfaces with sf_solidifyT and Function\nDESCRIPTION: This OpenSCAD snippet provides a more advanced example of using `sf_solidifyT`. It defines a function `f(x, y)` and generates 2D points in a loop. It then uses the function to compute the Z coordinates for two sets of 3D points. Finally, it calls `sf_solidifyT` using these points and the triangles generated by `tri_delaunay` to create the solid. This example demonstrates the flexibility of the function in creating complex shapes. The example depends on `triangle/tri_delaunay.scad` and `surface/sf_solidifyT.scad` libraries.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_solidifyT.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n    use <triangle/tri_delaunay.scad>\n    use <surface/sf_solidifyT.scad>\n\n    thickness = .2;\n    a_step = 15;\n    r_step = 0.2;\n    scale = 100;\n\n    function f(x, y) = (y ^ 2 - x ^ 2) / 4;\n\n    pts2d = [\n        for(a = [a_step:a_step:360], r = [r_step:r_step:2])\n        let(\n            x = r * cos(a), \n            y = r * sin(a)\n        )\n        [x, y] \n    ];\n\n    points1 = [for(p = pts2d) scale * [p.x, p.y, f(p.x, p.y)]];\n    points2 = [for(p = points1) [p.x, p.y, p.z - scale * thickness]];\n    triangles = tri_delaunay(pts2d);\n\n    sf_solidifyT(points1, points2, triangles);\n```\n\n----------------------------------------\n\nTITLE: Translating and Creating a Spherical Wedge with Custom Angles in OpenSCAD\nDESCRIPTION: This snippet translates a crystal ball instance to position [24, 0, 0] and creates a spherical segment with theta = 270 and phi = 90, both defining the angular cutoff in azimuth and polar directions. The $fn parameter specifies the sphere smoothness. Both 'theta' and 'phi' can accept either scalars or two-element vectors for angular bounds. The module must be imported before use.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-crystal_ball.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\ntranslate([24, 0, 0]) \n\tcrystal_ball(\n\t\tradius = 6, \n\t\ttheta = 270,\n\t\tphi = 90,\n\t\t$fn = 12\n\t);\n```\n\n----------------------------------------\n\nTITLE: Generate Uniform B-spline Curve (OpenSCAD)\nDESCRIPTION: Demonstrates basic usage of the `bspline_curve` module to generate a B-spline curve using a set of control points and default uniform knots. It visualizes the control points in red spheres and the curve points as smaller spheres.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-bspline_curve.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <bspline_curve.scad>\n    \n\tpoints = [\n\t\t[-10, 0],\n\t\t[-5,  5],\n\t\t[ 5, -5],\n\t\t[ 10, 0]\n\t];\n\n\tcolor(\"red\") for(p = points) {\n\t\ttranslate(p) \n\t\t\tsphere(0.5);\n\t}\n\n    // knots: [0, 1, 2, 3, 4, 5, 6]\n\t// weights: [1, 1, 1, 1]\n\tfor(p = bspline_curve(0.01, 2, points)) {\n\t\ttranslate(p) \n\t\t\tsphere(0.1);\n\t}\n```\n\n----------------------------------------\n\nTITLE: Creating a 3D Hilbert Curve using lsystem3 in OpenSCAD\nDESCRIPTION: This example generates a 3D Hilbert curve by defining an L-system with specific rules and rendering it with polyline_join and spheres at each vertex. It uses a recursive grammar with 4 production rules and default iteration depth of 3.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-lsystem3.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <turtle/lsystem3.scad>\nuse <polyline_join.scad>\n\nfor(line = hilbert_curve()) {\n\tpolyline_join([line[0], line[1]])\n\t    sphere(.25, $fn = 4);\n}  \n\nfunction hilbert_curve(n = 3, angle = 90, leng = 1, heading = 0, start = [0, 0, 0]) = \n\tlet(\n\t\taxiom = \"A\",\n\t\trules = [\n\t\t\t[\"A\", \"B-F+CFC+F-D&F^D-F+&&CFC+F+B//\"],\n\t\t\t[\"B\", \"A&F^CFB^F^D^^-F-D^|F^B|FC^F^A//\"],\n\t\t\t[\"C\", \"|D^|F^B-F+C^F^A&&FA&F^C+F+B^F^D//\"],\n\t\t\t[\"D\", \"|CFB-F+B|FA&F^A&&FB-F+B|FC//\"]\n\t\t]\n\t)\n\tlsystem3(axiom, rules, n, angle, leng, heading, start);\n```\n\n----------------------------------------\n\nTITLE: Path Generation Functions for Geometric Shapes in OpenSCAD (DotSCADE Library)\nDESCRIPTION: This collection provides functions to create and manipulate various paths around geometric objects such as arcs, spirals, spheres, and knots. They are designed for use in modeling complex curves and paths in 3D space, often serving as trajectories for extrusions or animations. Dependencies include the specific base functions documented with URLs. Examples include 'arc_path', 'archimedean_spiral', 'sphere_spiral', and 'torus_knot'.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**arc_path**(radius, angle)](https://openhome.cc/eGossip/OpenSCAD/lib3x-arc_path.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**archimedean_spiral**(arm_distance, init_angle, point_distance, num_of_points[, rt_dir])](https://openhome.cc/eGossip/OpenSCAD/lib3x-archimedean_spiral.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**bauer_spiral**(n, radius = 1[, rt_dir])](https://openhome.cc/eGossip/OpenSCAD/lib3x-bauer_spiral.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**bezier_curve**(t_step, points)](https://openhome.cc/eGossip/OpenSCAD/lib3x-bezier_curve.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**bspline_curve**(t_step, degree, points, knots, weights)](https://openhome.cc/eGossip/OpenSCAD/lib3x-bspline_curve.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**curve**(t_step, points[, tightness])](https://openhome.cc/eGossip/OpenSCAD/lib3x-curve.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**fibonacci_lattice**(n, radius = 1[, dir])](https://openhome.cc/eGossip/OpenSCAD/lib3x-fibonacci_lattice.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**golden_spiral**(from, to, point_distance[, rt_dir)]](https://openhome.cc/eGossip/OpenSCAD/lib3x-golden_spiral.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**helix**(radius, levels, level_dist[, vt_dir, rt_dir])](https://openhome.cc/eGossip/OpenSCAD/lib3x-helix.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**sphere_spiral**(radius, za_step[, z_circles, begin_angle, end_angle, ...]) ](https://openhome.cc/eGossip/OpenSCAD/lib3x-sphere_spiral.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**torus_knot**(p, q, phi_step)](https://openhome.cc/eGossip/OpenSCAD/lib3x-torus_knot.html)\n```\n\n----------------------------------------\n\nTITLE: Creating a Box with Text in OpenSCAD\nDESCRIPTION: This OpenSCAD snippet creates a 3D box from text using the `box_extrude` function. It specifies a height of 30 and a shell thickness of 2. The `text` function is used to define the 2D shape, displaying \"XD\" with a size of 40 and using the \"Cooper Black\" font.  No additional dependencies are required besides the `box_extrude.scad` library.  The expected output is a 3D box based on the provided text.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-box_extrude.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <box_extrude.scad>\n\n\tbox_extrude(height = 30, shell_thickness = 2) \n\t    text(\"XD\", size = 40, font = \"Cooper Black\");\n```\n\n----------------------------------------\n\nTITLE: Extruding a Starburst Shape along a Golden Spiral in OpenSCAD\nDESCRIPTION: This snippet shows how to first generate points for an 8-pointed starburst shape using `shape_starburst` with an outer radius of 5 and inner radius of 2. These points (`shape_pts`) are then used as the profile for extrusion along a golden spiral path using the `golden_spiral_extrude` module. This example requires including both the `shape_starburst.scad` and `golden_spiral_extrude.scad` libraries.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_starburst.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_starburst.scad>\nuse <golden_spiral_extrude.scad>\n\nshape_pts = shape_starburst(5, 2, 8);\n\ngolden_spiral_extrude(\n    shape_pts, \n    from = 5, \n    to = 10, \n    point_distance = 1,\n    scale = 10\n);\n```\n\n----------------------------------------\n\nTITLE: Sorting a List with Custom Comparison Function in OpenSCAD\nDESCRIPTION: This snippet uses a custom comparison function `cmp` to sort a list of lists based on the first element of each sublist. The comparison function subtracts the first element of the first list from the first element of the second list.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sorted.md#_snippet_6\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nassert(\n    [[2, 0, 0], [5, 0, 0], [7, 0, 0], [9, 0, 0], [10, 0, 0]] == \n    sorted([[10, 0, 0], [5, 0, 0], [7, 0, 0], [2, 0, 0], [9, 0, 0]], cmp = function(a, b) a[0] - b[0])\n);\n```\n\n----------------------------------------\n\nTITLE: Creating 3D Line with Butt End-caps in OpenSCAD\nDESCRIPTION: Creates a 3D line with flat ends (CAP_BUTT style) at both endpoints. Demonstrates how to specify different end-cap styles while maintaining the same line positioning and diameter.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-line3d.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <line3d.scad>\n\nline3d(\n    p1 = [0, 0, 0], \n    p2 = [10, 2, 10], \n    diameter = 1, \n    p1Style = \"CAP_BUTT\", \n    p2Style = \"CAP_BUTT\",\n    $fn = 24\n);\n```\n\n----------------------------------------\n\nTITLE: Example Usage of vrn3_space Module in OpenSCAD\nDESCRIPTION: Demonstrates how to call the `vrn3_space` module to generate a Voronoi diagram. It requires including the module file (`voronoi/vrn3_space.scad`) using the `use` statement. The `vrn3_space` function is then called with specific parameters for the overall size (`size` as a 3-element vector) and the grid width (`grid_w`). Optional parameters like `seed` and `spacing` are omitted, using their default values.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vrn3_space.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voronoi/vrn3_space.scad>\n\nvrn3_space(\n    size = [20, 15, 10],\n    grid_w = 5\n);\n```\n\n----------------------------------------\n\nTITLE: Generating and Visualizing Circle Path Points in OpenSCAD\nDESCRIPTION: This snippet shows how to use the 'circle_path' function to obtain a list of points defining a circle. It then demonstrates two ways to use these points: creating a polygon from the points and iterating through them to place and orient text labels along the path, illustrating point distribution and tangent direction.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-circle_path.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <circle_path.scad>\n\n\t$fn = 24;\n\t\n\tpoints = circle_path(radius = 50);\n\tpolygon(points);\n\t\nleng = len(points);\n\tstep_angle = 360 / leng;\n\tfor(i = [0:leng - 1]) {\n\t    translate(points[i]) \n\t\trotate([90, 0, 90 + i * step_angle]) \n\t\tlinear_extrude(1, center = true) \n\t\t\ttext(\"A\", valign = \"center\", halign = \"center\");\n\t}\n```\n\n----------------------------------------\n\nTITLE: Sorting with Key Extraction in OpenSCAD\nDESCRIPTION: This snippet demonstrates sorting a list of lists using a key extraction function. The key function `function(elem) elem.x` extracts the `x` property from each element (which are lists in this case), and the sorting is performed based on these extracted keys. Note that `elem.x` will not work, the correct syntax is `elem[0]`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sorted.md#_snippet_9\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nassert(\n    [[2, 0, 0], [5, 0, 0], [7, 0, 0], [9, 0, 0], [10, 0, 0]] == \n    sorted([[10, 0, 0], [5, 0, 0], [7, 0, 0], [2, 0, 0], [9, 0, 0]], key = function(elem) elem.x)\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Equality Function in OpenSCAD\nDESCRIPTION: This snippet defines an equality function `eq`. This function compares two vectors element-wise. It takes two vectors, `e1` and `e2`, as input and returns `true` if all corresponding elements are equal and `false` otherwise. This function is used as a parameter when calling the `dedup` function for custom vector comparison. It ensures vectors with the same components are considered duplicates, enhancing the deduplication process.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-dedup.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\neq = function(e1, e2) e1[0] == e2[0] && e1[1] == e2[1] && e1[2] == e2[2];\n```\n\n----------------------------------------\n\nTITLE: shape_pie Example with polygon\nDESCRIPTION: Demonstrates how to use the shape_pie module to create a pie shape and then use the polygon module to render it.  It includes the necessary 'use' statement to import the shape_pie module.  The shape_pts variable stores the result of the shape_pie function call, which is then passed to the polygon function.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_pie.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n\tuse <shape_pie.scad>\n\t\n\tshape_pts = shape_pie(10, [45, 315], $fn = 24);\n    polygon(shape_pts);\n```\n\n----------------------------------------\n\nTITLE: Using the Select Module for Conditional Object Creation in OpenSCAD\nDESCRIPTION: This snippet demonstrates how to use the `select` module from the `select.scad` library. It imports the module and then uses the `select(i)` syntax with an index `i`. The objects listed within the `select` block are implicitly indexed starting from 0, and only the object corresponding to the provided index `i` is rendered. This offers a more concise alternative to nested if/else if statements.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-select.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <select.scad>\n\ni = 0;\n\nselect(i) {\n\tsphere(1);\n\tcube(1);\n\tcylinder(1, 1);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating List Swap in OpenSCAD\nDESCRIPTION: This snippet provides an example usage of the `swap` function. It demonstrates how to include the utility file and use the `swap` function to swap elements at specific indices (1 and 3) in a list. It includes an `assert` statement to verify that the function returns the expected result.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-swap.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/swap.scad>\n\nassert(swap([10, 20, 30, 40], 1, 3) == [10, 40, 30, 20]);\n```\n\n----------------------------------------\n\nTITLE: Creating an Inward Arc in OpenSCAD\nDESCRIPTION: Illustrates creating an arc using the `arc` module with `width_mode` set to \"LINE_INWARD\". This mode makes the arc extend inwards from the specified radius by the given width. Requires the `arc.scad` library. `$fn` is used to define the resolution of the arc.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-arc.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <arc.scad>\n\n$fn = 24;\narc(radius = 20, angle = [45, 290], width = 2, width_mode = \"LINE_INWARD\");\n%circle(r = 20);\n```\n\n----------------------------------------\n\nTITLE: Generating Hexagonal Maze Walls with mz_hexwalls in OpenSCAD\nDESCRIPTION: This snippet illustrates the use of the 'mz_hexwalls' function to create maze wall data based on square maze cells, incorporating parameters for cell dimensions and border options. It then visualizes the walls by joining polylines and adding circular profiles representing wall thickness, useful for rendering maze walls in 3D models.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-mz_hexwalls.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nrows = 10;\ncolumns = 12;\ncell_width = 5;\nwall_thickness = 2;\n\ncells = mz_square(rows, columns);\n\nwalls = mz_hexwalls(cells, cell_width);\n\nfor(wall = walls) {\n\tpolyline_join(wall)\n\t\tcircle(wall_thickness, $fn = 24);\n}\n```\n\n----------------------------------------\n\nTITLE: Generate Non-uniform B-spline Curve (OpenSCAD)\nDESCRIPTION: Illustrates how to generate a non-uniform B-spline curve by providing a custom `knots` vector. The example uses the same control points but specifies a non-uniform sequence for the knots, altering the shape of the resulting curve. Control points are shown in red, and curve points are displayed.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-bspline_curve.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <bspline_curve.scad>\n    \n\tpoints = [\n\t\t[-10, 0],\n\t\t[-5,  5],\n\t\t[ 5, -5],\n\t\t[ 10, 0]\n\t];\n\n    // a non-uniform B-spline curve\n    knots = [0, 1/8, 1/4, 1/2, 3/4, 4/5, 1];\n    \n\tcolor(\"red\") \n\tfor(p = points) {\n\t\ttranslate(p) \n\t\t\tsphere(0.5);\n\t}\n\n\tfor(p = bspline_curve(0.01, 2, points, knots)) {\n\t\ttranslate(p) \n\t\t\tsphere(0.1);\n\t}\n```\n\n----------------------------------------\n\nTITLE: Creating a Turtle Spiral using t2d with separate commands\nDESCRIPTION: Demonstrates creating a spiral pattern using the t2d turtle graphics module with separate turn and forward commands. The recursive function draws line segments between points as the turtle moves.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-t2d.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <line2d.scad>\nuse <turtle/t2d.scad>\n\nmodule turtle_spiral(t, times, side_leng, angle, width) {\n    $fn = 24;\n    if(times != 0) {\n        t1 = t2d(t, \"turn\", angle = angle);\n        t2 = t2d(t1, \"forward\", leng = side_leng);\n\n        line2d(\n            t2d(t, \"point\"),\n            t2d(t2, \"point\"),\n            width,\n            p1Style = \"CAP_ROUND\", \n            p2Style =  \"CAP_ROUND\"\n        );\n\n        turtle_spiral(t2, times - 1, side_leng, angle, width);\n    }\n\n}\n\nturtle_spiral(\n    t2d(point = [0, 0], angle = 0), \n    times = 5, \n    side_leng = 10, \n    angle = 144, \n    width = 1\n);\n```\n\n----------------------------------------\n\nTITLE: Generating Squares using vx_gray - dotscad\nDESCRIPTION: This dotscad code snippet uses the vx_gray function to generate a list of dots (positions). For each dot, the code translates the coordinate space and draws a square. Dependencies: The code depends on the `vx_gray` function and the `translate` and `square` commands which are part of the dotscad library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_gray.md#_snippet_2\n\nLANGUAGE: dotscad\nCODE:\n```\ndots = vx_gray(levels, center = true, normalize = true);\n    for(dot = dots) {\n        translate(dot[0]) \n            square(dot[1]);\n    }\n```\n\n----------------------------------------\n\nTITLE: Basic sf_thicken Example\nDESCRIPTION: Demonstrates the basic usage of the sf_thicken function with a simple set of 3D points and a specified thickness.  The example shows how to create a thickened surface from a predefined array of points. It depends on the sf_thicken.scad library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_thicken.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n\tuse <surface/sf_thicken.scad>\n\n\tpoints = [\n\t\t[[0, 0, 1], [1, 0, 2.5], [2, 0, 2], [3, 0, 2.5]],\n\t\t[[0, 1, 1], [1, 1, 2], [2, 1, 1], [3, 1, 2]],\n\t\t[[0, 2, 1], [1, 2, 2.3], [2, 2, 2], [3, 2, 2.2]],\n\t\t[[0, 3, 1], [1, 3, 2], [2, 3, 1], [3, 3, 2]]\n\t];\n\n\tthickness = 0.25;\n\n\tsf_thicken(points, thickness);\n```\n\n----------------------------------------\n\nTITLE: Using the crystal_ball Module in OpenSCAD\nDESCRIPTION: This snippet demonstrates a basic invocation of the crystal_ball module in OpenSCAD to create a solid sphere with default angular extents and specified radius. It requires that the crystal_ball.scad file is available and imported. The only parameter specified is 'radius', which defines the size of the sphere. The result is a full crystal ball centered at the origin. No transformations or additional shape segmentation is performed.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-crystal_ball.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <crystal_ball.scad>\n\ncrystal_ball(radius = 6);\n```\n\n----------------------------------------\n\nTITLE: Translating and Creating a Hollow Crystal Ball Segment in OpenSCAD\nDESCRIPTION: This snippet showcases the creation of a crystal ball segment with specified angular extent (theta = 270) and shell thickness (thickness = 1), translated along the X-axis. The $fn parameter controls the detail level of the spherical surface. It requires importing crystal_ball.scad. The resulting object is a partial sphere located at [12, 0, 0] with a shell thickness of 1 unit.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-crystal_ball.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\ntranslate([12, 0, 0]) \n\tcrystal_ball(\n\t\tradius = 6, \n\t\ttheta = 270,\n\t\tthickness = 1,\n\t\t$fn = 12\n\t);\n```\n\n----------------------------------------\n\nTITLE: Generating a Surface from Levels and a Curve Path in OpenSCAD\nDESCRIPTION: Uses the `sf_curve` function to generate a 3D surface. It requires pre-defined `levels` data (likely defining cross-sections), the `curve_path` generated by `bezier_curve`, and parameters for `thickness`, `depth`, and an `invert` boolean flag. This function likely creates a shape by sweeping the `levels` profiles along the `curve_path`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_curve.md#_snippet_1\n\nLANGUAGE: openscad\nCODE:\n```\nsf_curve(levels, curve_path, thickness, depth, invert);\n```\n\n----------------------------------------\n\nTITLE: Generating Square Maze Cell Data Using mz_square in OpenSCAD\nDESCRIPTION: This snippet shows how to call the mz_square function to generate a square maze's cell data as a 2D list, where each cell is represented as [x, y, type]. It defines constants for wall types and uses the cell data to draw walls using line2d calls. The snippet demonstrates iterating over cells to translate and draw top and right walls accordingly. Inputs include rows, columns, and cell dimensions, and the output is a visual maze representation. Dependencies include the mz_square and line2d modules in OpenSCAD.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-mz_square.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <maze/mz_square.scad>\nuse <line2d.scad>\n\nrows = 10;\ncolumns = 10;\ncell_width = 5;\nwall_thickness = 2;\n\nNO_WALL = 0;       \nTOP_WALL = 1;    \nRIGHT_WALL = 2;    \nTOP_RIGHT_WALL = 3; \nMASK = 4;\n\ncells = mz_square(rows, columns);\n\nfor(row = cells, cell = row) {\n\ttype = cell[2];\n\t\n\ttranslate([cell.x, cell.y] * cell_width) {\n\t\tif(type == TOP_WALL || type == TOP_RIGHT_WALL) {\n\t\t\tline2d([0, cell_width], [cell_width, cell_width], wall_thickness);\n\t\t}\n\t\t\n\t\tif(type == RIGHT_WALL || type == TOP_RIGHT_WALL) {\n\t\t\tline2d([cell_width, cell_width], [cell_width, 0], wall_thickness);\n\t\t}\t\n\t}\n}\n\nline2d([0, 0], [cell_width * columns, 0], wall_thickness);\nline2d([0, 0], [0, cell_width * rows], wall_thickness);\n```\n\n----------------------------------------\n\nTITLE: Creating a Double-Ended Connector Peg and Void in OpenSCAD\nDESCRIPTION: Shows how to use the `connector_peg` module from `part/connector_peg.scad` to generate a double-ended peg and its corresponding void. It sets `radius`, `spacing`, and `$fn`, then calls `connector_peg` twice with `ends = true`: once for the peg and once with `void = true` (using `%` for visual debugging) for the cavity.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-connector_peg.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <part/connector_peg.scad>\n\nradius = 2.5;\nspacing = 0.5;\n\n$fn = 48;\n\nconnector_peg(\n    radius = radius, \n    spacing = spacing,\n    ends = true\n);\n\n%connector_peg(\n    radius = radius, \n    spacing = spacing,\n    ends = true,\n    void = true\n);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Conditional Object Creation in OpenSCAD\nDESCRIPTION: This snippet illustrates a common OpenSCAD pattern for conditionally creating objects using nested if/else if statements. It assigns an index to a variable `i` and then uses conditional logic to render either a sphere, cube, or cylinder based on the value of `i`. This pattern can become verbose with many conditions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-select.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\ni = 0;\n\nif(i == 0) {\n\tsphere(1);\n}\nelse if(i == 1) {\n\tcube(1);\n}\nelse if(i == 2) {\n\tcylinder(1, 1);\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Maze Cell Data in OpenSCAD\nDESCRIPTION: Defines the mz_square_initialize function which initializes the cell data for a maze by specifying the number of rows and columns, or alternatively a mask indicating traversable and non-traversable cells using 0s and 1s. This initialized data serves as input for maze construction functions. Dependencies include other maze modules like mz_square and mz_squarewalls for maze structure and wall generation, along with the polyline2d module for rendering walls. Parameters include rows (number of maze rows), columns (number of maze columns), and mask (2D list specifying valid paths). The function outputs a data structure representing cell initialization to be further processed. This helper facilitates flexible maze creation and supports masked regions preventing traversal.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-mz_square_initialize.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <maze/mz_square_initialize.scad>\nuse <maze/mz_square.scad>\nuse <maze/mz_squarewalls.scad>\nuse <polyline2d.scad>\n\nrows = 10;\ncolumns = 10;\ncell_width = 5;\nwall_thickness = 2;\n\ninit_cells = mz_square_initialize(rows, columns);\ncells = mz_square(init_cells = init_cells);\nwalls = mz_squarewalls(cells, cell_width);\n\nfor(wall = walls) {\n\tpolyline2d(wall, wall_thickness, joinStyle = \"JOIN_MITER\");\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Visually Evenly Spaced Points on a Sphere Using Bauer Spiral in OpenSCAD\nDESCRIPTION: Defines the 'bauer_spiral' function to generate n points approximately evenly spaced over the surface of a sphere with specified radius. The 'rt_dir' parameter determines spiral direction (counterclockwise or clockwise). The snippet demonstrates invoking the function with parameters n and radius, then using a for loop to place small spheres at each point. It also integrates the 'polyline_join' module for linking points visually. Dependencies include 'bauer_spiral.scad' and 'polyline_join.scad'. Inputs are integer point count, float radius, and string rotation direction, outputting a list of 3D coordinate points. Limitations include approximate spacing since perfect uniform spacing is only achieved with Platonic solids.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-bauer_spiral.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <bauer_spiral.scad>\\nuse <polyline_join.scad>\\n\\nn = 200;\\nradius = 20;\\npts = bauer_spiral(n, radius);\\n\\nfor(p = pts) {\\n    translate(p)\\n        sphere(1, $fn = 24);\\n}\\n\\npolyline_join(pts) \\n    sphere(.5);\n```\n\n----------------------------------------\n\nTITLE: Creating a 3D Lens Shape with shape_liquid_splitting in OpenSCAD\nDESCRIPTION: Shows how to create a 3D lens-like or ring shape using `shape_liquid_splitting`. The 2D profile is rotated 90 degrees, extruded using `rotate_extrude`, and then an `intersection` operation with a centered square defines the final geometry. Requires the `shape_liquid_splitting.scad` library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_liquid_splitting.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_liquid_splitting.scad>\n\n$fn = 36;\n\nradius = 10;\ncentre_dist = 30;\n\nshape_pts = shape_liquid_splitting(radius, centre_dist);\n\nwidth = centre_dist + radius * 2;\n\nrotate_extrude() \nintersection() { \n    rotate(-90) polygon(shape_pts);    \n\n    translate([radius / 2, 0]) \n        square([radius, width], center = true);\n}\n```\n\n----------------------------------------\n\nTITLE: Using vx_circle module in OpenSCAD\nDESCRIPTION: This code snippet shows how to use the `vx_circle` module from the dotSCAD library to create a set of points representing a circle. It needs the `vx_circle.scad` file to be included in the OpenSCAD project, which is located in the `voxel` directory. The example iterates through the generated points and creates a square at each point using the `translate` and `square` functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voxel/vx_circle.scad>\n\t\n\tpoints = vx_circle(radius = 10);\n\tfor(pt = points) {\n        translate(pt) square(1);\n\t}\n```\n\n----------------------------------------\n\nTITLE: Sorting with Key Extraction and Reverse Order in OpenSCAD\nDESCRIPTION: This snippet demonstrates sorting a list using key extraction and reversing the order.  The key function extracts the 'x' property, and the list is sorted in descending order based on that extracted key. Note that `elem.x` will not work, the correct syntax is `elem[0]`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sorted.md#_snippet_10\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nassert(\n    [[10, 0, 0], [9, 0, 0], [7, 0, 0], [5, 0, 0], [2, 0, 0]] == \n    sorted([[10, 0, 0], [5, 0, 0], [7, 0, 0], [2, 0, 0], [9, 0, 0]], key = function(elem) elem.x, reverse = true)\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Stochastic Vine using lsystem3 in OpenSCAD\nDESCRIPTION: This example demonstrates a stochastic L-system that generates a random vine-like structure. It uses a single rule with a probability of 0.8, creating variations in the structure each time it's generated.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-lsystem3.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <turtle/lsystem3.scad>\nuse <polyline_join.scad>\n\nfor(line = vine()) {\n\tpolyline_join([line[0], line[1]])\n\t    sphere(.25, $fn = 4);\n}  \n\nfunction vine(n = 3, angle = 18, leng = 1, heading = 0, start = [0, 0, 0]) = \n\tlet(\n\t\taxiom = \"--F\",\n\t\trules = [\n\t\t\t[\"F\", \"/F[++F]-\\\\F[--F]+//F\"]\n\t\t]\n\t)\n\tlsystem3(axiom, rules, n, angle, leng, heading, start, rule_prs = [0.8]);\n```\n\n----------------------------------------\n\nTITLE: Splitting Strings with split_str Utility in OpenSCAD\nDESCRIPTION: This OpenSCAD code snippet demonstrates the usage of the split_str utility function to separate a string into a list of substrings based on the provided delimiter character. The example uses the split_str function with a source string and a delimiter, and then asserts that the result is a list containing the expected parts. The function requires importing or including the util/split_str.scad module and accepts a source string and a delimiter; it returns a list of substrings or an empty list if the input is empty.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-split_str.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/split_str.scad>\n\nassert(split_str(\"hello,world\", \",\") == [\"hello\", \"world\"]);\n```\n\n----------------------------------------\n\nTITLE: Generating Polyline Rounded Ending Cap OpenSCAD\nDESCRIPTION: This example shows how to create a polyline with a rounded style for the ending cap. It imports the module, sets $fn, and calls polyline2d specifying 'CAP_ROUND' for the endingStyle parameter, while keeping the startingStyle at its default (CAP_SQUARE).\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polyline2d.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline2d.scad>\n    \n$fn = 24;\n    polyline2d(\n        points = [[1, 2], [-5, -4], [-5, 3], [5, 5]], \n        width = 1,\n        endingStyle = \"CAP_ROUND\"\n    );\n```\n\n----------------------------------------\n\nTITLE: Parsing Number with Assertions in OpenSCAD\nDESCRIPTION: This OpenSCAD snippet imports the `parse_number` function from the `util/parse_number.scad` file and then uses the `assert` function to verify the correctness of the parsing. It tests parsing of positive and negative numbers and performs a simple arithmetic operation to validate the result. No external dependencies are needed besides the OpenSCAD standard library and the custom module file.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-parse_number.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/parse_number.scad>\n\nassert((parse_number(\"10\") + 1) == 11);\nassert((parse_number(\"-1.1\") + 1) == -0.1);\n```\n\n----------------------------------------\n\nTITLE: Extruding Text with ellipse_extrude - OpenSCAD\nDESCRIPTION: This OpenSCAD snippet shows the `ellipse_extrude` function used to extrude the text \"A\". The `semi_minor_axis` is set to 5. Then, `ellipse_extrude` is called with `semi_minor_axis` and the `height` set to 4.5. The text \"A\" is placed within the extruded shape. The text is vertically and horizontally centered.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-ellipse_extrude.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <ellipse_extrude.scad>\n\n\tsemi_minor_axis = 5;\n\t \n\tellipse_extrude(semi_minor_axis, height = 4.5) \n\t    text(\"A\", valign = \"center\", halign = \"center\");\n```\n\n----------------------------------------\n\nTITLE: Utility Functions for List, String, and Random Operations in OpenSCAD DotSCADE Library\nDESCRIPTION: This module encompasses various utility functions for data manipulation, including list operations like binary search, duplication removal, sorting, and summation; string parsing and splitting; and randomization functions such as choosing, shuffling, and generating random numbers. These utilities facilitate complex data handling within OpenSCAD scripts.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_6\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/binary_search**(sorted, target[, lo, hi])](https://openhome.cc/eGossip/OpenSCAD/lib3x-binary_search.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/contains**(lt, elem)](https://openhome.cc/eGossip/OpenSCAD/lib3x-contains.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/find_index**(lt, test)](https://openhome.cc/eGossip/OpenSCAD/lib3x-find_index.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/dedup**(lt, ...)](https://openhome.cc/eGossip/OpenSCAD/lib3x-dedup.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/flat**(lt[, depth])](https://openhome.cc/eGossip/OpenSCAD/lib3x-flat.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/reverse**(lt)](https://openhome.cc/eGossip/OpenSCAD/lib3x-reverse.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/slice**(lt, begin, end)](https://openhome.cc/eGossip/OpenSCAD/lib3x-slice.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/sorted**(lt[, cmp, key, reverse])](https://openhome.cc/eGossip/OpenSCAD/lib3x-sorted.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/sum**(lt)](https://openhome.cc/eGossip/OpenSCAD/lib3x-sum.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/swap**(lt, i, j)](https://openhome.cc/eGossip/OpenSCAD/lib3x-swap.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/zip**(lts, combine)](https://openhome.cc/eGossip/OpenSCAD/lib3x-zip.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/every**(lt, test)](https://openhome.cc/eGossip/OpenSCAD/lib3x-every.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/some**(lt, test)](https://openhome.cc/eGossip/OpenSCAD/lib3x-some.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/count**(lt, test)](https://openhome.cc/eGossip/OpenSCAD/lib3x-count.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/choose**(choices, seed)](https://openhome.cc/eGossip/OpenSCAD/lib3x-choose.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/rand**([min_value, max_value, seed_value])](https://openhome.cc/eGossip/OpenSCAD/lib3x-rand.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/shuffle**(lt[, seed])](https://openhome.cc/eGossip/OpenSCAD/lib3x-shuffle.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/parse_number**(t)](https://openhome.cc/eGossip/OpenSCAD/lib3x-parse_number.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/split_str**(t, delimiter)](https://openhome.cc/eGossip/OpenSCAD/lib3x-split_str.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**util/sub_str**(t, begin, end)](https://openhome.cc/eGossip/OpenSCAD/lib3x-sub_str.html)\n```\n\n----------------------------------------\n\nTITLE: Creating a 3D polyline with spherical end-caps at both start and end points\nDESCRIPTION: This snippet sets both the `startingStyle` and `endingStyle` to 'CAP_SPHERE', providing rounded end caps at both ends of the polyline for a smooth and uniform appearance. It uses the same points, diameter, and resolution as previous examples.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polyline3d.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline3d.scad>\n\npolyline3d(\n    points = [\n        [1, 2, 1], \n        [-5, -4, 2], \n        [-5, 3, 3], \n        [5, 5, 4]\n    ], \n    diameter = 1,\n    startingStyle = \"CAP_SPHERE\",\n    endingStyle = \"CAP_SPHERE\",\n    $fn = 24\n);\n```\n\n----------------------------------------\n\nTITLE: Extracting All Values from Hashmap in OpenSCAD\nDESCRIPTION: Provides a function to return a list containing every value stored in a hashmap constructed by util/map/hashmap in OpenSCAD. The function requires a valid hashmap object as input, which is a data structure mapping keys to corresponding values. The output is a list of values associated with each key in the map, suitable for iteration or inspection. This relies on util/map/hashmap.scad as a prerequisite to define the hashmap structure. It is constrained to work with maps created using that library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-hashmap_values.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/map/hashmap.scad>  \nuse <util/map/hashmap_values.scad>  \n\nm = hashmap([[\"k1\", 10], [\"k2\", 20], [\"k3\", 30]]);  \n\necho(hashmap_values(m));    // a list contains 10, 20, 30\n```\n\n----------------------------------------\n\nTITLE: Generating Outline Voxel Polygon - OpenSCAD\nDESCRIPTION: This snippet demonstrates how to use the `vx_polygon` function to generate points for an outline voxel polygon. It uses an external `shape_pentagram` function to define the input polygon and then iterates through the points returned by `vx_polygon` to render each voxel using `translate` and `linear_extrude`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_polygon.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voxel/vx_polygon.scad>;\nuse <shape_pentagram.scad>;\n\npentagram = [\n\t\tfor(pt = shape_pentagram(15))\n\t\t\t[round(pt.x), round(pt.y)]\n\t];\n\tfor(pt = vx_polygon(pentagram)) {\n\t\ttranslate(pt)\n\t\tlinear_extrude(1, scale = 0.5)\n\t\t\tsquare(1, center = true);\n\t}\n```\n\n----------------------------------------\n\nTITLE: Implementing Binary Search with Direct Value and Custom Comparators in OpenSCAD\nDESCRIPTION: Example demonstrating how to use the binary_search function with both direct value comparison and custom comparison functions. The example sorts a list of points, then searches for specific values and custom conditions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-binary_search.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/sorted.scad>\nuse <util/binary_search.scad>\n\npoints = [[1, 1], [3, 4], [7, 2], [5, 2]];\nlt = sorted(points); // [[1, 1], [3, 4], [5, 2], [7, 2]]\n\nassert(binary_search(lt, [7, 2]) == 3);\n\nxIs5 = function(elem) elem[0] - 5;\nassert(binary_search(lt, xIs5) == 2);\n\nyIs4 = function(elem) elem[1] - 4;\nassert(binary_search(lt, yIs4) == 1);\n```\n\n----------------------------------------\n\nTITLE: 2D Shape Extrusion Along Paths in OpenSCAD DotSCADE Library\nDESCRIPTION: These functions enable extruding 2D shapes along complex paths such as spirals and helices, facilitating the creation of intricate 3D geometries like spirals, spheres, and rings. They depend on the base shape points and path parameters, allowing for versatile shape transformations in 3D space.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_5\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**archimedean_spiral_extrude**(shape_pts, arm_distance, init_angle, point_distance, num_of_points, ...)](https://openhome.cc/eGossip/OpenSCAD/lib3x-archimedean_spiral_extrude.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**golden_spiral_extrude**(shape_pts, from, to, point_distance, ...)](https://openhome.cc/eGossip/OpenSCAD/lib3x-golden_spiral_extrude.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**helix_extrude**(shape_pts, radius, levels, level_dist, ...)](https://openhome.cc/eGossip/OpenSCAD/lib3x-helix_extrude.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**path_extrude**(shape_pts, path_pts, ...)](https://openhome.cc/eGossip/OpenSCAD/lib3x-path_extrude.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**ring_extrude**(shape_pts, radius[, angle = 360])](https://openhome.cc/eGossip/OpenSCAD/lib3x-ring_extrude.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**sphere_spiral_extrude**(shape_pts, radius, za_step, ...)](https://openhome.cc/eGossip/OpenSCAD/lib3x-sphere_spiral_extrude.html)\n```\n\n----------------------------------------\n\nTITLE: Creating a 3D Bézier Curve with Four Control Points in OpenSCAD\nDESCRIPTION: This example demonstrates how to use the bezier_curve function to generate points along a 3D Bézier curve using four control points. The polyline_join function is then used to place spheres at each point along the curve, creating a visual representation of the Bézier path.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-bezier_curve.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline_join.scad>\nuse <bezier_curve.scad>\n\nt_step = 0.05;\nradius = 2;\n\np0 = [0, 0, 0];\np1 = [40, 60, 35];\np2 = [-50, 90, 0];\np3 = [0, 200, -35];\n\npoints = bezier_curve(t_step, \n    [p0, p1, p2, p3]\n);\n\npolyline_join(points)\n    sphere(radius);\n```\n\n----------------------------------------\n\nTITLE: Using vx_curve to Generate a Voxelized Curve in OpenSCAD\nDESCRIPTION: This example demonstrates how to use the vx_curve function to generate a series of points along a curve defined by control points. The points are used to place cubes to create a voxelized curve. The original control points are shown as spheres for reference, and a polyline connecting the control points is also displayed.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_curve.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voxel/vx_curve.scad>\nuse <polyline_join.scad>\n\npts = [\n    [28, 2, 1],\n    [15, 8, -10],\n    [2, 14, 5],\n    [28, 14, 2],\n    [15, 21, 9],\n    [2, 28, 0]\n];\n\nfor(pt = vx_curve(pts)) {\n    translate(pt)\n        cube(1);\n}\n\n#for(pt = pts) {\n    translate(pt)\n        sphere(1);\n}\n#polyline_join(pts)\n    sphere(.05);\n```\n\n----------------------------------------\n\nTITLE: Implementing sum function in OpenSCAD\nDESCRIPTION: This snippet provides an OpenSCAD function that sums elements of a list, with support for nested lists. Dependencies include the OpenSCAD environment and its list management capabilities. The key parameter is `lt`, the list to sum. The function returns the sum of the list's elements or element-wise sum for nested lists. Usage examples demonstrate functionality with assertions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sum.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n#function sum(lt) = \\\n  if (is_list(lt)) \\\n    foldl(\"+\", lt) \\\n  else \\\n    lt;\n```\n\n----------------------------------------\n\nTITLE: Path Extrusion along Helix Points (Default Method) in OpenSCAD\nDESCRIPTION: Demonstrates the default behavior (`method = \"AXIS_ANGLE\"`) of `path_extrude` when given only points generated by `helix`. This highlights how `path_extrude` guesses rotation information, which might differ from the precise rotation used by `helix_extrude`. Requires `helix.scad` and `path_extrude.scad`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-path_extrude.md#_snippet_4\n\nLANGUAGE: openscad\nCODE:\n```\n\tuse <helix.scad>\n\tuse <path_extrude.scad>\n\n\tshape_pts = [\n\t\t[0,0],\n\t\t[3, 1],\n\t\t[0, 2]\n\t];\n\n\tpoints = helix( \n\t\tradius = 5, \n\t\tlevels = 5, \n\t\tlevel_dist = 3,\n\t\tvt_dir = \"SPI_UP\"\n\t);\n\n\tpath_extrude(shape_pts, points);\n```\n\n----------------------------------------\n\nTITLE: Creating a 3D polyline with spherical end-caps at the end points\nDESCRIPTION: This snippet configures the polyline to have spherical end-caps at both start and end points, enhancing visual smoothness at connection points. It employs the same points and diameter as the previous example but modifies the `endingStyle` parameter.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polyline3d.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline3d.scad>\n\npolyline3d(\n    points = [\n        [1, 2, 1], \n        [-5, -4, 2], \n        [-5, 3, 3], \n        [5, 5, 4]\n    ], \n    diameter = 1,\n    endingStyle = \"CAP_SPHERE\",\n    $fn = 24\n);\n```\n\n----------------------------------------\n\nTITLE: Cartesian to Polar Coordinate Conversion in OpenSCAD\nDESCRIPTION: This OpenSCAD code snippet demonstrates the usage of the `polar_coordinate` function. It first includes the `util/polar_coordinate.scad` file.  Then, it calls `polar_coordinate` with Cartesian coordinates [100, 100], retrieves the radius and theta, rounds them, and asserts that the rounded values are [141, 45].\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polar_coordinate.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/polar_coordinate.scad>\n\n\tcoord = polar_coordinate([100, 100]);\n\tr = round(coord[0]);\n\ttheta = round(coord[1]);\n    assert([r, theta] == [141, 45]);\n```\n\n----------------------------------------\n\nTITLE: Using the joint_T Module in OpenSCAD\nDESCRIPTION: Example demonstrating how to use the `joint_T` module in OpenSCAD to create a T-shaped joint. It requires including the `part/joint_T.scad` file and sets parameters like shaft radius, height, T-length, thickness, and spacing. The `$fn` variable is set to control the smoothness/resolution of the generated curves.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-joint_T.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <part/joint_T.scad>\n\n$fn = 48;\n\njoint_T(\n\tshaft_r = 2,\n\tshaft_h = 15,\n\tt_leng = 15,\n\tthickness = 2,\n\tspacing = 0.5\n);\n```\n\n----------------------------------------\n\nTITLE: Basic 3D Voronoi Diagram with Sphere Intersection in OpenSCAD\nDESCRIPTION: Creates a 3D Voronoi diagram from randomly generated points on a sphere and intersects it with a sphere. Points are generated using spherical coordinates with random angles, and highlighted as small cubes.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vrn3_from.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voronoi/vrn3_from.scad>\n\nr = 30;\n\nzas = rands(0, 359, 12);\nyas = rands(0, 179, 12);\n\npoints = [\n    for(i = [0:len(zas) - 1])\n    [\n        r * cos(yas[i]) * cos(zas[i]), \n        r * cos(yas[i]) * sin(zas[i]), \n        r * sin(yas[i])\n    ]\n];\n\n#for(pt = points) {\n    translate(pt) cube(1);\n}\n\nintersection() {\n    sphere(r);\n    vrn3_from(points);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating 3D Line with Sphere End-caps in OpenSCAD\nDESCRIPTION: Creates a 3D line with spherical endpoints (CAP_SPHERE style) at both ends. The spheres are centered on the specified points with the same diameter as the line.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-line3d.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <line3d.scad>\n\nline3d(\n    p1 = [0, 0, 0], \n    p2 = [10, 2, 10], \n    diameter = 1, \n    p1Style = \"CAP_SPHERE\", \n    p2Style = \"CAP_SPHERE\",\n    $fn = 24\n);\n```\n\n----------------------------------------\n\nTITLE: Using line2d module in OpenSCAD\nDESCRIPTION: This code snippet demonstrates how to use the `line2d` module from the dotSCAD library to create a 2D line. It requires the `line2d.scad` file to be included in the OpenSCAD project. The `p1` and `p2` parameters define the start and end points of the line, and the `width` parameter specifies the line's thickness.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <line2d.scad>\n\n\tline2d(p1 = [0, 0], p2 = [5, 0], width = 1);\n```\n\n----------------------------------------\n\nTITLE: Extrusion Operations in OpenSCAD DotSCADE Library\nDESCRIPTION: These functions perform various extrusion techniques to transform 2D shapes into 3D objects, including bending, boxing, elliptical extrusion, rounded extrusion, and stereographic extrusion. Dependencies are URLs pointing to detailed documentation. Suitable for creating complex 3D geometries from flat shapes.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_3\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**bend_extrude**(size, thickness, angle[, frags])](https://openhome.cc/eGossip/OpenSCAD/lib3x-bend_extrude.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**box_extrude**(height, shell_thickness, bottom_thickness[, offset_mode, chamfer, ...])](https://openhome.cc/eGossip/OpenSCAD/lib3x-box_extrude.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**ellipse_extrude**(semi_minor_axis, height[, center, convexity, twist, slices])](https://openhome.cc/eGossip/OpenSCAD/lib3x-ellipse_extrude.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**rounded_extrude**(size, round_r[, angle, twist, convexity])](https://openhome.cc/eGossip/OpenSCAD/lib3x-rounded_extrude.html)\n```\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n[**stereographic_extrude**(shadow_side_leng)](https://openhome.cc/eGossip/OpenSCAD/lib3x-stereographic_extrude.html)\n```\n\n----------------------------------------\n\nTITLE: Data structure and constants defining maze cell types in OpenSCAD\nDESCRIPTION: This snippet defines the data structure for maze cells, which includes ring index, cell index, and wall type. It also declares constants representing different wall configurations for clarity and ease of use in maze construction.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-mz_theta_cells.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# NO_WALL = 0;           // the cell has no wall\n# INWARD_WALL = 1;       // the cell has an inward wall\n# CCW_WALL = 2;          // the cell has a counter-clockwise wall\n# INWARD_CCW_WALL = 3;   // the cell has an inward wall and a clockwise wall\n\n```\n\n----------------------------------------\n\nTITLE: Basic Voronoi Diagram Generation in OpenSCAD\nDESCRIPTION: This code snippet demonstrates the basic usage of the `vrn2_space` module to generate a Voronoi diagram within a specified rectangle. It sets the `size` parameter to define the rectangle's dimensions and the `grid_w` parameter to control the grid width for cell distribution. It requires the `vrn2_space.scad` library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vrn2_space.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voronoi/vrn2_space.scad>\n\nvrn2_space(\n    size = [40, 20],\n    grid_w = 5\n);\n```\n\n----------------------------------------\n\nTITLE: Reversing a List Using Dotscad Utility Module in OpenSCAD\nDESCRIPTION: Defines a function to reverse the order of elements in a given list in OpenSCAD. Requires the Dotscad utility module 'util/reverse.scad' to be imported. Accepts a single parameter 'lt', which is the list to be reversed. Outputs the reversed list and can be used for assertions or other list operations within OpenSCAD scripts.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-reverse.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/reverse.scad>\n\nassert(reverse([1, 2, 3]) == [3, 2, 1]); \n```\n\n----------------------------------------\n\nTITLE: Drawing a Filled Voxel Circle with Extrusion in OpenSCAD\nDESCRIPTION: Creates a filled voxel-style circle with a radius of 10 units, where each voxel is represented by an extruded square with scaling. The filled parameter is set to true to generate points for the entire circle area.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_circle.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voxel/vx_circle.scad>\n\nfor(pt = vx_circle(10, filled = true)) {\n\ttranslate(pt)\n\tlinear_extrude(1, scale = 0.5) \n\t\tsquare(1, center = true);\n}\n```\n\n----------------------------------------\n\nTITLE: Bending a Surface in OpenSCAD\nDESCRIPTION: Transforms a photo into a bent surface with specified levels, radius, thickness, and optional angle and inversion, useful for surface manipulation and photomapping. Depends on surface library functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_25\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nsurface/sf_bend(levels, radius, thickness, depth[, angle, invert])\n```\n\n----------------------------------------\n\nTITLE: Parameter Overview for helix_extrude Module\nDESCRIPTION: This section lists and explains the parameters for the helix_extrude module, including shape points, radii, extrusion levels, direction controls, twist, scaling, triangle options, and OpenSCAD-specific parameters like $fa, $fs, $fn. It provides detailed context for customizing helix extrusions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-helix_extrude.md#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Generating and Visualizing Bézier Voxels in OpenSCAD\nDESCRIPTION: This OpenSCAD example demonstrates how to use the `vx_bezier` module to plot a 4-point Bézier curve. It defines control points, calls `vx_bezier` to get the voxel locations, and then uses a loop to place a unit cube at each resulting point. It requires the `voxel/vx_bezier.scad` library and defines common voxel parameters like `t_step` and `width`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_bezier.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voxel/vx_bezier.scad>\n\tt_step = 0.05;\n\twidth = 2;\n\t\np1 = [0, 0, 0];\np2 = [30, 15, 25];\np3 = [-35, 20, -20];\np4 = [10, 40, 9];\n\t\npoints = vx_bezier( \n\tp1, p2, p3, p4\n);\n\t\nfor(p = points) {\n\ttranslate(p)\n\t    cube(1);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating Voxel ASCII Characters in OpenSCAD\nDESCRIPTION: Defines a function to generate 8x8 voxel points for printable ASCII characters, useful for visualizing characters in 3D voxel style. No external dependencies are specified, but it relies on voxel library functions. Inputs include the character array, center positioning, and invert option, producing voxel points representing characters.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_7\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoxel/vx_ascii(char[, center, invert])\n```\n\n----------------------------------------\n\nTITLE: Computing 3D Worley Noise in OpenSCAD\nDESCRIPTION: Calculates Worley noise at 3D coordinates with adjustable seed, grid, and distance parameters, suitable for volumetric textures.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_45\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nnoise/nz_worley3(x, y, z[, seed, grid_w, dist])\n```\n\n----------------------------------------\n\nTITLE: Voxel Polyline from Sphere Spiral - OpenSCAD\nDESCRIPTION: This example shows how to use `vx_polyline` to generate a voxelized sphere spiral. It uses `sphere_spiral` to generate 3D points and then rounds their coordinates before passing them to `vx_polyline`. Cubes are then placed at each returned point, and the whole structure is rotated to create a complex 3D design.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_polyline.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n\tuse <voxel/vx_polyline.scad>\n\tuse <sphere_spiral.scad>\n\n\tpoints_angles = sphere_spiral(\n\t\tradius = 20, \n\t\tza_step = 5\n\t);\n\n\tpoints = [\n\t\tfor(pa = points_angles) \n\t\tlet(pt = pa[0])\n\t\t[round(pt.x), round(pt.y), round(pt.z)]\n\t];\n\n\tfor(a = [0:30:330]) { \n\t\trotate(a) \n\t\tfor(pt = vx_polyline(points)) {\n\t\t\ttranslate(pt)\n\t\t\t\tcube(1, center = true);\n\t\t}\n\t}\n```\n\n----------------------------------------\n\nTITLE: Creating Ellipse Shape Points with dotSCAD in OpenSCAD\nDESCRIPTION: This OpenSCAD snippet demonstrates how to generate ellipse shape points using the shape_ellipse function from dotSCAD. The axes parameter expects a two-element vector where the first value is the semi-major axis and the second is the semi-minor axis. Generated points are passed to the built-in polygon module for rendering; required dependencies include the shape_ellipse.scad file, which must be imported via use. Inputs are a vector specifying the ellipse size; output is the rendered 2D polygon. This approach does not create a true ellipse but an approximation based on the chosen axes, with segmentation controlled by OpenSCAD's global variables ($fa, $fs, $fn).\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_ellipse.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <shape_ellipse.scad>\n\npolygon(\n\tshape_ellipse([40, 20])\n);\n```\n\n----------------------------------------\n\nTITLE: Computing 1D Perlin Noise in OpenSCAD\nDESCRIPTION: Returns a Perlin noise value at a specific 1D coordinate, with optional seed for randomness. Used for smooth procedural variations, depends on noise library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_37\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nnoise/nz_perlin1(x[, seed])\n```\n\n----------------------------------------\n\nTITLE: Importing dedup Function in OpenSCAD\nDESCRIPTION: This snippet imports the `dedup.scad` file, which presumably contains the definition of the `dedup` function. This dependency is crucial for utilizing the deduplication functionality within the OpenSCAD script. The code assumes that the `dedup.scad` file is located in a subdirectory `util` relative to the current file.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-dedup.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/dedup.scad>\n```\n\n----------------------------------------\n\nTITLE: Using rand module\nDESCRIPTION: This OpenSCAD snippet demonstrates how to include and use the `rand` module for generating random numbers. It shows how to call the function with default values, specific ranges, and a seed value for repeatable results. The generated random numbers are echoed to the console.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-rand.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/rand.scad>\n\necho(rand());              \necho(rand(1, 10));\necho(rand(seed_value = 4));\n```\n\n----------------------------------------\n\nTITLE: Defining Comparison Functions in OpenSCAD\nDESCRIPTION: This snippet defines two comparison functions, `ascending` and `descending`, which can be used with the `sorted` function. `ascending` sorts in ascending order, and `descending` sorts in descending order.  These functions take two elements and return their difference.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sorted.md#_snippet_7\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nascending = function(e1, e2) e1 - e2;\ndescending = function(e1, e2) e2 - e1;\n```\n\n----------------------------------------\n\nTITLE: Rotating an Object Using m_rotation with Array Parameter\nDESCRIPTION: This example demonstrates rotating a point [20, 0, 0] using m_rotation with an array of rotation angles [0, -45, 45]. The hull function creates a shape connecting the original position and the rotated position.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-m_rotation.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <matrix/m_rotation.scad>\n\npoint = [20, 0, 0];\na = [0, -45, 45];\n\nhull() {\n\tsphere(1);\n\tmultmatrix(m_rotation(a))    \n\ttranslate(point) \n\t\tsphere(1);   \n}\n```\n\n----------------------------------------\n\nTITLE: Picking Random Points on a Sphere Surface in OpenSCAD\nDESCRIPTION: Defines the pp_sphere function to generate a vector of random 3D points uniformly distributed across the surface of a sphere with a specified radius. Parameters include 'radius' which sets the sphere's radius, 'value_count' indicating the number of points to generate, and an optional 'seed' to make the random sequence repeatable. The output is a vector of points that can be used for further 3D transformations or visualizations in OpenSCAD. Requires the pp/pp_sphere.scad library to be included.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-pp_sphere.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <pp/pp_sphere.scad>\n\nnumber = 1000;\nradius = 2;\n\npoints = pp_sphere(radius, number);\n\nfor(p = points) {\n    translate(p)\n        sphere(.05);\n}\n\n%sphere(radius, $fn = 48);\n```\n\n----------------------------------------\n\nTITLE: Generating Pentagram Shape Points in SCAD\nDESCRIPTION: This snippet defines the process to generate and use shape points of a pentagram in SCAD. It includes examples of invoking the shape_pentagram function and applying its output with polygon and golden_spiral_extrude modules, enabling 3D modeling workflows. Dependencies include shape_pentagram.scad and golden_spiral_extrude.scad files; inputs include radius values. Outputs are arrays of shape points used for extrusion or polygon definition.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-shape_pentagram.md#_snippet_0\n\nLANGUAGE: scad\nCODE:\n```\n# shape_pentagram\n\nReturns shape points of a pentagram. They can be used with xxx_extrude modules of dotSCAD. The shape points can be also used with the built-in polygon module.\n\n## Parameters\n\n- `r` : The length between the center and a tip.\n\n## Examples\n\n\tuse <shape_pentagram.scad>\n\n\tpolygon(shape_pentagram(5));\n\n![shape_pentagram](images/lib3x-shape_pentagram-1.JPG)\n\n\tuse <shape_pentagram.scad>\n\tuse <golden_spiral_extrude.scad>\n\n\tshape_pts = shape_pentagram(2);\n\n\tgolden_spiral_extrude(\n\t\tshape_pts, \n\t\tfrom = 5, \n\t\tto = 10, \n\t\tpoint_distance = 1,\n\t\tscale = 10\n\t);\n\n![shape_pentagram](images/lib3x-shape_pentagram-2.JPG)\n```\n\n----------------------------------------\n\nTITLE: Generating Voxel Bezier Curve in OpenSCAD\nDESCRIPTION: Provides a function to generate voxel points along a Bézier curve defined by four control points. It outputs voxel points that trace the curve, useful for stylized curve rendering. Requires voxel library functions; no additional dependencies are specified.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_8\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoxel/vx_bezier(p1, p2, p3, p4)\n```\n\n----------------------------------------\n\nTITLE: Basic Ring Extrusion with Twist in OpenSCAD\nDESCRIPTION: Creates a twisted ring by extruding a rectangular shape around a circle with radius 50 and applying a 180-degree twist. The shape_pts array defines the 2D rectangle to be extruded.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-ring_extrude.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <ring_extrude.scad>\n\nshape_pts = [\n\t[2, -10],\n\t[2, 10],\n\t[-2, 10],\n\t[-2, -10]\n];\n\nring_extrude(shape_pts, radius = 50, twist = 180);\n```\n\n----------------------------------------\n\nTITLE: Generating Sphere Spiral Coordinates in OpenSCAD\nDESCRIPTION: Defines the sphere_spiral function to calculate a vector of points on a spherical spiral along with associated rotation angles. It requires parameters such as radius, za_step (angular step size), z_circles (number of spiral rotations), begin_angle and end_angle (defining start and finish latitudes), vt_dir (vertical spiral direction), and rt_dir (rotation direction). The function returns vectors of the form [[x, y, z], [ax, ay, az]] where [x, y, z] are the rotated points on the sphere and [ax, ay, az] represent the corresponding rotation angles in degrees to orient objects placed at those points. This is designed to facilitate creation of 3D spirals on spherical surfaces in OpenSCAD, allowing for precise control of spiral geometry for modeling purposes.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sphere_spiral.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n# sphere_spiral\n\nCreates all points and angles on the path of a spiral around a sphere. It returns a vector of `[[x, y, z], [ax, ay, az]]`. `[x, y, z]` is actually obtained from rotating `[radius, 0, 0]` by `[ax, ay, az]`.\n\n## Parameters\n\n- `radius` : The radius of the sphere.\n- `za_step` : The spiral rotates around the z axis. When the rotated angle increases `za_step`, a point will be calculated.\n- `z_circles` : The spiral rotates around the z axis. This parameter determines how many circles it will rotate from the top to the end. It defaults to 1.\n- `begin_angle` : The default value is 0 which means begins from the north pole of the sphere. See examples below.\n- `end_angle` : The default value is 0 which means begins from the sourth pole of the sphere. See examples below.\n- `vt_dir` : `\"SPI_DOWN\"` for spiraling down. `\"SPI_UP\"` for spiraling up. The default value is `\"SPI_DOWN\"`.\n- `rt_dir` : `\"CT_CLK\"` for counterclockwise. `\"CLK\"` for clockwise. The default value is `\"CT_CLK\"`.\n```\n\n----------------------------------------\n\nTITLE: Generating and Visualizing 2D Worley Noise in OpenSCAD\nDESCRIPTION: This OpenSCAD example demonstrates how to use the `nz_worley2` module to generate a 2D Worley noise field over a grid and visualize the results. It calculates noise values for each point, normalizes them, and creates a 3D visualization where extrusion height and color represent the noise intensity. It also extracts and displays the cell nuclei locations.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-nz_worley2.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <noise/nz_worley2.scad>\n    use <util/dedup.scad>\n\n    size = [100, 50];\n    grid_w = 10;\n    dist = \"euclidean\"; // [euclidean, manhattan, chebyshev, border] \n    seed = 51;\n\n    points = [\n        for(y = [0:size.y - 1], x = [0:size.x - 1]) \n        [x, y]\n    ];\n\n    cells = [for(p = points) nz_worley2(p.x, p.y, seed, grid_w, dist)];\n\n    max_dist = max([for(c = cells) c[2]]);\n    for(i = [0:len(cells) - 1]) {\n        c = cells[i][2] / max_dist;\n        color([c, c, c])\n        linear_extrude(cells[i][2])\n        translate(points[i])\n            square(1);\n    }\n\n    cells_pts = dedup([for(c = cells) [c.x, c.y]]);\n    for(p = cells_pts) {\n        translate(p)\n        linear_extrude(max_dist)\n            square(1);\n    }\n```\n\n----------------------------------------\n\nTITLE: Ring Extrusion with Angle and Scale in OpenSCAD\nDESCRIPTION: Demonstrates creating a partial ring by extruding a rectangular shape with an angle of 180 degrees and scaling it by a factor of 2. The shape_pts array defines the 2D rectangle coordinates.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-ring_extrude.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <ring_extrude.scad>\n\nshape_pts = [\n\t[2, -10],\n\t[2, 10],\n\t[-2, 10],\n\t[-2, -10]\n];\n\nring_extrude(shape_pts, radius = 50, angle = 180, scale = 2);\n```\n\n----------------------------------------\n\nTITLE: Using m_translation for Object Translation in OpenSCAD\nDESCRIPTION: This example demonstrates how to use the m_translation function to create a transformation matrix that translates a sphere 5 units along the x-axis. It shows the typical use pattern with multmatrix.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-m_translation.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <matrix/m_translation.scad>\n\ncube(2, center = true); \nmultmatrix(m_translation([5, 0, 0]))\n    sphere(1);\n```\n\n----------------------------------------\n\nTITLE: Creating a Delaunay Triangulation in OpenSCAD\nDESCRIPTION: Generates a Delaunay triangulation from a set of points, with options to return triangle indices or triangle shapes.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/RELEASE.md#_snippet_8\n\nLANGUAGE: OpenSCAD\nCODE:\n```\ninclude <dotscad/triangle/tri_delaunay.scad>\n\n// Example usage:\npoints = [[0, 0], [10, 0], [10, 10], [0, 10], [5, 5]];\ndelaunay = tri_delaunay(points);\n\n// Get triangle indices\ninclude <dotscad/triangle/tri_delaunay_indices.scad>\nindices = tri_delaunay_indices(delaunay);\n\n// Get triangle shapes\ninclude <dotscad/triangle/tri_delaunay_shapes.scad>\nshapes = tri_delaunay_shapes(delaunay);\n```\n\n----------------------------------------\n\nTITLE: Path Extrusion Issue with EULER_ANGLE on Vertical Path in OpenSCAD\nDESCRIPTION: Illustrates a known issue with the `EULER_ANGLE` method in `path_extrude` where an abrupt twist or gimbal lock can occur when the path becomes nearly vertical. Requires `path_extrude.scad`.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-path_extrude.md#_snippet_6\n\nLANGUAGE: openscad\nCODE:\n```\n\tuse <path_extrude.scad>\n\n\tshape_pts = [[5, -5], [5, 5], [-5, 5], [-5, -5]];\n\n\tpath_pts = [\n\t\t[20, 20, 0], \n\t\t[18.2, 18.2, 2], \n\t\t[16.8, 16.8, 4], \n\t\t[15.8, 15.8, 6], \n\t\t[15.2, 15.2, 8], \n\t\t[15, 15, 10], \n\t\t[15.2, 15.2, 12], \n\t\t[15.8, 15.8, 14], \n\t\t[16.8, 16.8, 16], \n\t\t[18.2, 18.2, 18], \n\t\t[20, 20, 20]\n\t];\n\n\tpath_extrude(shape_pts, path_pts, method = \"EULER_ANGLE\");\n```\n\n----------------------------------------\n\nTITLE: Creating Voxel-Style Circle Points in OpenSCAD\nDESCRIPTION: Defines a function to generate points for a voxel-style circle with specified radius and optional filled parameter. The output can be used for rendering circles in voxel style. It depends on voxel library functions for point generation.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_9\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoxel/vx_circle(radius[, filled])\n```\n\n----------------------------------------\n\nTITLE: Converting Gray Level Images to Voxel Data in OpenSCAD\nDESCRIPTION: Transforms a list of gray levels (0-255) into voxel points with associated levels, suitable for detailed grayscale image rendering in voxels. Uses voxel functions to process intensity levels.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_15\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoxel/vx_gray(levels[, center, invert, normalize])\n```\n\n----------------------------------------\n\nTITLE: Drawing Voxel Curves from Points in OpenSCAD\nDESCRIPTION: Creates voxel points along a smooth curve passing through specified points, with adjustable tightness for curvature. It outputs voxel points representing the curve, useful in stylized visualizations. Depends on voxel library functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_11\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoxel/vx_curve(points[, tightness])\n```\n\n----------------------------------------\n\nTITLE: Using ptf_x_twist to Twist Points - OpenSCAD\nDESCRIPTION: This OpenSCAD snippet demonstrates the usage of the `ptf_x_twist` function to twist points along the x-axis.  It defines a size and then iterates through rows and columns of points, applying the `ptf_x_twist` function with a specified angle (90 degrees) to each point. The `polyline_join` function is then used to connect the twisted points, creating a twisted shape. Requires the `polyline_join.scad` file. The function takes `size` (2-value array: [x, y]), `point` (the point to be twisted), and `angle` (in degrees) as input.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-ptf_x_twist.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline_join.scad>\nuse <ptf/ptf_x_twist.scad>\n\nsize = [20, 10];\n\nrows = [\n    for(y = [0:size.y])\n        [for(x = [0:size.x]) [x, y]]\n];\n\ncolumns = [\n    for(x = [0:size.x])\n        [for(y = [0:size.y]) [x, y]]\n];\n\nfor(line = rows) {\n    twisted = [for(p = line) ptf_x_twist(size, p, 90)];\n    polyline_join(twisted)\n\t    sphere(.05);\n}\n\nfor(line = columns) {\n    twisted = [for(p = line) ptf_x_twist(size, p, 90)];\n    polyline_join(twisted)\n\t    sphere(.05);\n}\n```\n\n----------------------------------------\n\nTITLE: Binary Search in OpenSCAD with util/binary_search\nDESCRIPTION: Replacement for the deprecated util/bsearch function. Searches for a value in a sorted list with optional low and high indices.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/RELEASE.md#_snippet_3\n\nLANGUAGE: OpenSCAD\nCODE:\n```\ninclude <dotscad/util/binary_search.scad>\n\n// Example usage:\nsorted_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nindex = binary_search(sorted_list, 7);\n// Returns the index of 7 in the list if found, or -1 if not found\n```\n\n----------------------------------------\n\nTITLE: Rounded Cube with Custom Resolution in OpenSCAD\nDESCRIPTION: Creating a rounded cube with custom resolution by setting the $fn parameter. This example creates a centered 50×25×15 cube with 5mm rounded corners and lower resolution (8 fragments per circle).\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-rounded_cube.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <rounded_cube.scad>\n\n$fn = 8;\n\nrounded_cube(\n    size = [50, 25, 15], \n    corner_r = 5,\n    center = true\n);\n```\n\n----------------------------------------\n\nTITLE: Smoothing a Closed 2D Polygon with bezier_smooth in OpenSCAD\nDESCRIPTION: This example shows how to apply `bezier_smooth` to a closed 2D path to create a smoothed polygon. It requires `bezier_smooth.scad`. A triangular path (`path_pts`) is defined and displayed using `polygon`. The `bezier_smooth` function is then called with `closed = true` and a specified `round_d` to generate the smoothed path, which is displayed as a translated polygon for comparison.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-bezier_smooth.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n\tuse <bezier_smooth.scad>\n\n\tround_d = 10;\n\n\tpath_pts = [\n\t\t[0, 0],\n\t\t[40, 0],\n\t\t[0, 60]\n\t];\n\n\tpolygon(path_pts);\n\n\tsmoothed_path_pts = bezier_smooth(path_pts, round_d, closed = true);\n\n\ttranslate([50, 0, 0]) \n\t    polygon(smoothed_path_pts);\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Arc in OpenSCAD\nDESCRIPTION: Demonstrates using the `arc` module to create an arc segment. It specifies the radius, angle range (45 to 290 degrees), and width. The default `width_mode` (\"LINE_CROSS\") is used, meaning the width is centered on the radius. Requires the `arc.scad` library. `$fn` sets the number of fragments for rendering curves.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-arc.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <arc.scad>\n\n$fn = 24;\narc(radius = 20, angle = [45, 290], width = 2);\n%circle(r = 20);\n```\n\n----------------------------------------\n\nTITLE: Creating a Cone Part in OpenSCAD\nDESCRIPTION: Defines a function to generate a cone model with adjustable radius, length, spacing, angle, void, and end options, suitable for use as a rotatable component. Depends on part library functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_22\n\nLANGUAGE: OpenSCAD\nCODE:\n```\npart/cone(radius[, length, spacing, angle, void, ends])\n```\n\n----------------------------------------\n\nTITLE: Creating a Photo-Torus Surface in OpenSCAD\nDESCRIPTION: Maps a photo onto a toroidal surface with adjustable levels, radius, thickness, depth, twist, and inversion, suitable for detailed textured torus models. Uses surface functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_30\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nsurface/sf_torus(levels, radius, thickness, depth[, angle, twist, invert])\n```\n\n----------------------------------------\n\nTITLE: Forming a Ring from a Photo in OpenSCAD\nDESCRIPTION: Creates a ring-shaped surface from photo input with adjustable levels, radius, thickness, depth, angle, twist, and invert options for complex surface modeling. Uses surface library functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_26\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nsurface/sf_ring(levels, radius, thickness, depth[, angle, twist, invert])\n```\n\n----------------------------------------\n\nTITLE: Translating Binary Image to Voxel Points in OpenSCAD\nDESCRIPTION: Converts a binary image represented as a list of 0s and 1s into voxel points for rendering. The center and invert options control positioning and color mapping. This function relies on voxel library capabilities.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_14\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoxel/vx_from(binaries[, center, invert])\n```\n\n----------------------------------------\n\nTITLE: Transforming a Photo into a Twistable Square in OpenSCAD\nDESCRIPTION: Creates a distorted, twistable square surface from a photo input, with parameters for levels, thickness, twist, and inversion. Uses surface library functions to produce complex surface textures.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_29\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nsurface/sf_square(levels, thickness, depth[, x_twist, y_twist, invert])\n```\n\n----------------------------------------\n\nTITLE: Generating Voxel Cylinder Coordinates in OpenSCAD\nDESCRIPTION: Produces voxel points forming a cylinder with specified radius and height, with optional filling and thickness parameters. Enables voxel-style cylinder rendering, relying on voxel library functions for point calculations.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_12\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoxel/vx_cylinder(r, h[, filled, thickness])\n```\n\n----------------------------------------\n\nTITLE: Mapping a Photo onto a Sphere in OpenSCAD\nDESCRIPTION: Maps a 2D photo onto a spherical surface, with configurable levels, radius, thickness, depth, angle, and inversion. Enables textured spherical models in OpenSCAD; depends on surface functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_28\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nsurface/sf_sphere(levels, radius, thickness, depth[, angle, invert])\n```\n\n----------------------------------------\n\nTITLE: Creating Voronoi Cells from Random Points in 2D with Space in OpenSCAD\nDESCRIPTION: Creates Voronoi diagram with random points within a specified size and grid, useful for generating cellular textures or partitioned areas. Uses Voronoi library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_48\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoronoi/vrn2_cells_space(size, grid_w[, seed])\n```\n\n----------------------------------------\n\nTITLE: nz_worley2s Usage Example - OpenSCAD\nDESCRIPTION: This example demonstrates how to use the `nz_worley2s` function in OpenSCAD to generate Worley noise and visualize it by extruding squares. It initializes parameters like size, grid width, distance metric, and seed.  It then generates a list of points and uses `nz_worley2s` to calculate cell data for each point.  Finally, it iterates through the cell data, assigning colors and extruding squares at each point based on the calculated noise.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-nz_worley2s.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <noise/nz_worley2s.scad>\n\nsize = [100, 50];\ngrid_w = 10;\ndist = \"euclidean\"; // [euclidean, manhattan, chebyshev, border] \nseed = 51;\n\npoints = [\n    for(y = [0:size.y - 1], x = [0:size.x - 1]) \n    [x, y]\n];\n\ncells = nz_worley2s(points, seed, grid_w, dist);\n\nfor(i = [0:len(cells) - 1]) {\n    h = norm([cells[i][0], cells[i][1]]) % 10;\n    color([h, h, h] / 10)\n    linear_extrude(h)\n    translate(points[i])\n        square(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Rotatable T-Joint in OpenSCAD\nDESCRIPTION: Generates a T-shaped joint with specified shaft radius, height, T-length, thickness, spacing, and center options for rotatable models. Relies on part library functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_24\n\nLANGUAGE: OpenSCAD\nCODE:\n```\npart/joint_T(shaft_r, shaft_h, t_leng, thickness,[ spacing, center])\n```\n\n----------------------------------------\n\nTITLE: Creating a Polyhedron Star in OpenSCAD\nDESCRIPTION: Generates a 3D star with configurable outer radius, inner radius, height, and number of points. Replaces the deprecated starburst function.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/RELEASE.md#_snippet_9\n\nLANGUAGE: OpenSCAD\nCODE:\n```\ninclude <dotscad/polyhedra/star.scad>\n\n// Example usage:\npolyhedra_star(outerRadius=10, innerRadius=5, height=3, n=5);\n// Creates a 3D star with 5 points\n```\n\n----------------------------------------\n\nTITLE: Sorting with Predefined Comparison Functions in OpenSCAD\nDESCRIPTION: This snippet demonstrates sorting a list using the predefined `ascending` and `descending` comparison functions. It showcases sorting in ascending and descending order and using `reverse` in conjunction with a comparison function.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sorted.md#_snippet_8\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nassert(sorted([2, 1, 3, 5, 4], ascending) == [1, 2, 3, 4, 5]);\nassert(sorted([2, 1, 3, 5, 4], ascending, reverse = true) == [5, 4, 3, 2, 1]);\nassert(sorted([2, 1, 3, 5, 4], descending) == [5, 4, 3, 2, 1]);\n```\n\n----------------------------------------\n\nTITLE: Using Matrix Transpose in OpenSCAD\nDESCRIPTION: Replaces the deprecated rails2sections function with the matrix/m_transpose function from the OpenSCAD library. This function transposes a matrix.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/RELEASE.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\ninclude <dotscad/matrix/m_transpose.scad>\n\n// Example usage:\nmatrix = [[1, 2, 3], [4, 5, 6]];\ntransposed = m_transpose(matrix);\n// Result: [[1, 4], [2, 5], [3, 6]]\n```\n\n----------------------------------------\n\nTITLE: Extracting Contour Points in Voxel Style in OpenSCAD\nDESCRIPTION: Generates the contour around a set of points, optionally sorted, for voxel rendering. Useful for outlining shapes in 3D voxel models. It depends on voxel library functions for processing contour data.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_10\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoxel/vx_contour(points[, sorted])\n```\n\n----------------------------------------\n\nTITLE: Generating Voronoi Cells from Specific Points in 2D in OpenSCAD\nDESCRIPTION: Creates Voronoi diagram based on input point list with optional spacing, allowing custom cell pattern creation. Depends on Voronoi library functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_49\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoronoi/vrn2_from(points[, spacing, ...])\n```\n\n----------------------------------------\n\nTITLE: Creating Voronoi Diagram in First Quadrant in OpenSCAD\nDESCRIPTION: Produces Voronoi diagram based on size and grid parameters within the first quadrant space, useful for tiled or symmetric patterns. Uses Voronoi functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_50\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoronoi/vrn2_space(size, grid_w[, seed])\n```\n\n----------------------------------------\n\nTITLE: Element Search in OpenSCAD with util/contains\nDESCRIPTION: Replacement for the deprecated util/has function. Returns true if the list contains the specified element.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/RELEASE.md#_snippet_2\n\nLANGUAGE: OpenSCAD\nCODE:\n```\ninclude <dotscad/util/contains.scad>\n\n// Example usage:\nmy_list = [1, 2, 3, 4, 5];\nresult = contains(my_list, 3);\n// Result: true\n\nresult2 = contains(my_list, 6);\n// Result: false\n```\n\n----------------------------------------\n\nTITLE: Using Hashset Functions in OpenSCAD\nDESCRIPTION: This example demonstrates how to use the `hashset` function and its associated helper functions in OpenSCAD. It shows initializing a set from a list (`hashset`), adding an element (`hashset_add`), checking for an element's presence (`hashset_has`), deleting an element (`hashset_del`), getting the set size (`hashset_len`), and retrieving all elements (`hashset_elems`). It requires importing the necessary modules using the `use` statement.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-hashset.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/set/hashset.scad>\nuse <util/set/hashset_add.scad>\nuse <util/set/hashset_has.scad>\nuse <util/set/hashset_del.scad>\nuse <util/set/hashset_len.scad>\nuse <util/set/hashset_elems.scad>\n\ns1 = hashset([1, 2, 3, 4, 5, 2, 3, 5]);\nassert(hashset_len(s1) == 5);\n\ns2 = hashset_add(s1, 9);\nassert(hashset_has(s2, 9));\n\ns3 = hashset_del(s2, 2);\nassert(!hashset_has(s3, 2));\n\nassert(hashset_elems(s3) == [1, 3, 4, 5, 9]);\n```\n\n----------------------------------------\n\nTITLE: Computing 2D Worley Noise in OpenSCAD\nDESCRIPTION: Calculates Worley (cell) noise at a 2D coordinate, with seed, grid, and distance parameters to control pattern complexity. Useful for organic textures.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_43\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nnoise/nz_worley2(x, y[, seed, grid_w, dist])\n```\n\n----------------------------------------\n\nTITLE: Generating Worley Noise in OpenSCAD\nDESCRIPTION: Implements Worley noise (cell-based noise algorithm) for a set of points, with adjustable point and distance parameters. Useful for procedural texturing, relying on noise library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_36\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nnoise/nz_cell(points, p[, dist])\n```\n\n----------------------------------------\n\nTITLE: Creating Voxel Polygons in OpenSCAD\nDESCRIPTION: Returns voxel points outlining a polygon defined by a set of points, which can be filled or unfilled. Useful for voxelized polygon shapes. Uses voxel library functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_18\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoxel/vx_polygon(points[, filled])\n```\n\n----------------------------------------\n\nTITLE: Combining Two Voxel Point Sets in OpenSCAD\nDESCRIPTION: Creates a union of two voxel point lists for combined shapes. Useful for constructing complex voxel objects via set union operations. Relies on voxel functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_21\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoxel/vx_union(points1, points2)\n```\n\n----------------------------------------\n\nTITLE: Basic Rounded Cube Example in OpenSCAD\nDESCRIPTION: Basic usage of the rounded_cube module with a fixed size and corner radius. Creates a 20×20×20 cube with 5mm rounded corners in the first octant.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-rounded_cube.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <rounded_cube.scad>\n\nrounded_cube(20, 5);\n```\n\n----------------------------------------\n\nTITLE: Creating Voronoi Cells from Points in 2D in OpenSCAD\nDESCRIPTION: Generates Voronoi cell shapes based on input points, useful for cellular patterns or partitioning in 2D space. Uses Voronoi library functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_47\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoronoi/vrn2_cells_from(points)\n```\n\n----------------------------------------\n\nTITLE: Creating Voxel Sphere Points in OpenSCAD\nDESCRIPTION: Produces points for a voxel-style sphere with specified radius, optional fill, and thickness. Enables 3D spherical voxel models, depending on voxel library functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_20\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoxel/vx_sphere(radius[, filled, thickness])\n```\n\n----------------------------------------\n\nTITLE: Point Picking on a Disk in OpenSCAD\nDESCRIPTION: Generates random points over a disk with specified radius, number of points, and optional random seed.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/RELEASE.md#_snippet_6\n\nLANGUAGE: OpenSCAD\nCODE:\n```\ninclude <dotscad/pp/pp_disk.scad>\n\n// Example usage:\npoints = pp_disk(radius=10, value_count=100, seed=42);\n// Generates 100 random points within a disk of radius 10\n```\n\n----------------------------------------\n\nTITLE: Creating Difference between Two Voxel Point Sets in OpenSCAD\nDESCRIPTION: Computes the difference between two sets of voxel points, useful for boolean-like operations in voxel modeling. Requires voxel library functions to process point lists.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_13\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoxel/vx_difference(points1, points2)\n```\n\n----------------------------------------\n\nTITLE: Generating Voxel Points for a Line in OpenSCAD\nDESCRIPTION: Produces voxel points along a straight line between two points, used in constructing voxel-based line drawings. Relies on voxel functions for point generation.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_17\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoxel/vx_line(p1, p2)\n```\n\n----------------------------------------\n\nTITLE: Creating 3D Voronoi Diagram from Points in OpenSCAD\nDESCRIPTION: Generates a 3D Voronoi diagram from input points, useful for volumetric cellular structures, controlled by spacing parameter, relies on Voronoi library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_51\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoronoi/vrn3_from(points[, spacing])\n```\n\n----------------------------------------\n\nTITLE: Poisson Sampling - OpenSCAD\nDESCRIPTION: This code snippet demonstrates the usage of the `pp_poisson2` function to generate Poisson-distributed points within a 100x100 rectangle with a minimum distance of 5. It first includes the library `pp_poisson2.scad`, then calls the function to get the sampled points.  Finally, it iterates through these points, drawing a circle at each location. There are no dependencies other than the library file. The output is a set of circle primitives, representing the sampled points within the specified rectangle.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-pp_poisson2.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <pp/pp_poisson2.scad>\n\npoints = pp_poisson2([100, 100], 5);\nfor(p = points) {\n    translate(p)\n        circle(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Computing 2D Perlin Noise at a Coordinate in OpenSCAD\nDESCRIPTION: Returns a Perlin noise value for a 2D coordinate (x, y), useful for textured patterns and terrain generation. Depends on noise library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_39\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nnoise/nz_perlin2(x, y[, seed])\n```\n\n----------------------------------------\n\nTITLE: Sampling Multiple 3D Perlin Noise Values in OpenSCAD\nDESCRIPTION: Outputs an array of 3D Perlin noise values at specified (x, y, z) points, for complex procedural effects. Depends on noise functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_42\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nnoise/nz_perlin3s(points[, seed])\n```\n\n----------------------------------------\n\nTITLE: Sampling 3D Worley Noise at Multiple Points in OpenSCAD\nDESCRIPTION: Outputs Worley noise values over multiple 3D points, facilitating complex noise-based textures or effects. Depends on noise library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_46\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nnoise/nz_worley3s(points[, seed, grid_w, dist])\n```\n\n----------------------------------------\n\nTITLE: Sorting Nested Lists with dotSCAD in dotSCAD\nDESCRIPTION: Implements a sorting function to order elements of nested lists by comparing values at a specified index or coordinate axis. It supports sorting by 'x', 'y', 'z', or 'idx' which defaults to the first index, and allows for sorting by zyx order when using 'vt'. From dotSCAD 3.0 onwards, it accepts custom comparator functions enabling fine-grained sorting behavior. Dependencies include importing <util/sort.scad> for the sort function. Inputs include the list to sort ('lt'), sorting criteria ('by'), and optional index ('idx'). Outputs a sorted list maintaining sublist structures. The function is used primarily for sorting coordinate points or similarly structured data sets.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sort.md#_snippet_0\n\nLANGUAGE: dotSCAD\nCODE:\n```\nuse <util/sort.scad>\n\nassert(\n    [[2, 0, 0], [5, 0, 0], [7, 0, 0], [9, 0, 0], [10, 0, 0]] == \n    sort([[10, 0, 0], [5, 0, 0], [7, 0, 0], [2, 0, 0], [9, 0, 0]])\n);\n\nassert(\n    [[2, 0, 0], [5, 0, 0], [7, 0, 0], [9, 0, 0], [10, 0, 0]] == \n    sort([[10, 0, 0], [5, 0, 0], [7, 0, 0], [2, 0, 0], [9, 0, 0]], by = \"x\")\n);\n\nassert(\n    [[0, 2, 0], [0, 5, 0], [0, 7, 0], [0, 9, 0], [0, 10, 0]] == \n    sort([[0, 10, 0], [0, 5, 0], [0, 7, 0], [0, 2, 0], [0, 9, 0]], by = \"idx\", idx = 1)\n);\n\nascending = function(e1, e2) e1 - e2;\ndescending = function(e1, e2) e2 - e1;\nassert(sort([2, 1, 3, 5, 4], by = ascending) == [1, 2, 3, 4, 5]);\nassert(sort([2, 1, 3, 5, 4], by = descending) == [5, 4, 3, 2, 1]);\n```\n\n----------------------------------------\n\nTITLE: Sampling Multiple 1D Perlin Noise Values in OpenSCAD\nDESCRIPTION: Outputs an array of Perlin noise values at multiple x coordinates, allowing for batch procedural noise generation. Uses noise library functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_38\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nnoise/nz_perlin1s(xs[, seed])\n```\n\n----------------------------------------\n\nTITLE: Sampling Multiple 2D Worley Noise in OpenSCAD\nDESCRIPTION: Returns Worley noise values at multiple (x, y) points, enabling texture mapping. Depends on noise library functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_44\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nnoise/nz_worley2s(points[, seed, grid_w, dist])\n```\n\n----------------------------------------\n\nTITLE: Calculating and Visualizing Voxel Intersection in OpenSCAD\nDESCRIPTION: This example demonstrates using the `vx_intersection` function to find the common points between a voxel cylinder (created by `vx_cylinder`) and a voxel sphere (created by `vx_sphere`). It first includes the necessary modules (`vx_cylinder.scad`, `vx_sphere.scad`, `vx_intersection.scad`) using the `use` statement. Then, it computes the intersection of the point sets returned by the shape functions and stores the resulting list of points in the `voxels` variable. Finally, it iterates through the `voxels` list using a `for` loop, placing a unit cube centered at each point's location via `translate` to visualize the intersection shape.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_intersection.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n\tuse <voxel/vx_cylinder.scad>\n\tuse <voxel/vx_sphere.scad>\n\tuse <voxel/vx_intersection.scad>\n\n\tvoxels = vx_intersection(\n\t\tvx_cylinder([1, 8], 8, filled = true),\n\t\tvx_sphere(8, filled = true)\n\t);\n\n\tfor(pt = voxels) {\n\t\ttranslate(pt)\n\t\t\tcube(1, center = true);\n\t}\n```\n\n----------------------------------------\n\nTITLE: Adding and Verifying Element in OpenSCAD Hashmap using hashmap_put\nDESCRIPTION: This OpenSCAD snippet demonstrates the basic usage of `hashmap_put`. It initializes a hashmap using `hashmap`, adds a new key-value pair (`\"k4\"`, `40`) using `hashmap_put`, and then uses `hashmap_get` and `assert` to confirm that the new key was successfully added and its value is correct. It requires importing the relevant hashmap modules (`hashmap.scad`, `hashmap_put.scad`, `hashmap_get.scad`).\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-hashmap_put.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/map/hashmap.scad>\nuse <util/map/hashmap_put.scad>\nuse <util/map/hashmap_get.scad>\n\nm1 = hashmap([[\"k1\", 10], [\"k2\", 20], [\"k3\", 30]]);\n\nm2 = hashmap_put(m1, \"k4\", 40);\nassert(hashmap_get(m2, \"k4\") == 40);\n```\n\n----------------------------------------\n\nTITLE: Voxel Polyline from Pentagram - OpenSCAD\nDESCRIPTION: This example demonstrates how to use `vx_polyline` to create a voxel-style pentagram. It uses `shape_pentagram` to generate the initial pentagram points, then rounds the coordinates and passes them to `vx_polyline`. The resulting points are then used to place scaled squares, effectively creating a voxelized pentagram through linear extrusion.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_polyline.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n\tuse <voxel/vx_polyline.scad>\n\tuse <shape_pentagram.scad>\n\n\tpentagram = [\n\t\tfor(pt = shape_pentagram(15)) \n\t\t\t[round(pt.x), round(pt.y)]\n\t];\n\n\tfor(pt = vx_polyline([each pentagram, pentagram[0]])) {\n\t\ttranslate(pt) \n\t\tlinear_extrude(1, scale = 0.5) \n\t\t\tsquare(1, center = true);\n\t}\n```\n\n----------------------------------------\n\nTITLE: Checking hashset contains element in OpenSCAD\nDESCRIPTION: Demonstrates how to check if a hashset contains a specific element using the `hashset_has` function. It uses assertion to verify that the function returns true when the element exists in the set.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-hashset_has.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <util/set/hashset.scad>\nuse <util/set/hashset_has.scad>\n\ns = hashset([1, 2, 3, 4, 5]);\nassert(hashset_has(s, 3));\n```\n\n----------------------------------------\n\nTITLE: Solidifying Two Surfaces with Triangular Mesh in OpenSCAD\nDESCRIPTION: Combines two point-based surfaces into a solid object using a triangular mesh, enabling detailed 3D surface merging. Uses surface library of points and triangles.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_34\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nsurface/sf_solidifyT(points1, points2, triangles)\n```\n\n----------------------------------------\n\nTITLE: Curving a Photo along a Path in OpenSCAD\nDESCRIPTION: Maps a photo onto a customized curve path with specified levels and additional parameters, enabling complex curved surface rendering. Relies on surface library functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_31\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nsurface/sf_curve(levels, curve_path, ...)\n```\n\n----------------------------------------\n\nTITLE: Thickening a Surface with Triangular Mesh in OpenSCAD\nDESCRIPTION: Adds thickness to a surface represented by points and a triangle mesh, allowing conversion of flat meshes into volumetric shapes. Relies on surface mesh functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_35\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nsurface/sf_thickenT(points, thickness, ...)\n```\n\n----------------------------------------\n\nTITLE: Using vx_line for 2D Voxel Line in OpenSCAD\nDESCRIPTION: This snippet demonstrates how to use the vx_line module to generate a 2D voxel line between two points and then visualize it using OpenSCAD's square primitive. The code iterates through the points returned by vx_line, translating a square to each point to create the line. It requires the `vx_line.scad` module from the voxel library.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-vx_line.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <voxel/vx_line.scad>\n\nfor(pt = vx_line([-10, 0], [20, 50])) {\n\ttranslate(pt) \n\t\tsquare(1, center = true);\n}\n```\n\n----------------------------------------\n\nTITLE: Placing Rotated Text Along a Golden Spiral in OpenSCAD\nDESCRIPTION: Example showing how to use the 'golden_spiral' module in OpenSCAD to place oriented objects. It calls 'golden_spiral' for Fibonacci numbers 5 to 11 with a point distance of 4. The resulting points ([x, y] coordinates) and angles are used to position and rotate extruded text characters ('A') along the spiral path.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-golden_spiral.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <golden_spiral.scad>\n        \npts_angles = golden_spiral(\n    from = 5, \n    to = 11, \n    point_distance = 4\n);\n    \nfor(pt_angle = pts_angles) {\n    translate(pt_angle[0]) \n\trotate([90, 0, pt_angle[1]])\n\tlinear_extrude(1, center = true) \n\t\ttext(\"A\", valign = \"center\", halign = \"center\");\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a 2D Star Shape in OpenSCAD\nDESCRIPTION: Generates a 2D star shape with configurable outer radius, inner radius, and number of points. Replaces deprecated shape_starburst and shape_pentagram functions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/RELEASE.md#_snippet_7\n\nLANGUAGE: OpenSCAD\nCODE:\n```\ninclude <dotscad/shape_star.scad>\n\n// Example usage:\npolygon(shape_star(outer_radius=10, inner_radius=5, n=5));\n// Creates a 5-pointed star with outer radius 10 and inner radius 5\n```\n\n----------------------------------------\n\nTITLE: Creating Intersection of Voxel Point Sets in OpenSCAD\nDESCRIPTION: Generates the intersection points between two voxel point lists, enabling complex shape combinations. Depends on voxel library functions for intersection operations.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/README.md#_snippet_16\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nvoxel/vx_intersection(points1, points2)\n```\n\n----------------------------------------\n\nTITLE: Transforming Rectangle Points to Torus Coordinates Using ptf_torus in OpenSCAD\nDESCRIPTION: This OpenSCAD code snippet demonstrates how to use the ptf_torus function to map 2D points defined within a rectangle to corresponding points on a torus surface. It requires the polyline_join module and the ptf_torus module to be available. The parameters include 'size' defining the rectangle dimensions as [x, y], 'radius' defining the torus radii [R, r], 'angle' specifying torus angles [A, a], and 'twist' denoting the degree of twist applied. The example iterates over rows and columns of points, transforming each point then drawing connecting polylines and spheres to visualize the toroidal mapping. Inputs are arrays of coordinate points, and the output is a 3D plot representing the transformed torus surface structure. It is designed for visualization of complex torus shapes like mazes and requires OpenSCAD rendering support.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-ptf_torus.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <polyline_join.scad>\nuse <ptf/ptf_torus.scad>\n\nsize = [20, 10];\nradius = [10, 5];\nangle = [180, 180];\ntwist = 90;\n\nrows = [\n\tfor(y = [0:size.y])\n\t\t[for(x = [0:size.x]) [x, y]]\n];\n\ncolumns = [\n\tfor(x = [0:size.x])\n\t\t[for(y = [0:size.y]) [x, y]]\n];\n\nfor(line = rows) {\n\ttransformed = [for(p = line) ptf_torus(size, p, radius, angle, twist)];\n\tpolyline_join(transformed)\n\t\tsphere(.25);\n}\n\nfor(line = columns) {\n\ttransformed = [for(p = line) ptf_torus(size, p, radius, angle, twist)];\n\tpolyline_join(transformed)\n\t\tsphere(.25);\n}\n```\n\n----------------------------------------\n\nTITLE: Calling sf_square for Shape Generation in dotscad\nDESCRIPTION: This Python code calls the `sf_square` function, likely part of the `dotscad` library. It takes parameters `levels`, `thicnkess` (potential typo, likely should be `thickness`), `depth`, and optional named parameters `x_twist`, `y_twist`, and `invert` to generate a square-based 3D shape. The exact behavior depends on the implementation of `sf_square` within the `dotscad` context.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-sf_square.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsf_square(levels, thicnkess, depth, x_twist = x_twist, y_twist = y_twist, invert = invert);\n```\n\n----------------------------------------\n\nTITLE: Parameter Definitions for Star Shape in OpenSCAD\nDESCRIPTION: This section defines the default parameters for creating star shapes: outer radius, inner radius, height, and number of points (n). These parameters can be adjusted to customize the shape. The defaults generate a pentagram with specific proportions suitable for 3D modeling or CAD design.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-polyhedra_star.md#_snippet_0\n\nLANGUAGE: OpenSCAD\nCODE:\n```\n- `outer_radius`: The outer radius of the star. Default to 1.\n- `inner_radius`: The inner radius of the star. Default to 0.381966.\n- `height`: The star height. Default to 0.5.\n- `n`: The burst number. Default to 5.\n```\n\n----------------------------------------\n\nTITLE: Initializing Maze Cells with Mask Support in OpenSCAD\nDESCRIPTION: This example uses a mask array defined as a 2D list of 0s and 1s to indicate valid and blocked cells within the maze. The mz_square_initialize function is called with this mask to generate initialization data that respects these blocked cells (0s represent impassable cells). The maze is constructed from a specified start point and rendered shapes omit the masked-out areas. Additional parameters control cell size and wall thickness. This approach enables the creation of mazes with irregular shapes and holes. Dependencies include mz_square, mz_squarewalls, mz_square_initialize modules, and polyline2d for wall outlines. Masking cells as 0 restricts movement and drawing in those maze regions.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-mz_square_initialize.md#_snippet_1\n\nLANGUAGE: OpenSCAD\nCODE:\n```\nuse <maze/mz_square.scad>\nuse <maze/mz_squarewalls.scad>\nuse <maze/mz_square_initialize.scad>\nuse <polyline2d.scad>\n\nmask = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0],\n    [0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0],\n    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],\n    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],\n    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],\n    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],\n    [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0],\n    [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n];\nstart = [3, 3];\ncell_width = 5;\nwall_thickness = 2;\n\nrows = len(mask);\ncolumns = len(mask[0]);\ninit_cells = mz_square_initialize(mask = mask);\ncells = mz_square(start = start, init_cells = init_cells);\nwalls = mz_squarewalls(cells, cell_width, left_border = false, bottom_border = false);\n\n// Maze\nfor(wall = walls) {\n    polyline2d(wall, wall_thickness, joinStyle = \"JOIN_MITER\");\n}\n\n// Mask\nmask_width = cell_width + wall_thickness;\ntranslate([-wall_thickness / 2, -wall_thickness / 2])\nfor(i = [0:rows - 1], j = [0:columns - 1]) {\n    if(mask[i][j] == 0) {\n        translate([cell_width * j, cell_width * (rows - i - 1)])\n            square(mask_width);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating maze cell data with mz_theta_cells in OpenSCAD\nDESCRIPTION: This function generates a list of maze cells with their ring index, cell index, and wall type, based on the specified number of rows and cells in the first row. It facilitates maze creation with customizable dimensions and potentially random configurations.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/docs/lib3x-mz_theta_cells.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Creating Square Maze in OpenSCAD\nDESCRIPTION: Generates square maze cell data with configurable parameters including rows, columns, starting point, cell initialization, wrapping options, and randomization seed.\nSOURCE: https://github.com/justinsdk/dotscad/blob/master/RELEASE.md#_snippet_4\n\nLANGUAGE: OpenSCAD\nCODE:\n```\ninclude <dotscad/maze/mz_square.scad>\n\n// Example usage:\ncells = mz_square(rows=10, columns=10, seed=42);\n\n// Use with mz_squarewalls to create walls\ninclude <dotscad/maze/mz_squarewalls.scad>\nwalls = mz_squarewalls(cells, cell_width=10);\n```"
  }
]