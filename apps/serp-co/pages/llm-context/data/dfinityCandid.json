[
  {
    "owner": "dfinity",
    "repo": "candid",
    "content": "TITLE: Core Grammar for Candid Interface Description Language\nDESCRIPTION: Defines the basic grammar structure for the Candid IDL, including definitions for programs, service declarations, actor types, method types, function types, and data types. This grammar forms the foundation for describing canister interfaces on the Internet Computer.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_0\n\nLANGUAGE: candid\nCODE:\n```\n<prog>  ::= <def>;* <actor>?\n<def>   ::= type <id> = <datatype> | import service? <text>\n<actor> ::= service <id>? : (<tuptype> ->)? (<actortype> | <id>) ;?\n\n<actortype> ::= { <methtype>;* }\n<methtype>  ::= <name> : (<functype> | <id>)\n<functype>  ::= <tuptype> -> <tuptype> <funcann>*\n<funcann>   ::= oneway | query | composite_query\n<tuptype>   ::= ( <argtype>,* )\n<argtype>   ::= <datatype>\n<fieldtype> ::= <nat> : <datatype>\n<datatype>  ::= <id> | <primtype> | <comptype>\n<comptype>  ::= <constype> | <reftype>\n\n<primtype>  ::=\n  | <numtype>\n  | bool\n  | text\n  | null\n  | reserved\n  | empty\n  | principal\n\n<numtype>  ::=\n  | nat | nat8 | nat16 | nat32 | nat64\n  | int | int8 | int16 | int32 | int64\n  | float32 | float64\n\n<constype>  ::=\n  | opt <datatype>\n  | vec <datatype>\n  | record { <fieldtype>;* }\n  | variant { <fieldtype>;* }\n\n<reftype>  ::=\n  | func <functype>\n  | service <actortype>\n\n<name> ::= <id> | <text>\n```\n\n----------------------------------------\n\nTITLE: Function Type Definitions in Candid\nDESCRIPTION: Defines the syntax for function types in Candid, including parameter lists, result lists, and function annotations such as query, composite_query, and oneway. This also shows the shorthand for named parameters and results.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_5\n\nLANGUAGE: candid\nCODE:\n```\n<functype> ::= ( <argtype>,* ) -> ( <argtype>,* ) <funcann>*\n<funcann>  ::= oneway | query | composite_query\n<argtype>  ::= <datatype>\n```\n\nLANGUAGE: candid\nCODE:\n```\n<argtype> ::= <name> : <datatype>   := <datatype>\n```\n\n----------------------------------------\n\nTITLE: Using @dfinity/didc for Candid Service Method Analysis and Data Encoding/Decoding\nDESCRIPTION: This code demonstrates the core functionality of @dfinity/didc library, including getting service methods from Candid IDL, encoding input data to Candid format, and decoding Candid data. It shows how to work with a sample service that handles number storage through store_number and get_number methods.\nSOURCE: https://github.com/dfinity/candid/blob/master/tools/didc-js/wasm-package/README.md#2025-04-20_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { getServiceMethods, encode, decode } from \"@dfinity/didc\";\n\n// The IDL in text format to be used, most canisters expose their IDL through\n// the `candid:service` public metadata.\n//\n// You can fetch the IDL with an agent call or dfx with `dfx canister metadata <canisterId> candid:service`\nexport const IDL = `\n  type StoreNumberInput = record {\n    number : nat64;\n  };\n\n  service : {\n    store_number : (input : StoreNumberInput) -> ();\n    get_number : () -> (nat64) query;\n  };\n`;\n\n// Gets the service methods from the IDL and returns an array of the methods.\n//\n// Example returned value: ['store_number', 'get_number']\nconst methods = getServiceMethods(IDL);\n\n// Encodes a candid in text format to a hex representation.\n//\n// Example returned value: '4449444c016c01c98dea8b0a7801005a00000000000000'\nconst encoded = encode({\n  idl: IDL,\n  input: \"(record { number=90; })\",\n  serviceMethod: \"store_number\",\n  targetFormat: \"hex\",\n});\n\n// Decodes a hex representation of a candid value to a text format.\n//\n// Example returned value: '(90 : nat64)'\nconst decoded = decode({\n  idl: IDL,\n  input: \"4449444c0001785a00000000000000\",\n  serviceMethod: \"get_number\",\n  inputFormat: \"hex\",\n  targetFormat: \"candid\",\n});\n```\n\n----------------------------------------\n\nTITLE: Displaying Candid CLI Usage Information\nDESCRIPTION: Shows the main usage information for the Candid CLI tool, including available subcommands.\nSOURCE: https://github.com/dfinity/candid/blob/master/tools/didc/README.md#2025-04-20_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndidc 0.1.0\n\nUSAGE:\n    didc <SUBCOMMAND>\n\nSUBCOMMANDS:\n    check     Type check Candid file\n    bind      Binding for different languages\n    test      Generate test suites for different languages\n    encode    Encode Candid value\n    decode    Decode Candid binary data\n    random    Generate random Candid values\n```\n\n----------------------------------------\n\nTITLE: Service Definition Example in Candid\nDESCRIPTION: Demonstrates a complete service definition in Candid syntax, showing different method types including regular methods, query methods, and oneway methods with their parameter and result types.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_4\n\nLANGUAGE: candid\nCODE:\n```\nservice : {\n  addUser : (name : text, age : nat8) -> (id : nat64);\n  userName : (id : nat64) -> (text) query;\n  userAge : (id : nat64) -> (nat8) query;\n  deleteUser : (id : nat64) -> () oneway;\n}\n```\n\n----------------------------------------\n\nTITLE: Candid Type Encoding Specification\nDESCRIPTION: Defines mapping T that encodes Candid types to byte sequences. Each type constructor uses a negative opcode. Includes encoding for primitive types, composite types, field types, reference types and function annotations.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_76\n\nLANGUAGE: candid\nCODE:\n```\nT : <primtype> -> i8*\nT(null)      = sleb128(-1)  = 0x7f\nT(bool)      = sleb128(-2)  = 0x7e\nT(nat)       = sleb128(-3)  = 0x7d\nT(int)       = sleb128(-4)  = 0x7c\nT(nat8)      = sleb128(-5)  = 0x7b\nT(nat16)     = sleb128(-6)  = 0x7a\nT(nat32)     = sleb128(-7)  = 0x79\nT(nat64)     = sleb128(-8)  = 0x78\nT(int8)      = sleb128(-9)  = 0x77\nT(int16)     = sleb128(-10) = 0x76\nT(int32)     = sleb128(-11) = 0x75\nT(int64)     = sleb128(-12) = 0x74\nT(float32)   = sleb128(-13) = 0x73\nT(float64)   = sleb128(-14) = 0x72\nT(text)      = sleb128(-15) = 0x71\nT(reserved)  = sleb128(-16) = 0x70\nT(empty)     = sleb128(-17) = 0x6f\nT(principal) = sleb128(-24) = 0x68\n\nT : <constype> -> i8*\nT(opt <datatype>) = sleb128(-18) I(<datatype>)              // 0x6e\nT(vec <datatype>) = sleb128(-19) I(<datatype>)              // 0x6d\nT(record {<fieldtype>^N}) = sleb128(-20) T*(<fieldtype>^N)  // 0x6c\nT(variant {<fieldtype>^N}) = sleb128(-21) T*(<fieldtype>^N) // 0x6b\n\nT : <fieldtype> -> i8*\nT(<nat>:<datatype>) = leb128(<nat>) I(<datatype>)\n\nT : <reftype> -> i8*\nT(func (<datatype1>*) -> (<datatype2>*) <funcann>*) =\n  sleb128(-22) T*(<datatype1>*) T*(<datatype2>*) T*(<funcann>*) // 0x6a\nT(service {<methtype>*}) =\n  sleb128(-23) T*(<methtype>*)                                    // 0x69\n\nT : <methtype> -> i8*\nT(<name>:<datatype>) = leb128(|utf8(<name>)|) i8*(utf8(<name>)) I(<datatype>)\n\nT : <funcann> -> i8\nT(query)  = i8(1)\nT(oneway) = i8(2)\nT(composite_query) = i8(3)\n\nT* : <X>* -> i8*\nT*(<X>^N) = leb128(N) T(<X>)^N\n```\n\n----------------------------------------\n\nTITLE: Defining Type Selector Syntax for Candid\nDESCRIPTION: Formal definition of the type selector syntax for selecting particular type nodes in Candid types. The selector supports scopes and paths to identify specific type nodes within a Candid interface.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Type-selector.md#2025-04-20_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\n<selector> := <scopes> (. <path>)? | <path>\n<path> := <name> (. <name>)*\n<scopes> := <scope> (. <scope>)*\n<scope> := func:<name> | func:init | arg:<num> | ret:<num>\n```\n\n----------------------------------------\n\nTITLE: Name Definition in Candid\nDESCRIPTION: Defines the syntax for names in Candid, which can be either identifiers following typical programming language conventions or quoted text strings for cases where identifiers would conflict with keywords.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_3\n\nLANGUAGE: candid\nCODE:\n```\n<name> ::= <id> | <text>\n<id>   ::= (A..Z|a..z|_)(A..Z|a..z|_|0..9)*\n<text> ::= \"<char>*\"\n```\n\n----------------------------------------\n\nTITLE: Encoding Candid Values\nDESCRIPTION: Examples of encoding Candid values using the 'didc encode' command with various options.\nSOURCE: https://github.com/dfinity/candid/blob/master/tools/didc/README.md#2025-04-20_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ didc encode '(42, vec {1;2;-3})'\n4449444c016d7c027c002a0301027d\n\n$ didc encode '(42, vec {1;2;-3})' -t '(nat, vec int32)' -f pretty\nLength: 24 (0x18) bytes\n0000:   44 49 44 4c  01 6d 75 02  7d 00 2a 03  01 00 00 00   DIDL.mu.}.*.....\\n0010:   02 00 00 00  fd ff ff ff                             ........\n\n$ didc encode '(\"text\")' -d hello.did -m greet\n4449444c0001710474657874\n\n$ didc encode '(\"text\")' -d list.did -t '(list)'\nError: type mismatch: \"text\" can not be of type opt node\n```\n\n----------------------------------------\n\nTITLE: Decoding Candid Binary Data\nDESCRIPTION: Examples of decoding Candid binary data using the 'didc decode' command with different options.\nSOURCE: https://github.com/dfinity/candid/blob/master/tools/didc/README.md#2025-04-20_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ didc decode '4449444c016d7c027c002a0301027d'\n(42, vec { 1; 2; -3; })\n\n$ didc decode '4449444c016d7c027c002a0301027d' -t '(int)'\n(42)\n```\n\n----------------------------------------\n\nTITLE: Candid Value Format Grammar\nDESCRIPTION: Comprehensive grammar specification for the text format of Candid values. This format enables debugging and includes syntax for primitive values, constructed values, reference values, and various data types.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_40\n\nLANGUAGE: candid\nCODE:\n```\n<val> ::=\n  | <primval> | <consval> | <refval>\n  | ( <annval> )\n\n<annval> ::=\n  | <val>\n  | <val> : <datatype>\n\n<primval> ::=\n  | <nat> | <int> | <float>\n  | <text>\n  | true | false\n  | null\n\n<consval> ::=\n  | opt <val>\n  | vec { <annval>;* }\n  | record { <fieldval>;* }\n  | variant { <fieldval> }\n\n<fieldval> ::= <nat> = <annval>\n\n<refval> ::=\n  | service <text>             (canister URI)\n  | func <text> . <name>       (canister URI and message name)\n  | principal <text>           (principal URI)\n\n<arg> ::= ( <annval>,* )\n\n<letter> ::= A..Z | a..z\n<digit>  ::= 0..9\n<id>     ::= (<letter> | _)(<letter> | <digit> | _)*\n\n<sign>   ::= + | -\n<hex>    ::= <digit> | A..F | a..f\n<num>    ::= <digit>(_? <digit>)*\n<hexnum> ::= <hex>(_? <hex>)*\n<nat>    ::= <num> | 0x<hexnum>\n<int>    ::= <sign>? <num>\n<float>  ::=\n  | <sign>? <num> . <num>?\n  | <sign>? <num> (. <frac>?)? (e | E) <sign>? <num>\n  | <sign>? 0x<hexnum> . <hexnum>?\n  | <sign>? 0x<hexnum> (. <hexnum>?)? (p | P) <sign>? <num>\n\n<text>   ::= \" <char>* \"\n<char>   ::=\n  | <utf8>\n  | \\ <hex> <hex>\n  | \\ <escape>\n  | \\u{ <hexnum> }\n<escape>  ::= n | r | t | \\ | \" | '\n<utf8>    ::= <ascii> | <utf8enc>\n<ascii>   ::= '\\20'..'\\7e' except \" or \\\n<utf8enc> ::=\n  | '\\c2'..'\\df' <utf8cont>\n  | '\\e0' '\\a0'..'\\bf' <utf8cont>\n  | '\\ed' '\\80'..'\\9f' <utf8cont>\n  | '\\e1'..'\\ec' <utf8cont> <utf8cont>\n  | '\\ee'..'\\xef' <utf8cont> <utf8cont>\n  | '\\f0' '\\90'..'\\bf' <utf8cont> <utf8cont>\n  | '\\f4' '\\80'..'\\8f' <utf8cont> <utf8cont>\n  | '\\f1'..'\\f3' <utf8cont> <utf8cont> <utf8cont>\n<utf8cont> ::= '\\80'..'\\bf'\n```\n\n----------------------------------------\n\nTITLE: Defining Record Types in Candid\nDESCRIPTION: Grammar rules for record types in Candid, which represent heterogeneous sequences of values with unique field IDs.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_20\n\nLANGUAGE: candid\nCODE:\n```\n<constype>  ::= ... | record { <fieldtype>;* } | ...\n<fieldtype> ::= <nat> : <datatype>\n```\n\n----------------------------------------\n\nTITLE: Using CandidType Derive Macro in Rust\nDESCRIPTION: Demonstrates the syntax for applying the CandidType derive macro to Rust data structures. This macro facilitates conversion between Rust types and Candid types for Internet Computer canisters.\nSOURCE: https://github.com/dfinity/candid/blob/master/rust/candid_derive/README.md#2025-04-20_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(CandidType)]\n```\n\n----------------------------------------\n\nTITLE: Defining Variant Types in Candid\nDESCRIPTION: Grammar rule for variant types in Candid, which represent tagged unions with different possible data types.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_25\n\nLANGUAGE: candid\nCODE:\n```\n<constype>  ::= ... | variant { <fieldtype>;* } | ...\n```\n\n----------------------------------------\n\nTITLE: Generating JavaScript Bindings from Candid Interface\nDESCRIPTION: Example of generating JavaScript bindings from a Candid interface file using the 'didc bind' command.\nSOURCE: https://github.com/dfinity/candid/blob/master/tools/didc/README.md#2025-04-20_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ didc bind hello.did -t js\nexport const idlFactory = ({ IDL }) => {\n  return IDL.Service({ 'greet' : IDL.Func([IDL.Text], [IDL.Text], []) });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Integer Types in Candid\nDESCRIPTION: Grammar rule for integer types in Candid, including the unlimited-range 'int' and fixed-size variants (int8, int16, int32, int64).\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_10\n\nLANGUAGE: candid\nCODE:\n```\n<numtype> ::= ... | int | int8 | int16 | int32 | int64 | ...\n```\n\n----------------------------------------\n\nTITLE: Candid Upgrading Example - Version 2\nDESCRIPTION: Upgraded version of the Candid interface showing how to extend a record type with optional fields. This demonstrates safe interface evolution without breaking existing clients.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_43\n\nLANGUAGE: candid\nCODE:\n```\n// Version 2\ntype t = {x : nat; y : opt nat};\nservice : {\n  produce : () -> t;\n  consume : t -> ();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Text Type in Candid\nDESCRIPTION: Grammar rule showing the text type in Candid, which represents Unicode text strings.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_13\n\nLANGUAGE: candid\nCODE:\n```\n<primtype> ::= ... | text | ...\n```\n\n----------------------------------------\n\nTITLE: Candid Upgrading Example - Version 1\nDESCRIPTION: Initial version of a Candid interface showing a service with produce and consume methods using a record type. This serves as the baseline for demonstrating upgrade compatibility.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_42\n\nLANGUAGE: candid\nCODE:\n```\n// Version 1\ntype t = {x : nat};\nservice : {\n  produce : () -> t;\n  consume : t -> ();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Equivalent Function Types in Candid\nDESCRIPTION: Example showing three equivalent function type definitions in Candid, demonstrating how parameter and result field names are optional and don't affect type equivalence.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_6\n\nLANGUAGE: candid\nCODE:\n```\n(text, text, nat16) -> (text, nat64)\n(name : text, address : text, nat16) -> (text, id : nat64)\n(name : text, address : text, nr : nat16) -> (nick : text, id : nat64)\n```\n\n----------------------------------------\n\nTITLE: Syntactic Shorthands in Candid Grammar\nDESCRIPTION: Defines syntactic shorthands that simplify common patterns in Candid definitions, including named arguments, blob type as a shorthand for byte vectors, and simplified field type notations for records and variants.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_1\n\nLANGUAGE: candid\nCODE:\n```\n<argtype>  ::= ...\n  | <name> : <datatype>    := <datatype>\n\n<constype> ::= ...\n  | blob                   :=  vec nat8\n\n<fieldtype> ::= ...\n  | <name> : <datatype>    :=  <hash(name)> : <datatype>\n  | <datatype>             :=  N : <datatype>  where N is either 0 or previous + 1  (only in records)\n  | <nat>                  :=  <nat> : null   (only in variants)\n  | <name>                 :=  <name> : null  (only in variants)\n```\n\n----------------------------------------\n\nTITLE: Example of Mutually Recursive Type Definitions in Candid\nDESCRIPTION: Example showing mutually recursive type definitions for a linked list structure in Candid.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_35\n\nLANGUAGE: candid\nCODE:\n```\ntype node = record {head : nat; tail : list};\ntype list = opt node;\n```\n\n----------------------------------------\n\nTITLE: Defining Service Reference Types in Candid\nDESCRIPTION: Grammar rule for service reference types in Candid, which point to services described by actor types.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_28\n\nLANGUAGE: candid\nCODE:\n```\n<reftype> ::= ... | service <actortype>\n```\n\n----------------------------------------\n\nTITLE: Generating Random Candid Values\nDESCRIPTION: Examples of generating random Candid values using the 'didc random' command with various options and configurations.\nSOURCE: https://github.com/dfinity/candid/blob/master/tools/didc/README.md#2025-04-20_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ didc random -t '(int, text)'\n(-72_594_379_354_493_140_610_202_928_640_651_761_468, \"_J`:t7^>\")\n\n$ didc random -t '(int, text)' -c 'random = { range = [-10, +10], text = \"name\" }'\n(-6, \"Cindy Klocko\")\n\n$ didc random -d service.did -m method -c random.toml -a '(\"seed argument\")' -l js\n[new BigNumber('-4'), 'Marcus Kris']\n```\n\n----------------------------------------\n\nTITLE: Example of Function Reference Type in Candid\nDESCRIPTION: Example of a function reference type in Candid, showing a search engine service that takes a callback function.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_31\n\nLANGUAGE: candid\nCODE:\n```\ntype engine = service {\n  search : (query : text, callback : func (vec result) -> ());\n}\n```\n\n----------------------------------------\n\nTITLE: Examples of Type Definitions in Candid\nDESCRIPTION: Examples of type definitions in Candid, including recursive types for streams and lists, and a disallowed cyclic definition.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_34\n\nLANGUAGE: candid\nCODE:\n```\ntype stream = opt record {head : nat; next : func () -> stream};\n```\n\n----------------------------------------\n\nTITLE: Examples of Record Types in Candid\nDESCRIPTION: Examples of record type definitions in Candid, including a named-field record and equivalent tuple-style records.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_24\n\nLANGUAGE: candid\nCODE:\n```\nrecord {\n  name : text;\n  street : text;\n  num : nat;\n  city : text;\n  zip : nat;\n}\n\nrecord { nat; nat }\nrecord { 0 : nat; 1 : nat }\n```\n\n----------------------------------------\n\nTITLE: Primitive Type Subtyping Rule in Candid\nDESCRIPTION: Defines the basic subtyping rule for primitive types, stating that primitive types can only be upgraded to the same primitive type.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_46\n\nLANGUAGE: candid\nCODE:\n```\n------------------------\n<primtype> <: <primtype>\n```\n\n----------------------------------------\n\nTITLE: Candid Higher-Order Function Upgrading Example\nDESCRIPTION: Example demonstrating how subtyping rules apply to higher-order functions in Candid. Shows a service with functions that take other functions as parameters.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_44\n\nLANGUAGE: candid\nCODE:\n```\ntype t = {x : nat};\nservice : {\n  h1 : (f1 : () -> t) -> ();      // might call f1() and expects a t\n  h2 : (f2 : t -> ()) -> ();      // might call f2({x = 5})\n}\n```\n\n----------------------------------------\n\nTITLE: Natural Number to Integer Subtyping Rule in Candid\nDESCRIPTION: Specifies that natural numbers can be treated as a subtype of integers during upgrades.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_47\n\nLANGUAGE: candid\nCODE:\n```\n-----------\nnat <: int\n```\n\n----------------------------------------\n\nTITLE: Syntactic Shorthands for Candid Values\nDESCRIPTION: Additional syntactic shorthands for Candid values that reduce to basic value forms. Includes blob format for binary data and simplified field value notations for records and variants.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_41\n\nLANGUAGE: candid\nCODE:\n```\n<consval> ::= ...\n  | blob <text>            := vec { N;* }  where N;* is the sequence of bytes in the string, interpreted [as in the WebAssembly textual format](https://webassembly.github.io/spec/core/text/values.html#strings)\n\n<fieldval> ::= ...\n  | <name> = <annval>      :=  <hash(name)> = <annval>\n  | <annval>               :=  N = <annval>  where N is either 0 or previous + 1  (only in records)\n  | <nat>                  :=  <nat> = null   (only in variants)\n  | <name>                 :=  <name> = null  (only in variants)\n```\n\n----------------------------------------\n\nTITLE: Example TOML Configuration for Candid Interface\nDESCRIPTION: A TOML configuration file example showing how to customize random value generation and Rust bindings for the sample Candid interface. It demonstrates setting depth limits, value ranges, and Rust-specific customizations.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Type-selector.md#2025-04-20_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[random]\nleft.tree = { depth = 1, range = [-200, -100] }\nright.tree = { depth = 5, range = [100, 200] }\n\n[rust]\nvisibility = \"pub(crate)\"\nattributes = \"#[derive(CandidType, Deserialize, Clone, Debug)]\"\nint.use_type = \"i128\"\nf.arg0.name = \"input\"\n```\n\n----------------------------------------\n\nTITLE: Datatype to Option Subtyping Rule in Candid\nDESCRIPTION: Defines when a datatype can be considered a subtype of an option type, with restrictions to prevent ambiguity.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_52\n\nLANGUAGE: candid\nCODE:\n```\nnot (null <: <datatype'>)\n<datatype> <: <datatype'>\n-----------------------------\n<datatype> <: opt <datatype'>\n```\n\n----------------------------------------\n\nTITLE: Example of Service Reference Type in Candid\nDESCRIPTION: Example of a service reference type definition in Candid, showing a broker service that can return other service references.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_29\n\nLANGUAGE: candid\nCODE:\n```\ntype broker = service {\n  findCounterService : (name : text) ->\n    (service {up : () -> (); current : () -> (nat)});\n}\n```\n\n----------------------------------------\n\nTITLE: Special Option Subtyping Rules for Transitivity in Candid\nDESCRIPTION: Defines special rules to maintain transitivity of subtyping with option types, allowing any type to be regarded as a subtype of an option under specific conditions.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_53\n\nLANGUAGE: candid\nCODE:\n```\nnot (<datatype> <: opt <datatype'>)\n---------------------------------\nopt <datatype> <: opt <datatype'>\n\nnot (null <: <datatype'>)\nnot (<datatype> <: <datatype'>)\n---------------------------------\nopt <datatype> <: opt <datatype'>\n```\n\n----------------------------------------\n\nTITLE: Record Field Subtyping Rule in Candid\nDESCRIPTION: Defines how record types can be specialized by specializing field types or adding new fields.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_55\n\nLANGUAGE: candid\nCODE:\n```\n<datatype> <: <datatype'>\nrecord { <fieldtype>;* } <: record { <fieldtype'>;* }\n----------------------------------------------------------------------------------------------\nrecord { <nat> : <datatype>; <fieldtype>;* } <: record { <nat> : <datatype'>; <fieldtype'>;* }\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Binding Generation with TOML\nDESCRIPTION: Demonstrates how to use a TOML configuration file to customize Rust binding generation and random value generation in Candid CLI.\nSOURCE: https://github.com/dfinity/candid/blob/master/tools/didc/README.md#2025-04-20_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[didc.rust]\ntarget = \"custom\"  # Other targets: canister_call, agent, stub\ntemplate = \"template.hbs\"  # required for custom target\n# any tags mentioned from hbs\ncandid_crate = \"candid\"\nservice_name = \"service\"\n\n[rust]\nvisibility = \"pub(crate)\"\nattributes = \"#[derive(CandidType, Deserialize, Debug)]\"\nGetBlocksResponse.attributes = \"#[derive(CandidType, Deserialize, Debug, Clone, Serialize)]\"\nGetBlocksResponseArchivedBlocksItem.name = \"ABetterName\"\n```\n\n----------------------------------------\n\nTITLE: Record Field Removal Subtyping Rule in Candid\nDESCRIPTION: Allows removing optional, null, or reserved fields from records to support evolution of record types in both inbound and outbound positions.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_56\n\nLANGUAGE: candid\nCODE:\n```\n<nat> not in <fieldtype>;*\nrecord { <fieldtype>;* } <: record { <fieldtype'>;* }\nnull <: <datatype'>\n------------------------------------------------------------------------------\nrecord { <fieldtype>;* } <: record { <nat> : <datatype'>; <fieldtype'>;* }\n```\n\n----------------------------------------\n\nTITLE: Candid Complex Higher-Order Function Upgrading Example\nDESCRIPTION: Advanced example showing multiple levels of function types in a Candid service. Demonstrates how subtyping applies recursively at any order of function types.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_45\n\nLANGUAGE: candid\nCODE:\n```\ntype t = {x : nat};\ntype f = t -> ();\ntype g = () -> t;\nservice : {\n  h : (f, g) -> ();    // might compose f(g())\n}\n```\n\n----------------------------------------\n\nTITLE: Empty Variant Subtyping Rule in Candid\nDESCRIPTION: Specifies that the empty variant is a subtype of any variant type.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_57\n\nLANGUAGE: candid\nCODE:\n```\n-----------------------------------------\nvariant { } <: variant { <fieldtype'>;* }\n```\n\n----------------------------------------\n\nTITLE: Interface Description Grammar in Candid\nDESCRIPTION: Grammar rules for defining interfaces in Candid. An interface description consists of imports and type definitions, followed by an optional service declaration.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_39\n\nLANGUAGE: candid\nCODE:\n```\n<desc>  ::= <def>;* <service>;?\n<service> ::= service <id>? : (<actortype> | <id>)\n```\n\n----------------------------------------\n\nTITLE: Defining Type Selector Syntax for Candid Configuration\nDESCRIPTION: Specifies the syntax for selecting particular type nodes in Candid types, similar to CSS selectors. This allows for precise targeting of specific elements within complex Candid type structures.\nSOURCE: https://github.com/dfinity/candid/blob/master/tools/didc/config.md#2025-04-20_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n<selector> := <method> (. <path>)? | <path>\n<method> := [ <name> ] | [ <nat> ] | [ <name> ] . [ <nat> ]\n<path> := <name> (. <name>)*\n```\n\n----------------------------------------\n\nTITLE: Variant Tag Subtyping Rule in Candid\nDESCRIPTION: Defines how variant types can be specialized by specializing tag types or removing tags.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_58\n\nLANGUAGE: candid\nCODE:\n```\n<datatype> <: <datatype'>\nvariant { <fieldtype>;* } <: variant { <fieldtype'>;* }\n------------------------------------------------------------------------------------------------\nvariant { <nat> : <datatype>; <fieldtype>;* } <: variant { <nat> : <datatype'>; <fieldtype'>;* }\n```\n\n----------------------------------------\n\nTITLE: Example of Import Usage in Candid Files\nDESCRIPTION: Demonstrates how to use imports between two Candid files. File A.did defines a service type and implementation, while B.did imports A.did and extends the service.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_38\n\nLANGUAGE: candid\nCODE:\n```\ntype A = service { f : () -> () };\nservice : A\n```\n\nLANGUAGE: candid\nCODE:\n```\nimport \"A.did\";  // Cannot use `import service` because of method name duplication\nservice B : A ;\n```\n\n----------------------------------------\n\nTITLE: Function Subtyping Rule in Candid\nDESCRIPTION: Defines how function types can be specialized by generalizing parameter types and specializing result types, following contravariant and covariant patterns.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_59\n\nLANGUAGE: candid\nCODE:\n```\nrecord { (N1' : <datatype1'>);* } <: record { (N1 : <datatype1>);* }\nrecord { (N2 : <datatype2>);* } <: record { N2' : <datatype2'>);* }\n-------------------------------------------------------------------------------------------------------------------\nfunc ( <datatype1>,* ) -> ( <datatype2>,* ) <funcann>* <: func ( <datatype1'>,* ) -> ( <datatype2'>,* ) <funcann>*\n```\n\n----------------------------------------\n\nTITLE: Defining Type Definitions in Candid\nDESCRIPTION: Grammar rule for type definitions in Candid, which allow naming data types for reuse.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_33\n\nLANGUAGE: candid\nCODE:\n```\n<def>   ::= type <id> = <datatype>\n```\n\n----------------------------------------\n\nTITLE: Empty Service Subtyping Rule in Candid\nDESCRIPTION: Specifies that any service type can be considered a supertype of the empty service.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_60\n\nLANGUAGE: candid\nCODE:\n```\n----------------------------------------\nservice { <methtype'>;* } <: service { }\n```\n\n----------------------------------------\n\nTITLE: Service Method Subtyping Rule in Candid\nDESCRIPTION: Defines how service types can be specialized by specializing method function types or adding new methods, treating services as records of functions.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_61\n\nLANGUAGE: candid\nCODE:\n```\n<functype> <: <functype'>\nservice { <methtype>;* } <: service { <methtype'>;* }\n------------------------------------------------------------------------------------------------\nservice { <name> : <functype>; <methtype>;* } <: service { <name> : <functype'>; <methtype'>;* }\n```\n\n----------------------------------------\n\nTITLE: Candid Parameter and Result Encoding\nDESCRIPTION: Defines the A mapping for encoding function arguments and results, combining type table, type references and value encoding with a magic number prefix.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_80\n\nLANGUAGE: candid\nCODE:\n```\nA(kv* : <datatype>*) = ( B(kv* : <datatype>*), R(kv* : <datatype>*) )\n\nB(kv* : <datatype>*) =\n  i8('D') i8('I') i8('D') i8('L')      magic number\n  T*(<comptype>*)                      type definition table\n  I*(<datatype>*)                      types of the argument list\n  M(kv* : <datatype>*)                 values of argument list\n```\n\n----------------------------------------\n\nTITLE: Type Coercion Rule for Primitive Types in Candid\nDESCRIPTION: Defines the identity coercion rule for primitive types including numeric types, boolean, text, and null.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_62\n\nLANGUAGE: markup\nCODE:\n```\n<t> ∈ <numtype>, bool, text, null\n---------------------------------\n<v> : <t> ~> <v> : <t>\n```\n\n----------------------------------------\n\nTITLE: Record Type Coercion in Candid\nDESCRIPTION: Defines how record types are coerced by handling matching fields, extra fields in the source, and missing fields in the target.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_70\n\nLANGUAGE: markup\nCODE:\n```\n<v1> : <t1> ~> <v1'> : <t1'>\nnull <: <t3>\n-------------------------------------------------------------------------------------------\nrecord { <nat1> = <v1>;* <nat2> = <v2>;* } : record { <nat1> : <t1>;* <nat2> : <t2>;* } ~>\nrecord { <nat1> = <v1'>;* <nat3> = null;* } : record { <nat1> : <t1'>;* <nat3> : <t3>;* }\n```\n\n----------------------------------------\n\nTITLE: Defining Vector Type in Candid\nDESCRIPTION: Grammar rule for vector types in Candid, which represent homogeneous sequences of values of the same data type.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_18\n\nLANGUAGE: candid\nCODE:\n```\n<constype>  ::= ... | vec <datatype> | ...\n```\n\n----------------------------------------\n\nTITLE: Nat to Int Coercion in Candid\nDESCRIPTION: Specifies how natural number values coerce to the int type.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_63\n\nLANGUAGE: markup\nCODE:\n```\n--------------------------\n<nat> : nat ~> <nat> : int\n```\n\n----------------------------------------\n\nTITLE: Defining Principal Reference Type in Candid\nDESCRIPTION: Grammar rule for the principal reference type in Candid, which represents identities like canisters or users.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_32\n\nLANGUAGE: candid\nCODE:\n```\n<primtype> ::= ... | principal | ...\n```\n\n----------------------------------------\n\nTITLE: Vector Pointwise Coercion in Candid\nDESCRIPTION: Defines how vectors are coerced element by element when converting between vector types.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_65\n\nLANGUAGE: markup\nCODE:\n```\n<v> : <t> ~> <v'> : <t'>\n----------------------------------------------------\nvec { <v>;* } : vec <t> ~> vec { <v'>;* } : vec <t'>\n```\n\n----------------------------------------\n\nTITLE: Defining Data Types in Candid\nDESCRIPTION: Grammar rule showing how data types in Candid can be categorized as primitive types, constructed types, or reference types.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_7\n\nLANGUAGE: candid\nCODE:\n```\n<datatype>  ::= <primtype> | <constype> | <reftype>\n```\n\n----------------------------------------\n\nTITLE: Null Value Coercion to Option Type in Candid\nDESCRIPTION: Specifies how null values coerce into option types when the null value is a subtype of the source type.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_66\n\nLANGUAGE: markup\nCODE:\n```\nnull <: <t>\n-----------------------------\nnull : <t> ~> null : opt <t'>\n```\n\n----------------------------------------\n\nTITLE: Defining Function Reference Types in Candid\nDESCRIPTION: Grammar rule for function reference types in Candid, which describe callbacks and other first-class functions.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_30\n\nLANGUAGE: candid\nCODE:\n```\n<reftype> ::= func <functype> | ...\n```\n\n----------------------------------------\n\nTITLE: Option Value Coercion in Candid\nDESCRIPTION: Defines how optional values coerce at option types, preserving the value if it can be coerced or converting to null otherwise.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_67\n\nLANGUAGE: markup\nCODE:\n```\n<v> : <t> ~> <v'> : <t'>\n----------------------------------------\nopt <v> : opt <t> ~> opt <v'> : opt <t'>\n\nnot (<v> : <t> ~> _ : <t'>)\n----------------------------------------\nopt <v> : opt <t> ~> null : opt <t'>\n```\n\n----------------------------------------\n\nTITLE: Defining Option Type in Candid\nDESCRIPTION: Grammar rule for option types in Candid, which represent possibly absent values of a specific data type.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_17\n\nLANGUAGE: candid\nCODE:\n```\n<constype>  ::= opt <datatype> | ...\n```\n\n----------------------------------------\n\nTITLE: Non-Option Value Coercion to Option Type in Candid\nDESCRIPTION: Shows how a non-null, non-optional, non-reserved type can be coerced to an option type by treating it as an optional value.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_68\n\nLANGUAGE: markup\nCODE:\n```\nnot (null <: <t>)\nnot (null <: <t'>)\n<v> : <t> ~> <v'> : <t'>\n--------------------------------\n<v> : <t> ~> opt <v'> : opt <t'>\n```\n\n----------------------------------------\n\nTITLE: Variant Type Coercion in Candid\nDESCRIPTION: Specifies how variant values are coerced, requiring that the tag matches one of the expected tags in the target type.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_71\n\nLANGUAGE: markup\nCODE:\n```\n<v> : <t> ~> <v'> : <t'>\n----------------------------------------------------------\nvariant { <nat> = <v>; } : variant { <nat> : <t>; _;* } ~>\nvariant { <nat> = <v'> } : variant { <nat> : <t'>; _;* }\n```\n\n----------------------------------------\n\nTITLE: Defining Blob Type in Candid\nDESCRIPTION: Grammar rule showing that 'blob' is a shorthand for 'vec nat8' in Candid, representing arbitrary sequences of bytes.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_19\n\nLANGUAGE: candid\nCODE:\n```\n<constype> ::= ....\n  | blob   := vec nat8\n```\n\n----------------------------------------\n\nTITLE: Fallback Coercion to Null for Option Types in Candid\nDESCRIPTION: Specifies how various values that cannot be properly coerced to an option type are converted to null.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_69\n\nLANGUAGE: markup\nCODE:\n```\n---------------------------------\n<v> : reserved ~> null : opt <t'>\n\nnot (null <: <t'>)\nnot (<v> : <t> ~> _ : <t'>)\n--------------------------------\n<v> : <t> ~> null : opt <t'>\n\nnull <: <t'>\nnot (null <: <t>)\n----------------------------\n<v> : <t> ~> null : opt <t'>\n```\n\n----------------------------------------\n\nTITLE: Defining Numeric Types in Candid\nDESCRIPTION: Grammar rule showing how primitive types in Candid include numeric types.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_8\n\nLANGUAGE: candid\nCODE:\n```\n<primtype> ::= <numtype> | ...\n```\n\n----------------------------------------\n\nTITLE: Reference Type Coercion in Candid\nDESCRIPTION: Defines coercion rules for function and service reference values, checking that the actual types are subtypes of expected types.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_72\n\nLANGUAGE: markup\nCODE:\n```\nfunc <functype> <: func <functype'>\n---------------------------------------------------------------------\nfunc <text>.id : func <functype> ~> func <text>.id : func <functype'>\n\nservice <actortype> <: service <actortype'>\n-----------------------------------------------------------------------------\nservice <text> : service <actortype> ~> service <text> : service <actortype'>\n\n------------------------------------------------------------\nprincipal <text> : principal ~> principal <text> : principal\n```\n\n----------------------------------------\n\nTITLE: Defining Natural Number Types in Candid\nDESCRIPTION: Grammar rule for natural number types in Candid, including the unlimited-range 'nat' and fixed-size variants (nat8, nat16, nat32, nat64).\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_9\n\nLANGUAGE: candid\nCODE:\n```\n<numtype> ::= nat | nat8 | nat16 | nat32 | nat64 | ...\n```\n\n----------------------------------------\n\nTITLE: Transitive Coherence Property in Candid\nDESCRIPTION: Describes the limits of transitive coherence in the type system, noting that while exact equality is not preserved, a weaker equivalence relation holds.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_75\n\nLANGUAGE: markup\nCODE:\n```\n<v1> : <t1> ~> <v2> : <t2>\n<v2> : <t2> ~> <v3> : <t3>\n<v1> : <t1> ~> <v3'> : <t3>\n```\n\n----------------------------------------\n\nTITLE: Defining Import Declarations in Candid\nDESCRIPTION: Grammar definition for import declarations in Candid. Imports allow splitting interface definitions across multiple files or sharing common definitions between interfaces.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_37\n\nLANGUAGE: candid\nCODE:\n```\n<def>   ::= ... | import service? <text>\n```\n\n----------------------------------------\n\nTITLE: Candid Reference Collection\nDESCRIPTION: Defines the R mapping that extracts references contained in Candid values. Used for tracking references across values of different types.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_79\n\nLANGUAGE: candid\nCODE:\n```\nR : <val> -> <primtype> -> <ref>*\nR(_ : <primtype>) = .\n\nR : <val> -> <constype> -> <ref>*\nR(null : opt <datatype>) = .\nR(?v   : opt <datatype>) = R(v : <datatype>)\nR(v*   : vec <datatype>) = R(v : <datatype>)*\nR(kv*  : record {<fieldtype>*}) = R(kv : <fieldtype>)*\nR(kv   : variant {<fieldtype>*}) = R(kv : <fieldtype>*[i])\n\nR : (<nat>, <val>) -> <fieldtype> -> <ref>*\nR((k,v) : k:<datatype>) = R(v : <datatype>)\n\nR : <val> -> <reftype> -> <ref>*\nR(ref(r) : service <actortype>) = r\nR(id(b*) : service <actortype>) = .\nR(ref(r)   : func <functype>) = r\nR(pub(s,n) : func <functype>) = .\nR(ref(r) : principal) = r\nR(id(b*) : principal) = .\n```\n\n----------------------------------------\n\nTITLE: Candid Test Suite Grammar Definition\nDESCRIPTION: Defines the grammar for Candid test files, including encoding tests and input format specifications. The grammar supports type definitions, encoding assertions, and value comparison tests.\nSOURCE: https://github.com/dfinity/candid/blob/master/test/README.md#2025-04-20_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\n<enctest>  ::= <def>;* <test>;*\n```\n\nLANGUAGE: grammar\nCODE:\n```\n<test> ::=\n      | assert <input> : <tuptype> <desc>\n      | assert <input> !: <tuptype> <desc>\n      | assert <input> == <input> : <tuptype> <desc>\n      | assert <input> != <input> : <tuptype> <desc>\n<input> ::= <text> | blob <text>\n<desc> ::=  <text>?\n```\n\n----------------------------------------\n\nTITLE: Defining Service Addition Rule in IDL Soundness Framework\nDESCRIPTION: A formal rule for adding a new service to the system state. The rule states that if service identifier A is fresh (not already present) in state S, then the state can transition to include A with service type s.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/IDL-Soundness.md#2025-04-20_snippet_0\n\nLANGUAGE: mathematical notation\nCODE:\n```\n    A fresh in S\n─────────────────────\n  S --> (A : s) ∪ S\n```\n\n----------------------------------------\n\nTITLE: Empty and Reserved Type Rules in Candid\nDESCRIPTION: Defines rules for 'empty' as a bottom type and 'reserved' as a top type in the type hierarchy, allowing any datatype to be considered a subtype of reserved, and empty to be a subtype of any datatype.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_48\n\nLANGUAGE: candid\nCODE:\n```\n-------------------------\n<datatype> <: reserved\n\n\n--------------------\nempty <: <datatype>\n```\n\n----------------------------------------\n\nTITLE: Rust Config Trait Definition\nDESCRIPTION: Rust trait definition for Config that applications must implement to handle configuration merging, unmatched configs, and state management during type AST traversal.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Type-selector.md#2025-04-20_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait Config {\n  fn merge_config(&mut self, config: &Self, ctx: &Context);\n  fn unmatched_config() -> Self;\n  fn update_state(&mut self, ctx: &Context);\n  fn restore_state(&mut self, ctx: &Context);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Service Evolution Rule in IDL Soundness Framework\nDESCRIPTION: A formal rule specifying how services can evolve their types. If a service type s1 can evolve to s2 (according to the ~> relation), then a service A can transition from having type s1 to having type s2.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/IDL-Soundness.md#2025-04-20_snippet_1\n\nLANGUAGE: mathematical notation\nCODE:\n```\n             s1 ~> s2\n────────────────────────────────\n{ A : s1, S' } --> { A : s2, S'}\n```\n\n----------------------------------------\n\nTITLE: Candid Memory Value Encoding\nDESCRIPTION: Defines the M mapping that serializes Candid values to byte sequences. Includes encoding for primitive values, composite values, and reference values.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_78\n\nLANGUAGE: candid\nCODE:\n```\nM : <val> -> <primtype> -> i8*\nM(n : nat)      = leb128(n)\nM(i : int)      = sleb128(i)\nM(n : nat<N>)   = i<N>(n)\nM(i : int<N>)   = i<N>(signed_N^-1(i))\nM(z : float<N>) = f<N>(z)\nM(b : bool)     = i8(if b then 1 else 0)\nM(t : text)     = leb128(|utf8(t)|) i8*(utf8(t))\nM(_ : null)     = .\nM(_ : reserved) = .\n\nM : <val> -> <constype> -> i8*\nM(null : opt <datatype>) = i8(0)\nM(?v   : opt <datatype>) = i8(1) M(v : <datatype>)\nM(v^N  : vec <datatype>) = leb128(N) M(v : <datatype>)^N\nM(kv*  : record {<fieldtype>*}) = M(kv : <fieldtype>)*\nM(kv   : variant {<fieldtype>*}) = leb128(i) M(kv : <fieldtype>*[i])\n\nM : (<nat>, <val>) -> <fieldtype> -> i8*\nM((k,v) : k:<datatype>) = M(v : <datatype>)\n\nM : <val> -> <reftype> -> i8*\nM(ref(r) : service <actortype>) = i8(0)\nM(id(v*) : service <actortype>) = i8(1) M(v* : vec nat8)\n\nM(ref(r)   : func <functype>) = i8(0)\nM(pub(s,n) : func <functype>) = i8(1) M(s : service {}) M(n : text)\n\nM(ref(r) : principal) = i8(0)\nM(id(v*) : principal) = i8(1) M(v* : vec nat8)\n```\n\n----------------------------------------\n\nTITLE: Defining Service Discovery Rule in IDL Soundness Framework\nDESCRIPTION: A formal rule for how services learn about other services. If service A with type s exists in state S, then the state can transition to one where service B has a reference to A at type s.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/IDL-Soundness.md#2025-04-20_snippet_2\n\nLANGUAGE: mathematical notation\nCODE:\n```\n         A : s ∈ S\n────────────────────────────\n  S  --> (B has A : s) ∪ S\n```\n\n----------------------------------------\n\nTITLE: Defining Host-Language Subtyping Rule in IDL Soundness Framework\nDESCRIPTION: A formal rule allowing host-language subtyping to apply to service references. If A has a reference to B at type s1, and s1 is a subtype of s2 in the host language, then A can also reference B at type s2.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/IDL-Soundness.md#2025-04-20_snippet_4\n\nLANGUAGE: mathematical notation\nCODE:\n```\n  A has B at s1 ∈ S   s1 <:h s2\n──────────────────────────────────\n     S --> (A has B : s2) ∪ S\n```\n\n----------------------------------------\n\nTITLE: Type Relation Properties in Candid\nDESCRIPTION: Specifies formal properties of the type coercion system including reflexivity, transitivity, roundtripping, well-typedness, and soundness.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_74\n\nLANGUAGE: markup\nCODE:\n```\n<t> <: <t>\n\n<t> <: <t'>, <t'> <: <t''> ⇒ <t> <: <t'>\n\n(<v> : <t>) ⟺ <v> : <t> ~> <v> : <t>\n\n<v> : <t> ~> <v'> : <t'> ⇒ <v'> : <t'>\n\n<t> <: <t'> ⇒ ∀ <v> : <t> ∃ <v'>. <v> : <t> ~> <v'> : <t'>\n\ns1 ~> s2 ≔ s2 <: s1\nt1 <: t2 ≔ t1 <: t2\ns1 in t1 <: s2 in t2 ≔ (to be done)\ns1 <:h s2 ≔ (host-language dependent)\n```\n\n----------------------------------------\n\nTITLE: Defining Reply Communication Rule in IDL Soundness Framework\nDESCRIPTION: A formal rule defining when service A can send a response of type t1 to service B that expects type t1'. This rule applies when B has a reference to A as a function returning type t1', and A actually returns type t1.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/IDL-Soundness.md#2025-04-20_snippet_6\n\nLANGUAGE: mathematical notation\nCODE:\n```\n  B has A : _ -> t1' ∈ S   A : _ -> t1 ∈ S\n──────────────────────────────────────────────\n             [S] A =(t1)=(t1')=> B\n```\n\n----------------------------------------\n\nTITLE: Defining Enumeration Types in Candid\nDESCRIPTION: Grammar rule showing how variant fields can omit their types, defaulting to 'null', to create enumeration types.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_26\n\nLANGUAGE: candid\nCODE:\n```\n<fieldtype> ::= ...\n  | <nat>    :=  <nat> : null\n  | <name>   :=  <name> : null\n```\n\n----------------------------------------\n\nTITLE: Example Candid Interface Definition\nDESCRIPTION: Sample Candid interface defining a recursive tree type, a record type, and a service with a function that takes and returns pairs. Used as a reference for demonstrating the type selector functionality.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Type-selector.md#2025-04-20_snippet_1\n\nLANGUAGE: did\nCODE:\n```\ntype tree = variant { leaf: int; branch: record { left: tree; right: tree } };\ntype pair = record { left: int; right: int };\nservice : {\n  f : (pair, pair) -> (pair);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Floating-Point Types in Candid\nDESCRIPTION: Grammar rule for floating-point types in Candid, supporting single precision (float32) and double precision (float64) IEEE 754 formats.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_11\n\nLANGUAGE: candid\nCODE:\n```\n<numtype> ::= ... | float32 | float64\n```\n\n----------------------------------------\n\nTITLE: Option Type Subtyping Rule in Candid\nDESCRIPTION: Defines how option types can be specialized through their constituent types during upgrades.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_50\n\nLANGUAGE: candid\nCODE:\n```\n<datatype> <: <datatype'>\n---------------------------------\nopt <datatype> <: opt <datatype'>\n```\n\n----------------------------------------\n\nTITLE: Random Configuration Properties for Candid in Dhall\nDESCRIPTION: Defines properties for random value generation in Candid, including range limits, text generation options, and depth/size constraints. These properties are specified using Dhall syntax.\nSOURCE: https://github.com/dfinity/candid/blob/master/tools/didc/config.md#2025-04-20_snippet_2\n\nLANGUAGE: dhall\nCODE:\n```\nlet default =  {- This is the default config -}\n      { range = None (List Natural)\n      , text = Some \"ascii\"\n      , width = Some 10\n      , depth = Some 10\n      , size = Some 100\n      , value = None (List Text)\n      }\n\nin  default /\\\n    { {- Generate (record {a=42; b=1}, record {a=any int; b=1}) for method f  -}\n      `[f]` =\n      { `[0]`.a = { range = Some [ 42,42 ] }\n      , b = { value = Some [\"1\"] }\n      }\n      \n    {- Left tree is leaf only; Left tree has negative numbers and right tree has positive numbers -}\n    , left.tree = { depth = Some 1, range = Some [ -200, -100 ] }\n    , right.tree = { depth = Some 5, range = Some [ 100, 200 ] }\n    \n    {- Customize text fields in record type -}\n    , profile.record =\n      { name.text = Some \"name\"\n      , age.range = Some [ 18, 65 ]\n      , company.text = Some \"company\"\n      , country.text = Some \"country\"\n      , file.text = Some \"path\"\n      , description.text = Some \"bs\"\n      }\n      \n    {- Generate principal id -}\n    , principal.value = Some [\"principal \\\"aaaaa-aa\\\"\", \"principal \\\"2vxsx-fae\\\"\"]\n    }\n```\n\n----------------------------------------\n\nTITLE: Candid Type Definition Index Encoding\nDESCRIPTION: Specifies how nested types are encoded using either primitive types or indices into type definitions, enabling recursive types and type sharing.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_77\n\nLANGUAGE: candid\nCODE:\n```\nI : <datatype> -> i8*\nI(<primtype>) = T(<primtype>)\nI(<comptype>) = sleb128(i)  where type definition i defines T(<datatype>)\n```\n\n----------------------------------------\n\nTITLE: Candid Type Definition for Configuration Structure\nDESCRIPTION: Defines the Candid type structure for representing configuration options, including RandomConfig and nested node structures. This demonstrates how Candid itself could be used as a configuration language.\nSOURCE: https://github.com/dfinity/candid/blob/master/tools/didc/config.md#2025-04-20_snippet_3\n\nLANGUAGE: candid\nCODE:\n```\ntype RandomConfig = record { \n  range: opt record { int; int }; \n  depth: opt nat;\n  ...\n};\ntype node = record { \n  config: opt RandomConfig; \n  branch: configs \n};\ntype configs = vec record { text; node };\n```\n\n----------------------------------------\n\nTITLE: Vector Subtyping Rule in Candid\nDESCRIPTION: Defines how vector types can be specialized through their constituent types during upgrades.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_49\n\nLANGUAGE: candid\nCODE:\n```\n<datatype> <: <datatype'>\n---------------------------------\nvec <datatype> <: vec <datatype'>\n```\n\n----------------------------------------\n\nTITLE: Building Candid UI Project with DFX, Cargo, NPM, and Wasm-opt\nDESCRIPTION: This code snippet provides the commands to build the Candid UI project. It includes steps for installing dependencies, starting the DFX environment, creating and building canisters, and installing them.\nSOURCE: https://github.com/dfinity/candid/blob/master/tools/ui/README.md#2025-04-20_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd ui/\nnpm install\ndfx start --background\ndfx canister create --all\ndfx build\ndfx canister install --all\n```\n\n----------------------------------------\n\nTITLE: Example Candid Types for Selector Demonstration\nDESCRIPTION: Provides sample Candid type definitions to demonstrate how type selectors can be used to target specific elements within complex type structures.\nSOURCE: https://github.com/dfinity/candid/blob/master/tools/didc/config.md#2025-04-20_snippet_1\n\nLANGUAGE: candid\nCODE:\n```\ntype tree = variant { leaf: int; branch: record { left: tree; right: tree } };\ntype pair = record { left: int; right: nat };\ntype left = opt int;\nservice : {\n  f : (record {a:int; b:int}, record {a:int; b:int}) -> ();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CandidType for PhantomData in Rust\nDESCRIPTION: Adds implementation of CandidType trait for std::marker::PhantomData.\nSOURCE: https://github.com/dfinity/candid/blob/master/Changelog.md#2025-04-20_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl CandidType for std::marker::PhantomData\n```\n\n----------------------------------------\n\nTITLE: Tuple Type Coercion in Candid\nDESCRIPTION: Specifies how tuple types are coerced by treating them as record-like structures, handling extra arguments and missing parameters.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_73\n\nLANGUAGE: markup\nCODE:\n```\nrecord { <v>;* } : record { <t>;* } ~> record { <v'>;* } : record { <t'>;* }\n----------------------------------------------------------------------------\n(<v>,*) : (<t>,*) ~> (<v'>,*) : (<t'>,*)\n```\n\n----------------------------------------\n\nTITLE: Adding Capacity Reservation Method in Rust\nDESCRIPTION: Adds a method to reserve capacity before serializing large amounts of data.\nSOURCE: https://github.com/dfinity/candid/blob/master/Changelog.md#2025-04-20_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nIDLBuilder.try_reserve_value_serializer_capacity()\n```\n\n----------------------------------------\n\nTITLE: Defining Tuple Field Shorthand in Candid\nDESCRIPTION: Grammar rule showing how field IDs can be omitted in records, using sequential numbering starting from 0.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_23\n\nLANGUAGE: candid\nCODE:\n```\n<fieldtype> ::= ...\n  | <datatype>    :=  N : <datatype>\n```\n\n----------------------------------------\n\nTITLE: Defining Numeric ID Format in Candid\nDESCRIPTION: Grammar rule showing the format of numeric IDs in Candid, allowing decimal or hexadecimal notation with optional underscores.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_21\n\nLANGUAGE: candid\nCODE:\n```\n<nat> ::= (0..9)(_? 0..9)* | 0x(0..9|a..f|A..F)(_? 0..9|a..f|A..F)*\n```\n\n----------------------------------------\n\nTITLE: Adding MotokoResult Type in Rust\nDESCRIPTION: Adds a new type for handling Motoko-style results and conversions to/from Rust results.\nSOURCE: https://github.com/dfinity/candid/blob/master/Changelog.md#2025-04-20_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ncandid::MotokoResult\nmotoko_result.into_result()\nrust_result.into()\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean Type in Candid\nDESCRIPTION: Grammar rule showing the boolean type in Candid, represented by 'bool'.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_12\n\nLANGUAGE: candid\nCODE:\n```\n<primtype> ::= ... | bool | ...\n```\n\n----------------------------------------\n\nTITLE: Examples of Variant Types in Candid\nDESCRIPTION: Examples of variant type definitions in Candid, including a simple enumeration and a recursive tree structure.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_27\n\nLANGUAGE: candid\nCODE:\n```\ntype color = variant { red; green; blue };\n\ntype tree = variant {\n  leaf : int;\n  branch : record {left : tree; val : int; right : tree};\n}\n```\n\n----------------------------------------\n\nTITLE: Null to Option Subtyping Rule in Candid\nDESCRIPTION: Specifies that null can be treated as a subtype of any option type.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_51\n\nLANGUAGE: candid\nCODE:\n```\n------------------------\nnull <: opt <datatype>\n```\n\n----------------------------------------\n\nTITLE: Defining Symbolic Field IDs in Candid\nDESCRIPTION: Grammar rule showing how symbolic field names are converted to numeric IDs using a hash function in Candid.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_22\n\nLANGUAGE: candid\nCODE:\n```\n<fieldtype> ::= ...\n  | <name> : <datatype>    :=  <hash(name)> : <datatype>\n```\n\n----------------------------------------\n\nTITLE: Defining Call Communication Rule in IDL Soundness Framework\nDESCRIPTION: A formal rule defining when service A can send a message of type t1 to service B that expects type t1'. This rule applies when A has a reference to B as a function accepting type t1, and B actually has type t1'.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/IDL-Soundness.md#2025-04-20_snippet_5\n\nLANGUAGE: mathematical notation\nCODE:\n```\n  A has B : t1 -> _ ∈ S   B : t1' -> _ ∈ S\n──────────────────────────────────────────────\n             [S] A =(t1)=(t1')=> B\n```\n\n----------------------------------------\n\nTITLE: Defining Reference Sending Rule in IDL Soundness Framework\nDESCRIPTION: A formal rule for how services can send references to other services. If A has a reference to C at type s1, A can send a message to B, and the reference type evolves correctly, then B gains a reference to C at type s2.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/IDL-Soundness.md#2025-04-20_snippet_3\n\nLANGUAGE: mathematical notation\nCODE:\n```\n  A has C at s1 ∈ S    [S] A =(t1)=(t2)=> B    s1 in t1 <: s2 in t2\n────────────────────────────────────────────────────────────────────\n                       S --> (B has C : s2) ∪ S\n```\n\n----------------------------------------\n\nTITLE: Defining Reserved Type in Candid\nDESCRIPTION: Grammar rule showing the reserved type in Candid, used to occupy field IDs in records for backward/forward compatibility.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_15\n\nLANGUAGE: candid\nCODE:\n```\n<primtype> ::= ... | reserved\n```\n\n----------------------------------------\n\nTITLE: Example Candid Configuration for Tree Depth Limitation\nDESCRIPTION: Demonstrates how to use Candid syntax to specify a configuration for limiting the depth of a tree's left branch. This example highlights the verbosity of using Candid directly for configuration.\nSOURCE: https://github.com/dfinity/candid/blob/master/tools/didc/config.md#2025-04-20_snippet_4\n\nLANGUAGE: candid\nCODE:\n```\nvec {\n  record { \n    \"left\"; \n    record { \n      branch = vec { \n        record { \n          \"tree\"; \n          record { \n            config = opt record { depth = opt 1 }; \n            branch = vec {}\n          }\n        }\n      };\n    }\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Empty Record Subtyping Rule in Candid\nDESCRIPTION: Specifies that any record type can be considered a supertype of the empty record.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_54\n\nLANGUAGE: candid\nCODE:\n```\n---------------------------------------\nrecord { <fieldtype'>;* } <: record { }\n```\n\n----------------------------------------\n\nTITLE: Defining Null Type in Candid\nDESCRIPTION: Grammar rule showing the null type in Candid, which has exactly one value and carries no information.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_14\n\nLANGUAGE: candid\nCODE:\n```\n<primtype> ::= ... | null | ...\n```\n\n----------------------------------------\n\nTITLE: Coercion to Reserved Type in Candid\nDESCRIPTION: Defines how any value coerces to the reserved type, using null as the canonical value.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_64\n\nLANGUAGE: markup\nCODE:\n```\n--------------------------\n_ : <t> ~> null : reserved\n```\n\n----------------------------------------\n\nTITLE: Example of Invalid Cyclic Type Definition in Candid\nDESCRIPTION: Example showing an invalid cyclic type definition in Candid, where types reference each other without a productive type expression.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_36\n\nLANGUAGE: candid\nCODE:\n```\ntype A = B;\ntype B = A;  // error: cyclic type definition\n```\n\n----------------------------------------\n\nTITLE: Defining Empty Type in Candid\nDESCRIPTION: Grammar rule showing the empty type in Candid, used to mark absent variants or unused function arguments.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_16\n\nLANGUAGE: candid\nCODE:\n```\n<primtype> ::= ... | empty\n```\n\n----------------------------------------\n\nTITLE: Comment Syntax in Candid\nDESCRIPTION: Defines the syntax for single-line and block comments in Candid. Unlike C-style comments, Candid block comments can be properly nested within each other.\nSOURCE: https://github.com/dfinity/candid/blob/master/spec/Candid.md#2025-04-20_snippet_2\n\nLANGUAGE: candid\nCODE:\n```\n<comment> ::=\n  | //<codepoint>*<nl>\n  | /*(<codepoint>|<comment>)*/\n```\n\n----------------------------------------\n\nTITLE: Adding Reference Encoding Methods in Rust\nDESCRIPTION: Adds new methods for encoding arguments by reference without consuming the value.\nSOURCE: https://github.com/dfinity/candid/blob/master/Changelog.md#2025-04-20_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nArgumentEncoder::encode_ref\nutils::{write_args, encode_args}\n```"
  }
]