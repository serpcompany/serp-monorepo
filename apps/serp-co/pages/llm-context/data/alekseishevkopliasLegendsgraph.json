[
  {
    "owner": "alekseishevkoplias",
    "repo": "legendsgraph",
    "content": "TITLE: Interactive Graph Editor with PyQt5\nDESCRIPTION: Creates an interactive graph editor using PyQt5 and matplotlib, allowing for visual manipulation of network graphs.\nSOURCE: https://github.com/alekseishevkoplias/legendsgraph/blob/main/playground.ipynb#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nimport matplotlib; matplotlib.use(\"Qt5Agg\")\n\nfrom PyQt5 import QtWidgets, QtCore\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg, NavigationToolbar2QT\nfrom matplotlib.figure import Figure\nfrom netgraph import EditableGraph\n\n\nclass MplCanvas(FigureCanvasQTAgg):\n    def __init__(self, parent=None, width=5, height=4, dpi=100):\n        super(MplCanvas, self).__init__(Figure(figsize=(width, height), dpi=dpi))\n        self.setParent(parent)\n        self.ax = self.figure.add_subplot(111)\n        self.graph = EditableGraph([(6, 41), (11, 26), (28, 29), (30, 10), (21, 1), (40, 15), (17, 27), (23, 10), (36, 35), (26, 12), (33, 20), (38, 21), (27, 15), (13, 18), (28, 19), (12, 4), (4, 19), (45, 16), (38, 46), (32, 13), (2, 26), (33, 9), (34, 6), (16, 48), (21, 33), (42, 48), (36, 14), (14, 12), (7, 18), (5, 39), (5, 29), (18, 47), (13, 37), (2, 6), (34, 48), (26, 6), (22, 48), (1, 6), (3, 12), (31, 21), (5, 18), (7, 15), (28, 12), (18, 25), (13, 23), (27, 35), (38, 37), (29, 31), (4, 30), (22, 21)], ax=self.ax)\n\n\nclass MainWindow(QtWidgets.QMainWindow):\n    def __init__(self, *args, **kwargs):\n        super(MainWindow, self).__init__(*args, **kwargs)\n\n        self.canvas = MplCanvas(self, width=5, height=4, dpi=100)\n\n        # Enable key_press_event events:\n        # https://github.com/matplotlib/matplotlib/issues/707/#issuecomment-4181799\n        self.canvas.setFocusPolicy(QtCore.Qt.ClickFocus)\n        self.canvas.setFocus()\n\n        self.toolbar = NavigationToolbar2QT(self.canvas, self)\n\n        widget = QtWidgets.QWidget()\n        self.setCentralWidget(widget)\n\n        layout = QtWidgets.QVBoxLayout(widget)\n        layout.addWidget(self.toolbar)\n        layout.addWidget(self.canvas)\n\n\ndef main():\n    app = QtWidgets.QApplication(sys.argv)\n    w = MainWindow()\n    w.show()\n    app.exec_()\n\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing ZoomPan Class for Interactive Graph Navigation in Python\nDESCRIPTION: A custom class that adds zooming and panning capabilities to the graph visualization. It handles mouse scroll events for zooming and mouse drag events for panning, allowing users to navigate large graphs more easily.\nSOURCE: https://github.com/alekseishevkoplias/legendsgraph/blob/main/playground.ipynb#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass ZoomPan:\n    def __init__(self):\n        self.press = None\n        self.cur_xlim = None\n        self.cur_ylim = None\n        self.x0 = None\n        self.y0 = None\n        self.x1 = None\n        self.y1 = None\n        self.xpress = None\n        self.ypress = None\n\n\n    def zoom_factory(self, ax, base_scale = 2.):\n        def zoom(event):\n            cur_xlim = ax.get_xlim()\n            cur_ylim = ax.get_ylim()\n\n            xdata = event.xdata # get event x location\n            ydata = event.ydata # get event y location\n\n            if event.button == 'down':\n                # deal with zoom in\n                scale_factor = 1 / base_scale\n            elif event.button == 'up':\n                # deal with zoom out\n                scale_factor = base_scale\n            else:\n                # deal with something that should never happen\n                scale_factor = 1\n                print(event.button)\n\n            new_width = (cur_xlim[1] - cur_xlim[0]) * scale_factor\n            new_height = (cur_ylim[1] - cur_ylim[0]) * scale_factor\n\n            relx = (cur_xlim[1] - xdata)/(cur_xlim[1] - cur_xlim[0])\n            rely = (cur_ylim[1] - ydata)/(cur_ylim[1] - cur_ylim[0])\n\n            ax.set_xlim([xdata - new_width * (1-relx), xdata + new_width * (relx)])\n            ax.set_ylim([ydata - new_height * (1-rely), ydata + new_height * (rely)])\n            ax.figure.canvas.draw()\n\n        fig = ax.get_figure() # get the figure of interest\n        fig.canvas.mpl_connect('scroll_event', zoom)\n\n        return zoom\n\n    def pan_factory(self, ax):\n        def onPress(event):\n            if event.inaxes != ax: return\n            self.cur_xlim = ax.get_xlim()\n            self.cur_ylim = ax.get_ylim()\n            self.press = self.x0, self.y0, event.xdata, event.ydata\n            self.x0, self.y0, self.xpress, self.ypress = self.press\n\n        def onRelease(event):\n            self.press = None\n            ax.figure.canvas.draw()\n\n        def onMotion(event):\n            if self.press is None: return\n            if event.inaxes != ax: return\n            dx = event.xdata - self.xpress\n            dy = event.ydata - self.ypress\n            self.cur_xlim -= dx\n            self.cur_ylim -= dy\n            ax.set_xlim(self.cur_xlim)\n            ax.set_ylim(self.cur_ylim)\n\n            ax.figure.canvas.draw()\n\n        fig = ax.get_figure() # get the figure of interest\n\n        # attach the call back\n        fig.canvas.mpl_connect('button_press_event',onPress)\n        fig.canvas.mpl_connect('button_release_event',onRelease)\n        fig.canvas.mpl_connect('motion_notify_event',onMotion)\n\n        #return the function\n        return onMotion\n```\n\n----------------------------------------\n\nTITLE: Setting Up Zoom and Pan Functionality for Graph Visualization in Python\nDESCRIPTION: Initializes the ZoomPan class and connects its zoom and pan factories to the graph's axes. This adds interactive zoom and pan capabilities to the graph visualization, allowing users to explore the graph in detail.\nSOURCE: https://github.com/alekseishevkoplias/legendsgraph/blob/main/playground.ipynb#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nscale = 1.1\nzp = ZoomPan()\nfigZoom = zp.zoom_factory(ax, base_scale = scale)\nfigPan = zp.pan_factory(ax)\n\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Implementing AnnoteFinder Class for Node Click Detection in NetworkX Graphs in Python\nDESCRIPTION: A custom class that detects and handles node click events in a matplotlib-based network visualization. It calculates the closest node to the click position within a specified tolerance, and triggers a callback function when a node is selected.\nSOURCE: https://github.com/alekseishevkoplias/legendsgraph/blob/main/playground.ipynb#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass AnnoteFinder:  # thanks to http://www.scipy.org/Cookbook/Matplotlib/Interactive_Plotting\n    \"\"\"\n    callback for matplotlib to visit a node (display an annotation) when points are clicked on.  The\n    point which is closest to the click and within xtol and ytol is identified.\n    \"\"\"\n    def __init__(self, xdata, ydata, annotes, callback = None, threshold=None, axis=None, xtol=None, ytol=None):\n        self.data = list(zip(xdata, ydata, annotes))\n        if xtol is None: xtol = ((max(xdata) - min(xdata))/float(len(xdata)))/2\n        if ytol is None: ytol = ((max(ydata) - min(ydata))/float(len(ydata)))/2\n        self.xtol = xtol\n        self.ytol = ytol\n        if axis is None: axis = gca()\n        self.axis= axis\n        self.drawnAnnotations = {}\n        self.links = []\n        self.callback = callback\n        self.threshold = threshold if threshold else 1.0e-3\n\n    def __call__(self, event):\n        if event.inaxes:\n            clickX = event.xdata\n            clickY = event.ydata\n            if self.axis is None or self.axis==event.inaxes:\n                annotes = []\n                smallest_x_dist = float('inf')\n                smallest_y_dist = float('inf')\n                for x,y,a in self.data:\n                    if abs(clickX-x)<=smallest_x_dist and abs(clickY-y)<=smallest_y_dist :\n                        dx, dy = x - clickX, y - clickY\n                        annotes.append((dx*dx+dy*dy,x,y, a) )\n                        smallest_x_dist=abs(clickX-x)\n                        smallest_y_dist=abs(clickY-y)\n                if annotes:\n                    annotes.sort() # to select the nearest node\n                    distance, x, y, annote = annotes[0]\n                    print(distance)\n                    if distance < self.threshold:\n                        if self.callback:\n                            self.callback(annote)\n```\n\n----------------------------------------\n\nTITLE: Building and Visualizing Karate Club Graph with NetworkX in Python\nDESCRIPTION: Creates a NetworkX graph using the Karate Club dataset, computes a spring layout for node positioning, and extracts node coordinates for click detection. The graph is then drawn with custom styling parameters.\nSOURCE: https://github.com/alekseishevkoplias/legendsgraph/blob/main/playground.ipynb#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Build your graph\nG = nx.karate_club_graph()\npos = nx.spring_layout(G,k=0.1, iterations=20)  # the layout gives us the nodes position x,y,annotes=[],[],[] for key in pos:\nx, y, annotes = [], [], []\nfor key in pos:\n    d = pos[key]\n    annotes.append(key)\n    x.append(d[0])\n    y.append(d[1])\n\nfig = plt.figure(figsize=(10,10))\nax = fig.add_subplot(111)\n\nnx.draw(G, pos, font_size=6, node_color='skyblue', edge_color='#BB0000', width=0.5, node_size=200, with_labels=True)\n```\n\n----------------------------------------\n\nTITLE: Interactive Network Graph with Node Click Events\nDESCRIPTION: Creates an interactive network graph with clickable nodes that trigger alert messages using Pyvis and NetworkX.\nSOURCE: https://github.com/alekseishevkoplias/legendsgraph/blob/main/playground.ipynb#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport networkx as nx\nfrom pyvis.network import Network\n\ndef on_node_click(node_id):\n    print('CLICKED:', node_id)\n\nG = nx.karate_club_graph()\nnt = Network(height='400px', width='100%', directed=False)\n\nfor node in G.nodes:\n    nt.add_node(node, onclick=f\"alert('CLICKED: {node}')\")\n\nfor edge in G.edges:\n    nt.add_edge(edge[0], edge[1])\n\nnt.set_options(\"\"\"\nvar options = {\n  \"nodes\": {\n    \"borderWidth\": 2\n  },\n  \"edges\": {\n    \"color\": {\n      \"inherit\": true\n    },\n    \"smooth\": {\n      \"type\": \"continuous\"\n    }\n  },\n  \"physics\": {\n    \"minVelocity\": 0.75\n  }\n}\n\"\"\")\n\nnt.write_html(\"graph.html\", notebook=False)\nnt.show(\"graph.html\")\n```\n\n----------------------------------------\n\nTITLE: Tkinter-based Graph Visualization App\nDESCRIPTION: Creates a GUI application using Tkinter for graph visualization with interactive node selection and connection display.\nSOURCE: https://github.com/alekseishevkoplias/legendsgraph/blob/main/playground.ipynb#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport networkx as nx\nfrom pyvis.network import Network\nimport tkinter as tk\nfrom tkinter import ttk\n\nimport re\n\n\n\n\n\n\nclass App(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title(\"Graph Visualization\")\n\n        self.notebook = ttk.Notebook(self)\n        self.notebook.pack(expand=True, fill='both')\n\n        self.init_graph()\n\n    def init_graph(self):\n        G = nx.karate_club_graph()\n        self.nt = Network(height='400px', width='100%', directed=False)\n\n        for node in G.nodes:\n            self.nt.add_node(node)\n\n        for edge in G.edges:\n            self.nt.add_edge(edge[0], edge[1])\n\n        self.nt.set_options(\"\"\"\n        var options = {\n          \"nodes\": {\n            \"borderWidth\": 2\n          },\n          \"edges\": {\n            \"color\": {\n              \"inherit\": true\n            },\n            \"smooth\": {\n              \"type\": \"continuous\"\n            }\n          },\n          \"physics\": {\n            \"minVelocity\": 0.75\n          }\n        }\n        \"\"\")\n\n        self.nt.show(\"graph.html\")\n\n        graph_frame = ttk.Frame(self.notebook)\n        self.notebook.add(graph_frame, text=\"Graph\")\n\n        self.webview = tk.Text(graph_frame, wrap=\"word\", width=80, height=20)\n        self.webview.pack(expand=True, fill='both')\n\n        with open(\"graph.html\") as file:\n            html_code = file.read()\n\n        self.webview.insert('1.0', html_code)\n\n        self.webview.tag_bind(\"node\", \"<Button-1>\", self.on_node_click)\n\n        pattern = re.compile(rf'>({node})</span>')\n        \n        for node in G.nodes:\n            match = pattern.search(html_code)\n            if match:\n                start_index = self.webview.search(match.group(1), \"1.0\", stopindex=tk.END)\n                end_index = self.webview.index(f\"{start_index} + {len(str(node))}c\")\n                self.webview.tag_add(\"node\", start_index, end_index)\n\n    def on_node_click(self, event):\n        index = self.webview.index(f\"@{event.x},{event.y}\")\n        node = int(self.webview.get(index))\n\n        node_connections = list(self.nt.get_adj_list()[node])\n\n        connections_frame = ttk.Frame(self.notebook)\n        self.notebook.add(connections_frame, text=f\"Node {node}\")\n\n        connections_label = tk.Label(connections_frame, text=f\"Node {node} is connected to nodes: {', '.join(map(str, node_connections))}\")\n        connections_label.pack()\n\n        self.notebook.select(connections_frame)\n\n\napp = App()\napp.mainloop()\n```\n\n----------------------------------------\n\nTITLE: Zachary's Karate Club Graph Visualization\nDESCRIPTION: Creates and displays an interactive visualization of the Zachary's Karate Club graph using NetworkX and Pyvis, with physics controls enabled.\nSOURCE: https://github.com/alekseishevkoplias/legendsgraph/blob/main/playground.ipynb#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport networkx as nx\nG = nx.karate_club_graph()\n\ng4 = net.Network(height='400px', width='50%', notebook=True, heading='Zachary's Karate Club graph')\n\ng4.from_nx(G)\n\ng4.show_buttons(filter_=['physics'])\ng4.show('karate.html')\n```\n\n----------------------------------------\n\nTITLE: Connecting AnnoteFinder to Graph for Node Click Detection in Python\nDESCRIPTION: Initializes the AnnoteFinder with node coordinates and IDs, then connects it to the Matplotlib button press event. This enables the detection of node clicks on the graph visualization.\nSOURCE: https://github.com/alekseishevkoplias/legendsgraph/blob/main/playground.ipynb#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\naf = AnnoteFinder(x, y, annotes, my_callback)\nconnect('button_press_event', af)\n```\n\n----------------------------------------\n\nTITLE: Holoviews Graph Visualization Setup\nDESCRIPTION: Configures Holoviews for advanced graph visualization with datashader integration and custom styling options.\nSOURCE: https://github.com/alekseishevkoplias/legendsgraph/blob/main/playground.ipynb#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport holoviews as hv\nfrom holoviews import opts, dim\nimport networkx as nx\nimport dask.dataframe as dd\n\nfrom holoviews.operation.datashader import (\n    datashade, dynspread, directly_connect_edges, bundle_graph, stack\n)\nfrom holoviews.element.graphs import layout_nodes\nfrom datashader.layout import random_layout\nfrom colorcet import fire\n\nhv.extension('bokeh')\n\nkeywords = dict(bgcolor='black', width=800, height=800, xaxis=None, yaxis=None)\nopts.defaults(opts.Graph(**keywords), opts.Nodes(**keywords), opts.RGB(**keywords))\n```\n\n----------------------------------------\n\nTITLE: Network Graph with Custom JavaScript Events\nDESCRIPTION: Creates a network graph with custom JavaScript event handling for node clicks, implemented through HTML file modification.\nSOURCE: https://github.com/alekseishevkoplias/legendsgraph/blob/main/playground.ipynb#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport networkx as nx\nfrom pyvis.network import Network\n\nG = nx.karate_club_graph()\nnt = Network(height='400px', width='100%', directed=False)\n\nfor node in G.nodes:\n    nt.add_node(node)\n\nfor edge in G.edges:\n    nt.add_edge(edge[0], edge[1])\n\nnt.set_options(\"\"\"\nvar options = {\n  \"nodes\": {\n    \"borderWidth\": 2\n  },\n  \"edges\": {\n    \"color\": {\n      \"inherit\": true\n    },\n    \"smooth\": {\n      \"type\": \"continuous\"\n    }\n  },\n  \"physics\": {\n    \"minVelocity\": 0.75\n  }\n}\n\"\"\")\n\nhtml_file = \"graph.html\"\nnt.write_html(html_file, notebook=False)\n\n# Add the JavaScript code to the generated HTML file\nwith open(html_file, 'r') as file:\n    html_code = file.read()\n\njs_code = \"\"\"\n<script>\n  function on_node_click(node_id) {\n    alert('CLICKED: ' + node_id);\n  }\n</script>\n\"\"\"\n\nhtml_code = html_code.replace(\"</body>\", f\"{js_code}\\n</body>\")\n\nwith open(html_file, 'w') as file:\n    file.write(html_code)\n\nnt.show(html_file)\n```\n\n----------------------------------------\n\nTITLE: Defining Node Click Callback Function for NetworkX Graph in Python\nDESCRIPTION: A simple callback function that prints the ID of the node when it's clicked in the graph visualization. This function is passed to the AnnoteFinder to be executed when a node is selected.\nSOURCE: https://github.com/alekseishevkoplias/legendsgraph/blob/main/playground.ipynb#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef my_callback(node_id):\n    print(f'Clicked {node_id}')\n```\n\n----------------------------------------\n\nTITLE: Interactive Bar Chart with Bokeh\nDESCRIPTION: Creates an interactive bar chart showing mean MPG by cylinders and manufacturer using Bokeh, including hover tooltips and custom styling.\nSOURCE: https://github.com/alekseishevkoplias/legendsgraph/blob/main/playground.ipynb#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom bokeh.models import ColumnDataSource, HoverTool\nfrom bokeh.plotting import figure\nfrom bokeh.sampledata.autompg import autompg_clean as df\nfrom bokeh.transform import factor_cmap\n\ndf.cyl = df.cyl.astype(str)\ndf.yr = df.yr.astype(str)\n\ngroup = df.groupby(by=['cyl', 'mfr'])\nsource = ColumnDataSource(group)\n\np = figure(width=800, height=300, title=\"Mean MPG by # Cylinders and Manufacturer\",\n           x_range=group, toolbar_location=None, tools=\"\")\n\np.xgrid.grid_line_color = None\np.xaxis.axis_label = \"Manufacturer grouped by # Cylinders\"\np.xaxis.major_label_orientation = 1.2\n\nindex_cmap = factor_cmap('cyl_mfr', palette=['#2b83ba', '#abdda4', '#ffffbf', '#fdae61', '#d7191c'], \n                         factors=sorted(df.cyl.unique()), end=1)\n\np.vbar(x='cyl_mfr', top='mpg_mean', width=1, source=source,\n       line_color=\"white\", fill_color=index_cmap, \n       hover_line_color=\"darkgrey\", hover_fill_color=index_cmap)\n\np.add_tools(HoverTool(tooltips=[(\"MPG\", \"@mpg_mean\"), (\"Cyl, Mfr\", \"@cyl_mfr\")]))\n\nshow(p)\n```\n\n----------------------------------------\n\nTITLE: Importing Network Visualization Libraries\nDESCRIPTION: Initial imports of pyvis network and IPython display modules for graph visualization.\nSOURCE: https://github.com/alekseishevkoplias/legendsgraph/blob/main/playground.ipynb#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyvis import network as net\nfrom IPython.core.display import display, HTML\n```"
  }
]