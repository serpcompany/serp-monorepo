[
  {
    "owner": "panda-re",
    "repo": "panda",
    "content": "TITLE: Defining Linux System Call Prototypes in C\nDESCRIPTION: This snippet defines numerous Linux system call prototypes as C function declarations, detailing each syscall's return type and parameters. The code assumes inclusion of relevant types and kernel header dependencies such as <linux/types.h> and <linux/time.h>. Each declaration serves as the kernel entry point signature for specific operations; for example, sys_mount() manages filesystem mounting, while sys_sync() flushes filesystem buffers. Parameters such as pointers prefixed with __user indicate memory originating from userspace. The functions are used internally by the kernel, with inputs and outputs adhering strictly to their prototypes and constraints such as argument types, pointer safety, and privilege requirements.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_x64_prototypes.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n160 long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim);\\n161 long sys_chroot(const char __user *filename);\\n162 long sys_sync(void);\\n163 long sys_acct(const char __user *name);\\n164 long sys_settimeofday(struct timeval __user *tv, struct timezone __user *tz);\\n165 long sys_mount(char __user *dev_name, char __user *dir_name, char __user *type, unsigned long flags, void __user *data);\\n166 long sys_umount(char __user *name, int flags);\\n167 long sys_swapon(const char __user *specialfile, int swap_flags);\\n168 long sys_swapoff(const char __user *specialfile);\\n169 long sys_reboot(int magic1, int magic2, unsigned int cmd, void __user *arg);\\n170 long sys_sethostname(char __user *name, int len);\\n171 long sys_setdomainname(char __user *name, int len);\\n172 long sys_iopl(unsigned int);\\n173 long sys_ioperm(unsigned long, unsigned long, int);\\n175 long sys_init_module(void __user *umod, unsigned long len, const char __user *uargs);\\n176 long sys_delete_module(const char __user *name_user, unsigned int flags);\\n179 long sys_quotactl(unsigned int cmd, const char __user *special, qid_t id, void __user *addr);\\n186 long sys_gettid(void);\\n187 long sys_readahead(int fd, loff_t offset, size_t count);\\n188 long sys_setxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\\n189 long sys_lsetxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\\n190 long sys_fsetxattr(int fd, const char __user *name, const void __user *value, size_t size, int flags);\\n191 long sys_getxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\\n192 long sys_lgetxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\\n193 long sys_fgetxattr(int fd, const char __user *name, void __user *value, size_t size);\\n194 long sys_listxattr(const char __user *path, char __user *list, size_t size);\\n195 long sys_llistxattr(const char __user *path, char __user *list, size_t size);\\n196 long sys_flistxattr(int fd, char __user *list, size_t size);\\n197 long sys_removexattr(const char __user *path, const char __user *name);\\n198 long sys_lremovexattr(const char __user *path, const char __user *name);\\n199 long sys_fremovexattr(int fd, const char __user *name);\\n200 long sys_tkill(pid_t pid, int sig);\\n201 long sys_time(time_t __user *tloc);\\n202 long sys_futex(u32 __user *uaddr, int op, u32 val, struct timespec __user *utime, u32 __user *uaddr2, u32 val3);\\n203 long sys_sched_setaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\\n204 long sys_sched_getaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\\n206 long sys_io_setup(unsigned nr_reqs, aio_context_t __user *ctx);\\n207 long sys_io_destroy(aio_context_t ctx);\\n208 long sys_io_getevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct timespec __user *timeout);\\n209 long sys_io_submit(aio_context_t, long, struct iocb __user * __user *);\\n210 long sys_io_cancel(aio_context_t ctx_id, struct iocb __user *iocb, struct io_event __user *result);\\n212 long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);\\n213 long sys_epoll_create(int size);\\n216 long sys_remap_file_pages(unsigned long start, unsigned long size, unsigned long prot, unsigned long pgoff, unsigned long flags);\\n217 long sys_getdents64(unsigned int fd, struct linux_dirent64 __user *dirent, unsigned int count);\\n218 long sys_set_tid_address(int __user *tidptr);\\n219 long sys_restart_syscall(void);\\n220 long sys_semtimedop(int semid, struct sembuf __user *sops, unsigned nsops, const struct timespec __user *timeout);\\n221 long sys_fadvise64(int fd, loff_t offset, size_t len, int advice);\\n222 long sys_timer_create(clockid_t which_clock, struct sigevent __user *timer_event_spec, timer_t __user *created_timer_id);\\n223 long sys_timer_settime(timer_t timer_id, int flags, const struct itimerspec __user *new_setting, struct itimerspec __user *old_setting);\\n224 long sys_timer_gettime(timer_t timer_id, struct itimerspec __user *setting);\\n225 long sys_timer_getoverrun(timer_t timer_id);\\n226 long sys_timer_delete(timer_t timer_id);\\n227 long sys_clock_settime(clockid_t which_clock, const struct timespec __user *tp);\\n228 long sys_clock_gettime(clockid_t which_clock, struct timespec __user *tp);\\n229 long sys_clock_getres(clockid_t which_clock, struct timespec __user *tp);\\n230 long sys_clock_nanosleep(clockid_t which_clock, int flags, const struct timespec __user *rqtp, struct timespec __user *rmtp);\\n231 long sys_exit_group(int error_code);\\n232 long sys_epoll_wait(int epfd, struct epoll_event __user *events, int maxevents, int timeout);\\n233 long sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user *event);\\n234 long sys_tgkill(pid_t tgid, pid_t pid, int sig);\\n235 long sys_utimes(char __user *filename, struct timeval __user *utimes);\\n237 long sys_mbind(unsigned long start, unsigned long len, unsigned long mode, const unsigned long __user *nmask, unsigned long maxnode, unsigned flags);\\n238 long sys_set_mempolicy(int mode, const unsigned long __user *nmask, unsigned long maxnode);\\n239 long sys_get_mempolicy(int __user *policy, unsigned long __user *nmask, unsigned long maxnode, unsigned long addr, unsigned long flags);\\n240 long sys_mq_open(const char __user *name, int oflag, umode_t mode, struct mq_attr __user *attr);\\n241 long sys_mq_unlink(const char __user *name);\\n242 long sys_mq_timedsend(mqd_t mqdes, const char __user *msg_ptr, size_t msg_len, unsigned int msg_prio, const struct timespec __user *abs_timeout);\\n243 long sys_mq_timedreceive(mqd_t mqdes, char __user *msg_ptr, size_t msg_len, unsigned int __user *msg_prio, const struct timespec __user *abs_timeout);\\n244 long sys_mq_notify(mqd_t mqdes, const struct sigevent __user *notification);\\n245 long sys_mq_getsetattr(mqd_t mqdes, const struct mq_attr __user *mqstat, struct mq_attr __user *omqstat);\\n246 long sys_kexec_load(unsigned long entry, unsigned long nr_segments, struct kexec_segment __user *segments, unsigned long flags);\\n247 long sys_waitid(int which, pid_t pid, struct siginfo __user *infop, int options, struct rusage __user *ru);\\n248 long sys_add_key(const char __user *_type, const char __user *_description, const void __user *_payload, size_t plen, key_serial_t destringid);\\n249 long sys_request_key(const char __user *_type, const char __user *_description, const char __user *_callout_info, key_serial_t destringid);\\n250 long sys_keyctl(int cmd, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\\n251 long sys_ioprio_set(int which, int who, int ioprio);\\n252 long sys_ioprio_get(int which, int who);\\n253 long sys_inotify_init(void);\\n254 long sys_inotify_add_watch(int fd, const char __user *path, u32 mask);\\n255 long sys_inotify_rm_watch(int fd, __s32 wd);\\n256 long sys_migrate_pages(pid_t pid, unsigned long maxnode, const unsigned long __user *from, const unsigned long __user *to);\\n257 long sys_openat(int dfd, const char __user *filename, int flags, umode_t mode);\\n258 long sys_mkdirat(int dfd, const char __user *pathname, umode_t mode);\\n259 long sys_mknodat(int dfd, const char __user *filename, umode_t mode, unsigned dev);\\n260 long sys_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group, int flag);\\n261 long sys_futimesat(int dfd, const char __user *filename, struct timeval __user *utimes);\\n262 long sys_newfstatat(int dfd, const char __user *filename, struct stat __user *statbuf, int flag);\\n263 long sys_unlinkat(int dfd, const char __user *pathname, int flag);\\n264 long sys_renameat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname);\\n265 long sys_linkat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, int flags);\\n266 long sys_symlinkat(const char __user *oldname, int newdfd, const char __user *newname);\\n267 long sys_readlinkat(int dfd, const char __user *path, char __user *buf, int bufsiz);\\n268 long sys_fchmodat(int dfd, const char __user *filename, umode_t mode);\\n269 long sys_faccessat(int dfd, const char __user *filename, int mode);\\n270 long sys_pselect6(int, fd_set __user *, fd_set __user *, fd_set __user *, struct timespec __user *, void __user *);\\n271 long sys_ppoll(struct pollfd __user *, unsigned int, struct timespec __user *, const sigset_t __user *, size_t);\\n272 long sys_unshare(unsigned long unshare_flags);\\n273 long sys_set_robust_list(struct robust_list_head __user *head, size_t len);\\n274 long sys_get_robust_list(int pid, struct robust_list_head __user * __user *head_ptr, size_t __user *len_ptr);\\n275 long sys_splice(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);\\n276 long sys_tee(int fdin, int fdout, size_t len, unsigned int flags);\\n277 long sys_sync_file_range(int fd, loff_t offset, loff_t nbytes, unsigned int flags);\\n278 long sys_vmsplice(int fd, const struct iovec __user *iov, unsigned long nr_segs, unsigned int flags);\\n279 long sys_move_pages(pid_t pid, unsigned long nr_pages, const void __user * __user *pages, const int __user *nodes, int __user *status, int flags);\\n280 long sys_utimensat(int dfd, const char __user *filename, struct timespec __user *utimes, int flags);\\n281 long sys_epoll_pwait(int epfd, struct epoll_event __user *events, int maxevents, int timeout, const sigset_t __user *sigmask, size_t sigsetsize);\\n282 long sys_signalfd(int ufd, sigset_t __user *user_mask, size_t sizemask);\\n283 long sys_timerfd_create(int clockid, int flags);\\n284 long sys_eventfd(unsigned int count);\\n285 long sys_fallocate(int fd, int mode, loff_t offset, loff_t len);\\n286 long sys_timerfd_settime(int ufd, int flags, const struct itimerspec __user *utmr, struct itimerspec __user *otmr);\\n287 long sys_timerfd_gettime(int ufd, struct itimerspec __user *otmr);\\n288 long sys_accept4(int, struct sockaddr __user *, int __user *, int);\n```\n\n----------------------------------------\n\nTITLE: Declaring Linux Kernel System Call Prototypes - C\nDESCRIPTION: This snippet consists of a comprehensive list of Linux kernel system call function prototypes, each specifying the handler function's signature for a particular syscall number. These prototypes establish the ABI between user space and the kernel, detailing pointer qualifications (such as __user), types, and any required structures (e.g., siginfo_t, timeval, aio_context_t). Inputs include a variety of primitive values, pointers to user memory, and custom structs, while outputs are typically long integers indicating success or failure codes. No user code is present, and dependencies include kernel-defined types and structuresâ€”this file is to be included within kernel source, not compiled directly.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_x86_prototypes.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n177 long sys_rt_sigtimedwait(const sigset_t __user *uthese, siginfo_t __user *uinfo, const struct timespec __user *uts, size_t sigsetsize);\n178 long sys_rt_sigqueueinfo(pid_t pid, int sig, siginfo_t __user *uinfo);\n179 long sys_rt_sigsuspend(sigset_t __user *unewset, size_t sigsetsize);\n180 long sys_pread64(unsigned int fd, char __user *buf, size_t count, loff_t pos);\n181 long sys_pwrite64(unsigned int fd, const char __user *buf, size_t count, loff_t pos);\n182 long sys_chown16(const char __user *filename, old_uid_t user, old_gid_t group);\n183 long sys_getcwd(char __user *buf, unsigned long size);\n184 long sys_capget(cap_user_header_t header, cap_user_data_t dataptr);\n185 long sys_capset(cap_user_header_t header, const cap_user_data_t data);\n186 long sys_sigaltstack(const struct sigaltstack __user *uss, struct sigaltstack __user *uoss);\n187 long sys_sendfile(int out_fd, int in_fd, off_t __user *offset, size_t count);\n190 long sys_vfork(void);\n191 long sys_getrlimit(unsigned int resource, struct rlimit __user *rlim);\n192 long sys_mmap_pgoff(unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags, unsigned long fd, unsigned long pgoff);\n193 long sys_truncate64(const char __user *path, loff_t length);\n194 long sys_ftruncate64(unsigned int fd, loff_t length);\n195 long sys_stat64(const char __user *filename, struct stat64 __user *statbuf);\n196 long sys_lstat64(const char __user *filename, struct stat64 __user *statbuf);\n197 long sys_fstat64(unsigned long fd, struct stat64 __user *statbuf);\n198 long sys_lchown(const char __user *filename, uid_t user, gid_t group);\n199 long sys_getuid(void);\n200 long sys_getgid(void);\n201 long sys_geteuid(void);\n202 long sys_getegid(void);\n203 long sys_setreuid(uid_t ruid, uid_t euid);\n204 long sys_setregid(gid_t rgid, gid_t egid);\n205 long sys_getgroups(int gidsetsize, gid_t __user *grouplist);\n206 long sys_setgroups(int gidsetsize, gid_t __user *grouplist);\n207 long sys_fchown(unsigned int fd, uid_t user, gid_t group);\n208 long sys_setresuid(uid_t ruid, uid_t euid, uid_t suid);\n209 long sys_getresuid(uid_t __user *ruid, uid_t __user *euid, uid_t __user *suid);\n210 long sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid);\n211 long sys_getresgid(gid_t __user *rgid, gid_t __user *egid, gid_t __user *sgid);\n212 long sys_chown(const char __user *filename, uid_t user, gid_t group);\n213 long sys_setuid(uid_t uid);\n214 long sys_setgid(gid_t gid);\n215 long sys_setfsuid(uid_t uid);\n216 long sys_setfsgid(gid_t gid);\n217 long sys_pivot_root(const char __user *new_root, const char __user *put_old);\n218 long sys_mincore(unsigned long start, size_t len, unsigned char __user *vec);\n219 long sys_madvise(unsigned long start, size_t len, int behavior);\n220 long sys_getdents64(unsigned int fd, struct linux_dirent64 __user *dirent, unsigned int count);\n221 long sys_fcntl64(unsigned int fd, unsigned int cmd, unsigned long arg);\n224 long sys_gettid(void);\n225 long sys_readahead(int fd, loff_t offset, size_t count);\n226 long sys_setxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\n227 long sys_lsetxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\n228 long sys_fsetxattr(int fd, const char __user *name, const void __user *value, size_t size, int flags);\n229 long sys_getxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\n230 long sys_lgetxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\n231 long sys_fgetxattr(int fd, const char __user *name, void __user *value, size_t size);\n232 long sys_listxattr(const char __user *path, char __user *list, size_t size);\n233 long sys_llistxattr(const char __user *path, char __user *list, size_t size);\n234 long sys_flistxattr(int fd, char __user *list, size_t size);\n235 long sys_removexattr(const char __user *path, const char __user *name);\n236 long sys_lremovexattr(const char __user *path, const char __user *name);\n237 long sys_fremovexattr(int fd, const char __user *name);\n238 long sys_tkill(pid_t pid, int sig);\n239 long sys_sendfile64(int out_fd, int in_fd, loff_t __user *offset, size_t count);\n240 long sys_futex(u32 __user *uaddr, int op, u32 val, struct timespec __user *utime, u32 __user *uaddr2, u32 val3);\n241 long sys_sched_setaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\n242 long sys_sched_getaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\n243 long sys_set_thread_area(struct user_desc __user *);\n244 long sys_get_thread_area(struct user_desc __user *);\n245 long sys_io_setup(unsigned nr_reqs, aio_context_t __user *ctx);\n246 long sys_io_destroy(aio_context_t ctx);\n247 long sys_io_getevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct timespec __user *timeout);\n248 long sys_io_submit(aio_context_t, long, struct iocb __user * __user *);\n249 long sys_io_cancel(aio_context_t ctx_id, struct iocb __user *iocb, struct io_event __user *result);\n250 long sys_fadvise64(int fd, loff_t offset, size_t len, int advice);\n252 long sys_exit_group(int error_code);\n253 long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);\n254 long sys_epoll_create(int size);\n255 long sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user *event);\n256 long sys_epoll_wait(int epfd, struct epoll_event __user *events, int maxevents, int timeout);\n257 long sys_remap_file_pages(unsigned long start, unsigned long size, unsigned long prot, unsigned long pgoff, unsigned long flags);\n258 long sys_set_tid_address(int __user *tidptr);\n259 long sys_timer_create(clockid_t which_clock, struct sigevent __user *timer_event_spec, timer_t __user *created_timer_id);\n260 long sys_timer_settime(timer_t timer_id, int flags, const struct itimerspec __user *new_setting, struct itimerspec __user *old_setting);\n261 long sys_timer_gettime(timer_t timer_id, struct itimerspec __user *setting);\n262 long sys_timer_getoverrun(timer_t timer_id);\n263 long sys_timer_delete(timer_t timer_id);\n264 long sys_clock_settime(clockid_t which_clock, const struct timespec __user *tp);\n265 long sys_clock_gettime(clockid_t which_clock, struct timespec __user *tp);\n266 long sys_clock_getres(clockid_t which_clock, struct timespec __user *tp);\n267 long sys_clock_nanosleep(clockid_t which_clock, int flags, const struct timespec __user *rqtp, struct timespec __user *rmtp);\n268 long sys_statfs64(const char __user *path, size_t sz, struct statfs64 __user *buf);\n269 long sys_fstatfs64(unsigned int fd, size_t sz, struct statfs64 __user *buf);\n270 long sys_tgkill(pid_t tgid, pid_t pid, int sig);\n271 long sys_utimes(char __user *filename, struct timeval __user *utimes);\n272 long sys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice);\n274 long sys_mbind(unsigned long start, unsigned long len, unsigned long mode, const unsigned long __user *nmask, unsigned long maxnode, unsigned flags);\n275 long sys_get_mempolicy(int __user *policy, unsigned long __user *nmask, unsigned long maxnode, unsigned long addr, unsigned long flags);\n276 long sys_set_mempolicy(int mode, const unsigned long __user *nmask, unsigned long maxnode);\n277 long sys_mq_open(const char __user *name, int oflag, umode_t mode, struct mq_attr __user *attr);\n278 long sys_mq_unlink(const char __user *name);\n279 long sys_mq_timedsend(mqd_t mqdes, const char __user *msg_ptr, size_t msg_len, unsigned int msg_prio, const struct timespec __user *abs_timeout);\n280 long sys_mq_timedreceive(mqd_t mqdes, char __user *msg_ptr, size_t msg_len, unsigned int __user *msg_prio, const struct timespec __user *abs_timeout);\n281 long sys_mq_notify(mqd_t mqdes, const struct sigevent __user *notification);\n282 long sys_mq_getsetattr(mqd_t mqdes, const struct mq_attr __user *mqstat, struct mq_attr __user *omqstat);\n283 long sys_kexec_load(unsigned long entry, unsigned long nr_segments, struct kexec_segment __user *segments, unsigned long flags);\n284 long sys_waitid(int which, pid_t pid, struct siginfo __user *infop, int options, struct rusage __user *ru);\n286 long sys_add_key(const char __user *_type, const char __user *_description, const void __user *_payload, size_t plen, key_serial_t destringid);\n287 long sys_request_key(const char __user *_type, const char __user *_description, const char __user *_callout_info, key_serial_t destringid);\n288 long sys_keyctl(int cmd, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\n289 long sys_ioprio_set(int which, int who, int ioprio);\n290 long sys_ioprio_get(int which, int who);\n291 long sys_inotify_init(void);\n292 long sys_inotify_add_watch(int fd, const char __user *path, u32 mask);\n293 long sys_inotify_rm_watch(int fd, __s32 wd);\n294 long sys_migrate_pages(pid_t pid, unsigned long maxnode, const unsigned long __user *from, const unsigned long __user *to);\n295 long sys_openat(int dfd, const char __user *filename, int flags, umode_t mode);\n296 long sys_mkdirat(int dfd, const char __user *pathname, umode_t mode);\n297 long sys_mknodat(int dfd, const char __user *filename, umode_t mode, unsigned dev);\n298 long sys_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group, int flag);\n299 long sys_futimesat(int dfd, const char __user *filename, struct timeval __user *utimes);\n300 long sys_fstatat64(int dfd, const char __user *filename, struct stat64 __user *statbuf, int flag);\n301 long sys_unlinkat(int dfd, const char __user *pathname, int flag);\n302 long sys_renameat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname);\n303 long sys_linkat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, int flags);\n304 long sys_symlinkat(const char __user *oldname, int newdfd, const char __user *newname);\n305 long sys_readlinkat(int dfd, const char __user *path, char __user *buf, int bufsiz);\n306 long sys_fchmodat(int dfd, const char __user *filename, umode_t mode);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows Native API NT System Call Prototypes - C\nDESCRIPTION: This snippet declares the function prototypes for numerous NT (Windows Native API) system calls in C. These declarations are required for user applications or libraries that access the undocumented NT subsystem, facilitating direct usage of Windows kernel functions. All functions return NTSTATUS, and parameters are defined using native NT data types such as HANDLE, POBJECT_ATTRIBUTES, and PUNICODE_STRING. No code implementation is provided; only the signatures and parameter types are specified, suitable for creating custom system-level tools or extending API access.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2003sp0_x86_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAcceptConnectPort (PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView);\nNTSTATUS NtAccessCheck (PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheckByType (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByTypeAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheckByTypeResultList (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarmByHandle (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAddAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\nNTSTATUS NtAddBootEntry (PBOOT_ENTRY BootEntry, PULONG Id);\nNTSTATUS NtAddDriverEntry (PEFI_DRIVER_ENTRY DriverEntry, PULONG Id);\nNTSTATUS NtAdjustGroupsToken (HANDLE TokenHandle, BOOLEAN ResetToDefault, PTOKEN_GROUPS NewState, ULONG BufferLength, PTOKEN_GROUPS PreviousState, PULONG ReturnLength);\nNTSTATUS NtAdjustPrivilegesToken (HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);\nNTSTATUS NtAlertResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtAlertThread (HANDLE ThreadHandle);\nNTSTATUS NtAllocateLocallyUniqueId (PLUID Luid);\nNTSTATUS NtAllocateUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtAllocateUuids (PULARGE_INTEGER Time, PULONG Range, PULONG Sequence, PCHAR Seed);\nNTSTATUS NtAllocateVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);\nNTSTATUS NtApphelpCacheControl (APPHELPCOMMAND type, PVOID buf);\nNTSTATUS NtAreMappedFilesTheSame (PVOID File1MappedAsAnImage, PVOID File2MappedAsFile);\nNTSTATUS NtAssignProcessToJobObject (HANDLE JobHandle, HANDLE ProcessHandle);\nNTSTATUS NtCallbackReturn (PVOID OutputBuffer, ULONG OutputLength, NTSTATUS Status);\nNTSTATUS NtCancelIoFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtCancelTimer (HANDLE TimerHandle, PBOOLEAN CurrentState);\nNTSTATUS NtClearEvent (HANDLE EventHandle);\nNTSTATUS NtClose (HANDLE Handle);\nNTSTATUS NtCloseObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtCompactKeys (ULONG Count, HANDLE KeyArray[]);\nNTSTATUS NtCompareTokens (HANDLE FirstTokenHandle, HANDLE SecondTokenHandle, PBOOLEAN Equal);\nNTSTATUS NtCompleteConnectPort (HANDLE PortHandle);\nNTSTATUS NtCompressKey (HANDLE Key);\nNTSTATUS NtConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\nNTSTATUS NtContinue (PCONTEXT ContextRecord, BOOLEAN TestAlert);\nNTSTATUS NtCreateDebugObject (PHANDLE DebugObjectHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\nNTSTATUS NtCreateDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);\nNTSTATUS NtCreateEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);\nNTSTATUS NtCreateIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Count);\nNTSTATUS NtCreateJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateJobSet (ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);\nNTSTATUS NtCreateKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);\nNTSTATUS NtCreateMailslotFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout);\nNTSTATUS NtCreateMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN InitialOwner);\nNTSTATUS NtCreateNamedPipeFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout);\nNTSTATUS NtCreatePagingFile (PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority);\nNTSTATUS NtCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtCreateProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort);\nNTSTATUS NtCreateProcessEx (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel);\nNTSTATUS NtCreateProfile (PHANDLE ProfileHandle, HANDLE Process, PVOID RangeBase, SIZE_T RangeSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);\nNTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);\nNTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);\nNTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);\nNTSTATUS NtCreateThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended);\nNTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);\nNTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);\nNTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtDebugActiveProcess (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\n```\n\n----------------------------------------\n\nTITLE: Windows NT System API Function Declarations\nDESCRIPTION: Function declarations for Windows NT native API (NTAPI) system calls. These functions provide low-level access to Windows operating system features including process management, thread control, file operations, and ALPC communication.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);\nNTSTATUS NtQueryVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);\n/* Additional function declarations omitted for brevity */\nNTSTATUS NtAlpcQueryInformationMessage (HANDLE PortHandle, PPORT_MESSAGE PortMessage, ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass, PVOID MessageInformation, ULONG Length, PULONG ReturnLength);\n```\n\n----------------------------------------\n\nTITLE: Installing PyPANDA Dependencies\nDESCRIPTION: Command to install required system packages for PyPANDA installation including genisoimage, wget, and libffi-dev.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\napt-get install -y genisoimage wget libffi-dev\n```\n\n----------------------------------------\n\nTITLE: Defining Windows NT Native API Function Declarations for System Operations in C\nDESCRIPTION: This code snippet contains a comprehensive set of Windows NT Native API (NTAPI) function declarations representing low-level system calls. These functions handle various system operations including process and thread management, file operations, memory management, security operations, and inter-process communication via ALPC.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp12_x64_prototypes.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);\nNTSTATUS NtQueryVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);\nNTSTATUS NtFlushBuffersFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtApphelpCacheControl (APPHELPCOMMAND type, PVOID buf);\nNTSTATUS NtCreateProcessEx (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel);\nNTSTATUS NtCreateThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended);\nNTSTATUS NtIsProcessInJob (HANDLE ProcessHandle, HANDLE JobHandle);\nNTSTATUS NtProtectVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, WIN32_PROTECTION_MASK NewProtectWin32, PULONG OldProtect);\nNTSTATUS NtQuerySection (HANDLE SectionHandle, SECTION_INFORMATION_CLASS SectionInformationClass, PVOID SectionInformation, SIZE_T SectionInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtTerminateThread (HANDLE ThreadHandle, NTSTATUS ExitStatus);\nNTSTATUS NtReadRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtCreateFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);\nNTSTATUS NtQueryEvent (HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ReturnLength);\nNTSTATUS NtWriteRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\nNTSTATUS NtOpenDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtAccessCheckByTypeAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtQuerySystemTime (PLARGE_INTEGER SystemTime);\nNTSTATUS NtWaitForMultipleObjects (ULONG Count, HANDLE Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtSetInformationObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength);\nNTSTATUS NtCancelIoFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtTraceEvent (HANDLE TraceHandle, ULONG Flags, ULONG FieldSize, PVOID Fields);\nNTSTATUS NtPowerInformation (POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtSetValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);\nNTSTATUS NtCancelTimer (HANDLE TimerHandle, PBOOLEAN CurrentState);\nNTSTATUS NtSetTimer (HANDLE TimerHandle, PLARGE_INTEGER DueTime, PTIMER_APC_ROUTINE TimerApcRoutine, PVOID TimerContext, BOOLEAN WakeTimer, LONG Period, PBOOLEAN PreviousState);\nNTSTATUS NtAcceptConnectPort (PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView);\nNTSTATUS NtAccessCheck (PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByType (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByTypeResultList (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarmByHandle (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n\nNTSTATUS NtAddBootEntry (PBOOT_ENTRY BootEntry, PULONG Id);\nNTSTATUS NtAddDriverEntry (PEFI_DRIVER_ENTRY DriverEntry, PULONG Id);\nNTSTATUS NtAdjustGroupsToken (HANDLE TokenHandle, BOOLEAN ResetToDefault, PTOKEN_GROUPS NewState, ULONG BufferLength, PTOKEN_GROUPS PreviousState, PULONG ReturnLength);\nNTSTATUS NtAlertResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtAlertThread (HANDLE ThreadHandle);\nNTSTATUS NtAllocateLocallyUniqueId (PLUID Luid);\nNTSTATUS NtAllocateUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtAllocateUuids (PULARGE_INTEGER Time, PULONG Range, PULONG Sequence, PCHAR Seed);\nNTSTATUS NtAlpcAcceptConnectPort (PHANDLE PortHandle, HANDLE ConnectionPortHandle, ULONG Flags, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes, BOOLEAN AcceptConnection);\nNTSTATUS NtAlpcCancelMessage (HANDLE PortHandle, ULONG Flags, PALPC_CONTEXT_ATTR MessageContext);\nNTSTATUS NtAlpcConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, ULONG Flags, PSID RequiredServerSid, PPORT_MESSAGE ConnectionMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes, PALPC_MESSAGE_ATTRIBUTES InMessageAttributes, PLARGE_INTEGER Timeout);\nNTSTATUS NtAlpcCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes);\nNTSTATUS NtAlpcCreatePortSection (HANDLE PortHandle, ULONG Flags, HANDLE SectionHandle, SIZE_T SectionSize, PALPC_HANDLE AlpcSectionHandle, PSIZE_T ActualSectionSize);\nNTSTATUS NtAlpcCreateResourceReserve (HANDLE PortHandle, ULONG Flags, SIZE_T MessageSize, PALPC_HANDLE ResourceId);\nNTSTATUS NtAlpcCreateSectionView (HANDLE PortHandle, ULONG Flags, PALPC_DATA_VIEW_ATTR ViewAttributes);\nNTSTATUS NtAlpcCreateSecurityContext (HANDLE PortHandle, ULONG Flags, PALPC_SECURITY_ATTR SecurityAttribute);\nNTSTATUS NtAlpcDeletePortSection (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE SectionHandle);\nNTSTATUS NtAlpcDeleteResourceReserve (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ResourceId);\nNTSTATUS NtAlpcDeleteSectionView (HANDLE PortHandle, ULONG Flags, PVOID ViewBase);\nNTSTATUS NtAlpcDeleteSecurityContext (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);\nNTSTATUS NtAlpcDisconnectPort (HANDLE PortHandle, ULONG Flags);\nNTSTATUS NtAlpcImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE PortMessage, PVOID Reserved);\nNTSTATUS NtAlpcOpenSenderProcess (PHANDLE ProcessHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtAlpcOpenSenderThread (PHANDLE ThreadHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtAlpcQueryInformation (HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtAlpcQueryInformationMessage (HANDLE PortHandle, PPORT_MESSAGE PortMessage, ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass, PVOID MessageInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtAlpcRevokeSecurityContext (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);\n```\n\n----------------------------------------\n\nTITLE: Defining the on_call Callback Type with PANDA Plugin API in C\nDESCRIPTION: This snippet defines the type signature for the 'on_call' callback in the PANDA callstack_instr plugin. It specifies that callbacks receive the emulation CPU state and the guest function address when a call is traced. Requires inclusion of appropriate CPUState and target_ulong definitions, and is intended for use by plugin developers to register call tracing hooks. The callback is invoked on every guest function call, and implementers should take care to minimize side effects.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/callstack_instr/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (* on_call_t)(CPUState *env, target_ulong func)\n```\n\n----------------------------------------\n\nTITLE: PANDA Callback Event Types in C\nDESCRIPTION: A comprehensive enumeration of all callback event types recognized by PANDA for plugin development. Each entry corresponds to a specific lifecycle or hardware event during emulation, such as instruction translation/execution, memory operations, device I/O, or replay operations. Understanding and using these constants (e.g., PANDA_CB_BEFORE_BLOCK_TRANSLATE) is necessary for fine-grained plugin instrumentation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_13\n\nLANGUAGE: C\nCODE:\n```\nPANDA_CB_BEFORE_BLOCK_TRANSLATE,// Before translating each basic block\nPANDA_CB_BEFORE_TCG_CODEGEN,    // Before host codegen of each basic block.\nPANDA_CB_AFTER_BLOCK_TRANSLATE, // After translating each basic block\nPANDA_CB_BEFORE_BLOCK_EXEC_INVALIDATE_OPT,    // Before executing each basic block (with option to invalidate, may trigger retranslation)\nPANDA_CB_BEFORE_BLOCK_EXEC,     // Before executing each basic block\nPANDA_CB_AFTER_BLOCK_EXEC,      // After executing each basic block\nPANDA_CB_INSN_TRANSLATE,        // Before an instruction is translated\nPANDA_CB_INSN_EXEC,             // Before an instruction is executed\nPANDA_CB_AFTER_INSN_TRANSLATE,  // After an insn is translated\nPANDA_CB_AFTER_INSN_EXEC,       // After an insn is executed\nPANDA_CB_VIRT_MEM_BEFORE_READ,  // Before read of virtual memory\nPANDA_CB_VIRT_MEM_BEFORE_WRITE, // Before write to virtual memory\nPANDA_CB_PHYS_MEM_BEFORE_READ,  // Before read of physical memory\nPANDA_CB_PHYS_MEM_BEFORE_WRITE, // Before write to physical memory\nPANDA_CB_VIRT_MEM_AFTER_READ,   // After read of virtual memory\nPANDA_CB_VIRT_MEM_AFTER_WRITE,  // After write to virtual memory\nPANDA_CB_PHYS_MEM_AFTER_READ,   // After read of physical memory\nPANDA_CB_PHYS_MEM_AFTER_WRITE,  // After write to physical memory\nPANDA_CB_MMIO_AFTER_READ,       // After each MMIO read\nPANDA_CB_MMIO_BEFORE_WRITE,     // Before each MMIO write\nPANDA_CB_HD_READ,               // Each HDD read\nPANDA_CB_HD_WRITE,              // Each HDD write\nPANDA_CB_GUEST_HYPERCALL,       // Hypercall from the guest (e.g. CPUID)\nPANDA_CB_MONITOR,               // Monitor callback\nPANDA_CB_CPU_RESTORE_STATE,     // In cpu_restore_state() (fault/exception)\nPANDA_CB_BEFORE_LOADVM,         // At start of replay, before loadvm\nPANDA_CB_ASID_CHANGED,          // After an ASID (address space identifier - aka PGD) write\nPANDA_CB_REPLAY_HD_TRANSFER,    // In replay, hd transfer\nPANDA_CB_REPLAY_NET_TRANSFER,   // In replay, transfers within network card (currently only E1000)\nPANDA_CB_REPLAY_SERIAL_RECEIVE, // In replay, right after data is pushed into the serial RX FIFO\nPANDA_CB_REPLAY_SERIAL_READ,    // In replay, right after a value is read from the serial RX FIFO.\nPANDA_CB_REPLAY_SERIAL_SEND,    // In replay, right after data is popped from the serial TX FIFO\nPANDA_CB_REPLAY_SERIAL_WRITE,   // In replay, right after data is pushed into the serial TX FIFO.\nPANDA_CB_REPLAY_BEFORE_DMA,     // In replay, just before RAM case of cpu_physical_mem_rw\nPANDA_CB_REPLAY_AFTER_DMA,      // In replay, just after RAM case of cpu_physical_mem_rw\nPANDA_CB_REPLAY_HANDLE_PACKET,  // In replay, packet in / out\nPANDA_CB_AFTER_CPU_EXEC_ENTER,  // Just after cpu_exec_enter is called\nPANDA_CB_BEFORE_CPU_EXEC_EXIT,  // Just before cpu_exec_exit is called\nPANDA_CB_AFTER_MACHINE_INIT,    // Right after the machine is initialized, before any code runs\nPANDA_CB_AFTER_VMLOAD,          // Right after machine state is restored from a snapshot, before any code runs\nPANDA_CB_START_BLOCK_EXEC,      // TCG stream start of block\nPANDA_CB_END_BLOCK_EXEC,        // TCG stream end of block\nPANDA_CB_TOP_LOOP,              // At top of loop that manages emulation.  good place to take a snapshot\n```\n\n----------------------------------------\n\nTITLE: Registering Callbacks in PANDA Plugins using C\nDESCRIPTION: Documents the use of panda_register_callback to assign custom callback functions to various PANDA framework event types. The function takes a plugin handle, the type of callback, and the callback union. Depending on the type, the callback will be executed during specific QEMU or PANDA lifecycle events. Requires knowledge of PANDA's callback system and event types.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_12\n\nLANGUAGE: C\nCODE:\n```\nvoid panda_register_callback(void *plugin, panda_cb_type type, panda_cb cb);\n```\n\n----------------------------------------\n\nTITLE: Declaring Native Windows NT System Call Prototypes - C\nDESCRIPTION: This code snippet defines a series of function prototypes for the native Windows NT system call interface in C. Each function represents a specific NT system call, allowing direct invocation of low-level kernel services such as file handling, security settings, environment variables, power management, profiling, process and thread control, debugging, registry operations, and more. The prototypes require knowledge of Windows data types and constants (e.g., HANDLE, NTSTATUS, PVOID, SECURITY_INFORMATION, etc.), and are intended to be used by low-level system applications, drivers, or emulation frameworks interfacing closely with the NT kernel. Each function exposes parameters specific to the call's context and purpose, and most return an NTSTATUS code indicating success or failure. Limitations include platform dependency (Windows NT family), requirement of proper privilege levels, and the necessity for correctly structured input parameters for safe and correct operation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_26\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetSecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetSystemEnvironmentValue (PUNICODE_STRING VariableName, PUNICODE_STRING VariableValue);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetSystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, ULONG ValueLength, ULONG Attributes);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetSystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetSystemPowerState (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetSystemTime (PLARGE_INTEGER SystemTime, PLARGE_INTEGER PreviousTime);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetThreadExecutionState (EXECUTION_STATE esFlags, PEXECUTION_STATE PreviousFlags);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetTimerEx (HANDLE TimerHandle, TIMER_SET_INFORMATION_CLASS TimerSetInformationClass, PVOID TimerSetInformation, ULONG TimerSetInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetTimerResolution (ULONG DesiredTime, BOOLEAN SetResolution, PULONG ActualTime);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetUuidSeed (PCHAR Seed);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtShutdownSystem (SHUTDOWN_ACTION Action);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtShutdownWorkerFactory (HANDLE WorkerFactoryHandle, LONG *PendingWorkerCount);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSignalAndWaitForSingleObject (HANDLE SignalHandle, HANDLE WaitHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSinglePhaseReject (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtStartProfile (HANDLE ProfileHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtStopProfile (HANDLE ProfileHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSuspendProcess (HANDLE ProcessHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSuspendThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSystemDebugControl (SYSDBG_COMMAND Command, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtTerminateJobObject (HANDLE JobHandle, NTSTATUS ExitStatus);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtTestAlert ();\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtThawRegistry ();\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtThawTransactions ();\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtTraceControl (ULONG FunctionCode, PVOID InBuffer, ULONG InBufferLen, PVOID OutBuffer, ULONG OutBufferLen, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtTranslateFilePath (PFILE_PATH InputFilePath, ULONG OutputType, PFILE_PATH OutputFilePath, PULONG OutputFilePathLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtUmsThreadYield (PVOID SchedulerParam);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtUnloadDriver (PUNICODE_STRING DriverServiceName);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtUnloadKey (POBJECT_ATTRIBUTES TargetKey);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtUnloadKey2 (POBJECT_ATTRIBUTES TargetKey, ULONG Flags);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtUnloadKeyEx (POBJECT_ATTRIBUTES TargetKey, HANDLE Event);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtUnlockFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtUnlockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtVdmControl (VDMSERVICECLASS Service, PVOID ServiceData);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWaitForDebugEvent (HANDLE DebugObjectHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PDBGUI_WAIT_STATE_CHANGE WaitStateChange);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWaitForKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWaitForWorkViaWorkerFactory (HANDLE WorkerFactoryHandle, PFILE_IO_COMPLETION_INFORMATION MiniPacket);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWaitHighEventPair (HANDLE EventPairHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWaitLowEventPair (HANDLE EventPairHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWorkerFactoryWorkerReady (HANDLE WorkerFactoryHandle);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Call Prototypes - C\nDESCRIPTION: Declares a comprehensive set of function prototypes for Windows Native API (Nt*) calls in C. Each declaration specifies the return type, function name, and parameter types, enabling use by user-mode code or by modules that build, wrap, forward, or analyze such system calls. Expected parameters include handles, pointers to system objects, status blocks, and configuration structures as needed for each operation. No implementation is provided: these are prototypes that require corresponding function definitions in a DLL (e.g., ntdll.dll), and are intended for advanced users or reverse engineers needing precise low-level access. All dependencies are standard Windows data types and structures.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_xpsp3_x86_prototypes.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetEventBoostPriority (HANDLE EventHandle);\nNTSTATUS NtSetHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetHighWaitLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetInformationDebugObject (HANDLE DebugObjectHandle, DEBUGOBJECTINFOCLASS DebugObjectInformationClass, PVOID DebugInformation, ULONG DebugInformationLength, PULONG ReturnLength);\nNTSTATUS NtSetInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\nNTSTATUS NtSetInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength);\nNTSTATUS NtSetInformationKey (HANDLE KeyHandle, KEY_SET_INFORMATION_CLASS KeySetInformationClass, PVOID KeySetInformation, ULONG KeySetInformationLength);\nNTSTATUS NtSetInformationObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength);\nNTSTATUS NtSetInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);\nNTSTATUS NtSetInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);\nNTSTATUS NtSetInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength);\nNTSTATUS NtSetIntervalProfile (ULONG Interval, KPROFILE_SOURCE Source);\nNTSTATUS NtSetIoCompletion (HANDLE IoCompletionHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);\nNTSTATUS NtSetLdtEntries (ULONG Selector0, ULONG Entry0Low, ULONG Entry0Hi, ULONG Selector1, ULONG Entry1Low, ULONG Entry1Hi);\nNTSTATUS NtSetLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetLowWaitHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\nNTSTATUS NtSetSecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);\nNTSTATUS NtSetSystemEnvironmentValue (PUNICODE_STRING VariableName, PUNICODE_STRING VariableValue);\nNTSTATUS NtSetSystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, ULONG ValueLength, ULONG Attributes);\nNTSTATUS NtSetSystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);\nNTSTATUS NtSetSystemPowerState (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags);\nNTSTATUS NtSetSystemTime (PLARGE_INTEGER SystemTime, PLARGE_INTEGER PreviousTime);\nNTSTATUS NtSetThreadExecutionState (EXECUTION_STATE esFlags, PEXECUTION_STATE PreviousFlags);\nNTSTATUS NtSetTimer (HANDLE TimerHandle, PLARGE_INTEGER DueTime, PTIMER_APC_ROUTINE TimerApcRoutine, PVOID TimerContext, BOOLEAN WakeTimer, LONG Period, PBOOLEAN PreviousState);\nNTSTATUS NtSetTimerResolution (ULONG DesiredTime, BOOLEAN SetResolution, PULONG ActualTime);\nNTSTATUS NtSetUuidSeed (PCHAR Seed);\nNTSTATUS NtSetValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);\nNTSTATUS NtSetVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtShutdownSystem (SHUTDOWN_ACTION Action);\nNTSTATUS NtSignalAndWaitForSingleObject (HANDLE SignalHandle, HANDLE WaitHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtStartProfile (HANDLE ProfileHandle);\nNTSTATUS NtStopProfile (HANDLE ProfileHandle);\nNTSTATUS NtSuspendProcess (HANDLE ProcessHandle);\nNTSTATUS NtSuspendThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtSystemDebugControl (SYSDBG_COMMAND Command, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, PULONG ReturnLength);\nNTSTATUS NtTerminateJobObject (HANDLE JobHandle, NTSTATUS ExitStatus);\nNTSTATUS NtTerminateProcess (HANDLE ProcessHandle, NTSTATUS ExitStatus);\nNTSTATUS NtTerminateThread (HANDLE ThreadHandle, NTSTATUS ExitStatus);\nNTSTATUS NtTestAlert ();\nNTSTATUS NtTraceEvent (HANDLE TraceHandle, ULONG Flags, ULONG FieldSize, PVOID Fields);\nNTSTATUS NtTranslateFilePath (PFILE_PATH InputFilePath, ULONG OutputType, PFILE_PATH OutputFilePath, PULONG OutputFilePathLength);\nNTSTATUS NtUnloadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtUnloadKey (POBJECT_ATTRIBUTES TargetKey);\nNTSTATUS NtUnloadKeyEx (POBJECT_ATTRIBUTES TargetKey, HANDLE Event);\nNTSTATUS NtUnlockFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key);\nNTSTATUS NtUnlockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtUnmapViewOfSection (HANDLE ProcessHandle, PVOID BaseAddress);\nNTSTATUS NtVdmControl (VDMSERVICECLASS Service, PVOID ServiceData);\nNTSTATUS NtWaitForDebugEvent (HANDLE DebugObjectHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PDBGUI_WAIT_STATE_CHANGE WaitStateChange);\nNTSTATUS NtWaitForMultipleObjects (ULONG Count, HANDLE Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitForSingleObject (HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtWaitLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtWriteFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtWriteFileGather (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtWriteRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\nNTSTATUS NtWriteVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\nNTSTATUS NtYieldExecution ();\nNTSTATUS NtCreateKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\nNTSTATUS NtOpenKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtReleaseKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitForKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtQueryPortInformationProcess ();\n```\n\n----------------------------------------\n\nTITLE: NT API Function Declarations for Windows Kernel Object Creation and Management\nDESCRIPTION: Contains declarations for Windows NT native API functions used for creating, opening, and managing various kernel objects like keys, files, processes, threads, transactions, and resource managers. These functions are part of the low-level system interface used by the Windows operating system.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp0_x86_prototypes.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, HANDLE TransactionHandle, PULONG Disposition);\nNTSTATUS NtCreateMailslotFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout);\nNTSTATUS NtCreateMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN InitialOwner);\nNTSTATUS NtCreateNamedPipeFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout);\nNTSTATUS NtCreatePrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\nNTSTATUS NtCreatePagingFile (PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority);\nNTSTATUS NtCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtCreateProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort);\nNTSTATUS NtCreateProcessEx (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel);\nNTSTATUS NtCreateProfile (PHANDLE ProfileHandle, HANDLE Process, PVOID RangeBase, SIZE_T RangeSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);\nNTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);\nNTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);\nNTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);\nNTSTATUS NtCreateThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended);\nNTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);\nNTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);\nNTSTATUS NtCreateTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle, ULONG CreateOptions, ULONG IsolationLevel, ULONG IsolationFlags, PLARGE_INTEGER Timeout, PUNICODE_STRING Description);\nNTSTATUS NtOpenTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle);\nNTSTATUS NtQueryInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationTransactionManager (HANDLE TransactionManagerHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength, PULONG ReturnLength);\nNTSTATUS NtPrePrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCommitEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtReadOnlyEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRollbackComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRollbackEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCommitTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\nNTSTATUS NtRollbackTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\nNTSTATUS NtPrePrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCommitComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtSinglePhaseReject (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtSetInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength);\nNTSTATUS NtSetInformationTransactionManager (HANDLE TmHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength);\nNTSTATUS NtSetInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength);\nNTSTATUS NtCreateTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, ULONG CreateOptions, ULONG CommitStrength);\nNTSTATUS NtOpenTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, LPGUID TmIdentity, ULONG OpenOptions);\nNTSTATUS NtRollforwardTransactionManager (HANDLE TransactionManagerHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRecoverEnlistment (HANDLE EnlistmentHandle, PVOID EnlistmentKey);\nNTSTATUS NtRecoverResourceManager (HANDLE ResourceManagerHandle);\nNTSTATUS NtRecoverTransactionManager (HANDLE TransactionManagerHandle);\nNTSTATUS NtCreateResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID RmGuid, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, PUNICODE_STRING Description);\nNTSTATUS NtOpenResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID ResourceManagerGuid, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtGetNotificationResourceManager (HANDLE ResourceManagerHandle, PTRANSACTION_NOTIFICATION TransactionNotification, ULONG NotificationLength, PLARGE_INTEGER Timeout, PULONG ReturnLength, ULONG Asynchronous, ULONG_PTR AsynchronousContext);\nNTSTATUS NtQueryInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength, PULONG ReturnLength);\nNTSTATUS NtCreateEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, HANDLE TransactionHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, NOTIFICATION_MASK NotificationMask, PVOID EnlistmentKey);\nNTSTATUS NtOpenEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, LPGUID EnlistmentGuid, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtSetInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength);\nNTSTATUS NtQueryInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength, PULONG ReturnLength);\n\nNTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtDebugActiveProcess (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtDebugContinue (HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);\nNTSTATUS NtDelayExecution (BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);\nNTSTATUS NtDeleteAtom (RTL_ATOM Atom);\nNTSTATUS NtDeleteBootEntry (ULONG Id);\nNTSTATUS NtDeleteDriverEntry (ULONG Id);\nNTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtDeleteKey (HANDLE KeyHandle);\nNTSTATUS NtDeletePrivateNamespace (HANDLE NamespaceHandle);\nNTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);\nNTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtDisplayString (PUNICODE_STRING String);\nNTSTATUS NtDuplicateObject (HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);\n```\n\n----------------------------------------\n\nTITLE: Declaring a Callback after Machine Initialization - C\nDESCRIPTION: Declares a void function after_machine_init for use as a PANDA callback post machine setup, before guest code execution. Receives CPUState for initialization that may require access to RAM and CPU; commonly employed for enabling features like taint tracking before replay starts. No value is returned; relies on PANDA environment and structures for proper operation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_58\n\nLANGUAGE: C\nCODE:\n```\nvoid after_machine_init(CPUState *env);\n```\n\n----------------------------------------\n\nTITLE: Counting Executed Basic Blocks with PyPANDA in Python\nDESCRIPTION: This snippet demonstrates how to count the number of basic blocks executed inside a 32-bit guest by initializing a Panda instance, registering a pre-block execution callback (via a decorator), and queuing a blocking function to run shell commands within the guest. Dependencies: the pandare Python module, a valid Panda build with Python support, and an accessible qcow2 image. The key parameters are the architecture (e.g., 'i386') and the callback incrementing a global block counter. Input: guest machine image and command; Output: command results and a basic block execution count.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/docs/USAGE.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pandare import Panda\npanda = Panda(generic='i386') # Create an instance of panda\n\n# Counter of the number of basic blocks\nblocks = 0\n\n# Register a callback to run before_block_exec and increment blocks\n@panda.cb_before_block_exec\ndef before_block_execute(cpustate, transblock):\n    global blocks\n    blocks += 1\n\n# This 'blocking' function is queued to run in a seperate thread from the main CPU loop\n# which allows for it to wait for the guest to complete commands\n@panda.queue_blocking\ndef run_cmd():\n    # First revert to the qcow's root snapshot (synchronously)\n    panda.revert_sync(\"root\")\n    # Then type a command via the serial port and print its results\n    print(panda.run_serial_cmd(\"uname -a\"))\n    # When the command finishes, terminate the panda.run() call\n    panda.end_analysis()\n\n# Start the guest\npanda.run()\nprint(\"Finished. Saw a total of {} basic blocks during execution\".format(blocks))\n```\n\n----------------------------------------\n\nTITLE: Declaring Native Windows NT System Call Prototypes in C\nDESCRIPTION: This snippet provides standard C-style function declarations for over 80 NT system calls, describing their signatures as they would appear in a Windows system header file. The declarations specify input/output parameters and use Windows-specific types such as HANDLE, PUNICODE_STRING, and NTSTATUS. No function definitions or logic are included; these are only prototypes and require linking against ntdll.dll or similar, along with the appropriate Windows SDK headers and libraries.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2003sp12_x86_prototypes.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDebugContinue (HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);\nNTSTATUS NtDelayExecution (BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);\nNTSTATUS NtDeleteAtom (RTL_ATOM Atom);\nNTSTATUS NtDeleteBootEntry (ULONG Id);\nNTSTATUS NtDeleteDriverEntry (ULONG Id);\nNTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtDeleteKey (HANDLE KeyHandle);\nNTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);\nNTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtDisplayString (PUNICODE_STRING String);\nNTSTATUS NtDuplicateObject (HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);\nNTSTATUS NtDuplicateToken (HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);\nNTSTATUS NtEnumerateBootEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateDriverEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateKey (HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtEnumerateSystemEnvironmentValuesEx (ULONG InformationClass, PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateValueKey (HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);\nNTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);\nNTSTATUS NtFindAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\nNTSTATUS NtFlushBuffersFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);\nNTSTATUS NtFlushKey (HANDLE KeyHandle);\nNTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);\nNTSTATUS NtFlushWriteBuffer ();\nNTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG FreeType);\nNTSTATUS NtFsControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nNTSTATUS NtGetDevicePowerState (HANDLE Device, DEVICE_POWER_STATE *State);\nNTSTATUS NtGetPlugPlayEvent (HANDLE EventHandle, PVOID Context, PPLUGPLAY_EVENT_BLOCK EventBlock, ULONG EventBufferSize);\nNTSTATUS NtGetWriteWatch (HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, SIZE_T RegionSize, PVOID *UserAddressArray, PULONG_PTR EntriesInUserAddressArray, PULONG Granularity);\nNTSTATUS NtImpersonateAnonymousToken (HANDLE ThreadHandle);\nNTSTATUS NtImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE Message);\nNTSTATUS NtImpersonateThread (HANDLE ServerThreadHandle, HANDLE ClientThreadHandle, PSECURITY_QUALITY_OF_SERVICE SecurityQos);\nNTSTATUS NtInitializeRegistry (USHORT BootCondition);\nNTSTATUS NtInitiatePowerAction (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);\nNTSTATUS NtIsProcessInJob (HANDLE ProcessHandle, HANDLE JobHandle);\nBOOLEAN NtIsSystemResumeAutomatic ();\nNTSTATUS NtListenPort (HANDLE PortHandle, PPORT_MESSAGE ConnectionRequest);\nNTSTATUS NtLoadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtLoadKey (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile);\nNTSTATUS NtLoadKey2 (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags);\nNTSTATUS NtLoadKeyEx (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags, HANDLE TrustClassKey );\nNTSTATUS NtLockFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);\nNTSTATUS NtLockProductActivationKeys (ULONG *pPrivateVer, ULONG *pSafeMode);\nNTSTATUS NtLockRegistryKey (HANDLE KeyHandle);\nNTSTATUS NtLockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtMakePermanentObject (HANDLE Handle);\nNTSTATUS NtMakeTemporaryObject (HANDLE Handle);\nNTSTATUS NtMapUserPhysicalPages (PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, WIN32_PROTECTION_MASK Win32Protect);\nNTSTATUS NtModifyBootEntry (PBOOT_ENTRY BootEntry);\nNTSTATUS NtModifyDriverEntry (PEFI_DRIVER_ENTRY DriverEntry);\nNTSTATUS NtNotifyChangeDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree);\nNTSTATUS NtNotifyChangeKey (HANDLE KeyHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtNotifyChangeMultipleKeys (HANDLE MasterKeyHandle, ULONG Count, OBJECT_ATTRIBUTES SlaveObjects[], HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtOpenDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);\nNTSTATUS NtOpenIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, ACCESS_MASK GrantedAccess, PPRIVILEGE_SET Privileges, BOOLEAN ObjectCreation, BOOLEAN AccessGranted, PBOOLEAN GenerateOnClose);\nNTSTATUS NtOpenProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenProcessToken (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);\nNTSTATUS NtOpenProcessTokenEx (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenThreadToken (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);\nNTSTATUS NtOpenThreadTokenEx (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtPlugPlayControl (PLUGPLAY_CONTROL_CLASS PnPControlClass, PVOID PnPControlData, ULONG PnPControlDataLength);\nNTSTATUS NtPowerInformation (POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtPrivilegeCheck (HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, PBOOLEAN Result);\nNTSTATUS NtPrivilegeObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\nNTSTATUS NtPrivilegedServiceAuditAlarm (PUNICODE_STRING SubsystemName, PUNICODE_STRING ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\n```\n\n----------------------------------------\n\nTITLE: Registering and Implementing pri Plugin Callbacks - C\nDESCRIPTION: This C code snippet demonstrates the initialization and teardown sequence for a PANDA plugin using pri for OS-level debugging introspection. It details the inclusion of both pri and provider headers, conditional compilation for target platforms, live variable debug printing through callback implementation, and callback registration. Dependencies include PANDA core/plugin infrastructure, pri, and a symbol provider (e.g., dwarfp). Key parameters passed to the callbacks are CPU state, program counter, file/function names, and variable info. Inputs are event-driven via PANDA introspection; outputs are side effects (logging variable locations). Only 32-bit Linux targets are supported in the provided logic.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/pri/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#ifdef __cplusplus\nextern \"C\" {\n\n// usual panda includes . . .\n\n// pri specific includes\n#include \"../pri/pri_types.h\"\n#include \"../pri/pri_ext.h\"\n#include \"../pri/pri.h\"\n// pri provider include\n#include \"../dwarfp/dwarfp_ext.h\"\n\n    bool init_plugin(void *);\n    void uninit_plugin(void *);\n\n}\n#endif\n\n// pri is only supported 32 bit linux\n#if defined(TARGET_I386) && !defined(TARGET_X86_64)\nvoid pfun(void *var_ty, const char *var_nm, LocType loc_t, target_ulong loc){\n    switch (loc_t){\n        case LocReg:\n            printf(\"VAR REG %s in 0x%x\\n\", var_nm, loc);\n            break;\n        case LocMem:\n            printf(\"VAR MEM %s @ 0x%x\\n\", var_nm, loc);\n            break;\n        case LocConst:\n            printf(\"VAR CONST %s as 0x%x\\n\", var_nm, loc);\n            break;\n        case LocErr:\n            printf(\"VAR does not have a location we coulddetermine. Most likely because the var is splitamong multiple locations\\n\");\n            break;\n    }\n}\nvoid on_line_change(CPUState *env, target_ulong pc, const char*file_Name, const char *funct_name, unsigned long long lno){\n    printf(\"[%s] %s(), ln: %4lld, pc @ 0x%x\\n\",file_Name,funct_name,lno,pc);\n    //pri_funct_livevar_iter(env, pc, pfun);\n}\nvoid on_fn_start(CPUState *env, target_ulong pc, const char*file_Name, const char *funct_name, unsigned long long lno){\n    printf(\"fn-start: %s() [%s], ln: %4lld, pc @ 0x%x\\n\"funct_name,file_Name,lno,pc);\n    pri_funct_livevar_iter(env, pc, pfun);\n}\n#endif\n\nbool init_plugin(void *self) {\n#if defined(TARGET_I386) && !defined(TARGET_X86_64)\n    printf(\"Initializing plugin dwarf_simple\\n\");\n    //panda_arg_list *args = panda_get_args(\"dwarf_taint\");\n    panda_require(\"pri\");\n    assert(init_pri_api());\n    panda_require(\"dwarfp\");\n    assert(init_dwarfp_api());\n    //PPP_REG_CB(\"pri\", on_line_change, on_line_change);\n    PPP_REG_CB(\"pri\", on_fn_start, on_fn_start);\n#endif\n    return true;\n}\nvoid uninit_plugin(void *self) {\n}\n\n```\n\n----------------------------------------\n\nTITLE: Linux System Call Function Declarations in C\nDESCRIPTION: This snippet defines a comprehensive list of Linux system call function signatures with their parameters and return types. Each function signature corresponds to a specific system call number (4001-4168) and defines the interface between user applications and the kernel.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nlong sys_exit(int error_code);\npid_t sys_fork(void);\nlong sys_read(unsigned int fd, char __user *buf, size_t count);\nlong sys_write(unsigned int fd, const char __user *buf, size_t count);\nlong sys_open(const char __user *filename, int flags, umode_t mode);\nlong sys_close(unsigned int fd);\nlong sys_waitpid(pid_t pid, int __user *stat_addr, int options);\nlong sys_creat(const char __user *pathname, umode_t mode);\nlong sys_link(const char __user *oldname, const char __user *newname);\nlong sys_unlink(const char __user *pathname);\nlong sys_execve(const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp);\nlong sys_chdir(const char __user *filename);\nlong sys_time32(old_time32_t __user *tloc);\nlong sys_mknod(const char __user *filename, umode_t mode, unsigned dev);\nlong sys_chmod(const char __user *filename, umode_t mode);\nlong sys_lchown(const char __user *filename, uid_t user, gid_t group);\n// 4017 sys_break - UNIMPLEMENTED\nlong sys_stat(const char __user *filename, struct __old_kernel_stat __user *statbuf);\nlong sys_lseek(unsigned int fd, off_t offset, unsigned int whence);\nlong sys_getpid(void);\nlong sys_mount(char __user *dev_name, char __user *dir_name, char __user *type, unsigned long flags, void __user *data);\nlong sys_oldumount(char __user *name);\nlong sys_setuid(uid_t uid);\nlong sys_getuid(void);\nlong sys_stime32(old_time32_t __user *tptr);\nlong sys_ptrace(long request, long pid, unsigned long addr, unsigned long data);\nlong sys_alarm(unsigned int seconds);\nlong sys_fstat(unsigned int fd, struct __old_kernel_stat __user *statbuf);\nlong sys_pause(void);\nlong sys_utime32(const char __user *filename, struct old_utimbuf32 __user *t);\n// 4031 sys_stty - UNIMPLEMENTED\n// 4032 sys_gtty - UNIMPLEMENTED\nlong sys_access(const char __user *filename, int mode);\nlong sys_nice(int increment);\n// 4035 sys_ftime - UNIMPLEMENTED\nlong sys_sync(void);\nlong sys_kill(pid_t pid, int sig);\nlong sys_rename(const char __user *oldname, const char __user *newname);\nlong sys_mkdir(const char __user *pathname, umode_t mode);\nlong sys_rmdir(const char __user *pathname);\nlong sys_dup(unsigned int fildes);\nlong sys_pipe(int __user *fildes);\nlong sys_times(struct tms __user *tbuf);\nlong sys_brk(unsigned long brk);\nlong sys_setgid(gid_t gid);\nlong sys_getgid(void);\nlong sys_signal(int sig, __sighandler_t handler);\nlong sys_geteuid(void);\nlong sys_getegid(void);\nlong sys_acct(const char __user *name);\nlong sys_umount(char __user *name, int flags);\nlong sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);\nlong sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg);\n// 4056 sys_mpx - UNIMPLEMENTED\nlong sys_setpgid(pid_t pid, pid_t pgid);\n// 4058 sys_ulimit - UNIMPLEMENTED\nlong sys_olduname(struct oldold_utsname __user *);\nlong sys_umask(int mask);\nlong sys_chroot(const char __user *filename);\nlong sys_ustat(unsigned dev, struct ustat __user *ubuf);\nlong sys_dup2(unsigned int oldfd, unsigned int newfd);\nlong sys_getppid(void);\nlong sys_getpgrp(void);\nlong sys_setsid(void);\nlong sys_sigaction(int, const struct old_sigaction __user *, struct old_sigaction __user *);\nlong sys_sgetmask(void);\nlong sys_ssetmask(int newmask);\nlong sys_setreuid(uid_t ruid, uid_t euid);\nlong sys_setregid(gid_t rgid, gid_t egid);\nlong sys_sigsuspend(int unused1, int unused2, old_sigset_t mask);\nlong sys_sigpending(old_sigset_t __user *uset);\nlong sys_sethostname(char __user *name, int len);\nlong sys_setrlimit(unsigned int resource, struct rlimit __user *rlim);\nlong sys_getrlimit(unsigned int resource, struct rlimit __user *rlim);\nlong sys_getrusage(int who, struct rusage __user *ru);\nlong sys_gettimeofday(struct __kernel_old_timeval __user *tv, struct timezone __user *tz);\nlong sys_settimeofday(struct __kernel_old_timeval __user *tv, struct timezone __user *tz);\nlong sys_getgroups(int gidsetsize, gid_t __user *grouplist);\nlong sys_setgroups(int gidsetsize, gid_t __user *grouplist);\n// 4082 - RESERVED\nlong sys_symlink(const char __user *old, const char __user *new);\nlong sys_lstat(const char __user *filename, struct __old_kernel_stat __user *statbuf);\nlong sys_readlink(const char __user *path, char __user *buf, int bufsiz);\nlong sys_uselib(const char __user *library);\nlong sys_swapon(const char __user *specialfile, int swap_flags);\nlong sys_reboot(int magic1, int magic2, unsigned int cmd, void __user *arg);\nlong sys_old_readdir(unsigned int, struct old_linux_dirent __user *, unsigned int);\nlong sys_mmap(unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags, unsigned long fd, unsigned long pgoff);\nlong sys_munmap(unsigned long addr, size_t len);\nlong sys_truncate(const char __user *path, long length);\nlong sys_ftruncate(unsigned int fd, unsigned long length);\nlong sys_fchmod(unsigned int fd, umode_t mode);\nlong sys_fchown(unsigned int fd, uid_t user, gid_t group);\nlong sys_getpriority(int which, int who);\nlong sys_setpriority(int which, int who, int niceval);\n// 4098 sys_profil - UNIMPLEMENTED\nlong sys_statfs(const char __user *path, struct statfs __user *buf);\nlong sys_fstatfs(unsigned int fd, struct statfs __user *buf);\nlong sys_ioperm(unsigned long from, unsigned long num, int on);\nlong sys_socketcall(int call, unsigned long __user *args);\nlong sys_syslog(int type, char __user *buf, int len);\nlong sys_setitimer(int which, struct __kernel_old_itimerval __user *value, struct __kernel_old_itimerval __user *ovalue);\nlong sys_getitimer(int which, struct __kernel_old_itimerval __user *value);\nlong sys_newstat(const char __user *filename, struct stat __user *statbuf);\nlong sys_newlstat(const char __user *filename, struct stat __user *statbuf);\nlong sys_newfstat(unsigned int fd, struct stat __user *statbuf);\nlong sys_uname(struct old_utsname __user *);\nlong sys_iopl(int level);\nlong sys_vhangup(void);\nlong sys_idle(void);\n// 4113 sys_vm86 - X86 ONLY AND DEPRECIATED\nlong sys_wait4(pid_t pid, int __user *stat_addr, int options, struct rusage __user *ru);\nlong sys_swapoff(const char __user *specialfile);\nlong sys_sysinfo(struct sysinfo __user *info);\nlong sys_ipc(unsigned int call, int first, unsigned long second, unsigned long third, void __user *ptr, long fifth);\nlong sys_fsync(unsigned int fd);\nvoid sys_sigreturn(void);\nlong sys_clone(unsigned long, unsigned long, int __user *, unsigned long, int __user *);\nlong sys_setdomainname(char __user *name, int len);\nlong sys_newuname(struct new_utsname __user *name);\nlong modify_ldt(int func, void *ptr, unsigned long bytecount);\nlong sys_adjtimex_time32(struct old_timex32 __user *txc_p);\nlong sys_mprotect(unsigned long start, size_t len, unsigned long prot);\nlong sys_sigprocmask(int how, old_sigset_t __user *set, old_sigset_t __user *oset);\ncaddr_t create_module(const char *name, size_t size);\nlong sys_init_module(void __user *umod, unsigned long len, const char __user *uargs);\nlong sys_delete_module(const char __user *name_user, unsigned int flags);\nlong get_kernel_syms(struct kernel_sym *table);\nlong sys_quotactl(unsigned int cmd, const char __user *special, qid_t id, void __user *addr);\nlong sys_getpgid(pid_t pid);\nlong sys_fchdir(unsigned int fd);\nlong sys_bdflush(int func, long data);\nlong sys_sysfs(int option, unsigned long arg1, unsigned long arg2);\nlong sys_personality(unsigned int personality);\n// 4137 sys_afs_syscall - UNIMPLEMENTED\nlong sys_setfsuid(uid_t uid);\nlong sys_setfsgid(gid_t gid);\nlong sys_llseek(unsigned int fd, unsigned long offset_high, unsigned long offset_low, loff_t __user *result, unsigned int whence);\nlong sys_getdents(unsigned int fd, struct linux_dirent __user *dirent, unsigned int count);\nlong sys_select(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct __kernel_old_timeval __user *tvp);\nlong sys_flock(unsigned int fd, unsigned int cmd);\nlong sys_msync(unsigned long start, size_t len, int flags);\nlong sys_readv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\nlong sys_writev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\nlong sys_cacheflush(char *addr, int nbytes, int cache);\n// 4148 sys_cachectl - ???\n// 4149 sys_sysmips - ???\nlong sys_setup(void);\nlong sys_getsid(pid_t pid);\nlong sys_fdatasync(unsigned int fd);\nlong sys_sysctl(struct __sysctl_args __user *args);\nlong sys_mlock(unsigned long start, size_t len);\nlong sys_munlock(unsigned long start, size_t len);\nlong sys_mlockall(int flags);\nlong sys_munlockall(void);\nlong sys_sched_setparam(pid_t pid, struct sched_param __user *param);\nlong sys_sched_getparam(pid_t pid, struct sched_param __user *param);\nlong sys_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param);\nlong sys_sched_getscheduler(pid_t pid);\nlong sys_sched_yield(void);\nlong sys_sched_get_priority_max(int policy);\nlong sys_sched_get_priority_min(int policy);\nlong sys_sched_rr_get_interval_time32(pid_t pid, struct old_timespec32 __user *interval);\nlong sys_nanosleep_time32(struct old_timespec32 __user *rqtp, struct old_timespec32 __user *rmtp);\nlong sys_mremap(unsigned long addr, unsigned long old_len, unsigned long new_len, unsigned long flags, unsigned long new_addr);\nlong sys_accept(int, struct sockaddr __user *, int __user *);\n```\n\n----------------------------------------\n\nTITLE: Implementing and Registering a Syscall Callback with PANDA syscalls2 Plugin (C)\nDESCRIPTION: This C code implements a sample PANDA plugin callback for the Windows NtReadFile system call, prints syscall arguments for tracing, and registers the handler with the syscalls2 plugin. Required dependencies are PANDA plugin APIs and header files from both the plugin and syscalls2 directories. Key parameters include the full syscall argument list, and the registration function (PPP_REG_CB) ensures the callback is invoked at syscall entry. It must be compiled and loaded as a PANDA plugin, with syscalls2 active and the target OS profile specified; incorrect argument matching or registration may prevent correct callback execution.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n#include \"plugin/plugin.h\"\n#include \"panda/plugin_plugin.h\"\n#include \"syscalls2/syscalls_ext_typedefs.h\"\n\nvoid my_NtReadFile_enter(\n        CPUState* env,\n        target_ulong pc,\n        uint32_t FileHandle,\n        uint32_t Event,\n        uint32_t UserApcRoutine,\n        uint32_t UserApcContext,\n        uint32_t IoStatusBlock,\n        uint32_t Buffer,\n        uint32_t BufferLength,\n        uint32_t ByteOffset,\n        uint32_t Key) {\n   printf(\"NtReadFile(FileHandle=%x, Event=%x, UserApcRoutine=%x, \"\n                     \"UserApcContext=%x, IoStatusBlock=%x, Buffer=%x, \"\n                     \"BufferLength=%x, ByteOffset=%x, Key=%x)\\n\",\n        FileHandle, Event, UserApcRoutine, UserApcContext,\n        IoStatusBlock, Buffer, BufferLength, ByteOffset, Key);\n}\n\n// ...\n\nbool init_plugin(void *self) {\n    PPP_REG_CB(\"syscalls2\", on_NtReadFile_enter, my_NtReadFile_enter);\n    return true;\n}\n\n// ...\n\n```\n\n----------------------------------------\n\nTITLE: Network Operation Prototypes in C\nDESCRIPTION: Function prototypes for Linux system calls related to network operations. These functions provide interfaces for socket connections, message transmission, and controlling network behaviors.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_15\n\nLANGUAGE: c\nCODE:\n```\nlong sys_accept4(int, struct sockaddr __user *, int __user *, int);\nlong sys_recvmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags, struct __kernel_timespec __user *timeout);\nlong sys_sendmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags);\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing Guest Physical Memory in C\nDESCRIPTION: This function allows a plugin to synchronously read or write a sequence of bytes in guest physical memory. It requires the guest physical address (addr), a buffer (buf), the length (len), and a flag (is_write) to select between read (0) and write (1). Returns 0 on success, non-zero if the memory page is not mapped; it never accesses guest I/O, only RAM.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nint panda_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf, int len, int is_write);\n```\n\n----------------------------------------\n\nTITLE: Running PANDA with tainted_net to Analyze Network-Dependent Instructions\nDESCRIPTION: This command launches PANDA with the 'tainted_net' plugin to label incoming network data with taint and uses 'tainted_instr' to identify instructions that process this tainted data. The 'taint2' plugin is automatically loaded as a dependency.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/tainted_net/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/i386-softmmu/panda-system-i386 -net nic -net user \\\n    -replay foo \\\n    -panda tainted_net:label_incoming_network=true \\\n    -panda tainted_instr\n```\n\n----------------------------------------\n\nTITLE: Initializing RAM, ROM, MMIO, and Specialized QEMU Memory Regions in C\nDESCRIPTION: Demonstrates various memory region initialization routines in C for the QEMU memory subsystem, such as memory_region_init_ram(), memory_region_init_resizeable_ram(), memory_region_init_ram_from_file(), memory_region_init_ram_ptr(), memory_region_init_io(), memory_region_init_rom(), memory_region_init_rom_device(), memory_region_init_iommu(), memory_region_init(), memory_region_init_alias(), and memory_region_init_reservation() (or memory_region_init_io() with a NULL callback). These functions set up different types of guest-visible memory (e.g., RAM, MMIO, ROM, containers, aliases) required for extending device emulation or custom memory maps. Each function has specific dependencies on the QEMU core libraries and sometimes host resources (e.g., files for backing RAM); required arguments commonly include pointers to MemoryRegion structs, size, name, flags, callbacks, and parent object references. Input parameters determine the memory region behavior, such as accessibility and callbacks for read/write. The output is initialized MemoryRegion objects, ready to be added to address spaces or containers. These routines are subject to QEMU's memory model constraints and require careful handling with respect to region ownership and lifecycle.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/memory.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/* Example: Initialize a RAM region */\\nmemory_region_init_ram(&ram, owner, \"region_name\", size, &error_abort);\\n\\n/* Example: Initialize a resizable RAM region */\\nmemory_region_init_resizeable_ram(&ram, owner, \"region_name\", size, max_size, &error_abort);\\n\\n/* Initialize RAM from file */\\nmemory_region_init_ram_from_file(&ram, owner, \"region_name\", size, file, shared, &error_abort);\\n\\n/* Initialize RAM from a pointer */\\nmemory_region_init_ram_ptr(&ram, owner, \"region_name\", size, ptr);\\n\\n/* Initialize MMIO region with callbacks */\\nmemory_region_init_io(&mmio, owner, &mmio_ops, opaque, \"region_name\", size);\\n\\n/* Initialize a ROM region */\\nmemory_region_init_rom(&rom, owner, \"region_name\", size, &error_abort);\\n\\n/* Initialize a ROM device region */\\nmemory_region_init_rom_device(&rom_dev, owner, &write_ops, opaque, \"region_name\", size);\\n\\n/* Initialize IOMMU region */\\nmemory_region_init_iommu(&iommu, owner, &iommu_ops, opaque, \"iommu_name\", size);\\n\\n/* Initialize a pure container region */\\nmemory_region_init(&container, owner, \"container_name\", size);\\n\\n/* Initialize an alias region */\\nmemory_region_init_alias(&alias, owner, \"alias_name\", size, &target_region, offset);\\n\\n/* Initialize a reservation region */\\nmemory_region_init_reservation(&reservation, owner, \"reservation_name\", size);\\n/* or by passing a NULL callback to memory_region_init_io */\\nmemory_region_init_io(&reservation, owner, NULL, NULL, \"reservation_name\", size);\n```\n\n----------------------------------------\n\nTITLE: Sample kernelinfo.conf Section (GLib key-value format)\nDESCRIPTION: This snippet shows how to format a section in kernelinfo.conf to match kernel offsets extracted with the kernelinfo module. This example must be placed under a dedicated section header (e.g., [my_kernel_info]) and referenced by the `kconf_group` parameter of the plugin. Users should fill in the fields with actual output values. Each key matches an offset or version field required for introspection.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi_linux/README.md#_snippet_3\n\nLANGUAGE: GLib key-value (INI)\nCODE:\n```\n[my_kernel_info]\nname = #1 SMP Debian 3.2.51-1 i686\nversion.a = 3\n[...]\n\n```\n\n----------------------------------------\n\nTITLE: Declaring File I/O System Calls in C for FreeBSD\nDESCRIPTION: This snippet declares system calls for file I/O operations in FreeBSD, including reading, writing, seeking, and truncating files. It also includes functions for memory-mapped I/O and file descriptor operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_21\n\nLANGUAGE: C\nCODE:\n```\nssize_t pread(int fd, void *buf, size_t nbyte, off_t offset);\nssize_t pwrite(int fd, const void *buf, size_t nbyte, off_t offset);\nvoid *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t pos);\noff_t lseek(int fd, off_t offset, int whence);\nint truncate(const char *path, off_t length);\nint ftruncate(int fd, off_t length);\n```\n\n----------------------------------------\n\nTITLE: Declaring OSI Data Structures for Introspection - C\nDESCRIPTION: This C snippet defines several data structures crucial to the OSI introspection APIs. The structures represent fundamental OS-level concepts such as process handles (OsiProcHandle), threads (OsiThread), memory pages (OsiPage), modules (OsiModule), processes (OsiProc), and process memory (OsiProcMem). Fields within these structs represent pointers and IDs relevant to the target system, and some include string or pointer fields for names and collections (such as a pointer to a list of pages in OsiProc). These structs form the base types returned or manipulated by the introspection APIs, and must be allocated and freed in accordance with OSI and GLib memory management rules.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n    // Represents a process handle\n    typedef struct osi_prochandle_struct {\n        target_ptr_t taskd;\n        target_ptr_t asid;\n    } OsiProcHandle;\n\n    // Represents a thread\n    typedef struct osi_thread_struct {\n        target_pid_t pid;\n        target_pid_t tid;\n    } OsiThread;\n\n    // Represents a page of memory (not implemented so far)\n    typedef struct osi_page_struct {\n        target_ptr_t start;\n        target_ulong len;\n    } OsiPage;\n\n    // Represents a single module (userspace library or kernel module)\n    typedef struct osi_module_struct {\n        target_ptr_t modd;\n        target_ptr_t base;\n        target_ptr_t size;\n        char *file;\n        char *name;\n    } OsiModule;\n\n    // Represents a single process\n    typedef struct osi_proc_struct {\n        target_ptr_t taskd;\n        target_ptr_t asid;\n        target_pid_t pid;\n        target_pid_t ppid;\n        char *name;\n        OsiPage *pages;     // TODO in osi_linux\n    } OsiProc;\n\n    // Represents process memory details\n    typedef struct osi_proc_mem {\n        target_ptr_t start_brk;\n        target_ptr_t brk;\n    } OsiProcMem;\n\n```\n\n----------------------------------------\n\nTITLE: Windows NT File Operations\nDESCRIPTION: Function declarations for file system operations including reading, writing, and querying file information.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2000_x86_prototypes.txt#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtReadFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtSetInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\n```\n\n----------------------------------------\n\nTITLE: Configuring PANDA Plugins with Custom Options - Bash\nDESCRIPTION: This Bash code demonstrates launching a PANDA system emulator for replaying execution traces with a set of plugins configured. It shows how to pass custom options to the taint2 plugin (such as \"no_tp=y\" to disable tainted pointers) even when taint2 is auto-loaded as a dependency of file_taint. Required dependencies include a built PANDA environment, the appropriate system binary (here, x86_64-softmmu), and availability of the listed plugins. Users must specify an existing replay to load and configuration options for each plugin. The command outputs logs to the specified pandalog file, and changes in plugin ordering or options may affect results.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/taint2/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo -panda osi \\\n    -panda osi_linux:kconf_group=debian-3.2.63-i686 \\\n    -panda syscalls2:profile=linux_x86 \\\n    -panda taint2:no_tp=y \\\n    -panda file_taint:filename=foo.dat \\\n    -panda tainted_branch \\\n    -pandalog foo.plog\n```\n\n----------------------------------------\n\nTITLE: Kernel Semaphore Operations in C\nDESCRIPTION: Function declarations for kernel semaphore operations. These functions allow creating, opening, closing, and manipulating POSIX-style semaphores.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_15\n\nLANGUAGE: c\nCODE:\n```\nint ksem_close(semid_t id);\nint ksem_post(semid_t id);\nint ksem_wait(semid_t id);\nint ksem_trywait(semid_t id);\nint ksem_init(semid_t *idp, unsigned int value);\nint ksem_open(semid_t *idp, const char *name, int oflag, mode_t mode, unsigned int value);\nint ksem_unlink(const char *name);\nint ksem_getvalue(semid_t id, int *val);\nint ksem_destroy(semid_t id);\nint __mac_get_pid(pid_t pid, struct mac *mac_p);\nint __mac_get_link(const char *path_p, struct mac *mac_p);\nint __mac_set_link(const char *path_p, struct mac *mac_p);\nssize_t extattr_set_link(const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes);\nssize_t extattr_get_link(const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes);\nint extattr_delete_link(const char *path, int attrnamespace, const char *attrname);\nint __mac_execve(const char *fname, char **argv, char **envv, struct mac *mac_p);\nint sigaction(int sig, const struct sigaction *act, struct sigaction *oact);\nint sigreturn(const struct __ucontext *sigcntxp);\n```\n\n----------------------------------------\n\nTITLE: Defining and Querying Core Kernel Introspection APIs via C\nDESCRIPTION: This snippet lists the main C function prototypes provided by the COSI core API for introspection of kernel symbol and structure data, offering type and symbol lookup, field and offset retrieval, and memory management. The functions expect appropriate pointer types from the Volatility and PANDA frameworks and are declared in the cosi.h header file. Return types vary (pointers, target addresses, strings, booleans), and correct use of dependencies is crucial for safe operation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/cosi/README.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ntarget_ptr_t kaslr_offset(CPUState *cpu);\nconst VolatilityEnum *enum_from_name(const char *name);\nconst VolatilityBaseType *base_type_from_name(const char *name);\nconst VolatilitySymbol *symbol_from_name(const char *name);\nconst VolatilityStruct *type_from_name(const char *name);\ntarget_ptr_t addr_of_symbol(const VolatilitySymbol *symbol);\ntarget_ptr_t value_of_symbol(const VolatilitySymbol *symbol);\nchar *name_of_symbol(const VolatilitySymbol *symbol);\nchar *name_of_struct(const VolatilityStruct *ty);\nchar *get_field_by_index(const VolatilityStruct *ty, uintptr_t index);\nchar *name_of_enum(const VolatilityEnum *ty);\nchar *name_of_base_type(const VolatilityBaseType *ty);\ntarget_ptr_t size_of_base_type(const VolatilityBaseType *ty);\nbool is_base_type_signed(const VolatilityBaseType *ty);\ntarget_ptr_t symbol_value_from_name(const char *name);\ntarget_ptr_t symbol_addr_from_name(const char *name);\ntarget_long offset_of_field(const VolatilityStruct *vol_struct, const char *name);\nchar *type_of_field(const VolatilityStruct *vol_struct, const char *name);\ntarget_ulong size_of_struct(const VolatilityStruct *vol_struct);\ntarget_ulong current_cpu_offset(CPUState *cpu);\nvoid free_cosi_str(char *string);\n```\n\n----------------------------------------\n\nTITLE: Event and Timer System Calls in C\nDESCRIPTION: System call declarations for event handling, timers, and notifications including epoll, timerfd, and eventfd operations\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_arm_prototypes.txt#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nlong sys_epoll_pwait(int epfd, struct epoll_event __user *events, int maxevents, int timeout, const sigset_t __user *sigmask, size_t sigsetsize);\nlong sys_timerfd_create(int clockid, int flags);\nlong sys_eventfd(unsigned int count);\nlong sys_timerfd_settime(int ufd, int flags, const struct itimerspec __user *utmr, struct itimerspec __user *otmr);\n```\n\n----------------------------------------\n\nTITLE: Using an Exported Plugin API in C\nDESCRIPTION: This snippet shows how to consume an API exported from another plugin within PANDA. By including <plugin>_ext.h, the consumer gains access to the exported functions, and then initializes the API at runtime with init_<plugin>_api(). The snippet demonstrates invoking a plugin-provided function and checking initialization status; return values are used to confirm successful setup. Dependencies include the presence of generated headers and the corresponding plugin library.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_22\n\nLANGUAGE: C\nCODE:\n```\n#include \"../sample/sample_ext.h\"\n\nvoid some_other_callback() {\n    // This function is defined in sample_ext.h but can be used here\n    sample_function();\n}\n\nbool init_plugin(void *self) {\n    if (!init_sample_api()) return false;\n    return true;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Call Prototypes in C\nDESCRIPTION: Each snippet provides the function signature (prototype) for a specific native Windows NT system call using the C programming language. These prototypes define the expected parameters, including handles, security structures, object attributes, and data buffers, as well as the NTSTATUS return value convention. There are no implementation detailsâ€”just function declarationsâ€”making them essential for linking or referencing these system calls directly in C applications requiring low-level OS access; dependencies may include Windows data type definitions (e.g., HANDLE, PUNICODE_STRING, ACCESS_MASK). Inputs and outputs are determined by the function parameters, and use is constrained to compatible platforms and privilege levels.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2000_x86_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAcceptConnectPort (PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheck (PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckByType (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeResultList (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarmByHandle (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAddAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAdjustGroupsToken (HANDLE TokenHandle, BOOLEAN ResetToDefault, PTOKEN_GROUPS NewState, ULONG BufferLength, PTOKEN_GROUPS PreviousState, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAdjustPrivilegesToken (HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAlertResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAlertThread (HANDLE ThreadHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAllocateLocallyUniqueId (PLUID Luid);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAllocateUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAllocateUuids (PULARGE_INTEGER Time, PULONG Range, PULONG Sequence, PCHAR Seed);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAllocateVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAreMappedFilesTheSame (PVOID File1MappedAsAnImage, PVOID File2MappedAsFile);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAssignProcessToJobObject (HANDLE JobHandle, HANDLE ProcessHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCallbackReturn (PVOID OutputBuffer, ULONG OutputLength, NTSTATUS Status);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCancelIoFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCancelTimer (HANDLE TimerHandle, PBOOLEAN CurrentState);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtClearEvent (HANDLE EventHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtClose (HANDLE Handle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCloseObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCompleteConnectPort (HANDLE PortHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtContinue (PCONTEXT ContextRecord, BOOLEAN TestAlert);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Count);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateMailslotFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN InitialOwner);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateNamedPipeFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreatePagingFile (PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateProfile (PHANDLE ProfileHandle, HANDLE Process, PVOID RangeBase, SIZE_T RangeSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDelayExecution (BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDeleteAtom (RTL_ATOM Atom);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDeleteKey (HANDLE KeyHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDisplayString (PUNICODE_STRING String);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDuplicateObject (HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);\n```\n\n----------------------------------------\n\nTITLE: Declaring Get Unknown Mappings Callback Typedef in C\nDESCRIPTION: Defines a typedef for returning memory mappings of unknown or non-standard origin, such as additional heap or mmap segments. Currently implemented only in osi_linux. The callback takes CPUState, OsiProc for the target process, and outputs a GArray** of OsiModule types explaining unknown memory segments.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_15\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_get_unknown_mappings_t)(CPUState *, OsiProc *, GArray**)\n```\n\n----------------------------------------\n\nTITLE: Populating Fields in Panda__LogEntry for Logging - C\nDESCRIPTION: Populates the Panda__LogEntry struct's fields (asid, process_id, process_name) and updates their corresponding 'has_' flags to indicate presence. Required before passing to pandalog_write_entry. This step assures proper serialization of only the set fields, per protobuf/C conventions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_26\n\nLANGUAGE: C\nCODE:\n```\nple.has_asid = 1;\\nple.asid = p->asid;\\nple.has_process_id = 1;\\nple.process_id = p->pid;\\nple.process_name = p->name;\n```\n\n----------------------------------------\n\nTITLE: Defining Port Connection System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to port connection and communication. These functions establish communication channels between processes via named ports.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\n```\n\n----------------------------------------\n\nTITLE: Declaring Native NT System Call Prototypes - Windows NT API - C\nDESCRIPTION: This code snippet declares a series of Windows NT API native function prototypes in C, enabling direct invocation of low-level kernel and system services such as querying or setting information on files, processes, threads, registry keys, security descriptors, and events. These declarations require Windows NT kernel header dependencies for types like HANDLE, NTSTATUS, PVOID, and various information class enums. Each function typically takes handles to objects (such as files or processes), pointers to output buffers or structures, and relevant enums or flags for requested operations. Inputs include object handles and structured parameters; outputs depend on requested service, often filling provided buffers. Usage of these functions is constrained by required privileges, exact structure alignment, and availability in modern Windows versions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_xpsp2_x86_prototypes.txt#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryDebugFilterState (ULONG ComponentId, ULONG Level);\nNTSTATUS NtQueryDefaultLocale (BOOLEAN UserProfile, PLCID DefaultLocaleId);\nNTSTATUS NtQueryDefaultUILanguage (LANGID *DefaultUILanguageId);\nNTSTATUS NtQueryDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);\nNTSTATUS NtQueryDirectoryObject (HANDLE DirectoryHandle, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, BOOLEAN RestartScan, PULONG Context, PULONG ReturnLength);\nNTSTATUS NtQueryEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan);\nNTSTATUS NtQueryEvent (HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryFullAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);\nNTSTATUS NtQueryInformationAtom (RTL_ATOM Atom, ATOM_INFORMATION_CLASS InformationClass, PVOID AtomInformation, ULONG AtomInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\nNTSTATUS NtQueryInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationPort (HANDLE PortHandle, PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtQueryInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInstallUILanguage (LANGID *InstallUILanguageId);\nNTSTATUS NtQueryIntervalProfile (KPROFILE_SOURCE ProfileSource, PULONG Interval);\nNTSTATUS NtQueryIoCompletion (HANDLE IoCompletionHandle, IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass, PVOID IoCompletionInformation, ULONG IoCompletionInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryKey (HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtQueryMultipleValueKey (HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength);\nNTSTATUS NtQueryMutant (HANDLE MutantHandle, MUTANT_INFORMATION_CLASS MutantInformationClass, PVOID MutantInformation, ULONG MutantInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryOpenSubKeys (POBJECT_ATTRIBUTES TargetKey, PULONG HandleCount);\nNTSTATUS NtQueryPerformanceCounter (PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);\nNTSTATUS NtQueryQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID SidList, ULONG SidListLength, PULONG StartSid, BOOLEAN RestartScan);\nNTSTATUS NtQuerySection (HANDLE SectionHandle, SECTION_INFORMATION_CLASS SectionInformationClass, PVOID SectionInformation, SIZE_T SectionInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtQuerySecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Length, PULONG LengthNeeded);\nNTSTATUS NtQuerySemaphore (HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG SemaphoreInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySymbolicLinkObject (HANDLE LinkHandle, PUNICODE_STRING LinkTarget, PULONG ReturnedLength);\nNTSTATUS NtQuerySystemEnvironmentValue (PUNICODE_STRING VariableName, PWSTR VariableValue, USHORT ValueLength, PUSHORT ReturnLength);\nNTSTATUS NtQuerySystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, PULONG ValueLength, PULONG Attributes);\nNTSTATUS NtQuerySystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySystemTime (PLARGE_INTEGER SystemTime);\nNTSTATUS NtQueryTimer (HANDLE TimerHandle, TIMER_INFORMATION_CLASS TimerInformationClass, PVOID TimerInformation, ULONG TimerInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryTimerResolution (PULONG MaximumTime, PULONG MinimumTime, PULONG CurrentTime);\nNTSTATUS NtQueryValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtQueryVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtQueryVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtQueueApcThread (HANDLE ThreadHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\nNTSTATUS NtRaiseException (PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ContextRecord, BOOLEAN FirstChance);\nNTSTATUS NtRaiseHardError (NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask, PULONG_PTR Parameters, ULONG ValidResponseOptions, PULONG Response);\nNTSTATUS NtReadFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtReadFileScatter (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtReadRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtReadVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtRegisterThreadTerminatePort (HANDLE PortHandle);\nNTSTATUS NtReleaseMutant (HANDLE MutantHandle, PLONG PreviousCount);\nNTSTATUS NtReleaseSemaphore (HANDLE SemaphoreHandle, LONG ReleaseCount, PLONG PreviousCount);\nNTSTATUS NtRemoveIoCompletion (HANDLE IoCompletionHandle, PVOID *KeyContext, PVOID *ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER Timeout);\nNTSTATUS NtRemoveProcessDebug (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtRenameKey (HANDLE KeyHandle, PUNICODE_STRING NewName);\nNTSTATUS NtReplaceKey (POBJECT_ATTRIBUTES NewFile, HANDLE TargetHandle, POBJECT_ATTRIBUTES OldFile);\nNTSTATUS NtReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtReplyWaitReceivePort (HANDLE PortHandle, PVOID *PortContext , PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage);\nNTSTATUS NtReplyWaitReceivePortEx (HANDLE PortHandle, PVOID *PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage, PLARGE_INTEGER Timeout);\nNTSTATUS NtReplyWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtRequestPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage);\nNTSTATUS NtRequestWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtResetEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtResetWriteWatch (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T RegionSize);\nNTSTATUS NtRestoreKey (HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags);\nNTSTATUS NtResumeProcess (HANDLE ProcessHandle);\nNTSTATUS NtResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtSaveKey (HANDLE KeyHandle, HANDLE FileHandle);\nNTSTATUS NtSaveKeyEx (HANDLE KeyHandle, HANDLE FileHandle, ULONG Format);\nNTSTATUS NtSaveMergedKeys (HANDLE HighPrecedenceKeyHandle, HANDLE LowPrecedenceKeyHandle, HANDLE FileHandle);\nNTSTATUS NtSecureConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PSID RequiredServerSid, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\nNTSTATUS NtSetBootEntryOrder (PULONG Ids, ULONG Count);\nNTSTATUS NtSetBootOptions (PBOOT_OPTIONS BootOptions, ULONG FieldsToChange);\nNTSTATUS NtSetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nNTSTATUS NtSetDebugFilterState (ULONG ComponentId, ULONG Level, BOOLEAN State);\nNTSTATUS NtSetDefaultHardErrorPort (HANDLE DefaultHardErrorPort);\nNTSTATUS NtSetDefaultLocale (BOOLEAN UserProfile, LCID DefaultLocaleId);\nNTSTATUS NtSetDefaultUILanguage (LANGID DefaultUILanguageId);\nNTSTATUS NtSetEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\nNTSTATUS NtSetEvent (HANDLE EventHandle, PLONG PreviousState);\n```\n\n----------------------------------------\n\nTITLE: Performing Sequentially Consistent Atomic Read-Modify-Write Operations in QEMU (C)\nDESCRIPTION: This snippet shows a suite of sequentially consistent atomic macros for safely modifying shared variables in concurrent QEMU code. Operations like atomic_inc, atomic_dec, atomic_add, atomic_sub, atomic_and, atomic_or, and atomic_xchg are included, each operating on a pointer to an int-width type and, for fetch variants, returning the previous value. These macros depend on the inclusion of qemu/atomic.h and ensure that all threads see operations in a consistent global order. They are polymorphic for int-wide data types and may have varying performance on different CPU architectures.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/atomics.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nvoid atomic_inc(ptr)\nvoid atomic_dec(ptr)\nvoid atomic_add(ptr, val)\nvoid atomic_sub(ptr, val)\nvoid atomic_and(ptr, val)\nvoid atomic_or(ptr, val)\n\ntypeof(*ptr) atomic_fetch_inc(ptr)\ntypeof(*ptr) atomic_fetch_dec(ptr)\ntypeof(*ptr) atomic_fetch_add(ptr, val)\ntypeof(*ptr) atomic_fetch_sub(ptr, val)\ntypeof(*ptr) atomic_fetch_and(ptr, val)\ntypeof(*ptr) atomic_fetch_or(ptr, val)\ntypeof(*ptr) atomic_xchg(ptr, val)\ntypeof(*ptr) atomic_cmpxchg(ptr, old, new)\n```\n\n----------------------------------------\n\nTITLE: Implementing QMP Command with Error Handling (QAPI, C)\nDESCRIPTION: This updated C implementation for the 'hello-world' QMP command demonstrates error checking. If the provided 'message' contains the word 'love', an error is reported using the error_setg() macro. Otherwise, the function prints the message or the default string as before. The 'Error **errp' parameter is used for error propagation per QEMU convention.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/writing-qmp-commands.txt#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nvoid qmp_hello_world(bool has_message, const char *message, Error **errp)\n{\n    if (has_message) {\n        if (strstr(message, \"love\")) {\n            error_setg(errp, \"the word 'love' is not allowed\");\n            return;\n        }\n        printf(\"%s\\n\", message);\n    } else {\n        printf(\"Hello, world\\n\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PPP Callback for Auxiliary Vectors in PANDA Plugin (C)\nDESCRIPTION: This C code snippet defines the signature for a PPP callback function named on_rec_auxv_t within PANDA's proc_start_linux plugin. It enables users to hook and process the auxv structure each time it is recorded from the guest. The function accepts pointers to the guest CPU state, a translation block, and the auxv data structure. Prerequisites include PANDA with the syscalls2 plugin, Structures CPUState, TranslationBlock, and auxv_values must be properly defined. The callback does not guarantee every auxv value, as some fields may be zero if unset by the guest kernel.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/proc_start_linux/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid (*on_rec_auxv_t)(CPUState *env, TranslationBlock *tb, struct auxv_values);\n```\n\n----------------------------------------\n\nTITLE: Declaring System Call Prototypes in Linux Kernel (C)\nDESCRIPTION: This snippet declares function prototypes for system calls in the Linux kernel. Each function follows a consistent 'sys_' prefix naming convention and returns either 'long' or 'void', with parameters representing user-provided or kernel-managed data. These declarations require inclusion of relevant type definitions and are prerequisites for syscall table generation and implementation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\n5123 long sys_capget(cap_user_header_t header, cap_user_data_t dataptr);\n5124 long sys_capset(cap_user_header_t header, const cap_user_data_t data);\n5125 long sys_rt_sigpending(sigset_t __user *set, size_t sigsetsize);\n5126 long sys_rt_sigtimedwait(const sigset_t __user *uthese, siginfo_t __user *uinfo, const struct __kernel_timespec __user *uts, size_t sigsetsize);\n5127 long sys_rt_sigqueueinfo(pid_t pid, int sig, siginfo_t __user *uinfo);\n5128 long sys_rt_sigsuspend(sigset_t __user *unewset, size_t sigsetsize);\n5129 long sys_sigaltstack(const struct sigaltstack __user *uss, struct sigaltstack __user *uoss);\n5130 long sys_utime(char __user *filename, struct utimbuf __user *times);\n5131 long sys_mknod(const char __user *filename, umode_t mode, unsigned dev);\n5132 long sys_personality(unsigned int personality);\n5133 long sys_ustat(unsigned dev, struct ustat __user *ubuf);\n5134 long sys_statfs(const char __user *path, struct statfs __user *buf);\n5135 long sys_fstatfs(unsigned int fd, struct statfs __user *buf);\n5136 long sys_sysfs(int option, unsigned long arg1, unsigned long arg2);\n5137 long sys_getpriority(int which, int who);\n5138 long sys_setpriority(int which, int who, int niceval);\n5139 long sys_sched_setparam(pid_t pid, struct sched_param __user *param);\n5140 long sys_sched_getparam(pid_t pid, struct sched_param __user *param);\n5141 long sys_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param);\n5142 long sys_sched_getscheduler(pid_t pid);\n5143 long sys_sched_get_priority_max(int policy);\n5144 long sys_sched_get_priority_min(int policy);\n5145 long sys_sched_rr_get_interval(pid_t pid, struct __kernel_timespec __user *interval);\n5146 long sys_mlock(unsigned long start, size_t len);\n5147 long sys_munlock(unsigned long start, size_t len);\n5148 long sys_mlockall(int flags);\n5149 long sys_munlockall(void);\n5150 long sys_vhangup(void);\n5151 long sys_pivot_root(const char __user *new_root, const char __user *put_old);\n5152 long sys_sysctl(struct __sysctl_args __user *args);\n5153 long sys_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\n5154 long sys_adjtimex(struct __kernel_timex __user *txc_p);\n5155 long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim);\n5156 long sys_chroot(const char __user *filename);\n5157 long sys_sync(void);\n5158 long sys_acct(const char __user *name);\n5159 long sys_settimeofday(struct __kernel_old_timeval __user *tv, struct timezone __user *tz);\n5160 long sys_mount(char __user *dev_name, char __user *dir_name, char __user *type, unsigned long flags, void __user *data);\n5161 long sys_umount(char __user *name, int flags);\n5162 long sys_swapon(const char __user *specialfile, int swap_flags);\n5163 long sys_swapoff(const char __user *specialfile);\n5164 long sys_reboot(int magic1, int magic2, unsigned int cmd, void __user *arg);\n5165 long sys_sethostname(char __user *name, int len);\n5166 long sys_setdomainname(char __user *name, int len);\n5167 long sys_ni_syscall(void);\n5168 long sys_init_module(void __user *umod, unsigned long len, const char __user *uargs);\n5169 long sys_delete_module(const char __user *name_user, unsigned int flags);\n5170 long sys_ni_syscall(void);\n5171 long sys_ni_syscall(void);\n5172 long sys_quotactl(unsigned int cmd, const char __user *special, qid_t id, void __user *addr);\n5173 long sys_ni_syscall(void);\n5174 long sys_ni_syscall(void);\n5175 long sys_ni_syscall(void);\n5176 long sys_ni_syscall(void);\n5177 long sys_ni_syscall(void);\n5178 long sys_gettid(void);\n5179 long sys_readahead(int fd, loff_t offset, size_t count);\n5180 long sys_setxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\n5181 long sys_lsetxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\n5182 long sys_fsetxattr(int fd, const char __user *name, const void __user *value, size_t size, int flags);\n5183 long sys_getxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\n5184 long sys_lgetxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\n5185 long sys_fgetxattr(int fd, const char __user *name, void __user *value, size_t size);\n5186 long sys_listxattr(const char __user *path, char __user *list, size_t size);\n5187 long sys_llistxattr(const char __user *path, char __user *list, size_t size);\n5188 long sys_flistxattr(int fd, char __user *list, size_t size);\n5189 long sys_removexattr(const char __user *path, const char __user *name);\n5190 long sys_lremovexattr(const char __user *path, const char __user *name);\n5191 long sys_fremovexattr(int fd, const char __user *name);\n5192 long sys_tkill(pid_t pid, int sig);\n5193 long sys_ni_syscall(void);\n5194 long sys_futex(u32 __user *uaddr, int op, u32 val, struct __kernel_timespec __user *utime, u32 __user *uaddr2, u32 val3);\n5195 long sys_sched_setaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\n5196 long sys_sched_getaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\n5200 long sys_io_setup(unsigned nr_reqs, aio_context_t __user *ctx);\n5201 long sys_io_destroy(aio_context_t ctx);\n5202 long sys_io_getevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct __kernel_timespec __user *timeout);\n5203 long sys_io_submit(aio_context_t, long, struct iocb __user * __user *);\n5204 long sys_io_cancel(aio_context_t ctx_id, struct iocb __user *iocb, struct io_event __user *result);\n5205 long sys_exit_group(int error_code);\n5206 long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);\n5207 long sys_epoll_create(int size);\n5208 long sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user *event);\n5209 long sys_epoll_wait(int epfd, struct epoll_event __user *events, int maxevents, int timeout);\n5210 long sys_remap_file_pages(unsigned long start, unsigned long size, unsigned long prot, unsigned long pgoff, unsigned long flags);\n5211 void sys_rt_sigreturn(void);\n5212 long sys_set_tid_address(int __user *tidptr);\n5213 long sys_restart_syscall(void);\n5214 long sys_semtimedop(int semid, struct sembuf __user *sops, unsigned nsops, const struct __kernel_timespec __user *timeout);\n5215 long sys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice);\n5216 long sys_timer_create(clockid_t which_clock, struct sigevent __user *timer_event_spec, timer_t __user *created_timer_id);\n5217 long sys_timer_settime(timer_t timer_id, int flags, const struct __kernel_itimerspec __user *new_setting, struct __kernel_itimerspec __user *old_setting);\n5218 long sys_timer_gettime(timer_t timer_id, struct __kernel_itimerspec __user *setting);\n5219 long sys_timer_getoverrun(timer_t timer_id);\n5220 long sys_timer_delete(timer_t timer_id);\n5221 long sys_clock_settime(clockid_t which_clock, const struct __kernel_timespec __user *tp);\n5222 long sys_clock_gettime(clockid_t which_clock, struct __kernel_timespec __user *tp);\n5223 long sys_clock_getres(clockid_t which_clock, struct __kernel_timespec __user *tp);\n5224 long sys_clock_nanosleep(clockid_t which_clock, int flags, const struct __kernel_timespec __user *rqtp, struct __kernel_timespec __user *rmtp);\n5225 long sys_tgkill(pid_t tgid, pid_t pid, int sig);\n5226 long sys_utimes(char __user *filename, struct __kernel_old_timeval __user *utimes);\n5227 long sys_mbind(unsigned long start, unsigned long len, unsigned long mode, const unsigned long __user *nmask, unsigned long maxnode, unsigned flags);\n5228 long sys_get_mempolicy(int __user *policy, unsigned long __user *nmask, unsigned long maxnode, unsigned long addr, unsigned long flags);\n5229 long sys_set_mempolicy(int mode, const unsigned long __user *nmask, unsigned long maxnode);\n5230 long sys_mq_open(const char __user *name, int oflag, umode_t mode, struct mq_attr __user *attr);\n5231 long sys_mq_unlink(const char __user *name);\n5232 long sys_mq_timedsend(mqd_t mqdes, const char __user *msg_ptr, size_t msg_len, unsigned int msg_prio, const struct __kernel_timespec __user *abs_timeout);\n5233 long sys_mq_timedreceive(mqd_t mqdes, char __user *msg_ptr, size_t msg_len, unsigned int __user *msg_prio, const struct __kernel_timespec __user *abs_timeout);\n5234 long sys_mq_notify(mqd_t mqdes, const struct sigevent __user *notification);\n5235 long sys_mq_getsetattr(mqd_t mqdes, const struct mq_attr __user *mqstat, struct mq_attr __user *omqstat);\n5236 long sys_ni_syscall(void);\n5237 long sys_waitid(int which, pid_t pid, struct siginfo __user *infop, int options, struct rusage __user *ru);\n5239 long sys_add_key(const char __user *_type, const char __user *_description, const void __user *_payload, size_t plen, key_serial_t destringid);\n5240 long sys_request_key(const char __user *_type, const char __user *_description, const char __user *_callout_info, key_serial_t destringid);\n5241 long sys_keyctl(int cmd, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\n5243 long sys_inotify_init(void);\n5244 long sys_inotify_add_watch(int fd, const char __user *path, u32 mask);\n5245 long sys_inotify_rm_watch(int fd, __s32 wd);\n5246 long sys_migrate_pages(pid_t pid, unsigned long maxnode, const unsigned long __user *from, const unsigned long __user *to);\n5247 long sys_openat(int dfd, const char __user *filename, int flags, umode_t mode);\n5248 long sys_mkdirat(int dfd, const char __user *pathname, umode_t mode);\n5249 long sys_mknodat(int dfd, const char __user *filename, umode_t mode, unsigned dev);\n5250 long sys_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group, int flag);\n5251 long sys_futimesat(int dfd, const char __user *filename, struct __kernel_old_timeval __user *utimes);\n5252 long sys_newfstatat(int dfd, const char __user *filename, struct stat __user *statbuf, int flag);\n5253 long sys_unlinkat(int dfd, const char __user *pathname, int flag);\n```\n\n----------------------------------------\n\nTITLE: Declaring NT System Call Prototypes - Windows Native API - C\nDESCRIPTION: These snippets define the prototypes for various Windows NT system calls, such as setting thread execution state, managing timers, processes, memory, files, and jobs, as well as system-level debugging and shutdown actions. Dependencies include Windows data types (e.g., HANDLE, NTSTATUS, PLARGE_INTEGER, etc.) that require appropriate header files like windows.h, ntdef.h, and ntifs.h. Each prototype specifies the function name, return type (NTSTATUS), and a set of parameters pertinent to its respective operation, with the expectation that actual implementation is provided by the operating system kernel. Inputs are typically handles and pointers to data structures, while outputs may be status codes or modified data buffers. Limitations: Intended for use in C/C++ environments with access to appropriate system headers and privileges for invoking native NT APIs; misuse may lead to security or stability issues.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2000_x86_prototypes.txt#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetThreadExecutionState (EXECUTION_STATE esFlags, PEXECUTION_STATE PreviousFlags);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetTimer (HANDLE TimerHandle, PLARGE_INTEGER DueTime, PTIMER_APC_ROUTINE TimerApcRoutine, PVOID TimerContext, BOOLEAN WakeTimer, LONG Period, PBOOLEAN PreviousState);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetTimerResolution (ULONG DesiredTime, BOOLEAN SetResolution, PULONG ActualTime);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetUuidSeed (PCHAR Seed);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtShutdownSystem (SHUTDOWN_ACTION Action);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSignalAndWaitForSingleObject (HANDLE SignalHandle, HANDLE WaitHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtStartProfile (HANDLE ProfileHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtStopProfile (HANDLE ProfileHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSuspendThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSystemDebugControl (SYSDBG_COMMAND Command, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtTerminateJobObject (HANDLE JobHandle, NTSTATUS ExitStatus);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtTerminateProcess (HANDLE ProcessHandle, NTSTATUS ExitStatus);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtTerminateThread (HANDLE ThreadHandle, NTSTATUS ExitStatus);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtTestAlert ();\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtUnloadDriver (PUNICODE_STRING DriverServiceName);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtUnloadKey (POBJECT_ATTRIBUTES TargetKey);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtUnlockFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtUnlockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtUnmapViewOfSection (HANDLE ProcessHandle, PVOID BaseAddress);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtVdmControl (VDMSERVICECLASS Service, PVOID ServiceData);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtWaitForMultipleObjects (ULONG Count, HANDLE Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtWaitForSingleObject (HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtWaitHighEventPair (HANDLE EventPairHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtWaitLowEventPair (HANDLE EventPairHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtWriteFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtWriteFileGather (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtWriteRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtWriteVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtYieldExecution ();\n```\n\n----------------------------------------\n\nTITLE: Declaring Before Physical Memory Write Callback Signature in PANDA (C)\nDESCRIPTION: Provides a function signature used to intercept physical memory write operations prior to execution, supplying access to CPU state, PC, address, size, and the data buffer to be written. Plugin authors must enable memory callbacks manually to use this feature. No return value, for pure side-effect use.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_41\n\nLANGUAGE: C\nCODE:\n```\nvoid (*phys_mem_before_write)(CPUState *env, target_ulong pc, target_ulong addr, target_ulong size, void *buf);\n```\n\n----------------------------------------\n\nTITLE: Declaring Get Processes Callback Typedef in C\nDESCRIPTION: Declares a typedef for an OSI provider callback to enumerate all current processes in the guest OS. The callback receives a CPUState pointer and an output GArray** that it should fill with OsiProc entries as specified by the OS-specific data containers. Plugins must manage memory with g_array_free. This callback is vital for process enumeration and introspection within the OSI framework.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_get_processes_t)(CPUState *, GArray **)\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows Native NT Service Prototypes in C\nDESCRIPTION: This block provides forward declarations for dozens of Nt* family functions, enabling access to low-level system functionality for registry, process, thread, file, transaction, security, and other kernel operations. Usage requires appropriate inclusion of Windows headers and knowledge of associated data structures and constants (e.g., HANDLE, NTSTATUS, PVOID, structures like IO_STATUS_BLOCK, etc). Functions expect parameters corresponding to object handles, pointers to buffers or data, and configuration flags, generally returning NTSTATUS codes for error handling. Expected usage is in system utilities, drivers, or low-level management tools that interact directly with the Windows kernel or native subsystem, and callers must observe significant security and stability constraints.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x86_prototypes.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSaveMergedKeys (HANDLE HighPrecedenceKeyHandle, HANDLE LowPrecedenceKeyHandle, HANDLE FileHandle);\nNTSTATUS NtSaveKeyEx (HANDLE KeyHandle, HANDLE FileHandle, ULONG Format);\nNTSTATUS NtSaveKey (HANDLE KeyHandle, HANDLE FileHandle);\nNTSTATUS NtRollforwardTransactionManager (HANDLE TransactionManagerHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRollbackTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\nNTSTATUS NtRollbackEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRollbackComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtResumeProcess (HANDLE ProcessHandle);\nNTSTATUS NtRestoreKey (HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags);\nNTSTATUS NtResetWriteWatch (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T RegionSize);\nNTSTATUS NtResetEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtRequestWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtRequestPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage);\nNTSTATUS NtReplyWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtReplyWaitReceivePortEx (HANDLE PortHandle, PVOID *PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage, PLARGE_INTEGER Timeout);\nNTSTATUS NtReplyWaitReceivePort (HANDLE PortHandle, PVOID *PortContext , PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage);\nNTSTATUS NtReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtReplacePartitionUnit (PUNICODE_STRING TargetInstancePath, PUNICODE_STRING SpareInstancePath, ULONG Flags);\nNTSTATUS NtReplaceKey (POBJECT_ATTRIBUTES NewFile, HANDLE TargetHandle, POBJECT_ATTRIBUTES OldFile);\nNTSTATUS NtRenameTransactionManager (PUNICODE_STRING LogFileName, LPGUID ExistingTransactionManagerGuid);\nNTSTATUS NtRenameKey (HANDLE KeyHandle, PUNICODE_STRING NewName);\nNTSTATUS NtRemoveProcessDebug (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtRemoveIoCompletionEx (HANDLE IoCompletionHandle, PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation, ULONG Count, PULONG NumEntriesRemoved, PLARGE_INTEGER Timeout, BOOLEAN Alertable);\nNTSTATUS NtRemoveIoCompletion (HANDLE IoCompletionHandle, PVOID *KeyContext, PVOID *ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER Timeout);\nNTSTATUS NtReleaseWorkerFactoryWorker (HANDLE WorkerFactoryHandle);\nNTSTATUS NtReleaseSemaphore (HANDLE SemaphoreHandle, LONG ReleaseCount, PLONG PreviousCount);\nNTSTATUS NtReleaseMutant (HANDLE MutantHandle, PLONG PreviousCount);\nNTSTATUS NtReleaseKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtRegisterThreadTerminatePort (HANDLE PortHandle);\nNTSTATUS NtRegisterProtocolAddressInformation (HANDLE ResourceManager, PCRM_PROTOCOL_ID ProtocolId, ULONG ProtocolInformationSize, PVOID ProtocolInformation, ULONG CreateOptions);\nNTSTATUS NtRecoverTransactionManager (HANDLE TransactionManagerHandle);\nNTSTATUS NtRecoverResourceManager (HANDLE ResourceManagerHandle);\nNTSTATUS NtRecoverEnlistment (HANDLE EnlistmentHandle, PVOID EnlistmentKey);\nNTSTATUS NtReadVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtReadRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtReadOnlyEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtReadFileScatter (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtReadFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtRaiseHardError (NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask, PULONG_PTR Parameters, ULONG ValidResponseOptions, PULONG Response);\nNTSTATUS NtRaiseException (PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ContextRecord, BOOLEAN FirstChance);\nNTSTATUS NtQueueApcThreadEx (HANDLE ThreadHandle, HANDLE UserApcReserveHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\nNTSTATUS NtQueueApcThread (HANDLE ThreadHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\nNTSTATUS NtQueryVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtQueryVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtQueryValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtQueryTimerResolution (PULONG MaximumTime, PULONG MinimumTime, PULONG CurrentTime);\nNTSTATUS NtQueryTimer (HANDLE TimerHandle, TIMER_INFORMATION_CLASS TimerInformationClass, PVOID TimerInformation, ULONG TimerInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySystemTime (PLARGE_INTEGER SystemTime);\nNTSTATUS NtQuerySystemInformationEx (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID QueryInformation, ULONG QueryInformationLength, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, PULONG ValueLength, PULONG Attributes);\nNTSTATUS NtQuerySystemEnvironmentValue (PUNICODE_STRING VariableName, PWSTR VariableValue, USHORT ValueLength, PUSHORT ReturnLength);\nNTSTATUS NtQuerySymbolicLinkObject (HANDLE LinkHandle, PUNICODE_STRING LinkTarget, PULONG ReturnedLength);\nNTSTATUS NtQuerySemaphore (HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG SemaphoreInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Length, PULONG LengthNeeded);\nNTSTATUS NtQuerySecurityAttributesToken (HANDLE TokenHandle, PUNICODE_STRING Attributes, ULONG NumberOfAttributes, PVOID Buffer, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtQuerySection (HANDLE SectionHandle, SECTION_INFORMATION_CLASS SectionInformationClass, PVOID SectionInformation, SIZE_T SectionInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtQueryQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID SidList, ULONG SidListLength, PULONG StartSid, BOOLEAN RestartScan);\nNTSTATUS NtQueryPortInformationProcess ();\nNTSTATUS NtQueryPerformanceCounter (PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);\nNTSTATUS NtQueryOpenSubKeysEx (POBJECT_ATTRIBUTES TargetKey, ULONG BufferLength, PVOID Buffer, PULONG RequiredSize);\nNTSTATUS NtQueryOpenSubKeys (POBJECT_ATTRIBUTES TargetKey, PULONG HandleCount);\nNTSTATUS NtQueryObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryMutant (HANDLE MutantHandle, MUTANT_INFORMATION_CLASS MutantInformationClass, PVOID MutantInformation, ULONG MutantInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryMultipleValueKey (HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength);\nNTSTATUS NtQueryLicenseValue (PUNICODE_STRING Name, PULONG Type, PVOID Buffer, ULONG Length, PULONG ReturnedLength);\nNTSTATUS NtQueryKey (HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtQueryIoCompletion (HANDLE IoCompletionHandle, IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass, PVOID IoCompletionInformation, ULONG IoCompletionInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryIntervalProfile (KPROFILE_SOURCE ProfileSource, PULONG Interval);\nNTSTATUS NtQueryInstallUILanguage (LANGID *InstallUILanguageId);\nNTSTATUS NtQueryInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationTransactionManager (HANDLE TransactionManagerHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API ALPC Communication Functions in C\nDESCRIPTION: Function declarations for Windows NT native API calls related to Advanced Local Procedure Call (ALPC) mechanism for inter-process communication. These functions manage port connections, message passing, and security contexts for ALPC communication.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp0_x64_prototypes.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAlpcAcceptConnectPort (PHANDLE PortHandle, HANDLE ConnectionPortHandle, ULONG Flags, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes, BOOLEAN AcceptConnection);\nNTSTATUS NtAlpcCancelMessage (HANDLE PortHandle, ULONG Flags, PALPC_CONTEXT_ATTR MessageContext);\nNTSTATUS NtAlpcConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, ULONG Flags, PSID RequiredServerSid, PPORT_MESSAGE ConnectionMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes, PALPC_MESSAGE_ATTRIBUTES InMessageAttributes, PLARGE_INTEGER Timeout);\nNTSTATUS NtAlpcCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes);\nNTSTATUS NtAlpcCreatePortSection (HANDLE PortHandle, ULONG Flags, HANDLE SectionHandle, SIZE_T SectionSize, PALPC_HANDLE AlpcSectionHandle, PSIZE_T ActualSectionSize);\nNTSTATUS NtAlpcCreateResourceReserve (HANDLE PortHandle, ULONG Flags, SIZE_T MessageSize, PALPC_HANDLE ResourceId);\nNTSTATUS NtAlpcCreateSectionView (HANDLE PortHandle, ULONG Flags, PALPC_DATA_VIEW_ATTR ViewAttributes);\nNTSTATUS NtAlpcCreateSecurityContext (HANDLE PortHandle, ULONG Flags, PALPC_SECURITY_ATTR SecurityAttribute);\nNTSTATUS NtAlpcDeletePortSection (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE SectionHandle);\nNTSTATUS NtAlpcDeleteResourceReserve (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ResourceId);\nNTSTATUS NtAlpcDeleteSectionView (HANDLE PortHandle, ULONG Flags, PVOID ViewBase);\nNTSTATUS NtAlpcDeleteSecurityContext (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);\nNTSTATUS NtAlpcDisconnectPort (HANDLE PortHandle, ULONG Flags);\nNTSTATUS NtAlpcImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE PortMessage, PVOID Reserved);\nNTSTATUS NtAlpcOpenSenderProcess (PHANDLE ProcessHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtAlpcOpenSenderThread (PHANDLE ThreadHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtAlpcQueryInformation (HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtAlpcQueryInformationMessage (HANDLE PortHandle, PPORT_MESSAGE PortMessage, ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass, PVOID MessageInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtAlpcRevokeSecurityContext (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);\n```\n\n----------------------------------------\n\nTITLE: Adding a String Pattern in PANDA Plugin (C)\nDESCRIPTION: This C function adds a search string (literal or hex byte pattern) to the stringsearch plugin's internal list. Takes a null-terminated string as input and returns true if the string was added (or already present). Requires inclusion of the plugin's API header and linking against the PANDA stringsearch implementation. Input: const char* arg (search string); Output: bool (success). Works only if the stringsearch plugin is loaded; strings must be ASCII or colon-separated hex values.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/stringsearch/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nbool add_string(const char* arg)\n```\n\n----------------------------------------\n\nTITLE: Declaring Before Block Execution Callback Signature in PANDA (C)\nDESCRIPTION: Describes a function pointer interface called before the execution of every translated basic block, supplying plugin writers with the CPU state and translation block prior to execution. Offers a hook for instrumentation or other side effects prior to block execution, with an integer return value (unused). Dependencies include PANDA CPU and translation block types.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_32\n\nLANGUAGE: C\nCODE:\n```\nint (*before_block_exec)(CPUState *env, TranslationBlock *tb);\n```\n\n----------------------------------------\n\nTITLE: Registering a pre-block-execution Callback with PyPANDA in Python\nDESCRIPTION: This snippet illustrates how to register a Python function as a callback using the @panda.cb_before_block_exec decorator. The callback prints the program counter before each translation block runs, using methods on the Panda instance to acquire the current PC. Requires a Panda object and appropriate build. Inputs: cpustate, translation_block; Output: string logging the address of next executed block to stdout.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/docs/USAGE.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@panda.cb_before_block_exec\ndef my_before_block_fn(cpustate, translation_block):\n  pc = panda.current_pc(cpustate)\n  print(\"About to run the block at 0x{:x}\".format(pc))\n```\n\n----------------------------------------\n\nTITLE: Declaring Native NT System Service Prototypes - C/C++\nDESCRIPTION: This snippet provides C/C++ function prototypes for a variety of Windows NT Native API (NTAPI) functions, enabling direct interaction with kernel-level system services. These declarations generally require kernel headers and dependencies on types such as HANDLE, ACCESS_MASK, and various custom structs/enums (e.g., POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK). Each function is designed for use in low-level system, driver, or emulation code, providing input and output parameters via pointers, and returning NTSTATUS to indicate success or specific failure reasons. The expected usage is for implementing system call wrappers, emulation layers, or advanced debugging tools.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2000_x86_prototypes.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDuplicateToken (HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);\nNTSTATUS NtEnumerateKey (HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtEnumerateValueKey (HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);\nNTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);\nNTSTATUS NtFindAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\nNTSTATUS NtFlushBuffersFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);\nNTSTATUS NtFlushKey (HANDLE KeyHandle);\nNTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);\nNTSTATUS NtFlushWriteBuffer ();\nNTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG FreeType);\nNTSTATUS NtFsControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nNTSTATUS NtGetDevicePowerState (HANDLE Device, DEVICE_POWER_STATE *State);\nNTSTATUS NtGetPlugPlayEvent (HANDLE EventHandle, PVOID Context, PPLUGPLAY_EVENT_BLOCK EventBlock, ULONG EventBufferSize);\nNTSTATUS NtGetWriteWatch (HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, SIZE_T RegionSize, PVOID *UserAddressArray, PULONG_PTR EntriesInUserAddressArray, PULONG Granularity);\nNTSTATUS NtImpersonateAnonymousToken (HANDLE ThreadHandle);\nNTSTATUS NtImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE Message);\nNTSTATUS NtImpersonateThread (HANDLE ServerThreadHandle, HANDLE ClientThreadHandle, PSECURITY_QUALITY_OF_SERVICE SecurityQos);\nNTSTATUS NtInitializeRegistry (USHORT BootCondition);\nNTSTATUS NtInitiatePowerAction (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);\nBOOLEAN NtIsSystemResumeAutomatic ();\nNTSTATUS NtListenPort (HANDLE PortHandle, PPORT_MESSAGE ConnectionRequest);\nNTSTATUS NtLoadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtLoadKey (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile);\nNTSTATUS NtLoadKey2 (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags);\nNTSTATUS NtLockFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);\nNTSTATUS NtLockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtMakeTemporaryObject (HANDLE Handle);\nNTSTATUS NtMapUserPhysicalPages (PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, WIN32_PROTECTION_MASK Win32Protect);\nNTSTATUS NtNotifyChangeDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree);\nNTSTATUS NtNotifyChangeKey (HANDLE KeyHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtNotifyChangeMultipleKeys (HANDLE MasterKeyHandle, ULONG Count, OBJECT_ATTRIBUTES SlaveObjects[], HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtOpenDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);\nNTSTATUS NtOpenIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, ACCESS_MASK GrantedAccess, PPRIVILEGE_SET Privileges, BOOLEAN ObjectCreation, BOOLEAN AccessGranted, PBOOLEAN GenerateOnClose);\nNTSTATUS NtOpenProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenProcessToken (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);\nNTSTATUS NtOpenSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenThreadToken (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);\nNTSTATUS NtOpenTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtPlugPlayControl (PLUGPLAY_CONTROL_CLASS PnPControlClass, PVOID PnPControlData, ULONG PnPControlDataLength);\nNTSTATUS NtPowerInformation (POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtPrivilegeCheck (HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, PBOOLEAN Result);\nNTSTATUS NtPrivilegedServiceAuditAlarm (PUNICODE_STRING SubsystemName, PUNICODE_STRING ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\nNTSTATUS NtPrivilegeObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\nNTSTATUS NtProtectVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, WIN32_PROTECTION_MASK NewProtectWin32, PULONG OldProtect);\nNTSTATUS NtPulseEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtQueryInformationAtom (RTL_ATOM Atom, ATOM_INFORMATION_CLASS InformationClass, PVOID AtomInformation, ULONG AtomInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);\nNTSTATUS NtQueryDefaultLocale (BOOLEAN UserProfile, PLCID DefaultLocaleId);\nNTSTATUS NtQueryDefaultUILanguage (LANGID *DefaultUILanguageId);\nNTSTATUS NtQueryDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);\nNTSTATUS NtQueryDirectoryObject (HANDLE DirectoryHandle, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, BOOLEAN RestartScan, PULONG Context, PULONG ReturnLength);\nNTSTATUS NtQueryEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan);\nNTSTATUS NtQueryEvent (HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryFullAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);\nNTSTATUS NtQueryInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\nNTSTATUS NtQueryInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength, PULONG ReturnLength);\n```\n\n----------------------------------------\n\nTITLE: Running Coverage Collection with PANDA (Shell Command)\nDESCRIPTION: This shell command demonstrates how to launch PANDA for x86 with a specified recording, guest OS, and the 'coverage' plugin configured to output results in 'osi-block' mode to 'test_coverage.csv'. Prerequisites include a PANDA environment with the appropriate guest recording, OSI plugin support, and the 'coverage' plugin installed. Key parameters: '-replay' for the recording, '-os' for guest OS specification, and plugin arguments for filename and mode. The expected result is a CSV file with coverage results written for post-processing. Limitations: this specific example is for OSI-supported guests only.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/coverage/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npanda-system-i386 -m 2G -replay test \\\n    -os windows-32-xpsp3 \\\n    -panda coverage:filename=test_coverage.csv,mode=osi-block\n```\n\n----------------------------------------\n\nTITLE: Defining Transaction Management System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to transaction management. These functions handle commit operations and enlistment in the Windows NT transaction framework.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCommitComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCommitEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCommitTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\n```\n\n----------------------------------------\n\nTITLE: Downloading the Kernel Info Module Generator\nDESCRIPTION: Command to download a snapshot of the kernel information module generator from July 2020. This is needed to compile and run the module to extract kernel structure offsets.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi_linux/utils/kernelinfo/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwget https://panda-re.mit.edu/kernelinfos/generator_july20.tgz\n```\n\n----------------------------------------\n\nTITLE: Declaring System Call Callback Typedefs for syscalls2 Plugin (C)\nDESCRIPTION: These snippets define function pointer types (typedefs) for various system call callback scenarios in PANDA's syscalls2 plugin. Each typedef specifies the function signature for callbacks triggered when specific or any system call is entered or returned from, with parameters offering CPU state, program counter, and syscall-specific info. Dependencies include PANDA instrumented QEMU headers and a compatible syscall2 profile. These typedefs are the key integration points for monitoring system calls and serve as the contract for any plugin registering a callback; incorrect signatures and missing prerequisites can lead to improper callback registration.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_unknown_sys_enter_t)(CPUState *env, target_ulong pc, target_ulong callno)\n```\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_unknown_sys_return_t)(CPUState *env, target_ulong pc, target_ulong callno)\n```\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_all_sys_enter_t)(CPUState *env, target_ulong pc, target_ulong callno)\n```\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_all_sys_return_t)(CPUState *env, target_ulong pc, target_ulong callno)\n```\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_all_sys_enter2_t)(CPUState *cpu, target_ulong pc, const syscall_info_t *call, const syscall_ctx_t *rp)\n```\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_all_sys_return2_t)(CPUState *cpu, target_ulong pc, const syscall_info_t *call, const syscall_ctx_t *rp)\n```\n\n----------------------------------------\n\nTITLE: Loading ELF File for CPU Boot with QEMU Loader\nDESCRIPTION: This example demonstrates how to load an ELF file that CPU0 will boot from using the QEMU loader device.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/generic-loader.txt#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n-device loader,file=./images/boot.elf,cpu-num=0\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing Guest Virtual Memory in C\nDESCRIPTION: This function allows access to the guest's virtual memory space, providing translation via current page tables from virtual to physical addresses. It takes the CPU state pointer (env), a virtual address (addr), buffer (buf), length (len), and an is_write flag. Like the physical version, it returns 0 on success and supports synchronized read/write operations only to mapped RAM.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nint panda_virtual_memory_rw(CPUState *env, target_ulong addr, uint8_t *buf, int len, int is_write);\n```\n\n----------------------------------------\n\nTITLE: Counting Basic Blocks with Web Server Integration in PANDA PyPlugin (Python)\nDESCRIPTION: Implements a PyPlugin that counts the number of executed basic blocks using a callback and exposes this count on a simple webserver endpoint. Requires pandare's PyPlugin infrastructure and a web server framework (likely Flask). The plugin increments a counter per block execution, and the webserver_init method registers a route at the root path to display the count in an HTML page. Inputs: PANDA callbacks, Flask-like app object; Output: HTML page with count.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/pyplugins.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pandare import PyPlugin\n\nclass BasicBlockCount(PyPlugin):\n    def __init__(self, panda):\n        self.bb_count = 0\n\n        @panda.cb_before_block_exec\n        def my_before_block_fn(_cpu, _trans):\n            self.bb_count += 1\n\n    def webserver_init(self, app):\n        @app.route(\"/\")\n        def test_index():\n            return \"\"\"<html>\n            <body>\n                <p>\n                    Basic Block Count: <span id=\\\"bb_count\\\">\"\"\" + str(self.bb_count) +  \"\"\"</span>\n                </p>\n            </body>\n            </html>\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Applying Weak Atomic Access and Manual Memory Barriers in QEMU (C)\nDESCRIPTION: This snippet documents the use of atomic_read, atomic_set, and several macros for manually enforcing ordering between reads and writes, providing weak atomicity guarantees for advanced synchronization needs in QEMU. Along with atomic_read() and atomic_set() to signal shared variables, macros like smp_rmb(), smp_wmb(), smp_mb(), smp_mb_acquire(), smp_mb_release(), and smp_read_barrier_depends() ensure the required ordering among memory accesses. These APIs depend on qemu/atomic.h and correct placement between loads and stores to provide the desired visibility and ordering semantics, and are only safe for int-width or smaller types.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/atomics.txt#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\natomic_read()\natomic_set()\nsmp_rmb()\nsmp_wmb()\nsmp_mb()\nsmp_mb_acquire()\nsmp_mb_release()\nsmp_read_barrier_depends()\n```\n\n----------------------------------------\n\nTITLE: Implementing Syscall Logger Plugin for PANDA (C)\nDESCRIPTION: This C file implements a PANDA plugin that monitors and logs x86 system call (sysenter) executions. It defines and registers instruction translation and execution callbacks that specifically detect the sysenter opcode and log the system call number from the EAX register to an output file. Required dependencies include PANDA and QEMU headers, and x86 support. The init_plugin function must succeed in opening 'syscalls.txt'; otherwise, the plugin will not load. The plugin only activates on x86 architectures and properly handles resource cleanup in its uninit_plugin callback.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/case_study_syscallmon.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n#include \"config.h\"\\n#include \"qemu-common.h\"\\n#include \"cpu.h\"\\n\\n#include \"panda_plugin.h\"\\n\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nbool translate_callback(CPUState *env, target_ulong pc);\\nint exec_callback(CPUState *env, target_ulong pc);\\n\\nbool init_plugin(void *);\\nvoid uninit_plugin(void *);\\n\\n// This is where we\\'ll write out the syscall data\\nFILE *plugin_log;\\n\\n// Check if the instruction is sysenter (0F 34)\\nbool translate_callback(CPUState *env, target_ulong pc) {\\n    unsigned char buf[2];\\n    cpu_memory_rw_debug(env, pc, buf, 2, 0);\\n    if (buf[0] == 0x0F && buf[1] == 0x34)\\n        return true;\\n    else\\n        return false;\\n}\\n\\n// This will only be called for instructions where the\\n// translate_callback returned true\\nint exec_callback(CPUState *env, target_ulong pc) {\\n#ifdef TARGET_I386\\n    // On Windows and Linux, the system call id is in EAX\\n    fprintf(plugin_log,\\n    \\t\\\"PC=\\\" TARGET_FMT_lx \\\", SYSCALL=\\\" TARGET_FMT_lx \\\"\\\\n\\\",\\n    \\tpc, env->regs[R_EAX]);\\n#endif\\n    return 0;\\n}\\n\\nbool init_plugin(void *self) {\\n// Don\\'t bother if we\\'re not on x86\\n#ifdef TARGET_I386\\n    panda_cb pcb;\\n\\n    pcb.insn_translate = translate_callback;\\n    panda_register_callback(self, PANDA_CB_INSN_TRANSLATE, pcb);\\n    pcb.insn_exec = exec_callback;\\n    panda_register_callback(self, PANDA_CB_INSN_EXEC, pcb);\\n#endif\\n\\n    plugin_log = fopen(\"syscalls.txt\", \"w\");\\n    if(!plugin_log) return false;\\n    else return true;\\n}\\n\\nvoid uninit_plugin(void *self) {\\n    fclose(plugin_log);\\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring NT System Call Function Prototypes in C\nDESCRIPTION: This snippet enumerates C function prototypes for NT system calls from the Windows Native API. It requires knowledge of the relevant NT types and structures; inclusion of system headers (like Windows.h, winternl.h) is a prerequisite. Each function expects arguments strongly typed to NT kernel data structures or handles, and returns NTSTATUS (or BOOLEAN), indicating success or detailed errors. The prototypes serve as declarations only and do not implement functionality; they are intended to be implemented by the Windows kernel and called directly or via dynamic invocation by advanced software. Inputs are strictly specified to correspond to the internal workings of the Windows NT subsystem, with no user-level abstractions. Outputs via out-parameters receive data as returned by the kernel. These calls are only valid in privileged contexts (e.g., drivers, system utilities) and require administrative or kernel access.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_xpsp3_x86_prototypes.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeleteAtom (RTL_ATOM Atom);\nNTSTATUS NtDeleteBootEntry (ULONG Id);\nNTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtDeleteKey (HANDLE KeyHandle);\nNTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);\nNTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtDisplayString (PUNICODE_STRING String);\nNTSTATUS NtDuplicateObject (HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);\nNTSTATUS NtDuplicateToken (HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);\nNTSTATUS NtEnumerateBootEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateKey (HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtEnumerateSystemEnvironmentValuesEx (ULONG InformationClass, PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateValueKey (HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);\nNTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);\nNTSTATUS NtFindAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\nNTSTATUS NtFlushBuffersFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);\nNTSTATUS NtFlushKey (HANDLE KeyHandle);\nNTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);\nNTSTATUS NtFlushWriteBuffer ();\nNTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG FreeType);\nNTSTATUS NtFsControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nNTSTATUS NtGetDevicePowerState (HANDLE Device, DEVICE_POWER_STATE *State);\nNTSTATUS NtGetPlugPlayEvent (HANDLE EventHandle, PVOID Context, PPLUGPLAY_EVENT_BLOCK EventBlock, ULONG EventBufferSize);\nNTSTATUS NtGetWriteWatch (HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, SIZE_T RegionSize, PVOID *UserAddressArray, PULONG_PTR EntriesInUserAddressArray, PULONG Granularity);\nNTSTATUS NtImpersonateAnonymousToken (HANDLE ThreadHandle);\nNTSTATUS NtImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE Message);\nNTSTATUS NtImpersonateThread (HANDLE ServerThreadHandle, HANDLE ClientThreadHandle, PSECURITY_QUALITY_OF_SERVICE SecurityQos);\nNTSTATUS NtInitializeRegistry (USHORT BootCondition);\nNTSTATUS NtInitiatePowerAction (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);\nNTSTATUS NtIsProcessInJob (HANDLE ProcessHandle, HANDLE JobHandle);\nBOOLEAN NtIsSystemResumeAutomatic ();\nNTSTATUS NtListenPort (HANDLE PortHandle, PPORT_MESSAGE ConnectionRequest);\nNTSTATUS NtLoadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtLoadKey (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile);\nNTSTATUS NtLoadKey2 (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags);\nNTSTATUS NtLockFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);\nNTSTATUS NtLockProductActivationKeys (ULONG *pPrivateVer, ULONG *pSafeMode);\nNTSTATUS NtLockRegistryKey (HANDLE KeyHandle);\nNTSTATUS NtLockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtMakePermanentObject (HANDLE Handle);\nNTSTATUS NtMakeTemporaryObject (HANDLE Handle);\nNTSTATUS NtMapUserPhysicalPages (PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, WIN32_PROTECTION_MASK Win32Protect);\nNTSTATUS NtModifyBootEntry (PBOOT_ENTRY BootEntry);\nNTSTATUS NtNotifyChangeDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree);\nNTSTATUS NtNotifyChangeKey (HANDLE KeyHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtNotifyChangeMultipleKeys (HANDLE MasterKeyHandle, ULONG Count, OBJECT_ATTRIBUTES SlaveObjects[], HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtOpenDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);\nNTSTATUS NtOpenIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, ACCESS_MASK GrantedAccess, PPRIVILEGE_SET Privileges, BOOLEAN ObjectCreation, BOOLEAN AccessGranted, PBOOLEAN GenerateOnClose);\nNTSTATUS NtOpenProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenProcessToken (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);\nNTSTATUS NtOpenProcessTokenEx (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenThreadToken (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);\nNTSTATUS NtOpenThreadTokenEx (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtPlugPlayControl (PLUGPLAY_CONTROL_CLASS PnPControlClass, PVOID PnPControlData, ULONG PnPControlDataLength);\nNTSTATUS NtPowerInformation (POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtPrivilegeCheck (HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, PBOOLEAN Result);\nNTSTATUS NtPrivilegeObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\nNTSTATUS NtPrivilegedServiceAuditAlarm (PUNICODE_STRING SubsystemName, PUNICODE_STRING ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\nNTSTATUS NtProtectVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, WIN32_PROTECTION_MASK NewProtectWin32, PULONG OldProtect);\nNTSTATUS NtPulseEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtQueryAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);\nNTSTATUS NtQueryBootEntryOrder (PULONG Ids, PULONG Count);\nNTSTATUS NtQueryBootOptions (PBOOT_OPTIONS BootOptions, PULONG BootOptionsLength);\n```\n\n----------------------------------------\n\nTITLE: Running osi_linux with a Live DVD and OSI Test (Bash Execution Command)\nDESCRIPTION: This command example shows how to replay a recording of a Linux guest with specific memory, plugin, and configuration parameters for use with osi_linux on Ubuntu. It passes the kconf_group for the selected kernel, the OS type, and invokes the osi_test plugin, redirecting output to ositest.txt for analysis. All referenced binaries and configuration files must be present and accessible to the emulator.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi_linux/README.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 \\\n-m 4096 -replay foo -panda osi\\\n-panda osi_linux:kconf_group=ubuntu:5.3.0-28-generic:64 \\\n-os linux-64-ubuntu -panda osi_test > ositest.txt\n\n```\n\n----------------------------------------\n\nTITLE: Process Management System Call Prototypes in C\nDESCRIPTION: Function prototypes for Linux system calls related to process management, signals, and IPC mechanisms. These functions handle process creation, termination, and interprocess communication.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nlong sys_rt_sigaction(int, const struct sigaction __user *, struct sigaction __user *, size_t);\nlong sys_rt_sigprocmask(int how, sigset_t __user *set, sigset_t __user *oset, size_t sigsetsize);\nlong sys_unshare(unsigned long unshare_flags);\nlong sys_set_robust_list(struct robust_list_head __user *head, size_t len);\nlong sys_get_robust_list(int pid, struct robust_list_head __user * __user *head_ptr, size_t __user *len_ptr);\nlong sys_getcpu(unsigned __user *cpu, unsigned __user *node, struct getcpu_cache __user *cache);\nlong sys_clone3(struct clone_args __user *uargs, size_t size);\nlong sys_pidfd_open(pid_t pid, unsigned int flags);\nlong sys_pidfd_getfd(int pidfd, int fd, unsigned int flags);\nlong sys_pidfd_send_signal(int pidfd, int sig, siginfo_t __user *info, unsigned int flags);\n```\n\n----------------------------------------\n\nTITLE: Declaring Instruction Translation Callback Signature in PANDA (C)\nDESCRIPTION: Specifies a plugin function pointer interface for hooking just before each guest instruction's translation, allowing selective instruction instrumentation with a boolean return. Relies on PANDA types for CPU state and program counter. The returned boolean enables or disables subsequent instruction execution callbacks in target code.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_35\n\nLANGUAGE: C\nCODE:\n```\nbool (*insn_translate)(CPUState *env, target_ulong pc);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows Nt* Native API Function Prototypes in C\nDESCRIPTION: This set of C declarations defines prototypes for Windows Native API functions beginning with 'Nt', which control low-level kernel operations such as memory protection, file and registry access, event handling, thread/process querying, and more. These functions require the inclusion of NT types and structures (e.g., HANDLE, NTSTATUS, OBJECT_ATTRIBUTES), and are typically used in privileged contexts like system utilities, debuggers, or drivers. Each prototype specifies input and output parametersâ€”handles, pointers, or structure referencesâ€”and expects callers to obey strict contract for memory, type safety, and synchronization; results are returned as NTSTATUS codes.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2003sp12_x86_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtProtectVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, WIN32_PROTECTION_MASK NewProtectWin32, PULONG OldProtect);\nNTSTATUS NtPulseEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtQueryAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);\nNTSTATUS NtQueryBootEntryOrder (PULONG Ids, PULONG Count);\nNTSTATUS NtQueryBootOptions (PBOOT_OPTIONS BootOptions, PULONG BootOptionsLength);\nNTSTATUS NtQueryDebugFilterState (ULONG ComponentId, ULONG Level);\nNTSTATUS NtQueryDefaultLocale (BOOLEAN UserProfile, PLCID DefaultLocaleId);\nNTSTATUS NtQueryDefaultUILanguage (LANGID *DefaultUILanguageId);\nNTSTATUS NtQueryDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);\nNTSTATUS NtQueryDirectoryObject (HANDLE DirectoryHandle, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, BOOLEAN RestartScan, PULONG Context, PULONG ReturnLength);\nNTSTATUS NtQueryDriverEntryOrder (PULONG Ids, PULONG Count);\nNTSTATUS NtQueryEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan);\nNTSTATUS NtQueryEvent (HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryFullAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);\nNTSTATUS NtQueryInformationAtom (RTL_ATOM Atom, ATOM_INFORMATION_CLASS InformationClass, PVOID AtomInformation, ULONG AtomInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\nNTSTATUS NtQueryInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationPort (HANDLE PortHandle, PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtQueryInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInstallUILanguage (LANGID *InstallUILanguageId);\nNTSTATUS NtQueryIntervalProfile (KPROFILE_SOURCE ProfileSource, PULONG Interval);\nNTSTATUS NtQueryIoCompletion (HANDLE IoCompletionHandle, IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass, PVOID IoCompletionInformation, ULONG IoCompletionInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryKey (HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtQueryMultipleValueKey (HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength);\nNTSTATUS NtQueryMutant (HANDLE MutantHandle, MUTANT_INFORMATION_CLASS MutantInformationClass, PVOID MutantInformation, ULONG MutantInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryOpenSubKeys (POBJECT_ATTRIBUTES TargetKey, PULONG HandleCount);\nNTSTATUS NtQueryOpenSubKeysEx (POBJECT_ATTRIBUTES TargetKey, ULONG BufferLength, PVOID Buffer, PULONG RequiredSize);\nNTSTATUS NtQueryPerformanceCounter (PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);\nNTSTATUS NtQueryQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID SidList, ULONG SidListLength, PULONG StartSid, BOOLEAN RestartScan);\nNTSTATUS NtQuerySection (HANDLE SectionHandle, SECTION_INFORMATION_CLASS SectionInformationClass, PVOID SectionInformation, SIZE_T SectionInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtQuerySecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Length, PULONG LengthNeeded);\nNTSTATUS NtQuerySemaphore (HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG SemaphoreInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySymbolicLinkObject (HANDLE LinkHandle, PUNICODE_STRING LinkTarget, PULONG ReturnedLength);\nNTSTATUS NtQuerySystemEnvironmentValue (PUNICODE_STRING VariableName, PWSTR VariableValue, USHORT ValueLength, PUSHORT ReturnLength);\nNTSTATUS NtQuerySystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, PULONG ValueLength, PULONG Attributes);\nNTSTATUS NtQuerySystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySystemTime (PLARGE_INTEGER SystemTime);\nNTSTATUS NtQueryTimer (HANDLE TimerHandle, TIMER_INFORMATION_CLASS TimerInformationClass, PVOID TimerInformation, ULONG TimerInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryTimerResolution (PULONG MaximumTime, PULONG MinimumTime, PULONG CurrentTime);\nNTSTATUS NtQueryValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtQueryVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtQueryVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtQueueApcThread (HANDLE ThreadHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\nNTSTATUS NtRaiseException (PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ContextRecord, BOOLEAN FirstChance);\nNTSTATUS NtRaiseHardError (NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask, PULONG_PTR Parameters, ULONG ValidResponseOptions, PULONG Response);\nNTSTATUS NtReadFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtReadFileScatter (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtReadRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtReadVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtRegisterThreadTerminatePort (HANDLE PortHandle);\nNTSTATUS NtReleaseMutant (HANDLE MutantHandle, PLONG PreviousCount);\nNTSTATUS NtReleaseSemaphore (HANDLE SemaphoreHandle, LONG ReleaseCount, PLONG PreviousCount);\nNTSTATUS NtRemoveIoCompletion (HANDLE IoCompletionHandle, PVOID *KeyContext, PVOID *ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER Timeout);\nNTSTATUS NtRemoveProcessDebug (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtRenameKey (HANDLE KeyHandle, PUNICODE_STRING NewName);\nNTSTATUS NtReplaceKey (POBJECT_ATTRIBUTES NewFile, HANDLE TargetHandle, POBJECT_ATTRIBUTES OldFile);\nNTSTATUS NtReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtReplyWaitReceivePort (HANDLE PortHandle, PVOID *PortContext , PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage);\nNTSTATUS NtReplyWaitReceivePortEx (HANDLE PortHandle, PVOID *PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage, PLARGE_INTEGER Timeout);\nNTSTATUS NtReplyWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtRequestPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage);\nNTSTATUS NtRequestWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtResetEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtResetWriteWatch (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T RegionSize);\nNTSTATUS NtRestoreKey (HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags);\nNTSTATUS NtResumeProcess (HANDLE ProcessHandle);\nNTSTATUS NtResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtSaveKey (HANDLE KeyHandle, HANDLE FileHandle);\nNTSTATUS NtSaveKeyEx (HANDLE KeyHandle, HANDLE FileHandle, ULONG Format);\nNTSTATUS NtSaveMergedKeys (HANDLE HighPrecedenceKeyHandle, HANDLE LowPrecedenceKeyHandle, HANDLE FileHandle);\nNTSTATUS NtSecureConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PSID RequiredServerSid, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\n```\n\n----------------------------------------\n\nTITLE: Logging Struct Argument Syscall Parameters with DWARF - PANDALOG Output - JSON\nDESCRIPTION: This snippet demonstrates an enhanced PANDALOG entry output in JSON format from the syscall_logger plugin, where the plugin leverages a supplied DWARF JSON file to decode structure members for a syscall argument (sys_newuname). The argument struct ('new_utsname') is fully traversed and all string fields are recorded. Fields such as structType and structData facilitate detailed introspection. Usage requires the plugin be supplied a valid DWARF info JSON at runtime (see 'dwarf_json' argument). The output includes all primitive and nested members, recursively resolved. Limitations: not all kernel structures may be supported due to incomplete DWARF, and bitfields, unions, enums, and 2D arrays are not handled.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls_logger/README.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"pc\": \"1995861912\",\n  \"instr\": \"0\",\n  \"asid\": \"4294967295\",\n  \"syscall\": {\n    \"pid\": 1,\n    \"ppid\": 0,\n    \"tid\": 1,\n    \"createTime\": \"190000000\",\n    \"retcode\": \"0\",\n    \"callName\": \"sys_newuname\",\n    \"args\": [\n      {\n        \"argName\": \"name\",\n        \"structType\": \"new_utsname\",\n        \"structData\": {\n          \"members\": [\n            {\n              \"argName\": \"sysname\",\n              \"str\": \"Linux\"\n            },\n            {\n              \"argName\": \"nodename\",\n              \"str\": \"(none)\"\n            },\n            {\n              \"argName\": \"release\",\n              \"str\": \"4.4.138\"\n            },\n            {\n              \"argName\": \"version\",\n              \"str\": \"#1 SMP Wed Nov 4 23:03:38 EST 2020\"\n            },\n            {\n              \"argName\": \"machine\",\n              \"str\": \"armv7l\"\n            },\n            {\n              \"argName\": \"domainname\",\n              \"str\": \"(none)\"\n            }\n          ]\n        }\n      }\n    ]\n  }\n},\n```\n\n----------------------------------------\n\nTITLE: Disabling ASLR for Linux User Mode Programs (Shell Command)\nDESCRIPTION: This command disables Address Space Layout Randomization (ASLR) in Linux user mode by writing '0' to /proc/sys/kernel/randomize_va_space using sudo. This is required to ensure deterministic memory layouts for PANDA recordings, which is necessary for reproducible introspection by the osi_linux plugin.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi_linux/README.md#_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\necho 0 | sudo tee /proc/sys/kernel/randomize_va_space\n```\n\n----------------------------------------\n\nTITLE: Controlling Memory Access Callbacks in C\nDESCRIPTION: These two functions enable or disable PANDA's memory read/write callbacks, which trace memory accesses in the guest VM. Memory callbacks are off by default due to their performance overhead and should be enabled only when needed by the plugin for instrumentation or analysis. No parameters are required and usage impacts global memory tracing behavior.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nvoid panda_enable_memcb(void);\n```\n\nLANGUAGE: C\nCODE:\n```\nvoid panda_disable_memcb(void);\n```\n\n----------------------------------------\n\nTITLE: Asynchronous I/O Operations in C\nDESCRIPTION: Function declarations for asynchronous I/O operations including writing, listing, and result handling. These functions allow for non-blocking file operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nint aio_write(struct aiocb *aiocbp);\nint lio_listio(int mode, struct aiocb * const *acb_list, int nent, struct sigevent *sig);\n```\n\n----------------------------------------\n\nTITLE: Declaring pri Plugin API Functions for Debug Info Introspection - C\nDESCRIPTION: This C code snippet defines the core pri API functions: they expose source location and symbol info lookups, and provide iteration over live variables via callback. Functions consume CPU state, program counter, and user-provided callbacks, and some may return string or struct data (not to be freed by the caller). These APIs must be called from a PANDA plugin with pri and a suitable symbol provider loaded. Key parameters are CPU state, address information, and callback functions for variables. Results are primarily delivered via callbacks or structure outputs.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/pri/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n// get source info for a pc at current execution return -1 if in external libraries that do not have symbol information\nint pri_get_pc_source_info (CPUState *env, target_ulong pc, PC_Info *info);\n\n// get dwarf symbol info for a Virtual Memory Address while execution is at pc. Return `NULL` if external libraries that do not have symbol information\n// do not free string returned from function\nchar *pri_get_vma_symbol (CPUState *env, target_ulong pc, target_ulong vma);\n\n// iterate through the live vars at the current state of execution\nvoid pri_all_livevar_iter (CPUState *env, target_ulong pc, void (*f)(void *var_ty, const char *var_nm, LocType loc_t,     target_ulong loc));\n\n// iterate through the function vars at the current state of execution\nvoid pri_funct_livevar_iter (CPUState *env, target_ulong pc, void (*f)(void *var_ty, const char *var_nm, LocType loc_t, target_ulong loc));\n\n// iterate through the global vars at the current state of execution\nvoid pri_global_livevar_iter (CPUState *env, target_ulong pc, void (*f)(void *var_ty, const char *var_nm, LocType loc_t, target_ulong loc));\n\n```\n\n----------------------------------------\n\nTITLE: Declaring Get Heap Mappings Callback Typedef in C\nDESCRIPTION: Declares a callback for returning only mappings corresponding to process heap segments. Implemented only by certain providers (osi_linux). Accepts CPUState, target OsiProc pointer, and GArray** output to produce OsiModule entries for heap regions. Results freed with g_array_free.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_13\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_get_heap_mappings_t)(CPUState *, OsiProc *, GArray**)\n```\n\n----------------------------------------\n\nTITLE: Implementing PPP-style Callbacks in PANDA PyPlugin (Python)\nDESCRIPTION: Defines two PyPlugins demonstrating the PPP-style callback API: Server declares a callback ('some_f') triggered on the next block execution, and Consumer registers a local function to this callback and calls an exported function on the Server. Requires PyPlugin, two plugin classes, and the PANDA infrastructure for plugin management and callback invocation. Shows multi-plugin coordination and callback argument passing.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/pyplugins.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass Server(PyPlugin):\n    '''\n    PyPlugin which provides a PPP-style callback: `some_f` which is run once at the next BBE callback.\n    '''\n    def __init__(self, panda):\n        self.ppp_cb_boilerplate('some_f') # Inform the world that Server.some_f is a PPP callback\n\n        @panda.cb_before_block_exec\n        def server_bbe(cpu, tb):\n            print(\"Server is running all registered `some_f` callbacks\")\n\n            self.ppp_run_cb('some_f', panda.current_pc(cpu)) # Run cbs registered to run with Server.some_f: args are current_pc\n\n            panda.disable_callback('server_bbe')\n\nclass Consumer(PyPlugin):\n    '''\n    PyPlugin which defines a function to run when Server's `some_f` callback is triggered\n    '''\n    def __init__(self, panda):\n        self.ppp.Server.ppp_reg_cb('some_f', self.my_f)\n        print(f\"Calling Server's do_add(1): \", self.ppp.Server.do_add(1))\n\n    def my_f(self, arg):\n        print(\"Consumer my_f runs with arg:\", hex(arg))\n```\n\n----------------------------------------\n\nTITLE: Taint2 Core API Functions\nDESCRIPTION: Core API functions for enabling taint tracking, labeling memory/registers, and querying taint status. Includes functions for managing taint labels on RAM, IO addresses, and registers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/taint2/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid taint2_enable_taint(void);\nint taint2_enabled(void);\nvoid taint2_label_ram(uint64_t pa, uint32_t l);\nvoid taint2_label_ram_additive(uint64_t pa, uint32_t l);\nvoid taint2_label_reg_additive(int reg_num, int offset, uint32_t l);\nvoid taint2_label_io(uint64_t ia, uint32_t l);\nvoid taint2_label_io_additive(uint64_t ia, uint32_t l);\n```\n\n----------------------------------------\n\nTITLE: Implementing QMP Command with Optional Argument (QAPI, C)\nDESCRIPTION: This C snippet implements the 'hello-world' QMP command supporting an optional 'message' argument. The 'has_message' boolean indicates if the argument was provided. The function prints the 'message' if present, or falls back to a default string if omitted. The function parameters must follow the ordering from the QAPI schema.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/writing-qmp-commands.txt#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nvoid qmp_hello_world(bool has_message, const char *message, Error **errp)\n{\n    if (has_message) {\n        printf(\"%s\\n\", message);\n    } else {\n        printf(\"Hello, world\\n\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running a PANDA Replay in PyPANDA with Python\nDESCRIPTION: This minimal example demonstrates analyzing an existing PANDA recording (replay) by initializing Panda and calling panda.run_replay(). All necessary callback registration is done before running. Requires a previously taken replay file; Input: path to replay; Output: execution of guest trace, triggering registered callbacks as with live analysis.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/docs/USAGE.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npanda = Panda(...)\n# Register functions to run on callbacks here\npanda.run_replay(\"/file/path/here\") # Runs the replay\n```\n\n----------------------------------------\n\nTITLE: Querying Call Stack Entries Using callstack_instr Plugin API in C\nDESCRIPTION: This snippet provides API functions for querying current call stack information from the callstack_instr PANDA plugin. Functions allow the caller to retrieve up to 'n' most recent callers or functions from the emulated CPU state, populating user-provided arrays with these addresses. Another function retrieves the current program point structure. Caller must ensure proper array sizing; the functions return the number of entries actually retrieved. Intended for use by PANDA plugins querying guest control flow state. Requires inclusion of PANDA types and plugin headers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/callstack_instr/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n// Get up to n callers from the given stack in use at this moment\n// Callers are returned in callers[], most recent first\n// Return value is the number of callers actually retrieved\nuint32_t get_callers(target_ulong *callers, uint32_t n, CPUState *env);\n\n// Get up to n functions from the given stack in use at this moment\n// Functions are returned in functions[], most recent first\n// Return value is the number of callers actually retrieved\nuint32_t get_functions(target_ulong *functions, uint32_t n, CPUState *env);\n\n// Get the current program point: (Caller, PC, stack ID)\n// This isn't quite the right place for it, but since it's awkward\n// right now to have a \"utilities\" library, this will have to do\nvoid get_prog_point(CPUState *env, prog_point *p);\n```\n\n----------------------------------------\n\nTITLE: Unparenting and Cleaning Up QEMU Memory Regions in C\nDESCRIPTION: Shows how to explicitly destroy MemoryRegion objects by calling object_unparent() on a memory region, which is required for dynamically allocated regions (such as alias or container types) to ensure memory/resource cleanup in custom data structures. Must be used within the instance_finalize callback of the owning object except for the documented exceptions (alias/container). Relies on QEMU object and memory subsystem headers for the region and owner object definitions. Input is a valid pointer to a MemoryRegion; output is the region and its resources being unmapped and deallocated. Improper destruction (outside allowed lifecycles or on in-use regions) may result in reference leaks or double-frees.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/memory.txt#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n/* Destroy a memory region when it is no longer needed */\\nobject_unparent(&region_obj);\n```\n\n----------------------------------------\n\nTITLE: Loading a Plugin at Runtime in PANDA using C\nDESCRIPTION: This function loads a dynamic plugin library at runtime into the PANDA environment, given its filename. Returns a boolean indicating success. It allows dynamic module composition and loading. The filename is provided as a plain string; no searching or path resolution is handled. Integration with PANDA/QEMU is required.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_15\n\nLANGUAGE: C\nCODE:\n```\nbool   panda_load_plugin(const char *filename);\n```\n\n----------------------------------------\n\nTITLE: Implementing QMP Command Without Return Data (QAPI, C)\nDESCRIPTION: This C function implements the 'hello-world' QMP command with no arguments or return value. The function prints the phrase 'Hello, world!' to stdout. In QEMU, QMP command handlers follow a naming convention (qmp_ prefix) and accept an 'Error **errp' parameter for error reporting, which is unused here.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/writing-qmp-commands.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nvoid qmp_hello_world(Error **errp)\n{\n    printf(\"Hello, world!\\n\");\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Task Change Callback Typedef in C\nDESCRIPTION: Defines a typedef for a plugin callback named on_task_change_t, which receives a pointer to a CPUState structure. This callback is used to notify a plugin when the active task (process or thread) changes in the guest OS. The callback relies on the CPUState type, and is registered by plugins that need to react to task switches. No return value is expected; only one input parameter is provided.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_task_change_t)(CPUState *)\n```\n\n----------------------------------------\n\nTITLE: Running PANDA with file_taint Plugin\nDESCRIPTION: This command demonstrates how to run PANDA with the file_taint plugin to taint a file named 'foo.txt'. It includes necessary dependencies like osi and syscalls2.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/file_taint/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/i386-softmmu/panda-system-i386 -replay foo -panda osi \\\n    -panda osi_linux:kconf_group=debian-3.2.63-i686 \\\n    -panda syscalls2:profile=linux_x86 -panda file_taint:filename=foo.txt\n```\n\n----------------------------------------\n\nTITLE: Declaring System Call Prototypes for Windows NTAPI in C\nDESCRIPTION: This code snippet consists of a sequential set of C function prototypes representing internal Windows NT API (Nt*) system calls. These declarations enable direct invocation of kernel routines for querying, opening, and manipulating various system resources, processes, files, and objects. The functions return NTSTATUS codes and require specific structured arguments, reflecting close adherence to native Windows conventions and dependencies on numerous custom types (e.g., HANDLE, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK). To use these APIs, the caller must include proper headers and link to system libraries or use dynamic resolution. No business logic or implementations are provided, and usage is subject to Windows privilege and security constraints.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x86_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationPort (HANDLE PortHandle, PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtQueryInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\nNTSTATUS NtQueryInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationAtom (RTL_ATOM Atom, ATOM_INFORMATION_CLASS InformationClass, PVOID AtomInformation, ULONG AtomInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryFullAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);\nNTSTATUS NtQueryEvent (HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan);\nNTSTATUS NtQueryDriverEntryOrder (PULONG Ids, PULONG Count);\nNTSTATUS NtQueryDirectoryObject (HANDLE DirectoryHandle, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, BOOLEAN RestartScan, PULONG Context, PULONG ReturnLength);\nNTSTATUS NtQueryDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);\nNTSTATUS NtQueryDefaultUILanguage (LANGID *DefaultUILanguageId);\nNTSTATUS NtQueryDefaultLocale (BOOLEAN UserProfile, PLCID DefaultLocaleId);\nNTSTATUS NtQueryDebugFilterState (ULONG ComponentId, ULONG Level);\nNTSTATUS NtQueryBootOptions (PBOOT_OPTIONS BootOptions, PULONG BootOptionsLength);\nNTSTATUS NtQueryBootEntryOrder (PULONG Ids, PULONG Count);\nNTSTATUS NtQueryAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);\nNTSTATUS NtPulseEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtProtectVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, WIN32_PROTECTION_MASK NewProtectWin32, PULONG OldProtect);\nNTSTATUS NtPropagationFailed (HANDLE ResourceManagerHandle, ULONG RequestCookie, NTSTATUS PropStatus);\nNTSTATUS NtPropagationComplete (HANDLE ResourceManagerHandle, ULONG RequestCookie, ULONG BufferLength, PVOID Buffer);\nNTSTATUS NtPrivilegeObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\nNTSTATUS NtPrivilegedServiceAuditAlarm (PUNICODE_STRING SubsystemName, PUNICODE_STRING ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\nNTSTATUS NtPrivilegeCheck (HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, PBOOLEAN Result);\nNTSTATUS NtPrePrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrePrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPowerInformation (POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtPlugPlayControl (PLUGPLAY_CONTROL_CLASS PnPControlClass, PVOID PnPControlData, ULONG PnPControlDataLength);\nNTSTATUS NtOpenTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, LPGUID TmIdentity, ULONG OpenOptions);\nNTSTATUS NtOpenTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle);\nNTSTATUS NtOpenTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenThreadTokenEx (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenThreadToken (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);\nNTSTATUS NtOpenThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSession (PHANDLE SessionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID ResourceManagerGuid, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenProcessTokenEx (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenProcessToken (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);\nNTSTATUS NtOpenProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenPrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\nNTSTATUS NtOpenObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, ACCESS_MASK GrantedAccess, PPRIVILEGE_SET Privileges, BOOLEAN ObjectCreation, BOOLEAN AccessGranted, PBOOLEAN GenerateOnClose);\nNTSTATUS NtOpenMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKeyTransactedEx (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG OpenOptions, HANDLE TransactionHandle);\nNTSTATUS NtOpenKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE TransactionHandle);\nNTSTATUS NtOpenKeyEx (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG OpenOptions);\nNTSTATUS NtOpenKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);\nNTSTATUS NtOpenEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, LPGUID EnlistmentGuid, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtNotifyChangeSession (HANDLE Session, ULONG IoStateSequence, PVOID Reserved, ULONG Action, IO_SESSION_STATE IoState, IO_SESSION_STATE IoState2, PVOID Buffer, ULONG BufferSize);\nNTSTATUS NtNotifyChangeMultipleKeys (HANDLE MasterKeyHandle, ULONG Count, OBJECT_ATTRIBUTES SlaveObjects[], HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtNotifyChangeKey (HANDLE KeyHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtNotifyChangeDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree);\nNTSTATUS NtModifyDriverEntry (PEFI_DRIVER_ENTRY DriverEntry);\nNTSTATUS NtModifyBootEntry (PBOOT_ENTRY BootEntry);\nNTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, WIN32_PROTECTION_MASK Win32Protect);\n```\n\n----------------------------------------\n\nTITLE: Running PANDA with textprinter Plugin - Shell\nDESCRIPTION: Demonstrates how to invoke the PANDA emulator with both the callstack_instr and textprinter plugins enabled, passing the required stack_type argument to ensure callstack data is collected in the same format as the tap_points.txt file. This command must be adapted for the actual PANDA_PATH and replay file, and requires prior setup of the tap_points.txt configuration file. The output of this execution will appear in two gzipped text log files capturing memory reads and writes.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/textprinter/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo \\\n    -panda callstack_instr,stack_type=threaded -panda textprinter\n```\n\n----------------------------------------\n\nTITLE: Defining Linux Kernel Structure Offsets (GLib key-value format)\nDESCRIPTION: These configuration snippets define offsets and versioning details for different Linux kernels using the GLib key-value file format, as expected by the `osi_linux` plugin. Each configuration section corresponds to a specific Linux kernel variant, declaring critical field offsets, addresses, and metadata required for guest introspection. Required by `osi_linux` for correct operation, the file should include at least one section matching the guest under introspection. Key parameters include structural offsets (e.g., task size, pid offset) and version identifiers. Values can be decimal or hexadecimal (comments as needed).\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi_linux/README.md#_snippet_0\n\nLANGUAGE: GLib key-value (INI)\nCODE:\n```\n[ubuntu:4.4.0-98-generic:32]\nname = 4.4.0-98-generic|#121-Ubuntu SMP Tue Oct 10 14:23:20 UTC 2017|i686\nversion.a = 4\nversion.b = 4\nversion.c = 90\ntask.init_addr = 3249445504\n#task.init_addr = 0xC1AE9A80\n#task.per_cpu_offset_0 = 0x34B42000\ntask.per_cpu_offset_0 = 884219904\n#task.current_task_addr = 0xC1C852A8\ntask.current_task_addr = 3251131048\ntask.size = 5824\ntask.tasks_offset = 624\ntask.pid_offset = 776\n\n```\n\nLANGUAGE: GLib key-value (INI)\nCODE:\n```\n[debian:4.9.0-6-686-pae:32]\nname = 4.9.0-6-686-pae|#1 SMP Debian 4.9.82-1+deb9u3 (2018-03-02)|i686\nversion.a = 4\nversion.b = 9\nversion.c = 88\ntask.init_addr = 3245807232\n#task.init_addr = 0xC1771680\n#task.per_cpu_offset_0 = 0x36127000\ntask.per_cpu_offset_0 = 907177984\n#task.current_task_addr = 0xC18C3208\ntask.current_task_addr = 3247190536\ntask.size = 5888\ntask.tasks_offset = 708\ntask.pid_offset = 864\n\n```\n\n----------------------------------------\n\nTITLE: Running PANDA with Lighthouse Coverage Plugin\nDESCRIPTION: Example command showing how to execute PANDA with the lighthouse_coverage plugin enabled, along with required OSI dependencies. The command specifies memory allocation, replay file, OS configuration, and necessary plugins.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/lighthouse_coverage/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ ./panda-system-x86_64 -m 4096 -replay theRecording -os linux-64-ubuntu -panda osi -panda osi_linux:kconf_group=ubuntu:5.3.0-28-generic:64 -panda lighthouse_coverage\n```\n\n----------------------------------------\n\nTITLE: Declaring Get Mappings Callback Typedef in C\nDESCRIPTION: Declares a callback typedef for returning the shared libraries or memory mappings loaded for a specific process. Inputs are CPUState, an OsiProc pointer for the target process, and a GArray** output which receives OsiModule entries describing those mappings. Must free results with g_array_free.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_11\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_get_mappings_t)(CPUState *, OsiProc *, GArray**)\n```\n\n----------------------------------------\n\nTITLE: Invoking PANDA with syscalls2 and Custom Plugin from Command Line (sh)\nDESCRIPTION: This shell command demonstrates how to launch PANDA's QEMU-based VM replay with the syscalls2 and a custom plugin enabled. It specifies the OS profile, replay file, and plugin arguments. The command must be run in an environment where PANDA is installed and built, and the specified replay/OS/plugin files are present. Key parameters include the path to PANDA's QEMU binary, the replay file, the OS profile, and the names of the enabled plugins. Success requires all plugins to be properly compiled and in the PANDA plugin path.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo \\\n    -os windows-32-7sp1 -panda syscalls2 -panda filereadmon\n```\n\n----------------------------------------\n\nTITLE: Plugin Argument Parsing Functions in PANDA using C\nDESCRIPTION: Lists all available argument parsing helpers for PANDA plugins, allowing typed retrieval of uint32, uint64, ulong, double, boolean, or string argument values from a panda_arg_list. Each function takes the argument list, argument name, and a default value. This enables robust and user-friendly argument parsing in plugin code.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_19\n\nLANGUAGE: C\nCODE:\n```\ntarget_ulong panda_parse_ulong(panda_arg_list *args, const char *argname, target_ulong defval);\nuint32_t panda_parse_uint32(panda_arg_list *args, const char *argname, uint32_t defval);\nuint64_t panda_parse_uint64(panda_arg_list *args, const char *argname, uint64_t defval);\ndouble panda_parse_double(panda_arg_list *args, const char *argname, double defval);\nbool panda_parse_bool(panda_arg_list *args, const char *argname);\nconst char *panda_parse_string(panda_arg_list *args, const char *argname, const char *defval);\n```\n\n----------------------------------------\n\nTITLE: Freeing an Object Safely Using qemu_lockcnt_lock and Count in C\nDESCRIPTION: This C snippet shows how to safely free a shared object and clear its pointer while ensuring no other operations are ongoing. It locks the QemuLockCnt object, checks the reference count with qemu_lockcnt_count, and only frees and sets to NULL if safe. Dependencies include the QemuLockCnt API, atomic RCU helpers, and GLib memory management.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/lockcnt.txt#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nqemu_lockcnt_lock(&xyz_lockcnt);\nif (!qemu_lockcnt_count(&xyz_lockcnt)) {\n    g_free(xyz);\n    xyz = NULL;\n}\nqemu_lockcnt_unlock(&xyz_lockcnt);\n```\n\n----------------------------------------\n\nTITLE: Running PANDA with serial_taint Plugin\nDESCRIPTION: This example demonstrates how to run PANDA with the serial_taint plugin enabled. It sets up a pipe for serial communication, replays a 'serialwrite' recording, and uses the stringsearch, tstringsearch, and serial_taint plugins to perform taint analysis on serial data containing 'hello world'.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/serial_taint/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npanda-system-i386 -m 2048 \\\n  -chardev pipe,id=com1,path=/tmp/com1 -device pci-serial,chardev=com1 \\\n  -replay serialwrite -panda stringsearch:str=\"hello world\" \\\n  -panda tstringsearch -panda serial_taint\n```\n\n----------------------------------------\n\nTITLE: Declaring Instruction Execution Callback Signature in PANDA (C)\nDESCRIPTION: Defines the type for functions called prior to the execution of instructions previously marked for instrumentation by insn_translate, providing a hook for fine-grained instruction-level monitoring. Inputs include CPU state and current PC; returns int (unused). Only blocks opted-in via insn_translate are instrumented, minimizing performance overhead.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_36\n\nLANGUAGE: C\nCODE:\n```\nint (*insn_exec)(CPUState *env, target_ulong pc);\n```\n\n----------------------------------------\n\nTITLE: Enabling or Disabling Precise Program Counter Tracking in C\nDESCRIPTION: These functions toggle the precision of the guest program counter in QEMU; enabling precise PC allows for accurate instrumentation and state representation which is essential for certain plugins. After enabling, the precise value is accessible via env->panda_guest_pc or the panda_current_pc helper. These are parameterless and should be used in concert with translation block flushing to synchronize state.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nvoid panda_enable_precise_pc(void);\n```\n\nLANGUAGE: C\nCODE:\n```\nvoid panda_disable_precise_pc(void);\n```\n\n----------------------------------------\n\nTITLE: Declaring New C Function Signature for PyPANDA (C)\nDESCRIPTION: This entry demonstrates how to declare a new function (panda_current_pc) in the panda_datatypes.h header. The C function is then discoverable by CFFI and exposed via the libpanda library for Python bindings. The signature must match PyPANDA and QEMU conventions, specifically referencing CPUState for CPU introspection.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/docs/extending_pypanda.md#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nint panda_current_pc(CPUState *cpu);\n```\n\n----------------------------------------\n\nTITLE: Defining Time and Security Management System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to timer creation, security token creation, and transaction management. These functions handle time-based operations and security context management.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_13\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);\nNTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);\nNTSTATUS NtCreateTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle, ULONG CreateOptions, ULONG IsolationLevel, ULONG IsolationFlags, PLARGE_INTEGER Timeout, PUNICODE_STRING Description);\nNTSTATUS NtCreateTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, ULONG CreateOptions, ULONG CommitStrength);\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Object Creation System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to creating resource managers, semaphores, symbolic links, and threads. These functions create synchronization and abstraction objects needed by applications.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_12\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID RmGuid, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, PUNICODE_STRING Description);\nNTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);\nNTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);\nNTSTATUS NtCreateThreadEx (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument, ULONG CreateFlags, ULONG_PTR ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, PPS_ATTRIBUTE_LIST AttributeList);\n```\n\n----------------------------------------\n\nTITLE: Defining Object Creation System Calls in Windows NT API (Debug to Job Objects)\nDESCRIPTION: Function declarations for Windows NT system calls related to creating various system objects like debug objects, directories, enlistments, event pairs, IO completions, and job objects. These functions create and initialize kernel-managed resources.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateDebugObject (PHANDLE DebugObjectHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\nNTSTATUS NtCreateDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, HANDLE TransactionHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, NOTIFICATION_MASK NotificationMask, PVOID EnlistmentKey);\nNTSTATUS NtCreateEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Count);\nNTSTATUS NtCreateJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateJobSet (ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);\n```\n\n----------------------------------------\n\nTITLE: Declaring a Callback for Starting Block Execution via TCG - C\nDESCRIPTION: Defines a function pointer start_block_exec used as a callback inserted into the TCG stream before code generation, similar to before_block_exec. Accepts a CPUState pointer and a TranslationBlock pointer, enabling low-level instrumentation of block execution in PANDA. No return value; depends on PANDA's CPUState and TranslationBlock definitions and is invoked as part of TCG translation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_60\n\nLANGUAGE: C\nCODE:\n```\nvoid (*start_block_exec)(CPUState *cpu, TranslationBlock* tb);\n```\n\n----------------------------------------\n\nTITLE: Running filereadmon plugin with Linux in PANDA\nDESCRIPTION: Example command for running the filereadmon plugin with a Linux 64-bit system in PANDA. This demonstrates usage with the required dependencies (osi and osi_linux) for Linux operating systems.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/filereadmon/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo \\\n-panda osi \\\n-panda osi_linux:kconf_group=ubuntu:5.3.0-28-generic:64 \\\n-os linux-64-ubuntu -panda filereadmon\n```\n\n----------------------------------------\n\nTITLE: Defining Memory and Registry Cache Management System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to cache flushing operations. These functions ensure data consistency by flushing various caches in the system.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_21\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);\nNTSTATUS NtFlushKey (HANDLE KeyHandle);\nVOID NtFlushProcessWriteBuffers ();\nNTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);\nNTSTATUS NtFlushWriteBuffer ();\n```\n\n----------------------------------------\n\nTITLE: Defining Hook Enable API in PANDA hooks2 Plugin\nDESCRIPTION: Defines the ENABLE_HOOKS2 function which activates a previously registered hook identified by its ID. This allows for dynamic enabling of hooks during runtime.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/hooks2/README.md#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nvoid ENABLE_HOOKS2(int id);\n```\n\n----------------------------------------\n\nTITLE: Windows NT Process and Thread Management Functions\nDESCRIPTION: System calls for process and thread enumeration, creation and management. These functions allow traversing processes and threads with specified access rights.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x64_prototypes.txt#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtGetNextProcess(HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewProcessHandle);\nNTSTATUS NtGetNextThread(HANDLE ProcessHandle, HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewThreadHandle);\nNTSTATUS NtOpenThread(PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\n```\n\n----------------------------------------\n\nTITLE: Blocking a Signal for a Named Process using PANDA Plugin in C\nDESCRIPTION: This C function blocks a specified UNIX signal for a specific process, identified by its name. The function requires the signal's integer number and a character pointer to the process name. It should be used in the context of PANDA analysis with the required plugins ('syscalls2', 'osi_linux', 'signal') loaded. The block applies only to processes whose name matches the provided proc_name argument.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/signal/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nvoid block_sig_by_proc(int32_t sig, char* proc_name);\n```\n\n----------------------------------------\n\nTITLE: Parsing Plugin Command-Line Arguments in PANDA using C\nDESCRIPTION: Demonstrates how a PANDA plugin retrieves and parses its specific command-line arguments at initialization. panda_get_args returns a list of arguments for the specified plugin name; panda_parse_uint32 and panda_parse_string extract argument values. The example assigns integer and string arguments ('foo', 'base') to corresponding C variables. panda_arg_list structure is memory-managed (see panda_free_args). Key for user-configurable plugin parameters.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_18\n\nLANGUAGE: C\nCODE:\n```\npanda_arg_list *args = panda_get_args(\"llvm_trace\");\nuint32_t foo = panda_parse_uint32(args, \"foo\", 0);\nchar *base = panda_parse_string(args, \"base\", NULL);\n```\n\n----------------------------------------\n\nTITLE: Configuring PXB Devices in QEMU Command-Line - Shell\nDESCRIPTION: This shell snippet demonstrates example command-line options for running QEMU with multiple PCI Expander Bridge (PXB) devices attached to different NUMA nodes. It illustrates memory backend setup for two NUMA nodes and how to instantiate three PXB bridges, each exposing additional devices (network adapters, hard drive) to the guest VM. Required dependencies include QEMU with PXB and NUMA support, and suitable disk image files. Key parameters include memory backends (\\\"-object memory-backend-ram\\\"), NUMA binding (\\\"-numa node\\\"), PXB bridge setup (\\\"-device pxb\\\"), and device attachments (e.g., \\\"e1000\\\", \\\"virtio-blk-pci\\\"). Inputs are standard QEMU arguments, and outputs are a guest VM with specified PXB topology. PXBs can only be placed under the root bus, and correct NUMA mapping and device IDs must be maintained.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/pci_expander_bridge.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n[qemu-bin + storage options]\n-m 2G\n-object memory-backend-ram,size=1024M,policy=bind,host-nodes=0,id=ram-node0 -numa node,nodeid=0,cpus=0,memdev=ram-node0\n-object memory-backend-ram,size=1024M,policy=bind,host-nodes=1,id=ram-node1 -numa node,nodeid=1,cpus=1,memdev=ram-node1\n-device pxb,id=bridge1,bus=pci.0,numa_node=1,bus_nr=4 -netdev user,id=nd -device e1000,bus=bridge1,addr=0x4,netdev=nd\n-device pxb,id=bridge2,bus=pci.0,numa_node=0,bus_nr=8 -device e1000,bus=bridge2,addr=0x3\n-device pxb,id=bridge3,bus=pci.0,bus_nr=40 -drive if=none,id=drive0,file=[img] -device virtio-blk-pci,drive=drive0,scsi=off,bus=bridge3,addr=1\n```\n\n----------------------------------------\n\nTITLE: Loop Barrier Hoisting with Atomic Sets - C\nDESCRIPTION: Illustrates how a full memory barrier between multiple atomic_mb_set() stores in a loop can be hoisted outside the loop for better performance. The code shows a loop using atomic_mb_set() (which provides a barrier per iteration) being transformed into a loop using atomic_set(), surrounded by a release barrier before and a full barrier after. Applicable when batch updates to arrays are safe and permissible. Depends on C or QEMU atomic and barrier primitives; respects ordering where prior stores must become visible at the correct time.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/atomics.txt#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nsmp_mb_release();\\nfor (i = 0; i < 10; i++)          =>    for (i = 0; i < 10; i++)\\n  atomic_mb_set(&a[i], false);            atomic_set(&a[i], false);\\n                                         smp_mb();\n```\n\n----------------------------------------\n\nTITLE: Declaring Notify Task Change API in C\nDESCRIPTION: Declares the notify_task_change API, which is to be called by OSI providers after switching the currently running thread or process in the guest OS. This triggers any registered task-change callbacks. No return value is produced; only the updated CPUState is required. This is the main entry point for notifying other plugins of OS task context switches.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_19\n\nLANGUAGE: C\nCODE:\n```\nvoid notify_task_change(CPUState *)\n```\n\n----------------------------------------\n\nTITLE: Declaring Get Current Process Callback Typedef in C\nDESCRIPTION: Introduces a typedef for a callback to get the currently running process in the guest OS. The function receives CPUState and must allocate and return an OsiProc pointer via an out-parameter. Memory for the returned object should be freed with free_osiproc. This enables fast retrieval of active process information for introspection tasks.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_get_current_process_t)(CPUState *, OsiProc **)\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API Synchronization Functions in C\nDESCRIPTION: Function declarations for Windows NT native API calls related to synchronization including event creation, timer management, and object waiting operations. These functions provide mechanisms for coordinating execution between threads and processes.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp0_x64_prototypes.txt#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);\nNTSTATUS NtQueryEvent (HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ReturnLength);\nNTSTATUS NtWaitForMultipleObjects (ULONG Count, HANDLE Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtCancelTimer (HANDLE TimerHandle, PBOOLEAN CurrentState);\nNTSTATUS NtSetTimer (HANDLE TimerHandle, PLARGE_INTEGER DueTime, PTIMER_APC_ROUTINE TimerApcRoutine, PVOID TimerContext, BOOLEAN WakeTimer, LONG Period, PBOOLEAN PreviousState);\n```\n\n----------------------------------------\n\nTITLE: Running PANDA with mmio_trace Plugin - Shell Command\nDESCRIPTION: This shell command invokes PANDA's ARM QEMU binary with the mmio_trace plugin and logs all MMIO accesses to a specified JSON file (mmio.json). The example shows required kernel, initrd, disk, and VM configuration parameters for testing Debian ARM images. The 'out_log' plugin argument is optional and can be used to direct the log output. Requires an installed PANDA/QEMU environment and relevant disk images and kernels.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/mmio_trace/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\narm-softmmu/panda-system-arm -M versatilepb -kernel ~/.panda/vmlinuz-3.2.0-4-versatile \\\n    -initrd ~/.panda/initrd.img-3.2.0-4-versatile -hda ~/.panda/arm_wheezy.qcow \\\n    -monitor stdio -loadvm root \\\n    -panda mmio_trace:out_log=\\\"mmio.json\\\"\n```\n\n----------------------------------------\n\nTITLE: Registering a Hypercall Handler â€” C Plugin Example\nDESCRIPTION: Full example showing how to access the 'hypercaller' plugin within a C plugin, define a custom hypercall handler, and register it for a unique magic number. Dependencies are the PANDA plugin API and dynamic linking (dlsym). The CPUState pointer is provided by PANDA when a matching hypercall is invoked. Registration logic ensures the 'hypercaller' plugin is loaded, then fetches the function and registers the handler. Returns success/failure as a boolean.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/hypercaller/README.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\n#include <panda/plugin.h>\n#include <hypercaller/hypercaller.h>\n\nhypercall_t* register_hypercall;\n\nvoid my_hypercall(CPUState *cpu) {\n    printf(\"Hello from my hypercall!\\n\");\n}\n\nbool init_plugin(void *self) {\n    void *hypercaller = panda_get_plugin_by_name(\"hypercaller\");\n    if (hypercaller == NULL){\n      panda_require(\"hypercaller\");\n      hypercaller = panda_get_plugin_by_name(\"hypercaller\");\n    }\n    register_hypercall = (hypercall_t*)dlsym(hypercaller, \"register_hypercall\");\n    register_hypercall(0x12345678, my_hypercall);\n    return true;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Calls for Querying Information in C\nDESCRIPTION: This snippet declares several Windows NT system calls for querying information about transactions, worker factories, and other system objects. These functions typically take handles to objects, information classes, and buffers for returning data.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x64_prototypes.txt#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationTransactionManager (HANDLE TransactionManagerHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength, PULONG ReturnLength);\n```\n\n----------------------------------------\n\nTITLE: Signal Handling System Call Declarations in C\nDESCRIPTION: Function declarations for Linux system calls related to signal handling. These declarations define the interface for managing process signals, including queuing, pending, and suspending operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_24\n\nLANGUAGE: C\nCODE:\n```\nlong sys_rt_sigpending(sigset_t __user *set, size_t sigsetsize);\nlong sys_rt_sigqueueinfo(pid_t pid, int sig, siginfo_t __user *uinfo);\nlong sys_rt_sigsuspend(sigset_t __user *unewset, size_t sigsetsize);\nlong sys_sigaltstack(const struct sigaltstack __user *uss, struct sigaltstack __user *uoss);\n```\n\n----------------------------------------\n\nTITLE: Initializing a PANDA Hello PyPlugin with Argument Parsing (Python)\nDESCRIPTION: Shows how to define a PANDA PyPlugin that demonstrates usage of argument parsing using get_arg and get_arg_bool methods. Requires pandare.PyPlugin and expects arguments 'path' and 'should_print_hello' to function. When 'should_print_hello' evaluates to True, prints 'Hello!'; always prints the path if provided.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/pyplugins.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass HelloPlugin(PyPlugin):\n    def __init__(self, panda):\n        path = self.get_arg('path')\n        print(f\"path = {path}\")\n        should_print_hello = self.get_arg_bool('should_print_hello')\n        if should_print_hello:\n            print(\"Hello!\")\n```\n\n----------------------------------------\n\nTITLE: Defining Registry and Token Management System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to registry key management and security token operations. These functions provide low-level access to the Windows registry and security token comparison.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCompactKeys (ULONG Count, HANDLE KeyArray[]);\nNTSTATUS NtCompareTokens (HANDLE FirstTokenHandle, HANDLE SecondTokenHandle, PBOOLEAN Equal);\nNTSTATUS NtCompleteConnectPort (HANDLE PortHandle);\nNTSTATUS NtCompressKey (HANDLE Key);\n```\n\n----------------------------------------\n\nTITLE: Declaring Native NT System API Function Prototypes - C\nDESCRIPTION: This collection of C declarations defines Windows NT kernel-mode API prototypes for advanced system operations. All functions use NTSTATUS as a return type, employ pointers to kernel objects (such as handles or descriptors), and expose system calls for memory, privilege, group, driver and boot entry management, and thorough security auditing and access checks. Intended for use in system programming or OS projects, these prototypes require Windows NT-specific headers and structures as dependencies and expect callers to provide appropriate structures and buffer sizes; outputs and results are via pointer arguments where changes are returned, and misuse (such as passing invalid pointers or improper buffer sizing) will lead to failures.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x86_prototypes.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAllocateReserveObject (PHANDLE MemoryReserveHandle, POBJECT_ATTRIBUTES ObjectAttributes, MEMORY_RESERVE_TYPE Type);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAllocateLocallyUniqueId (PLUID Luid);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAlertThread (HANDLE ThreadHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAlertResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAdjustPrivilegesToken (HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAdjustGroupsToken (HANDLE TokenHandle, BOOLEAN ResetToDefault, PTOKEN_GROUPS NewState, ULONG BufferLength, PTOKEN_GROUPS PreviousState, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAddDriverEntry (PEFI_DRIVER_ENTRY DriverEntry, PULONG Id);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAddBootEntry (PBOOT_ENTRY BootEntry, PULONG Id);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAddAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarmByHandle (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeResultList (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckByType (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheck (PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\n```\n\n----------------------------------------\n\nTITLE: Installing Build Tools and Linux Headers (Shell Command)\nDESCRIPTION: This snippet shows how to install the build-essential package and kernel headers on a Debian-based Linux system. These build dependencies are needed to compile the kernelinfo kernel module for exporting Linux data structure offsets. Both `build-essential` and `linux-headers-\\`uname -r\\`` must be present in the guest VM before building the module.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi_linux/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\napt-get install build-essential linux-headers-`uname -r`\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API Function Prototypes - C/C++\nDESCRIPTION: This snippet defines multiple C/C++ function prototypes corresponding to the Windows Native API, primarily for use in system programming on the Windows platform. The prototypes require specific types such as NTSTATUS, HANDLE, ACCESS_MASK, and various custom structures (e.g., OBJECT_ATTRIBUTES, IO_STATUS_BLOCK), which typically depend on Windows or NT headers being available in the codebase. Each function prototype details the function name, parameters for system operations such as token duplication, registry access, file I/O, memory management, and device control, reflecting the low-level abstraction and interactions possible via the NT Native API. Inputs are pointer-based, often representing object handles or data buffers, and outputs generally involve function-specific result/status codes, with usage constrained to advanced/system-level applications requiring detailed OS knowledge and proper context setup.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp0_x86_prototypes.txt#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDuplicateToken (HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);\nNTSTATUS NtEnumerateBootEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateDriverEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateKey (HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtEnumerateSystemEnvironmentValuesEx (ULONG InformationClass, PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateTransactionObject (HANDLE RootObjectHandle, KTMOBJECT_TYPE QueryType, PKTMOBJECT_CURSOR ObjectCursor, ULONG ObjectCursorLength, PULONG ReturnLength);\nNTSTATUS NtEnumerateValueKey (HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);\nNTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);\nNTSTATUS NtFindAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\nNTSTATUS NtFlushBuffersFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);\nNTSTATUS NtFlushKey (HANDLE KeyHandle);\nVOID NtFlushProcessWriteBuffers ();\nNTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);\nNTSTATUS NtFlushWriteBuffer ();\nNTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG FreeType);\nNTSTATUS NtFreezeRegistry (ULONG TimeOutInSeconds);\nNTSTATUS NtFreezeTransactions (PLARGE_INTEGER FreezeTimeout, PLARGE_INTEGER ThawTimeout);\nNTSTATUS NtFsControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nNTSTATUS NtGetDevicePowerState (HANDLE Device, DEVICE_POWER_STATE *State);\nNTSTATUS NtGetNlsSectionPtr (ULONG SectionType, ULONG SectionData, PVOID ContextData, PVOID *SectionPointer, PULONG SectionSize);\nNTSTATUS NtGetPlugPlayEvent (HANDLE EventHandle, PVOID Context, PPLUGPLAY_EVENT_BLOCK EventBlock, ULONG EventBufferSize);\nNTSTATUS NtGetWriteWatch (HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, SIZE_T RegionSize, PVOID *UserAddressArray, PULONG_PTR EntriesInUserAddressArray, PULONG Granularity);\nNTSTATUS NtImpersonateAnonymousToken (HANDLE ThreadHandle);\nNTSTATUS NtImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE Message);\nNTSTATUS NtImpersonateThread (HANDLE ServerThreadHandle, HANDLE ClientThreadHandle, PSECURITY_QUALITY_OF_SERVICE SecurityQos);\nNTSTATUS NtInitializeNlsFiles (PVOID *BaseAddress, PLCID DefaultLocaleId, PLARGE_INTEGER DefaultCasingTableSize);\nNTSTATUS NtInitializeRegistry (USHORT BootCondition);\nNTSTATUS NtInitiatePowerAction (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);\nNTSTATUS NtIsProcessInJob (HANDLE ProcessHandle, HANDLE JobHandle);\nBOOLEAN NtIsSystemResumeAutomatic ();\nNTSTATUS NtListenPort (HANDLE PortHandle, PPORT_MESSAGE ConnectionRequest);\nNTSTATUS NtLoadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtLoadKey (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile);\nNTSTATUS NtLoadKey2 (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags);\nNTSTATUS NtLoadKeyEx (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags, HANDLE TrustClassKey );\nNTSTATUS NtLockFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);\nNTSTATUS NtLockProductActivationKeys (ULONG *pPrivateVer, ULONG *pSafeMode);\nNTSTATUS NtLockRegistryKey (HANDLE KeyHandle);\nNTSTATUS NtLockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtMakePermanentObject (HANDLE Handle);\nNTSTATUS NtMakeTemporaryObject (HANDLE Handle);\nNTSTATUS NtMapUserPhysicalPages (PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, WIN32_PROTECTION_MASK Win32Protect);\nNTSTATUS NtModifyBootEntry (PBOOT_ENTRY BootEntry);\nNTSTATUS NtModifyDriverEntry (PEFI_DRIVER_ENTRY DriverEntry);\nNTSTATUS NtNotifyChangeDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree);\nNTSTATUS NtNotifyChangeKey (HANDLE KeyHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtNotifyChangeMultipleKeys (HANDLE MasterKeyHandle, ULONG Count, OBJECT_ATTRIBUTES SlaveObjects[], HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtOpenDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);\nNTSTATUS NtOpenIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE TransactionHandle);\nNTSTATUS NtOpenMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenPrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\nNTSTATUS NtOpenObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, ACCESS_MASK GrantedAccess, PPRIVILEGE_SET Privileges, BOOLEAN ObjectCreation, BOOLEAN AccessGranted, PBOOLEAN GenerateOnClose);\nNTSTATUS NtOpenProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenProcessToken (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);\nNTSTATUS NtOpenProcessTokenEx (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSession (PHANDLE SessionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenThreadToken (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);\nNTSTATUS NtOpenThreadTokenEx (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtPlugPlayControl (PLUGPLAY_CONTROL_CLASS PnPControlClass, PVOID PnPControlData, ULONG PnPControlDataLength);\nNTSTATUS NtPowerInformation (POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtPrivilegeCheck (HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, PBOOLEAN Result);\nNTSTATUS NtPrivilegeObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\nNTSTATUS NtPrivilegedServiceAuditAlarm (PUNICODE_STRING SubsystemName, PUNICODE_STRING ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\n```\n\n----------------------------------------\n\nTITLE: Declaring Get Process by Handle Callback Typedef in C\nDESCRIPTION: Provides a typedef for a callback enabling plugins to retrieve full process details based on a given OsiProcHandle. Receives a CPUState, an OsiProcHandle, and returns a pointer to OsiProc. Memory management is handled via free_osiproc. This allows efficient mapping from handle to full process metadata.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_get_process_t)(CPUState *, OsiProcHandle *, OsiProc **)\n```\n\n----------------------------------------\n\nTITLE: Defining Single Instruction Hook API in PANDA hooks2 Plugin\nDESCRIPTION: Defines the ADD_HOOKS2_SINGLE_INSN function that registers a callback for a single instruction address in specific processes and libraries. This is a simplified version of ADD_HOOKS2 for monitoring specific program counter values.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/hooks2/README.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nint ADD_HOOKS2_SINGLE_INSN(\n        hooks2_func_t hook,\n        void *cb_data,\n        const char *procname,\n        const char *libname,\n        target_ulong pc);\n```\n\n----------------------------------------\n\nTITLE: Timestamp Modification for Symbolic Links in C\nDESCRIPTION: Function declaration for setting access and modification times of a symbolic link. This operates on the link itself rather than the file it points to.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nint lutimes(const char *path, struct timeval *tptr);\n```\n\n----------------------------------------\n\nTITLE: Configuring PANDA with Android/ARM Guest Support - Shell Command - Shell\nDESCRIPTION: This shell command demonstrates the build configuration for PANDA to enable Android/ARM guest emulation. The key build requirements are to build only the arm_softmmu architecture and pass the --enable-android flag to the configure script. Build must be executed on a 64-bit OS. These configuration choices restrict builds to the relevant emulator/architecture and ensure Android-specific support is enabled.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/Android.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# Build PANDA as normal, with two changes:\n# 1. Only build the arm_softmmu architecture\n# 2. Pass the \"--enable-android\" flag to configure\n\n./configure --target-list=arm-softmmu --enable-android\nmake\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies, Cloning and Building PANDA - Shell\nDESCRIPTION: Installs all required system dependencies for Panda based on the versions listed for Ubuntu, clones the Panda repository from GitHub, creates a build directory, and executes the build script to compile the Panda binaries. Requires the user to edit the install command with the correct dependency package names and have Git, as well as general build tool prerequisites, installed. Inputs include necessary system package names; outputs are built PANDA binaries in the build directory. The process assumes permission to use sudo and sufficient network access to clone the repository.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/build_ubuntu.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nsudo apt-get update\nsudo apt install --no-install-recommends [dependencies]\n\n# clone and build PANDA\ngit clone https://github.com/panda-re/panda\ncd panda\nmkdir -p build && cd build\n../build.sh\n\n```\n\n----------------------------------------\n\nTITLE: Using callstack_instr API in a PANDA Plugin in C\nDESCRIPTION: This snippet provides an example for consuming the callstack_instr API from another PANDA plugin written in C. It demonstrates including required headers, querying up to 16 most recent callers on the guest stack, printing their addresses with formatted output, and initializing the API by requiring the callstack_instr plugin and calling its initialization function. Dependencies include the callstack_instr header, panda/plugin_plugin.h, and linking against required PANDA libraries. The example assumes integration in a C-based plugin project where PANDA plugin loading and initialization are handled externally.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/callstack_instr/README.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\n#include \"../callstack_instr/callstack_instr_ext.h\"\n#include \"panda/plugin_plugin.h\"\n\n// ...\n\nint some_plugin_fn(CPUState *env) {\n    target_ulong callers[16];\n    int n;\n    n = get_callers(callers, 16, env);\n    for (int i = 0; i < n; i++)\n        printf(\"Callstack entry: \" TARGET_FMT_lx \"\\n\", callers[i]);\n    return 0;\n}\n\n// ...\n\nbool init_plugin(void *self) {\n    panda_require(\"callstack_instr\");\n    if (!init_callstack_instr_api()) return false;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Valid OS Patterns for PANDA OSI Plugins - C\nDESCRIPTION: This C snippet declares an array of regular expressions used to validate command line OS arguments for the plugin. The valid_os_re array specifies patterns for supported operating systems and architectures, such as various Windows, Linux, and FreeBSD versions, ending with NULL for termination. This array is checked in logic elsewhere (such as in common.c) to ensure that only supported OS names are accepted, and acts as an extensibility point for supporting additional OS provider plugins.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n  const char * valid_os_re[] = {\n      \"windows[-_]32[-_]xpsp[23]\",\n      \"windows[-_]32[-_]2000\",\n      \"windows[-_]32[-_]7sp[01]\",\n      \"windows[-_]64[-_]7sp[01]\",\n      \"linux[-_]32[-_].+\",\n      \"linux[-_]64[-_].+\",\n      \"freebsd[-_]32[-_].+\",\n      \"freebsd[-_]64[-_].+\",\n      NULL\n  };\n```\n\n----------------------------------------\n\nTITLE: Initializing a Panda__LogEntry Struct for Pandalog Logging - C\nDESCRIPTION: Demonstrates correct initialization of the generated Panda__LogEntry struct using its macro initializer before setting fields for logging. This step is required for correct protobuf marshalling, and the macro ensures all internal pointers and presence flags are properly set. This must precede any assignment of values to fields.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_25\n\nLANGUAGE: C\nCODE:\n```\nPanda__LogEntry ple = PANDA__LOG_ENTRY__INIT;\n```\n\n----------------------------------------\n\nTITLE: Documenting QMP Command in QAPI Schema (QEMU, Comments in JSON)\nDESCRIPTION: This schema comment block documents the 'hello-world' QMP command for inclusion in qapi-schema.json. It explains the command purpose, argument, return value, special notes, and version history. Adequate documentation is mandatory for command acceptance in QEMU.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/writing-qmp-commands.txt#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n##\n# @hello-world\n#\n# Print a client provided string to the standard output stream.\n#\n# @message: string to be printed\n#\n# Returns: Nothing on success.\n#\n# Notes: if @message is not provided, the \"Hello, world\" string will\n#        be printed instead\n#\n# Since: <next qemu stable release, eg. 1.0>\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API Functions in C\nDESCRIPTION: This snippet contains multiple function declarations for Windows NT native API calls. These functions cover a wide range of system operations including port handling, access checks, memory allocation, and object management.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/all_windows_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAcceptConnectPort (PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView);\nNTSTATUS NtAccessCheck (PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n// ... [additional function declarations omitted for brevity] ...\nNTSTATUS NtCreateEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);\nNTSTATUS NtCreateEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Dependencies\nDESCRIPTION: Specifies exact versions of required Python packages for the project. Includes Jinja2 templating engine version 3.1.2 and its dependency MarkupSafe version 2.1.3.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/scripts/requirements2.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nJinja2==3.1.2\nMarkupSafe==2.1.3\n```\n\n----------------------------------------\n\nTITLE: Writing a Log Entry to the Pandalog from C - C\nDESCRIPTION: Invokes the C API to serialize and emit the log entry previously populated, completing the construction and output of a structured log message. Passing the struct pointer to pandalog_write_entry stores the entry in the current pandalog, as assigned by 'pandalog'.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_27\n\nLANGUAGE: C\nCODE:\n```\npandalog_write_entry(&ple);\n```\n\n----------------------------------------\n\nTITLE: Post-DMA Replay Callback Signature\nDESCRIPTION: Callback function signature for operations after DMA transfers during replay.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_54\n\nLANGUAGE: C\nCODE:\n```\nint (*replay_after_cpu_physical_mem_rw_ram)(CPUState *env, uint32_t is_write, uint8_t* src_addr, uint64_t dest_addr, uint32_t num_bytes);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Call Prototypes using NTAPI (C)\nDESCRIPTION: This snippet defines a set of function prototypes representing direct system calls provided by the Windows NT kernel. Each function returns an NTSTATUS value and uses native Windows types and structures (such as HANDLE, PUNICODE_STRING, and ACCESS_MASK), conforming to the NTAPI calling conventions. These functions require the inclusion of appropriate Windows headers and type definitions, and are intended to be linked dynamically or used for low-level programming, often by system utilities or reverse engineering tools. Inputs and outputs are pointer-based, with expected low-level memory, handle, and privilege management responsibilities left to the caller; incorrect usage may result in undefined behavior or security violations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp0_x86_prototypes.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAcceptConnectPort (PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAccessCheck (PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAccessCheckAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAccessCheckByType (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeResultList (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarmByHandle (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAddAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAddBootEntry (PBOOT_ENTRY BootEntry, PULONG Id);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAddDriverEntry (PEFI_DRIVER_ENTRY DriverEntry, PULONG Id);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAdjustGroupsToken (HANDLE TokenHandle, BOOLEAN ResetToDefault, PTOKEN_GROUPS NewState, ULONG BufferLength, PTOKEN_GROUPS PreviousState, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAdjustPrivilegesToken (HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlertResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlertThread (HANDLE ThreadHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAllocateLocallyUniqueId (PLUID Luid);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAllocateUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAllocateUuids (PULARGE_INTEGER Time, PULONG Range, PULONG Sequence, PCHAR Seed);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAllocateVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcAcceptConnectPort (PHANDLE PortHandle, HANDLE ConnectionPortHandle, ULONG Flags, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes, BOOLEAN AcceptConnection);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcCancelMessage (HANDLE PortHandle, ULONG Flags, PALPC_CONTEXT_ATTR MessageContext);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, ULONG Flags, PSID RequiredServerSid, PPORT_MESSAGE ConnectionMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes, PALPC_MESSAGE_ATTRIBUTES InMessageAttributes, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcCreatePortSection (HANDLE PortHandle, ULONG Flags, HANDLE SectionHandle, SIZE_T SectionSize, PALPC_HANDLE AlpcSectionHandle, PSIZE_T ActualSectionSize);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcCreateResourceReserve (HANDLE PortHandle, ULONG Flags, SIZE_T MessageSize, PALPC_HANDLE ResourceId);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcCreateSectionView (HANDLE PortHandle, ULONG Flags, PALPC_DATA_VIEW_ATTR ViewAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcCreateSecurityContext (HANDLE PortHandle, ULONG Flags, PALPC_SECURITY_ATTR SecurityAttribute);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcDeletePortSection (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE SectionHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcDeleteResourceReserve (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ResourceId);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcDeleteSectionView (HANDLE PortHandle, ULONG Flags, PVOID ViewBase);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcDeleteSecurityContext (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcDisconnectPort (HANDLE PortHandle, ULONG Flags);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE PortMessage, PVOID Reserved);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcOpenSenderProcess (PHANDLE ProcessHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcOpenSenderThread (PHANDLE ThreadHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcQueryInformation (HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcQueryInformationMessage (HANDLE PortHandle, PPORT_MESSAGE PortMessage, ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass, PVOID MessageInformation, ULONG Length, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcRevokeSecurityContext (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcSendWaitReceivePort (HANDLE PortHandle, ULONG Flags, PPORT_MESSAGE SendMessage, PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes, PPORT_MESSAGE ReceiveMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcSetInformation (HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtApphelpCacheControl (APPHELPCOMMAND type, PVOID buf);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAreMappedFilesTheSame (PVOID File1MappedAsAnImage, PVOID File2MappedAsFile);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAssignProcessToJobObject (HANDLE JobHandle, HANDLE ProcessHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCallbackReturn (PVOID OutputBuffer, ULONG OutputLength, NTSTATUS Status);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCancelIoFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCancelTimer (HANDLE TimerHandle, PBOOLEAN CurrentState);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtClearEvent (HANDLE EventHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtClose (HANDLE Handle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCloseObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCompactKeys (ULONG Count, HANDLE KeyArray[]);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCompareTokens (HANDLE FirstTokenHandle, HANDLE SecondTokenHandle, PBOOLEAN Equal);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCompleteConnectPort (HANDLE PortHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCompressKey (HANDLE Key);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtContinue (PCONTEXT ContextRecord, BOOLEAN TestAlert);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateDebugObject (PHANDLE DebugObjectHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Count);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateJobSet (ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);\n```\n\n----------------------------------------\n\nTITLE: Adding switch_task_hook_addr to kernelinfo.conf (GLib key-value format)\nDESCRIPTION: This snippet shows how to specify the address of the context switch hook, 'task.switch_task_hook_addr', in the kernelinfo.conf configuration section. The address should be extracted using grep from System.map as demonstrated and inserted as a value for this key. This enables enhanced tracking of task changes in Linux guests.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi_linux/README.md#_snippet_5\n\nLANGUAGE: GLib key-value (INI)\nCODE:\n```\n[my_kernel_info]\nname = #1 SMP Debian 3.2.51-1 i686\nversion.a = 3\n[...]\ntask.switch_task_hook_addr = <Address extracted from System.map>\n\n```\n\n----------------------------------------\n\nTITLE: Installing AUR Packages and Dependencies for PANDA (Shell)\nDESCRIPTION: This shell script snippet automates the installation of required PANDA dependencies on Arch Linux. It defines a function for downloading and installing AUR packages, performs a GPG key import, and fetches specific versions of key dependencies including protobuf, LLVM, and Wireshark. It relies on tools such as wget, tar, makepkg, git, and pacman, and also demonstrates building software from source. Inputs include package names and repository URLs, with outputs being the installed packages. Prerequisites include sudo rights and network connectivity.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/build_arch.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\naur_install_pkg () {\n\tlocal FNAME=$1\n\tlocal FNAME_WEB=$(python2 -c \"import urllib; print urllib.quote('''$FNAME''')\")\n\twget -O /tmp/$FNAME.tar.gz https://aur.archlinux.org/cgit/aur.git/snapshot/$FNAME_WEB.tar.gz\n\tcd /tmp\n\ttar -xvf $FNAME.tar.gz\n\tcd /tmp/$FNAME\n\tmakepkg -s\n\tmakepkg --install\n}\n\ngpg --receive-keys A2C794A986419D8A\naur_install_pkg \"libc++\"\naur_install_pkg \"llvm33\"\naur_install_pkg \"libprotobuf2\"\n\n# Protobuf for C language\ncd /tmp\ngit clone https://github.com/protobuf-c/protobuf-c.git protobuf-c\ncd protobuf-c\n./autogen.sh\n./configure --prefix=/usr\nmake\nsudo make install\n\n# We need to use an older version of wireshark, since 2.5.1 breaks the network plugin\nsudo pacman -U https://archive.archlinux.org/packages/w/wireshark-common/wireshark-common-2.4.4-1-x86_64.pkg.tar.xz\nsudo pacman -U https://archive.archlinux.org/packages/w/wireshark-cli/wireshark-cli-2.4.4-1-x86_64.pkg.tar.xz\n\n# Other dependencies\nsudo pacman -S python2-protobuf libelf dtc capstone libdwarf python2-pycparser\n\n```\n\n----------------------------------------\n\nTITLE: Connecting to QEMU QMP Using Telnet (Bash and Interactive JSON Exchange)\nDESCRIPTION: Shows how to connect to an active QEMU QMP server using telnet and interactively issue JSON commands and observe responses. Dependencies: telnet installed; QMP must be running on specified port. Example includes connection sequence, manual QMP capability negotiation, and sample QMP status query with expected JSON-formatted replies. Input: user-typed JSON commands. Output: JSON responses as per QMP specifications. Limitations: For manual testing and debugging, not automation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qmp-intro.txt#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ telnet localhost 4444\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\n{\n    \"QMP\": {\n        \"version\": {\n            \"qemu\": {\n                \"micro\": 50, \n                \"minor\": 6, \n                \"major\": 1\n            }, \n            \"package\": \"\"\n        }, \n        \"capabilities\": [\n        ]\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Tap Points for textprinter - Configuration File\nDESCRIPTION: Illustrates the required structure of the tap_points.txt file used by the textprinter plugin. The first line specifies the stack type (0: asid, 1: heuristic, 2: threaded) followed by one or more tap points, each defined by caller, program counter, and address space identifiers. Proper configuration of this file is critical, as mismatches in stack type or address space format between the tap_points.txt and actual runtime parameters can cause failures or mis-logging.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/textprinter/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n2\n7800f6a8 7800fc97 0000019c 00000210\n7800f6a8 7800fc97 0000019c 00000244\n7800f6a8 7800fc9a 0000019c 00000210\n7800f6a8 7800fc9a 0000019c 00000244\n```\n\n----------------------------------------\n\nTITLE: Configuring VM Snapshot Recording in PANDA\nDESCRIPTION: Command line configuration for specifying the default starting snapshot name using the icount field rrsnapshot. This enables creating and restoring VM states during replay execution.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/replay.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n-icount shift=7,rr=record,rrfile=replay.bin,rrsnapshot=snapshot_name\n```\n\n----------------------------------------\n\nTITLE: Loading and Configuring the COSI Plugin via Python API\nDESCRIPTION: These Python usage snippets illustrate how to load the COSI plugin using `panda.load_plugin`, optionally specifying a compressed symbol table profile file that must exist in the `~/.panda` directory. Functions like `panda.cosi.current_process()` expose COSI's capabilities directly to Python scripts, returning process information. No extra dependencies are required beyond the PANDA and COSI plugin installation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/cosi/README.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npanda.load_plugin(\"cosi\")\n```\n\nLANGUAGE: python\nCODE:\n```\npanda.load_plugin(\"cosi\", args = {\"profile\": \"your_file_here\"})\n```\n\nLANGUAGE: python\nCODE:\n```\ncosi_current = panda.cosi.current_process()\n```\n\n----------------------------------------\n\nTITLE: Defining a QMP Command with Optional Argument (QAPI, JSON)\nDESCRIPTION: This JSON snippet updates the QAPI schema for the 'hello-world' command to support an optional string argument called 'message'. The asterisk (*) denotes that 'message' is optional, and 'str' specifies its type. The schema enables QEMU to generate the appropriate marshalling interface for passing this argument from protocol to C handler.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/writing-qmp-commands.txt#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{ 'command': 'hello-world', 'data': { '*message': 'str' } }\n```\n\n----------------------------------------\n\nTITLE: Declaring After Virtual Memory Write Callback Signature in PANDA (C)\nDESCRIPTION: Declares the function pointer signature for plugin callbacks after virtual memory write operations, provided with CPU state, PC, address, size, and the written data. Activates only when panda_enable_memcb is called; there is no return value. Suitable for auditing or post-write effects.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_43\n\nLANGUAGE: C\nCODE:\n```\nvoid (*virt_mem_after_write)(CPUState *env, target_ulong pc, target_ulong addr, target_ulong size, void *buf);\n```\n\n----------------------------------------\n\nTITLE: Taint2 Query Functions\nDESCRIPTION: Functions for querying taint status and retrieving taint sets from various memory locations and registers. Includes functions for getting taint compute numbers and control bit masks.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/taint2/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nuint32_t taint2_query(Addr a);\nuint32_t taint2_query_ram(uint64_t pa);\nuint32_t taint2_query_reg(int reg_num, int offset);\nuint32_t taint2_query_io(uint64_t ia);\nuint32_t taint2_query_llvm(int reg_num, int offset);\nvoid taint2_query_set(Addr a, uint32_t *out);\nuint32_t taint2_query_tcn(Addr a);\nuint64_t taint2_query_cb_mask(Addr a, uint8_t size);\n```\n\n----------------------------------------\n\nTITLE: Setting CPU Program Counter with QEMU Loader Device\nDESCRIPTION: This snippet demonstrates the syntax for setting a CPU's program counter using the QEMU loader device. It allows specifying the address value and the CPU number.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/generic-loader.txt#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n-device loader,addr=<addr>,cpu-num=<cpu-num>\n```\n\n----------------------------------------\n\nTITLE: Compiling and Deploying recctrlu PANDA Utility - Shell\nDESCRIPTION: These shell commands illustrate compiling the 'recctrlu' guest utility for various CPU architectures using make, and securely transferring the resulting binaries into the guest VM via scp. All dependencies relate to a working build environment, correct PANDA source, and SSH connectivity with port forwarding configured. 'recctrlu' is necessary to send hypercalls from the guest to trigger PANDA recording, with binaries placed in accessible paths for execution by guest users or administrators. Compilation outputs static binaries, which do not require runtime dependencies on the guest.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/recctrl/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# copy to user directory\\nscp -P 10022 utils/recctrlu panda@localhost:~\\n\\n# copy to /usr/local/sbin\\nscp -P 10022 utils/recctrlu root@localhost:/usr/local/sbin\n```\n\n----------------------------------------\n\nTITLE: Exporting and Using Direct PPP Functions in PANDA PyPlugin (Python)\nDESCRIPTION: Demonstrates creating a PyPlugin (Server) that exports a PPP function do_add using the @PyPlugin.ppp_export decorator, and another (Consumer) that calls this function. The Server maintains a counter and increments it when do_add is called. Dependencies include PyPlugin and access to the internal PPP interface via PANDAâ€™s pyplugin loader. Inputs: integer to increment; Output: new counter value. Can be called by other plugins or directly using panda.pyplugins.ppp.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/pyplugins.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pandare import PyPlugin\nclass Server(PyPlugin):\n    '''\n    PyPlugin which provides a PPP-exported function do_add which increments a number\n    '''\n    def __init__(self, panda):\n      self.counter = 0\n\n    @PyPlugin.ppp_export\n    def do_add(self, x):\n        self.counter += x\n        return self.counter\n\nclass Consumer(PyPlugin):\n    '''\n    PyPlugin which calls a function in Server\n    '''\n    def __init__(self, panda):\n        print(f\"Calling Server's do_add(1): \", self.ppp.Server.do_add(1))\n```\n\n----------------------------------------\n\nTITLE: Installing PANDA Dependencies on Ubuntu\nDESCRIPTION: Command to install required system libraries for pandare on Ubuntu 20.04. These dependencies are necessary for PANDA's core functionality.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/core/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\napt install libvdeplug-dev libpng16-16 libsdl2-2.0-0\n```\n\n----------------------------------------\n\nTITLE: Creating qcow2 Image with Custom Cluster Size using qemu-img - Shell\nDESCRIPTION: This shell snippet demonstrates how to create a qcow2 virtual disk image using the qemu-img tool with a specified cluster size. The -f option selects the qcow2 format, -o allows options like cluster_size in bytes (here set to 128K), and the final parameters assign the output filename and overall size (in this example, 4G). This command requires qemu-img to be installed and ensures the cluster_size is a power of two and at least 512 bytes. The output is a new disk image file with specified structural parameters.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qcow2-cache.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nqemu-img create -f qcow2 -o cluster_size=128K hd.qcow2 4G\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API Functions in C\nDESCRIPTION: This snippet contains multiple function declarations for Windows NT native API calls. These functions provide low-level access to various system operations and objects.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2003sp12_x64_prototypes.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryMutant (HANDLE MutantHandle, MUTANT_INFORMATION_CLASS MutantInformationClass, PVOID MutantInformation, ULONG MutantInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryOpenSubKeys (POBJECT_ATTRIBUTES TargetKey, PULONG HandleCount);\nNTSTATUS NtQueryOpenSubKeysEx (POBJECT_ATTRIBUTES TargetKey, ULONG BufferLength, PVOID Buffer, PULONG RequiredSize);\nNTSTATUS NtQueryPortInformationProcess ();\nNTSTATUS NtQueryQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID SidList, ULONG SidListLength, PULONG StartSid, BOOLEAN RestartScan);\n// ... [truncated for brevity] ...\nNTSTATUS NtWaitForKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtWaitLowEventPair (HANDLE EventPairHandle);\n```\n\n----------------------------------------\n\nTITLE: Running PANDA Plugin Test and Logging Syscalls (Python)\nDESCRIPTION: This Python script boots the test kernel and logs syscall data to PANDALOG. It's used for executing the test and capturing relevant system call information for debugging and analysis of the PANDA plugin.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls_logger/dbg/README.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nrun_dbg.py\n```\n\n----------------------------------------\n\nTITLE: Flushing QEMU Translation Block Cache in C\nDESCRIPTION: This function triggers a flush of the translation block cache in QEMU, which is essential when code translation settings are altered by plugins. It must be used when plugins enable features like precise program counters to guarantee translation determinism and avoid crashes. No parameters are required; improper use may cause instability if translation state changes are not synchronized.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid panda_do_flush_tb(void);\n```\n\n----------------------------------------\n\nTITLE: Declaring Get Mapping by Address Callback Typedef in C\nDESCRIPTION: Introduces a typedef for retrieving the module (OsiModule) that contains a specific virtual address in a process address space. The callback receives CPUState, OsiProc pointer, a target virtual address, and outputs a pointer to the found OsiModule. Returned objects should be freed with free_osimodule.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_16\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_get_mapping_by_addr_t)(CPUState *, OsiProc *, target_ptr_t, OsiModule**)\n```\n\n----------------------------------------\n\nTITLE: Defining VMState for IDE Drive in C\nDESCRIPTION: This VMStateDescription defines the structure for saving the state of an IDE drive. It includes version information, a post-load callback, fields to be saved, and subsections.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/migration.txt#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nconst VMStateDescription vmstate_ide_drive = {\n    .name = \"ide_drive\",\n    .version_id = 3,\n    .minimum_version_id = 0,\n    .post_load = ide_drive_post_load,\n    .fields = (VMStateField[]) {\n        .... several fields ....\n        VMSTATE_END_OF_LIST()\n    },\n    .subsections = (const VMStateDescription*[]) {\n        &vmstate_ide_drive_pio_state,\n        NULL\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Defining System Configuration and Display System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to system configuration and display text functionality. These functions manage system-level settings and provide basic text display capabilities.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_18\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDisableLastKnownGood ();\nNTSTATUS NtDisplayString (PUNICODE_STRING String);\nNTSTATUS NtDrawText (PUNICODE_STRING Text);\nNTSTATUS NtEnableLastKnownGood ();\n```\n\n----------------------------------------\n\nTITLE: Declaring After Block Execution Callback Signature in PANDA (C)\nDESCRIPTION: Defines a function pointer for plugins to act after each block execution, receiving the CPU state, the translation block executed, and an exit code to determine normal completion or interruption. Key dependencies include types for CPU state and translation blocks, and the exitCode enumeration from PANDA's TCG machinery. Intended for post-execution instrumentation; the integer return value is unused.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_34\n\nLANGUAGE: C\nCODE:\n```\nint (*after_block_exec)(CPUState *env, TranslationBlock *tb, uint8_t exitCode);\n```\n\n----------------------------------------\n\nTITLE: Pairing Release/Acquire Barriers with Atomics - C\nDESCRIPTION: Demonstrates two approaches to ordering memory accesses between threads using various memory barrier primitives such as smp_mb_release()/smp_mb_acquire() and atomic_mb_set()/atomic_mb_read(). Shows the transformation from explicit full memory barriers to optimized write/read barriersâ€”improving performance while maintaining correctness. Requires C11 atomics or QEMU intrinsics, and a platform supporting atomic and barrier primitives. Intended for scenarios needing ordered communication between threads via shared variables. Each example shows writes in one thread becoming visible to reads in another.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/atomics.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nthread 1                                thread 1\\n-------------------------               ------------------------\\n(other writes)\\n                                             smp_mb_release()\\natomic_mb_set(&a, x)                    atomic_set(&a, x)\\n                                             smp_wmb()\\natomic_mb_set(&b, y)                    atomic_set(&b, y)\\n\\n                                   =>\\nthread 2                                thread 2\\n-------------------------               ------------------------\\ny = atomic_mb_read(&b)                  y = atomic_read(&b)\\n                                             smp_rmb()\\nx = atomic_mb_read(&a)                  x = atomic_read(&a)\\n                                             smp_mb_acquire()\n```\n\n----------------------------------------\n\nTITLE: Windows NT Native API Function Declarations in C\nDESCRIPTION: This code snippet contains declarations of Windows NT native API functions that provide direct access to kernel-level functionality. These system calls are used for operations such as inter-process communication, file system access, process and thread management, security token manipulation, and resource handling.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp12_x64_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAlpcSendWaitReceivePort (HANDLE PortHandle, ULONG Flags, PPORT_MESSAGE SendMessage, PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes, PPORT_MESSAGE ReceiveMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes, PLARGE_INTEGER Timeout);\nNTSTATUS NtAlpcSetInformation (HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length);\nNTSTATUS NtAreMappedFilesTheSame (PVOID File1MappedAsAnImage, PVOID File2MappedAsFile);\nNTSTATUS NtAssignProcessToJobObject (HANDLE JobHandle, HANDLE ProcessHandle);\nNTSTATUS NtCancelIoFileEx (HANDLE FileHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtCancelSynchronousIoFile (HANDLE ThreadHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtCommitComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCommitEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCommitTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\nNTSTATUS NtCompactKeys (ULONG Count, HANDLE KeyArray[]);\nNTSTATUS NtCompareTokens (HANDLE FirstTokenHandle, HANDLE SecondTokenHandle, PBOOLEAN Equal);\nNTSTATUS NtCompleteConnectPort (HANDLE PortHandle);\nNTSTATUS NtCompressKey (HANDLE Key);\nNTSTATUS NtConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\nNTSTATUS NtCreateDebugObject (PHANDLE DebugObjectHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\nNTSTATUS NtCreateDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, HANDLE TransactionHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, NOTIFICATION_MASK NotificationMask, PVOID EnlistmentKey);\nNTSTATUS NtCreateEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Count);\nNTSTATUS NtCreateJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateJobSet (ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);\nNTSTATUS NtCreateKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, HANDLE TransactionHandle, PULONG Disposition);\nNTSTATUS NtCreateKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\nNTSTATUS NtCreateMailslotFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout);\nNTSTATUS NtCreateMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN InitialOwner);\nNTSTATUS NtCreateNamedPipeFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout);\nNTSTATUS NtCreatePagingFile (PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority);\nNTSTATUS NtCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtCreatePrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\nNTSTATUS NtCreateProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort);\nNTSTATUS NtCreateProfile (PHANDLE ProfileHandle, HANDLE Process, PVOID RangeBase, SIZE_T RangeSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);\nNTSTATUS NtCreateResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID RmGuid, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, PUNICODE_STRING Description);\nNTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);\nNTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);\nNTSTATUS NtCreateThreadEx (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument, ULONG CreateFlags, ULONG_PTR ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, PPS_ATTRIBUTE_LIST AttributeList);\nNTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);\nNTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);\nNTSTATUS NtCreateTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle, ULONG CreateOptions, ULONG IsolationLevel, ULONG IsolationFlags, PLARGE_INTEGER Timeout, PUNICODE_STRING Description);\nNTSTATUS NtCreateTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, ULONG CreateOptions, ULONG CommitStrength);\nNTSTATUS NtCreateUserProcess (PHANDLE ProcessHandle, PHANDLE ThreadHandle, ACCESS_MASK ProcessDesiredAccess, ACCESS_MASK ThreadDesiredAccess, POBJECT_ATTRIBUTES ProcessObjectAttributes, POBJECT_ATTRIBUTES ThreadObjectAttributes, ULONG ProcessFlags, ULONG ThreadFlags, PRTL_USER_PROCESS_PARAMETERS ProcessParameters, PPROCESS_CREATE_INFO CreateInfo, PPROCESS_ATTRIBUTE_LIST AttributeList);\nNTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtCreateWorkerFactory (PHANDLE WorkerFactoryHandleReturn, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE CompletionPortHandle, HANDLE WorkerProcessHandle, PVOID StartRoutine, PVOID StartParameter, ULONG MaxThreadCount, SIZE_T StackReserve, SIZE_T StackCommit);\nNTSTATUS NtDebugActiveProcess (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtDebugContinue (HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);\nNTSTATUS NtDeleteAtom (RTL_ATOM Atom);\nNTSTATUS NtDeleteBootEntry (ULONG Id);\nNTSTATUS NtDeleteDriverEntry (ULONG Id);\nNTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtDeleteKey (HANDLE KeyHandle);\nNTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtDeletePrivateNamespace (HANDLE NamespaceHandle);\nNTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);\nNTSTATUS NtDisplayString (PUNICODE_STRING String);\nNTSTATUS NtEnumerateBootEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateDriverEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateSystemEnvironmentValuesEx (ULONG InformationClass, PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateTransactionObject (HANDLE RootObjectHandle, KTMOBJECT_TYPE QueryType, PKTMOBJECT_CURSOR ObjectCursor, ULONG ObjectCursorLength, PULONG ReturnLength);\nNTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);\nNTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);\nNTSTATUS NtFlushInstallUILanguage (LANGID InstallUILanguage, ULONG SetComittedFlag);\nNTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);\nNTSTATUS NtFlushKey (HANDLE KeyHandle);\nVOID NtFlushProcessWriteBuffers ();\nNTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);\nNTSTATUS NtFlushWriteBuffer ();\nNTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtFreezeRegistry (ULONG TimeOutInSeconds);\nNTSTATUS NtFreezeTransactions (PLARGE_INTEGER FreezeTimeout, PLARGE_INTEGER ThawTimeout);\nNTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nULONG NtGetCurrentProcessorNumber ();\nNTSTATUS NtGetDevicePowerState (HANDLE Device, DEVICE_POWER_STATE *State);\nNTSTATUS NtGetMUIRegistryInfo (ULONG Flags, PULONG DataSize, PVOID Data);\nNTSTATUS NtGetNextProcess (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewProcessHandle);\nNTSTATUS NtGetNextThread (HANDLE ProcessHandle, HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewThreadHandle);\n```\n\n----------------------------------------\n\nTITLE: Running PANDA Replay with Data Text Printer Plugin (Shell)\nDESCRIPTION: This command performs a new PANDA replay using the callstack_instr and textprinter plugins to extract full byte sequences passing through specified tap points. It is used to build detailed logs of sensitive data flow within the emulator. Dependencies include all previously created images, PANDA, and the tap points configuration. Outputs are read_tap_buffers.txt.gz and write_tap_buffers.txt.gz, containing logged memory transactions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/LINE_Censorship.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n../arm-softmmu/panda-system-arm -m 2048 -replay line2 -M android_arm -android -cpu cortex-a9 -kernel /dev/null \\\n  -global goldfish_mmc.sd_path=/dev/null -global goldfish_nand.system_path=dummy2.qcow2 \\\n  -global goldfish_nand.user_data_path=dummy.qcow2 \\\n  -panda 'callstack_instr;textprinter'\n```\n\n----------------------------------------\n\nTITLE: Declaring NT Native System Call Prototypes - C/C++\nDESCRIPTION: Declares a broad set of function prototypes for Windows NT native system calls, using types such as HANDLE, PVOID, NTSTATUS, and others commonly found in the Windows Driver Kit or NT headers. These declarations allow direct invocation of undocumented kernel API functions from C or C++ code, enabling advanced system-level programming, testing, or emulation. All functions return NTSTATUS and assume the programmer has set up proper typedefs for key structures (e.g., POBJECT_ATTRIBUTES, PPORT_MESSAGE, etc.); no function body is provided. Inputs are various pointer and scalar arguments matching Windows kernel types, outputs are via return value and output pointers. Requires inclusion of Windows platform-specific headers and knowledge of calling conventions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp0_x64_prototypes.txt#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcSendWaitReceivePort (HANDLE PortHandle, ULONG Flags, PPORT_MESSAGE SendMessage, PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes, PPORT_MESSAGE ReceiveMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes, PLARGE_INTEGER Timeout);\nNTSTATUS NtAlpcSetInformation (HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length);\nNTSTATUS NtAreMappedFilesTheSame (PVOID File1MappedAsAnImage, PVOID File2MappedAsFile);\nNTSTATUS NtAssignProcessToJobObject (HANDLE JobHandle, HANDLE ProcessHandle);\nNTSTATUS NtCancelIoFileEx (HANDLE FileHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtCancelSynchronousIoFile (HANDLE ThreadHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtCommitComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCommitEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCommitTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\nNTSTATUS NtCompactKeys (ULONG Count, HANDLE KeyArray[]);\nNTSTATUS NtCompareTokens (HANDLE FirstTokenHandle, HANDLE SecondTokenHandle, PBOOLEAN Equal);\nNTSTATUS NtCompleteConnectPort (HANDLE PortHandle);\nNTSTATUS NtCompressKey (HANDLE Key);\nNTSTATUS NtConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\nNTSTATUS NtCreateDebugObject (PHANDLE DebugObjectHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\nNTSTATUS NtCreateDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, HANDLE TransactionHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, NOTIFICATION_MASK NotificationMask, PVOID EnlistmentKey);\nNTSTATUS NtCreateEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Count);\nNTSTATUS NtCreateJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateJobSet (ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);\nNTSTATUS NtCreateKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, HANDLE TransactionHandle, PULONG Disposition);\nNTSTATUS NtCreateKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\nNTSTATUS NtCreateMailslotFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout);\nNTSTATUS NtCreateMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN InitialOwner);\nNTSTATUS NtCreateNamedPipeFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout);\nNTSTATUS NtCreatePagingFile (PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority);\nNTSTATUS NtCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtCreatePrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\nNTSTATUS NtCreateProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort);\nNTSTATUS NtCreateProfile (PHANDLE ProfileHandle, HANDLE Process, PVOID RangeBase, SIZE_T RangeSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);\nNTSTATUS NtCreateProfileEx (PHANDLE ProfileHandle, HANDLE Process, PVOID ProfileBase, SIZE_T ProfileSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, ULONG GroupAffinityCount, PGROUP_AFFINITY GroupAffinity);\nNTSTATUS NtCreateResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID RmGuid, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, PUNICODE_STRING Description);\nNTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);\nNTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);\nNTSTATUS NtCreateThreadEx (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument, ULONG CreateFlags, ULONG_PTR ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, PPS_ATTRIBUTE_LIST AttributeList);\nNTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);\nNTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);\nNTSTATUS NtCreateTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle, ULONG CreateOptions, ULONG IsolationLevel, ULONG IsolationFlags, PLARGE_INTEGER Timeout, PUNICODE_STRING Description);\nNTSTATUS NtCreateTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, ULONG CreateOptions, ULONG CommitStrength);\nNTSTATUS NtCreateUserProcess (PHANDLE ProcessHandle, PHANDLE ThreadHandle, ACCESS_MASK ProcessDesiredAccess, ACCESS_MASK ThreadDesiredAccess, POBJECT_ATTRIBUTES ProcessObjectAttributes, POBJECT_ATTRIBUTES ThreadObjectAttributes, ULONG ProcessFlags, ULONG ThreadFlags, PRTL_USER_PROCESS_PARAMETERS ProcessParameters, PPROCESS_CREATE_INFO CreateInfo, PPROCESS_ATTRIBUTE_LIST AttributeList);\nNTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtCreateWorkerFactory (PHANDLE WorkerFactoryHandleReturn, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE CompletionPortHandle, HANDLE WorkerProcessHandle, PVOID StartRoutine, PVOID StartParameter, ULONG MaxThreadCount, SIZE_T StackReserve, SIZE_T StackCommit);\nNTSTATUS NtDebugActiveProcess (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtDebugContinue (HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);\nNTSTATUS NtDeleteAtom (RTL_ATOM Atom);\nNTSTATUS NtDeleteBootEntry (ULONG Id);\nNTSTATUS NtDeleteDriverEntry (ULONG Id);\nNTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtDeleteKey (HANDLE KeyHandle);\nNTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtDeletePrivateNamespace (HANDLE NamespaceHandle);\nNTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);\nNTSTATUS NtDisableLastKnownGood ();\nNTSTATUS NtDisplayString (PUNICODE_STRING String);\nNTSTATUS NtDrawText (PUNICODE_STRING Text);\nNTSTATUS NtEnableLastKnownGood ();\nNTSTATUS NtEnumerateBootEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateDriverEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateSystemEnvironmentValuesEx (ULONG InformationClass, PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateTransactionObject (HANDLE RootObjectHandle, KTMOBJECT_TYPE QueryType, PKTMOBJECT_CURSOR ObjectCursor, ULONG ObjectCursorLength, PULONG ReturnLength);\nNTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);\nNTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);\nNTSTATUS NtFlushInstallUILanguage (LANGID InstallUILanguage, ULONG SetComittedFlag);\nNTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);\nNTSTATUS NtFlushKey (HANDLE KeyHandle);\nVOID NtFlushProcessWriteBuffers ();\nNTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);\nNTSTATUS NtFlushWriteBuffer ();\nNTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtFreezeRegistry (ULONG TimeOutInSeconds);\nNTSTATUS NtFreezeTransactions (PLARGE_INTEGER FreezeTimeout, PLARGE_INTEGER ThawTimeout);\nNTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nULONG NtGetCurrentProcessorNumber ();\nNTSTATUS NtGetDevicePowerState (HANDLE Device, DEVICE_POWER_STATE *State);\n```\n\n----------------------------------------\n\nTITLE: Registering and Handling Auxiliary Vector Callback with PANDA PPP (Python)\nDESCRIPTION: This Python script demonstrates how to use the PANDA Python API to interact with the proc_start_linux plugin. It shows registering the on_rec_auxv callback to process each guest process's auxv, queueing a set of shell commands, and formatting output. Required dependencies: pandare Python bindings and syscalls2-enabled PANDA build. The guest_interaction coroutine reverts the VM and runs commands, while recv_auxv extracts and prints process metadata from the auxv structure. The main entrypoint runs the panda VM and triggers analysis. Key parameters include the optional architecture (argv), command list, and the auxv fields used for output.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/proc_start_linux/README.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pandare import Panda\nfrom sys import argv\n\narch = \"i386\" if len(argv) <= 1 else argv[1]\npanda = Panda(generic=arch)\n\n@panda.queue_blocking\ndef guest_interaction():\n    panda.revert_sync(\"root\")\n    for cmd in [\"ls -la\", \"whoami\", \"time ls -la\"]:\n        print(f\"{cmd} {panda.run_serial_cmd('LD_SHOW_AUXV=1 '+cmd)}\")\n    panda.end_analysis()\n\n@panda.ppp(\"proc_start_linux\", \"on_rec_auxv\")\ndef recv_auxv(cpu, tb, auxv):\n    procname = panda.ffi.string(auxv.execfn)\n    print(f\"started proc {procname} {auxv.phdr:x} {auxv.entry:x}\")\n\npanda.run()\n```\n\n----------------------------------------\n\nTITLE: Loading Specific Value to Memory Address with QEMU Loader\nDESCRIPTION: This example shows how to load the value 0x8000000e to the memory address 0xfd1a0104 using the QEMU loader device.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/generic-loader.txt#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n-device loader,addr=0xfd1a0104,data=0x8000000e,data-len=4\n```\n\n----------------------------------------\n\nTITLE: Retrieving MMIO Events - PANDA mmio_trace C API\nDESCRIPTION: This C code snippet defines a function to retrieve a dynamically allocated array of mmio_event_t structures and its count, enabling programmatic access to recorded MMIO events during a guest run. There are no external dependencies, though callers should be aware of memory allocation and deallocation requirements for the returned array. Parameters include an output pointer for the count of events, and the function returns a pointer to the event array. Used for post-analysis or plugin-internal event retrieval.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/mmio_trace/README.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n// Get heap-allocated array of contiguous mmio_event_t structs and their count\\nmmio_event_t* get_mmio_events(int* struct_cnt_ret);\n```\n\n----------------------------------------\n\nTITLE: Setting Up Test Environment for PANDA Plugin (Bash)\nDESCRIPTION: This Bash script downloads a file system, builds a test kernel, and prepares kernel VMI artifacts including an OSI profile and DWARF JSON. It's used for setting up the debugging environment for the PANDA plugin.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls_logger/dbg/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\nsetup_dbg.py\n```\n\n----------------------------------------\n\nTITLE: Conditionally Compiling Functionality Based on Feature Flags - Rust - rust\nDESCRIPTION: Illustrates conditional compilation in Rust source by excluding the breaks_arm function if the feature 'arm' is active. This practice allows code to remain portable and prevents architecture-specific errors. Relies on build features specified in Cargo.toml; the attribute #[cfg(not(feature = \"arm\"))] is interpreted at compile-time.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/rust_skeleton/README.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(not(feature = \"arm\"))]\nfn breaks_arm() {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Running Scissors Plugin via PANDA Command-Line - Shell\nDESCRIPTION: This shell snippet demonstrates how to invoke the PANDA binary with the 'scissors' plugin to extract a replay segment between specified instruction counts. The command assumes the presence of the PANDA_PATH environment variable and the PANDA QEMU target. Users must specify the start and end instruction numbers, as well as the output base file name. The input replay and output segment can each be in either rr1 or rr2 format depending on file extension. Inputs are the original replay file, output file base name, and instruction range; outputs are the snipped replay log files in the chosen format. There are no additional dependencies, but users may need to adjust parameters if output is invalid.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/scissors/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo[.rr2] \\\n    -panda scissors:name=foo_reduced[.rr2],start=12345,end=8675309\n```\n\n----------------------------------------\n\nTITLE: Declaring Linux System Call Prototypes in C\nDESCRIPTION: These code snippets declare the C function prototypes for a wide range of system calls provided by the Linux kernel. Dependencies include system-defined types (e.g., struct sockaddr, uid_t, gid_t, sigset_t) and user-space pointer annotations (__user). Parameters detail user- and kernel-space pointers, various primitive types, and struct definitions. Expected inputs are syscall parameters from userspace; outputs include syscall return values and potentially modified user-space buffers. Limitations include platform- or architecture-specific struct definitions and the absence of implementation bodies within this file.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n4169 long sys_bind(int, struct sockaddr __user *, int);\n4170 long sys_connect(int, struct sockaddr __user *, int);\n4171 long sys_getpeername(int, struct sockaddr __user *, int __user *);\n4172 long sys_getsockname(int, struct sockaddr __user *, int __user *);\n4173 long sys_getsockopt(int fd, int level, int optname, char __user *optval, int __user *optlen);\n4174 long sys_listen(int, int);\n4175 long sys_recv(int, void __user *, size_t, unsigned);\n4176 long sys_recvfrom(int, void __user *, size_t, unsigned, struct sockaddr __user *, int __user *);\n4177 long sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\n4178 long sys_send(int, void __user *, size_t, unsigned);\n4179 long sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\n4180 long sys_sendto(int, void __user *, size_t, unsigned, struct sockaddr __user *, int);\n4181 long sys_setsockopt(int fd, int level, int optname, char __user *optval, int optlen);\n4182 long sys_shutdown(int, int);\n4183 long sys_socket(int, int, int);\n4184 long sys_socketpair(int, int, int, int __user *);\n4185 long sys_setresuid(uid_t ruid, uid_t euid, uid_t suid);\n4186 long sys_getresuid(uid_t __user *ruid, uid_t __user *euid, uid_t __user *suid);\n4187 long sys_query_module(const char *name, int which, void *buf, size_t bufsize, size_t *ret);\n4188 long sys_poll(struct pollfd __user *ufds, unsigned int nfds, int timeout);\n4189 long sys_nfsservctl(int cmd, struct nfsctl_arg *argp, union nfsctl_res *resp);\n4190 long sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid);\n4191 long sys_getresgid(gid_t __user *rgid, gid_t __user *egid, gid_t __user *sgid);\n4192 long sys_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\n4193 void sys_rt_sigreturn(void);\n4194 long sys_rt_sigaction(int, const struct sigaction __user *, struct sigaction __user *, size_t);\n4195 long sys_rt_sigprocmask(int how, sigset_t __user *set, sigset_t __user *oset, size_t sigsetsize);\n4196 long sys_rt_sigpending(sigset_t __user *set, size_t sigsetsize);\n4197 long sys_rt_sigtimedwait_time32(const sigset_t __user *uthese, siginfo_t __user *uinfo, const struct old_timespec32 __user *uts, size_t sigsetsize);\n4198 long sys_rt_sigqueueinfo(pid_t pid, int sig, siginfo_t __user *uinfo);\n4199 long sys_rt_sigsuspend(sigset_t __user *unewset, size_t sigsetsize);\n4200 long sys_pread64(unsigned int fd, char __user *buf, size_t count, loff_t pos);\n4201 long sys_pwrite64(unsigned int fd, const char __user *buf, size_t count, loff_t pos);\n4202 long sys_chown(const char __user *filename, uid_t user, gid_t group);\n4203 long sys_getcwd(char __user *buf, unsigned long size);\n4204 long sys_capget(cap_user_header_t header, cap_user_data_t dataptr);\n4205 long sys_capset(cap_user_header_t header, const cap_user_data_t data);\n4206 long sys_sigaltstack(const struct sigaltstack __user *uss, struct sigaltstack __user *uoss);\n4207 long sys_sendfile(int out_fd, int in_fd, off_t __user *offset, size_t count);\n// 4208 sys_getpmsg - UNIMPLEMENTED\n// 4209 sys_getpmsg - UNIMPLEMENTED\n4210 void* mmap2(void *addr, size_t length, int prot, int flags, int fd, off_t pgoffset);\n4211 long sys_truncate64(const char __user *path, loff_t length);\n4212 long sys_ftruncate64(unsigned int fd, loff_t length);\n4213 long sys_stat64(const char __user *filename, struct stat64 __user *statbuf);\n4214 long sys_lstat64(const char __user *filename, struct stat64 __user *statbuf);\n4215 long sys_fstat64(unsigned long fd, struct stat64 __user *statbuf);\n4216 long sys_pivot_root(const char __user *new_root, const char __user *put_old);\n4217 long sys_mincore(unsigned long start, size_t len, unsigned char __user *vec);\n4218 long sys_madvise(unsigned long start, size_t len, int behavior);\n4219 long sys_getdents64(unsigned int fd, struct linux_dirent64 __user *dirent, unsigned int count);\n4220 long sys_fcntl64(unsigned int fd, unsigned int cmd, unsigned long arg);\n// 4221 - RESERVED\n4222 long sys_gettid(void);\n4223 long sys_readahead(int fd, loff_t offset, size_t count);\n4224 long sys_setxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\n4225 long sys_lsetxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\n4226 long sys_fsetxattr(int fd, const char __user *name, const void __user *value, size_t size, int flags);\n4227 long sys_getxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\n4228 long sys_lgetxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\n4229 long sys_fgetxattr(int fd, const char __user *name, void __user *value, size_t size);\n4230 long sys_listxattr(const char __user *path, char __user *list, size_t size);\n4231 long sys_llistxattr(const char __user *path, char __user *list, size_t size);\n4232 long sys_flistxattr(int fd, char __user *list, size_t size);\n4233 long sys_removexattr(const char __user *path, const char __user *name);\n4234 long sys_lremovexattr(const char __user *path, const char __user *name);\n4235 long sys_fremovexattr(int fd, const char __user *name);\n4236 long sys_tkill(pid_t pid, int sig);\n4237 long sys_sendfile64(int out_fd, int in_fd, loff_t __user *offset, size_t count);\n4238 long sys_futex_time32(u32 __user *uaddr, int op, u32 val, struct old_timespec32 __user *utime, u32 __user *uaddr2, u32 val3);\n4239 long sys_sched_setaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\n4240 long sys_sched_getaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\n4241 long sys_io_setup(unsigned nr_reqs, aio_context_t __user *ctx);\n4242 long sys_io_destroy(aio_context_t ctx);\n4243 long sys_io_getevents_time32(__u32 ctx_id, __s32 min_nr, __s32 nr, struct io_event __user *events, struct old_timespec32 __user *timeout);\n4244 long sys_io_submit(aio_context_t, long, struct iocb __user * __user *);\n4245 long sys_io_cancel(aio_context_t ctx_id, struct iocb __user *iocb, struct io_event __user *result);\n4246 long sys_exit_group(int error_code);\n4247 long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);\n4248 long sys_epoll_create(int size);\n4249 long sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user *event);\n4250 long sys_epoll_wait(int epfd, struct epoll_event __user *events, int maxevents, int timeout);\n4251 long sys_remap_file_pages(unsigned long start, unsigned long size, unsigned long prot, unsigned long pgoff, unsigned long flags);\n4252 long sys_set_tid_address(int __user *tidptr);\n4253 long sys_restart_syscall(void);\n4254 long sys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice);\n4255 long sys_statfs64(const char __user *path, size_t sz, struct statfs64 __user *buf);\n4256 long sys_fstatfs64(unsigned int fd, size_t sz, struct statfs64 __user *buf);\n4257 long sys_timer_create(clockid_t which_clock, struct sigevent __user *timer_event_spec, timer_t __user *created_timer_id);\n4258 long sys_timer_settime32(timer_t timer_id, int flags, struct old_itimerspec32 __user *new, struct old_itimerspec32 __user *old);\n4259 long sys_timer_gettime32(timer_t timer_id, struct old_itimerspec32 __user *setting);\n4260 long sys_timer_getoverrun(timer_t timer_id);\n4261 long sys_timer_delete(timer_t timer_id);\n4262 long sys_clock_settime32(clockid_t which_clock, struct old_timespec32 __user *tp);\n4263 long sys_clock_gettime32(clockid_t which_clock, struct old_timespec32 __user *tp);\n4264 long sys_clock_getres_time32(clockid_t which_clock, struct old_timespec32 __user *tp);\n4265 long sys_clock_nanosleep_time32(clockid_t which_clock, int flags, struct old_timespec32 __user *rqtp, struct old_timespec32 __user *rmtp);\n4266 long sys_tgkill(pid_t tgid, pid_t pid, int sig);\n4267 long sys_utimes_time32(const char __user *filename, struct old_timeval32 __user *t);\n4268 long sys_mbind(unsigned long start, unsigned long len, unsigned long mode, const unsigned long __user *nmask, unsigned long maxnode, unsigned flags);\n4269 long sys_get_mempolicy(int __user *policy, unsigned long __user *nmask, unsigned long maxnode, unsigned long addr, unsigned long flags);\n4270 long sys_set_mempolicy(int mode, const unsigned long __user *nmask, unsigned long maxnode);\n4271 long sys_mq_open(const char __user *name, int oflag, umode_t mode, struct mq_attr __user *attr);\n4272 long sys_mq_unlink(const char __user *name);\n4273 long sys_mq_timedsend_time32(mqd_t mqdes, const char __user *u_msg_ptr, unsigned int msg_len, unsigned int msg_prio, const struct old_timespec32 __user *u_abs_timeout);\n4274 long sys_mq_timedreceive_time32(mqd_t mqdes, char __user *u_msg_ptr, unsigned int msg_len, unsigned int __user *u_msg_prio, const struct old_timespec32 __user *u_abs_timeout);\n4275 long sys_mq_notify(mqd_t mqdes, const struct sigevent __user *notification);\n4276 long sys_mq_getsetattr(mqd_t mqdes, const struct mq_attr __user *mqstat, struct mq_attr __user *omqstat);\n// 4277 sys_vserver - UNIMPLEMENTED\n4278 long sys_waitid(int which, pid_t pid, struct siginfo __user *infop, int options, struct rusage __user *ru);\n// 4279 - ???\n4280 long sys_add_key(const char __user *_type, const char __user *_description, const void __user *_payload, size_t plen, key_serial_t destringid);\n4281 long sys_request_key(const char __user *_type, const char __user *_description, const char __user *_callout_info, key_serial_t destringid);\n4282 long sys_keyctl(int cmd, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\n4283 long set_thread_area(unsigned long tp);\n4284 long sys_inotify_init(void);\n4285 long sys_inotify_add_watch(int fd, const char __user *path, u32 mask);\n4286 long sys_inotify_rm_watch(int fd, __s32 wd);\n4287 long sys_migrate_pages(pid_t pid, unsigned long maxnode, const unsigned long __user *from, const unsigned long __user *to);\n4288 long sys_openat(int dfd, const char __user *filename, int flags, umode_t mode);\n```\n\n----------------------------------------\n\nTITLE: Configuring Disk IOPS Limit with QEMU Command-line - Shell\nDESCRIPTION: This code snippet demonstrates how to set a maximum IOPS (Input/Output Operations Per Second) limit for a block device with QEMU using the -drive option. No additional dependencies are required, but a functional QEMU environment is necessary. The throttling.iops-total option is set to 100, which limits the drive to 100 IOPS, and all unspecified limits remain at their defaults. The input is a shell command line; output is enforced limit during VM runtime.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/throttle.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n-drive file=hd0.qcow2,throttling.iops-total=100\n```\n\n----------------------------------------\n\nTITLE: Guarding Architecture-Specific Code in PANDA Plugins using C/C++\nDESCRIPTION: This snippet demonstrates how to conditionally execute code for different architectures using preprocessor macros in C/C++. It is used to ensure that plugin logic is only compiled for supported architectures such as x86 (I386) or ARM. Key macros like TARGET_I386 or TARGET_ARM are used, enabling cross-architecture compatibility in plugin development. No external dependencies are required beyond PANDA/QEMU's build definitions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_9\n\nLANGUAGE: C\nCODE:\n```\n#if defined(TARGET_I386)\n// Do x86-specific stuff\n#elif defined(TARGET_ARM)\n// Do ARM-specific stuff\n#endif\n```\n\n----------------------------------------\n\nTITLE: Resizable RCU Array Write-Side Update Pattern in C\nDESCRIPTION: This write-side code for an RCU-protected, resizable array handles allocation, copying, pointer swap, and reclamation. It checks for array size before allocating a new, larger array, then copies old data and updates the shared pointer with an atomic RCU set, synchronizes, and frees the previous array. Required are g_malloc, memcpy, atomic_rcu_set, synchronize_rcu, and free. Input is the global array pointer; output is a resized array with consistent update and safe reclamation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/rcu.txt#_snippet_11\n\nLANGUAGE: C\nCODE:\n```\nif (global_array->size == global_array->alloc) {\n    /* Creating a new version.  */\n    new_array = g_malloc(sizeof(struct arr) +\n                         global_array->alloc * 2 * sizeof(T));\n    new_array->size = global_array->size;\n    new_array->alloc = global_array->alloc * 2;\n    memcpy(new_array->data, global_array->data,\n           global_array->alloc * sizeof(T));\n\n    /* Removal phase.  */\n    old_array = global_array;\n    atomic_rcu_set(&new_array->data, new_array);\n    synchronize_rcu();\n\n    /* Reclamation phase.  */\n    free(old_array);\n}\n```\n\n----------------------------------------\n\nTITLE: Resizable RCU Array Access Pattern in C\nDESCRIPTION: This snippet demonstrates how to safely read from a resizable array protected by RCU. It performs a lookup within a read-side critical section, ensuring array size and data integrity during concurrent access. Dependencies include rcu_read_lock, atomic_rcu_read, and rcu_read_unlock. Inputs are the global array pointer and index; outputs include safe, consistent retrieval or a sentinel value. Requires that array structure and memory layout remain stable until after grace period.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/rcu.txt#_snippet_10\n\nLANGUAGE: C\nCODE:\n```\nrcu_read_lock();\nstruct arr *array = atomic_rcu_read(&global_array);\nx = i < array->size ? array->data[i] : -1;\nrcu_read_unlock();\nreturn x;\n```\n\n----------------------------------------\n\nTITLE: Invoking PANDA with pc_search for Multiple PCs from File and Limiting Output - Shell\nDESCRIPTION: This example invokes PANDA with the pc_search plugin, instructing it to read multiple PC values from an input file and to output only the first and last occurrence for each PC. The pc_file argument specifies the filename with PC values, first_last_only reduces output lines, and out_file sets the output filename. The example is suitable for use cases where only boundary guest instructions are needed for each searched PC.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/pc_search/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo \\\n    -panda pc_search:first_last_only=true,pc_file=\"pc_input.txt\",out_file=\"my_pc_matches.txt\"\n```\n\n----------------------------------------\n\nTITLE: RCU Write-Side Removal with Reference Counting in C\nDESCRIPTION: This pattern safely updates a shared object pointer and handles memory reclamation by decrementing the reference count after releasing the mutex. It depends on qemu_mutex_lock, atomic_rcu_set, qemu_mutex_unlock, synchronize_rcu, and foo_unref. The inputs are the mutex and pointer variables; the output is correct disposal of the old object when no more references remain. Using foo_unref allows object reclamation only when all references are gone.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/rcu.txt#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nqemu_mutex_lock(&foo_mutex);\nold = foo;\natomic_rcu_set(&foo, new);\nqemu_mutex_unlock(&foo_mutex);\nsynchronize_rcu();\nfoo_unref(old);\n```\n\n----------------------------------------\n\nTITLE: Loading PANDA PyPlugins from PyPanda Scripts (Python)\nDESCRIPTION: Examples of loading PyPlugins by class or file path using panda.pyplugins.load() and related methods from within a PyPanda script. Assumes plugin classes or source files are accessible and properly defined. Shows loading with arguments, from single or multiple classes, and via load/load_all functions. Key parameters: plugin class/file, argument dictionary.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/pyplugins.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npanda.pyplugins.load(YourPlugin, {'path': '/foo'})\n```\n\n----------------------------------------\n\nTITLE: Creating qcow2 Image with Custom Refcount Bits using qemu-img - Shell\nDESCRIPTION: This shell snippet shows how to create a qcow2 image and explicitly set the bit-width for the refcount field using the refcount_bits option to qemu-img. The default is 16 bits, but here it's set to 8, which impacts storage efficiency and addressable space. The result is a new qcow2 file with 8-bit refcount entries, which can affect space savings and cache calculations. qemu-img must be installed and the requested setting must comply with qcow2 format limitations (refcount_bits not greater than 64, power of two).\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qcow2-cache.txt#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nqemu-img create -f qcow2 -o refcount_bits=8 hd.qcow2 4G\n```\n\n----------------------------------------\n\nTITLE: Freeing Argument Lists in PANDA Plugins using C\nDESCRIPTION: Explains usage of panda_free_args for releasing the memory allocated by panda_get_args. Calling panda_free_args with the argument list pointer ensures proper memory management and avoids leaks. Required for each plugin that parses command-line arguments.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_20\n\nLANGUAGE: C\nCODE:\n```\nvoid panda_free_args(panda_arg_list *args);\n```\n\n----------------------------------------\n\nTITLE: Hotplugging and Removing USB Devices via QEMU Monitor - QEMU Monitor Command\nDESCRIPTION: Demonstrates the use of QEMU monitor commands for adding and removing USB devices by specifying their IDs. These commands are to be entered at the QEMU monitor prompt and allow dynamic management of devices during runtime. Requires a running VM and use of device IDs to uniquely reference devices for removal.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/usb2.txt#_snippet_4\n\nLANGUAGE: QEMU CLI\nCODE:\n```\n(qemu) device_add usb-tablet,bus=usb-bus.0,port=1,id=my-tablet\n```\n\nLANGUAGE: QEMU CLI\nCODE:\n```\n(qemu) device_del my-tablet\n```\n\n----------------------------------------\n\nTITLE: Initializing LLVM Function PassManager in PANDA with C\nDESCRIPTION: This C/C++ snippet demonstrates how to enable and set up PANDA's LLVM subsystem for analysis. It initializes the LLVM context, enables LLVM and its helper functions, configures a FunctionPassManager, and adds a custom function pass for analyzing translation blocks. Dependencies include PANDA's internal LLVM context, the presence of a custom FunctionPass such as 'MyFunctionPass', and inclusion of necessary PANDA and LLVM headers. Inputs are implicit via global state; the output is the configured FunctionPassManager ready for use in code instrumentation. The snippet must be compiled within PANDA with appropriate linkage against LLVM.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_29\n\nLANGUAGE: C\nCODE:\n```\nextern \\\"C\\\" TCGLLVMContext *tcg_llvm_ctx;\npanda_enable_llvm();\npanda_enable_llvm_helpers();\nllvm::FunctionPassManager *fpm = tcg_llvm_ctx->getFunctionPassManager();\nfpm->add(new MyFunctionPass());\nFPM->doInitialization();\n```\n\n----------------------------------------\n\nTITLE: Adding Unimplemented Devices in QEMU Stellaris - C Code Excerpt\nDESCRIPTION: This C snippet, taken from QEMU's Stellaris board definition, demonstrates how the create_unimplemented_device API is used to stub peripherals that do not yet have proper emulation. These dummy regions prevent guest accesses from causing crashes, but are not functionally complete. The function takes the device name, base address, and size as parameters. This informs users that logs may omit activity for unimplemented hardware.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/mmio_trace/README.md#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n/* Add dummy regions for the devices we don't implement yet,\\n * so guest accesses don't cause unlogged crashes.\\n */\\ncreate_unimplemented_device(\\\"wdtimer\\\", 0x40000000, 0x1000);\\ncreate_unimplemented_device(\\\"i2c-0\\\", 0x40002000, 0x1000);\\ncreate_unimplemented_device(\\\"i2c-2\\\", 0x40021000, 0x1000);\\ncreate_unimplemented_device(\\\"PWM\\\", 0x40028000, 0x1000);\\ncreate_unimplemented_device(\\\"QEI-0\\\", 0x4002c000, 0x1000);\\ncreate_unimplemented_device(\\\"QEI-1\\\", 0x4002d000, 0x1000);\\ncreate_unimplemented_device(\\\"analogue-comparator\\\", 0x4003c000, 0x1000);\\ncreate_unimplemented_device(\\\"hibernation\\\", 0x400fc000, 0x1000);\\ncreate_unimplemented_device(\\\"flash-control\\\", 0x400fd000, 0x1000);\n```\n\n----------------------------------------\n\nTITLE: Declaring Get Current Thread Callback Typedef in C\nDESCRIPTION: Declares a typedef for a callback that retrieves the currently executing thread from the guest OS. The callback receives CPUState and outputs an allocated OsiThread pointer, which must be freed via free_osithread. Useful for thread-level introspection by plugins.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_9\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_get_current_thread_t)(CPUState *, OsiThread **)\n```\n\n----------------------------------------\n\nTITLE: Defining Advanced Process Creation System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to user process creation, waitable port creation, and worker factory management. These functions provide advanced process initialization capabilities.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_14\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateUserProcess (PHANDLE ProcessHandle, PHANDLE ThreadHandle, ACCESS_MASK ProcessDesiredAccess, ACCESS_MASK ThreadDesiredAccess, POBJECT_ATTRIBUTES ProcessObjectAttributes, POBJECT_ATTRIBUTES ThreadObjectAttributes, ULONG ProcessFlags, ULONG ThreadFlags, PRTL_USER_PROCESS_PARAMETERS ProcessParameters, PPROCESS_CREATE_INFO CreateInfo, PPROCESS_ATTRIBUTE_LIST AttributeList);\nNTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtCreateWorkerFactory (PHANDLE WorkerFactoryHandleReturn, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE CompletionPortHandle, HANDLE WorkerProcessHandle, PVOID StartRoutine, PVOID StartParameter, ULONG MaxThreadCount, SIZE_T StackReserve, SIZE_T StackCommit);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows Native API Functions in C\nDESCRIPTION: This snippet declares a series of Windows Native API functions using the NTSTATUS return type and various input parameters. These functions provide low-level access to Windows system operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x64_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWorkerFactoryWorkerReady (HANDLE WorkerFactoryHandle);\nNTSTATUS NtAcceptConnectPort (PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView);\nNTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtWaitForSingleObject (HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtCallbackReturn (PVOID OutputBuffer, ULONG OutputLength, NTSTATUS Status);\nNTSTATUS NtReadFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtWriteFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtRemoveIoCompletion (HANDLE IoCompletionHandle, PVOID *KeyContext, PVOID *ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER Timeout);\nNTSTATUS NtReleaseSemaphore (HANDLE SemaphoreHandle, LONG ReleaseCount, PLONG PreviousCount);\nNTSTATUS NtReplyWaitReceivePort (HANDLE PortHandle, PVOID *PortContext , PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage);\nNTSTATUS NtReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtSetInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);\nNTSTATUS NtSetEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtClose (HANDLE Handle);\nNTSTATUS NtQueryObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\nNTSTATUS NtOpenKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtEnumerateValueKey (HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtFindAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\nNTSTATUS NtQueryDefaultLocale (BOOLEAN UserProfile, PLCID DefaultLocaleId);\nNTSTATUS NtQueryKey (HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtQueryValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtAllocateVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);\nNTSTATUS NtQueryInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);\nNTSTATUS NtWaitForMultipleObjects32 (ULONG Count, LONG Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWriteFileGather (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtSetInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);\nNTSTATUS NtCreateKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);\nNTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG FreeType);\nNTSTATUS NtImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE Message);\nNTSTATUS NtReleaseMutant (HANDLE MutantHandle, PLONG PreviousCount);\nNTSTATUS NtQueryInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);\nNTSTATUS NtRequestWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtQueryVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtOpenThreadToken (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);\nNTSTATUS NtQueryInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);\nNTSTATUS NtOpenProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtSetInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\nNTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, WIN32_PROTECTION_MASK Win32Protect);\nNTSTATUS NtAccessCheckAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtUnmapViewOfSection (HANDLE ProcessHandle, PVOID BaseAddress);\nNTSTATUS NtReplyWaitReceivePortEx (HANDLE PortHandle, PVOID *PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage, PLARGE_INTEGER Timeout);\nNTSTATUS NtTerminateProcess (HANDLE ProcessHandle, NTSTATUS ExitStatus);\nNTSTATUS NtSetEventBoostPriority (HANDLE EventHandle);\nNTSTATUS NtReadFileScatter (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtOpenThreadTokenEx (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenProcessTokenEx (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtQueryPerformanceCounter (PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);\nNTSTATUS NtEnumerateKey (HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtOpenFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);\nNTSTATUS NtDelayExecution (BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);\nNTSTATUS NtQueryDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);\nNTSTATUS NtQuerySystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\nNTSTATUS NtOpenSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtQueryTimer (HANDLE TimerHandle, TIMER_INFORMATION_CLASS TimerInformationClass, PVOID TimerInformation, ULONG TimerInformationLength, PULONG ReturnLength);\nNTSTATUS NtFsControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtWriteVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\nNTSTATUS NtCloseObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtDuplicateObject (HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);\nNTSTATUS NtQueryAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);\nNTSTATUS NtClearEvent (HANDLE EventHandle);\nNTSTATUS NtReadVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtOpenEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtAdjustPrivilegesToken (HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);\nNTSTATUS NtDuplicateToken (HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);\nNTSTATUS NtContinue (PCONTEXT ContextRecord, BOOLEAN TestAlert);\nNTSTATUS NtQueryDefaultUILanguage (LANGID *DefaultUILanguageId);\n```\n\n----------------------------------------\n\nTITLE: Defining Windows NT Native API System Call Interfaces in C\nDESCRIPTION: This code snippet contains function prototypes for Windows NT kernel system calls (NtXxx functions). These functions form the Native API layer that serves as the interface between user mode and kernel mode in Windows NT operating systems. Each function is prefixed with a number that likely corresponds to its system call number.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp12_x64_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n0 NTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n1 NTSTATUS NtWaitForSingleObject (HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n2 NTSTATUS NtCallbackReturn (PVOID OutputBuffer, ULONG OutputLength, NTSTATUS Status);\n3 NTSTATUS NtReadFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n4 NTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\n5 NTSTATUS NtWriteFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n6 NTSTATUS NtRemoveIoCompletion (HANDLE IoCompletionHandle, PVOID *KeyContext, PVOID *ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER Timeout);\n7 NTSTATUS NtReleaseSemaphore (HANDLE SemaphoreHandle, LONG ReleaseCount, PLONG PreviousCount);\n8 NTSTATUS NtReplyWaitReceivePort (HANDLE PortHandle, PVOID *PortContext , PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage);\n9 NTSTATUS NtReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\n10 NTSTATUS NtSetInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);\n11 NTSTATUS NtSetEvent (HANDLE EventHandle, PLONG PreviousState);\n12 NTSTATUS NtClose (HANDLE Handle);\n13 NTSTATUS NtQueryObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);\n14 NTSTATUS NtQueryInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\n15 NTSTATUS NtOpenKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n16 NTSTATUS NtEnumerateValueKey (HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\n17 NTSTATUS NtFindAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\n18 NTSTATUS NtQueryDefaultLocale (BOOLEAN UserProfile, PLCID DefaultLocaleId);\n19 NTSTATUS NtQueryKey (HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\n20 NTSTATUS NtQueryValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\n21 NTSTATUS NtAllocateVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);\n22 NTSTATUS NtQueryInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);\n23 NTSTATUS NtWaitForMultipleObjects32 (ULONG Count, LONG Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n24 NTSTATUS NtWriteFileGather (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n25 NTSTATUS NtSetInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);\n26 NTSTATUS NtCreateKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);\n27 NTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG FreeType);\n28 NTSTATUS NtImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE Message);\n29 NTSTATUS NtReleaseMutant (HANDLE MutantHandle, PLONG PreviousCount);\n30 NTSTATUS NtQueryInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);\n31 NTSTATUS NtRequestWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage, PPORT_MESSAGE ReplyMessage);\n32 NTSTATUS NtQueryVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);\n33 NTSTATUS NtOpenThreadToken (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);\n34 NTSTATUS NtQueryInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);\n35 NTSTATUS NtOpenProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\n36 NTSTATUS NtSetInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\n37 NTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, WIN32_PROTECTION_MASK Win32Protect);\n38 NTSTATUS NtAccessCheckAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n39 NTSTATUS NtUnmapViewOfSection (HANDLE ProcessHandle, PVOID BaseAddress);\n40 NTSTATUS NtReplyWaitReceivePortEx (HANDLE PortHandle, PVOID *PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage, PLARGE_INTEGER Timeout);\n41 NTSTATUS NtTerminateProcess (HANDLE ProcessHandle, NTSTATUS ExitStatus);\n42 NTSTATUS NtSetEventBoostPriority (HANDLE EventHandle);\n43 NTSTATUS NtReadFileScatter (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n44 NTSTATUS NtOpenThreadTokenEx (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle);\n45 NTSTATUS NtOpenProcessTokenEx (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle);\n46 NTSTATUS NtQueryPerformanceCounter (PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);\n47 NTSTATUS NtEnumerateKey (HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\n48 NTSTATUS NtOpenFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);\n49 NTSTATUS NtDelayExecution (BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);\n50 NTSTATUS NtQueryDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);\n51 NTSTATUS NtQuerySystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\n52 NTSTATUS NtOpenSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n53 NTSTATUS NtQueryTimer (HANDLE TimerHandle, TIMER_INFORMATION_CLASS TimerInformationClass, PVOID TimerInformation, ULONG TimerInformationLength, PULONG ReturnLength);\n54 NTSTATUS NtFsControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\n55 NTSTATUS NtWriteVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\n56 NTSTATUS NtCloseObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\n57 NTSTATUS NtDuplicateObject (HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);\n58 NTSTATUS NtQueryAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);\n59 NTSTATUS NtClearEvent (HANDLE EventHandle);\n60 NTSTATUS NtReadVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\n61 NTSTATUS NtOpenEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n62 NTSTATUS NtAdjustPrivilegesToken (HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);\n63 NTSTATUS NtDuplicateToken (HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);\n64 NTSTATUS NtContinue (PCONTEXT ContextRecord, BOOLEAN TestAlert);\n65 NTSTATUS NtQueryDefaultUILanguage (LANGID *DefaultUILanguageId);\n66 NTSTATUS NtQueueApcThread (HANDLE ThreadHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\n67 NTSTATUS NtYieldExecution ();\n68 NTSTATUS NtAddAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\n```\n\n----------------------------------------\n\nTITLE: Working with PANDA rr-Inspired GDB Extensions - GDB\nDESCRIPTION: This GDB snippet demonstrates the use of PANDA-provided rr-inspired commands for working with instruction count-based breakpoints. Commands like 'when' allow querying the current guest instruction count, while 'rrbreakpoint', 'rrdelete', and 'rrlist' manage breakpoints based on instruction counts. The setup requires PANDA to be running with GDB and the rr command extensions loaded via the gdbinit script. Users can set, list, and delete these advanced breakpoints using the GDB CLI.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/time-travel.md#_snippet_3\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) when\n2000\n(gdb) rrb 3000\nAdded breakpoints at instructions 3000\n(gdb) c\nContinuing.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n0xffffffff810135d2 in ?? ()\n(gdb) when\n3000\n```\n\n----------------------------------------\n\nTITLE: Probing, Enabling, and Defining GNUTLS Support in QEMU Configure Script - Shell\nDESCRIPTION: This Shell snippet demonstrates how the QEMU configure script initializes and probes for optional GNUTLS cryptography support. It shows variable initialization, command-line flag handling, help messaging, feature checking with pkg-config, feature summary reporting, and conditional writing of a Makefile define if GNUTLS is enabled. Dependencies include POSIX shell compatibility and the presence of pkg-config and gnutls development libraries. Key parameters are the feature variable (gnutls), command-line arguments (--enable-gnutls/--disable-gnutls), and temporary files for summary/configuration output. Inputs are shell variables and user-provided flags; outputs are status messages and config file modifications. Limitations include reliance on POSIX shell and external tools.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/build-system.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n# Initial variable state\\ngnutls=\"\"\\n\\n..snip..\\n\\n# Configure flag processing\\n--disable-gnutls) gnutls=\"no\"\\n;;\\n--enable-gnutls) gnutls=\"yes\"\\n;;\\n\\n..snip..\\n\\n# Help output feature message\\ngnutls          GNUTLS cryptography support\\n\\n..snip..\\n\\n# Test for gnutls\\nif test \"$gnutls\" != \"no\"; then\\n   if ! $pkg_config --exists \"gnutls\"; then\\n      gnutls_cflags=`$pkg_config --cflags gnutls`\\n      gnutls_libs=`$pkg_config --libs gnutls`\\n      libs_softmmu=\"$gnutls_libs $libs_softmmu\"\\n      libs_tools=\"$gnutls_libs $libs_tools\"\\n      QEMU_CFLAGS=\"$QEMU_CFLAGS $gnutls_cflags\"\\n      gnutls=\"yes\"\\n   elif test \"$gnutls\" = \"yes\"; then\\n      feature_not_found \"gnutls\" \"Install gnutls devel\"\\n   else\\n      gnutls=\"no\"\\n   fi\\nfi\\n\\n..snip..\\n\\n# Completion feature summary\\necho \"GNUTLS support    $gnutls\"\\n\\n..snip..\\n\\n# Define make variables\\nif test \"$gnutls\" = \"yes\" ; then\\n   echo \"CONFIG_GNUTLS=y\" >> $config_host_mak\\nfi\n```\n\n----------------------------------------\n\nTITLE: Running QEMU with Selected Trace Events in Shell\nDESCRIPTION: This shell command runs QEMU with the '-trace events=/tmp/events' option, instructing QEMU to trace only the events listed in the /tmp/events file. The command can be appended with additional options and arguments as needed for normal QEMU execution. Requires a properly-set-up events file and QEMU built with trace support. Inputs: QEMU command arguments. Outputs: QEMU instance that produces a trace file during execution.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/tracing.txt#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nqemu -trace events=/tmp/events ... # your normal QEMU invocation\n```\n\n----------------------------------------\n\nTITLE: Declaring Linux System Call Function Prototypes in C\nDESCRIPTION: This code block enumerates a collection of function prototypes corresponding to Linux system calls, each prefixed with `sys_`, following kernel naming conventions. These declarations specify interfaces for system-level functions such as file access, I/O multiplexing, memory management, timers, and sockets, and use types and qualifiers specific to the Linux kernel (e.g., `__user`, `struct`). The expected input parameters vary per function, covering standard kernel data structures and user-space memory pointers; each function returns a `long` to convey success or error codes. This header file requires Linux kernel headers and appropriate kernel build context. The prototypes do not implement any logic or call flow; they simply define the contract between user-space and kernel subsystem handlers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_x86_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n307 long sys_faccessat(int dfd, const char __user *filename, int mode);\n308 long sys_pselect6(int, fd_set __user *, fd_set __user *, fd_set __user *, struct timespec __user *, void __user *);\n309 long sys_ppoll(struct pollfd __user *, unsigned int, struct timespec __user *, const sigset_t __user *, size_t);\n310 long sys_unshare(unsigned long unshare_flags);\n311 long sys_set_robust_list(struct robust_list_head __user *head, size_t len);\n312 long sys_get_robust_list(int pid, struct robust_list_head __user * __user *head_ptr, size_t __user *len_ptr);\n313 long sys_splice(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);\n314 long sys_sync_file_range(int fd, loff_t offset, loff_t nbytes, unsigned int flags);\n315 long sys_tee(int fdin, int fdout, size_t len, unsigned int flags);\n316 long sys_vmsplice(int fd, const struct iovec __user *iov, unsigned long nr_segs, unsigned int flags);\n317 long sys_move_pages(pid_t pid, unsigned long nr_pages, const void __user * __user *pages, const int __user *nodes, int __user *status, int flags);\n318 long sys_getcpu(unsigned __user *cpu, unsigned __user *node, struct getcpu_cache __user *cache);\n319 long sys_epoll_pwait(int epfd, struct epoll_event __user *events, int maxevents, int timeout, const sigset_t __user *sigmask, size_t sigsetsize);\n320 long sys_utimensat(int dfd, const char __user *filename, struct timespec __user *utimes, int flags);\n321 long sys_signalfd(int ufd, sigset_t __user *user_mask, size_t sizemask);\n322 long sys_timerfd_create(int clockid, int flags);\n323 long sys_eventfd(unsigned int count);\n324 long sys_fallocate(int fd, int mode, loff_t offset, loff_t len);\n325 long sys_timerfd_settime(int ufd, int flags, const struct itimerspec __user *utmr, struct itimerspec __user *otmr);\n326 long sys_timerfd_gettime(int ufd, struct itimerspec __user *otmr);\n327 long sys_signalfd4(int ufd, sigset_t __user *user_mask, size_t sizemask, int flags);\n328 long sys_eventfd2(unsigned int count, int flags);\n329 long sys_epoll_create1(int flags);\n330 long sys_dup3(unsigned int oldfd, unsigned int newfd, int flags);\n331 long sys_pipe2(int __user *fildes, int flags);\n332 long sys_inotify_init1(int flags);\n333 long sys_preadv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);\n334 long sys_pwritev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);\n335 long sys_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t __user *uinfo);\n336 long sys_perf_event_open(struct perf_event_attr __user *attr_uptr, pid_t pid, int cpu, int group_fd, unsigned long flags);\n337 long sys_recvmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags, struct timespec __user *timeout);\n338 long sys_fanotify_init(unsigned int flags, unsigned int event_f_flags);\n339 long sys_fanotify_mark(int fanotify_fd, unsigned int flags, u64 mask, int fd, const char __user *pathname);\n340 long sys_prlimit64(pid_t pid, unsigned int resource, const struct rlimit64 __user *new_rlim, struct rlimit64 __user *old_rlim);\n341 long sys_name_to_handle_at(int dfd, const char __user *name, struct file_handle __user *handle, int __user *mnt_id, int flag);\n342 long sys_open_by_handle_at(int mountdirfd, struct file_handle __user *handle, int flags);\n343 long sys_clock_adjtime(clockid_t which_clock, struct timex __user *tx);\n344 long sys_syncfs(int fd);\n345 long sys_sendmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags);\n346 long sys_setns(int fd, int nstype);\n347 long sys_process_vm_readv(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);\n348 long sys_process_vm_writev(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);\n349 long sys_kcmp(pid_t pid1, pid_t pid2, int type, unsigned long idx1, unsigned long idx2);\n350 long sys_finit_module(int fd, const char __user *uargs, int flags);\n351 long sys_sched_setattr(pid_t pid, struct sched_attr __user *attr, unsigned int flags);\n352 long sys_sched_getattr(pid_t pid, struct sched_attr __user *attr, unsigned int size, unsigned int flags);\n353 long sys_renameat2(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, unsigned int flags);\n354 long sys_seccomp(unsigned int op, unsigned int flags, const char __user *uargs);\n355 long sys_getrandom(char __user *buf, size_t count, unsigned int flags);\n356 long sys_memfd_create(const char __user *uname_ptr, unsigned int flags);\n357 long sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);\n358 long sys_execveat(int dfd, const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp, int flags);\n359 long sys_socket(int, int, int);\n360 long sys_socketpair(int, int, int, int __user *);\n361 long sys_bind(int, struct sockaddr __user *, int);\n362 long sys_connect(int, struct sockaddr __user *, int);\n363 long sys_listen(int, int);\n364 long sys_accept4(int, struct sockaddr __user *, int __user *, int);\n365 long sys_getsockopt(int fd, int level, int optname, char __user *optval, int __user *optlen);\n366 long sys_setsockopt(int fd, int level, int optname, char __user *optval, int optlen);\n367 long sys_getsockname(int, struct sockaddr __user *, int __user *);\n368 long sys_getpeername(int, struct sockaddr __user *, int __user *);\n369 long sys_sendto(int, void __user *, size_t, unsigned, struct sockaddr __user *, int);\n370 long sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\n371 long sys_recvfrom(int, void __user *, size_t, unsigned, struct sockaddr __user *, int __user *);\n372 long sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\n373 long sys_shutdown(int, int);\n374 long sys_userfaultfd(int flags);\n375 long sys_membarrier(int cmd, int flags);\n376 long sys_mlock2(unsigned long start, size_t len, int flags);\n377 long sys_copy_file_range(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);\n378 long sys_preadv2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);\n379 long sys_pwritev2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);\n380 long sys_pkey_mprotect(unsigned long start, size_t len, unsigned long prot, int pkey);\n381 long sys_pkey_alloc(unsigned long flags, unsigned long init_val);\n382 long sys_pkey_free(int pkey);\n383 long sys_statx(int dfd, const char __user *path, unsigned flags, unsigned mask, struct statx __user *buffer);\n384 long sys_arch_prctl(int, unsigned long);\n```\n\n----------------------------------------\n\nTITLE: Declaring Get Process Handles Callback Typedef in C\nDESCRIPTION: Defines a callback typedef allowing plugins to retrieve an array of OsiProcHandle objects corresponding to process handles for the guest OS. Like process enumeration, this is memory-managed with g_array_free and offers a lightweight method for OSI providers to track or identify processes without full process meta-data. The callback receives CPUState and a double pointer to a GArray for output.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_get_process_handles_t)(CPUState *, GArray **)\n```\n\n----------------------------------------\n\nTITLE: QAPI Expression Documentation Block for Struct Definition - Python\nDESCRIPTION: Defines a QAPI struct using single-quoted, Python-style dictionary syntax with inline documentation comments. The struct 'BlockStats' has optional device and node-name string members. Comments specify parameter roles, version history, and usage notes, parsed by the QAPI code and documentation generators. Input must appear in ASCII, and ordering within the dictionary is significant for code generation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n##\n# @BlockStats:\n#\n# Statistics of a virtual block device or a block backing device.\n#\n# @device: If the stats are for a virtual block device, the name\n#          corresponding to the virtual block device.\n#\n# @node-name: The node name of the device. (since 2.3)\n#\n# ... more members ...\n#\n# Since: 0.14.0\n##\n{ 'struct': 'BlockStats',\n  'data': {'*device': 'str', '*node-name': 'str',\n           ... more members ... } }\n```\n\n----------------------------------------\n\nTITLE: Loading cosi_strace Plugin with Prototype Dump Option - Python\nDESCRIPTION: This Python one-liner demonstrates loading the cosi_strace plugin with the 'dump_prototypes' parameter enabled, specifying an output path for syscall prototypes. When used, this disables syscall tracing but writes prototype signatures to the specified file instead. It depends on a valid Panda plugin loader context and a writable output path. The main input is the destination filename. This is ideal for users who need to generate syscall lists for external use. Limitation: disables trace output when the option is set.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/cosi_strace/README.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\npanda.load_plugin(\"cosi_strace\", { \"dump_prototypes\": \"prototypes.txt\" })\n```\n\n----------------------------------------\n\nTITLE: Running PANDA func_stats Plugin with CLI Arguments - Bash\nDESCRIPTION: This command line example demonstrates how to use the func_stats PANDA plugin with specific arguments for monitored ASIDs, hexadecimal address formatting, call and stack limits. Parameters are passed through the -panda option, allowing precise control over which processes/functions are tracked. Pre-requisites include a working PANDA QEMU binary, replay file, and the func_stats plugin compiled and installed.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/func_stats/README.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/qemu-system-x86_64 -replay foo -panda func_stats:asids=0x0fb45000_0x08ca0000,hex=true,call_limit=200,stack_limit=16\n```\n\n----------------------------------------\n\nTITLE: Attaching Multiple USB Attached SCSI (UAS) Devices with Manual SCSI Mapping - QEMU - Shell\nDESCRIPTION: This snippet shows how to configure QEMU to use the USB Attached SCSI protocol (usb-uas) with explicit SCSI device mapping. The example sets up a USB controller, a usb-uas device, and manually attaches multiple SCSI disks and a CD-ROM to it, mapping each drive to a logical unit number (LUN). Dependencies: QEMU with usb-uas and SCSI device support. Key parameters include individual image files for each SCSI device, explicit mapping via SCSI IDs/LUNs, and device relationships. Output is a VM with multiple LUNs on a single UAS device; the user must assign continuous LUNs and manage device order.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/usb-storage.txt#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nqemu ${other_vm_args}                                                \\\n     -drive if=none,id=uas-disk1,file=/path/to/file1.img             \\\n     -drive if=none,id=uas-disk2,file=/path/to/file2.img             \\\n     -drive if=none,id=uas-cdrom,media=cdrom,file=/path/to/image.iso \\\n     -device nec-usb-xhci,id=xhci                                    \\\n     -device usb-uas,id=uas,bus=xhci.0                               \\\n     -device scsi-hd,bus=uas.0,scsi-id=0,lun=0,drive=uas-disk1       \\\n     -device scsi-hd,bus=uas.0,scsi-id=0,lun=1,drive=uas-disk2       \\\n     -device scsi-cd,bus=uas.0,scsi-id=0,lun=5,drive=uas-cdrom\n```\n\n----------------------------------------\n\nTITLE: Accessing OS Resource Information via C API Functions\nDESCRIPTION: This C snippet provides function prototypes from the COSI OS resource APIs to retrieve and free process, thread, and file information. Functions expect prior setup with PANDA's CPUState and return direct pointers to data structures or derived information like process names and file handles. Correct resource lifetime handling via provided free functions is essential; typenames assume prior knowledge of COSI or PANDA core structures.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/cosi/README.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct CosiProc *get_current_cosiproc(CPUState *cpu);\nvoid free_process(struct CosiProc *proc);\nchar *cosi_proc_name(const struct CosiProc *proc);\nstruct CosiFiles *cosi_proc_files(const struct CosiProc);\nstruct CosiThread *get_current_cosithread(CPUState *cpu);\nvoid free_thread(struct CosiThread *thread);\nstruct CosiFiles *get_current_files(CPUState *cpu);\nuintptr_t cosi_files_len(const struct CosiFiles *files);\nconst struct CosiFile *cosi_files_get(const struct CosiFiles *files, uintptr_t index);\nconst struct CosiFile *cosi_files_file_from_fd(const struct CosiFiles *files, uint32_t fd);\nvoid free_cosi_files(struct CosiFiles *files);\nchar *cosi_file_name(const struct CosiFile *file);\n```\n\n----------------------------------------\n\nTITLE: Declaring NT Native API System Call Prototypes - Windows NT - C\nDESCRIPTION: This snippet declares multiple NTSTATUS-returning function prototypes for the Windows NT Native API, expressed as C external function declarations. Each prototype corresponds to a low-level OS operation, exposing direct system call interfaces unavailable in the standard Win32 API. Usage requires including the relevant Windows headers (such as winternl.h), and linking against the native system libraries. Parameters typically use NT kernel types (e.g., HANDLE, PUNICODE_STRING, etc.), and functions return an NTSTATUS value indicating success or failure. These are intended for advanced users needing direct access to undocumented NT features, and callers must consider privilege, compatibility, and stability implications.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp12_x86_prototypes.txt#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSecureConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PSID RequiredServerSid, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\nNTSTATUS NtSetBootEntryOrder (PULONG Ids, ULONG Count);\nNTSTATUS NtSetBootOptions (PBOOT_OPTIONS BootOptions, ULONG FieldsToChange);\nNTSTATUS NtSetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nNTSTATUS NtSetDebugFilterState (ULONG ComponentId, ULONG Level, BOOLEAN State);\nNTSTATUS NtSetDefaultHardErrorPort (HANDLE DefaultHardErrorPort);\nNTSTATUS NtSetDefaultLocale (BOOLEAN UserProfile, LCID DefaultLocaleId);\nNTSTATUS NtSetDefaultUILanguage (LANGID DefaultUILanguageId);\nNTSTATUS NtSetDriverEntryOrder (PULONG Ids, ULONG Count);\nNTSTATUS NtSetEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\nNTSTATUS NtSetEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtSetEventBoostPriority (HANDLE EventHandle);\nNTSTATUS NtSetHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetHighWaitLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetInformationDebugObject (HANDLE DebugObjectHandle, DEBUGOBJECTINFOCLASS DebugObjectInformationClass, PVOID DebugInformation, ULONG DebugInformationLength, PULONG ReturnLength);\nNTSTATUS NtSetInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\nNTSTATUS NtSetInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength);\nNTSTATUS NtSetInformationKey (HANDLE KeyHandle, KEY_SET_INFORMATION_CLASS KeySetInformationClass, PVOID KeySetInformation, ULONG KeySetInformationLength);\nNTSTATUS NtSetInformationObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength);\nNTSTATUS NtSetInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);\nNTSTATUS NtSetInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);\nNTSTATUS NtSetInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength);\nNTSTATUS NtSetIntervalProfile (ULONG Interval, KPROFILE_SOURCE Source);\nNTSTATUS NtSetIoCompletion (HANDLE IoCompletionHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);\nNTSTATUS NtSetLdtEntries (ULONG Selector0, ULONG Entry0Low, ULONG Entry0Hi, ULONG Selector1, ULONG Entry1Low, ULONG Entry1Hi);\nNTSTATUS NtSetLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetLowWaitHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\nNTSTATUS NtSetSecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);\nNTSTATUS NtSetSystemEnvironmentValue (PUNICODE_STRING VariableName, PUNICODE_STRING VariableValue);\nNTSTATUS NtSetSystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, ULONG ValueLength, ULONG Attributes);\nNTSTATUS NtSetSystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);\nNTSTATUS NtSetSystemPowerState (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags);\nNTSTATUS NtSetSystemTime (PLARGE_INTEGER SystemTime, PLARGE_INTEGER PreviousTime);\nNTSTATUS NtSetThreadExecutionState (EXECUTION_STATE esFlags, PEXECUTION_STATE PreviousFlags);\nNTSTATUS NtSetTimer (HANDLE TimerHandle, PLARGE_INTEGER DueTime, PTIMER_APC_ROUTINE TimerApcRoutine, PVOID TimerContext, BOOLEAN WakeTimer, LONG Period, PBOOLEAN PreviousState);\nNTSTATUS NtSetTimerResolution (ULONG DesiredTime, BOOLEAN SetResolution, PULONG ActualTime);\nNTSTATUS NtSetUuidSeed (PCHAR Seed);\nNTSTATUS NtSetValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);\nNTSTATUS NtSetVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtShutdownSystem (SHUTDOWN_ACTION Action);\nNTSTATUS NtSignalAndWaitForSingleObject (HANDLE SignalHandle, HANDLE WaitHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtStartProfile (HANDLE ProfileHandle);\nNTSTATUS NtStopProfile (HANDLE ProfileHandle);\nNTSTATUS NtSuspendProcess (HANDLE ProcessHandle);\nNTSTATUS NtSuspendThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtSystemDebugControl (SYSDBG_COMMAND Command, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, PULONG ReturnLength);\nNTSTATUS NtTerminateJobObject (HANDLE JobHandle, NTSTATUS ExitStatus);\nNTSTATUS NtTerminateProcess (HANDLE ProcessHandle, NTSTATUS ExitStatus);\nNTSTATUS NtTerminateThread (HANDLE ThreadHandle, NTSTATUS ExitStatus);\nNTSTATUS NtTestAlert ();\nNTSTATUS NtThawRegistry ();\nNTSTATUS NtThawTransactions ();\nNTSTATUS NtTraceEvent (HANDLE TraceHandle, ULONG Flags, ULONG FieldSize, PVOID Fields);\nNTSTATUS NtTraceControl (ULONG FunctionCode, PVOID InBuffer, ULONG InBufferLen, PVOID OutBuffer, ULONG OutBufferLen, PULONG ReturnLength);\nNTSTATUS NtTranslateFilePath (PFILE_PATH InputFilePath, ULONG OutputType, PFILE_PATH OutputFilePath, PULONG OutputFilePathLength);\nNTSTATUS NtUnloadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtUnloadKey (POBJECT_ATTRIBUTES TargetKey);\nNTSTATUS NtUnloadKey2 (POBJECT_ATTRIBUTES TargetKey, ULONG Flags);\nNTSTATUS NtUnloadKeyEx (POBJECT_ATTRIBUTES TargetKey, HANDLE Event);\nNTSTATUS NtUnlockFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key);\nNTSTATUS NtUnlockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtUnmapViewOfSection (HANDLE ProcessHandle, PVOID BaseAddress);\nNTSTATUS NtVdmControl (VDMSERVICECLASS Service, PVOID ServiceData);\nNTSTATUS NtWaitForDebugEvent (HANDLE DebugObjectHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PDBGUI_WAIT_STATE_CHANGE WaitStateChange);\nNTSTATUS NtWaitForMultipleObjects (ULONG Count, HANDLE Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitForSingleObject (HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtWaitLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtWriteFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtWriteFileGather (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtWriteRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\nNTSTATUS NtWriteVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\nNTSTATUS NtYieldExecution ();\nNTSTATUS NtCreateKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\nNTSTATUS NtOpenKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtReleaseKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitForKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtQueryPortInformationProcess ();\nULONG NtGetCurrentProcessorNumber ();\nNTSTATUS NtWaitForMultipleObjects32 (ULONG Count, LONG Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtGetNextProcess (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewProcessHandle);\nNTSTATUS NtGetNextThread (HANDLE ProcessHandle, HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewThreadHandle);\nNTSTATUS NtCancelIoFileEx (HANDLE FileHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtCancelSynchronousIoFile (HANDLE ThreadHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtRemoveIoCompletionEx (HANDLE IoCompletionHandle, PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation, ULONG Count, PULONG NumEntriesRemoved, PLARGE_INTEGER Timeout, BOOLEAN Alertable);\nNTSTATUS NtRegisterProtocolAddressInformation (HANDLE ResourceManager, PCRM_PROTOCOL_ID ProtocolId, ULONG ProtocolInformationSize, PVOID ProtocolInformation, ULONG CreateOptions);\nNTSTATUS NtPropagationComplete (HANDLE ResourceManagerHandle, ULONG RequestCookie, ULONG BufferLength, PVOID Buffer);\nNTSTATUS NtPropagationFailed (HANDLE ResourceManagerHandle, ULONG RequestCookie, NTSTATUS PropStatus);\nNTSTATUS NtCreateWorkerFactory (PHANDLE WorkerFactoryHandleReturn, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE CompletionPortHandle, HANDLE WorkerProcessHandle, PVOID StartRoutine, PVOID StartParameter, ULONG MaxThreadCount, SIZE_T StackReserve, SIZE_T StackCommit);\n```\n\n----------------------------------------\n\nTITLE: Implementing HMP Command Wrapper - C for QEMU\nDESCRIPTION: This C function implements the HMP counterpart for the 'hello-world' command by wrapping the underlying QMP interface. It retrieves the 'message' argument from the monitor argument dictionary, invokes the QMP handler function, and manages errors by presenting them to the user. Required dependencies include monitor infrastructure, QDict for arguments, and familiarity with QMP invocation patterns. Expected input is a message argument; output is displayed via the monitor interface, with error feedback as needed.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/writing-qmp-commands.txt#_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nvoid hmp_hello_world(Monitor *mon, const QDict *qdict)\n{\n    const char *message = qdict_get_try_str(qdict, \"message\");\n    Error *err = NULL;\n\n    qmp_hello_world(!!message, message, &err);\n    if (err) {\n        monitor_printf(mon, \"%s\\n\", error_get_pretty(err));\n        error_free(err);\n        return;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Has Mapping Prefix Callback Typedef in C\nDESCRIPTION: Declares a callback typedef for checking if any loaded mapping has a name prefix (string match) for a given process. Can be used for fast existence queries (e.g., whether a library or module with a certain prefix is loaded). Receives CPUState, OsiProc, a prefix string, and outputs a bool indicating presence.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_18\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_has_mapping_prefix_t)(CPUState *, OsiProc *, char *, bool *)\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Features for Multiple Architectures - Rust - toml\nDESCRIPTION: Defines architecture-specific build features in the Cargo.toml file via the [features] section, enabling conditional plugin compilation per guest architecture. The default feature is x86_64, while further entries activate support for ARM, MIPS, PPC, and others. Features are referenced in build commands and by #[cfg] attributes in code.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/rust_skeleton/README.md#_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[features]\ndefault = [\"x86_64\"]\n\nx86_64 = [\"panda-re/x86_64\"]\ni386 = [\"panda-re/i386\"]\narm = [\"panda-re/arm\"]\nppc = [\"panda-re/ppc\"]\nmips = [\"panda-re/mips\"]\nmipsel = [\"panda-re/mipsel\"]\n```\n\n----------------------------------------\n\nTITLE: QEMU Default Configuration Example for x86_64 System Emulation\nDESCRIPTION: Example from default-configs/x86_64-softmmu.mak showing how hardware components are enabled for the x86_64 system emulator through configuration variables.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/build-system.txt#_snippet_6\n\nLANGUAGE: Makefile\nCODE:\n```\ninclude pci.mak\ninclude sound.mak\ninclude usb.mak\nCONFIG_QXL=$(CONFIG_SPICE)\nCONFIG_VGA_ISA=y\nCONFIG_VGA_CIRRUS=y\nCONFIG_VMWARE_VGA=y\nCONFIG_VIRTIO_VGA=y\n...snip...\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Calls in C\nDESCRIPTION: This snippet declares multiple Windows NT system calls as function prototypes. These functions cover a wide range of system operations including debug control, job management, registry operations, driver loading/unloading, file operations, and event handling. The declarations specify the function names, parameters, and return types for various low-level system operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp12_x64_prototypes.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSystemDebugControl (SYSDBG_COMMAND Command, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, PULONG ReturnLength);\nNTSTATUS NtTerminateJobObject (HANDLE JobHandle, NTSTATUS ExitStatus);\nNTSTATUS NtTestAlert ();\nNTSTATUS NtThawRegistry ();\nNTSTATUS NtThawTransactions ();\nNTSTATUS NtTraceControl (ULONG FunctionCode, PVOID InBuffer, ULONG InBufferLen, PVOID OutBuffer, ULONG OutBufferLen, PULONG ReturnLength);\nNTSTATUS NtTranslateFilePath (PFILE_PATH InputFilePath, ULONG OutputType, PFILE_PATH OutputFilePath, PULONG OutputFilePathLength);\nNTSTATUS NtUnloadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtUnloadKey (POBJECT_ATTRIBUTES TargetKey);\nNTSTATUS NtUnloadKey2 (POBJECT_ATTRIBUTES TargetKey, ULONG Flags);\nNTSTATUS NtUnloadKeyEx (POBJECT_ATTRIBUTES TargetKey, HANDLE Event);\nNTSTATUS NtUnlockFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key);\nNTSTATUS NtUnlockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtVdmControl (VDMSERVICECLASS Service, PVOID ServiceData);\nNTSTATUS NtWaitForDebugEvent (HANDLE DebugObjectHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PDBGUI_WAIT_STATE_CHANGE WaitStateChange);\nNTSTATUS NtWaitForKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitForWorkViaWorkerFactory (HANDLE WorkerFactoryHandle, PFILE_IO_COMPLETION_INFORMATION MiniPacket);\nNTSTATUS NtWaitHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtWaitLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtWorkerFactoryWorkerReady (HANDLE WorkerFactoryHandle);\n```\n\n----------------------------------------\n\nTITLE: Advanced Barrier Pairing with Data Dependencies - C\nDESCRIPTION: Provides a multi-step example with multiple stores and memory barriers in the writer thread and corresponding reads and data dependency barriers (smp_read_barrier_depends()) in the reader thread. Useful for illustrating the importance of both memory order and data dependencies for safe concurrent access to complex shared state (arrays and structs). Requires C/QEMU atomic/barrier support. Correct variable ordering and visibility is ensured by the sequence and placement of barriers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/atomics.txt#_snippet_10\n\nLANGUAGE: C\nCODE:\n```\nthread 1             thread 2\\n===============      ===============\\nb[2] = 1;\\nsmp_wmb();\\nx->i = 2;\\nsmp_wmb();\\na = x;               x = a;\\n                     smp_read_barrier_depends();\\n                     y = x->i;\\n                     smp_read_barrier_depends();\\n                     z = b[y];\n```\n\n----------------------------------------\n\nTITLE: Verifying Extracted TLS Keys with Keychecker.py (Python, Shell)\nDESCRIPTION: This shell command runs a Python script ('keychecker.py') that verifies candidate cryptographic keys against a packet capture of a TLS session. It relies on pyshark for parsing the pcap file. Inputs: packet capture (tls_session.pcap) and candidate key file (key_candidates.txt) from keyfind. Output: verified_keys.txt, using OpenSSL-compatible format. Dependency: pyshark (install with pip).\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/keyfind/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npython keychecker.py tls_session.pcap key_candidates.txt\n```\n\n----------------------------------------\n\nTITLE: Registering HMP Info Command - C Structure Example\nDESCRIPTION: This structure registers the 'info alarmclock' HMP command within QEMU's monitor.c info_cmds array. It links the user command name, parameters, help string, and the previously implemented handler function, enabling user access through the monitor. No arguments are required, and the pattern shown matches the regular procedure for exposing informational commands in HMP.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/writing-qmp-commands.txt#_snippet_13\n\nLANGUAGE: c\nCODE:\n```\n{\n    .name       = \"alarmclock\",\n    .args_type  = \"\",\n    .params     = \"\",\n    .help       = \"show information about the alarm clock\",\n    .cmd        = hmp_info_alarm_clock,\n},\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Call Prototypes in C\nDESCRIPTION: This snippet lists function prototypes for NT system services in C, directly mapping to undocumented or documented Windows Native API calls. Each entry declares the function's signature, expected input/output parameters, and type structures, meant to be included in a header file for linking with a corresponding NT DLL or for use in kernel modules. The usage of NTSTATUS and HANDLE types reflects reliance on Windows internal data structures, and these declarations require prior definitions for types like PVOID, HANDLE, ACCESS_MASK, etc.; suitable for low-level system development and reverse engineering.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp12_x86_prototypes.txt#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDuplicateToken (HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);\nNTSTATUS NtEnumerateBootEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateDriverEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateKey (HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtEnumerateSystemEnvironmentValuesEx (ULONG InformationClass, PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateTransactionObject (HANDLE RootObjectHandle, KTMOBJECT_TYPE QueryType, PKTMOBJECT_CURSOR ObjectCursor, ULONG ObjectCursorLength, PULONG ReturnLength);\nNTSTATUS NtEnumerateValueKey (HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);\nNTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);\nNTSTATUS NtFindAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\nNTSTATUS NtFlushBuffersFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);\nNTSTATUS NtFlushKey (HANDLE KeyHandle);\nVOID NtFlushProcessWriteBuffers ();\nNTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);\nNTSTATUS NtFlushWriteBuffer ();\nNTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG FreeType);\nNTSTATUS NtFreezeRegistry (ULONG TimeOutInSeconds);\nNTSTATUS NtFreezeTransactions (PLARGE_INTEGER FreezeTimeout, PLARGE_INTEGER ThawTimeout);\nNTSTATUS NtFsControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nNTSTATUS NtGetDevicePowerState (HANDLE Device, DEVICE_POWER_STATE *State);\nNTSTATUS NtGetNlsSectionPtr (ULONG SectionType, ULONG SectionData, PVOID ContextData, PVOID *SectionPointer, PULONG SectionSize);\nNTSTATUS NtGetPlugPlayEvent (HANDLE EventHandle, PVOID Context, PPLUGPLAY_EVENT_BLOCK EventBlock, ULONG EventBufferSize);\nNTSTATUS NtGetWriteWatch (HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, SIZE_T RegionSize, PVOID *UserAddressArray, PULONG_PTR EntriesInUserAddressArray, PULONG Granularity);\nNTSTATUS NtImpersonateAnonymousToken (HANDLE ThreadHandle);\nNTSTATUS NtImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE Message);\nNTSTATUS NtImpersonateThread (HANDLE ServerThreadHandle, HANDLE ClientThreadHandle, PSECURITY_QUALITY_OF_SERVICE SecurityQos);\nNTSTATUS NtInitializeNlsFiles (PVOID *BaseAddress, PLCID DefaultLocaleId, PLARGE_INTEGER DefaultCasingTableSize);\nNTSTATUS NtInitializeRegistry (USHORT BootCondition);\nNTSTATUS NtInitiatePowerAction (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);\nNTSTATUS NtIsProcessInJob (HANDLE ProcessHandle, HANDLE JobHandle);\nBOOLEAN NtIsSystemResumeAutomatic ();\nNTSTATUS NtListenPort (HANDLE PortHandle, PPORT_MESSAGE ConnectionRequest);\nNTSTATUS NtLoadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtLoadKey (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile);\nNTSTATUS NtLoadKey2 (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags);\nNTSTATUS NtLoadKeyEx (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags, HANDLE TrustClassKey );\nNTSTATUS NtLockFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);\nNTSTATUS NtLockProductActivationKeys (ULONG *pPrivateVer, ULONG *pSafeMode);\nNTSTATUS NtLockRegistryKey (HANDLE KeyHandle);\nNTSTATUS NtLockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtMakePermanentObject (HANDLE Handle);\nNTSTATUS NtMakeTemporaryObject (HANDLE Handle);\nNTSTATUS NtMapUserPhysicalPages (PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, WIN32_PROTECTION_MASK Win32Protect);\nNTSTATUS NtModifyBootEntry (PBOOT_ENTRY BootEntry);\nNTSTATUS NtModifyDriverEntry (PEFI_DRIVER_ENTRY DriverEntry);\nNTSTATUS NtNotifyChangeDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree);\nNTSTATUS NtNotifyChangeKey (HANDLE KeyHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtNotifyChangeMultipleKeys (HANDLE MasterKeyHandle, ULONG Count, OBJECT_ATTRIBUTES SlaveObjects[], HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtOpenDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);\nNTSTATUS NtOpenIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE TransactionHandle);\nNTSTATUS NtOpenMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenPrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\nNTSTATUS NtOpenObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, ACCESS_MASK GrantedAccess, PPRIVILEGE_SET Privileges, BOOLEAN ObjectCreation, BOOLEAN AccessGranted, PBOOLEAN GenerateOnClose);\nNTSTATUS NtOpenProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenProcessToken (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);\nNTSTATUS NtOpenProcessTokenEx (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSession (PHANDLE SessionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenThreadToken (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);\nNTSTATUS NtOpenThreadTokenEx (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtPlugPlayControl (PLUGPLAY_CONTROL_CLASS PnPControlClass, PVOID PnPControlData, ULONG PnPControlDataLength);\nNTSTATUS NtPowerInformation (POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtPrivilegeCheck (HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, PBOOLEAN Result);\nNTSTATUS NtPrivilegeObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\nNTSTATUS NtPrivilegedServiceAuditAlarm (PUNICODE_STRING SubsystemName, PUNICODE_STRING ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\n```\n\n----------------------------------------\n\nTITLE: Configuring PANDA Build for Android Support (Shell)\nDESCRIPTION: This shell snippet modifies and executes PANDA's build configuration for Android support by setting flags for target architecture, installation prefix, enabling/disabling components, and passing specific compilation/linking options. It requires a functioning build environment and software dependencies such as LLVM and protobuf-c. Parameters configure emulator target, Android build, and library search paths. The output is a ready-to-build PANDA tree for replaying Android ARM traces. Users must change values as appropriate for their environment.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/LINE_Censorship.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n./configure --target-list=arm-softmmu \\\n--prefix=\\`pwd\\`/install \\\n--enable-android \\\n--disable-pie \\\n--disable-xen \\\n--disable-libiscsi \\\n$LLVM_BIT \\\n--extra-cflags=\"-O2 -I/usr/local/include\" \\\n--extra-cxxflags=\"-O2\" \\\n--extra-ldflags=\"-L/usr/local/lib -L/usr/local/lib64 -L/usr/local/lib -lprotobuf-c -lprotobuf -lpthread\"\n```\n\n----------------------------------------\n\nTITLE: Reentrant Safe Traversal with Reference Counter in C\nDESCRIPTION: This snippet introduces a walking_handlers counter to make a QLIST traversal reentrant-safe. It increments the counter before walking the list and decrements afterward, only removing and freeing nodes if they are deleted and this is the last traversal. The pattern supports reentrancy but requires manual management of the walking_handlers variable and synchronization if thread safety is needed.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/lockcnt.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nwalking_handlers++;\nQLIST_FOREACH_SAFE(ioh, &io_handlers, next, pioh) {\n    if (ioh->deleted) {\n        if (walking_handlers == 1) {\n            QLIST_REMOVE(ioh, next);\n            g_free(ioh);\n        }\n    } else {\n        if (ioh->revents & G_IO_OUT) {\n            ioh->fd_write(ioh->opaque);\n        }\n    }\n}\nwalking_handlers--;\n```\n\n----------------------------------------\n\nTITLE: Presenting asidstory Plugin Output Samples - Text/ASCII - English\nDESCRIPTION: This snippet provides a sample of the asidstory output file, showcasing both tabular process tracing data and ASCII visualizations. The 'Count' column shows the observed counts, with PIDs, process/thread names, ASID values, and first/last instruction IDs demarcating lifetimes. The ASCII art section visualizes process activity over the duration of the replay. No dependencies are required to interpret the plain text, but understanding PANDA's replay and asidstory plugin is needed to fully comprehend the meaning. The snippet is representative output and not executable code; its structure is fixed in width and content for proper alignment.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/asidstory/README.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n  Count   Pid              Name/tid      Asid    First         Last\\n    239     0          [Idle  / 0]4     39000  5169232  ->  7821664\\n    218   408    [csrss.exe  / 424]   6330000   437610  ->  6965698\\n    209   408    [csrss.exe  / 440]   6330000   441751  ->  7752438\\n    180   408    [csrss.exe  / 444]   6330000   870406  ->  7826129\\n    180     4        [System  / 24]     39000  2820706  ->  7818745\\n    142   264  [win_mt_sf_moref  /    c5ae000   331261  ->  4065153\\n    118     0           [Idle  / 0]     39000   926850  ->  7747954\\n    115     4       [System  / 296]     39000   258436  ->  7746411\\n     56     4       [System  / 256]     39000   448435  ->  6951671\\n     53     0          [Idle  / 0]2     39000   926903  ->  6957618\\n     51  1732  [explorer.exe  / 172   a64c000   258336  ->  5523697\\n     44   264  [win_mt_sf_moref  /2   c5ae000   439870  ->  3641250\\n     35   236     [cmd.exe  / 240]2   c580000  4070318  ->  5093133\\n     33     0         [Idle  / 0]12     39000  7445624  ->  7498470\\n     30   236      [cmd.exe  / 240]   c580000  4068146  ->  5110839\\n     24     4      [System  / 296]5     39000  5926559  ->  7496789\\n     19   236     [cmd.exe  / 240]5   c580000  4201362  ->  5050839\\n     19     0         [Idle  / 0]10     39000  6383046  ->  7121383\\n     19     4       [System  / 56]2     39000  6363377  ->  7122094\\n     17  1732  [explorer.exe  / 174   a64c000  4194681  ->  6720140\\n     16     0          [Idle  / 0]7     39000  5643867  ->  5688941\\n     15     4      [System  / 256]2     39000  5587581  ->  5619891\\n     15     0          [Idle  / 0]6     39000  5591977  ->  5619170\\n     15   408   [csrss.exe  / 444]5   6330000  5927154  ->  7493614\\n     13   408   [csrss.exe  / 424]2   6330000  2041793  ->  6632892\\n     12   488   [lsass.exe  / 1200]   6810000  5639932  ->  7770937\\n     12   408   [csrss.exe  / 444]3   6330000  5586087  ->  5627918\\n     12   408   [csrss.exe  / 440]6   6330000  4199056  ->  5075816\\n     12  1732  [explorer.exe  / 173   a64c000  6187778  ->  6469198\\n     10  1724  [wuauclt.exe  / 1760   a5ff000  5523797  ->  7662295\\n      9   800  [svchost.exe  / 824]   76d7000  6749178  ->  7433837\\n      9   408   [csrss.exe  / 244]2   6330000  5214029  ->  5217617\\n      9     4      [System  / 296]2     39000  5645346  ->  5659537\\n      9     0         [Idle  / 0]14     39000  7662448  ->  7670159\\n      8   800  [svchost.exe  / 440]   76d7000  6770867  ->  6823448\\n      7  1732  [explorer.exe  / 173   a64c000  4182542  ->  6651801\\n      7   264  [win_mt_sf_moref  /9   c5ae000  3644088  ->  3716256\\n      7   264  [win_mt_sf_moref  /6   c5ae000   940235  ->  4070177\\n      7   432  [winlogon.exe  / 168   64f5000  7498620  ->  7579810\\n      6   408   [csrss.exe  / 444]4   6330000  5647165  ->  5663894\\n      6   408    [csrss.exe  / 244]   6330000  5213923  ->  5737277\\n      6   408   [csrss.exe  / 440]8   6330000  6769697  ->  6774012\\n      6     4      [System  / 296]6     39000  7663974  ->  7669090\\n      6   408   [csrss.exe  / 440]2   6330000   630632  ->  3725004\\n      5   408   [csrss.exe  / 448]4   6330000  6237099  ->  6272939\\n      5   408    [csrss.exe  / 448]   6330000  5815589  ->  5860225\\n      5  1732  [explorer.exe  / 175   a64c000  5177175  ->  5213823\\n      5   264  [win_mt_sf_moref  /    c5ae000   629367  ->   632848\\n      5   236     [cmd.exe  / 240]4   c580000  4201308  ->  5073608\\n      4  1732  [explorer.exe  / 173   a64c000  5929375  ->  5950133\\n      4   408   [csrss.exe  / 448]3   6330000  5980882  ->  6015297\\n      4     0         [Idle  / 0]11     39000  6651953  ->  6684289\\n      4   408   [csrss.exe  / 448]2   6330000  5893740  ->  5926406\\n      4  1732  [explorer.exe  / 172   a64c000  6015818  ->  6034207\\n      4   264  [win_mt_sf_moref  /7   c5ae000  1040015  ->  1059118\\n      4  1732  [explorer.exe  / 174   a64c000  6363746  ->  6382894\\n      3   408   [csrss.exe  / 424]3   6330000  3641962  ->  3643935\\n      3   408   [csrss.exe  / 440]4   6330000  1092726  ->  1092732\\n      3   408   [csrss.exe  / 440]7   6330000  6769591  ->  6769597\\n      3     4      [System  / 296]3     39000  5702833  ->  5703395\\n      3   432  [winlogon.exe  / 468   64f5000  6988563  ->  6989494\\n      3   488  [lsass.exe  / 1200]3   6810000  7469208  ->  7472982\\n      3   408   [csrss.exe  / 440]5   6330000  1192807  ->  1192813\\n      3   488  [lsass.exe  / 1200]2   6810000  6850536  ->  6854310\\n      3   408   [csrss.exe  / 440]3   6330000  1059218  ->  1059224\\n      3     4       [System  / 56]3     39000  6633044  ->  6633260\\n      3     4       [System  / 68]2     39000  5739047  ->  5739731\\n      3     4       [System  / 64]3     39000  7579962  ->  7580369\\n      3  1724  [wuauclt.exe  / 1765   a5ff000  7304171  ->  7318616\\n      3     0          [Idle  / 0]8     39000  5703547  ->  5708410\\n      3  1724  [wuauclt.exe  / 1762   a5ff000  5523851  ->  5538392\\n      3     0          [Idle  / 0]3     39000  5164492  ->  5165445\\n      3  1724  [wuauclt.exe  / 1764   a5ff000  5739885  ->  5754338\\n      3     0         [Idle  / 0]13     39000  7583478  ->  7596724\\n      3   236     [cmd.exe  / 240]6   c580000  4205300  ->  4206819\\n      3   264  [win_mt_sf_moref  /8   c5ae000  1188325  ->  1192707\\n      3   264  [win_mt_sf_moref  /5   c5ae000   929661  ->   937391\\n      3     0          [Idle  / 0]9     39000  5737429  ->  5738898\\n      3  1732  [explorer.exe  / 176   a64c000  5214511  ->  5214738\\n      3   236     [cmd.exe  / 240]3   c580000  4197075  ->  4198956\\n      3   408   [csrss.exe  / 424]4   6330000  4210968  ->  4210974\\n      3   408   [csrss.exe  / 440]9   6330000  7580522  ->  7583326\\n      3   236     [cmd.exe  / 240]9   c580000  5095843  ->  5098450\\n      3   236     [cmd.exe  / 240]7   c580000  4213196  ->  4215084\\n      3     4       [System  / 24]3     39000  7091661  ->  7102036\\n      3     4        [System  / 64]     39000  3641402  ->  3641809\\n      3   408   [csrss.exe  / 444]2   6330000  5174942  ->  5176330\\n      3     4        [System  / 68]     39000  5176482  ->  5177022\\n      3   408   [csrss.exe  / 424]5   6330000  4211074  ->  4213043\\n      3     4        [System  / 56]     39000  6015449  ->  6015665\\n      3     4       [System  / 24]2     39000  5708559  ->  5716036\\n      3     4       [System  / 64]2     39000  7433989  ->  7435567\\n      2     0          [Idle  / 0]5     39000  5538492  ->  5538492\\n      2  1724  [wuauclt.exe  / 1763   a5ff000  5739831  ->  5739831\\n      2     4      [System  / 296]4     39000  5926506  ->  5926506\\n      2   236     [cmd.exe  / 240]8   c580000  5075916  ->  5075916\\n      2   408   [csrss.exe  / 448]5   6330000  6415824  ->  6415824\\n      2   264  [win_mt_sf_moref  /4   c5ae000   929610  ->   929610\\n      2   264  [win_mt_sf_moref  /3   c5ae000   462588  ->   462588\\n\\n[explorer.exe  / 172 : [#####                                             ###                      ]\\n     [System  / 296] : [  #   ##   #       #                  # #       ##   ###      #    #  #  ##]\\n[win_mt_sf_moref  /  : [   #########       #               ####                                    ]\\n  [csrss.exe  / 424] : [    # # #                  ########    ###########      # # ### ###        ]\\n[win_mt_sf_moref  /2 : [    # # ###                #      #                                        ]\\n  [csrss.exe  / 440] : [    # #  ###########                   ##       #    ### #    #    #  #  ##]\\n     [System  / 256] : [    #   # #                #                            # #   # ###        ]\\n[win_mt_sf_moref  /3 : [    #                                                                      ]\\n[win_mt_sf_moref  /  : [      #                                                                    ]\\n [csrss.exe  / 440]2 : [      #                            #                                       ]\\n  [csrss.exe  / 444] : [        #          ########        #    #       ##   ##   ### ### # #######]\\n         [Idle  / 0] : [        ##                                       #   ### #        ##  ## ##]\\n        [Idle  / 0]2 : [        #                                        #      #     ## ##        ]\\n[win_mt_sf_moref  /4 : [        #                                                                  ]\\n[win_mt_sf_moref  /5 : [        #                                                                  ]\\n[win_mt_sf_moref  /6 : [         #                        #    #                                   ]\\n[win_mt_sf_moref  /7 : [         ##                                                                ]\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows Native NTSTATUS System Call Prototypes in C/C++\nDESCRIPTION: This snippet declares the prototypes for multiple Windows Native API Nt* system calls as used in C or C++. These declarations provide the contract for low-level system call invocations, allowing client code to access native kernel or system services directly. Dependencies include the presence of appropriate Windows header files (for data types like HANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, etc.), and optionally linking or run-time locating routines from ntdll.dll. Parameters and return values vary per function, commonly involving object handles, access rights, option flags, and status/result pointers. These prototypes do not include implementationâ€”rather, they describe the expected signature for later definition or dynamic resolution. None of the functions are directly usable without further dynamic linking or definition.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/all_windows_prototypes.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);\nNTSTATUS NtCreateIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Count);\nNTSTATUS NtCreateJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateJobSet (ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);\nNTSTATUS NtCreateKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);\nNTSTATUS NtCreateKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, HANDLE TransactionHandle, PULONG Disposition);\nNTSTATUS NtCreateKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\nNTSTATUS NtCreateMailslotFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout);\nNTSTATUS NtCreateMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN InitialOwner);\nNTSTATUS NtCreateNamedPipeFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout);\nNTSTATUS NtCreatePagingFile (PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority);\nNTSTATUS NtCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtCreatePrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\nNTSTATUS NtCreateProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort);\nNTSTATUS NtCreateProcessEx (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel);\nNTSTATUS NtCreateProfile (PHANDLE ProfileHandle, HANDLE Process, PVOID RangeBase, SIZE_T RangeSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);\nNTSTATUS NtCreateProfileEx (PHANDLE ProfileHandle, HANDLE Process, PVOID ProfileBase, SIZE_T ProfileSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, ULONG GroupAffinityCount, PGROUP_AFFINITY GroupAffinity);\nNTSTATUS NtCreateResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID RmGuid, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, PUNICODE_STRING Description);\nNTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);\nNTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);\nNTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);\nNTSTATUS NtCreateThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended);\nNTSTATUS NtCreateThreadEx (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument, ULONG CreateFlags, ULONG_PTR ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, PPS_ATTRIBUTE_LIST AttributeList);\nNTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);\nNTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);\nNTSTATUS NtCreateTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle, ULONG CreateOptions, ULONG IsolationLevel, ULONG IsolationFlags, PLARGE_INTEGER Timeout, PUNICODE_STRING Description);\nNTSTATUS NtCreateTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, ULONG CreateOptions, ULONG CommitStrength);\nNTSTATUS NtCreateUserProcess (PHANDLE ProcessHandle, PHANDLE ThreadHandle, ACCESS_MASK ProcessDesiredAccess, ACCESS_MASK ThreadDesiredAccess, POBJECT_ATTRIBUTES ProcessObjectAttributes, POBJECT_ATTRIBUTES ThreadObjectAttributes, ULONG ProcessFlags, ULONG ThreadFlags, PRTL_USER_PROCESS_PARAMETERS ProcessParameters, PPROCESS_CREATE_INFO CreateInfo, PPROCESS_ATTRIBUTE_LIST AttributeList);\nNTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtCreateWorkerFactory (PHANDLE WorkerFactoryHandleReturn, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE CompletionPortHandle, HANDLE WorkerProcessHandle, PVOID StartRoutine, PVOID StartParameter, ULONG MaxThreadCount, SIZE_T StackReserve, SIZE_T StackCommit);\nNTSTATUS NtDebugActiveProcess (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtDebugContinue (HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);\nNTSTATUS NtDelayExecution (BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);\nNTSTATUS NtDeleteAtom (RTL_ATOM Atom);\nNTSTATUS NtDeleteBootEntry (ULONG Id);\nNTSTATUS NtDeleteDriverEntry (ULONG Id);\nNTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtDeleteKey (HANDLE KeyHandle);\nNTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtDeletePrivateNamespace (HANDLE NamespaceHandle);\nNTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);\nNTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtDisableLastKnownGood ();\nNTSTATUS NtDisplayString (PUNICODE_STRING String);\nNTSTATUS NtDrawText (PUNICODE_STRING Text);\nNTSTATUS NtDuplicateObject (HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);\nNTSTATUS NtDuplicateToken (HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);\nNTSTATUS NtEnableLastKnownGood ();\nNTSTATUS NtEnumerateBootEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateDriverEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateKey (HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtEnumerateSystemEnvironmentValuesEx (ULONG InformationClass, PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateTransactionObject (HANDLE RootObjectHandle, KTMOBJECT_TYPE QueryType, PKTMOBJECT_CURSOR ObjectCursor, ULONG ObjectCursorLength, PULONG ReturnLength);\nNTSTATUS NtEnumerateValueKey (HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);\nNTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);\nNTSTATUS NtFindAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\nNTSTATUS NtFlushBuffersFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtFlushInstallUILanguage (LANGID InstallUILanguage, ULONG SetComittedFlag);\nNTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);\nNTSTATUS NtFlushKey (HANDLE KeyHandle);\nVOID NtFlushProcessWriteBuffers ();\nNTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);\nNTSTATUS NtFlushWriteBuffer ();\nNTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG FreeType);\nNTSTATUS NtFreezeRegistry (ULONG TimeOutInSeconds);\nNTSTATUS NtFreezeTransactions (PLARGE_INTEGER FreezeTimeout, PLARGE_INTEGER ThawTimeout);\n```\n\n----------------------------------------\n\nTITLE: API Utility Function Prototypes for Querying System Call Return Values and Info in PANDA syscalls2 (C)\nDESCRIPTION: These C API function prototypes allow a PANDA plugin developer to query the return value of the current system call or to obtain metadata associated with system calls, contingent on plugin initialization flags. `get_syscall_retval` retrieves the architecture-abstracted return value after a syscall, requiring invocation in the corresponding return context; `get_syscall_info` and `get_syscall_meta` provide detailed syscall information structures, only available when the plugin's 'load-info' argument is enabled. The expected input is a CPU state pointer or a syscall number as required, and output is a struct pointer or value relevant to the syscall; these functions require inclusion of appropriate PANDA or QEMU headers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\ntarget_long get_syscall_retval(CPUState *cpu)\n```\n\nLANGUAGE: C\nCODE:\n```\nconst syscall_info_t *get_syscall_info(uint32_t callno)\n```\n\nLANGUAGE: C\nCODE:\n```\nconst syscall_meta_t *get_syscall_meta(void)\n```\n\n----------------------------------------\n\nTITLE: SchemaInfo for Alternate Type with Multiple Members - JSON\nDESCRIPTION: This object describes SchemaInfo for an 'alternate' type, which can be either a 'BlockdevOptions' object or a string ('str'). It illustrates how alternates are listed by type in the 'members' array, showing that values must match exactly one of the listed types for the wire format to be valid.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_18\n\nLANGUAGE: json\nCODE:\n```\n{ \\\"name\\\": \\\"BlockdevRef\\\", \\\"meta-type\\\": \\\"alternate\\\",\\n  \\\"members\\\": [\\n      { \\\"type\\\": \\\"BlockdevOptions\\\" },\\n      { \\\"type\\\": \\\"str\\\" } ] }\n```\n\n----------------------------------------\n\nTITLE: Declaring File System Access and Manipulation System Calls in C for FreeBSD\nDESCRIPTION: This snippet declares system calls for file system access and manipulation in FreeBSD, including functions for checking permissions, changing ownership, and creating directories and special files.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_23\n\nLANGUAGE: C\nCODE:\n```\nint faccessat(int fd, const char *path, int amode, int flag);\nint fchmodat(int fd, const char *path, mode_t mode, int flag);\nint fchownat(int fd, const char *path, uid_t uid, gid_t gid, int flag);\nint fexecve(int fd, char **argv, char **envv);\nint fstatat(int fd, const char *path, struct freebsd11_stat *buf, int flag);\nint futimesat(int fd, const char *path, struct timeval *times);\nint linkat(int fd1, const char *path1, int fd2, const char *path2, int flag);\nint mkdirat(int fd, const char *path, mode_t mode);\nint mkfifoat(int fd, const char *path, mode_t mode);\nint mknodat(int fd, const char *path, mode_t mode, uint32_t dev);\nint openat(int fd, const char *path, int flag, mode_t mode);\nssize_t readlinkat(int fd, const char *path, char *buf, size_t bufsize);\nint renameat(int oldfd, const char *old, int newfd, const char *new);\nint symlinkat(const char *path1, int fd, const char *path2);\nint unlinkat(int fd, const char *path, int flag);\n```\n\n----------------------------------------\n\nTITLE: Truncation, Zero-Extension, and State Logging - LLVM IR\nDESCRIPTION: This snippet truncates a computed address, zero-extends the result, logs state, and stores it back to the register pointer. It also triggers a read-modify-store pattern on environment offsets to update counters, enabling traceability of memory operations in the emulated architecture. Dependencies include PANDA log helpers, memory accesses, and address arithmetic.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/dynslice.md#_snippet_12\n\nLANGUAGE: llvm\nCODE:\n```\n%45 = trunc i64 %tmp2_v10 to i32\n```\n\nLANGUAGE: llvm\nCODE:\n```\n%tmp-12_v12 = zext i32 %45 to i64\n%46 = ptrtoint i64* %rsp_ptr to i64\ncall void @log_dynval(i64 59634320, i32 0, i32 2, i64 %46)\nstore i64 %tmp-12_v12, i64* %rsp_ptr\n%47 = add i64 %env_v, 128\n%48 = inttoptr i64 %47 to i64*\n%49 = ptrtoint i64* %48 to i64\ncall void @log_dynval(i64 59634320, i32 0, i32 0, i64 %49)\n%tmp4_v13 = load i64* %48\n%tmp4_v14 = add i64 %tmp4_v13, 1\n%50 = add i64 %env_v, 128\n%51 = inttoptr i64 %50 to i64*\n%52 = ptrtoint i64* %51 to i64\ncall void @log_dynval(i64 59634320, i32 0, i32 2, i64 %52)\nstore i64 %tmp4_v14, i64* %51\n```\n\n----------------------------------------\n\nTITLE: Recording TLS Session with QEMU PANDA and Packet Capture (Shell)\nDESCRIPTION: This shell command launches the PANDA-enabled QEMU with networking configured to produce a packet capture file. It initiates the virtual machine with dumping enabled to store all network traffic to the provided file for later analysis. Required: QEMU with PANDA, proper environment setup. Output: tls_session.pcap. No inputs except for environment variables and installation prerequisites.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/keyfind/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/qemu-system-x86_64 \\\n    -net dump,file=tls_session.pcap\n```\n\n----------------------------------------\n\nTITLE: Command Execution JSON Structure in QMP\nDESCRIPTION: Specifies the JSON structure for executing commands in QMP. It includes the command name, optional arguments, and an optional transaction ID.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qmp-spec.txt#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{ \"execute\": json-string, \"arguments\": json-object, \"id\": json-value }\n```\n\n----------------------------------------\n\nTITLE: Declaring After Block Translate Callback Signature in PANDA (C)\nDESCRIPTION: Defines the function pointer type for running plugin-provided logic after a basic block has been translated, with exposure to the translation block for further analysis or manipulation. Requires PANDA structures (CPUState, TranslationBlock); returns an integer (unused). Used for post-processing or inspection, with parameters for current CPU and translated block.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_31\n\nLANGUAGE: C\nCODE:\n```\nint (*after_block_translate)(CPUState *env, TranslationBlock *tb);\n```\n\n----------------------------------------\n\nTITLE: Running PANDA Use-After-Free Detection Plugin via Command Line in Shell\nDESCRIPTION: This shell snippet demonstrates how to launch a PANDA dynamic analysis session with the use-after-free detection plugin enabled against a deterministic replay session. It presupposes that PANDA is installed and rebuilt with the callstack_instr and useafterfree plugins and that a compatible replay recording is available. The key parameters are the display mode (headless), memory allocation, the path to the replay session, and the exact plugins used; outputs include detection logs that highlight memory errors, including specific use-after-free events. This approach is constrained to PANDA's supported replay files, plugins, and instrumentation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/UAF.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\npanda/qemu/x86_64-softmmu/panda-system-x86_64 -display none -m 1024 -replay crash_reduced \\\n    -panda 'callstack_instr;useafterfree'\n```\n\n----------------------------------------\n\nTITLE: Filesystem Mount and Management Prototypes in C\nDESCRIPTION: Function prototypes for Linux system calls related to filesystem mounting, configuration, and management. These functions allow for advanced control of filesystems including mounting, unmounting, and configuring filesystem properties.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nlong sys_syncfs(int fd);\nlong sys_open_tree(int dfd, const char __user *path, unsigned flags);\nlong sys_move_mount(int from_dfd, const char __user *from_path, int to_dfd, const char __user *to_path, unsigned int ms_flags);\nlong sys_fsopen(const char __user *fs_name, unsigned int flags);\nlong sys_fsconfig(int fs_fd, unsigned int cmd, const char __user *key, const void __user *value, int aux);\nlong sys_fsmount(int fs_fd, unsigned int flags, unsigned int ms_flags);\nlong sys_fspick(int dfd, const char __user *path, unsigned int flags);\nlong sys_name_to_handle_at(int dfd, const char __user *name, struct file_handle __user *handle, int __user *mnt_id, int flag);\nlong sys_open_by_handle_at(int mountdirfd, struct file_handle __user *handle, int flags);\n```\n\n----------------------------------------\n\nTITLE: Implementing HMP Info Command - C for QEMU\nDESCRIPTION: This HMP handler invokes the corresponding QMP function, processes errors, and prints structured alarm clock information to the monitor. It ensures all resources are properly freed via the QAPI-generated free function and includes error checking for robust user feedback. Dependencies include monitor infrastructure, QMP data structure, and QAPI free functions. Inputs are from monitor invocation; results are displayed in human-readable form.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/writing-qmp-commands.txt#_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nvoid hmp_info_alarm_clock(Monitor *mon)\n{\n    QemuAlarmClock *clock;\n    Error *err = NULL;\n\n    clock = qmp_query_alarm_clock(&err);\n    if (err) {\n        monitor_printf(mon, \"Could not query alarm clock information\\n\");\n        error_free(err);\n        return;\n    }\n\n    monitor_printf(mon, \"Alarm clock method in use: '%s'\\n\", clock->clock_name);\n    if (clock->has_next_deadline) {\n        monitor_printf(mon, \"Next alarm will fire in %\" PRId64 \" nanoseconds\\n\",\n                       clock->next_deadline);\n    }\n\n   qapi_free_QemuAlarmClock(clock); \n}\n```\n\n----------------------------------------\n\nTITLE: Defining QEMUFile Callback Functions in C\nDESCRIPTION: This snippet defines the function signatures for QEMUFile callback functions used in migration operations. It includes functions for writing and reading data buffers, as well as closing the file.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/migration.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\ntypedef int (QEMUFilePutBufferFunc)(void *opaque, const uint8_t *buf,\n                                    int64_t pos, int size);\n\ntypedef int (QEMUFileGetBufferFunc)(void *opaque, uint8_t *buf,\n                                    int64_t pos, int size);\n\ntypedef int (QEMUFileCloseFunc)(void *opaque);\n```\n\n----------------------------------------\n\nTITLE: Tracking String Propagation to Network Output with PANDA\nDESCRIPTION: This command uses 'stringsearch' and 'tstringsearch' to taint the string 'quick', then uses 'tainted_net' to detect if this tainted data is sent out over the network. Results are written to 'quick_tnss.csv'.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/tainted_net/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/i386-softmmu/panda-system-i386 -net nic -net user \\\n    -replay foo \\\n    -panda stringsearch:str=\"quick\" -panda tstringsearch \\\n    -panda tainted_net:query_outgoing_network=true,file=quick_tnss.csv\n```\n\n----------------------------------------\n\nTITLE: Running PANDA with DWARF2 and Dependencies - Bash\nDESCRIPTION: This command demonstrates how to launch the PANDA QEMU system with the 'dwarf2', 'osi', 'osi_linux', and 'pri' plugins loaded, specifying replay files and configuring both guest and host debug paths required for symbol resolution. The dependencies 'osi' and an OS-specific provider are specified via '-panda osi' and '-panda osi_linux:...'. Key parameters include 'proc' to select the monitored process, and explicit paths ('g_debugpath', 'h_debugpath') for locating DWARF-generated JSON files. The command expects these JSON symbol files to have been generated and placed in the specified directories prior to execution. The output of this configuration is a VM instance where PANDA can use DWARF plugin-based callbacks to analyze the debug information from the specified process. Any misuse of arguments or missing plugins will prevent successful loading or operation of 'dwarf2'.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/dwarf2/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n~/git/panda/qemu/i386-softmmu/panda-system-i386 -replay \\\n    /nas/ulrich/dwarf_tshark_capture2/wireshark-1.2.1-saurabh.cap.iso \\\n    -panda osi \\\n    -panda osi_linux:kconf_file=/nas/ulrich/kernelinfo.conf,kconf_group=debian-3.2.51-i686 \\\n    -panda pri \\\n    -panda dwarf2:proc=tshark,g_debugpath=/nas/ulrich/wireshark-1.2.1/lava-install/,h_debugpath=/nas/ulrich/wireshark-1.2.1/lava-install/\n```\n\n----------------------------------------\n\nTITLE: Launching QEMU with USB Controllers and Devices - Bash/QEMU CLI\nDESCRIPTION: Demonstrates a sequence of QEMU command-line arguments to create a virtual machine with both USB 1.1 and USB 2.0 controllers, attaching a tablet device to UHCI and a USB storage device to EHCI. Requires QEMU to be installed, and an image file at the specified path. Parameters include drive setup, controller creation, and device-to-bus assignments. Inputs include options for QEMU, a disk image, and device descriptors; outputs are the correct attachment of devices to virtualized USB controllers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/usb2.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nqemu -M pc ${otheroptions}                           \\\n    -drive if=none,id=usbstick,file=/path/to/image   \\\n    -usb                                             \\\n    -device usb-ehci,id=ehci                         \\\n    -device usb-tablet,bus=usb-bus.0                 \\\n    -device usb-storage,bus=ehci.0,drive=usbstick\n```\n\n----------------------------------------\n\nTITLE: SchemaInfo for an Event with Data - JSON\nDESCRIPTION: This JSON object defines SchemaInfo metadata for a QAPI 'event' named 'EVENT_C', with an argument type that references an implicitly defined object. It demonstrates how event definitions with data correspond to separate object types for their arguments and shows the linkage between event wire names and object type names used for validation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{ \\\"name\\\": \\\"EVENT_C\\\", \\\"meta-type\\\": \\\"event\\\",\\n  \\\"arg-type\\\": \\\"q_obj-EVENT_C-arg\\\" }\n```\n\n----------------------------------------\n\nTITLE: Configuring NBD Server on Secondary VM\nDESCRIPTION: These QMP commands initialize the QMP capabilities, start the NBD server, and add the secondary disk to the NBD server. This setup is necessary before initiating migration on the primary VM.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/COLO-FT.txt#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{'execute':'qmp_capabilities'}\n{ 'execute': 'nbd-server-start',\n  'arguments': {'addr': {'type': 'inet', 'data': {'host': 'xx.xx.xx.xx', 'port': '8889'} } }\n}\n{'execute': 'nbd-server-add', 'arguments': {'device': 'secondeary-disk0', 'writable': true } }\n```\n\n----------------------------------------\n\nTITLE: Launching a PANDA Replay with GDB Integration - Bash\nDESCRIPTION: This snippet demonstrates how to start a system replay with PANDA and enable its GDB debugging plugin from the command line. Dependencies include the PANDA system emulator and the appropriate OSI plugin for your guest operating system. Key arguments such as '-os', '-replay', '-panda', and memory size '-m' are specified; 'on_entry' is an optional flag determining the GDB break location. The command expects pre-generated replay data and correct OS metadata.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/gdb/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npanda-system-x86_64 -os \"linux-64-ubuntu:4.15.0-72-generic-noaslr-nokaslr\" -replay catmaps -panda gdb:on_entry=1 -m 1G\n```\n\n----------------------------------------\n\nTITLE: Defining Thread End Callback in PANDA hooks2 Plugin\nDESCRIPTION: Defines the signature for the on_thread_end callback function that gets triggered when a thread terminates. The callback provides CPU state, process name, address space ID (asid), process ID, and thread ID information.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/hooks2/README.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nvoid on_thread_end(\n    CPUState *cpu,\n    const char *procname,\n    target_ulong asid,\n    target_pid_t pid,\n    target_pid_t tid);\n```\n\n----------------------------------------\n\nTITLE: Specifying Device Placement on QEMU Buses (QEMU CLI, Shell)\nDESCRIPTION: Provides example shell command for placing a device into a specific PCI slot on a bus using the -device syntax, specifying the parent bus and address for accurate QEMU virtual hardware configuration. No dependencies except QEMU CLI tool. Parameters include FOO (device type), bus (bus path), and addr (slot number). Input is the CLI string; output is QEMU instantiation of the device on the given slot.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n-device FOO,bus=/i440FX-pcihost/pci.0,addr=4\n```\n\n----------------------------------------\n\nTITLE: Registering Legacy Device State Handlers in C\nDESCRIPTION: This snippet shows the function signature for registering legacy save and load state handlers for a device. It includes parameters for device identification, versioning, and callback functions for saving and loading state.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/migration.txt#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nint register_savevm(DeviceState *dev,\n                    const char *idstr,\n                    int instance_id,\n                    int version_id,\n                    SaveStateHandler *save_state,\n                    LoadStateHandler *load_state,\n                    void *opaque);\n\ntypedef void SaveStateHandler(QEMUFile *f, void *opaque);\ntypedef int LoadStateHandler(QEMUFile *f, void *opaque, int version_id);\n```\n\n----------------------------------------\n\nTITLE: Windows NT System Functions Declarations - System Information and Query\nDESCRIPTION: Function declarations for querying various system information and status. These functions provide access to system-level information and configurations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp0_x86_prototypes.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQuerySystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySystemTime (PLARGE_INTEGER SystemTime);\nNTSTATUS NtQueryPerformanceCounter (PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);\nNTSTATUS NtQueryObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);\n```\n\n----------------------------------------\n\nTITLE: Defining Memory and Registry Management System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to physical memory management and system freezing operations. These functions provide low-level memory management and state preservation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_22\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtFreezeRegistry (ULONG TimeOutInSeconds);\nNTSTATUS NtFreezeTransactions (PLARGE_INTEGER FreezeTimeout, PLARGE_INTEGER ThawTimeout);\n```\n\n----------------------------------------\n\nTITLE: Sending QAPI Events in C Generated by qapi-event.py - C\nDESCRIPTION: This code snippet, generated by qapi-event.py from a QAPI schema, illustrates how to define and send a QAPI event in C. It includes retrieving an event emission function, building a QDict for event arguments, emitting the event, propagating any error, and cleaning up resources. Dependencies include the QAPI C runtime and previously generated type headers; the snippet expects event-specific enums, error handling infrastructure, and a QDict allocation routine.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_23\n\nLANGUAGE: C\nCODE:\n```\n#ifndef EXAMPLE_QAPI_EVENT_H\\n#define EXAMPLE_QAPI_EVENT_H\\n\\n#include \\\"qapi/error.h\\\"\\n#include \\\"qapi/qmp/qdict.h\\\"\\n#include \\\"example-qapi-types.h\\\"\\n\\n\\nvoid qapi_event_send_my_event(Error **errp);\\n\\ntypedef enum example_QAPIEvent {\\n    EXAMPLE_QAPI_EVENT_MY_EVENT = 0,\\n    EXAMPLE_QAPI_EVENT__MAX = 1,\\n} example_QAPIEvent;\\n\\nextern const char *const example_QAPIEvent_lookup[];\\n\\n#endif\n```\n\nLANGUAGE: C\nCODE:\n```\nvoid qapi_event_send_my_event(Error **errp)\\n{\\n    QDict *qmp;\\n    Error *err = NULL;\\n    QMPEventFuncEmit emit;\\n    emit = qmp_event_get_func_emit();\\n    if (!emit) {\\n        return;\\n    }\\n\\n    qmp = qmp_event_build_dict(\\\"MY_EVENT\\\");\\n\\n    emit(EXAMPLE_QAPI_EVENT_MY_EVENT, qmp, &err);\\n\\n    error_propagate(errp, err);\\n    QDECREF(qmp);\\n}\n```\n\nLANGUAGE: C\nCODE:\n```\nconst char *const example_QAPIEvent_lookup[] = {\\n    [EXAMPLE_QAPI_EVENT_MY_EVENT] = \\\"MY_EVENT\\\",\\n    [EXAMPLE_QAPI_EVENT__MAX] = NULL,\\n};\n```\n\n----------------------------------------\n\nTITLE: Running PANDA with pri_taint and Related Plugins - Shell Command\nDESCRIPTION: This shell command demonstrates how to launch PANDA's QEMU-based system with a collection of plugins (`osi`, `osi_linux`, `pri`, `pri_dwarf`, `file_taint`, and `pri_taint`) to perform a taint analysis correlated with variable liveness using DWARF information during the replay of an execution log. The command requires an existing replay log, specific kernel configuration, DWARF debug data, and a target file to track for taint. Output is directed to `foo.plog`. Key options include specifying the replay log, configuring the Linux kernel context, and wiring in all necessary plugins in the correct order. This example expects the PANDA QEMU binaries, the appropriate kernel debug and host debug files, and all referenced plugins to be installed and accessible.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/pri_taint/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n~/git/panda/qemu/i386-softmmu/panda-system-i386 \\\n    -replay \"/path/to/replaylog\" \\\n    -panda osi \\\n    -panda osi_linux:kconf_file=/path/to/kconf,kconf_group=debian-3.2.51-i686 \\\n    -panda pri \\\n    -panda pri_dwarf:proc=\"procname\",g_debugpath=\"/path/to/dbg/\",h_debugpath=\"/path/to/hostdbg\" \\\n    -panda file_taint:filename=\"taintedfile\" \\\n    -panda pri_taint \\\n    -pandalog foo.plog\n```\n\n----------------------------------------\n\nTITLE: Enabling Checkpoints in PANDA via Shell Command - Shell\nDESCRIPTION: Demonstrates how to enable the 'checkpoint' plugin in PANDA during a VM replay to support time-travel debugging. Requires a valid PANDA installation and sufficient available RAM (argument 'space' in plugin configuration must exceed the VM's memory size). The command invokes the PANDA system binary with plugin parameters, specifying a 4GB allocation for checkpoint data. Inputs include the guest replay file and configurable options, and output is the PANDA system with active checkpointing; incorrect parameters may result in insufficient checkpoint storage or errors.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/checkpoint/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$PANDA_PATH/build/x86_64-softmmu/panda-system-x86_64 -replay foo -S -s -panda checkpoint:space=4GB\n```\n\n----------------------------------------\n\nTITLE: Defining pri Plugin Data Structures and Typedefs - C\nDESCRIPTION: This C code snippet illustrates the primary data structures and type definitions used for introspection callbacks in pri. It introduces a LocType enum to classify variable locations and a callback type for live variable iteration, which takes variable type, name, location, and address data. Dependencies include PANDA plugin base types. The inputs for these are set by the execution engine and debugging provider, and the outputs are used by introspection callbacks. LocErr represents limitations in the backendâ€™s capability to resolve a variableâ€™s location.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/pri/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n// A location is one of three types: Register, Memory, or a Constant (variable is not stored anywhere in memory or registers)\n// but we know it's value at compile time.\n// LocErr means that the variables location was too difficult to be determine (future support may remediate this).\n//     -> ie a variable's location is represented by two different registers (DW_OP_bit_piece)\ntypedef enum { LocReg, LocMem, LocConst, LocErr } LocType;\n\n// the live_var_iter functions take in this callback and apply it to all vars that are live at the current program state\ntypedef void (*liveVarCB)(void *var_ty, const char *var_nm, LocType loc_t, target_ulong loc);\n\n```\n\n----------------------------------------\n\nTITLE: Blocking Signals in PANDA using Python Plugin API\nDESCRIPTION: This Python code demonstrates using PANDA's Python plugin interface to block UNIX signals either for a specific process or system-wide. It encodes the target process name as ASCII for compatibility and invokes block_sig_by_proc (for a named process) or block_sig (for all processes), passing the appropriate signal numbers. The script ensures that analysis logs are flushed by calling panda.panda_finish() at the end. Dependencies include an initialized PANDA environment with the 'signal' plugin as well as 'syscalls2' and 'osi_linux'.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/signal/README.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Block SIGSEGV for one process\\nproc_name = 'my_proc_name'.encode('ascii')\\npanda.plugins['signal'].block_sig_by_proc(11, proc_name)\\n\\n# Block SIGABRT for the entire system\\npanda.plugins['signal'].block_sig(6)\\n\\n# Remember to flush PANDALOG before ending your analysis\\npanda.panda_finish()\n```\n\n----------------------------------------\n\nTITLE: Declaring Core Panda Dependency - Rust - toml\nDESCRIPTION: Adds the main panda-re dependency in the Cargo.toml file for the plugin project, specifying a minimum version and disabling default features. This allows the plugin to interface with the PANDA system. The dependency is required for all functionality and relates directly to plugin APIs.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/rust_skeleton/README.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\npanda-re = { version = \"0.48\", default-features = false }\n```\n\n----------------------------------------\n\nTITLE: Mapping Offsets to Tap Points (Bash)\nDESCRIPTION: This command uses the idxmap.py script to map the offsets in foo_offsets.txt to tap points using the tap_reads.idx index file.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/tapindex/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nscripts/idxmap.py tap_reads.idx foo_offsets.txt\n```\n\n----------------------------------------\n\nTITLE: Removing a String Pattern from PANDA Plugin (C)\nDESCRIPTION: This C function removes a previously registered string from the search list in the stringsearch plugin. The function requires the pluginâ€™s internal tracking state and returns true if removal succeeded (or if the string was found and deleted). Input: const char* arg (string to remove); Output: bool (success). Plugin must be initialized and the string must exist for removal to succeed.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/stringsearch/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nbool remove_strings(const char* arg)\n```\n\n----------------------------------------\n\nTITLE: I/O Control and Advanced I/O Operation Prototypes in C\nDESCRIPTION: Function prototypes for Linux system calls related to I/O control, data transfer, and specialized I/O operations. These functions provide more fine-grained control over I/O operations including zero-copy transfers and I/O prioritization.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nlong sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);\nlong sys_ioprio_set(int which, int who, int ioprio);\nlong sys_ioprio_get(int which, int who);\nlong sys_splice(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);\nlong sys_sync_file_range(int fd, loff_t offset, loff_t nbytes, unsigned int flags);\nlong sys_tee(int fdin, int fdout, size_t len, unsigned int flags);\nlong sys_vmsplice(int fd, const struct iovec __user *iov, unsigned long nr_segs, unsigned int flags);\nlong sys_fallocate(int fd, int mode, loff_t offset, loff_t len);\nlong sys_copy_file_range(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);\nlong sys_preadv2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);\nlong sys_pwritev2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);\n```\n\n----------------------------------------\n\nTITLE: Unregistering a Hypercall Handler â€” C\nDESCRIPTION: Provides the API to unregister a hypercall previously registered via its magic number. Requires that a handler has been registered; passing the same magic removes the handler from the dispatch table. Ensures that handlers are not accidentally invoked after they are no longer valid.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/hypercaller/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nvoid unregister_hypercall(uint32_t magic);\n```\n\n----------------------------------------\n\nTITLE: Defining Process End Callback in PANDA hooks2 Plugin\nDESCRIPTION: Defines the signature for the on_process_end callback function that gets triggered when a process terminates. The callback provides CPU state, process name, address space ID (asid), and process ID information.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/hooks2/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nvoid on_process_end(\n    CPUState *cpu,\n    const char *procname,\n    target_ulong asid,\n    target_pid_t pid);\n```\n\n----------------------------------------\n\nTITLE: Configuring USB Devices in QEMU\nDESCRIPTION: Compares old -usbdevice syntax with new -device syntax for various USB device types including keyboard, mouse, tablet, and host device assignment. This shows the direct mapping between old and new command syntaxes.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nccid            -device usb-ccid\nkeyboard        -device usb-kbd\nmouse           -device usb-mouse\ntablet          -device usb-tablet\nwacom-tablet    -device usb-wacom-tablet\nhost:...        See \"Host Device Assignment\"\ndisk:...        See \"Block Devices\"\nserial:...      See \"Character Devices\"\nbraille         See \"Character Devices\"\nnet:...         See \"Network Devices\"\nbt:...          not yet available with -device\n```\n\n----------------------------------------\n\nTITLE: Performing Sequentially Consistent Atomic Loads and Stores in QEMU (C)\nDESCRIPTION: This snippet demonstrates performing atomic loads and stores through read-modify-write macros in the QEMU concurrency model. Specifically, atomic_fetch_add(ptr, 0) is used to perform a load, while atomic_xchg(ptr, val) performs a store, both enforcing sequential consistency. These macros require including qemu/atomic.h, and their parameters define the pointer and the value to load or store. Inputs include the variable pointer and desired write value; outputs are the old value for stores. While highly portable, these operations are potentially expensive on some CPU architectures.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/atomics.txt#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\natomic_fetch_add(ptr, 0) // load\natomic_xchg(ptr, val)    // store\n```\n\n----------------------------------------\n\nTITLE: Reversing TUBTF Trace Log for Backward Slicing using Shell Command\nDESCRIPTION: This shell snippet calls the logreverse_mmap tool to reverse a TUBTF dynamic trace log file in-place, a necessary preprocessing step for performing dynamic slicing since slicing processes the execution backward. The command assumes you have already produced tubtf.log with PANDA. logreverse_mmap operates directly on the file, so creating a backup is recommended before running this command. Its output is a reversed-log version of the input file, required for subsequent slicing by dynslice.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/dynslice.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncd <arch>-softmmu/panda_tools/\n./logreverse_mmap tubtf.log\n```\n\n----------------------------------------\n\nTITLE: Defining Hook Disable API in PANDA hooks2 Plugin\nDESCRIPTION: Defines the DISABLE_HOOKS2 function which deactivates a previously registered hook identified by its ID. This allows for dynamic disabling of hooks during runtime.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/hooks2/README.md#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nvoid DISABLE_HOOKS2(int id);\n```\n\n----------------------------------------\n\nTITLE: Host PCI Device Assignment in QEMU\nDESCRIPTION: Shows the syntax for assigning host PCI devices to QEMU guests, comparing old -pcidevice syntax with new -device syntax. Includes options for IOMMU configuration.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n-pcidevice host=ADDR,dma=none,id=ID\n```\n\nLANGUAGE: bash\nCODE:\n```\n-device pci-assign,host=ADDR,iommu=IOMMU,id=ID\n```\n\n----------------------------------------\n\nTITLE: Controlling QEMU Translation Block Chaining in C\nDESCRIPTION: These functions allow PANDA plugins to selectively enable or disable translation block chaining, a QEMU optimization that reduces emulation overhead. Disabling chaining is useful in situations like LLVM or replay modes to maintain accurate code translation and event callback timing. Functions do not require parameters and affect global translation behavior regardless of backend.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nvoid panda_disable_tb_chaining(void);\n```\n\nLANGUAGE: C\nCODE:\n```\nvoid panda_enable_tb_chaining(void);\n```\n\n----------------------------------------\n\nTITLE: Enabling syscalls2 with a profile from the command line - Shell\nDESCRIPTION: This shell argument configures PANDA to load the syscalls2 plugin with the specified operating system profile for use by user plugins. The profile parameter must match the target OS/architecture; supports profiles like windows_7_x86, linux_x86, etc. This is typically supplied as part of the replay or experiment run command.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/syscalls2.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n-panda 'syscalls2:profile=windows_7_x86'\n```\n\n----------------------------------------\n\nTITLE: Reading QEMU Configuration for EHCI/UHCI - Bash/QEMU CLI\nDESCRIPTION: Demonstrates use of the '-readconfig' command-line argument to load a QEMU configuration file that sets up companion EHCI/UHCI controllers. This assumes the presence of a configuration file at the specified path. Parameters specify the use of a prepared config file, and the result is a VM booted with the desired USB controller arrangement, as defined in the config.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/usb2.txt#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nqemu -readconfig docs/ich9-ehci-uhci.cfg\n```\n\n----------------------------------------\n\nTITLE: Building for a Specific Architecture (e.g., ARM) - Rust - shell\nDESCRIPTION: Shows how to compile the PANDA plugin targeting the ARM architecture by disabling default features and enabling the arm feature. This command increases cross-platform flexibility and must be executed in the source directory with the correct toolchain setup.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/rust_skeleton/README.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncargo build --release --no-default-features --features=arm\n```\n\n----------------------------------------\n\nTITLE: Defining the on_ret Callback Type with PANDA Plugin API in C\nDESCRIPTION: This snippet defines the type signature for the 'on_ret' callback in the PANDA callstack_instr plugin. It takes CPU state and guest function address parameters and is called whenever the traced guest returns from a function. Plugins may use this to observe function returns, and must handle recursive call/return matching if required. Dependencies are similar to the on_call callback and requires PANDA emulation types for integration.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/callstack_instr/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (* on_ret_t)(CPUState *env, target_ulong func)\n```\n\n----------------------------------------\n\nTITLE: Declaring a Plugin Class for Web Endpoint Mounting - Python\nDESCRIPTION: Shows a minimal subclass declaration of PyPlugin for the purpose of Flask web integration. This snippet highlights the convention that the subclass name (here 'BasicBlockCount') determines the endpoint mount path for the plugin's web interface when using Flask integration with snake_hook. There are no dependencies within the snippet itself, but for actual use, the PyPlugin class and related Flask/Blueprint infrastructure must be set up as per the PANDA and PyPANDA plugin documentation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/snake_hook/README.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass BasicBlockCount(PyPlugin):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Best Matching Symbol Lookup in C\nDESCRIPTION: Function that attempts to find the closest matching symbol for a given address without going over. Returns best-guess results and should be used with caution as it may not always identify the correct function.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/dynamic_symbols/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nstruct symbol get_best_matching_symbol(CPUState* cpu, target_ulong address, target_ulong asid);\n```\n\n----------------------------------------\n\nTITLE: Linux System Call Function Prototypes\nDESCRIPTION: Complete set of Linux kernel system call function prototypes defining low-level system operations. Each function returns a long type and accepts various parameters specific to its operation. These definitions are used by the kernel to implement system call functionality.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_x64_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nlong sys_signalfd4(int ufd, sigset_t __user *user_mask, size_t sizemask, int flags);\nlong sys_eventfd2(unsigned int count, int flags);\nlong sys_epoll_create1(int flags);\nlong sys_dup3(unsigned int oldfd, unsigned int newfd, int flags);\nlong sys_pipe2(int __user *fildes, int flags);\nlong sys_inotify_init1(int flags);\nlong sys_preadv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);\nlong sys_pwritev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);\nlong sys_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t __user *uinfo);\nlong sys_perf_event_open(struct perf_event_attr __user *attr_uptr, pid_t pid, int cpu, int group_fd, unsigned long flags);\nlong sys_recvmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags, struct timespec __user *timeout);\nlong sys_fanotify_init(unsigned int flags, unsigned int event_f_flags);\nlong sys_fanotify_mark(int fanotify_fd, unsigned int flags, u64 mask, int fd, const char __user *pathname);\nlong sys_prlimit64(pid_t pid, unsigned int resource, const struct rlimit64 __user *new_rlim, struct rlimit64 __user *old_rlim);\nlong sys_name_to_handle_at(int dfd, const char __user *name, struct file_handle __user *handle, int __user *mnt_id, int flag);\nlong sys_open_by_handle_at(int mountdirfd, struct file_handle __user *handle, int flags);\nlong sys_clock_adjtime(clockid_t which_clock, struct timex __user *tx);\nlong sys_syncfs(int fd);\nlong sys_sendmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags);\nlong sys_setns(int fd, int nstype);\nlong sys_getcpu(unsigned __user *cpu, unsigned __user *node, struct getcpu_cache __user *cache);\nlong sys_process_vm_readv(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);\nlong sys_process_vm_writev(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);\nlong sys_kcmp(pid_t pid1, pid_t pid2, int type, unsigned long idx1, unsigned long idx2);\nlong sys_finit_module(int fd, const char __user *uargs, int flags);\nlong sys_sched_setattr(pid_t pid, struct sched_attr __user *attr, unsigned int flags);\nlong sys_sched_getattr(pid_t pid, struct sched_attr __user *attr, unsigned int size, unsigned int flags);\nlong sys_renameat2(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, unsigned int flags);\nlong sys_seccomp(unsigned int op, unsigned int flags, const char __user *uargs);\nlong sys_getrandom(char __user *buf, size_t count, unsigned int flags);\nlong sys_memfd_create(const char __user *uname_ptr, unsigned int flags);\nlong sys_kexec_file_load(int kernel_fd, int initrd_fd, unsigned long cmdline_len, const char __user *cmdline_ptr, unsigned long flags);\nlong sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);\nlong sys_execveat(int dfd, const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp, int flags);\nlong sys_userfaultfd(int flags);\nlong sys_membarrier(int cmd, int flags);\nlong sys_mlock2(unsigned long start, size_t len, int flags);\nlong sys_copy_file_range(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);\nlong sys_preadv2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);\nlong sys_pwritev2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);\nlong sys_pkey_mprotect(unsigned long start, size_t len, unsigned long prot, int pkey);\nlong sys_pkey_alloc(unsigned long flags, unsigned long init_val);\nlong sys_pkey_free(int pkey);\nlong sys_statx(int dfd, const char __user *path, unsigned flags, unsigned mask, struct statx __user *buffer);\n```\n\n----------------------------------------\n\nTITLE: Adding a Callback Argument in Callback Initializer (Python)\nDESCRIPTION: This snippet details how to initialize the PandaCB namedtuple with callbacks using the pyp.callback abstraction. Each field is assigned a callback signature, and new callbacks should be added preserving the ordering for organizational clarity. The pattern supports specifying return types and argument lists for each callback.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/docs/extending_pypanda.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npcb = PandaCB(init = pyp.callback(\"bool(void*)\"),\nbefore_block_exec_invalidate_opt = pyp.callback(\"bool(CPUState*,\nTranslationBlock*)\"),\n...\n...\nafter_machine_init = pyp.callback(\"void(CPUState*)\"),\ntop_loop = pyp.callback(\"void(CPUState*)\"))\n```\n\n----------------------------------------\n\nTITLE: Invoking PANDA with pc_search for a Single PC - Shell\nDESCRIPTION: This snippet demonstrates how to invoke the PANDA system with the pc_search plugin to search for a single program counter (PC) value during replay. The pc argument is provided directly in hexadecimal, and the platform used is x86_64. No additional dependencies are required, but the user must have PANDA built and available as specified by the $PANDA_PATH variable. The command outputs all guest instruction matches for the specified PC value, and writes results to the default output file.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/pc_search/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo \\\n    -panda pc_search:pc=0x77c47f06\n```\n\n----------------------------------------\n\nTITLE: Declaring Linux System Calls in C\nDESCRIPTION: This code snippet shows the declaration of various Linux system calls. Each line represents a system call function with its return type, name, and parameters. These declarations are typically used in kernel-level programming or system libraries.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nlong sys_mq_timedsend(mqd_t mqdes, const char __user *msg_ptr, size_t msg_len, unsigned int msg_prio, const struct __kernel_timespec __user *abs_timeout);\nlong sys_mq_timedreceive(mqd_t mqdes, char __user *msg_ptr, size_t msg_len, unsigned int __user *msg_prio, const struct __kernel_timespec __user *abs_timeout);\nlong sys_semtimedop(int semid, struct sembuf __user *sops, unsigned nsops, const struct __kernel_timespec __user *timeout);\nlong sys_rt_sigtimedwait(const sigset_t __user *uthese, siginfo_t __user *uinfo, const struct __kernel_timespec __user *uts, size_t sigsetsize);\nlong sys_futex(u32 __user *uaddr, int op, u32 val, struct __kernel_timespec __user *utime, u32 __user *uaddr2, u32 val3);\nlong sys_sched_rr_get_interval(pid_t pid, struct __kernel_timespec __user *interval);\nlong sys_pidfd_send_signal(int pidfd, int sig, siginfo_t __user *info, unsigned int flags);\nlong sys_io_uring_setup(u32 entries, struct io_uring_params __user *p);\nlong sys_io_uring_enter(unsigned int fd, u32 to_submit, u32 min_complete, u32 flags, const sigset_t __user *sig, size_t sigsz);\nlong sys_io_uring_register(unsigned int fd, unsigned int op, void __user *arg, unsigned int nr_args);\nlong sys_open_tree(int dfd, const char __user *path, unsigned flags);\nlong sys_move_mount(int from_dfd, const char __user *from_path, int to_dfd, const char __user *to_path, unsigned int ms_flags);\nlong sys_fsopen(const char __user *fs_name, unsigned int flags);\nlong sys_fsconfig(int fs_fd, unsigned int cmd, const char __user *key, const void __user *value, int aux);\nlong sys_fsmount(int fs_fd, unsigned int flags, unsigned int ms_flags);\nlong sys_fspick(int dfd, const char __user *path, unsigned int flags);\nlong sys_pidfd_open(pid_t pid, unsigned int flags);\nlong sys_openat2(int dfd, const char __user *filename, struct open_how *how, size_t size);\nlong sys_pidfd_getfd(int pidfd, int fd, unsigned int flags);\nlong sys_faccessat2(int dfd, const char __user *filename, int mode, int flags);\nlong sys_read(unsigned int fd, char __user *buf, size_t count);\nlong sys_write(unsigned int fd, const char __user *buf, size_t count);\nlong sys_open(const char __user *filename, int flags, umode_t mode);\nlong sys_close(unsigned int fd);\nlong sys_newstat(const char __user *filename, struct stat __user *statbuf);\nlong sys_newfstat(unsigned int fd, struct stat __user *statbuf);\nlong sys_newlstat(const char __user *filename, struct stat __user *statbuf);\nlong sys_poll(struct pollfd __user *ufds, unsigned int nfds, int timeout);\nlong sys_lseek(unsigned int fd, off_t offset, unsigned int whence);\nlong sys_old_mmap(struct mmap_arg_struct __user *arg);\nlong sys_mprotect(unsigned long start, size_t len, unsigned long prot);\nlong sys_munmap(unsigned long addr, size_t len);\nlong sys_brk(unsigned long brk);\nlong sys_rt_sigaction(int, const struct sigaction __user *, struct sigaction __user *, size_t);\nlong sys_rt_sigprocmask(int how, sigset_t __user *set, sigset_t __user *oset, size_t sigsetsize);\nlong sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);\nlong sys_pread64(unsigned int fd, char __user *buf, size_t count, loff_t pos);\nlong sys_pwrite64(unsigned int fd, const char __user *buf, size_t count, loff_t pos);\nlong sys_readv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\nlong sys_writev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\nlong sys_access(const char __user *filename, int mode);\nlong sys_pipe(int __user *fildes);\nlong sys_select(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct __kernel_old_timeval __user *tvp);\nlong sys_sched_yield(void);\nlong sys_mremap(unsigned long addr, unsigned long old_len, unsigned long new_len, unsigned long flags, unsigned long new_addr);\nlong sys_msync(unsigned long start, size_t len, int flags);\nlong sys_mincore(unsigned long start, size_t len, unsigned char __user *vec);\nlong sys_madvise(unsigned long start, size_t len, int behavior);\nlong sys_shmget(key_t key, size_t size, int flag);\nlong sys_shmat(int shmid, char __user *shmaddr, int shmflg);\nlong sys_old_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);\nlong sys_dup(unsigned int fildes);\nlong sys_dup2(unsigned int oldfd, unsigned int newfd);\nlong sys_pause(void);\nlong sys_nanosleep(struct __kernel_timespec __user *rqtp, struct __kernel_timespec __user *rmtp);\nlong sys_getitimer(int which, struct __kernel_old_itimerval __user *value);\nlong sys_setitimer(int which, struct __kernel_old_itimerval __user *value, struct __kernel_old_itimerval __user *ovalue);\nlong sys_alarm(unsigned int seconds);\nlong sys_getpid(void);\nlong sys_sendfile64(int out_fd, int in_fd, loff_t __user *offset, size_t count);\nlong sys_socket(int, int, int);\nlong sys_connect(int, struct sockaddr __user *, int);\nlong sys_accept(int, struct sockaddr __user *, int __user *);\nlong sys_sendto(int, void __user *, size_t, unsigned, struct sockaddr __user *, int);\nlong sys_recvfrom(int, void __user *, size_t, unsigned, struct sockaddr __user *, int __user *);\nlong sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\nlong sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\nlong sys_shutdown(int, int);\nlong sys_bind(int, struct sockaddr __user *, int);\nlong sys_listen(int, int);\nlong sys_getsockname(int, struct sockaddr __user *, int __user *);\nlong sys_getpeername(int, struct sockaddr __user *, int __user *);\nlong sys_socketpair(int, int, int, int __user *);\nlong sys_setsockopt(int fd, int level, int optname, char __user *optval, int optlen);\nlong sys_getsockopt(int fd, int level, int optname, char __user *optval, int __user *optlen);\nlong sys_clone(unsigned long, unsigned long, int __user *, int __user *, unsigned long);\nlong sys_fork(void);\nlong sys_execve(const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp);\nlong sys_exit(int error_code);\nlong sys_wait4(pid_t pid, int __user *stat_addr, int options, struct rusage __user *ru);\nlong sys_kill(pid_t pid, int sig);\nlong sys_newuname(struct new_utsname __user *name);\nlong sys_semget(key_t key, int nsems, int semflg);\nlong sys_semop(int semid, struct sembuf __user *sops, unsigned nsops);\nlong sys_old_semctl(int semid, int semnum, int cmd, unsigned long arg);\nlong sys_shmdt(char __user *shmaddr);\nlong sys_msgget(key_t key, int msgflg);\nlong sys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz, int msgflg);\nlong sys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz, long msgtyp, int msgflg);\nlong sys_old_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);\nlong sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg);\nlong sys_flock(unsigned int fd, unsigned int cmd);\nlong sys_fsync(unsigned int fd);\nlong sys_fdatasync(unsigned int fd);\nlong sys_truncate(const char __user *path, long length);\nlong sys_ftruncate(unsigned int fd, unsigned long length);\nlong sys_getdents(unsigned int fd, struct linux_dirent __user *dirent, unsigned int count);\nlong sys_getcwd(char __user *buf, unsigned long size);\nlong sys_chdir(const char __user *filename);\nlong sys_fchdir(unsigned int fd);\nlong sys_rename(const char __user *oldname, const char __user *newname);\nlong sys_mkdir(const char __user *pathname, umode_t mode);\nlong sys_rmdir(const char __user *pathname);\nlong sys_creat(const char __user *pathname, umode_t mode);\nlong sys_link(const char __user *oldname, const char __user *newname);\nlong sys_unlink(const char __user *pathname);\nlong sys_symlink(const char __user *old, const char __user *new);\nlong sys_readlink(const char __user *path, char __user *buf, int bufsiz);\nlong sys_chmod(const char __user *filename, umode_t mode);\nlong sys_fchmod(unsigned int fd, umode_t mode);\nlong sys_chown(const char __user *filename, uid_t user, gid_t group);\nlong sys_fchown(unsigned int fd, uid_t user, gid_t group);\nlong sys_lchown(const char __user *filename, uid_t user, gid_t group);\nlong sys_umask(int mask);\nlong sys_gettimeofday(struct __kernel_old_timeval __user *tv, struct timezone __user *tz);\nlong sys_getrlimit(unsigned int resource, struct rlimit __user *rlim);\nlong sys_getrusage(int who, struct rusage __user *ru);\nlong sys_sysinfo(struct sysinfo __user *info);\nlong sys_times(struct tms __user *tbuf);\nlong sys_ptrace(long request, long pid, unsigned long addr, unsigned long data);\nlong sys_getuid(void);\nlong sys_syslog(int type, char __user *buf, int len);\nlong sys_getgid(void);\nlong sys_setuid(uid_t uid);\nlong sys_setgid(gid_t gid);\nlong sys_geteuid(void);\nlong sys_getegid(void);\nlong sys_setpgid(pid_t pid, pid_t pgid);\nlong sys_getppid(void);\nlong sys_getpgrp(void);\nlong sys_setsid(void);\nlong sys_setreuid(uid_t ruid, uid_t euid);\nlong sys_setregid(gid_t rgid, gid_t egid);\nlong sys_getgroups(int gidsetsize, gid_t __user *grouplist);\nlong sys_setgroups(int gidsetsize, gid_t __user *grouplist);\nlong sys_setresuid(uid_t ruid, uid_t euid, uid_t suid);\nlong sys_getresuid(uid_t __user *ruid, uid_t __user *euid, uid_t __user *suid);\nlong sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid);\nlong sys_getresgid(gid_t __user *rgid, gid_t __user *egid, gid_t __user *sgid);\nlong sys_getpgid(pid_t pid);\nlong sys_setfsuid(uid_t uid);\nlong sys_setfsgid(gid_t gid);\nlong sys_getsid(pid_t pid);\n```\n\n----------------------------------------\n\nTITLE: Registering HMP Command - C Structure Example\nDESCRIPTION: This snippet demonstrates adding the 'hello-world' command to the HMP command registry via a structure initializer macro. The command appears in hmp-commands.hx, describing its name, argument typing, parameters, help string, and handler function. The QEMU toolchain requires this registration for the command to be exposed in the human monitor UI. No direct parameters are taken, and dependencies include the registration macros and the implemented C handler function.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/writing-qmp-commands.txt#_snippet_8\n\nLANGUAGE: c\nCODE:\n```\n{\n    .name       = \"hello-world\",\n    .args_type  = \"message:s?\",\n    .params     = \"hello-world [message]\",\n    .help       = \"Print message to the standard output\",\n    .cmd        = hmp_hello_world,\n},\n```\n\n----------------------------------------\n\nTITLE: Installing PANDA Build Dependencies\nDESCRIPTION: This snippet lists the system packages required to build PANDA. It includes essential build tools, libraries, and development packages needed for compiling PANDA and its components.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/dependencies/ubuntu_22.04_build.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nlibc++-dev\nlibelf-dev\nlibtool-bin\nlibwireshark-dev\nlibwiretap-dev\nlsb-core\nzip\n\n# panda build deps\n# Note libcapstone-dev is required, but we need v4 + which isn't in apt\nbuild-essential\nchrpath\nclang-11\ngcc\nlibdwarf-dev\nlibprotoc-dev\nllvm-11-dev\nprotobuf-c-compiler\nprotobuf-compiler\npython3-dev\nlibpixman-1-dev\nzip\n\n# pypanda dependencies\npython3-setuptools\npython3-wheel\n\n# pypanda test dependencies\ngcc-multilib\nlibc6-dev-i386\nnasm\n\n# Qemu build deps\ndebhelper\ndevice-tree-compiler\nlibgnutls28-dev\nlibaio-dev\nlibasound2-dev\nlibattr1-dev\nlibbrlapi-dev\nlibcacard-dev\nlibcap-dev\nlibcap-ng-dev\nlibcurl4-gnutls-dev\nlibdrm-dev\nlibepoxy-dev\nlibfdt-dev\nlibgbm-dev\nlibibumad-dev\nlibibverbs-dev\nlibiscsi-dev\nlibjpeg-dev\nlibncursesw5-dev\nlibnuma-dev\nlibpmem-dev\nlibpng-dev\nlibpulse-dev\nlibrbd-dev\nlibrdmacm-dev\nlibsasl2-dev\nlibseccomp-dev\nlibslirp-dev\nlibspice-protocol-dev\nlibspice-server-dev\nlibssh-dev\nlibudev-dev\nlibusb-1.0-0-dev\nlibusbredirparser-dev\nlibvirglrenderer-dev\nnettle-dev\npython3\npython3-sphinx\ntexinfo\nuuid-dev\nxfslibs-dev\nzlib1g-dev\nlibc6.1-dev-alpha-cross\n\n# qemu build deps that conflict with gcc-multilib\n#gcc-alpha-linux-gnu\n#gcc-powerpc64-linux-gnu\n#gcc-s390x-linux-gnu\n\n# rust install deps\ncurl\n\n# libosi install deps\ncmake\nninja-build\nrapidjson-dev\n```\n\n----------------------------------------\n\nTITLE: Declaring Linux System Call Function Prototypes in C\nDESCRIPTION: This code snippet declares a series of function prototypes for various Linux system calls, each prefixed with sys_*. These declarations define the kernel's public syscall interface for operations including file and directory management, process information, event polling, IPC (semaphores, shared memory, messages), clock and timer management, and additional extended features such as robust futex lists, namespaces, and security. Function parameter types like __user pointers, struct types, and scalar values indicate interfaces designed for direct communication between user space and the kernel. All prototypes return a long and use Linux kernel C types and conventions. Each function is not implemented here; the snippet provides only declarations, which require kernel headers (e.g., linux/types.h) and a kernel build environment to be meaningful.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n4289 long sys_mkdirat(int dfd, const char __user *pathname, umode_t mode);\n4290 long sys_mknodat(int dfd, const char __user *filename, umode_t mode, unsigned dev);\n4291 long sys_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group, int flag);\n4292 long sys_futimesat_time32(unsigned int dfd, const char __user *filename, struct old_timeval32 __user *t);\n4293 long sys_fstatat64(int dfd, const char __user *filename, struct stat64 __user *statbuf, int flag);\n4294 long sys_unlinkat(int dfd, const char __user *pathname, int flag);\n4295 long sys_renameat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname);\n4296 long sys_linkat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, int flags);\n4297 long sys_symlinkat(const char __user *oldname, int newdfd, const char __user *newname);\n4298 long sys_readlinkat(int dfd, const char __user *path, char __user *buf, int bufsiz);\n4299 long sys_fchmodat(int dfd, const char __user *filename, umode_t mode);\n4300 long sys_faccessat(int dfd, const char __user *filename, int mode);\n4301 long sys_pselect6_time32(int, fd_set __user *, fd_set __user *, fd_set __user *, struct old_timespec32 __user *, void __user *);\n4302 long sys_ppoll_time32(struct pollfd __user *, unsigned int, struct old_timespec32 __user *, const sigset_t __user *, size_t);\n4303 long sys_unshare(unsigned long unshare_flags);\n4304 long sys_splice(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);\n4305 long sys_sync_file_range(int fd, loff_t offset, loff_t nbytes, unsigned int flags);\n4306 long sys_tee(int fdin, int fdout, size_t len, unsigned int flags);\n4307 long sys_vmsplice(int fd, const struct iovec __user *iov, unsigned long nr_segs, unsigned int flags);\n4308 long sys_move_pages(pid_t pid, unsigned long nr_pages, const void __user * __user *pages, const int __user *nodes, int __user *status, int flags);\n4309 long sys_set_robust_list(struct robust_list_head __user *head, size_t len);\n4310 long sys_get_robust_list(int pid, struct robust_list_head __user * __user *head_ptr, size_t __user *len_ptr);\n4311 long sys_kexec_load(unsigned long entry, unsigned long nr_segments, struct kexec_segment __user *segments, unsigned long flags);\n4312 long sys_getcpu(unsigned __user *cpu, unsigned __user *node, struct getcpu_cache __user *cache);\n4313 long sys_epoll_pwait(int epfd, struct epoll_event __user *events, int maxevents, int timeout, const sigset_t __user *sigmask, size_t sigsetsize);\n4314 long sys_ioprio_set(int which, int who, int ioprio);\n4315 long sys_ioprio_get(int which, int who);\n4316 long sys_utimensat_time32(unsigned int dfd, const char __user *filename, struct old_timespec32 __user *t, int flags);\n4317 long sys_signalfd(int ufd, sigset_t __user *user_mask, size_t sizemask);\n4318 long sys_ni_syscall(void);\n4319 long sys_eventfd(unsigned int count);\n4320 long sys_fallocate(int fd, int mode, loff_t offset, loff_t len);\n4321 long sys_timerfd_create(int clockid, int flags);\n4322 long sys_timerfd_gettime32(int ufd, struct old_itimerspec32 __user *otmr);\n4323 long sys_timerfd_settime32(int ufd, int flags, const struct old_itimerspec32 __user *utmr, struct old_itimerspec32 __user *otmr);\n4324 long sys_signalfd4(int ufd, sigset_t __user *user_mask, size_t sizemask, int flags);\n4325 long sys_eventfd2(unsigned int count, int flags);\n4326 long sys_epoll_create1(int flags);\n4327 long sys_dup3(unsigned int oldfd, unsigned int newfd, int flags);\n4328 long sys_pipe2(int __user *fildes, int flags);\n4329 long sys_inotify_init1(int flags);\n4330 long sys_preadv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);\n4331 long sys_pwritev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);\n4332 long sys_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t __user *uinfo);\n4333 long sys_perf_event_open(struct perf_event_attr __user *attr_uptr, pid_t pid, int cpu, int group_fd, unsigned long flags);\n4334 long sys_accept4(int, struct sockaddr __user *, int __user *, int);\n4335 long sys_recvmmsg_time32(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags, struct old_timespec32 __user *timeout);\n4336 long sys_fanotify_init(unsigned int flags, unsigned int event_f_flags);\n4337 long sys_fanotify_mark(int fanotify_fd, unsigned int flags, u64 mask, int fd, const char __user *pathname);\n4338 long sys_prlimit64(pid_t pid, unsigned int resource, const struct rlimit64 __user *new_rlim, struct rlimit64 __user *old_rlim);\n4339 long sys_name_to_handle_at(int dfd, const char __user *name, struct file_handle __user *handle, int __user *mnt_id, int flag);\n4340 long sys_open_by_handle_at(int mountdirfd, struct file_handle __user *handle, int flags);\n4341 long sys_clock_adjtime32(clockid_t which_clock, struct old_timex32 __user *tx);\n4342 long sys_syncfs(int fd);\n4343 long sys_sendmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags);\n4344 long sys_setns(int fd, int nstype);\n4345 long sys_process_vm_readv(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);\n4346 long sys_process_vm_writev(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);\n4347 long sys_kcmp(pid_t pid1, pid_t pid2, int type, unsigned long idx1, unsigned long idx2);\n4348 long sys_finit_module(int fd, const char __user *uargs, int flags);\n4349 long sys_sched_setattr(pid_t pid, struct sched_attr __user *attr, unsigned int flags);\n4350 long sys_sched_getattr(pid_t pid, struct sched_attr __user *attr, unsigned int size, unsigned int flags);\n4351 long sys_renameat2(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, unsigned int flags);\n4352 long sys_seccomp(unsigned int op, unsigned int flags, void __user *uargs);\n4353 long sys_getrandom(char __user *buf, size_t count, unsigned int flags);\n4354 long sys_memfd_create(const char __user *uname_ptr, unsigned int flags);\n4355 long sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);\n4356 long sys_execveat(int dfd, const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp, int flags);\n4357 long sys_userfaultfd(int flags);\n4358 long sys_membarrier(int cmd, int flags);\n4359 long sys_mlock2(unsigned long start, size_t len, int flags);\n4360 long sys_copy_file_range(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);\n4361 long sys_preadv2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);\n4362 long sys_pwritev2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);\n4363 long sys_pkey_mprotect(unsigned long start, size_t len, unsigned long prot, int pkey);\n4364 long sys_pkey_alloc(unsigned long flags, unsigned long init_val);\n4365 long sys_pkey_free(int pkey);\n4366 long sys_statx(int dfd, const char __user *path, unsigned flags, unsigned mask, struct statx __user *buffer);\n4367 long sys_rseq(struct rseq __user *rseq, uint32_t rseq_len, int flags, uint32_t sig);\n4368 long sys_io_pgetevents_time32(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct old_timespec32 __user *timeout, const struct __aio_sigset *sig);\n// Arch-specfic syscalls go here\n4393 long sys_semget(key_t key, int nsems, int semflg);\n4394 long sys_semctl(int semid, int semnum, int cmd, unsigned long arg);\n4395 long sys_shmget(key_t key, size_t size, int flag);\n4396 long sys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);\n4397 long sys_shmat(int shmid, char __user *shmaddr, int shmflg);\n4398 long sys_shmdt(char __user *shmaddr);\n4399 long sys_msgget(key_t key, int msgflg);\n4400 long sys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz, int msgflg);\n4401 long sys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz, long msgtyp, int msgflg);\n4402 long sys_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);\n4403 long sys_clock_gettime(clockid_t which_clock, struct __kernel_timespec __user *tp);\n4404 long sys_clock_settime(clockid_t which_clock, const struct __kernel_timespec __user *tp);\n4405 long sys_clock_adjtime(clockid_t which_clock, struct __kernel_timex __user *tx);\n4406 long sys_clock_getres(clockid_t which_clock, struct __kernel_timespec __user *tp);\n4407 long sys_clock_nanosleep(clockid_t which_clock, int flags, const struct __kernel_timespec __user *rqtp, struct __kernel_timespec __user *rmtp);\n4408 long sys_timer_gettime(timer_t timer_id, struct __kernel_itimerspec __user *setting);\n4409 long sys_timer_settime(timer_t timer_id, int flags, const struct __kernel_itimerspec __user *new_setting, struct __kernel_itimerspec __user *old_setting);\n4410 long sys_timerfd_gettime(int ufd, struct __kernel_itimerspec __user *otmr);\n4411 long sys_timerfd_settime(int ufd, int flags, const struct __kernel_itimerspec __user *utmr, struct __kernel_itimerspec __user *otmr);\n4412 long sys_utimensat(int dfd, const char __user *filename, struct __kernel_timespec __user *utimes, int flags);\n4413 long sys_pselect6(int, fd_set __user *, fd_set __user *, fd_set __user *, struct __kernel_timespec __user *, void __user *);\n4414 long sys_ppoll(struct pollfd __user *, unsigned int, struct __kernel_timespec __user *, const sigset_t __user *, size_t);\n4416 long sys_io_pgetevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct __kernel_timespec __user *timeout, const struct __aio_sigset *sig);\n4417 long sys_recvmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags, struct __kernel_timespec __user *timeout);\n```\n\n----------------------------------------\n\nTITLE: Running PANDA with Custom taint2 Options and tainted_net\nDESCRIPTION: This command demonstrates how to pass custom options to the 'taint2' plugin (disabling tainted pointers) while using 'tainted_net' to label incoming network data and 'tainted_instr' to track instructions processing that data.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/tainted_net/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/i386-softmmu/panda-system-i386 -net nic -net user \\\n    -replay foo \\\n    -panda taint2:no_tp=y \\\n    -panda tainted_net:label_incoming_network=true \\\n    -panda tainted_instr\n```\n\n----------------------------------------\n\nTITLE: Declaring After Virtual Memory Read Callback Signature in PANDA (C)\nDESCRIPTION: Defines a plugin interface for monitoring or acting after virtual memory read operations, with access to CPU state, PC, address, size, and a pointer to the data that was just read. Requires memory callbacks to be enabled. No return value, intended for observation or analysis of memory results.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_42\n\nLANGUAGE: C\nCODE:\n```\nvoid (*virt_mem_after_read)(CPUState *env, target_ulong pc, target_ulong addr, target_ulong size, void *buf);\n```\n\n----------------------------------------\n\nTITLE: Adding Hotplugged RAM via QEMU Monitor Commands - QEMU Monitor\nDESCRIPTION: This snippet provides QEMU monitor commands that dynamically create a memory backend ('memory-backend-ram') and a corresponding front-end device ('pc-dimm') to hotplug RAM into a running guest. The object_add command establishes a 1GB memory block with the ID mem1; device_add attaches this backend to a new DIMM slot (dimm1). These commands require an active QEMU instance configured with available slots and appropriate permissions. Inputs include the memory size and unique IDs; outputs are the active memory increase in the guest.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/memory-hotplug.txt#_snippet_1\n\nLANGUAGE: qemu-monitor\nCODE:\n```\n(qemu) object_add memory-backend-ram,id=mem1,size=1G\n(qemu) device_add pc-dimm,id=dimm1,memdev=mem1\n```\n\n----------------------------------------\n\nTITLE: Exporting Build Variables and Executing PANDA Build Script (Shell)\nDESCRIPTION: This shell snippet sets essential environment variables and initiates the PANDA build process. It assigns PANDA_LLVM_ROOT and compiler flags, then calls the build.sh script. These variables control the build configuration and suppress certain compiler errors. Dependencies include a prepared build environment and that prior dependency installation steps have been completed. Inputs are environment variables; output is the build product from build.sh.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/build_arch.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nexport PANDA_LLVM_ROOT=/opt/llvm33\nexport CFLAGS=-Wno-error\n./build.sh\n\n```\n\n----------------------------------------\n\nTITLE: Programmatic Record and Replay Control for PANDA via C\nDESCRIPTION: These functions let plugins initiate or terminate VM recording and replay in PANDA. Each call either begins or ends a mode (record or replay), using a session name and optional snapshot argument where applicable. Requests are queued and processed after the current basic block; functions return a status code (RRCTRL_OK, RRCTRL_EPENDING, or RRCTRL_ERROR) to indicate success or failure. Correct use requires awareness of current record/replay state and pending operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nint panda_vm_quit(void);\n```\n\nLANGUAGE: C\nCODE:\n```\nint panda_record_begin(const char *name, const char *snapshot);\n```\n\nLANGUAGE: C\nCODE:\n```\nint panda_record_end(void);\n```\n\nLANGUAGE: C\nCODE:\n```\nint panda_replay_begin(const char *name);\n```\n\nLANGUAGE: C\nCODE:\n```\nint panda_replay_end(void);\n```\n\n----------------------------------------\n\nTITLE: Disabling and Enabling Plugins in PANDA using C\nDESCRIPTION: Code to enable or disable callbacks for a loaded PANDA plugin by its handle. Disabling a plugin prevents its callbacks from being triggered; enabling re-activates them. Such functionality facilitates flexible, dynamic plugin management during emulation sessions. Relies on PANDA's core API.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_17\n\nLANGUAGE: C\nCODE:\n```\nvoid   panda_disable_plugin(void *plugin);\n```\n\nLANGUAGE: C\nCODE:\n```\nvoid   panda_enable_plugin(void *plugin);\n```\n\n----------------------------------------\n\nTITLE: Configuring Quorum Block Device for COLO Replication - QEMU Command Line - shell\nDESCRIPTION: This shell snippet demonstrates setting up a QEMU drive using the 'quorum' block driver, specifying child raw disk files with required quorum parameters for COLO block replication. No external dependencies are needed beyond QEMU. The primary parameters are 'if', 'driver', 'read-pattern', 'id', 'vote-threshold', and a list of child device parameters. This configuration is the basis for adding block replication and can be extended with further QMP commands.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/block-replication.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n-drive if=xxx,driver=quorum,read-pattern=fifo,id=colo1,vote-threshold=1,\\\n       children.0.file.filename=1.raw,\\\n       children.0.driver=raw\n```\n\n----------------------------------------\n\nTITLE: Setting Disk I/O Throttle via QMP - JSON\nDESCRIPTION: This code snippet shows how to use QEMU's QMP interface to apply disk IOPS limits to a device by sending a JSON command. All I/O throttle parameters are specified: active limiting is set for iops (100), while others (iops_rd, iops_wr, bps, bps_rd, bps_wr) are set to 0, meaning unlimited. This command requires an open QMP session and is typically handled via a control program or script. Input is a JSON object; the device's performance is constrained per the provided arguments.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/throttle.txt#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"execute\": \"block_set_io_throttle\",\n  \"arguments\": {\n    \"device\": \"virtio0\",\n    \"iops\": 100,\n    \"iops_rd\": 0,\n    \"iops_wr\": 0,\n    \"bps\": 0,\n    \"bps_rd\": 0,\n    \"bps_wr\": 0\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking PANDA with osi_linux Plugin (Bash Execution Command)\nDESCRIPTION: This Bash command shows how to run the PANDA emulator with a Linux replay, loading the osi and osi_linux plugins, and pointing osi_linux at a local kernelinfo.conf configuration. The kconf_group value must match a section in the configuration file corresponding to the guest kernel. Output of the osi_test plugin is displayed to the user. Required dependencies: PANDA built for the guest architecture, correctly configured kernelinfo.conf.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi_linux/README.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo \\\n    -panda osi -panda osi_linux:kconf_file=kernelinfo.conf,kconf_group=my_kernel_info \\\n    -panda osi_test\n\n```\n\n----------------------------------------\n\nTITLE: Reading a Shared Reference with RCU in C\nDESCRIPTION: This snippet demonstrates how to use RCU read-side protection to safely and atomically read a shared pointer, ensuring the value remains valid for the duration of the critical section. It requires the use of rcu_read_lock(), atomic_rcu_read(), and rcu_read_unlock() functions. The input is a global variable 'foo', and the snippet outputs a reference 'p' that is valid during the critical section. Ensure atomic_rcu_read and RCU primitives are available in your environment.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/rcu.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nrcu_read_lock();\np = atomic_rcu_read(&foo);\n/* do something with p. */\nrcu_read_unlock();\n```\n\n----------------------------------------\n\nTITLE: Running filereadmon plugin with Windows in PANDA\nDESCRIPTION: Example command for running the filereadmon plugin with Windows 32-bit system in PANDA. This demonstrates basic usage with a replay session named 'foo'.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/filereadmon/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$PANDA_PATH/i386-softmmu/panda-system-i386 -replay foo \\\n    -os windows-32-xpsp3 -panda filereadmon\n```\n\n----------------------------------------\n\nTITLE: Security and Resource Management Prototypes in C\nDESCRIPTION: Function prototypes for Linux system calls related to security features, resource limits, and system control. These functions manage process resource limits, security policies, and restricted execution environments.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_13\n\nLANGUAGE: c\nCODE:\n```\nlong sys_seccomp(unsigned int op, unsigned int flags, void __user *uargs);\nlong sys_getrandom(char __user *buf, size_t count, unsigned int flags);\nlong sys_memfd_create(const char __user *uname_ptr, unsigned int flags);\nlong sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);\nlong sys_execveat(int dfd, const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp, int flags);\nlong sys_userfaultfd(int flags);\nlong sys_membarrier(int cmd, int flags);\nlong sys_rseq(struct rseq __user *rseq, uint32_t rseq_len, int flags, uint32_t sig);\nlong sys_prlimit64(pid_t pid, unsigned int resource, const struct rlimit64 __user *new_rlim, struct rlimit64 __user *old_rlim);\nlong sys_kexec_load(unsigned long entry, unsigned long nr_segments, struct kexec_segment __user *segments, unsigned long flags);\nlong sys_sched_setattr(pid_t pid, struct sched_attr __user *attr, unsigned int flags);\nlong sys_sched_getattr(pid_t pid, struct sched_attr __user *attr, unsigned int size, unsigned int flags);\nlong sys_finit_module(int fd, const char __user *uargs, int flags);\nlong sys_kcmp(pid_t pid1, pid_t pid2, int type, unsigned long idx1, unsigned long idx2);\nlong sys_setns(int fd, int nstype);\n```\n\n----------------------------------------\n\nTITLE: Launching QEMU with Emulated Smart Card and Certificates Backend - Shell\nDESCRIPTION: This command starts a QEMU VM that attaches a USB CCID device and emulates a smart card with a certificates backend, pointing to a specific NSS database and assigned certificate nicknames for user, signing, and encryption. Required prerequisites are completed certificate setup and a properly built QEMU. Key parameters: 'backend', 'db', 'cert1', 'cert2', 'cert3'. Output is a guest VM that interacts with the emulated smart card using file-based certificates.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/ccid.txt#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nqemu -usb -device usb-ccid -device ccid-card-emulated,backend=certificates,db=sql:$PWD,cert1=id-cert,cert2=signing-cert,cert3=encryption-cert\n```\n\n----------------------------------------\n\nTITLE: Defining Thread Start Callback in PANDA hooks2 Plugin\nDESCRIPTION: Defines the signature for the on_thread_start callback function that gets triggered when a new thread starts. The callback provides CPU state, process name, address space ID (asid), process ID, and thread ID information.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/hooks2/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nvoid on_thread_start(\n    CPUState *cpu,\n    const char *procname,\n    target_ulong asid,\n    target_pid_t pid,\n    target_pid_t tid);\n```\n\n----------------------------------------\n\nTITLE: Declaring Before Block Execution with Invalidate Option Callback in PANDA (C)\nDESCRIPTION: Declares a callback type used before basic block execution with an added mechanism for plugins to invalidate the current translation block (TB) and request its re-translation, by returning true. Parameters include CPU state and translation block; return value is a boolean indicating whether to invalidate the TB. Requires prior integration with PANDA's memory and block translation internals.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_33\n\nLANGUAGE: C\nCODE:\n```\nbool (*before_block_exec_invalidate_opt)(CPUState *env, TranslationBlock *tb);\n```\n\n----------------------------------------\n\nTITLE: Running PANDA with proc_trace Plugin\nDESCRIPTION: Example command showing how to run PANDA with the proc_trace plugin enabled and logging process data to a plog file. Uses pandare.qcows module to set up the QEMU environment for x86_64 architecture.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/proc_trace/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$(python3 -m pandare.qcows x86_64) -panda proc_trace -plog my_proc_data.plog\n```\n\n----------------------------------------\n\nTITLE: Building and Running PANDA Docker Container from Source (Shell)\nDESCRIPTION: This shell snippet details building the PANDA Docker image locally from the project repository using Docker BuildKit and running the main program. Required dependencies: Docker with BuildKit support enabled. The '--target=panda' build target yields a minimal container. The command runs the PANDA binary with '--help' parameter, returning usage information. This method is suitable if users wish to customize their build or avoid downloading from Docker Hub.\nSOURCE: https://github.com/panda-re/panda/blob/dev/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ DOCKER_BUILDKIT=1 docker build --target=panda -t panda .\\n$ docker run --rm panda panda-system-i386 --help\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building QEMU with Smartcard Support - Shell\nDESCRIPTION: This snippet shows the standard procedure to configure and build QEMU's smart card capability by enabling the smartcard option during configuration. The prerequisites are the NSS libraries and a build environment with typical Unix development tools. Inputs are the execution of the 'configure' script with parameters, and outputs are compiled binaries with smartcard support enabled. The process must be executed from the root of the QEMU source tree.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/ccid.txt#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n./configure --enable-smartcard && make\n```\n\n----------------------------------------\n\nTITLE: Defining Memory Management System Calls in C\nDESCRIPTION: Function declarations for Linux system calls related to memory management, including memory policies, page migration, and memory mapping operations. These calls enable fine-grained control of memory allocation and usage.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_30\n\nLANGUAGE: C\nCODE:\n```\nlong sys_remap_file_pages(unsigned long start, unsigned long size, unsigned long prot, unsigned long pgoff, unsigned long flags);\nlong sys_mbind(unsigned long start, unsigned long len, unsigned long mode, const unsigned long __user *nmask, unsigned long maxnode, unsigned flags);\nlong sys_get_mempolicy(int __user *policy, unsigned long __user *nmask, unsigned long maxnode, unsigned long addr, unsigned long flags);\nlong sys_set_mempolicy(int mode, const unsigned long __user *nmask, unsigned long maxnode);\nlong sys_migrate_pages(pid_t pid, unsigned long maxnode, const unsigned long __user *from, const unsigned long __user *to);\nlong sys_move_pages(pid_t pid, unsigned long nr_pages, const void __user * __user *pages, const int __user *nodes, int __user *status, int flags);\n```\n\n----------------------------------------\n\nTITLE: Converting Android Images for PANDA with pandroidConverter.py - Python Script - Python\nDESCRIPTION: The pandroidConverter.py script is used to prepare Android guest images for PANDA. It converts filesystems into QCOW2 files and copies the required kernel and initramfs. The script should be invoked from the /scripts directory, and relies on Python and the presence of relevant Android Virtual Device (AVD) files. Its inputs are the source files from the AVD, and outputs are PANDA-compatible QCOW2 images and boot files. Users must ensure all required files are available in the correct paths prior to execution.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/Android.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Usage: Run from /scripts directory\n# Converts filesystems and copies kernel/initramfs for Android guests\npython3 pandroidConverter.py --avd-path /path/to/avd --output-dir /androidstuff\n```\n\n----------------------------------------\n\nTITLE: Inter-Process Communication System Call Declarations in C\nDESCRIPTION: Function declarations for Linux system calls related to inter-process communication (IPC). These declarations define interfaces for shared memory, semaphores, and message queues that allow processes to exchange data and synchronize execution.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_20\n\nLANGUAGE: C\nCODE:\n```\nlong sys_shmget(key_t key, size_t size, int flag);\nlong sys_shmat(int shmid, char __user *shmaddr, int shmflg);\nlong sys_old_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);\nlong sys_shmdt(char __user *shmaddr);\nlong sys_semget(key_t key, int nsems, int semflg);\nlong sys_semop(int semid, struct sembuf __user *sops, unsigned nsops);\nlong sys_semctl(int semid, int semnum, int cmd, unsigned long arg);\nlong sys_msgget(key_t key, int msgflg);\nlong sys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz, int msgflg);\nlong sys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz, long msgtyp, int msgflg);\nlong sys_old_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);\n```\n\n----------------------------------------\n\nTITLE: Manual GDB Commands for Kernel Info Extraction\nDESCRIPTION: These GDB commands show how to manually load and execute the kernel information extraction script within GDB. They include starting GDB, loading the Python script, running the custom command, and quitting GDB.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi_linux/utils/kernelinfo_gdb/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngdb ./vmlinux\nsource extract_kernelinfo.py\nkernel_info output.file\nq\n```\n\n----------------------------------------\n\nTITLE: Installing PANDA Core Dependencies\nDESCRIPTION: List of essential packages required for building the core PANDA project. Includes development libraries and tools necessary for compilation and execution.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/dependencies/ubuntu_18.04_build.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Note that Ubuntu 18.04 requires a PPA for LLVM 11\n\nlibc++-dev\nlibelf-dev\nlibglib2.0-0\nlibsasl2-dev\nlibsdl1.2debian\nlibtool-bin\nlibvirglrenderer-dev\nlibwiretap8\nlibxenstore3.0\nlsb-core\n\n# panda build deps\nbuild-essential\nchrpath\nclang-11\ngcc\nlibcapstone-dev\nlibdwarf-dev\nlibprotoc-dev\nllvm-11-dev\nprotobuf-c-compiler\nprotobuf-compiler\npython3-dev\nzip\n```\n\n----------------------------------------\n\nTITLE: Declaring Get Mapping Base Address by Name Callback Typedef in C\nDESCRIPTION: Defines a callback typedef that, when given a mapping name and a process, retrieves the base address of that named mapping. Receives CPUState, OsiProc pointer, name string, and output for base address (target_ptr_t*). Used for quickly resolving library or segment bases in the guest OS.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_17\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_get_mapping_base_address_by_name_t)(CPUState *, OsiProc *, char *, target_ptr_t *)\n```\n\n----------------------------------------\n\nTITLE: NT Native API Function Declarations for Windows System Operations in C\nDESCRIPTION: A collection of Windows NT Native API function declarations that provide low-level system functionality. These functions are used for operations such as unloading drivers, managing virtual memory, file operations, and synchronization primitives. These functions typically return NTSTATUS values and require specific parameters for various system resources.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/all_windows_prototypes.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtUnloadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtUnloadKey (POBJECT_ATTRIBUTES TargetKey);\nNTSTATUS NtUnloadKey2 (POBJECT_ATTRIBUTES TargetKey, ULONG Flags);\nNTSTATUS NtUnloadKeyEx (POBJECT_ATTRIBUTES TargetKey, HANDLE Event);\nNTSTATUS NtUnlockFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key);\nNTSTATUS NtUnlockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtUnmapViewOfSection (HANDLE ProcessHandle, PVOID BaseAddress);\nNTSTATUS NtVdmControl (VDMSERVICECLASS Service, PVOID ServiceData);\nNTSTATUS NtWaitForDebugEvent (HANDLE DebugObjectHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PDBGUI_WAIT_STATE_CHANGE WaitStateChange);\nNTSTATUS NtWaitForKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitForMultipleObjects (ULONG Count, HANDLE Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitForMultipleObjects32 (ULONG Count, LONG Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitForSingleObject (HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitForWorkViaWorkerFactory (HANDLE WorkerFactoryHandle, PFILE_IO_COMPLETION_INFORMATION MiniPacket);\nNTSTATUS NtWaitHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtWaitLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtWorkerFactoryWorkerReady (HANDLE WorkerFactoryHandle);\nNTSTATUS NtWriteFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtWriteFileGather (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtWriteRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\nNTSTATUS NtWriteVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\nNTSTATUS NtYieldExecution ();\nNTSTATUS NtNotifyChangeSession (HANDLE Session, ULONG IoStateSequence, PVOID Reserved, ULONG Action, IO_SESSION_STATE IoState, IO_SESSION_STATE IoState2, PVOID Buffer, ULONG BufferSize);\nNTSTATUS NtQueryLicenseValue (PUNICODE_STRING Name, PULONG Type, PVOID Buffer, ULONG Length, PULONG ReturnedLength);\n```\n\n----------------------------------------\n\nTITLE: Unloading a Plugin at Runtime in PANDA using C\nDESCRIPTION: Enables the removal of a previously loaded plugin from the PANDA environment using its handle. This is useful for dynamically unloading plugins during emulation or from the monitor. The plugin parameter should be a void pointer obtained from plugin loading or retrieval functions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_16\n\nLANGUAGE: C\nCODE:\n```\nvoid   panda_unload_plugin(void *plugin);\n```\n\n----------------------------------------\n\nTITLE: VPATH, Non-VPATH, and Output File Grouping in QEMU Makefile - Makefile\nDESCRIPTION: These Makefile snippets illustrate object file variable grouping and platform-conditional additions for the QEMU build system. They show standard practices for modular compilation and handling cross-platform differences (notably between POSIX and Windows) via config variables. Dependencies include GNU make and the environment variables/definitions from the configure script. Inputs are source/object file lists and environment macros; outputs are composite object/libraries. Limitations are that proper config variable assignment is required for correct expansion. Supports extensibility by adding or conditioning object file groupings.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/build-system.txt#_snippet_2\n\nLANGUAGE: Makefile\nCODE:\n```\nutil-obj-y += bitmap.o bitops.o hbitmap.o\\nutil-obj-y += fifo8.o\\nutil-obj-y += acl.o\\nutil-obj-y += error.o qemu-error.o\n```\n\nLANGUAGE: Makefile\nCODE:\n```\nutil-obj-$(CONFIG_WIN32) += oslib-win32.o qemu-thread-win32.o\\nutil-obj-$(CONFIG_POSIX) += oslib-posix.o qemu-thread-posix.o\n```\n\n----------------------------------------\n\nTITLE: Running Memorymap Plugin with PANDA\nDESCRIPTION: Example command showing how to run the memorymap plugin on a Windows 2000 32-bit recording to analyze memory mappings at specific instruction addresses. The command specifies two target instruction addresses to monitor.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/memorymap/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/i386-softmmu/qemu-system-i386 -replay foo -os windows-32-2000 -panda memorymap:pcs=0xbfeee8bd-0x80069a0f\n```\n\n----------------------------------------\n\nTITLE: Setting Up Network Device Replay in PANDA\nDESCRIPTION: Configuration for network device recording and replay using the replay filter. Shows how to set up a user network backend with RTL8139 device and associated replay filter.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/replay.txt#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n-netdev user,id=net1 -device rtl8139,netdev=net1\n-object filter-replay,id=replay,netdev=net1\n```\n\n----------------------------------------\n\nTITLE: Callback Function for String Argument Match in C\nDESCRIPTION: This C function signature represents the callback triggered when a string argument matches a target value. It provides CPU state, argument array, matching index, matched string value, and number of arguments read.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/callwitharg/README.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\non_call_match_str(CPUState *cpu, target_ulong* args, uint matching_idx, char* value, uint args_read);\n```\n\n----------------------------------------\n\nTITLE: Sample MMIO Event JSON Log - PANDA mmio_trace Output\nDESCRIPTION: This JSON snippet presents the actual data format output by the mmio_trace plugin, capturing sequential MMIO accesses (type, PC, physical/virtual address, size, value, device). No dependencies; the log is generated during PANDA execution when 'out_log' is set. Each entry reflects a single access and all relevant event fields. Note: Virtual addresses may be equal to physical addresses, especially on CPUs without MMUs.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/mmio_trace/README.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{ \\\"type\\\": \\\"R\\\", \\\"guest_pc\\\": \\\"0x0000043e\\\", \\\"phys_addr\\\": \\\"0x00000010\\\", \\\"virt_addr\\\": \\\"0xe000e010\\\", \\\"size\\\": \\\"0x00000004\\\", \\\"value\\\": \\\"0x00000000\\\", \\\"device\\\": \\\"systick\\\" },\\n{ \\\"type\\\": \\\"W\\\", \\\"guest_pc\\\": \\\"0x00000444\\\", \\\"phys_addr\\\": \\\"0x00000010\\\", \\\"virt_addr\\\": \\\"0xe000e010\\\", \\\"size\\\": \\\"0x00000004\\\", \\\"value\\\": \\\"0x00000004\\\", \\\"device\\\": \\\"systick\\\" },\\n{ \\\"type\\\": \\\"W\\\", \\\"guest_pc\\\": \\\"0x0000044a\\\", \\\"phys_addr\\\": \\\"0x00000014\\\", \\\"virt_addr\\\": \\\"0xe000e014\\\", \\\"size\\\": \\\"0x00000004\\\", \\\"value\\\": \\\"0x00001000\\\", \\\"device\\\": \\\"systick\\\" },\\n{ \\\"type\\\": \\\"W\\\", \\\"guest_pc\\\": \\\"0x0000044c\\\", \\\"phys_addr\\\": \\\"0x00000018\\\", \\\"virt_addr\\\": \\\"0xe000e018\\\", \\\"size\\\": \\\"0x00000004\\\", \\\"value\\\": \\\"0x00000000\\\", \\\"device\\\": \\\"systick\\\" },\\n{ \\\"type\\\": \\\"R\\\", \\\"guest_pc\\\": \\\"0x0000044e\\\", \\\"phys_addr\\\": \\\"0x00000010\\\", \\\"virt_addr\\\": \\\"0xe000e010\\\", \\\"size\\\": \\\"0x00000004\\\", \\\"value\\\": \\\"0x00000004\\\", \\\"device\\\": \\\"systick\\\" },\\n{ \\\"type\\\": \\\"W\\\", \\\"guest_pc\\\": \\\"0x00000454\\\", \\\"phys_addr\\\": \\\"0x00000010\\\", \\\"virt_addr\\\": \\\"0xe000e010\\\", \\\"size\\\": \\\"0x00000004\\\", \\\"value\\\": \\\"0x00000005\\\", \\\"device\\\": \\\"systick\\\" },\\n{ \\\"type\\\": \\\"R\\\", \\\"guest_pc\\\": \\\"0x00000478\\\", \\\"phys_addr\\\": \\\"0x00000010\\\", \\\"virt_addr\\\": \\\"0xe000e010\\\", \\\"size\\\": \\\"0x00000004\\\", \\\"value\\\": \\\"0x00000005\\\", \\\"device\\\": \\\"systick\\\" },\\n{ \\\"type\\\": \\\"R\\\", \\\"guest_pc\\\": \\\"0x00000480\\\", \\\"phys_addr\\\": \\\"0x00000018\\\", \\\"virt_addr\\\": \\\"0xe000e018\\\", \\\"size\\\": \\\"0x00000004\\\", \\\"value\\\": \\\"0x00000e41\\\", \\\"device\\\": \\\"systick\\\" },\\n{ \\\"type\\\": \\\"R\\\", \\\"guest_pc\\\": \\\"0x00000478\\\", \\\"phys_addr\\\": \\\"0x00000010\\\", \\\"virt_addr\\\": \\\"0xe000e010\\\", \\\"size\\\": \\\"0x00000004\\\", \\\"value\\\": \\\"0x00000005\\\", \\\"device\\\": \\\"systick\\\" },\\n{ \\\"type\\\": \\\"R\\\", \\\"guest_pc\\\": \\\"0x00000480\\\", \\\"phys_addr\\\": \\\"0x00000018\\\", \\\"virt_addr\\\": \\\"0xe000e018\\\", \\\"size\\\": \\\"0x00000004\\\", \\\"value\\\": \\\"0x00000df1\\\", \\\"device\\\": \\\"systick\\\" }\n```\n\n----------------------------------------\n\nTITLE: Defining Test Registers and Operations - Markdown\nDESCRIPTION: This snippet describes switch test registers, including register offsets, bit-widths, read/write behaviors, and associated DMA control operations in table format. It lists each test register, its memory offset, and functions for troubleshooting and diagnostics (interrupts, DMA, etc.). Prerequisites include familiarity with register map structures and numeric data types; output is to be interpreted by hardware engineers or driver programmers. The code uses Markdown formatting for tables and conventions; there are no explicit code dependencies.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/rocker.txt#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n    TEST_REG, offset 0x0010, 32-bit (R/W)\n    TEST_REG64, offset 0x0018, 64-bit (R/W)\n    TEST_IRQ, offset 0x0020, 32-bit (R/W)\n    TEST_DMA_ADDR, offset 0x0028, 64-bit (R/W)\n    TEST_DMA_SIZE, offset 0x0030, 32-bit (R/W)\n    TEST_DMA_CTRL, offset 0x0034, 32-bit (R/W)\n\n    operation        value   description\n    -----------------------------------------------------------\n    TEST_DMA_CTRL_CLEAR   1   clear buffer\n    TEST_DMA_CTRL_FILL    2   fill buffer bytes with 0x96\n    TEST_DMA_CTRL_INVERT  4   invert bytes in buffer\n\n```\n\n----------------------------------------\n\nTITLE: Recording HD to I/O Buffer Transfer in DMA Callback\nDESCRIPTION: Code from ide_dma_cb that records DMA transfers from hard drive to I/O buffer, creating log entries for replay with sector address information and transfer size.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/hd_taint.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nrr_record_hd_transfer\n  (RR_CALLSITE_IDE_DMA_CB,\n   HD_TRANSFER_HD_TO_IOB,\n   HD_BASE_ADDR + sector_num*512,\n   (uint64_t) s->io_buffer, \n   n*512);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Calls in C\nDESCRIPTION: This snippet contains multiple function declarations for Windows NT system calls. These functions are part of the native API and provide low-level access to system resources. They cover operations like file control, thread context manipulation, process enumeration, and various system state queries.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/all_windows_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtFsControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nULONG NtGetCurrentProcessorNumber ();\nNTSTATUS NtGetDevicePowerState (HANDLE Device, DEVICE_POWER_STATE *State);\nNTSTATUS NtGetMUIRegistryInfo (ULONG Flags, PULONG DataSize, PVOID Data);\nNTSTATUS NtGetNextProcess (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewProcessHandle);\nNTSTATUS NtGetNextThread (HANDLE ProcessHandle, HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewThreadHandle);\nNTSTATUS NtGetNlsSectionPtr (ULONG SectionType, ULONG SectionData, PVOID ContextData, PVOID *SectionPointer, PULONG SectionSize);\nNTSTATUS NtGetNotificationResourceManager (HANDLE ResourceManagerHandle, PTRANSACTION_NOTIFICATION TransactionNotification, ULONG NotificationLength, PLARGE_INTEGER Timeout, PULONG ReturnLength, ULONG Asynchronous, ULONG_PTR AsynchronousContext);\nNTSTATUS NtGetPlugPlayEvent (HANDLE EventHandle, PVOID Context, PPLUGPLAY_EVENT_BLOCK EventBlock, ULONG EventBufferSize);\nNTSTATUS NtGetWriteWatch (HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, SIZE_T RegionSize, PVOID *UserAddressArray, PULONG_PTR EntriesInUserAddressArray, PULONG Granularity);\nNTSTATUS NtImpersonateAnonymousToken (HANDLE ThreadHandle);\nNTSTATUS NtImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE Message);\nNTSTATUS NtImpersonateThread (HANDLE ServerThreadHandle, HANDLE ClientThreadHandle, PSECURITY_QUALITY_OF_SERVICE SecurityQos);\nNTSTATUS NtInitializeNlsFiles (PVOID *BaseAddress, PLCID DefaultLocaleId, PLARGE_INTEGER DefaultCasingTableSize);\nNTSTATUS NtInitializeRegistry (USHORT BootCondition);\nNTSTATUS NtInitiatePowerAction (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);\nNTSTATUS NtIsProcessInJob (HANDLE ProcessHandle, HANDLE JobHandle);\nBOOLEAN NtIsSystemResumeAutomatic ();\nNTSTATUS NtIsUILanguageComitted ();\nNTSTATUS NtListenPort (HANDLE PortHandle, PPORT_MESSAGE ConnectionRequest);\nNTSTATUS NtLoadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtLoadKey (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile);\nNTSTATUS NtLoadKey2 (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags);\nNTSTATUS NtLoadKeyEx (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags, HANDLE TrustClassKey );\nNTSTATUS NtLockFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);\nNTSTATUS NtLockProductActivationKeys (ULONG *pPrivateVer, ULONG *pSafeMode);\nNTSTATUS NtLockRegistryKey (HANDLE KeyHandle);\nNTSTATUS NtLockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtMakePermanentObject (HANDLE Handle);\nNTSTATUS NtMakeTemporaryObject (HANDLE Handle);\nNTSTATUS NtMapCMFModule (ULONG What, ULONG Index, PULONG CacheIndexOut, PULONG CacheFlagsOut, PULONG ViewSizeOut, PVOID *BaseAddress);\nNTSTATUS NtMapUserPhysicalPages (PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, WIN32_PROTECTION_MASK Win32Protect);\nNTSTATUS NtModifyBootEntry (PBOOT_ENTRY BootEntry);\nNTSTATUS NtModifyDriverEntry (PEFI_DRIVER_ENTRY DriverEntry);\nNTSTATUS NtNotifyChangeDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree);\nNTSTATUS NtNotifyChangeKey (HANDLE KeyHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtNotifyChangeMultipleKeys (HANDLE MasterKeyHandle, ULONG Count, OBJECT_ATTRIBUTES SlaveObjects[], HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtOpenDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, LPGUID EnlistmentGuid, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);\nNTSTATUS NtOpenIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKeyEx (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG OpenOptions);\nNTSTATUS NtOpenKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE TransactionHandle);\nNTSTATUS NtOpenKeyTransactedEx (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG OpenOptions, HANDLE TransactionHandle);\nNTSTATUS NtOpenKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, ACCESS_MASK GrantedAccess, PPRIVILEGE_SET Privileges, BOOLEAN ObjectCreation, BOOLEAN AccessGranted, PBOOLEAN GenerateOnClose);\nNTSTATUS NtOpenPrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\nNTSTATUS NtOpenProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenProcessToken (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);\nNTSTATUS NtOpenProcessTokenEx (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID ResourceManagerGuid, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSession (PHANDLE SessionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenThreadToken (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);\nNTSTATUS NtOpenThreadTokenEx (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle);\nNTSTATUS NtOpenTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, LPGUID TmIdentity, ULONG OpenOptions);\nNTSTATUS NtPlugPlayControl (PLUGPLAY_CONTROL_CLASS PnPControlClass, PVOID PnPControlData, ULONG PnPControlDataLength);\nNTSTATUS NtPowerInformation (POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtPrePrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrePrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrivilegeCheck (HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, PBOOLEAN Result);\nNTSTATUS NtPrivilegeObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\nNTSTATUS NtPrivilegedServiceAuditAlarm (PUNICODE_STRING SubsystemName, PUNICODE_STRING ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\nNTSTATUS NtPropagationComplete (HANDLE ResourceManagerHandle, ULONG RequestCookie, ULONG BufferLength, PVOID Buffer);\n```\n\n----------------------------------------\n\nTITLE: Unpacking Bug Replay Log - Python Script - Bash\nDESCRIPTION: This snippet invokes the 'rrunpack.py' script from the PANDA scripts directory to extract the provided replay log ('cve-2011-1255-crash.rr'). This step is necessary to prepare recorded traces for replay. Python and any libraries required by the script must be available, and the given *.rr file must be obtainable from rrshare.org.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/UAF.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npanda/scripts/rrunpack.py cve-2011-1255-crash.rr\n```\n\n----------------------------------------\n\nTITLE: Writing QEMU Trace Event Names to a File in Shell\nDESCRIPTION: These shell commands append specific trace event names to a file used by QEMU's tracing infrastructure. The event names 'bdrv_aio_readv' and 'bdrv_aio_writev' are written into /tmp/events, one per line. This file is later supplied to QEMU to enable tracing only those events. Requires shell access. Inputs: event names. Output: A file ready for QEMU trace event selection.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/tracing.txt#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\necho bdrv_aio_readv   > /tmp/events\necho bdrv_aio_writev >> /tmp/events\n```\n\n----------------------------------------\n\nTITLE: Parsing Error Example in QMP\nDESCRIPTION: Shows an example of a parsing error response in QMP due to invalid JSON syntax in the command.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qmp-spec.txt#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{ \"execute\": }\n```\n\nLANGUAGE: json\nCODE:\n```\n{ \"error\": { \"class\": \"GenericError\", \"desc\": \"Invalid JSON syntax\" } }\n```\n\n----------------------------------------\n\nTITLE: Accessing Protected Value with qemu_lockcnt_inc/dec in C\nDESCRIPTION: Here, the snippet demonstrates incrementing the QemuLockCnt reference count before accessing a shared object and decrementing it afterward. The atomic_rcu_read function ensures the value of xyz is safely read with RCU memory barriers. This pattern enables safe concurrent access, relying on QEMU's QemuLockCnt and atomic RCU helpers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/lockcnt.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nqemu_lockcnt_inc(&xyz_lockcnt);\nif (xyz) {\n    XYZ *p = atomic_rcu_read(&xyz);\n    ...\n    /* Accesses can now be done through \"p\".  */\n}\nqemu_lockcnt_dec(&xyz_lockcnt);\n```\n\n----------------------------------------\n\nTITLE: Defining NT System Call Prototypes with NTSTATUS Return - C\nDESCRIPTION: Declares a collection of NT native system call prototypes in C, each returning NTSTATUS and accepting context-specific typed parameters. The prototypes require Windows NT headers and associated types (like PSECURITY_DESCRIPTOR, HANDLE, ACCESS_MASK, etc.) to be defined or included beforehand. Intended for use in low-level system projects requiring direct invocation of NT kernel services, these declarations specify function interfaces for tasks such as security checks, process/job management, file operations, interprocess communication, and more. No business logic or implementation is included; only the interface contracts are specified.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2003sp12_x86_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAcceptConnectPort (PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheck (PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckByType (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeResultList (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarmByHandle (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAddAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAddBootEntry (PBOOT_ENTRY BootEntry, PULONG Id);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAddDriverEntry (PEFI_DRIVER_ENTRY DriverEntry, PULONG Id);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAdjustGroupsToken (HANDLE TokenHandle, BOOLEAN ResetToDefault, PTOKEN_GROUPS NewState, ULONG BufferLength, PTOKEN_GROUPS PreviousState, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAdjustPrivilegesToken (HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAlertResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAlertThread (HANDLE ThreadHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAllocateLocallyUniqueId (PLUID Luid);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAllocateUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAllocateUuids (PULARGE_INTEGER Time, PULONG Range, PULONG Sequence, PCHAR Seed);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAllocateVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtApphelpCacheControl (APPHELPCOMMAND type, PVOID buf);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAreMappedFilesTheSame (PVOID File1MappedAsAnImage, PVOID File2MappedAsFile);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAssignProcessToJobObject (HANDLE JobHandle, HANDLE ProcessHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCallbackReturn (PVOID OutputBuffer, ULONG OutputLength, NTSTATUS Status);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCancelIoFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCancelTimer (HANDLE TimerHandle, PBOOLEAN CurrentState);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtClearEvent (HANDLE EventHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtClose (HANDLE Handle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCloseObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCompactKeys (ULONG Count, HANDLE KeyArray[]);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCompareTokens (HANDLE FirstTokenHandle, HANDLE SecondTokenHandle, PBOOLEAN Equal);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCompleteConnectPort (HANDLE PortHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCompressKey (HANDLE Key);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtContinue (PCONTEXT ContextRecord, BOOLEAN TestAlert);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateDebugObject (PHANDLE DebugObjectHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Count);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateJobSet (ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateMailslotFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN InitialOwner);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateNamedPipeFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreatePagingFile (PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateProcessEx (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateProfile (PHANDLE ProfileHandle, HANDLE Process, PVOID RangeBase, SIZE_T RangeSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDebugActiveProcess (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\n```\n\n----------------------------------------\n\nTITLE: Preparing Ubuntu Linux Kernel Source for Syscall Prototype Extraction\nDESCRIPTION: Commands for cloning, checking out, configuring and compiling the Ubuntu Linux kernel source to prepare it for extracting system call prototypes. This prepares the necessary unistd header files even if compilation fails.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/MAINTENANCE.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git://kernel.ubuntu.com/ubuntu/ubuntu-bionic.git\ncd ubuntu-bionic\ngit checkout Ubuntu-4.15.0-97.98\ncat ./debian.master/config/{config.common.ubuntu,i386/config.common.i386,i386/config.flavour.generic} > .config\nmake\n```\n\n----------------------------------------\n\nTITLE: Pulling and Running Developer PANDA Docker Container (Shell)\nDESCRIPTION: These commands allow users to obtain and execute the 'pandadev' Docker container, optimized for PANDA development. This container includes not only PANDA and PyPANDA but also source code and build artifacts. Prerequisite: Docker installed. The output shows the '--help' usage for the i386 binary located within the build directory. This approach is intended for contributors needing additional development tooling or access to the codebase within the container.\nSOURCE: https://github.com/panda-re/panda/blob/dev/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ docker pull pandare/pandadev\\n$ docker run --rm pandare/pandadev /panda/build/panda-system-i386 --help\n```\n\n----------------------------------------\n\nTITLE: Nim Decryption Implementation\nDESCRIPTION: Nim program implementing XOR decryption of an encrypted buffer containing the test pattern. Includes decryption function and constant definitions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/examples/yara-rules/README.md#_snippet_2\n\nLANGUAGE: nim\nCODE:\n```\nproc decrypt(key: byte, ciphertext: seq[byte]): seq[byte] =\n    var plaintext = newSeq[byte](ciphertext.len)\n    for i, c in ciphertext:\n        plaintext[i] = key xor c\n    return plaintext\n\nconst KEY = 0xFF\nconst PAYLOAD = @[\n    byte 178, 165, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 191, 255,\n    255, 255, 175, 186, 255, 255, 188, 144, 145,\n    145, 154, 156, 139, 150, 145, 152, 223, 139,\n    144, 197, 223, 218, 140, 197, 218, 150, 245,\n    188, 144, 145, 145, 154, 156, 139, 154, 155,\n    222, 172, 154, 145, 155, 223, 156, 144, 145,\n    139, 141, 144, 147, 223, 156, 144, 146, 146,\n    158, 145, 155, 223, 188, 160, 172, 188, 160,\n    177, 190, 160, 206, 188, 144, 145, 145, 154,\n    156, 139, 223, 153, 158, 150, 147, 154, 155,\n    222, 172, 154, 145, 155, 223, 139, 150, 146,\n    154, 223, 140, 134, 145, 156, 223, 156, 144,\n    146, 146, 158, 145, 155, 168, 158, 150, 139,\n    223, 209, 209, 209, 154, 135, 150, 139, 223,\n    207, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255\n]\n\nlet plaintext = decrypt(KEY, PAYLOAD)\nwriteFile(\"output.dat\", plaintext)\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing LTTng Tracing Sessions for QEMU\nDESCRIPTION: Shows how to create, start, stop, and destroy LTTng tracing sessions for QEMU. It also demonstrates how to enable specific events and view traces.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/tracing.txt#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nlttng create mysession\nlttng enable-event qemu:g_malloc -u\nlttng start\nlttng stop\nlttng view\nlttng destroy\n```\n\n----------------------------------------\n\nTITLE: Network Socket System Call Declarations in C\nDESCRIPTION: Function declarations for Linux system calls related to network socket operations. These declarations define the interface for creating, connecting, and communicating through network sockets.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_21\n\nLANGUAGE: C\nCODE:\n```\nlong sys_socket(int, int, int);\nlong sys_connect(int, struct sockaddr __user *, int);\nlong sys_accept(int, struct sockaddr __user *, int __user *);\nlong sys_sendto(int, void __user *, size_t, unsigned, struct sockaddr __user *, int);\nlong sys_recvfrom(int, void __user *, size_t, unsigned, struct sockaddr __user *, int __user *);\nlong sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\nlong sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\nlong sys_shutdown(int, int);\nlong sys_bind(int, struct sockaddr __user *, int);\nlong sys_listen(int, int);\nlong sys_getsockname(int, struct sockaddr __user *, int __user *);\nlong sys_getpeername(int, struct sockaddr __user *, int __user *);\nlong sys_socketpair(int, int, int, int __user *);\nlong sys_setsockopt(int fd, int level, int optname, char __user *optval, int optlen);\nlong sys_getsockopt(int fd, int level, int optname, char __user *optval, int __user *optlen);\nlong sys_sendfile(int out_fd, int in_fd, off_t __user *offset, size_t count);\n```\n\n----------------------------------------\n\nTITLE: Defining QMP Command Schema - QAPI Python-Like (JSON) Schema\nDESCRIPTION: This code defines a QMP command called 'hello-world' that optionally takes a string parameter 'message'. The schema is used by the QAPI framework to generate code for serializing, deserializing, and routing the command. No return type is specified, making the 'Returns' clause optional as mentioned in the documentation. This definition must reside in QAPI schema files and is a prerequisite for implementing the command in C.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/writing-qmp-commands.txt#_snippet_6\n\nLANGUAGE: qapi\nCODE:\n```\n{ 'command': 'hello-world', 'data': { '*message': 'str' } }\n```\n\n----------------------------------------\n\nTITLE: Setting Specific CPU Program Counter with QEMU Loader\nDESCRIPTION: This example shows how to set CPU 0's program counter to the value 0x8000 using the QEMU loader device.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/generic-loader.txt#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n-device loader,addr=0x8000,cpu-num=0\n```\n\n----------------------------------------\n\nTITLE: Running PANDA with Stringsearch and Callstack Plugins - Shell\nDESCRIPTION: This snippet shows how to invoke the PANDA QEMU system emulator with specific plugins ('callstack_instr;stringsearch') to analyze a given replay while disabling graphical display. It orchestrates the entire dynamic analysis, requiring a valid replay file, the specified plugins' availability, and the compiled system emulator. Key parameters include the replay file and plugin list. Outputs are match records in the console and log files. Limitations: correct paths and plugin builds are assumed.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/Starcraft.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npanda/qemu/i386-softmmu/panda-system-i386 -replay starcraft4 -display none -panda 'callstack_instr;stringsearch'\n```\n\n----------------------------------------\n\nTITLE: Declaring POSIX and UNIX System Call Prototypes in C\nDESCRIPTION: This snippet lists C function declarations corresponding to numerous POSIX and UNIX system calls, providing the interface needed for system-level operations such as file handling, process control, memory management, resource management, and inter-process communication. No function implementations are present; only prototypes are exposed, which typically reside in a system header file and are linked to actual system call implementations in libc or the kernel. Each function specifies required parameters including pointers to structures as needed and returns appropriate types for error and result handling.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n0 int nosys(void);\n1 void sys_exit(int rval);\n2 int fork(void);\n3 ssize_t read(int fd, void *buf, size_t nbyte);\n4 ssize_t write(int fd, const void *buf, size_t nbyte);\n5 int open(const char *path, int flags, mode_t mode);\n6 int close(int fd);\n7 int wait4(int pid, int *status, int options, struct rusage *rusage);\n8 int creat(const char *path, int mode);\n9 int link(const char *path, const char *link);\n10 int unlink(const char *path);\n\n12 int chdir(const char *path);\n13 int fchdir(int fd);\n14 int mknod(const char *path, int mode, uint32_t dev);\n15 int chmod(const char *path, mode_t mode);\n16 int chown(const char *path, int uid, int gid);\n17 void *break(char *nsize);\n18 int getfsstat(struct ostatfs *buf, long bufsize, int mode);\n\n20 pid_t getpid(void);\n21 int mount(const char *type, const char *path, int flags, void *data);\n22 int unmount(const char *path, int flags);\n23 int setuid(uid_t uid);\n24 uid_t getuid(void);\n25 uid_t geteuid(void);\n26 int ptrace(int req, pid_t pid, caddr_t addr, int data);\n27 int recvmsg(int s, struct msghdr *msg, int flags);\n28 int sendmsg(int s, struct msghdr *msg, int flags);\n29 int recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, __socklen_t *fromlenaddr);\n30 int accept(int s, struct sockaddr *name, __socklen_t *anamelen);\n31 int getpeername(int fdes, struct sockaddr *asa, __socklen_t *alen);\n32 int getsockname(int fdes, struct sockaddr *asa, __socklen_t *alen);\n33 int access(const char *path, int amode);\n34 int chflags(const char *path, u_long flags);\n35 int fchflags(int fd, u_long flags);\n36 int sync(void);\n37 int kill(int pid, int signum);\n38 int stat(const char *path, struct ostat *ub);\n39 pid_t getppid(void);\n40 int lstat(const char *path, struct ostat *ub);\n41 int dup(unsigned fd);\n42 int pipe(void);\n43 gid_t getegid(void);\n44 int profil(char *samples, size_t size, size_t offset, unsigned scale);\n45 int ktrace(const char *fname, int ops, int facs, int pid);\n46 int sigaction(int signum, struct osigaction *nsa, struct osigaction *osa);\n47 gid_t getgid(void);\n\n49 int getlogin(char *namebuf, unsigned namelen);\n50 int setlogin(const char *namebuf);\n51 int acct(const char *path);\n\n53 int sigaltstack(stack_t *ss, stack_t *oss);\n54 int ioctl(int fd, u_long com, char *data);\n55 int reboot(int opt);\n56 int revoke(const char *path);\n57 int symlink(const char *path, const char *link);\n58 ssize_t readlink(const char *path, char *buf, size_t count);\n59 int execve(const char *fname, char **argv, char **envv);\n60 int umask(mode_t newmask);\n61 int chroot(const char *path);\n62 int fstat(int fd, struct ostat *sb);\n63 int getkerninfo(int op, char *where, size_t *size, int arg);\n64 int getpagesize(void);\n65 int msync(void *addr, size_t len, int flags);\n66 int vfork(void);\n\n69 int sbrk(int incr);\n70 int sstk(int incr);\n71 void *mmap(void *addr, int len, int prot, int flags, int fd, long pos);\n72 int vadvise(int anom);\n73 int munmap(void *addr, size_t len);\n74 int mprotect(void *addr, size_t len, int prot);\n75 int madvise(void *addr, size_t len, int behav);\n\n78 int mincore(const void *addr, size_t len, char *vec);\n79 int getgroups(unsigned gidsetsize, gid_t *gidset);\n80 int setgroups(unsigned gidsetsize, gid_t *gidset);\n81 int getpgrp(void);\n82 int setpgid(int pid, int pgid);\n83 int setitimer(unsigned which, struct itimerval *itv, struct itimerval *oitv);\n84 int wait(void);\n85 int swapon(const char *name);\n86 int getitimer(unsigned which, struct itimerval *itv);\n87 int gethostname(char *hostname, unsigned len);\n88 int sethostname(char *hostname, unsigned len);\n89 int getdtablesize(void);\n90 int dup2(unsigned from, unsigned to);\n\n92 int fcntl(int fd, int cmd, long arg);\n93 int select(int nd, fd_set *in, fd_set *ou, fd_set *ex, struct timeval *tv);\n\n95 int fsync(int fd);\n96 int setpriority(int which, int who, int prio);\n97 int socket(int domain, int type, int protocol);\n98 int connect(int s, const struct sockaddr *name, int namelen);\n99 int accept(int s, struct sockaddr *name, int *anamelen);\n100 int getpriority(int which, int who);\n101 int send(int s, const void *buf, int len, int flags);\n102 int recv(int s, void *buf, int len, int flags);\n103 int sigreturn(struct osigcontext *sigcntxp);\n104 int bind(int s, const struct sockaddr *name, int namelen);\n105 int setsockopt(int s, int level, int name, const void *val, int valsize);\n106 int listen(int s, int backlog);\n\n108 int sigvec(int signum, struct sigvec *nsv, struct sigvec *osv);\n109 int sigblock(int mask);\n110 int sigsetmask(int mask);\n111 int sigsuspend(osigset_t mask);\n112 int sigstack(struct sigstack *nss, struct sigstack *oss);\n113 int recvmsg(int s, struct omsghdr *msg, int flags);\n114 int sendmsg(int s, const void *msg, int flags);\n\n116 int gettimeofday(struct timeval *tp, struct timezone *tzp);\n117 int getrusage(int who, struct rusage *rusage);\n118 int getsockopt(int s, int level, int name, void *val,  int *avalsize);\n\n120 int readv(int fd, struct iovec *iovp, unsigned iovcnt);\n121 int writev(int fd, struct iovec *iovp, unsigned iovcnt);\n122 int settimeofday(struct timeval *tv, struct timezone *tzp);\n123 int fchown(int fd, int uid, int gid);\n124 int fchmod(int fd, mode_t mode);\n125 int recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, int *fromlenaddr);\n126 int setreuid(int ruid, int euid);\n127 int setregid(int rgid, int egid);\n128 int rename(const char *from, const char *to);\n\n131 int flock(int fd, int how);\n132 int mkfifo(const char *path, mode_t mode);\n133 int sendto(int s, const void *buf, size_t len, int flags, const struct sockaddr *to, int tolen);\n134 int shutdown(int s, int how);\n135 int socketpair(int domain, int type, int protocol, int *rsv);\n136 int mkdir(const char *path, mode_t mode);\n137 int rmdir(const char *path);\n138 int utimes(const char *path, struct timeval *tptr);\n\n140 int adjtime(struct timeval *delta, struct timeval *olddelta);\n141 int getpeername(int fdes, struct sockaddr *asa, int *alen);\n142 long gethostid(void);\n143 int sethostid(long hostid);\n144 int getrlimit(unsigned which, struct orlimit *rlp);\n145 int setrlimit(unsigned which, struct orlimit *rlp);\n146 int killpg(int pgid, int signum);\n147 int setsid(void);\n148 int quotactl(const char *path, int cmd, int uid, void *arg);\n149 int quota(void);\n150 int getsockname(int fdec, struct sockaddr *asa, int *alen);\n\n154 int nlm_syscall(int debug_level, int grace_period, int addr_count, char **addrs);\n155 int nfssvc(int flag, void *argp);\n156 int getdirentries(int fd, char *buf, unsigned count, long *basep);\n157 int statfs(const char *path, struct ostatfs *buf);\n158 int fstatfs(int fd, struct ostatfs *buf);\n\n160 int lgetfh(const char *fname, struct fhandle *fhp);\n161 int getfh(const char *fname, struct fhandle *fhp);\n162 int getdomainname(char *domainname, int len);\n163 int setdomainname(char *domainname, int len);\n164 int uname(struct utsname *name);\n165 int sysarch(int op, char *parms);\n166 int rtprio(int function, pid_t pid, struct rtprio *rtp);\n\n169 int semsys(int which, int a2, int a3, int a4, int a5);\n\n175 int setfib(int fibnum);\n176 int ntp_adjtime(struct timex *tp);\n\n181 int setgid(gid_t gid);\n182 int setegid(gid_t egid);\n183 int seteuid(uid_t euid);\n\n188 int stat(const char *path, struct freebsd11_stat *ub);\n189 int fstat(int fd, struct freebsd11_stat *sb);\n190 int lstat(const char *path, struct freebsd11_stat *ub);\n191 int pathconf(const char *path, int name);\n192 int fpathconf(int fd, int name);\n\n194 int getrlimit(unsigned which, struct rlimit *rlp);\n195 int setrlimit(unsigned which, struct rlimit *rlp);\n196 int getdirentries(int fd, char *buf, unsigned count, long *basep);\n197 void *mmap(void *addr, size_t len, int prot, int flags, int fd, int pad, off_t pos);\n198 int nosys(void);\n\n202 int __sysctl(int *name, unsigned namelen, void *old, size_t *oldlenp, const void *new, size_t newlen);\n203 int mlock(const void *addr, size_t len);\n204 int munlock(const void *addr, size_t len);\n205 int undelete(const char *path);\n206 int futimes(int fd, struct timeval *tptr);\n207 int getpgid(pid_t pid);\n209 int poll(struct pollfd *fds, unsigned nfds, int timeout);\n\n220 int __semctl(int semid, int semnum, int cmd, union semun_old *arg);\n221 int semget(key_t key, int nsems, int semflg);\n222 int semop(int semid, struct sembuf *sops, size_t nsops);\n\n224 int msgctl(int msqid, int cmd, struct msqid_ds_old *buf);\n225 int msgget(key_t key, int msgflg);\n226 int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);\n227 ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);\n228 void *shmat(int shmid, const void *shmaddr, int shmflg);\n229 int shmctl(int shmid, int cmd, struct shmid_ds_old *buf);\n230 int shmdt(const void *shmaddr);\n231 int shmget(key_t key, size_t size, int shmflg);\n232 int clock_gettime(clockid_t clock_id, struct timespec *tp);\n233 int clock_settime(clockid_t clock_id, const struct timespec *tp);\n234 int clock_getres(clockid_t clock_id, struct timespec *tp);\n235 int ktimer_create(clockid_t clock_id, struct sigevent *evp, int *timerid);\n236 int ktimer_delete(int timerid);\n237 int ktimer_settime(int timerid, int flags, const struct itimerspec *value, struct itimerspec *ovalue);\n238 int ktimer_gettime(int timerid, struct itimerspec *value);\n239 int ktimer_getoverrun(int timerid);\n240 int nanosleep(const struct timespec *rqtp, struct timespec *rmtp);\n241 int ffclock_getcounter(ffcounter *ffcount);\n242 int ffclock_setestimate(struct ffclock_estimate *cest);\n243 int ffclock_getestimate(struct ffclock_estimate *cest);\n244 int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *rqtp, struct timespec *rmtp);\n\n247 int clock_getcpuclockid2(id_t id, int which, clockid_t *clock_id);\n248 int ntp_gettime(struct ntptimeval *ntvp);\n\n250 int minherit(void *addr, size_t len, int inherit);\n251 int rfork(int flags);\n252 AUE_POLL OBSOL openbsd_poll\n253 int issetugid(void);\n254 int lchown(const char *path, int uid, int gid);\n255 int aio_read(struct aiocb *aiocbp);\n```\n\n----------------------------------------\n\nTITLE: Recording I/O Buffer to HD Transfer in DMA Callback\nDESCRIPTION: Code from ide_dma_cb that records DMA transfers from I/O buffer to hard drive during record mode for later replay.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/hd_taint.txt#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nrr_record_hd_transfer\n  (RR_CALLSITE_IDE_DMA_CB,\n   HD_TRANSFER_IOB_TO_HD,\n   (uint64_t) s->io_buffer,\n   HD_BASE_ADDR + sector_num*512, \n   n*512);\n```\n\n----------------------------------------\n\nTITLE: Defining System Resource Management System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to page file creation, port creation, namespace management, and process creation. These functions handle core OS resources for memory management and process isolation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_10\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreatePagingFile (PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority);\nNTSTATUS NtCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtCreatePrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\nNTSTATUS NtCreateProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort);\n```\n\n----------------------------------------\n\nTITLE: Configuring Secondary VM Network and COLO-proxy in QEMU\nDESCRIPTION: This snippet shows the configuration for the secondary VM's network devices and COLO-proxy objects in QEMU. It sets up the tap device, e1000 NIC, and redirector sockets for communication with the primary VM.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/colo-proxy.txt#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n-netdev tap,id=hn0,vhost=off,script=/etc/qemu-ifup,down script=/etc/qemu-ifdown\n-device e1000,netdev=hn0,mac=52:a4:00:12:78:66\n-chardev socket,id=red0,host=3.3.3.3,port=9003\n-chardev socket,id=red1,host=3.3.3.3,port=9004\n-object filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0\n-object filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1\n```\n\n----------------------------------------\n\nTITLE: Creating and Connecting QEMU Block Devices (QEMU CLI, Shell)\nDESCRIPTION: Shows how to allocate a standalone drive using -drive and attach it to a guest device with -device, referencing the created drive by ID. No dependencies except QEMU CLI. Key parameters are the drive ID, device name, and respective options for drive and device configuration. Input is two CLI lines; QEMU links the drive to the virtual device as specified.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n-drive if=none,id=DRIVE-ID,HOST-OPTS...\n-device DEVNAME,drive=DRIVE-ID,DEV-OPTS...\n```\n\n----------------------------------------\n\nTITLE: Creating Dummy QCOW2 Images for PANDA Android Emulator (Shell)\nDESCRIPTION: This snippet creates two dummy QCOW2 disk images required by PANDA's Android emulator. Using the qemu-img utility bundled with PANDA/QEMU, it creates two 1MB blank images to satisfy device requirements even though the content is irrelevant. The prerequisite is qemu-img in the working directory, and outputs are two files: dummy.qcow2 and dummy2.qcow2. These are vital to avoid errors during replay but do not contain meaningful data.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/LINE_Censorship.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ ./qemu-img create -f qcow2 dummy.qcow2 1M\\n$ ./qemu-img create -f qcow2 dummy2.qcow2 1M\n```\n\n----------------------------------------\n\nTITLE: Updating a Shared Pointer with RCU and Mutex in C\nDESCRIPTION: This snippet shows a typical RCU write-side operation: acquiring a mutex, swapping a shared pointer, and synchronizing RCU before reclaiming the old resource. Necessary dependencies include qemu_mutex_lock/unlock, atomic_rcu_set, synchronize_rcu, and free. The main parameters are the mutex and the shared pointer variable; outputs are the update to the shared pointer and deallocation of the previous object. Requires locking discipline to avoid races.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/rcu.txt#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nqemu_mutex_lock(&foo_mutex);\nold = foo;\natomic_rcu_set(&foo, new);\nqemu_mutex_unlock(&foo_mutex);\nsynchronize_rcu();\nfree(old);\n```\n\n----------------------------------------\n\nTITLE: Declaring System Call Prototypes in the Linux Kernel - C\nDESCRIPTION: This code snippet outlines a list of function prototypes for system calls in the Linux kernel written in C. Each prototype declares the function's expected parameters (including pointers to userspace memory, flags, integers, or structs) and return type. Designed for internal use within kernel source files, these declarations provide a contract for the sys_* implementations that handle actual system call logic; required headers and type definitions (such as struct definitions and __user annotations) must be present elsewhere. The prototypes expect inputs/outputs to match kernel expectations, and misuse (or incorrect pointer/data type use) can cause critical system failures.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64n32_prototypes.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n6153 long sys_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\n6154 long sys_adjtimex_time32(struct old_timex32 __user *txc_p);\n6155 long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim);\n6156 long sys_chroot(const char __user *filename);\n6157 long sys_sync(void);\n6158 long sys_acct(const char __user *name);\n6159 long sys_settimeofday(struct __kernel_old_timeval __user *tv, struct timezone __user *tz);\n6160 long sys_mount(char __user *dev_name, char __user *dir_name, char __user *type, unsigned long flags, void __user *data);\n6161 long sys_umount(char __user *name, int flags);\n6162 long sys_swapon(const char __user *specialfile, int swap_flags);\n6163 long sys_swapoff(const char __user *specialfile);\n6164 long sys_reboot(int magic1, int magic2, unsigned int cmd, void __user *arg);\n6165 long sys_sethostname(char __user *name, int len);\n6166 long sys_setdomainname(char __user *name, int len);\n6167 long sys_ni_syscall(void);\n6168 long sys_init_module(void __user *umod, unsigned long len, const char __user *uargs);\n6169 long sys_delete_module(const char __user *name_user, unsigned int flags);\n6170 long sys_ni_syscall(void);\n6171 long sys_ni_syscall(void);\n6172 long sys_quotactl(unsigned int cmd, const char __user *special, qid_t id, void __user *addr);\n6173 long sys_ni_syscall(void);\n6174 long sys_ni_syscall(void);\n6175 long sys_ni_syscall(void);\n6176 long sys_ni_syscall(void);\n6177 long sys_ni_syscall(void);\n6178 long sys_gettid(void);\n6179 long sys_readahead(int fd, loff_t offset, size_t count);\n6180 long sys_setxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\n6181 long sys_lsetxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\n6182 long sys_fsetxattr(int fd, const char __user *name, const void __user *value, size_t size, int flags);\n6183 long sys_getxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\n6184 long sys_lgetxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\n6185 long sys_fgetxattr(int fd, const char __user *name, void __user *value, size_t size);\n6186 long sys_listxattr(const char __user *path, char __user *list, size_t size);\n6187 long sys_llistxattr(const char __user *path, char __user *list, size_t size);\n6188 long sys_flistxattr(int fd, char __user *list, size_t size);\n6189 long sys_removexattr(const char __user *path, const char __user *name);\n6190 long sys_lremovexattr(const char __user *path, const char __user *name);\n6191 long sys_fremovexattr(int fd, const char __user *name);\n6192 long sys_tkill(pid_t pid, int sig);\n6193 long sys_ni_syscall(void);\n6194 long sys_futex_time32(u32 __user *uaddr, int op, u32 val, struct old_timespec32 __user *utime, u32 __user *uaddr2, u32 val3);\n6195 long sys_sched_setaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\n6196 long sys_sched_getaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\n6200 long sys_io_setup(unsigned nr_reqs, aio_context_t __user *ctx);\n6201 long sys_io_destroy(aio_context_t ctx);\n6202 long sys_io_getevents_time32(__u32 ctx_id, __s32 min_nr, __s32 nr, struct io_event __user *events, struct old_timespec32 __user *timeout);\n6203 long sys_io_submit(aio_context_t, long, struct iocb __user * __user *);\n6204 long sys_io_cancel(aio_context_t ctx_id, struct iocb __user *iocb, struct io_event __user *result);\n6205 long sys_exit_group(int error_code);\n6206 long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);\n6207 long sys_epoll_create(int size);\n6208 long sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user *event);\n6209 long sys_epoll_wait(int epfd, struct epoll_event __user *events, int maxevents, int timeout);\n6210 long sys_remap_file_pages(unsigned long start, unsigned long size, unsigned long prot, unsigned long pgoff, unsigned long flags);\n6211 void sys_sigreturn(void);\n6212 long sys_fcntl64(unsigned int fd, unsigned int cmd, unsigned long arg);\n6213 long sys_set_tid_address(int __user *tidptr);\n6214 long sys_restart_syscall(void);\n6215 long sys_semtimedop_time32(int semid, struct sembuf __user *sops, unsigned nsops, const struct old_timespec32 __user *timeout);\n6216 long sys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice);\n6217 long sys_statfs64(const char __user *path, size_t sz, struct statfs64 __user *buf);\n6218 long sys_fstatfs64(unsigned int fd, size_t sz, struct statfs64 __user *buf);\n6219 long sys_sendfile64(int out_fd, int in_fd, loff_t __user *offset, size_t count);\n6220 long sys_timerfd_create(int clockid, int flags);\n6221 long sys_timer_settime32(timer_t timer_id, int flags, struct old_itimerspec32 __user *new, struct old_itimerspec32 __user *old);\n6222 long sys_timer_gettime32(timer_t timer_id, struct old_itimerspec32 __user *setting);\n6223 long sys_timer_getoverrun(timer_t timer_id);\n6224 long sys_timer_delete(timer_t timer_id);\n6225 long sys_clock_settime32(clockid_t which_clock, struct old_timespec32 __user *tp);\n6226 long sys_clock_gettime32(clockid_t which_clock, struct old_timespec32 __user *tp);\n6227 long sys_clock_getres_time32(clockid_t which_clock, struct old_timespec32 __user *tp);\n6228 long sys_clock_nanosleep_time32(clockid_t which_clock, int flags, struct old_timespec32 __user *rqtp, struct old_timespec32 __user *rmtp);\n6229 long sys_tgkill(pid_t tgid, pid_t pid, int sig);\n6230 long sys_utimes_time32(const char __user *filename, struct old_timeval32 __user *t);\n6231 long sys_mbind(unsigned long start, unsigned long len, unsigned long mode, const unsigned long __user *nmask, unsigned long maxnode, unsigned flags);\n6232 long sys_get_mempolicy(int __user *policy, unsigned long __user *nmask, unsigned long maxnode, unsigned long addr, unsigned long flags);\n6233 long sys_set_mempolicy(int mode, const unsigned long __user *nmask, unsigned long maxnode);\n6234 long sys_mq_open(const char __user *name, int oflag, umode_t mode, struct mq_attr __user *attr);\n6235 long sys_mq_unlink(const char __user *name);\n6236 long sys_mq_timedsend_time32(mqd_t mqdes, const char __user *u_msg_ptr, unsigned int msg_len, unsigned int msg_prio, const struct old_timespec32 __user *u_abs_timeout);\n6237 long sys_mq_timedreceive_time32(mqd_t mqdes, char __user *u_msg_ptr, unsigned int msg_len, unsigned int __user *u_msg_prio, const struct old_timespec32 __user *u_abs_timeout);\n6238 long sys_mq_notify(mqd_t mqdes, const struct sigevent __user *notification);\n6239 long sys_mq_getsetattr(mqd_t mqdes, const struct mq_attr __user *mqstat, struct mq_attr __user *omqstat);\n6240 long sys_ni_syscall(void);\n6241 long sys_waitid(int which, pid_t pid, struct siginfo __user *infop, int options, struct rusage __user *ru);\n6243 long sys_add_key(const char __user *_type, const char __user *_description, const void __user *_payload, size_t plen, key_serial_t destringid);\n6244 long sys_request_key(const char __user *_type, const char __user *_description, const char __user *_callout_info, key_serial_t destringid);\n6245 long sys_keyctl(int cmd, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\n6247 long sys_inotify_init(void);\n6248 long sys_inotify_add_watch(int fd, const char __user *path, u32 mask);\n6249 long sys_inotify_rm_watch(int fd, __s32 wd);\n6250 long sys_migrate_pages(pid_t pid, unsigned long maxnode, const unsigned long __user *from, const unsigned long __user *to);\n6251 long sys_openat(int dfd, const char __user *filename, int flags, umode_t mode);\n6252 long sys_mkdirat(int dfd, const char __user *pathname, umode_t mode);\n6253 long sys_mknodat(int dfd, const char __user *filename, umode_t mode, unsigned dev);\n6254 long sys_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group, int flag);\n6255 long sys_futimesat_time32(unsigned int dfd, const char __user *filename, struct old_timeval32 __user *t);\n6256 long sys_newfstatat(int dfd, const char __user *filename, struct stat __user *statbuf, int flag);\n6257 long sys_unlinkat(int dfd, const char __user *pathname, int flag);\n6258 long sys_renameat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname);\n6259 long sys_linkat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, int flags);\n6260 long sys_symlinkat(const char __user *oldname, int newdfd, const char __user *newname);\n6261 long sys_readlinkat(int dfd, const char __user *path, char __user *buf, int bufsiz);\n6262 long sys_fchmodat(int dfd, const char __user *filename, umode_t mode);\n6263 long sys_faccessat(int dfd, const char __user *filename, int mode);\n6264 long sys_io_pgetevents_time32(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct old_timespec32 __user *timeout, const struct __aio_sigset *sig);\n6265 long sys_pselect6_time32(int, fd_set __user *, fd_set __user *, fd_set __user *, struct old_timespec32 __user *, void __user *);\n6266 long sys_unshare(unsigned long unshare_flags);\n6267 long sys_splice(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);\n6268 long sys_sync_file_range(int fd, loff_t offset, loff_t nbytes, unsigned int flags);\n6269 long sys_tee(int fdin, int fdout, size_t len, unsigned int flags);\n6270 long sys_vmsplice(int fd, const struct iovec __user *iov, unsigned long nr_segs, unsigned int flags);\n6271 long sys_move_pages(pid_t pid, unsigned long nr_pages, const void __user * __user *pages, const int __user *nodes, int __user *status, int flags);\n6272 long sys_get_robust_list(int pid, struct robust_list_head __user * __user *head_ptr, size_t __user *len_ptr);\n6273 long sys_set_robust_list(struct robust_list_head __user *head, size_t len);\n6274 long sys_kexec_load(unsigned long entry, unsigned long nr_segments, struct kexec_segment __user *segments, unsigned long flags);\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Event JSON Structure in QMP\nDESCRIPTION: Defines the JSON structure for asynchronous events in QMP. It includes the event name, optional event-specific data, and a timestamp.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qmp-spec.txt#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{ \"event\": json-string, \"data\": json-object, \"timestamp\": { \"seconds\": json-number, \"microseconds\": json-number } }\n```\n\n----------------------------------------\n\nTITLE: Declaring NT System Call Prototypes in C\nDESCRIPTION: This snippet declares multiple NT system call prototypes in C, each corresponding to a low-level Windows kernel service. These prototypes require the inclusion of relevant Windows data types (such as NTSTATUS, HANDLE, ACCESS_MASK, and various structures). Each function defines its input and output parameters, tailored to specific system contract requirements. The input typically consists of handles, pointers to data structures, control flags, or buffers, while output parameters may involve pointers to returned handles, statuses, or data. No implementation is provided; this is for interface definition only.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp0_x64_prototypes.txt#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtGetMUIRegistryInfo (ULONG Flags, PULONG DataSize, PVOID Data);\nNTSTATUS NtGetNextProcess (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewProcessHandle);\nNTSTATUS NtGetNextThread (HANDLE ProcessHandle, HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewThreadHandle);\nNTSTATUS NtGetNlsSectionPtr (ULONG SectionType, ULONG SectionData, PVOID ContextData, PVOID *SectionPointer, PULONG SectionSize);\nNTSTATUS NtGetNotificationResourceManager (HANDLE ResourceManagerHandle, PTRANSACTION_NOTIFICATION TransactionNotification, ULONG NotificationLength, PLARGE_INTEGER Timeout, PULONG ReturnLength, ULONG Asynchronous, ULONG_PTR AsynchronousContext);\nNTSTATUS NtGetWriteWatch (HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, SIZE_T RegionSize, PVOID *UserAddressArray, PULONG_PTR EntriesInUserAddressArray, PULONG Granularity);\nNTSTATUS NtImpersonateAnonymousToken (HANDLE ThreadHandle);\nNTSTATUS NtImpersonateThread (HANDLE ServerThreadHandle, HANDLE ClientThreadHandle, PSECURITY_QUALITY_OF_SERVICE SecurityQos);\nNTSTATUS NtInitializeNlsFiles (PVOID *BaseAddress, PLCID DefaultLocaleId, PLARGE_INTEGER DefaultCasingTableSize);\nNTSTATUS NtInitializeRegistry (USHORT BootCondition);\nNTSTATUS NtInitiatePowerAction (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);\nBOOLEAN NtIsSystemResumeAutomatic ();\nNTSTATUS NtIsUILanguageComitted ();\nNTSTATUS NtListenPort (HANDLE PortHandle, PPORT_MESSAGE ConnectionRequest);\nNTSTATUS NtLoadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtLoadKey (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile);\nNTSTATUS NtLoadKey2 (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags);\nNTSTATUS NtLoadKeyEx (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags, HANDLE TrustClassKey );\nNTSTATUS NtLockFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);\nNTSTATUS NtLockProductActivationKeys (ULONG *pPrivateVer, ULONG *pSafeMode);\nNTSTATUS NtLockRegistryKey (HANDLE KeyHandle);\nNTSTATUS NtLockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtMakePermanentObject (HANDLE Handle);\nNTSTATUS NtMakeTemporaryObject (HANDLE Handle);\nNTSTATUS NtMapCMFModule (ULONG What, ULONG Index, PULONG CacheIndexOut, PULONG CacheFlagsOut, PULONG ViewSizeOut, PVOID *BaseAddress);\nNTSTATUS NtMapUserPhysicalPages (PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtModifyBootEntry (PBOOT_ENTRY BootEntry);\nNTSTATUS NtModifyDriverEntry (PEFI_DRIVER_ENTRY DriverEntry);\nNTSTATUS NtNotifyChangeDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree);\nNTSTATUS NtNotifyChangeKey (HANDLE KeyHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtNotifyChangeMultipleKeys (HANDLE MasterKeyHandle, ULONG Count, OBJECT_ATTRIBUTES SlaveObjects[], HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtNotifyChangeSession (HANDLE Session, ULONG IoStateSequence, PVOID Reserved, ULONG Action, IO_SESSION_STATE IoState, IO_SESSION_STATE IoState2, PVOID Buffer, ULONG BufferSize);\nNTSTATUS NtOpenEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, LPGUID EnlistmentGuid, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKeyEx (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG OpenOptions);\nNTSTATUS NtOpenKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE TransactionHandle);\nNTSTATUS NtOpenKeyTransactedEx (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG OpenOptions, HANDLE TransactionHandle);\nNTSTATUS NtOpenKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, ACCESS_MASK GrantedAccess, PPRIVILEGE_SET Privileges, BOOLEAN ObjectCreation, BOOLEAN AccessGranted, PBOOLEAN GenerateOnClose);\nNTSTATUS NtOpenPrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\nNTSTATUS NtOpenProcessToken (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);\nNTSTATUS NtOpenResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID ResourceManagerGuid, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSession (PHANDLE SessionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle);\nNTSTATUS NtOpenTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, LPGUID TmIdentity, ULONG OpenOptions);\nNTSTATUS NtPlugPlayControl (PLUGPLAY_CONTROL_CLASS PnPControlClass, PVOID PnPControlData, ULONG PnPControlDataLength);\nNTSTATUS NtPrePrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrePrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrivilegeCheck (HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, PBOOLEAN Result);\nNTSTATUS NtPrivilegeObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\nNTSTATUS NtPrivilegedServiceAuditAlarm (PUNICODE_STRING SubsystemName, PUNICODE_STRING ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\nNTSTATUS NtPropagationComplete (HANDLE ResourceManagerHandle, ULONG RequestCookie, ULONG BufferLength, PVOID Buffer);\nNTSTATUS NtPropagationFailed (HANDLE ResourceManagerHandle, ULONG RequestCookie, NTSTATUS PropStatus);\nNTSTATUS NtPulseEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtQueryBootEntryOrder (PULONG Ids, PULONG Count);\nNTSTATUS NtQueryBootOptions (PBOOT_OPTIONS BootOptions, PULONG BootOptionsLength);\nNTSTATUS NtQueryDebugFilterState (ULONG ComponentId, ULONG Level);\nNTSTATUS NtQueryDirectoryObject (HANDLE DirectoryHandle, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, BOOLEAN RestartScan, PULONG Context, PULONG ReturnLength);\nNTSTATUS NtQueryDriverEntryOrder (PULONG Ids, PULONG Count);\nNTSTATUS NtQueryEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan);\nNTSTATUS NtQueryFullAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);\nNTSTATUS NtQueryInformationAtom (RTL_ATOM Atom, ATOM_INFORMATION_CLASS InformationClass, PVOID AtomInformation, ULONG AtomInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationPort (HANDLE PortHandle, PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtQueryInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength, PULONG ReturnLength);\n```\n\n----------------------------------------\n\nTITLE: Declaring NT Native API Functions - Windows/NT Kernel - C\nDESCRIPTION: Each code snippet declares the prototype for an NT Native API function in C, intended for direct interaction with Windows kernel services. These declarations typically reside in a header file and require linking against ntdll.dll or similar low-level system libraries. Parameters vary by function and may include handles, pointers to structures, or primitive types, and all functions are designed to return NTSTATUS values to indicate the result of the kernel operation. Developers must ensure appropriate privilege levels and valid parameter values for the system to handle requests correctly.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x64_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAlpcRevokeSecurityContext (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAlpcSendWaitReceivePort (HANDLE PortHandle, ULONG Flags, PPORT_MESSAGE SendMessage, PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes, PPORT_MESSAGE ReceiveMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAlpcSetInformation (HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAreMappedFilesTheSame (PVOID File1MappedAsAnImage, PVOID File2MappedAsFile);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAssignProcessToJobObject (HANDLE JobHandle, HANDLE ProcessHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCancelIoFileEx (HANDLE FileHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCancelSynchronousIoFile (HANDLE ThreadHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCommitComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCommitEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCommitTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCompactKeys (ULONG Count, HANDLE KeyArray[]);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCompareTokens (HANDLE FirstTokenHandle, HANDLE SecondTokenHandle, PBOOLEAN Equal);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCompleteConnectPort (HANDLE PortHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCompressKey (HANDLE Key);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateDebugObject (PHANDLE DebugObjectHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, HANDLE TransactionHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, NOTIFICATION_MASK NotificationMask, PVOID EnlistmentKey);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Count);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateJobSet (ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, HANDLE TransactionHandle, PULONG Disposition);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateMailslotFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN InitialOwner);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateNamedPipeFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreatePagingFile (PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreatePrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateProfile (PHANDLE ProfileHandle, HANDLE Process, PVOID RangeBase, SIZE_T RangeSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateProfileEx (PHANDLE ProfileHandle, HANDLE Process, PVOID ProfileBase, SIZE_T ProfileSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, ULONG GroupAffinityCount, PGROUP_AFFINITY GroupAffinity);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID RmGuid, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, PUNICODE_STRING Description);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateThreadEx (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument, ULONG CreateFlags, ULONG_PTR ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, PPS_ATTRIBUTE_LIST AttributeList);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle, ULONG CreateOptions, ULONG IsolationLevel, ULONG IsolationFlags, PLARGE_INTEGER Timeout, PUNICODE_STRING Description);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, ULONG CreateOptions, ULONG CommitStrength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateUserProcess (PHANDLE ProcessHandle, PHANDLE ThreadHandle, ACCESS_MASK ProcessDesiredAccess, ACCESS_MASK ThreadDesiredAccess, POBJECT_ATTRIBUTES ProcessObjectAttributes, POBJECT_ATTRIBUTES ThreadObjectAttributes, ULONG ProcessFlags, ULONG ThreadFlags, PRTL_USER_PROCESS_PARAMETERS ProcessParameters, PPROCESS_CREATE_INFO CreateInfo, PPROCESS_ATTRIBUTE_LIST AttributeList);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateWorkerFactory (PHANDLE WorkerFactoryHandleReturn, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE CompletionPortHandle, HANDLE WorkerProcessHandle, PVOID StartRoutine, PVOID StartParameter, ULONG MaxThreadCount, SIZE_T StackReserve, SIZE_T StackCommit);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDebugActiveProcess (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDebugContinue (HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDeleteAtom (RTL_ATOM Atom);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDeleteBootEntry (ULONG Id);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDeleteDriverEntry (ULONG Id);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDeleteKey (HANDLE KeyHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDeletePrivateNamespace (HANDLE NamespaceHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDisableLastKnownGood ();\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDisplayString (PUNICODE_STRING String);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDrawText (PUNICODE_STRING Text);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtEnableLastKnownGood ();\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtEnumerateBootEntries (PVOID Buffer, PULONG BufferLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtEnumerateDriverEntries (PVOID Buffer, PULONG BufferLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtEnumerateSystemEnvironmentValuesEx (ULONG InformationClass, PVOID Buffer, PULONG BufferLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtEnumerateTransactionObject (HANDLE RootObjectHandle, KTMOBJECT_TYPE QueryType, PKTMOBJECT_CURSOR ObjectCursor, ULONG ObjectCursorLength, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtFlushInstallUILanguage (LANGID InstallUILanguage, ULONG SetComittedFlag);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtFlushKey (HANDLE KeyHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nVOID NtFlushProcessWriteBuffers ();\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtFlushWriteBuffer ();\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtFreezeRegistry (ULONG TimeOutInSeconds);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtFreezeTransactions (PLARGE_INTEGER FreezeTimeout, PLARGE_INTEGER ThawTimeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\n```\n\nLANGUAGE: C\nCODE:\n```\nULONG NtGetCurrentProcessorNumber ();\n```\n\n----------------------------------------\n\nTITLE: Generating Tapindex in PANDA (Bash)\nDESCRIPTION: This command runs QEMU with PANDA, replaying a session named 'foo' and using the tapindex plugin to generate index files.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/tapindex/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/qemu-system-x86_64 -replay foo \\\n    -panda tapindex\n```\n\n----------------------------------------\n\nTITLE: Initializing and Conditionally Writing a Log Entry Using the PANDA C API - C\nDESCRIPTION: Shows how to use the legacy C API for pandalogging by detecting changes in process/ASID, initializing a Panda__LogEntry struct, populating its fields, and writing a log entry. Relies on the global 'pandalog' variable to check if logging is active. Requires inclusion of 'panda/plog.h' and correct linkage against the PANDA C logging library. The main dependencies are the generated protobuf struct and the C wrapper functions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_24\n\nLANGUAGE: C\nCODE:\n```\nextern \\\"C\\\" {\\n...\\n#include \\\"panda/plog.h\\\"\\n...\\n}\\n...\\nint asidstory_before_block_exec(CPUState *env, TranslationBlock *tb) {\\n...\\n       if (pandalog) {\\n        if (last_name == 0\\n            || (p->asid != last_asid)\\n            || (p->pid != last_pid)\\n            || (0 != strcmp(p->name, last_name))) {\\n            Panda__LogEntry ple = PANDA__LOG_ENTRY__INIT;\\n            ple.has_asid = 1;\\n            ple.asid = p->asid;\\n            ple.has_process_id = 1;\\n            ple.process_id = p->pid;\\n            ple.process_name = p->name;\\n            pandalog_write_entry(&ple);\\n            last_asid = p->asid;\\n            last_pid = p->pid;\\n            free(last_name);\\n            last_name = strdup(p->name);\\n        }\\n    }\\n...\n```\n\n----------------------------------------\n\nTITLE: Running PANDA with Snake_hook PyPlugins - Shell\nDESCRIPTION: Shows how to start the PANDA system with the snake_hook compiled plugin, specifying one or more Python plugin files with the 'files' argument. It demonstrates the basic required command-line pattern for using snake_hook and loading plugins, including examples of how additional arguments can be appended and passed to the plugins upon startup. Key parameters include 'files' (a colon-separated list of Python files to load), and optional plugin-specific arguments such as 'path' and 'should_print_hello'. These commands presume that the specific PANDA binary (such as 'panda-system-x86_64' or 'x86_64-softmmu/panda-system-x86_64') is in your PATH, and that the referenced Python files are accessible.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/snake_hook/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npanda-system-x86_64 -panda snake_hook:files=print_pcs.py:print_strings.py -nographic\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ x86_64-softmmu/panda-system-x86_64 -panda snake_hook:files=test.py -nographic\n\npath = None\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ x86_64-softmmu/panda-system-x86_64 -panda \"snake_hook:files=test.py|path=/usr/bin\" -nographic\n\npath = /usr/bin\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ x86_64-softmmu/panda-system-x86_64 -panda \"snake_hook:files=test.py|path=/usr/bin|should_print_hello\" -nographic\n\npath = /usr/bin\nHello!\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ x86_64-softmmu/panda-system-x86_64 -panda \"snake_hook:files=test.py|path=/usr/bin|should_print_hello=1\" -nographic\n\npath = /usr/bin\nHello!\n\n$ x86_64-softmmu/panda-system-x86_64 -panda \"snake_hook:files=test.py|path=/usr/bin|should_print_hello=false\" -nographic\n\npath = /usr/bin\n```\n\n----------------------------------------\n\nTITLE: Enabling Virtio Block Trace Events via QEMU Monitor\nDESCRIPTION: This monitor command demonstrates how to enable all QEMU trace events starting with 'virtio_blk_' using a wildcard pattern. This is entered in QEMU's monitor environment to batch-enable related trace events. No prerequisites beyond QEMU monitor access are required. Inputs: wildcard event name. Outputs: changes to tracing state of the matching events.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/tracing.txt#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ntrace-event virtio_blk_* on\n```\n\n----------------------------------------\n\nTITLE: RCU Reclamation Function in C\nDESCRIPTION: Implementation of a reclamation function that frees memory for an RCU-protected structure. This function is called asynchronously after all pre-existing RCU read-side critical sections have completed.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/rcu.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\ncall_rcu1(&foo.rcu, foo_reclaim);\n\nvoid foo_reclaim(struct rcu_head *rp)\n{\n    struct foo *fp = container_of(rp, struct foo, rcu);\n    g_free(fp);\n}\n```\n\n----------------------------------------\n\nTITLE: FD-to-Filename and FD-to-Position APIs (C function declarations)\nDESCRIPTION: These API declarations provide hooks for resolving file descriptors to filenames or file positions within a guest Linux VM using the osi_linux plugin. Both take as input the virtual CPU state pointer, an OsiProc pointer (guest's process), and a file descriptor integer. Dependencies include osi_linux and its required plugins, and must be called within the PANDA introspection context. Expected output is a filename string pointer or file offset as unsigned long long, or NULL/invalid on failure.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi_linux/README.md#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\n// returns fd for a filename or a NULL if failed\nchar *osi_linux_fd_to_filename(CPUState *env, OsiProc *p, int fd);\n\n// returns pos in a file\nunsigned long long  osi_linux_fd_to_pos(CPUState *env, OsiProc *p, int fd);\n\n```\n\n----------------------------------------\n\nTITLE: Declaring After Physical Memory Read Callback Signature in PANDA (C)\nDESCRIPTION: Defines the callback prototype for plugin logic applied after reads from physical memory, passing the CPU state, PC, address, size, and a pointer to the data read. The signature matches PANDA's expected interface, and only functions once memory callbacks are enabled. The return value is void.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_44\n\nLANGUAGE: C\nCODE:\n```\nvoid (*phys_mem_after_read)(CPUState *env, target_ulong pc, target_ulong addr, target_ulong size, void *buf);\n```\n\n----------------------------------------\n\nTITLE: SchemaInfo for a Command Definition - JSON\nDESCRIPTION: This SchemaInfo JSON object represents metadata for a QAPI 'command' named 'query-qmp-schema', providing the argument and return types used on the wire. It specifies that the input uses the 'q_empty' type (an object without members) and that the return is an array of SchemaInfo objects (type 'SchemaInfoList'). Clients should expect 'arguments' to conform to 'q_empty' and results from the server to match 'SchemaInfoList'.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n{ \\\"name\\\": \\\"query-qmp-schema\\\", \\\"meta-type\\\": \\\"command\\\",\\n  \\\"arg-type\\\": \\\"q_empty\\\", \\\"ret-type\\\": \\\"SchemaInfoList\\\" }\n```\n\n----------------------------------------\n\nTITLE: Single Process Log Format Example\nDESCRIPTION: Example output showing register value changes, memory reads, and memory writes in single-process tracing mode. Each line contains register states and memory operations. Format is compatible with TENET trace exploration tool.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/trace/README.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nrax=0x4,rbx=0x1e288060,rcx=0x1e288060,rdx=0x403b870,rbp=0x1,rsp=0xbae438,rsi=0x2e1c0030,rdi=0x403b840,r8=0x0,r9=0x230,r10=0x403b870,r11=0x0,r12=0xffffffff,r13=0x2c7cb684b38,r14=0x141281d08,r15=0x1,rip=0x1401f6530\nrip=0x1401f6535,mw=0xbae450:6080281E00000000\nrip=0x1401f653a,mw=0xbae458:0100000000000000\nrsp=0xbae430,rip=0x1401f653b,mw=0xbae430:40B8030400000000\nrsp=0xbae000,rip=0x1401f6542\nrdi=0x403b870,rip=0x1401f6545\nrip=0x1401f6549,mw=0x1e288062:00\n```\n\n----------------------------------------\n\nTITLE: Connecting to a Remote PANDA GDB Session - Bash\nDESCRIPTION: This example shows how to launch a GDB environment suitable for remote multi-architecture debugging. The dependencies are a working installation of gdb-multiarch and a running PANDA environment accepting GDB remote connections. No arguments are passed, but the session is prepared for remote target attachment. The executable needs to be run in a shell or terminal with access to networking.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/gdb/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ gdb-multiarch\n```\n\n----------------------------------------\n\nTITLE: Declaring Before Virtual Memory Write Callback Signature in PANDA (C)\nDESCRIPTION: Defines a callback signature for intercepting virtual memory writes before they occur, giving plugins access to the CPU state, PC, address, size, and a buffer pointer to the data to be written. Requires that memory callbacks are explicitly enabled in PANDA. The void return type indicates no result is expected.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_39\n\nLANGUAGE: C\nCODE:\n```\nvoid (*virt_mem_before_write)(CPUState *env, target_ulong pc, target_ulong addr, target_ulong size, void *buf);\n```\n\n----------------------------------------\n\nTITLE: Negotiating QMP Capabilities via JSON Payloads (JSON)\nDESCRIPTION: Illustrates how to negotiate QMP capabilities and query system status by sending and receiving JSON objects to/from a QMP instance. Dependencies: Active QMP session (e.g., via telnet or TCP socket). The snippet includes payloads for 'qmp_capabilities' and 'query-status', and shows example JSON replies indicating system state. Inputs: JSON-formatted commands; Outputs: JSON responses reflecting QMP protocol behavior. Useful for understanding handshaking and command flow in QMP.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qmp-intro.txt#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{ \"execute\": \"qmp_capabilities\" }\n{\n    \"return\": {\n    }\n}\n\n{ \"execute\": \"query-status\" }\n{\n    \"return\": {\n        \"status\": \"prelaunch\", \n        \"singlestep\": false, \n        \"running\": false\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Plugin Initialization and Shutdown Functions in PANDA using C\nDESCRIPTION: Defines the two entry point functions required for every PANDA plugin: init_plugin for initialization and registering callbacks, and uninit_plugin for cleanup. The init_plugin function typically establishes the plugin's main behavior and resource setup, while uninit_plugin handles deallocation. Both functions receive a void pointer (plugin handle) as a parameter, usually provided by dlopen. No direct dependencies are needed apart from adherence to the PANDA plugin interface.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_10\n\nLANGUAGE: C\nCODE:\n```\nbool init_plugin(void *self);\nvoid uninit_plugin(void *self);\n```\n\n----------------------------------------\n\nTITLE: Running PANDA Replay with Keyfind Plugin (Shell)\nDESCRIPTION: This pair of commands replays a prior PANDA recording using the keyfind plugin to extract TLS candidate keys. Users specify either the ciphersuite name or numeric ID as an argument. Inputs: a PANDA replay (tls_recording_name) and either the ciphersuite name or ID. Outputs: key_candidates.txt. Dependency: keyfind plugin must be installed and available to PANDA.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/keyfind/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/qemu-system-x86_64 \\\n    -replay tls_recording_name \\\n    -panda keyfind:ciphersuite_name=TLS_AES_256_GCM_SHA384\n```\n\nLANGUAGE: shell\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/qemu-system-x86_64 \\\n    -replay tls_recording_name \\\n    -panda keyfind:ciphersuite_id=4866\n```\n\n----------------------------------------\n\nTITLE: Translating Legacy Character Device Syntax to -chardev (QEMU CLI, Shell)\nDESCRIPTION: Maps various old-style serial, file, or socket character device specifications to -chardev equivalents. Each source legacy syntax is illustrated with its new form. Inputs are legacy string and expected -chardev line; output is appropriate device endpoint for QEMU's modern CLI.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n-chardev null\n-chardev vc,width=WIDTH,height=HEIGHT\n-chardev vc,cols=<COLS>,rows=<ROWS>\n-chardev console\n-chardev serial,path=COM<NUM>\n-chardev file,path=FNAME\n-chardev pipe,path=FNAME\n-chardev socket,host=HOST,port=PORT,OPTS...\n-chardev socket,host=HOST,port=PORT,OPTS...,telnet=on\n-chardev udp,host=HOST,port=PORT,localaddr=LOCALADDR,localport=LOCALPORT\n-chardev socket,path=FNAME\n-chardev parport,file=/dev/parportN\n-chardev tty,path=/dev/FNAME\n```\n\n----------------------------------------\n\nTITLE: PANDA Command with Tainted Branch Plugin Example\nDESCRIPTION: Example command line for running PANDA with the tainted_branch plugin to track branches influenced by data from a file. The example includes necessary plugins like osi, syscalls2, and file_taint.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/tainted_branch/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo -panda osi \\\n    -panda osi_linux:kconf_group=debian-3.2.63-i686 \\\n    -panda syscalls2:profile=linux_x86 \\\n    -panda file_taint:filename=foo.dat \\\n    -panda tainted_branch \\\n    -pandalog foo.plog\n```\n\n----------------------------------------\n\nTITLE: Generating autogen code with syscalls2 scripts - Shell\nDESCRIPTION: This shell command demonstrates how to run the recreate_all_os_arch.sh script in the syscalls2 directory to regenerate autogen code for system call introspection, based on prototype input files. The script internally invokes syscall_parser.py for each supported OS/architecture. Prerequisites: executable permissions on the script and Python for running the parser.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/syscalls2.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nrecreate_all_os_arch.sh\n```\n\n----------------------------------------\n\nTITLE: Building and Running Developer PANDA Docker Container from Source (Shell)\nDESCRIPTION: This shell snippet demonstrates how to locally build the 'pandadev' Docker container for PANDA and run it. Dependencies: Docker with BuildKit enabled. The build uses the 'developer' target, including source, build artifacts, and both PANDA and PyPANDA binaries. The run command invokes the PANDA system binary (i386) with '--help', outputting usage information. Use this for the most complete developer environment or to create customized containers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ DOCKER_BUILDKIT=1 docker build --target=developer -t pandadev .\\n$ docker run --rm pandadev panda-system-i386 --help\n```\n\n----------------------------------------\n\nTITLE: Defining fw_cfg File Directory Structures in C\nDESCRIPTION: This code snippet details the C data structures ('FWCfgFiles' and 'FWCfgFile') used by the QEMU fw_cfg File Directory interface to enumerate file configuration items available for guest firmware. Required dependencies include stdint.h for fixed-width integers. The 'count' field in FWCfgFiles is the big-endian number of directory entries, each entry describing an individual file with its size, selector index (big-endian), and ASCII name. These are accessed via the 'File Directory' data item in fw_cfg to allow dynamic discovery of configuration blobs.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/fw_cfg.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct FWCfgFiles {\\n\\tuint32_t count;\\t\\t/* number of entries, in big-endian format */\\n\\tstruct FWCfgFile f[];\\t/* array of file entries, see below */\\n};\\n\\nstruct FWCfgFile {\\t\\t/* an individual file entry, 64 bytes total */\\n\\tuint32_t size;\\t\\t/* size of referenced fw_cfg item, big-endian */\\n\\tuint16_t select;\\t\\t/* selector key of fw_cfg item, big-endian */\\n\\tuint16_t reserved;\\n\\tchar name[56];\\t\\t/* fw_cfg item name, NUL-terminated ascii */\\n};\n```\n\n----------------------------------------\n\nTITLE: Advanced File System Operation Prototypes in C\nDESCRIPTION: Function prototypes for Linux system calls related to advanced file system operations such as renames, links, directory operations, and extended file attributes. These functions provide more sophisticated file handling capabilities beyond basic I/O.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nlong sys_renameat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname);\nlong sys_linkat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, int flags);\nlong sys_symlinkat(const char __user *oldname, int newdfd, const char __user *newname);\nlong sys_readlinkat(int dfd, const char __user *path, char __user *buf, int bufsiz);\nlong sys_fchmodat(int dfd, const char __user *filename, umode_t mode);\nlong sys_faccessat(int dfd, const char __user *filename, int mode);\nlong sys_renameat2(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, unsigned int flags);\nlong sys_statx(int dfd, const char __user *path, unsigned flags, unsigned mask, struct statx __user *buffer);\nlong sys_openat2(int dfd, const char __user *filename, struct open_how *how, size_t size);\nlong sys_faccessat2(int dfd, const char __user *filename, int mode, int flags);\nlong sys_getdents64(unsigned int fd, struct linux_dirent64 __user *dirent, unsigned int count);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Virtio Balloon Memory Statistics in QEMU\nDESCRIPTION: This snippet demonstrates how to retrieve the current memory statistics using the QEMU Object Model (QOM) interface. It includes an example response with various memory-related statistics.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/virtio-balloon-stats.txt#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{ \"execute\": \"qom-get\",\n  \"arguments\": { \"path\": \"/machine/peripheral-anon/device[1]\",\n  \"property\": \"guest-stats\" } }\n{\n    \"return\": {\n        \"stats\": {\n            \"stat-swap-out\": 0,\n            \"stat-free-memory\": 844943360,\n            \"stat-minor-faults\": 219028,\n            \"stat-major-faults\": 235,\n            \"stat-total-memory\": 1044406272,\n            \"stat-swap-in\": 0\n        },\n        \"last-update\": 1358529861\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Message Queue and Thread Management in C\nDESCRIPTION: Function declarations for POSIX message queue operations and additional thread control. Includes functions to open, configure, send/receive from message queues, and set thread names.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_19\n\nLANGUAGE: c\nCODE:\n```\nint kmq_open(const char *path, int flags, mode_t mode, const struct mq_attr *attr);\nint kmq_setattr(int mqd, const struct mq_attr *attr, struct mq_attr *oattr);\nint kmq_timedreceive(int mqd, char *msg_ptr, size_t msg_len, unsigned *msg_prio, const struct timespec *abs_timeout);\nint kmq_timedsend(int mqd, const char *msg_ptr, size_t msg_len, unsigned msg_prio, const struct timespec *abs_timeout);\nint kmq_notify(int mqd, const struct sigevent *sigev);\nint kmq_unlink(const char *path);\nint abort2(const char *why, int nargs, void **args);\nint thr_set_name(long id, const char *name);\nint aio_fsync(int op, struct aiocb *aiocbp);\nint rtprio_thread(int function, lwpid_t lwpid, struct rtprio *rtp);\n```\n\n----------------------------------------\n\nTITLE: Network Transfer Replay Callback Signature\nDESCRIPTION: Callback function signature for replaying network card data transfers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_52\n\nLANGUAGE: C\nCODE:\n```\nint (*replay_net_transfer)(CPUState *env, uint32_t type, uint64_t src_addr, uint64_t dest_addr, uint32_t num_bytes);\n```\n\n----------------------------------------\n\nTITLE: Acquiring and Releasing AioContext in C for Thread Safety\nDESCRIPTION: This snippet shows the proper way to acquire and release an AioContext when accessing it from other threads. This ensures mutual exclusion and prevents parallel access or event loop iterations in the same AioContext.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/multiple-iothreads.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\naio_context_acquire()/aio_context_release()\n```\n\n----------------------------------------\n\nTITLE: Client QMP Negotiation Example\nDESCRIPTION: Demonstrates a client negotiating QMP capabilities by executing the qmp_capabilities command and receiving a success response.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qmp-spec.txt#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{ \"execute\": \"qmp_capabilities\" }\n```\n\nLANGUAGE: json\nCODE:\n```\n{ \"return\": {}}\n```\n\n----------------------------------------\n\nTITLE: Enabling Polling for Virtio Balloon Memory Statistics in QEMU\nDESCRIPTION: This snippet demonstrates how to enable polling for memory statistics with a 2-second interval using the QEMU Object Model (QOM) interface.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/virtio-balloon-stats.txt#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{ \"execute\": \"qom-set\",\n             \"arguments\": { \"path\": \"/machine/peripheral-anon/device[1]\",\n\t\t\t \"property\": \"guest-stats-polling-interval\", \"value\": 2 } }\n\n{ \"return\": {} }\n```\n\n----------------------------------------\n\nTITLE: Declaring Get Stack Mappings Callback Typedef in C\nDESCRIPTION: Defines a callback typedef for fetching only mappings that correspond to process stack segments, for introspection of process memory layout. Supported only in osi_linux, with API similar to other mapping retrieval functions (CPUState, OsiProc, GArray**). Returns stack segment OsiModule objects.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_14\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_get_stack_mappings_t)(CPUState *, OsiProc *, GArray**)\n```\n\n----------------------------------------\n\nTITLE: Declaring QEMU Trace Events in Trace-Events File\nDESCRIPTION: These lines are event declarations for the QEMU tracing system, typically included in a trace-events file. Each line specifies the event name, argument types, argument names, and a format string for pretty-printing. These declarations are processed by QEMU tooling to generate wrapper functions. Required by the QEMU build system with tracing enabled. There are no parameters or runtime outputs as it is for build-time code generation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/tracing.txt#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nqemu_vmalloc(size_t size, void *ptr) \"size %zu ptr %p\"\nqemu_vfree(void *ptr) \"ptr %p\"\n```\n\n----------------------------------------\n\nTITLE: Documenting QAPI Section and Subsection Titles - Markdown\nDESCRIPTION: Demonstrates how to structure documentation comments in QAPI schema files using custom markup for section and subsection titles. This notation helps organize schema documentation for generation of readable output for both users and developers. The code uses the '#' for comments and varying counts of '=' for section laddering; no dependencies except consistent comment formatting imposed by the QAPI parser and documentation generator.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# = Section title\n# == Subection title\n```\n\n----------------------------------------\n\nTITLE: Executing PANDA with pri_dwarf Plugin - Shell\nDESCRIPTION: This shell command launches PANDA's QEMU replay system with multiple plugins, including osi, osi_linux, pri, and pri_dwarf. Arguments specify target process tracking, guest and host debug paths, and required kernel configuration. It demonstrates integration of PANDA modules for monitoring process execution and DWARF info gathering. Inputs include a replay file, plugin arguments, and kernel info path; outputs are PANDA analysis results. Ensure all referenced files and plugin dependencies exist before running.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/pri_dwarf/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n    ~/git/panda/qemu/i386-softmmu/panda-system-i386 -replay \\\n        /nas/ulrich/dwarf_tshark_capture2/wireshark-1.2.1-saurabh.cap.iso \\\n        -panda osi \\\n        -panda osi_linux:kconf_file=/nas/ulrich/kernelinfo.conf,kconf_group=debian-3.2.51-i686 \\\n        -panda pri \\\n        -panda pri_dwarf:proc=tshark,g_debugpath=/nas/ulrich/wireshark-1.2.1/lava-install/,h_debugpath=/nas/ulrich/wireshark-1.2.1/lava-install/\n```\n\n----------------------------------------\n\nTITLE: Monitor Command Callback Signature\nDESCRIPTION: Callback function signature for handling monitor commands via the plugin_cmd interface.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_47\n\nLANGUAGE: C\nCODE:\n```\nint (*monitor)(Monitor *mon, const char *cmd);\n```\n\n----------------------------------------\n\nTITLE: Adding Additional Dependencies such as libc - Rust - toml\nDESCRIPTION: Demonstrates how to add third-party crates (here, libc) to the dependencies block in Cargo.toml for improved functionality, such as FFI or system-level interfaces. The dependency declaration must be formatted as name = \"version\". All specified libraries will be fetched from crates.io during the next build or check.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/rust_skeleton/README.md#_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\nlibc = \"0.2\"\n```\n\n----------------------------------------\n\nTITLE: Linux System Call Function Declarations in C\nDESCRIPTION: A comprehensive list of Linux system calls (0-159) with their function signatures. Each line contains the system call number followed by its function prototype showing parameters and return type. These declarations represent the interface between user applications and the Linux kernel.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_x64_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n0 long sys_read(unsigned int fd, char __user *buf, size_t count);\n1 long sys_write(unsigned int fd, const char __user *buf, size_t count);\n2 long sys_open(const char __user *filename, int flags, umode_t mode);\n3 long sys_close(unsigned int fd);\n4 long sys_newstat(const char __user *filename, struct stat __user *statbuf);\n5 long sys_newfstat(unsigned int fd, struct stat __user *statbuf);\n6 long sys_newlstat(const char __user *filename, struct stat __user *statbuf);\n7 long sys_poll(struct pollfd __user *ufds, unsigned int nfds, int timeout);\n8 long sys_lseek(unsigned int fd, off_t offset, unsigned int whence);\n9 long sys_mmap(unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long);\n10 long sys_mprotect(unsigned long start, size_t len, unsigned long prot);\n11 long sys_munmap(unsigned long addr, size_t len);\n12 long sys_brk(unsigned long brk);\n13 long sys_rt_sigaction(int, const struct sigaction __user *, struct sigaction __user *, size_t);\n14 long sys_rt_sigprocmask(int how, sigset_t __user *set, sigset_t __user *oset, size_t sigsetsize);\n15 long sys_rt_sigreturn(void);\n16 long sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);\n17 long sys_pread64(unsigned int fd, char __user *buf, size_t count, loff_t pos);\n18 long sys_pwrite64(unsigned int fd, const char __user *buf, size_t count, loff_t pos);\n19 long sys_readv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\n20 long sys_writev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\n21 long sys_access(const char __user *filename, int mode);\n22 long sys_pipe(int __user *fildes);\n23 long sys_select(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct timeval __user *tvp);\n24 long sys_sched_yield(void);\n25 long sys_mremap(unsigned long addr, unsigned long old_len, unsigned long new_len, unsigned long flags, unsigned long new_addr);\n26 long sys_msync(unsigned long start, size_t len, int flags);\n27 long sys_mincore(unsigned long start, size_t len, unsigned char __user *vec);\n28 long sys_madvise(unsigned long start, size_t len, int behavior);\n29 long sys_shmget(key_t key, size_t size, int flag);\n30 long sys_shmat(int shmid, char __user *shmaddr, int shmflg);\n31 long sys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);\n32 long sys_dup(unsigned int fildes);\n33 long sys_dup2(unsigned int oldfd, unsigned int newfd);\n34 long sys_pause(void);\n35 long sys_nanosleep(struct timespec __user *rqtp, struct timespec __user *rmtp);\n36 long sys_getitimer(int which, struct itimerval __user *value);\n37 long sys_alarm(unsigned int seconds);\n38 long sys_setitimer(int which, struct itimerval __user *value, struct itimerval __user *ovalue);\n39 long sys_getpid(void);\n40 long sys_sendfile64(int out_fd, int in_fd, loff_t __user *offset, size_t count);\n41 long sys_socket(int, int, int);\n42 long sys_connect(int, struct sockaddr __user *, int);\n43 long sys_accept(int, struct sockaddr __user *, int __user *);\n44 long sys_sendto(int, void __user *, size_t, unsigned, struct sockaddr __user *, int);\n45 long sys_recvfrom(int, void __user *, size_t, unsigned, struct sockaddr __user *, int __user *);\n46 long sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\n47 long sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\n48 long sys_shutdown(int, int);\n49 long sys_bind(int, struct sockaddr __user *, int);\n50 long sys_listen(int, int);\n51 long sys_getsockname(int, struct sockaddr __user *, int __user *);\n52 long sys_getpeername(int, struct sockaddr __user *, int __user *);\n53 long sys_socketpair(int, int, int, int __user *);\n54 long sys_setsockopt(int fd, int level, int optname, char __user *optval, int optlen);\n55 long sys_getsockopt(int fd, int level, int optname, char __user *optval, int __user *optlen);\n56 long sys_clone(unsigned long, unsigned long, int __user *, int __user *, unsigned long);\n57 long sys_fork(void);\n58 long sys_vfork(void);\n59 long sys_execve(const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp);\n60 long sys_exit(int error_code);\n61 long sys_wait4(pid_t pid, int __user *stat_addr, int options, struct rusage __user *ru);\n62 long sys_kill(pid_t pid, int sig);\n63 long sys_newuname(struct new_utsname __user *name);\n64 long sys_semget(key_t key, int nsems, int semflg);\n65 long sys_semop(int semid, struct sembuf __user *sops, unsigned nsops);\n66 long sys_semctl(int semid, int semnum, int cmd, unsigned long arg);\n67 long sys_shmdt(char __user *shmaddr);\n68 long sys_msgget(key_t key, int msgflg);\n69 long sys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz, int msgflg);\n70 long sys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz, long msgtyp, int msgflg);\n71 long sys_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);\n72 long sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg);\n73 long sys_flock(unsigned int fd, unsigned int cmd);\n74 long sys_fsync(unsigned int fd);\n75 long sys_fdatasync(unsigned int fd);\n76 long sys_truncate(const char __user *path, long length);\n77 long sys_ftruncate(unsigned int fd, unsigned long length);\n78 long sys_getdents(unsigned int fd, struct linux_dirent __user *dirent, unsigned int count);\n79 long sys_getcwd(char __user *buf, unsigned long size);\n80 long sys_chdir(const char __user *filename);\n81 long sys_fchdir(unsigned int fd);\n82 long sys_rename(const char __user *oldname, const char __user *newname);\n83 long sys_mkdir(const char __user *pathname, umode_t mode);\n84 long sys_rmdir(const char __user *pathname);\n85 long sys_creat(const char __user *pathname, umode_t mode);\n86 long sys_link(const char __user *oldname, const char __user *newname);\n87 long sys_unlink(const char __user *pathname);\n88 long sys_symlink(const char __user *old, const char __user *new);\n89 long sys_readlink(const char __user *path, char __user *buf, int bufsiz);\n90 long sys_chmod(const char __user *filename, umode_t mode);\n91 long sys_fchmod(unsigned int fd, umode_t mode);\n92 long sys_chown(const char __user *filename, uid_t user, gid_t group);\n93 long sys_fchown(unsigned int fd, uid_t user, gid_t group);\n94 long sys_lchown(const char __user *filename, uid_t user, gid_t group);\n95 long sys_umask(int mask);\n96 long sys_gettimeofday(struct timeval __user *tv, struct timezone __user *tz);\n97 long sys_getrlimit(unsigned int resource, struct rlimit __user *rlim);\n98 long sys_getrusage(int who, struct rusage __user *ru);\n99 long sys_sysinfo(struct sysinfo __user *info);\n100 long sys_times(struct tms __user *tbuf);\n101 long sys_ptrace(long request, long pid, unsigned long addr, unsigned long data);\n102 long sys_getuid(void);\n103 long sys_syslog(int type, char __user *buf, int len);\n104 long sys_getgid(void);\n105 long sys_setuid(uid_t uid);\n106 long sys_setgid(gid_t gid);\n107 long sys_geteuid(void);\n108 long sys_getegid(void);\n109 long sys_setpgid(pid_t pid, pid_t pgid);\n110 long sys_getppid(void);\n111 long sys_getpgrp(void);\n112 long sys_setsid(void);\n113 long sys_setreuid(uid_t ruid, uid_t euid);\n114 long sys_setregid(gid_t rgid, gid_t egid);\n115 long sys_getgroups(int gidsetsize, gid_t __user *grouplist);\n116 long sys_setgroups(int gidsetsize, gid_t __user *grouplist);\n117 long sys_setresuid(uid_t ruid, uid_t euid, uid_t suid);\n118 long sys_getresuid(uid_t __user *ruid, uid_t __user *euid, uid_t __user *suid);\n119 long sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid);\n120 long sys_getresgid(gid_t __user *rgid, gid_t __user *egid, gid_t __user *sgid);\n121 long sys_getpgid(pid_t pid);\n122 long sys_setfsuid(uid_t uid);\n123 long sys_setfsgid(gid_t gid);\n124 long sys_getsid(pid_t pid);\n125 long sys_capget(cap_user_header_t header, cap_user_data_t dataptr);\n126 long sys_capset(cap_user_header_t header, const cap_user_data_t data);\n127 long sys_rt_sigpending(sigset_t __user *set, size_t sigsetsize);\n128 long sys_rt_sigtimedwait(const sigset_t __user *uthese, siginfo_t __user *uinfo, const struct timespec __user *uts, size_t sigsetsize);\n129 long sys_rt_sigqueueinfo(pid_t pid, int sig, siginfo_t __user *uinfo);\n130 long sys_rt_sigsuspend(sigset_t __user *unewset, size_t sigsetsize);\n131 long sys_sigaltstack(const struct sigaltstack __user *uss, struct sigaltstack __user *uoss);\n132 long sys_utime(char __user *filename, struct utimbuf __user *times);\n133 long sys_mknod(const char __user *filename, umode_t mode, unsigned dev);\n135 long sys_personality(unsigned int personality);\n136 long sys_ustat(unsigned dev, struct ustat __user *ubuf);\n137 long sys_statfs(const char __user *path, struct statfs __user *buf);\n138 long sys_fstatfs(unsigned int fd, struct statfs __user *buf);\n139 long sys_sysfs(int option, unsigned long arg1, unsigned long arg2);\n140 long sys_getpriority(int which, int who);\n141 long sys_setpriority(int which, int who, int niceval);\n142 long sys_sched_setparam(pid_t pid, struct sched_param __user *param);\n143 long sys_sched_getparam(pid_t pid, struct sched_param __user *param);\n144 long sys_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param);\n145 long sys_sched_getscheduler(pid_t pid);\n146 long sys_sched_get_priority_max(int policy);\n147 long sys_sched_get_priority_min(int policy);\n148 long sys_sched_rr_get_interval(pid_t pid, struct timespec __user *interval);\n149 long sys_mlock(unsigned long start, size_t len);\n150 long sys_munlock(unsigned long start, size_t len);\n151 long sys_mlockall(int flags);\n152 long sys_munlockall(void);\n153 long sys_vhangup(void);\n154 long sys_modify_ldt(int, void __user *, unsigned long);\n155 long sys_pivot_root(const char __user *new_root, const char __user *put_old);\n156 long sys_sysctl(struct __sysctl_args __user *args);\n157 long sys_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\n158 long sys_arch_prctl(int, unsigned long);\n159 long sys_adjtimex(struct timex __user *txc_p);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API System Calls in C\nDESCRIPTION: This set of C function prototypes declares direct system calls available in Windows NT through the NT Native API. Each function utilizes the NTSTATUS return type and accepts a range of pointers, handles, and specialized types as parameters, often requiring structures (e.g., OBJECT_ATTRIBUTES, IO_STATUS_BLOCK) and typedefs specific to Windows platform development. These declarations are typically placed in a header file to enable static or dynamic linking to ntoskrnl or ntdll system routines from privileged code. The input parameters correspond to system resources (files, events, processes, threads) and OS-level constructs, and the functions output status codes indicating success, failure, or specific error conditions. No implementations are provided here; only function prototypes.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x86_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWorkerFactoryWorkerReady (HANDLE WorkerFactoryHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAcceptConnectPort (PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtYieldExecution ();\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWriteVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWriteRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWriteFileGather (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWriteFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWaitLowEventPair (HANDLE EventPairHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWaitHighEventPair (HANDLE EventPairHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWaitForWorkViaWorkerFactory (HANDLE WorkerFactoryHandle, PFILE_IO_COMPLETION_INFORMATION MiniPacket);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWaitForSingleObject (HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWaitForMultipleObjects32 (ULONG Count, LONG Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWaitForMultipleObjects (ULONG Count, HANDLE Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWaitForKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWaitForDebugEvent (HANDLE DebugObjectHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PDBGUI_WAIT_STATE_CHANGE WaitStateChange);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtVdmControl (VDMSERVICECLASS Service, PVOID ServiceData);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtUnmapViewOfSection (HANDLE ProcessHandle, PVOID BaseAddress);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtUnlockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtUnlockFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtUnloadKeyEx (POBJECT_ATTRIBUTES TargetKey, HANDLE Event);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtUnloadKey2 (POBJECT_ATTRIBUTES TargetKey, ULONG Flags);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtUnloadKey (POBJECT_ATTRIBUTES TargetKey);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtUnloadDriver (PUNICODE_STRING DriverServiceName);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtUmsThreadYield (PVOID SchedulerParam);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtTranslateFilePath (PFILE_PATH InputFilePath, ULONG OutputType, PFILE_PATH OutputFilePath, PULONG OutputFilePathLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtTraceEvent (HANDLE TraceHandle, ULONG Flags, ULONG FieldSize, PVOID Fields);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtTraceControl (ULONG FunctionCode, PVOID InBuffer, ULONG InBufferLen, PVOID OutBuffer, ULONG OutBufferLen, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtThawTransactions ();\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtThawRegistry ();\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtTestAlert ();\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtTerminateThread (HANDLE ThreadHandle, NTSTATUS ExitStatus);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtTerminateProcess (HANDLE ProcessHandle, NTSTATUS ExitStatus);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtTerminateJobObject (HANDLE JobHandle, NTSTATUS ExitStatus);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSystemDebugControl (SYSDBG_COMMAND Command, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSuspendThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSuspendProcess (HANDLE ProcessHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtStopProfile (HANDLE ProfileHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtStartProfile (HANDLE ProfileHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSinglePhaseReject (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSignalAndWaitForSingleObject (HANDLE SignalHandle, HANDLE WaitHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtShutdownWorkerFactory (HANDLE WorkerFactoryHandle, LONG *PendingWorkerCount);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtShutdownSystem (SHUTDOWN_ACTION Action);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetUuidSeed (PCHAR Seed);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetTimerResolution (ULONG DesiredTime, BOOLEAN SetResolution, PULONG ActualTime);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetTimerEx (HANDLE TimerHandle, TIMER_SET_INFORMATION_CLASS TimerSetInformationClass, PVOID TimerSetInformation, ULONG TimerSetInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetTimer (HANDLE TimerHandle, PLARGE_INTEGER DueTime, PTIMER_APC_ROUTINE TimerApcRoutine, PVOID TimerContext, BOOLEAN WakeTimer, LONG Period, PBOOLEAN PreviousState);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetThreadExecutionState (EXECUTION_STATE esFlags, PEXECUTION_STATE PreviousFlags);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetSystemTime (PLARGE_INTEGER SystemTime, PLARGE_INTEGER PreviousTime);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetSystemPowerState (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetSystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetSystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, ULONG ValueLength, ULONG Attributes);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetSystemEnvironmentValue (PUNICODE_STRING VariableName, PUNICODE_STRING VariableValue);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetSecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetLowWaitHighEventPair (HANDLE EventPairHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetLowEventPair (HANDLE EventPairHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetLdtEntries (ULONG Selector0, ULONG Entry0Low, ULONG Entry0Hi, ULONG Selector1, ULONG Entry1Low, ULONG Entry1Hi);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetIoCompletionEx (HANDLE IoCompletionHandle, HANDLE IoCompletionReserveHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetIoCompletion (HANDLE IoCompletionHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetIntervalProfile (ULONG Interval, KPROFILE_SOURCE Source);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetInformationTransactionManager (HANDLE TmHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetInformationObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetInformationKey (HANDLE KeyHandle, KEY_SET_INFORMATION_CLASS KeySetInformationClass, PVOID KeySetInformation, ULONG KeySetInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetInformationDebugObject (HANDLE DebugObjectHandle, DEBUGOBJECTINFOCLASS DebugObjectInformationClass, PVOID DebugInformation, ULONG DebugInformationLength, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetHighWaitLowEventPair (HANDLE EventPairHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetHighEventPair (HANDLE EventPairHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetEventBoostPriority (HANDLE EventHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetEvent (HANDLE EventHandle, PLONG PreviousState);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetDriverEntryOrder (PULONG Ids, ULONG Count);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetDefaultUILanguage (LANGID DefaultUILanguageId);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetDefaultLocale (BOOLEAN UserProfile, LCID DefaultLocaleId);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetDefaultHardErrorPort (HANDLE DefaultHardErrorPort);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetDebugFilterState (ULONG ComponentId, ULONG Level, BOOLEAN State);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetBootOptions (PBOOT_OPTIONS BootOptions, ULONG FieldsToChange);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetBootEntryOrder (PULONG Ids, ULONG Count);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSerializeBoot ();\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSecureConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PSID RequiredServerSid, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\n```\n\n----------------------------------------\n\nTITLE: Expected PANDA osi_test Plugin Output (Text/Console Dump) - sh\nDESCRIPTION: This block presents a sample of the console output produced when running the osi_test plugin. It displays the detected process list, loaded dynamic libraries, and kernel modules as identified using the OS introspection APIs. No specific dependencies are required beyond running the PANDA guest with the appropriate plugins. The output is intended for human inspection or further parsing, and sections may be truncated by '[...]' when large. This output can be used for debugging or regression testing, particularly when normalized with the optional Python script.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi_test/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nCurrent process: csrss.exe PID:348 PPID:328\n\nProcess list (27 procs):\n  smss.exe        \t200\t4\n  csrss.exe       \t288\t280\n  wininit.exe     \t336\t280\n  csrss.exe       \t348\t328\n  winlogon.exe    \t376\t328\n  services.exe    \t436\t336\n  lsass.exe       \t448\t336\n  lsm.exe         \t456\t336\n  svchost.exe     \t544\t436\n[...]\n  conhost.exe     \t760\t348\n  System          \t4\t0\n\n-------------------------------------------------\n\nDynamic libraries list (18 libs):\n\t0x49cb0000\t20480\tcsrss.exe                C:\\Windows\\system32\\csrss.exe\n\t0x76f50000\t1318912\tntdll.dll                C:\\Windows\\SYSTEM32\\ntdll.dll\n\t0x74e50000\t53248\tCSRSRV.dll               C:\\Windows\\system32\\CSRSRV.dll\n\t0x74e40000\t57344\tbasesrv.DLL              C:\\Windows\\system32\\basesrv.DLL\n[...]\n\t0x770a0000\t659456\tADVAPI32.dll             C:\\Windows\\system32\\ADVAPI32.dll\n\t0x75fb0000\t102400\tsechost.dll              C:\\Windows\\SYSTEM32\\sechost.dll\n\nKernel module list (136 modules):\n\t0x82818000\t4251648\tntoskrnl.exe             \\SystemRoot\\system32\\ntoskrnl.exe\n\t0x82c26000\t225280\thal.dll                 \\SystemRoot\\system32\\halmacpi.dll\n\t0x80b9b000\t32768\tkdcom.dll                \\SystemRoot\\system32\\kdcom.dll\n\t0x8b405000\t544768\tmcupdate.dll             \\SystemRoot\\system32\\mcupdate_GenuineIntel.dll\n\t0x8b48a000\t69632\tPSHED.dll                \\SystemRoot\\system32\\PSHED.dll\n\t0x8b49b000\t32768\tBOOTVID.dll              \\SystemRoot\\system32\\BOOTVID.dll\n\t[...]\n\t0x98e2a000\t57344\ttssecsrv.sys             \\SystemRoot\\System32\\DRIVERS\\tssecsrv.sys\n\t0x98e38000\t204800\tRDPWD.SYS                \\SystemRoot\\System32\\Drivers\\RDPWD.SYS\n\t0x00000000\t0\t                         \n```\n\n----------------------------------------\n\nTITLE: Executing PANDA with memsavep Plugin (Percentage-based)\nDESCRIPTION: This command runs PANDA with the memsavep plugin, configured to dump memory at 66.2% of the replay progress to a file named 'mymem.dd'.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/memsavep/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo \\\n    -panda memsavep:percent=66.2,file=mymem.dd\n```\n\n----------------------------------------\n\nTITLE: Collecting Unigram Byte Statistics with PANDA - Bash\nDESCRIPTION: This bash command demonstrates running a PANDA replay with both the callstack_instr and unigrams plugins enabled. It requires the PANDA system binary for the x86_64-softmmu target and a recorded replay named 'foo'. The command collects unigram byte statistics per tap point by grouping memory accesses, and outputs the results as binary histogram files. The output can later be parsed using a Python script provided in 'scripts/unigram_hist.py'. There are no special arguments required for the unigrams plugin; dependencies include the callstack_instr plugin.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/unigrams/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo \\\n    -panda callstack_instr -panda unigrams\n```\n\n----------------------------------------\n\nTITLE: Sample qemu-img Cache Parameters for 1GB Disk Coverage - Shell\nDESCRIPTION: This snippet shows sample calculations (as shell-style pseudo-code) for the L2 and refcount cache sizes required to provide caching coverage for a specified disk size (n GB), using the default qcow2 parameters of cluster_size = 64KB and refcount_bits = 16. These are reference formulas, not direct command lines, and assist with pre-deployment planning for effective caching. Results must be substituted into QEMU-related commands to set cache sizes with appropriate options.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qcow2-cache.txt#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nl2_cache_size = disk_size_GB * 131072\nrefcount_cache_size = disk_size_GB * 32768\n```\n\n----------------------------------------\n\nTITLE: Trimming Replay with Scissors Plugin - Bash\nDESCRIPTION: Trims the PANDA replay log based on instruction counts using the 'scissors' plugin, effectively extracting a relevant execution window spanning the initial HTML load to crash. Arguments specify start/end instruction counts and a name for the reduced file. PANDA replay infrastructure, logs, and previous analysis must be set up before running.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/UAF.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npanda/qemu/x86_64-softmmu/panda-system-x86_64 -m 1024 -replay cve-2011-1255-crash \\\n    -display none -panda 'scissors:start=398546927,end=1122107469,name=crash_reduced`\n```\n\n----------------------------------------\n\nTITLE: Mandatory Access Control (MAC) Operations in C\nDESCRIPTION: Function declarations for Mandatory Access Control (MAC) operations on processes and files. These functions are used to get and set MAC labels on processes, file descriptors, and files.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nint __mac_get_proc(struct mac *mac_p);\nint __mac_set_proc(struct mac *mac_p);\nint __mac_get_fd(int fd, struct mac *mac_p);\nint __mac_get_file(const char *path_p, struct mac *mac_p);\nint __mac_set_fd(int fd, struct mac *mac_p);\nint __mac_set_file(const char *path_p, struct mac *mac_p);\nint kenv(int what, const char *name, char *value, int len);\nint lchflags(const char *path, u_long flags);\nint uuidgen(struct uuid *store, int count);\nint sendfile(int fd, int s, off_t offset, size_t nbytes, struct sf_hdtr *hdtr, off_t *sbytes, int flags);\nint mac_syscall(const char *policy, int call, void *arg);\nint getfsstat(struct freebsd11_statfs *buf, long bufsize, int mode);\nint statfs(const char *path, struct freebsd11_statfs *buf);\nint fstatfs(int fd, struct freebsd11_statfs *buf);\nint fhstatfs(const struct fhandle *u_fhp, struct freebsd11_statfs *buf);\n```\n\n----------------------------------------\n\nTITLE: Extended Attribute Operations on File Descriptors in C\nDESCRIPTION: Function declarations for managing extended attributes via file descriptors. These functions allow getting, setting, and deleting extended attributes using file descriptors rather than paths.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nssize_t extattr_set_fd(int fd, int attrnamespace, const char *attrname, void *data, size_t nbytes);\nssize_t extattr_get_fd(int fd, int attrnamespace, const char *attrname, void *data, size_t nbytes);\nint extattr_delete_fd(int fd, int attrnamespace, const char *attrname);\nint __setugid(int flag);\n```\n\n----------------------------------------\n\nTITLE: Defining I/O and File System System Calls in C\nDESCRIPTION: Function declarations for Linux system calls related to asynchronous I/O operations, file descriptor manipulation, and file system operations. These calls provide interfaces for efficient I/O handling and file system management.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_28\n\nLANGUAGE: C\nCODE:\n```\nlong sys_io_setup(unsigned nr_reqs, aio_context_t __user *ctx);\nlong sys_io_destroy(aio_context_t ctx);\nlong sys_io_getevents_time32(__u32 ctx_id, __s32 min_nr, __s32 nr, struct io_event __user *events, struct old_timespec32 __user *timeout);\nlong sys_io_submit(aio_context_t, long, struct iocb __user * __user *);\nlong sys_io_cancel(aio_context_t ctx_id, struct iocb __user *iocb, struct io_event __user *result);\nlong sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);\nlong sys_fcntl64(unsigned int fd, unsigned int cmd, unsigned long arg);\nlong sys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice);\nlong sys_statfs64(const char __user *path, size_t sz, struct statfs64 __user *buf);\nlong sys_fstatfs64(unsigned int fd, size_t sz, struct statfs64 __user *buf);\nlong sys_sendfile64(int out_fd, int in_fd, loff_t __user *offset, size_t count);\nlong sys_io_pgetevents_time32(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct old_timespec32 __user *timeout, const struct __aio_sigset *sig);\n```\n\n----------------------------------------\n\nTITLE: Linux System Call Function Prototypes in C\nDESCRIPTION: A comprehensive collection of Linux system call function declarations with their numeric identifiers. Each function is prefixed with 'sys_' and includes detailed parameter information. This serves as a reference for implementing or interacting with the Linux kernel's system call interface.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nlong sys_exit(int error_code);\npid_t sys_fork(void);\nlong sys_read(unsigned int fd, char __user *buf, size_t count);\nlong sys_write(unsigned int fd, const char __user *buf, size_t count);\nlong sys_open(const char __user *filename, int flags, umode_t mode);\nlong sys_close(unsigned int fd);\nlong sys_waitpid(pid_t pid, int __user *stat_addr, int options);\nlong sys_creat(const char __user *pathname, umode_t mode);\nlong sys_link(const char __user *oldname, const char __user *newname);\nlong sys_unlink(const char __user *pathname);\nlong sys_execve(const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp);\nlong sys_chdir(const char __user *filename);\nlong sys_time32(old_time32_t __user *tloc);\nlong sys_mknod(const char __user *filename, umode_t mode, unsigned dev);\nlong sys_chmod(const char __user *filename, umode_t mode);\nlong sys_lchown(const char __user *filename, uid_t user, gid_t group);\n// 4017 sys_break - UNIMPLEMENTED\nlong sys_stat(const char __user *filename, struct __old_kernel_stat __user *statbuf);\nlong sys_lseek(unsigned int fd, off_t offset, unsigned int whence);\nlong sys_getpid(void);\nlong sys_mount(char __user *dev_name, char __user *dir_name, char __user *type, unsigned long flags, void __user *data);\nlong sys_oldumount(char __user *name);\nlong sys_setuid(uid_t uid);\nlong sys_getuid(void);\nlong sys_stime32(old_time32_t __user *tptr);\nlong sys_ptrace(long request, long pid, unsigned long addr, unsigned long data);\nlong sys_alarm(unsigned int seconds);\nlong sys_fstat(unsigned int fd, struct __old_kernel_stat __user *statbuf);\nlong sys_pause(void);\nlong sys_utime32(const char __user *filename, struct old_utimbuf32 __user *t);\n// 4031 sys_stty - UNIMPLEMENTED\n// 4032 sys_gtty - UNIMPLEMENTED\nlong sys_access(const char __user *filename, int mode);\nlong sys_nice(int increment);\n// 4035 sys_ftime - UNIMPLEMENTED\nlong sys_sync(void);\nlong sys_kill(pid_t pid, int sig);\nlong sys_rename(const char __user *oldname, const char __user *newname);\nlong sys_mkdir(const char __user *pathname, umode_t mode);\nlong sys_rmdir(const char __user *pathname);\nlong sys_dup(unsigned int fildes);\nlong sys_pipe(int __user *fildes);\nlong sys_times(struct tms __user *tbuf);\nlong sys_brk(unsigned long brk);\nlong sys_setgid(gid_t gid);\nlong sys_getgid(void);\nlong sys_signal(int sig, __sighandler_t handler);\nlong sys_geteuid(void);\nlong sys_getegid(void);\nlong sys_acct(const char __user *name);\nlong sys_umount(char __user *name, int flags);\nlong sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);\nlong sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg);\n// 4056 sys_mpx - UNIMPLEMENTED\nlong sys_setpgid(pid_t pid, pid_t pgid);\n// 4058 sys_ulimit - UNIMPLEMENTED\nlong sys_olduname(struct oldold_utsname __user *);\nlong sys_umask(int mask);\nlong sys_chroot(const char __user *filename);\nlong sys_ustat(unsigned dev, struct ustat __user *ubuf);\nlong sys_dup2(unsigned int oldfd, unsigned int newfd);\nlong sys_getppid(void);\nlong sys_getpgrp(void);\nlong sys_setsid(void);\nlong sys_sigaction(int, const struct old_sigaction __user *, struct old_sigaction __user *);\nlong sys_sgetmask(void);\nlong sys_ssetmask(int newmask);\nlong sys_setreuid(uid_t ruid, uid_t euid);\nlong sys_setregid(gid_t rgid, gid_t egid);\nlong sys_sigsuspend(int unused1, int unused2, old_sigset_t mask);\nlong sys_sigpending(old_sigset_t __user *uset);\nlong sys_sethostname(char __user *name, int len);\nlong sys_setrlimit(unsigned int resource, struct rlimit __user *rlim);\nlong sys_getrlimit(unsigned int resource, struct rlimit __user *rlim);\nlong sys_getrusage(int who, struct rusage __user *ru);\nlong sys_gettimeofday(struct __kernel_old_timeval __user *tv, struct timezone __user *tz);\nlong sys_settimeofday(struct __kernel_old_timeval __user *tv, struct timezone __user *tz);\nlong sys_getgroups(int gidsetsize, gid_t __user *grouplist);\nlong sys_setgroups(int gidsetsize, gid_t __user *grouplist);\n// 4082 - RESERVED\nlong sys_symlink(const char __user *old, const char __user *new);\nlong sys_lstat(const char __user *filename, struct __old_kernel_stat __user *statbuf);\nlong sys_readlink(const char __user *path, char __user *buf, int bufsiz);\nlong sys_uselib(const char __user *library);\nlong sys_swapon(const char __user *specialfile, int swap_flags);\nlong sys_reboot(int magic1, int magic2, unsigned int cmd, void __user *arg);\nlong sys_old_readdir(unsigned int, struct old_linux_dirent __user *, unsigned int);\nlong sys_mmap(unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags, unsigned long fd, unsigned long pgoff);\nlong sys_munmap(unsigned long addr, size_t len);\nlong sys_truncate(const char __user *path, long length);\nlong sys_ftruncate(unsigned int fd, unsigned long length);\nlong sys_fchmod(unsigned int fd, umode_t mode);\nlong sys_fchown(unsigned int fd, uid_t user, gid_t group);\nlong sys_getpriority(int which, int who);\nlong sys_setpriority(int which, int who, int niceval);\n// 4098 sys_profil - UNIMPLEMENTED\nlong sys_statfs(const char __user *path, struct statfs __user *buf);\nlong sys_fstatfs(unsigned int fd, struct statfs __user *buf);\nlong sys_ioperm(unsigned long from, unsigned long num, int on);\nlong sys_socketcall(int call, unsigned long __user *args);\nlong sys_syslog(int type, char __user *buf, int len);\nlong sys_setitimer(int which, struct __kernel_old_itimerval __user *value, struct __kernel_old_itimerval __user *ovalue);\nlong sys_getitimer(int which, struct __kernel_old_itimerval __user *value);\nlong sys_newstat(const char __user *filename, struct stat __user *statbuf);\nlong sys_newlstat(const char __user *filename, struct stat __user *statbuf);\nlong sys_newfstat(unsigned int fd, struct stat __user *statbuf);\nlong sys_uname(struct old_utsname __user *);\nlong sys_iopl(int level);\nlong sys_vhangup(void);\nlong sys_idle(void);\n// 4113 sys_vm86 - X86 ONLY AND DEPRECIATED\nlong sys_wait4(pid_t pid, int __user *stat_addr, int options, struct rusage __user *ru);\nlong sys_swapoff(const char __user *specialfile);\nlong sys_sysinfo(struct sysinfo __user *info);\nlong sys_ipc(unsigned int call, int first, unsigned long second, unsigned long third, void __user *ptr, long fifth);\nlong sys_fsync(unsigned int fd);\nvoid sys_sigreturn(void);\nlong sys_clone(unsigned long, unsigned long, int __user *, unsigned long, int __user *);\nlong sys_setdomainname(char __user *name, int len);\nlong sys_newuname(struct new_utsname __user *name);\nlong modify_ldt(int func, void *ptr, unsigned long bytecount);\nlong sys_adjtimex_time32(struct old_timex32 __user *txc_p);\nlong sys_mprotect(unsigned long start, size_t len, unsigned long prot);\nlong sys_sigprocmask(int how, old_sigset_t __user *set, old_sigset_t __user *oset);\ncaddr_t create_module(const char *name, size_t size);\nlong sys_init_module(void __user *umod, unsigned long len, const char __user *uargs);\nlong sys_delete_module(const char __user *name_user, unsigned int flags);\nlong get_kernel_syms(struct kernel_sym *table);\nlong sys_quotactl(unsigned int cmd, const char __user *special, qid_t id, void __user *addr);\nlong sys_getpgid(pid_t pid);\nlong sys_fchdir(unsigned int fd);\nlong sys_bdflush(int func, long data);\nlong sys_sysfs(int option, unsigned long arg1, unsigned long arg2);\nlong sys_personality(unsigned int personality);\n// 4137 sys_afs_syscall - UNIMPLEMENTED\nlong sys_setfsuid(uid_t uid);\nlong sys_setfsgid(gid_t gid);\nlong sys_llseek(unsigned int fd, unsigned long offset_high, unsigned long offset_low, loff_t __user *result, unsigned int whence);\nlong sys_getdents(unsigned int fd, struct linux_dirent __user *dirent, unsigned int count);\nlong sys_select(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct __kernel_old_timeval __user *tvp);\nlong sys_flock(unsigned int fd, unsigned int cmd);\nlong sys_msync(unsigned long start, size_t len, int flags);\nlong sys_readv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\nlong sys_writev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\nlong sys_cacheflush(char *addr, int nbytes, int cache);\n// 4148 sys_cachectl - ???\n// 4149 sys_sysmips - ???\nlong sys_setup(void);\nlong sys_getsid(pid_t pid);\nlong sys_fdatasync(unsigned int fd);\nlong sys_sysctl(struct __sysctl_args __user *args);\nlong sys_mlock(unsigned long start, size_t len);\nlong sys_munlock(unsigned long start, size_t len);\nlong sys_mlockall(int flags);\nlong sys_munlockall(void);\nlong sys_sched_setparam(pid_t pid, struct sched_param __user *param);\nlong sys_sched_getparam(pid_t pid, struct sched_param __user *param);\nlong sys_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param);\nlong sys_sched_getscheduler(pid_t pid);\nlong sys_sched_yield(void);\nlong sys_sched_get_priority_max(int policy);\nlong sys_sched_get_priority_min(int policy);\nlong sys_sched_rr_get_interval_time32(pid_t pid, struct old_timespec32 __user *interval);\nlong sys_nanosleep_time32(struct old_timespec32 __user *rqtp, struct old_timespec32 __user *rmtp);\nlong sys_mremap(unsigned long addr, unsigned long old_len, unsigned long new_len, unsigned long flags, unsigned long new_addr);\nlong sys_accept(int, struct sockaddr __user *, int __user *);\n```\n\n----------------------------------------\n\nTITLE: Creating a new PCI Express Root Bus in QEMU\nDESCRIPTION: Command for exposing a new PCI Express Root Bus using the pxb-pcie device. This allows for creating separate PCIe hierarchies with configurable bus numbers and optional NUMA node assignment.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/pcie.txt#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n-device pxb-pcie,id=pcie.1,bus_nr=x[,numa_node=y][,addr=z]\n```\n\n----------------------------------------\n\nTITLE: Expanded Asynchronous I/O Operations in C\nDESCRIPTION: Function declarations for additional asynchronous I/O operations including result checking, suspending, cancellation, error handling, and reading. Also includes process yielding function.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nssize_t aio_return(struct aiocb *aiocbp);\nint aio_suspend(struct aiocb * const * aiocbp, int nent, const struct timespec *timeout);\nint aio_cancel(int fd, struct aiocb *aiocbp);\nint aio_error(struct aiocb *aiocbp);\nint aio_read( struct oaiocb *aiocbp);\nint aio_write(struct oaiocb *aiocbp);\nint lio_listio(int mode, struct oaiocb * const *acb_list, int nent, struct osigevent *sig);\nint yield(void);\n```\n\n----------------------------------------\n\nTITLE: CPU State Restore Callback Signature\nDESCRIPTION: Callback function signature for handling CPU state restoration after faults/exceptions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_48\n\nLANGUAGE: C\nCODE:\n```\nint (*cpu_restore_state)(CPUState *env, TranslationBlock *tb);\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Monitor Instances: HMP and QMP via Command-line (Bash)\nDESCRIPTION: This command launches QEMU with dual monitor interfaces: one for Human Monitor Protocol (HMP) on stdio, and another QMP monitor over a TCP socket. Dependencies: QEMU installed. Key parameters include chardev backends for stdio and socket, port 4444 on localhost, and monitor modes (readline for HMP, control/pretty for QMP). Inputs: n/a; Outputs: QEMU instance with both monitor interfaces available. Shows extensibility for advanced QEMU monitoring.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qmp-intro.txt#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ qemu [...] -chardev stdio,id=mon0 -mon chardev=mon0,mode=readline \\\n             -chardev socket,id=mon1,host=localhost,port=4444,server,nowait \\\n             -mon chardev=mon1,mode=control,pretty=on\n```\n\n----------------------------------------\n\nTITLE: Running STUW to Process Pandalog\nDESCRIPTION: Command to run the STUW tool, processing the previously generated pandalog file to create the interprocess communication adjacency matrix.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/stuw.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./stuw mypandalogfile\n```\n\n----------------------------------------\n\nTITLE: Setting driver_override for vfio-pci on Linux sysfs - Shell\nDESCRIPTION: This command writes 'vfio-pci' to the driver_override file in sysfs for the specified PCI device (here 0000:00:02.0), ensuring that only the vfio-pci driver is bound to that device. This prevents unintended rebinding by the default i915 driver on the host. Requires root permissions and a Linux environment supporting driver_override.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/igd-assign.txt#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# echo \"vfio-pci\" > /sys/bus/pci/devices/0000:00:02.0/driver_override\n```\n\n----------------------------------------\n\nTITLE: Retrieving Taint Label Liveness Count in C\nDESCRIPTION: Function to get the count of how many times a particular taint label has appeared in tainted branches. This API is provided by the tainted_branch plugin.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/tainted_branch/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nuint64_t get_liveness(uint32_t l);\n```\n\n----------------------------------------\n\nTITLE: Registering Basic Block Execution Callback in PANDA using C\nDESCRIPTION: Shows how to register a callback for post-basic-block execution events in PANDA plugins. Here, a callback function (after_block_callback) is assigned to pcb.after_block_exec, then registered for the PANDA_CB_AFTER_BLOCK_EXEC event type using panda_register_callback. The 'self' parameter is the plugin handle, and PANDA_CB_AFTER_BLOCK_EXEC specifies the callback event. No special dependencies beyond the PANDA API.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_11\n\nLANGUAGE: C\nCODE:\n```\npcb.after_block_exec = after_block_callback;\npanda_register_callback(self, PANDA_CB_AFTER_BLOCK_EXEC, pcb);\n```\n\n----------------------------------------\n\nTITLE: Connecting a PCIe device to a PCIe Root Port in QEMU\nDESCRIPTION: Command example for attaching a PCIe device to a PCIe Root Port. This requires first creating the Root Port with unique chassis and slot identification, then connecting the device to that port.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/pcie.txt#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n-device ioh3420,id=root_port1,chassis=x,slot=y[,bus=pcie.0][,addr=z]  \\\n-device <dev>,bus=root_port1\n```\n\n----------------------------------------\n\nTITLE: Configuring VGA Properties in QEMU\nDESCRIPTION: Shows how to add PCI bus configuration and BIOS properties to VGA devices in QEMU. Includes special notes about the isapc machine type.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nstd         -device isa-vga\ncirrus      not yet available with -device\nnone        -nodefaults\n                disables more than just VGA, see \"Default Devices\"\n```\n\n----------------------------------------\n\nTITLE: Declaring a String Search Match Callback Typedef for PANDA (C)\nDESCRIPTION: This typedef defines the on_ssm_t callback signature used by the stringsearch plugin in PANDA. The callback is triggered on each memory match and provides context: the CPU state, program counter, address, matched string pointer, string length, flags for write/read, and location (in_memory). Required dependencies: inclusion of PANDA and architecture-specific headers (for CPUState and target_ulong). Expected usage is by other plugins wishing to respond to a match event.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/stringsearch/README.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (* on_ssm_t)(CPUState *env, target_ulong pc, target_ulong addr,\\n                uint8_t *matched_string, uint32_t matched_string_length,\\n                bool is_write, bool in_memory)\n```\n\n----------------------------------------\n\nTITLE: Defining a QMP Command in QAPI Schema (QEMU, JSON)\nDESCRIPTION: This JSON snippet demonstrates the minimal QAPI schema definition for a QMP command called 'hello-world'. No arguments or return data are specified. The command schema is placed at the bottom of qapi-schema.json and enables code generation for the command handler. QEMU build tools will use this to marshal/unmarshal protocol data at runtime.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/writing-qmp-commands.txt#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{ 'command': 'hello-world' }\n```\n\n----------------------------------------\n\nTITLE: Defining Profiling System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to process profiling. These functions provide performance monitoring capabilities for processes running on the system.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_11\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateProfile (PHANDLE ProfileHandle, HANDLE Process, PVOID RangeBase, SIZE_T RangeSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);\nNTSTATUS NtCreateProfileEx (PHANDLE ProfileHandle, HANDLE Process, PVOID ProfileBase, SIZE_T ProfileSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, ULONG GroupAffinityCount, PGROUP_AFFINITY GroupAffinity);\n```\n\n----------------------------------------\n\nTITLE: Connecting a PCIe device through a PCIe Switch in QEMU\nDESCRIPTION: Command sequence for connecting a PCIe device through a switch hierarchy. This involves creating a Root Port, attaching an upstream port to it, connecting a downstream port to the upstream port, and finally connecting the device to the downstream port.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/pcie.txt#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n-device ioh3420,id=root_port1,chassis=x,slot=y[,bus=pcie.0][,addr=z]  \\\n-device x3130-upstream,id=upstream_port1,bus=root_port1[,addr=x]          \\\n-device xio3130-downstream,id=downstream_port1,bus=upstream_port1,chassis=x1,slot=y1[,addr=z1]] \\\n-device <dev>,bus=downstream_port1\n```\n\n----------------------------------------\n\nTITLE: Configuring QEMU Devices with Bootindex\nDESCRIPTION: This command demonstrates how to set up a QEMU machine with two NICs and two disks, each assigned a different bootindex value to determine boot priority.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/bootindex.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nqemu -drive file=disk1.img,if=none,id=disk1\n     -device ide-drive,drive=disk1,bootindex=4\n     -drive file=disk2.img,if=none,id=disk2\n     -device virtio-blk-pci,drive=disk2,bootindex=3\n     -netdev type=user,id=net0 -device virtio-net-pci,netdev=net0,bootindex=2\n     -netdev type=user,id=net1 -device e1000,netdev=net1,bootindex=1\n```\n\n----------------------------------------\n\nTITLE: Declaring Linux System Call Prototypes - C\nDESCRIPTION: This snippet consists of a contiguous list of C function declarations corresponding to standard Linux system calls, using consistent naming conventions (sys_*) and 'long' as the return type. Each prototype includes specific parameters and types (including pointers to user structures, size fields, and device identifiers), mapping exactly to syscall interface definitions. No dependencies are explicitly required, but inclusion assumes prior definition of all types used (pid_t, sigset_t, struct timespec, etc.), typically provided via standard kernel headers. Inputs are syscall arguments matching Linux conventions, outputs are syscall return codes (success result or negative error). The declarations impose constraints of C type-safety and strict correspondence to the system call ABI.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_arm64_prototypes.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nlong sys_tgkill(pid_t tgid, pid_t pid, int sig);\nlong sys_sigaltstack(const struct sigaltstack __user *uss, struct sigaltstack __user *uoss);\nlong sys_rt_sigsuspend(sigset_t __user *unewset, size_t sigsetsize);\nlong sys_rt_sigaction(int, const struct sigaction __user *, struct sigaction __user *, size_t);\nlong sys_rt_sigprocmask(int how, sigset_t __user *set, sigset_t __user *oset, size_t sigsetsize);\nlong sys_rt_sigpending(sigset_t __user *set, size_t sigsetsize);\nlong sys_rt_sigtimedwait(const sigset_t __user *uthese, siginfo_t __user *uinfo, const struct timespec __user *uts, size_t sigsetsize);\nlong sys_rt_sigqueueinfo(pid_t pid, int sig, siginfo_t __user *uinfo);\nlong sys_rt_sigreturn(struct pt_regs *regs);\nlong sys_setpriority(int which, int who, int niceval);\nlong sys_getpriority(int which, int who);\nlong sys_reboot(int magic1, int magic2, unsigned int cmd, void __user *arg);\nlong sys_setregid(gid_t rgid, gid_t egid);\nlong sys_setgid(gid_t gid);\nlong sys_setreuid(uid_t ruid, uid_t euid);\nlong sys_setuid(uid_t uid);\nlong sys_setresuid(uid_t ruid, uid_t euid, uid_t suid);\nlong sys_getresuid(uid_t __user *ruid, uid_t __user *euid, uid_t __user *suid);\nlong sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid);\nlong sys_getresgid(gid_t __user *rgid, gid_t __user *egid, gid_t __user *sgid);\nlong sys_setfsuid(uid_t uid);\nlong sys_setfsgid(gid_t gid);\nlong sys_times(struct tms __user *tbuf);\nlong sys_setpgid(pid_t pid, pid_t pgid);\nlong sys_getpgid(pid_t pid);\nlong sys_getsid(pid_t pid);\nlong sys_setsid(void);\nlong sys_getgroups(int gidsetsize, gid_t __user *grouplist);\nlong sys_setgroups(int gidsetsize, gid_t __user *grouplist);\nlong sys_uname(struct new_utsname __user *name);\nlong sys_sethostname(char __user *name, int len);\nlong sys_setdomainname(char __user *name, int len);\nlong sys_getrlimit(unsigned int resource, struct rlimit __user *rlim);\nlong sys_setrlimit(unsigned int resource, struct rlimit __user *rlim);\nlong sys_getrusage(int who, struct rusage __user *ru);\nlong sys_umask(int mask);\nlong sys_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\nlong sys_getcpu(unsigned __user *cpu, unsigned __user *node, struct getcpu_cache __user *cache);\nlong sys_gettimeofday(struct timeval __user *tv, struct timezone __user *tz);\nlong sys_settimeofday(struct timeval __user *tv, struct timezone __user *tz);\nlong sys_adjtimex(struct timex __user *txc_p);\nlong sys_getpid(void);\nlong sys_getppid(void);\nlong sys_getuid(void);\nlong sys_geteuid(void);\nlong sys_getgid(void);\nlong sys_getegid(void);\nlong sys_gettid(void);\nlong sys_sysinfo(struct sysinfo __user *info);\nlong sys_mq_open(const char __user *name, int oflag, umode_t mode, struct mq_attr __user *attr);\nlong sys_mq_unlink(const char __user *name);\nlong sys_mq_timedsend(mqd_t mqdes, const char __user *msg_ptr, size_t msg_len, unsigned int msg_prio, const struct timespec __user *abs_timeout);\nlong sys_mq_timedreceive(mqd_t mqdes, char __user *msg_ptr, size_t msg_len, unsigned int __user *msg_prio, const struct timespec __user *abs_timeout);\nlong sys_mq_notify(mqd_t mqdes, const struct sigevent __user *notification);\nlong sys_mq_getsetattr(mqd_t mqdes, const struct mq_attr __user *mqstat, struct mq_attr __user *omqstat);\nlong sys_msgget(key_t key, int msgflg);\nlong sys_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);\nlong sys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz, long msgtyp, int msgflg);\nlong sys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz, int msgflg);\nlong sys_semget(key_t key, int nsems, int semflg);\nlong sys_semctl(int semid, int semnum, int cmd, unsigned long arg);\nlong sys_semtimedop(int semid, struct sembuf __user *sops, unsigned nsops, const struct timespec __user *timeout);\nlong sys_semop(int semid, struct sembuf __user *sops, unsigned nsops);\nlong sys_shmget(key_t key, size_t size, int flag);\nlong sys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);\nlong sys_shmat(int shmid, char __user *shmaddr, int shmflg);\nlong sys_shmdt(char __user *shmaddr);\nlong sys_socket(int, int, int);\nlong sys_socketpair(int, int, int, int __user *);\nlong sys_bind(int, struct sockaddr __user *, int);\nlong sys_listen(int, int);\nlong sys_accept(int, struct sockaddr __user *, int __user *);\nlong sys_connect(int, struct sockaddr __user *, int);\nlong sys_getsockname(int, struct sockaddr __user *, int __user *);\nlong sys_getpeername(int, struct sockaddr __user *, int __user *);\nlong sys_sendto(int, void __user *, size_t, unsigned, struct sockaddr __user *, int);\nlong sys_recvfrom(int, void __user *, size_t, unsigned, struct sockaddr __user *, int __user *);\nlong sys_setsockopt(int fd, int level, int optname, char __user *optval, int optlen);\nlong sys_getsockopt(int fd, int level, int optname, char __user *optval, int __user *optlen);\nlong sys_shutdown(int, int);\nlong sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\nlong sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\nlong sys_readahead(int fd, loff_t offset, size_t count);\nlong sys_brk(unsigned long brk);\nlong sys_munmap(unsigned long addr, size_t len);\nlong sys_mremap(unsigned long addr, unsigned long old_len, unsigned long new_len, unsigned long flags, unsigned long new_addr);\nlong sys_add_key(const char __user *_type, const char __user *_description, const void __user *_payload, size_t plen, key_serial_t destringid);\nlong sys_request_key(const char __user *_type, const char __user *_description, const char __user *_callout_info, key_serial_t destringid);\nlong sys_keyctl(int cmd, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\nlong sys_clone(unsigned long, unsigned long, int __user *, int __user *, unsigned long);\nlong sys_execve(const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp);\nlong sys_mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);\nlong sys_fadvise64(int fd, loff_t offset, size_t len, int advice);\nlong sys_swapon(const char __user *specialfile, int swap_flags);\nlong sys_swapoff(const char __user *specialfile);\nlong sys_mprotect(unsigned long start, size_t len, unsigned long prot);\nlong sys_msync(unsigned long start, size_t len, int flags);\nlong sys_mlock(unsigned long start, size_t len);\nlong sys_munlock(unsigned long start, size_t len);\nlong sys_mlockall(int flags);\nlong sys_munlockall(void);\nlong sys_mincore(unsigned long start, size_t len, unsigned char __user *vec);\nlong sys_madvise(unsigned long start, size_t len, int behavior);\nlong sys_remap_file_pages(unsigned long start, unsigned long size, unsigned long prot, unsigned long pgoff, unsigned long flags);\nlong sys_mbind(unsigned long start, unsigned long len, unsigned long mode, const unsigned long __user *nmask, unsigned long maxnode, unsigned flags);\nlong sys_get_mempolicy(int __user *policy, unsigned long __user *nmask, unsigned long maxnode, unsigned long addr, unsigned long flags);\nlong sys_set_mempolicy(int mode, const unsigned long __user *nmask, unsigned long maxnode);\nlong sys_migrate_pages(pid_t pid, unsigned long maxnode, const unsigned long __user *from, const unsigned long __user *to);\nlong sys_move_pages(pid_t pid, unsigned long nr_pages, const void __user * __user *pages, const int __user *nodes, int __user *status, int flags);\nlong sys_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t __user *uinfo);\nlong sys_perf_event_open(struct perf_event_attr __user *attr_uptr, pid_t pid, int cpu, int group_fd, unsigned long flags);\nlong sys_accept4(int, struct sockaddr *, int *, int);\nlong sys_recvmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags, struct timespec __user *timeout);\n// 244 - 259: not implemented on AArch64\nlong sys_wait4(pid_t pid, int *stat_addr, int options, struct rusage *ru);\nlong sys_prlimit64(pid_t pid, unsigned int resource, const struct rlimit64 *new_rlim, struct rlimit64 *old_rlim);\nlong sys_fanotify_init(unsigned int flags, unsigned int event_f_flags);\nlong sys_fanotify_mark(int fanotify_fd, unsigned int flags, u64 mask, int fd, const char __user *pathname);\nlong sys_name_to_handle_at(int dfd, const char __user *name, struct file_handle __user *handle, int __user *mnt_id, int flag);\nlong sys_open_by_handle_at(int mountdirfd, struct file_handle __user *handle, int flags);\nlong sys_clock_adjtime(clockid_t which_clock, struct timex __user *tx);\nlong sys_syncfs(int fd);\nlong sys_setns(int fd, int nstype);\nlong sys_sendmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags);\nlong sys_process_vm_readv(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);\nlong sys_process_vm_writev(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);\nlong sys_kcmp(pid_t pid1, pid_t pid2, int type, unsigned long idx1, unsigned long idx2);\nlong sys_finit_module(int fd, const char __user *uargs, int flags);\nlong sys_sched_setattr(pid_t pid, struct sched_attr __user *attr, unsigned int flags);\nlong sys_sched_getattr(pid_t pid, struct sched_attr __user *attr, unsigned int size, unsigned int flags);\nlong sys_renameat2(int olddfd, const char *oldname, int newdfd, const char *newname, unsigned int flags);\n```\n\n----------------------------------------\n\nTITLE: Importing and Loading a PyPlugin via PyPanda and Python Modules (Python)\nDESCRIPTION: Shows instantiation of a Panda object and loading of a defined plugin from another module, passing arguments for configuration. Requires 'pandare' and a separate file (hello.py) containing HelloPlugin. Useful for modular plugin development and dynamic invocation in scripts.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/pyplugins.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pandare import Panda\nfrom hello import HelloPlugin\npanda = Panda.generic(\"x86_64\")\npanda.pyplugins.load(HelloPlugin, {'should_print_hello': True})\n```\n\n----------------------------------------\n\nTITLE: HD Transfer Callback Processing in Replay Mode\nDESCRIPTION: Code from rr_log.c that processes HD transfer callbacks during replay, executing all registered callbacks for hard drive transfers with appropriate parameters.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/hd_taint.txt#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\ncase RR_CALL_HD_TRANSFER:\n{\n  // run all callbacks registered for hd transfer                                                                   \n  RR_hd_transfer *hdt = &(args->variant.hd_transfer_args);\n  panda_cb_list *plist;\n  for (plist = panda_cbs[PANDA_CB_REPLAY_HD_TRANSFER]; plist != NULL; plist = plist->next) {\n    plist->entry.replay_hd_transfer\n      (cpu_single_env,\n       hdt->type,\n       hdt->src_addr,\n       hdt->dest_addr,\n       hdt->num_bytes);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Hot-Unplugging Memory Devices via QEMU Monitor - QEMU Monitor\nDESCRIPTION: This snippet illustrates how to remove (hot-unplug) a memory module from a running QEMU guest using monitor commands. 'device_del' detaches the specified pc-dimm device, and 'object_del' releases the backend previously created for it. The IDs used must correspond to those assigned at hotplug time. Proper sequence and existence of the device/object are critical, and the operation may be constrained by guest OS memory policies.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/memory-hotplug.txt#_snippet_4\n\nLANGUAGE: qemu-monitor\nCODE:\n```\n(qemu) device_del dimm1\n(qemu) object_del mem1\n```\n\n----------------------------------------\n\nTITLE: Formatting Tap Points for Data Tapping (Text Example)\nDESCRIPTION: This plaintext snippet shows the tap_points.txt file, which specifies program counters and address spaces where matching memory accesses occurred. These values are used by the textprinter plugin to carefully monitor interesting data flows during another PANDA replay. Inputs are sets of hexadecimal values representing tap locations; output is a search parameter file.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/LINE_Censorship.md#_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n40796784 40038678 28210000\\n40796784 40038688 28210000\\n407a7ada 4074f630 28210000\\n407a7ada 4b50817c 28210000\n```\n\n----------------------------------------\n\nTITLE: Pre-LoadVM Callback Signature\nDESCRIPTION: Callback function signature for operations before loading VM snapshot state during replay.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_49\n\nLANGUAGE: C\nCODE:\n```\nint (*before_loadvm)(void);\n```\n\n----------------------------------------\n\nTITLE: Attaching GDB Client to PANDA and Loading Commands - Shell\nDESCRIPTION: This shell command shows how to attach GDB to a paused PANDA replay, sourcing the provided 'gdbinit' script and connecting remotely to the PANDA guest. The '[kernel binary path]' indicates where the kernel binary is located for symbols and source mapping. Prerequisites include a working GDB installation and access to the PANDA gdbinit script.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/time-travel.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ngdb -x ~/panda/panda/scripts/gdbinit -ex 'target remote localhost:1234' [kernel binary path]\n```\n\n----------------------------------------\n\nTITLE: Defining File and Extended Attribute System Calls in C\nDESCRIPTION: Function declarations for Linux system calls related to file operations and extended attributes (xattr). These calls handle reading ahead, setting/getting/listing/removing extended attributes on files, directories, and file descriptors.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_26\n\nLANGUAGE: C\nCODE:\n```\nlong sys_readahead(int fd, loff_t offset, size_t count);\nlong sys_setxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\nlong sys_lsetxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\nlong sys_fsetxattr(int fd, const char __user *name, const void __user *value, size_t size, int flags);\nlong sys_getxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\nlong sys_lgetxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\nlong sys_fgetxattr(int fd, const char __user *name, void __user *value, size_t size);\nlong sys_listxattr(const char __user *path, char __user *list, size_t size);\nlong sys_llistxattr(const char __user *path, char __user *list, size_t size);\nlong sys_flistxattr(int fd, char __user *list, size_t size);\nlong sys_removexattr(const char __user *path, const char __user *name);\nlong sys_lremovexattr(const char __user *path, const char __user *name);\nlong sys_fremovexattr(int fd, const char __user *name);\n```\n\n----------------------------------------\n\nTITLE: Separating Character Device Parts with -chardev and -device (QEMU CLI, Shell)\nDESCRIPTION: Presents the best-practice approach for creating a host-side character device (with -chardev) and mapping it into a guest device via -device. Parameters are HOST-OPTS, chardev ID, device options. Input: two CLI lines; result is guest device mapped to designated host character endpoint. Dependency: QEMU CLI tool.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n-chardev HOST-OPTS...,id=CHR-ID\n-device DEVNAME,chardev=CHR-ID,DEV-OPTS...\n```\n\n----------------------------------------\n\nTITLE: Defining DMA Access Structure for fw_cfg Device in C\nDESCRIPTION: This C typedef describes the 'FWCfgDmaAccess' structure used to initiate DMA read/write operations from the guest firmware to the QEMU fw_cfg virtual device. The 'control', 'length', and 'address' fields are in big-endian order, with the 'control' field containing operation flags and status bits. DMA operations are triggered by writing the physical address of this struct to the fw_cfg DMA address register, as defined by the hardware interface. Key fields: control (flags and command), length (byte transfer size), address (target guest physical address). Prerequisite: knowledge of memory-mapped IO and endian conversion.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/fw_cfg.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct FWCfgDmaAccess {\\n\\tuint32_t control;\\n\\tuint32_t length;\\n\\tuint64_t address;\\n} FWCfgDmaAccess;\n```\n\n----------------------------------------\n\nTITLE: File and Directory System Call Declarations in C\nDESCRIPTION: Function declarations for Linux system calls related to file and directory operations. These declarations specify the interface for operations such as accessing, creating, modifying, and navigating files and directories.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_17\n\nLANGUAGE: C\nCODE:\n```\nlong sys_access(const char __user *filename, int mode);\nlong sys_pipe(int __user *fildes);\nlong sys_select(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct __kernel_old_timeval __user *tvp);\nlong sys_dup(unsigned int fildes);\nlong sys_dup2(unsigned int oldfd, unsigned int newfd);\nlong sys_fsync(unsigned int fd);\nlong sys_fdatasync(unsigned int fd);\nlong sys_truncate(const char __user *path, long length);\nlong sys_ftruncate(unsigned int fd, unsigned long length);\nlong sys_getdents(unsigned int fd, struct linux_dirent __user *dirent, unsigned int count);\nlong sys_getcwd(char __user *buf, unsigned long size);\nlong sys_chdir(const char __user *filename);\nlong sys_fchdir(unsigned int fd);\nlong sys_rename(const char __user *oldname, const char __user *newname);\nlong sys_mkdir(const char __user *pathname, umode_t mode);\nlong sys_rmdir(const char __user *pathname);\nlong sys_creat(const char __user *pathname, umode_t mode);\nlong sys_link(const char __user *oldname, const char __user *newname);\nlong sys_unlink(const char __user *pathname);\nlong sys_symlink(const char __user *old, const char __user *new);\nlong sys_readlink(const char __user *path, char __user *buf, int bufsiz);\nlong sys_chmod(const char __user *filename, umode_t mode);\nlong sys_fchmod(unsigned int fd, umode_t mode);\nlong sys_chown(const char __user *filename, uid_t user, gid_t group);\nlong sys_fchown(unsigned int fd, uid_t user, gid_t group);\nlong sys_lchown(const char __user *filename, uid_t user, gid_t group);\nlong sys_umask(int mask);\nlong sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg);\nlong sys_flock(unsigned int fd, unsigned int cmd);\nlong sys_mknod(const char __user *filename, umode_t mode, unsigned dev);\nlong sys_statfs(const char __user *path, struct statfs __user *buf);\nlong sys_fstatfs(unsigned int fd, struct statfs __user *buf);\nlong sys_sysfs(int option, unsigned long arg1, unsigned long arg2);\nlong sys_ustat(unsigned dev, struct ustat __user *ubuf);\nlong sys_mount(char __user *dev_name, char __user *dir_name, char __user *type, unsigned long flags, void __user *data);\nlong sys_umount(char __user *name, int flags);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Calls for System and Security Operations in C\nDESCRIPTION: This snippet declares Windows NT system calls related to system-wide operations, security, and object management. These functions handle tasks such as querying system environment values, managing security attributes, and interacting with various system objects.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x64_prototypes.txt#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQuerySystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, PULONG ValueLength, PULONG Attributes);\nNTSTATUS NtQuerySystemInformationEx (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID QueryInformation, ULONG QueryInformationLength, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySecurityAttributesToken (HANDLE TokenHandle, PUNICODE_STRING Attributes, ULONG NumberOfAttributes, PVOID Buffer, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtQuerySecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Length, PULONG LengthNeeded);\n```\n\n----------------------------------------\n\nTITLE: Declaring NT System Call Prototypes - Windows Native API - C\nDESCRIPTION: This snippet declares function prototypes for various native NT Windows system calls using the NTSTATUS convention in C. It requires inclusion of standard Windows headers for types such as HANDLE, PVOID, and specific info structs. Each prototype provides the interface to a kernel-mode function, requiring proper argument structures, and is intended for use when linking with ntdll or invoking system calls via dynamic resolution. Key parameters include handles, pointers to info classes, data buffers, and length indicators, with expected outputs usually being NTSTATUS error codes. Limitations include strong dependency on proper data types and privilege requirements for some operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2003sp0_x86_prototypes.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n219 NTSTATUS NtSetBootEntryOrder (PULONG Ids, ULONG Count);\n220 NTSTATUS NtSetBootOptions (PBOOT_OPTIONS BootOptions, ULONG FieldsToChange);\n221 NTSTATUS NtSetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\n222 NTSTATUS NtSetDebugFilterState (ULONG ComponentId, ULONG Level, BOOLEAN State);\n223 NTSTATUS NtSetDefaultHardErrorPort (HANDLE DefaultHardErrorPort);\n224 NTSTATUS NtSetDefaultLocale (BOOLEAN UserProfile, LCID DefaultLocaleId);\n225 NTSTATUS NtSetDefaultUILanguage (LANGID DefaultUILanguageId);\n226 NTSTATUS NtSetDriverEntryOrder (PULONG Ids, ULONG Count);\n227 NTSTATUS NtSetEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\n228 NTSTATUS NtSetEvent (HANDLE EventHandle, PLONG PreviousState);\n229 NTSTATUS NtSetEventBoostPriority (HANDLE EventHandle);\n230 NTSTATUS NtSetHighEventPair (HANDLE EventPairHandle);\n231 NTSTATUS NtSetHighWaitLowEventPair (HANDLE EventPairHandle);\n232 NTSTATUS NtSetInformationDebugObject (HANDLE DebugObjectHandle, DEBUGOBJECTINFOCLASS DebugObjectInformationClass, PVOID DebugInformation, ULONG DebugInformationLength, PULONG ReturnLength);\n233 NTSTATUS NtSetInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\n234 NTSTATUS NtSetInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength);\n235 NTSTATUS NtSetInformationKey (HANDLE KeyHandle, KEY_SET_INFORMATION_CLASS KeySetInformationClass, PVOID KeySetInformation, ULONG KeySetInformationLength);\n236 NTSTATUS NtSetInformationObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength);\n237 NTSTATUS NtSetInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);\n238 NTSTATUS NtSetInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);\n239 NTSTATUS NtSetInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength);\n240 NTSTATUS NtSetIntervalProfile (ULONG Interval, KPROFILE_SOURCE Source);\n241 NTSTATUS NtSetIoCompletion (HANDLE IoCompletionHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);\n242 NTSTATUS NtSetLdtEntries (ULONG Selector0, ULONG Entry0Low, ULONG Entry0Hi, ULONG Selector1, ULONG Entry1Low, ULONG Entry1Hi);\n243 NTSTATUS NtSetLowEventPair (HANDLE EventPairHandle);\n244 NTSTATUS NtSetLowWaitHighEventPair (HANDLE EventPairHandle);\n245 NTSTATUS NtSetQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\n246 NTSTATUS NtSetSecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);\n247 NTSTATUS NtSetSystemEnvironmentValue (PUNICODE_STRING VariableName, PUNICODE_STRING VariableValue);\n248 NTSTATUS NtSetSystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, ULONG ValueLength, ULONG Attributes);\n249 NTSTATUS NtSetSystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);\n250 NTSTATUS NtSetSystemPowerState (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags);\n251 NTSTATUS NtSetSystemTime (PLARGE_INTEGER SystemTime, PLARGE_INTEGER PreviousTime);\n252 NTSTATUS NtSetThreadExecutionState (EXECUTION_STATE esFlags, PEXECUTION_STATE PreviousFlags);\n253 NTSTATUS NtSetTimer (HANDLE TimerHandle, PLARGE_INTEGER DueTime, PTIMER_APC_ROUTINE TimerApcRoutine, PVOID TimerContext, BOOLEAN WakeTimer, LONG Period, PBOOLEAN PreviousState);\n254 NTSTATUS NtSetTimerResolution (ULONG DesiredTime, BOOLEAN SetResolution, PULONG ActualTime);\n255 NTSTATUS NtSetUuidSeed (PCHAR Seed);\n256 NTSTATUS NtSetValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);\n257 NTSTATUS NtSetVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\n258 NTSTATUS NtShutdownSystem (SHUTDOWN_ACTION Action);\n259 NTSTATUS NtSignalAndWaitForSingleObject (HANDLE SignalHandle, HANDLE WaitHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n260 NTSTATUS NtStartProfile (HANDLE ProfileHandle);\n261 NTSTATUS NtStopProfile (HANDLE ProfileHandle);\n262 NTSTATUS NtSuspendProcess (HANDLE ProcessHandle);\n263 NTSTATUS NtSuspendThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\n264 NTSTATUS NtSystemDebugControl (SYSDBG_COMMAND Command, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, PULONG ReturnLength);\n265 NTSTATUS NtTerminateJobObject (HANDLE JobHandle, NTSTATUS ExitStatus);\n266 NTSTATUS NtTerminateProcess (HANDLE ProcessHandle, NTSTATUS ExitStatus);\n267 NTSTATUS NtTerminateThread (HANDLE ThreadHandle, NTSTATUS ExitStatus);\n268 NTSTATUS NtTestAlert ();\n269 NTSTATUS NtTraceEvent (HANDLE TraceHandle, ULONG Flags, ULONG FieldSize, PVOID Fields);\n270 NTSTATUS NtTranslateFilePath (PFILE_PATH InputFilePath, ULONG OutputType, PFILE_PATH OutputFilePath, PULONG OutputFilePathLength);\n271 NTSTATUS NtUnloadDriver (PUNICODE_STRING DriverServiceName);\n272 NTSTATUS NtUnloadKey (POBJECT_ATTRIBUTES TargetKey);\n273 NTSTATUS NtUnloadKey2 (POBJECT_ATTRIBUTES TargetKey, ULONG Flags);\n274 NTSTATUS NtUnloadKeyEx (POBJECT_ATTRIBUTES TargetKey, HANDLE Event);\n275 NTSTATUS NtUnlockFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key);\n276 NTSTATUS NtUnlockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\n277 NTSTATUS NtUnmapViewOfSection (HANDLE ProcessHandle, PVOID BaseAddress);\n278 NTSTATUS NtVdmControl (VDMSERVICECLASS Service, PVOID ServiceData);\n279 NTSTATUS NtWaitForDebugEvent (HANDLE DebugObjectHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PDBGUI_WAIT_STATE_CHANGE WaitStateChange);\n280 NTSTATUS NtWaitForMultipleObjects (ULONG Count, HANDLE Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n281 NTSTATUS NtWaitForSingleObject (HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n282 NTSTATUS NtWaitHighEventPair (HANDLE EventPairHandle);\n283 NTSTATUS NtWaitLowEventPair (HANDLE EventPairHandle);\n284 NTSTATUS NtWriteFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n285 NTSTATUS NtWriteFileGather (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n286 NTSTATUS NtWriteRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\n287 NTSTATUS NtWriteVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\n288 NTSTATUS NtYieldExecution ();\n289 NTSTATUS NtCreateKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\n290 NTSTATUS NtOpenKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n291 NTSTATUS NtReleaseKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n292 NTSTATUS NtWaitForKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n293 NTSTATUS NtQueryPortInformationProcess ();\n294 ULONG NtGetCurrentProcessorNumber ();\n```\n\n----------------------------------------\n\nTITLE: Declaring Native NT System API Function Prototypes in C\nDESCRIPTION: These code snippets collectively declare multiple C functions mapping to Windows NT native system calls. Each function is declared with required parameter types, such as custom handle, status, and information structures, and returns an NTSTATUS value for error or success reporting. Dependencies include appropriate type definitions (e.g., PUNICODE_STRING, HANDLE, NTSTATUS), and linking to native NT headers or implementation libraries. Functions are parameterized for system, file, and memory operations; inputs and outputs align to Windows kernel conventions, typically not directly usable without operating system support; intended for system-level, driver, or advanced application code, and require privileges matching the respective operation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x64_prototypes.txt#_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetSystemEnvironmentValue (PUNICODE_STRING VariableName, PUNICODE_STRING VariableValue);\nNTSTATUS NtSetSystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, ULONG ValueLength, ULONG Attributes);\nNTSTATUS NtSetSystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);\nNTSTATUS NtSetSystemPowerState (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags);\nNTSTATUS NtSetSystemTime (PLARGE_INTEGER SystemTime, PLARGE_INTEGER PreviousTime);\nNTSTATUS NtSetThreadExecutionState (EXECUTION_STATE esFlags, PEXECUTION_STATE PreviousFlags);\nNTSTATUS NtSetTimerEx (HANDLE TimerHandle, TIMER_SET_INFORMATION_CLASS TimerSetInformationClass, PVOID TimerSetInformation, ULONG TimerSetInformationLength);\nNTSTATUS NtSetTimerResolution (ULONG DesiredTime, BOOLEAN SetResolution, PULONG ActualTime);\nNTSTATUS NtSetUuidSeed (PCHAR Seed);\nNTSTATUS NtSetVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtShutdownSystem (SHUTDOWN_ACTION Action);\nNTSTATUS NtShutdownWorkerFactory (HANDLE WorkerFactoryHandle, LONG *PendingWorkerCount);\nNTSTATUS NtSignalAndWaitForSingleObject (HANDLE SignalHandle, HANDLE WaitHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtSinglePhaseReject (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtStartProfile (HANDLE ProfileHandle);\nNTSTATUS NtStopProfile (HANDLE ProfileHandle);\nNTSTATUS NtSuspendProcess (HANDLE ProcessHandle);\nNTSTATUS NtSuspendThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtSystemDebugControl (SYSDBG_COMMAND Command, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, PULONG ReturnLength);\nNTSTATUS NtTerminateJobObject (HANDLE JobHandle, NTSTATUS ExitStatus);\nNTSTATUS NtTestAlert ();\nNTSTATUS NtThawRegistry ();\nNTSTATUS NtThawTransactions ();\nNTSTATUS NtTraceControl (ULONG FunctionCode, PVOID InBuffer, ULONG InBufferLen, PVOID OutBuffer, ULONG OutBufferLen, PULONG ReturnLength);\nNTSTATUS NtTranslateFilePath (PFILE_PATH InputFilePath, ULONG OutputType, PFILE_PATH OutputFilePath, PULONG OutputFilePathLength);\nNTSTATUS NtUmsThreadYield (PVOID SchedulerParam);\nNTSTATUS NtUnloadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtUnloadKey (POBJECT_ATTRIBUTES TargetKey);\nNTSTATUS NtUnloadKey2 (POBJECT_ATTRIBUTES TargetKey, ULONG Flags);\nNTSTATUS NtUnloadKeyEx (POBJECT_ATTRIBUTES TargetKey, HANDLE Event);\nNTSTATUS NtUnlockFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key);\nNTSTATUS NtUnlockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtVdmControl (VDMSERVICECLASS Service, PVOID ServiceData);\nNTSTATUS NtWaitForDebugEvent (HANDLE DebugObjectHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PDBGUI_WAIT_STATE_CHANGE WaitStateChange);\nNTSTATUS NtWaitForKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitForWorkViaWorkerFactory (HANDLE WorkerFactoryHandle, PFILE_IO_COMPLETION_INFORMATION MiniPacket);\nNTSTATUS NtWaitHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtWaitLowEventPair (HANDLE EventPairHandle);\n```\n\n----------------------------------------\n\nTITLE: Defining Boot Entry and Driver Management System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to boot configuration and driver entries. These functions manage boot-time configuration of the system.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_16\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDeleteBootEntry (ULONG Id);\nNTSTATUS NtDeleteDriverEntry (ULONG Id);\n```\n\n----------------------------------------\n\nTITLE: Declaring Get Current Process Handle Callback Typedef in C\nDESCRIPTION: Declares a callback typedef for fetching the handle of the currently running process. It takes CPUState and outputs a pointer to an OsiProcHandle, requiring freeing with free_osiprochandle. This function gives introspection plugins a handle suitable for later identification or lookups.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_get_current_process_handle_t)(CPUState *, OsiProcHandle **)\n```\n\n----------------------------------------\n\nTITLE: Installing PyPANDA Using setup.py - Python\nDESCRIPTION: Installs the PyPANDA Python bindings by navigating to the core Python module directory and running the setup.py installation script. Relies on dependencies listed in requirements.txt and assumes that Python 3 and setup tools are available. Key input is the path to the PyPANDA core directory and use of the system Python environment. Outputs are an installed PyPANDA module available to Python scripts in the environment.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/build_ubuntu.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# Install pypanda, see requirements.txt for the installed python dependancies\ncd panda/panda/python/core\npython3 setup.py install\n\n```\n\n----------------------------------------\n\nTITLE: Defining Robust Futex and File System Operation System Calls in C\nDESCRIPTION: Function declarations for Linux system calls related to robust futexes, event handling, and file system operations like fallocate. These calls provide mechanisms for robust process synchronization and efficient file management.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_36\n\nLANGUAGE: C\nCODE:\n```\nlong sys_get_robust_list(int pid, struct robust_list_head __user * __user *head_ptr, size_t __user *len_ptr);\nlong sys_set_robust_list(struct robust_list_head __user *head, size_t len);\nlong sys_kexec_load(unsigned long entry, unsigned long nr_segments, struct kexec_segment __user *segments, unsigned long flags);\nlong sys_getcpu(unsigned __user *cpu, unsigned __user *node, struct getcpu_cache __user *cache);\nlong sys_signalfd(int ufd, sigset_t __user *user_mask, size_t sizemask);\nlong sys_eventfd(unsigned int count);\nlong sys_fallocate(int fd, int mode, loff_t offset, loff_t len);\nlong sys_signalfd4(int ufd, sigset_t __user *user_mask, size_t sizemask, int flags);\nlong sys_eventfd2(unsigned int count, int flags);\nlong sys_dup3(unsigned int oldfd, unsigned int newfd, int flags);\nlong sys_pipe2(int __user *fildes, int flags);\n```\n\n----------------------------------------\n\nTITLE: Process Communication and Memory Sharing Prototypes in C\nDESCRIPTION: Function prototypes for Linux system calls related to interprocess communication and memory sharing. These functions facilitate data exchange and synchronization between processes running on the system.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nlong sys_process_vm_readv(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);\nlong sys_process_vm_writev(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);\nlong sys_move_pages(pid_t pid, unsigned long nr_pages, const void __user * __user *pages, const int __user *nodes, int __user *status, int flags);\nlong sys_dup3(unsigned int oldfd, unsigned int newfd, int flags);\nlong sys_pipe2(int __user *fildes, int flags);\nlong sys_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t __user *uinfo);\n```\n\n----------------------------------------\n\nTITLE: File Operation System Call Prototypes in C\nDESCRIPTION: Function prototypes for Linux system calls related to file operations including reading, writing, file creation, and manipulation. These functions form the core API for file handling in the Linux kernel.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nlong sys_read(unsigned int fd, char __user *buf, size_t count);\nlong sys_write(unsigned int fd, const char __user *buf, size_t count);\nlong sys_open(const char __user *filename, int flags, umode_t mode);\nlong sys_close(unsigned int fd);\nlong sys_newstat(const char __user *filename, struct stat __user *statbuf);\nlong sys_newfstat(unsigned int fd, struct stat __user *statbuf);\nlong sys_newlstat(const char __user *filename, struct stat __user *statbuf);\nlong sys_poll(struct pollfd __user *ufds, unsigned int nfds, int timeout);\nlong sys_lseek(unsigned int fd, off_t offset, unsigned int whence);\nlong sys_pread64(unsigned int fd, char __user *buf, size_t count, loff_t pos);\nlong sys_pwrite64(unsigned int fd, const char __user *buf, size_t count, loff_t pos);\nlong sys_readv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\nlong sys_writev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\n```\n\n----------------------------------------\n\nTITLE: Defining and Freeing Generated QAPI Structs and Lists in C\nDESCRIPTION: This header and source code, generated by qapi-types.py, declare C struct types reflecting the schema and the related free functions for deallocation. Dependencies include system headers, QAPI infrastructure, and the generated header itself. The types feature an example struct with an integer field and an optional string, and linked-list containers for handling lists of these types; inputs are struct pointers, and outputs are proper resource cleanup.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_20\n\nLANGUAGE: C\nCODE:\n```\n#ifndef EXAMPLE_QAPI_TYPES_H\\n#define EXAMPLE_QAPI_TYPES_H\\n\\ntypedef struct UserDefOne UserDefOne;\\n\\ntypedef struct UserDefOneList UserDefOneList;\\n\\nstruct UserDefOne {\\n    int64_t integer;\\n    bool has_string;\\n    char *string;\\n};\\n\\nvoid qapi_free_UserDefOne(UserDefOne *obj);\\n\\nstruct UserDefOneList {\\n    UserDefOneList *next;\\n    UserDefOne *value;\\n};\\n\\nvoid qapi_free_UserDefOneList(UserDefOneList *obj);\\n\\n#endif\n```\n\nLANGUAGE: C\nCODE:\n```\nvoid qapi_free_UserDefOne(UserDefOne *obj)\\n{\\n    Visitor *v;\\n\\n    if (!obj) {\\n        return;\\n    }\\n\\n    v = qapi_dealloc_visitor_new();\\n    visit_type_UserDefOne(v, NULL, &obj, NULL);\\n    visit_free(v);\\n}\\n\\nvoid qapi_free_UserDefOneList(UserDefOneList *obj)\\n{\\n    Visitor *v;\\n\\n    if (!obj) {\\n        return;\\n    }\\n\\n    v = qapi_dealloc_visitor_new();\\n    visit_type_UserDefOneList(v, NULL, &obj, NULL);\\n    visit_free(v);\\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning PANDA Repository - Git - Bash\nDESCRIPTION: This snippet uses Git to clone the PANDA repository, which contains all source code and analysis plugins. The command downloads the entire project from GitHub, enabling the user to set up the PANDA analysis environment. No input parameters are required, but Git must be installed on the system. Output is a local copy of the repository directory.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/UAF.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/moyix/panda.git\n```\n\n----------------------------------------\n\nTITLE: Declaring a Callback after VM Load Event - C\nDESCRIPTION: Presents the signature for after_vmload, a void callback meant to be triggered after a VM snapshot is loaded but before any guest code runs. Input is a pointer to CPUState, enabling post-restore or snapshot handling logic for modules. There is no return value and the function expects all required state to be available immediately after VM load.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_59\n\nLANGUAGE: C\nCODE:\n```\nvoid after_vmload(CPUState *env);\n```\n\n----------------------------------------\n\nTITLE: Creating Itemized and Numbered Lists in QAPI Documentation - Markdown\nDESCRIPTION: Explains how to include bullet and numbered lists within QAPI documentation comments using '*' or '-' for itemization and decimal numbers for ordered lists. The format is recognized by the documentation generator but does not support nesting or blank lines. Improper formatting may result in documentation parsing errors or loss of structure.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_2\n\nLANGUAGE: Markdown\nCODE:\n```\n# * First item, may span\n#   multiple lines\n# * Second item\n\n# 1. First item, may span\n#    multiple lines\n# 2. like that\n```\n\n----------------------------------------\n\nTITLE: Windows NT Native API System Call Declarations\nDESCRIPTION: Collection of Windows NT native API function declarations (NtXxx functions) that provide low-level system functionality. These functions handle operations like device power management, process enumeration, registry access, and system notifications.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_24\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtGetDevicePowerState (HANDLE Device, DEVICE_POWER_STATE *State);\nNTSTATUS NtGetMUIRegistryInfo (ULONG Flags, PULONG DataSize, PVOID Data);\nNTSTATUS NtGetNextProcess (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewProcessHandle);\nNTSTATUS NtGetNextThread (HANDLE ProcessHandle, HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewThreadHandle);\nNTSTATUS NtGetNlsSectionPtr (ULONG SectionType, ULONG SectionData, PVOID ContextData, PVOID *SectionPointer, PULONG SectionSize);\n// ... additional function declarations omitted for brevity ...\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API Miscellaneous System Functions in C\nDESCRIPTION: Function declarations for Windows NT native API calls related to various system operations including boot entry management, system time querying, power information, and unique ID allocation. These functions provide diverse system management capabilities.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp0_x64_prototypes.txt#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtApphelpCacheControl (APPHELPCOMMAND type, PVOID buf);\nNTSTATUS NtReadRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtWriteRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\nNTSTATUS NtOpenDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtQuerySystemTime (PLARGE_INTEGER SystemTime);\nNTSTATUS NtSetInformationObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength);\nNTSTATUS NtTraceEvent (HANDLE TraceHandle, ULONG Flags, ULONG FieldSize, PVOID Fields);\nNTSTATUS NtPowerInformation (POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtSetValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);\nNTSTATUS NtAcceptConnectPort (PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView);\nNTSTATUS NtAddBootEntry (PBOOT_ENTRY BootEntry, PULONG Id);\nNTSTATUS NtAddDriverEntry (PEFI_DRIVER_ENTRY DriverEntry, PULONG Id);\nNTSTATUS NtAllocateLocallyUniqueId (PLUID Luid);\nNTSTATUS NtAllocateUuids (PULARGE_INTEGER Time, PULONG Range, PULONG Sequence, PCHAR Seed);\n```\n\n----------------------------------------\n\nTITLE: Defining Plugin API Stubs and Including API Prototypes in C\nDESCRIPTION: This snippet demonstrates creating typedefs for custom types to satisfy the pycparser tool when generating plugin APIs in PANDA. The file includes <plugin>_int_fns.h, which lists function prototypes, and provides void typedefs for each custom type required by the plugin API. This pattern is necessary for automated code generation and seamless API usage by other plugins. Inputs include the set of functions/types to be exported; outputs are headers generated by apigen.py for cross-plugin API use.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_21\n\nLANGUAGE: C\nCODE:\n```\ntypedef void YourCustomType;\ntypedef void YourOtherCustomType;\n\n#include \"<plugin>_int_fns.h\"\n```\n\n----------------------------------------\n\nTITLE: Attaching IDE Devices with Bus and Unit Parameters (QEMU CLI, Shell)\nDESCRIPTION: Demonstrates attaching a block device to a specific IDE bus and unit by referencing both in the -device command. Targeted at configuration where multiple buses/devices may be present. Requires QEMU CLI. DEVNAME is ide-hd or ide-cd; IDE-BUS and UNIT parameter select exact target. Inputs are drive IDs and bus/unit selection; result is device placement on chosen IDE bus slot.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n-device DEVNAME,drive=DRIVE-ID,bus=IDE-BUS,unit=UNIT\n```\n\n----------------------------------------\n\nTITLE: Enabling Time-Travel Debugging with PANDA and Checkpoint Plugin - Shell\nDESCRIPTION: This shell snippet demonstrates the command required to start a PANDA replay with the checkpoint plugin enabled, initializing the system in a paused state and waiting for a debugger to attach. It assumes that PANDA is built and available in the specified path, and 'foo' represents the replay log. Parameters such as '-replay', '-S', '-s', and '-panda checkpoint' are necessary to enable checkpointing and wait for GDB. The user must have PANDA built, a valid replay log, and necessary permissions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/time-travel.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$PANDA_PATH/build/x86_64-softmmu/panda-system-x86_64 -replay foo -S -s -panda checkpoint\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Calls for Object and Information Management in C\nDESCRIPTION: This snippet declares Windows NT system calls for managing various objects and setting information. These functions handle tasks such as setting information for transactions, tokens, and worker factories, as well as managing I/O completion and LDT entries.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x64_prototypes.txt#_snippet_11\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength);\nNTSTATUS NtSetInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength);\nNTSTATUS NtSetInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength);\nNTSTATUS NtSetIoCompletion (HANDLE IoCompletionHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);\nNTSTATUS NtSetLdtEntries (ULONG Selector0, ULONG Entry0Low, ULONG Entry0Hi, ULONG Selector1, ULONG Entry1Low, ULONG Entry1Hi);\n```\n\n----------------------------------------\n\nTITLE: Defining Block Device Object Files with Conditional Compilation in QEMU Makefile\nDESCRIPTION: Example from block/Makefile.objs showing how object files are conditionally included based on configuration options and how to specify custom compiler and linker flags for specific object files.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/build-system.txt#_snippet_4\n\nLANGUAGE: Makefile\nCODE:\n```\nblock-obj-$(CONFIG_LIBISCSI) += iscsi.o\nblock-obj-$(CONFIG_CURL) += curl.o\n\n..snip...\n\niscsi.o-cflags     := $(LIBISCSI_CFLAGS)\niscsi.o-libs       := $(LIBISCSI_LIBS)\ncurl.o-cflags      := $(CURL_CFLAGS)\ncurl.o-libs        := $(CURL_LIBS)\n```\n\n----------------------------------------\n\nTITLE: Process ID Retrieval Function\nDESCRIPTION: API function that returns an integer identifier for the current process running on the CPU. For MIPS, it returns the task_struct address, while for other architectures it returns the ASID.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/hw_proc_id/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nint procid(CPUState*)\n```\n\n----------------------------------------\n\nTITLE: Configuring L2, Refcount, or Combined Cache Sizes at Image Launch - Shell\nDESCRIPTION: This group of shell snippets demonstrates three alternative ways to set cache sizes in QEMU: explicitly specifying the L2 cache, refcount cache, or both together with cache-size. All are passed as comma-separated parameters to the -drive option, with file designating the image and sizes set in bytes. QEMU ensures consistency by adjusting unspecified cache values so the L2 cache is typically four times larger than the refcount cache. The underlying qcow2 image must exist, and the size values should conform to cluster size alignment.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qcow2-cache.txt#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n-drive file=hd.qcow2,l2-cache-size=2097152\n```\n\nLANGUAGE: shell\nCODE:\n```\n-drive file=hd.qcow2,refcount-cache-size=524288\n```\n\nLANGUAGE: shell\nCODE:\n```\n-drive file=hd.qcow2,cache-size=2621440\n```\n\n----------------------------------------\n\nTITLE: Windows NT API System Functions Declarations\nDESCRIPTION: Function declarations for Windows NT native API (ntdll.dll) system calls. These functions handle operations like process management, file operations, registry access, and system queries. Most functions return NTSTATUS to indicate success or failure.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp0_x64_prototypes.txt#_snippet_9\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtGetNlsSectionPtr(ULONG SectionType, ULONG SectionData, PVOID ContextData, PVOID *SectionPointer, PULONG SectionSize);\nNTSTATUS NtGetNotificationResourceManager(HANDLE ResourceManagerHandle, PTRANSACTION_NOTIFICATION TransactionNotification, ULONG NotificationLength, PLARGE_INTEGER Timeout, PULONG ReturnLength, ULONG Asynchronous, ULONG_PTR AsynchronousContext);\nNTSTATUS NtGetPlugPlayEvent(HANDLE EventHandle, PVOID Context, PPLUGPLAY_EVENT_BLOCK EventBlock, ULONG EventBufferSize);\n/* Additional function declarations omitted for brevity */\nNTSTATUS NtQueryIntervalProfile(KPROFILE_SOURCE ProfileSource, PULONG Interval);\n```\n\n----------------------------------------\n\nTITLE: Assembling Replay Movie - Movie Script - Bash\nDESCRIPTION: This command runs the 'movie.sh' script from the 'replaymovie' plugin directory. It assembles the raw screenshots collected during the prior step into a playable video ('replay.mp4'). The script requires that 'parallel' and 'imagemagick' are installed. Expected input is a directory of images, and the output is an mp4 file usable by standard video players.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/UAF.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npanda/qemu/panda_plugins/replaymovie/movie.sh\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Call Prototypes in C\nDESCRIPTION: These C code snippets declare prototypes for various Windows NT system call functions for usage in user-mode or kernel-mode code. The functions leverage NTSTATUS return types for consistent error/success handling, and utilize an assortment of pointer, handle, and structure parameters, reflecting the complexity of low-level Windows resource management. Dependencies include windows data types (e.g., HANDLE, PUNICODE_STRING, PVOID) and relevant platform headers for data structures and constants.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp0_x64_prototypes.txt#_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtTestAlert ();\nNTSTATUS NtThawRegistry ();\nNTSTATUS NtThawTransactions ();\nNTSTATUS NtTraceControl (ULONG FunctionCode, PVOID InBuffer, ULONG InBufferLen, PVOID OutBuffer, ULONG OutBufferLen, PULONG ReturnLength);\nNTSTATUS NtTranslateFilePath (PFILE_PATH InputFilePath, ULONG OutputType, PFILE_PATH OutputFilePath, PULONG OutputFilePathLength);\nNTSTATUS NtUnloadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtUnloadKey (POBJECT_ATTRIBUTES TargetKey);\nNTSTATUS NtUnloadKey2 (POBJECT_ATTRIBUTES TargetKey, ULONG Flags);\nNTSTATUS NtUnloadKeyEx (POBJECT_ATTRIBUTES TargetKey, HANDLE Event);\nNTSTATUS NtUnlockFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key);\nNTSTATUS NtUnlockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtVdmControl (VDMSERVICECLASS Service, PVOID ServiceData);\nNTSTATUS NtWaitForDebugEvent (HANDLE DebugObjectHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PDBGUI_WAIT_STATE_CHANGE WaitStateChange);\nNTSTATUS NtWaitForKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitForWorkViaWorkerFactory (HANDLE WorkerFactoryHandle, PFILE_IO_COMPLETION_INFORMATION MiniPacket);\nNTSTATUS NtWaitHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtWaitLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtWorkerFactoryWorkerReady (HANDLE WorkerFactoryHandle);\n```\n\n----------------------------------------\n\nTITLE: File Permission Modification for Symbolic Links in C\nDESCRIPTION: Function declaration for changing permissions of a symbolic link. Unlike chmod, lchmod operates on the link itself rather than its target.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nint lchmod(const char *path, mode_t mode);\n```\n\n----------------------------------------\n\nTITLE: Declaring pri Provider Callback Typedefs - C\nDESCRIPTION: This code snippet contains C typedefs required for pri provider plugins to register their implementations for process introspection. Each typedef defines the required function signature for different kinds of callbacks: obtaining program counter source info, symbol lookups, and variable iteration. Implementations must match these signatures precisely for proper plugin operation. Key parameters include CPUState pointer, PC, VMA, user callback, symbol info pointers, and error codes. These are not standaloneâ€”they are expected to be wired into PANDAâ€™s plugin architecture.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/pri/README.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_get_pc_source_info_t)(CPUState *a, target_ulong pc, SrcInfo *info, int *rc)\n\ntypedef void (*on_get_vma_symbol)(CPUState *env, target_ulong pc, target_ulong vma, char **symbol_name)\n\ntypedef void (*on_all_livevar_iter_t)(CPUState *a, target_ulong pc, liveVarCB f)\n\ntypedef void (*on_global_livevar_iter_t)(CPUState *a, target_ulong pc, liveVarCB f)\n\ntypedef void (*on_funct_livevar_iter_t)(CPUState *a, target_ulong pc, liveVarCB f)\n\n```\n\n----------------------------------------\n\nTITLE: Declaring Get File Mappings Callback Typedef in C\nDESCRIPTION: Provides a callback typedef for returning file-backed memory mappings only; that is, modules mapped from disk files. Receives CPUState, OsiProc, and a double-pointer to a GArray output of OsiModule elements. In some OSI implementations, file mappings may be a direct subset of general mappings.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_12\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_get_file_mappings_t)(CPUState *, OsiProc *, GArray**)\n```\n\n----------------------------------------\n\nTITLE: Connecting a PCI device to a PCI-PCI Bridge in QEMU\nDESCRIPTION: Command sequence for connecting a legacy PCI device through the PCI hierarchy. This involves creating a DMI-PCI bridge connected to the root complex, attaching a PCI-PCI bridge to it, and finally connecting the PCI device to the PCI-PCI bridge.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/pcie.txt#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n-device i82801b11-bridge,id=dmi_pci_bridge1[,bus=pcie.0]                        \\\n-device pci-bridge,id=pci_bridge1,bus=dmi_pci_bridge1[,chassis_nr=x][,addr=y]   \\\n-device <dev>,bus=pci_bridge1[,addr=x]\n```\n\n----------------------------------------\n\nTITLE: Initializing Panda Testing with Python Script\nDESCRIPTION: This snippet outlines the command for initializing the Panda regression testing environment via the Python script. It clears the configured PANDA_REGRESSION_DIR, downloads required disk images (qcows), and runs setup scripts for all enabled tests specified in the config file. Ensure the PANDA_REGRESSION_DIR environment variable is set before executing the command, and that dependencies such as Python and any external download tools are available. Expected input is the explicit 'init' command; expected output is a fully initialized testing workspace.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/testing/README.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nptest.py init         # initializes testing - clears PANDA_REGRESSION_DIR, downloads some qcows, runs setup scripts for all enabled tests\n```\n\n----------------------------------------\n\nTITLE: Checking Out Specific PANDA Revision - Git - Bash\nDESCRIPTION: This command checks out a particular revision (commit hash 46bf2ea) of the PANDA repository, ensuring reproducibility of the analysis environment. Requires that the working directory is inside the previously cloned PANDA repository. There are no inputs beyond the commit hash; output is the repository in a detached HEAD state.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/UAF.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout 46bf2ea\n```\n\n----------------------------------------\n\nTITLE: Physical Memory Write Callback Signature\nDESCRIPTION: Callback function signature for handling physical memory writes. Requires panda_enable_memcb() to be called first.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_45\n\nLANGUAGE: C\nCODE:\n```\nvoid (*phys_mem_after_write)(CPUState *env, target_ulong pc, target_ulong addr, target_ulong size, void *buf);\n```\n\n----------------------------------------\n\nTITLE: Flow Table ID 10: VLAN Table Structure - Technical Table - plaintext\nDESCRIPTION: Documents the TLV fields, widths, and meanings for the VLAN flow table in OF-DPA, supporting VLAN matching and modification. Used in flow ADD/MOD commands with tableID=10. Key fields: match on port/VLAN, masking, goto/modify actions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/rocker.txt#_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\nfield\\t\\t\\t\\twidth\\tdescription\\n----------------------------------------------------\\nOF_DPA_IN_PPORT\\t\\t4\\tingress physical port number\\nOF_DPA_VLAN_ID\\t\\t2 (N)\\tvlan ID\\nOF_DPA_VLAN_ID_MASK\\t2 (N)\\tvlan ID mask\\nOF_DPA_GOTO_TBL\\t\\t2\\tgoto table ID; zero to drop\\nOF_DPA_NEW_VLAN_ID\\t2 (N)\\tnew vlan ID\n```\n\n----------------------------------------\n\nTITLE: Generating Synthetic Memory Workload for Migration Testing - C\nDESCRIPTION: This C code provides a simple synthetic workload generator for testing XBZRLE performance during live VM migration. It continuously allocates a large memory buffer (16 MB) and repeatedly increments selected bytes in a strided pattern to simulate intensive memory writes. The included print statement allows for basic progress monitoring. The code requires a C compiler (e.g., gcc), standard libraries (stdlib.h, stdio.h), and sufficient memory. Input parameters are fixed; the output is an ongoing sequence of dots to stdout. The code should be run as a standalone program in a suitable environment supporting dynamic memory allocation; improper system resources may cause allocation failures.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/xbzrle.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#include <stdlib.h>\\n#include <stdio.h>\\nint main()\\n{\\n    char *buf = (char *) calloc(4096, 4096);\\n    while (1) {\\n        int i;\\n        for (i = 0; i < 4096 * 4; i++) {\\n            buf[i * 4096 / 4]++;\\n        }\\n        printf(\".\");\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API Process Creation Functions in C\nDESCRIPTION: Function declarations for Windows NT native API calls related to process and thread creation, manipulation, and termination. These functions include creating processes, threads, managing process jobs, and thread suspension states.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp0_x64_prototypes.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateProcessEx (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel);\nNTSTATUS NtCreateThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended);\nNTSTATUS NtIsProcessInJob (HANDLE ProcessHandle, HANDLE JobHandle);\nNTSTATUS NtResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtTerminateThread (HANDLE ThreadHandle, NTSTATUS ExitStatus);\nNTSTATUS NtAlertResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtAlertThread (HANDLE ThreadHandle);\n```\n\n----------------------------------------\n\nTITLE: Defining Windows NT System Call Prototypes in C\nDESCRIPTION: This snippet defines multiple Windows NT system call function prototypes. These functions are low-level system calls used for various operating system operations, including file and process management, security checks, and system information retrieval.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2003sp12_x64_prototypes.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);\nNTSTATUS NtQueryVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);\n// ... (additional function prototypes)\n```\n\n----------------------------------------\n\nTITLE: Guest Hypercall Callback Signature\nDESCRIPTION: Callback function signature for handling guest hypercalls using CPUID (x86) or MCR (ARM) instructions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_46\n\nLANGUAGE: C\nCODE:\n```\nbool (*guest_hypercall)(CPUState *env);\n```\n\n----------------------------------------\n\nTITLE: Process Management System Calls in C\nDESCRIPTION: System call declarations for process management including scheduling, namespaces, and memory operations\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_arm_prototypes.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nlong sys_unshare(unsigned long unshare_flags);\nlong sys_set_robust_list(struct robust_list_head __user *head, size_t len);\nlong sys_get_robust_list(int pid, struct robust_list_head __user * __user *head_ptr, size_t __user *len_ptr);\nlong sys_move_pages(pid_t pid, unsigned long nr_pages, const void __user * __user *pages, const int __user *nodes, int __user *status, int flags);\n```\n\n----------------------------------------\n\nTITLE: Context Switching and ACL Link Operations in C\nDESCRIPTION: Function declarations for user context operations and ACL operations on symbolic links. Includes functions to get, set, and swap execution contexts, and to manage ACLs on links.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_16\n\nLANGUAGE: c\nCODE:\n```\nint getcontext(struct __ucontext *ucp);\nint setcontext(const struct __ucontext *ucp);\nint swapcontext(struct __ucontext *oucp, const struct __ucontext *ucp);\nint swapoff(const char *name);\nint __acl_get_link(const char *path, acl_type_t type, struct acl *aclp);\nint __acl_set_link(const char *path, acl_type_t type, struct acl *aclp);\nint __acl_delete_link(const char *path, acl_type_t type);\nint __acl_aclcheck_link(const char *path, acl_type_t type, struct acl *aclp);\nint sigwait(const sigset_t *set, int *sig);\nint thr_create(ucontext_t *ctx, long *id, int flags);\nvoid thr_exit(long *state);\nint thr_self(long *id);\nint thr_kill(long id, int sig);\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffer Fields for Pandalogging - Protocol Buffers\nDESCRIPTION: Defines optional fields in a Protobuf schema (asid, process_name, process_id) for use in a PANDA plugin's log entries. Each field is marked optional and assigned a tag number to ensure global uniqueness. This schema enables structured logging of process and ASID information and must be included in the plugin's build process before logging can be performed. Tag collisions between plugins must be avoided.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_23\n\nLANGUAGE: protobuf\nCODE:\n```\noptional uint64 asid = 3;\\noptional string process_name = 4;\\noptional uint32 process_id = 5;\n```\n\n----------------------------------------\n\nTITLE: Declaring a Callback for CPU Exec Enter Event - C\nDESCRIPTION: Provides the signature for after_cpu_exec_enter, a callback triggered immediately after cpu_exec calls cpu_exec_enter. It receives a pointer to CPUState, requires no return value, and allows PANDA modules to hook behaviors post CPU execution entry. This function expects a valid CPUState pointer as input and performs module-specific operations after CPU exec entry; dependencies include PANDA's CPUState definition.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_56\n\nLANGUAGE: C\nCODE:\n```\nint after_cpu_exec_enter(CPUState *env);\n```\n\n----------------------------------------\n\nTITLE: Malware Test Pattern Definition\nDESCRIPTION: Python byte sequence defining a test buffer that matches the YARA rule pattern, including PE header structure and target strings.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/examples/yara-rules/README.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nb\"\\x4D\\x5A\"\n+ b\"\\x00\" * (0x3c - 2)\n+ b\"\\x40\\x00\\x00\\x00\"\n+ b\"\\x50\\x45\\x00\\x00\"\n+ b\"Connecting to: %s:%i\\n\"\n+ b\"Connected!\"\n+ b\"Send control command C_SC_NA_1\"\n+ b\"Connect failed!\"\n+ b\"Send time sync command\"\n+ b\"Wait ...\"\n+ b\"exit 0\"\n+ b\"\\x00\" * 100\n```\n\n----------------------------------------\n\nTITLE: Splitting and Converting Tap Buffer Files Using split_taps.py (Python, Shell Usage)\nDESCRIPTION: This snippet demonstrates creating output directories and executing the split_taps.py Python script to process raw tap logs by splitting them into separate files per tap point and converting hex to binary. Prerequisites are mkdir, Python, and the split_taps.py script. Inputs are read and write tap buffer files; outputs are organized per-tap binary data files used for detailed content inspection.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/LINE_Censorship.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n$ mkdir -p taps/reads taps/writes\\n$ ../scripts/split_taps.py read_tap_buffers.txt.gz taps/reads/line\\n$ ../scripts/split_taps.py write_tap_buffers.txt.gz taps/writes/line\n```\n\n----------------------------------------\n\nTITLE: Performing Failover on Secondary VM\nDESCRIPTION: This QMP command initiates the failover process on the secondary VM when the primary VM fails. It should be executed after stopping block replication on both VMs.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/COLO-FT.txt#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{ \"execute\": \"x-colo-lost-heartbeat\" }\n```\n\n----------------------------------------\n\nTITLE: Defining NVDIMM ACPI Namespace Devices via AML (ASL) - ACPI Source Language\nDESCRIPTION: This AML (ACPI Source Language) snippet shows how a platform should define the NVDIMM root ACPI device (NVDR) and its children (NVD), including the standard device methods _HID (Device ID), _STA (Status), _FIT (Firmware Interface Table), and _DSM (Device Specific Method). This code establishes the ACPI interface for the OS and firmware to programmatically enumerate and interact with NVDIMM devices. Key parameters include NFIT device handles for child device addresses and method implementation details per ACPI 6.0. Inputs are not needed for device declarations, but correct inclusion in the platform DSDT is required.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/acpi_nvdimm.txt#_snippet_0\n\nLANGUAGE: asl\nCODE:\n```\nScope (\\_SB){\n   Device (NVDR) // Root device\n   {\n      Name (_HID, \"ACPI0012\")\n      Method (_STA) {...}\n      Method (_FIT) {...}\n      Method (_DSM, ...) {...}\n      Device (NVD)\n      {\n         Name(_ADR, h) //where h is NFIT Device Handle for this NVDIMM\n         Method (_DSM, ...) {...}\n      }\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Windows NT Native API Function Declarations for System Operations in C\nDESCRIPTION: A comprehensive list of function declarations for low-level Windows NT Native API (NTAPI) system calls. These functions provide direct access to Windows kernel functionality for operations such as memory protection, file manipulation, process management, registry access, and system information queries.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2003sp0_x86_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtProtectVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, WIN32_PROTECTION_MASK NewProtectWin32, PULONG OldProtect);\nNTSTATUS NtPulseEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtQueryAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);\nNTSTATUS NtQueryBootEntryOrder (PULONG Ids, PULONG Count);\nNTSTATUS NtQueryBootOptions (PBOOT_OPTIONS BootOptions, PULONG BootOptionsLength);\nNTSTATUS NtQueryDebugFilterState (ULONG ComponentId, ULONG Level);\nNTSTATUS NtQueryDefaultLocale (BOOLEAN UserProfile, PLCID DefaultLocaleId);\nNTSTATUS NtQueryDefaultUILanguage (LANGID *DefaultUILanguageId);\nNTSTATUS NtQueryDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);\nNTSTATUS NtQueryDirectoryObject (HANDLE DirectoryHandle, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, BOOLEAN RestartScan, PULONG Context, PULONG ReturnLength);\nNTSTATUS NtQueryDriverEntryOrder (PULONG Ids, PULONG Count);\nNTSTATUS NtQueryEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan);\nNTSTATUS NtQueryEvent (HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryFullAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);\nNTSTATUS NtQueryInformationAtom (RTL_ATOM Atom, ATOM_INFORMATION_CLASS InformationClass, PVOID AtomInformation, ULONG AtomInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\nNTSTATUS NtQueryInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationPort (HANDLE PortHandle, PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtQueryInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInstallUILanguage (LANGID *InstallUILanguageId);\nNTSTATUS NtQueryIntervalProfile (KPROFILE_SOURCE ProfileSource, PULONG Interval);\nNTSTATUS NtQueryIoCompletion (HANDLE IoCompletionHandle, IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass, PVOID IoCompletionInformation, ULONG IoCompletionInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryKey (HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtQueryMultipleValueKey (HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength);\nNTSTATUS NtQueryMutant (HANDLE MutantHandle, MUTANT_INFORMATION_CLASS MutantInformationClass, PVOID MutantInformation, ULONG MutantInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryOpenSubKeys (POBJECT_ATTRIBUTES TargetKey, PULONG HandleCount);\nNTSTATUS NtQueryOpenSubKeysEx (POBJECT_ATTRIBUTES TargetKey, ULONG BufferLength, PVOID Buffer, PULONG RequiredSize);\nNTSTATUS NtQueryPerformanceCounter (PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);\nNTSTATUS NtQueryQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID SidList, ULONG SidListLength, PULONG StartSid, BOOLEAN RestartScan);\nNTSTATUS NtQuerySection (HANDLE SectionHandle, SECTION_INFORMATION_CLASS SectionInformationClass, PVOID SectionInformation, SIZE_T SectionInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtQuerySecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Length, PULONG LengthNeeded);\nNTSTATUS NtQuerySemaphore (HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG SemaphoreInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySymbolicLinkObject (HANDLE LinkHandle, PUNICODE_STRING LinkTarget, PULONG ReturnedLength);\nNTSTATUS NtQuerySystemEnvironmentValue (PUNICODE_STRING VariableName, PWSTR VariableValue, USHORT ValueLength, PUSHORT ReturnLength);\nNTSTATUS NtQuerySystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, PULONG ValueLength, PULONG Attributes);\nNTSTATUS NtQuerySystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySystemTime (PLARGE_INTEGER SystemTime);\nNTSTATUS NtQueryTimer (HANDLE TimerHandle, TIMER_INFORMATION_CLASS TimerInformationClass, PVOID TimerInformation, ULONG TimerInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryTimerResolution (PULONG MaximumTime, PULONG MinimumTime, PULONG CurrentTime);\nNTSTATUS NtQueryValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtQueryVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtQueryVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtQueueApcThread (HANDLE ThreadHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\nNTSTATUS NtRaiseException (PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ContextRecord, BOOLEAN FirstChance);\nNTSTATUS NtRaiseHardError (NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask, PULONG_PTR Parameters, ULONG ValidResponseOptions, PULONG Response);\nNTSTATUS NtReadFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtReadFileScatter (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtReadRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtReadVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtRegisterThreadTerminatePort (HANDLE PortHandle);\nNTSTATUS NtReleaseMutant (HANDLE MutantHandle, PLONG PreviousCount);\nNTSTATUS NtReleaseSemaphore (HANDLE SemaphoreHandle, LONG ReleaseCount, PLONG PreviousCount);\nNTSTATUS NtRemoveIoCompletion (HANDLE IoCompletionHandle, PVOID *KeyContext, PVOID *ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER Timeout);\nNTSTATUS NtRemoveProcessDebug (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtRenameKey (HANDLE KeyHandle, PUNICODE_STRING NewName);\nNTSTATUS NtReplaceKey (POBJECT_ATTRIBUTES NewFile, HANDLE TargetHandle, POBJECT_ATTRIBUTES OldFile);\nNTSTATUS NtReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtReplyWaitReceivePort (HANDLE PortHandle, PVOID *PortContext , PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage);\nNTSTATUS NtReplyWaitReceivePortEx (HANDLE PortHandle, PVOID *PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage, PLARGE_INTEGER Timeout);\nNTSTATUS NtReplyWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtRequestPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage);\nNTSTATUS NtRequestWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtResetEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtResetWriteWatch (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T RegionSize);\nNTSTATUS NtRestoreKey (HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags);\nNTSTATUS NtResumeProcess (HANDLE ProcessHandle);\nNTSTATUS NtResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtSaveKey (HANDLE KeyHandle, HANDLE FileHandle);\nNTSTATUS NtSaveKeyEx (HANDLE KeyHandle, HANDLE FileHandle, ULONG Format);\nNTSTATUS NtSaveMergedKeys (HANDLE HighPrecedenceKeyHandle, HANDLE LowPrecedenceKeyHandle, HANDLE FileHandle);\nNTSTATUS NtSecureConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PSID RequiredServerSid, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\n```\n\n----------------------------------------\n\nTITLE: Installing Scapy for Network Packet Analysis\nDESCRIPTION: Commands to install the community-supported version of Scapy, a Python library for network packet manipulation and analysis.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/panda_ssltut.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ hg clone https://bitbucket.org/secdev/scapy-com\n$ cd scapy-com\n$ sudo python setup.py install\n```\n\n----------------------------------------\n\nTITLE: Hotplugging a vNVDIMM Device via QEMU Monitor Commands (Shell)\nDESCRIPTION: This snippet shows two QEMU monitor commands (object_add and device_add) for dynamically hotplugging a 4GB vNVDIMM device into a running VM. Requires QEMU v2.8.0 or later. The memory-backend-file 'object_add' creates a shared backend file for storage, while 'device_add' attaches the virtual NVDIMM device with the specified memory backend. Ensure enough memory slots and maximum memory are configured; otherwise, hotplug operations will fail.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/nvdimm.txt#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n(qemu) object_add memory-backend-file,id=mem2,share=on,mem-path=new_nvdimm.img,size=4G\n(qemu) device_add nvdimm,id=nvdimm2,memdev=mem2\n```\n\n----------------------------------------\n\nTITLE: Setting Up Python Virtual Environment and Installing Dependencies - Bash\nDESCRIPTION: This snippet demonstrates initializing a Python 3 virtual environment, activating it, and installing required packages from a requirements file. Dependencies include those listed in requirements2.txt, which must exist in the current directory. These commands should be run in a POSIX-compliant shell, and the resulting environment will be ready for executing further automation scripts requiring these dependencies.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/scripts/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npython3 -m venv venv\n. venv/bin/activate\n\npip install -r requirements2.txt\n```\n\n----------------------------------------\n\nTITLE: ARM-Specific System Calls in C\nDESCRIPTION: ARM architecture specific system calls for cache management, breakpoints, and thread local storage operations\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_arm_prototypes.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nlong ARM_breakpoint(void);\nlong ARM_cacheflush(unsigned long start, unsigned long end, unsigned long flags);\nlong ARM_user26_mode(void);\nlong ARM_usr32_mode(void);\nlong ARM_set_tls(unsigned long arg);\n```\n\n----------------------------------------\n\nTITLE: Plugging a device as Root Complex Integrated Endpoint in QEMU\nDESCRIPTION: Command syntax for connecting a device directly to the pcie.0 bus as a Root Complex Integrated Endpoint. This approach should only be used for legacy PCI devices, which will be treated as non-hot-pluggable integrated components.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/pcie.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n-device <dev>[,bus=pcie.0]\n```\n\n----------------------------------------\n\nTITLE: Assigning IGD device using vfio-pci on QEMU - Shell\nDESCRIPTION: This command configures a QEMU virtual machine to use an Intel Graphics Device (IGD) by assigning it through vfio-pci. The device is specified by its host PCI address (e.g., host=00:02.0) and VM bus/address (e.g., addr=0x2). To use legacy mode, all other graphics options should be omitted and appropriate flags (-nographic, -vga none or -nodefaults) included. This requires a compatible Linux kernel (>=4.6), vfio-pci drivers, and possibly additional VM firmware options as detailed above.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/igd-assign.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n-device vfio-pci,host=00:02.0,id=hostdev0,bus=pci.0,addr=0x2\n```\n\n----------------------------------------\n\nTITLE: Searching for String Offsets in Binary Tap Files Using grep (Shell)\nDESCRIPTION: This command finds byte offsets for occurrences of a specific ASCII string ('GCD') in a processed binary tap file using grep's byte and output-only options. It allows the analyst to locate the appearance of censored keywords within large datasets. Input is a search string and a binary data file; output is the byte offsets and matches. It depends on grep compiled with -a flag support and access to the processed .dat files.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/LINE_Censorship.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n$ grep -a -b -o GCD taps/writes/line.40796784.40038688.28210000.dat\\n64587:GCD\\n80715:GCD\n```\n\n----------------------------------------\n\nTITLE: Defining RTAS Hotplug/Unplug Event Structure in QEMU (C)\nDESCRIPTION: This C struct definition describes the binary format of RTAS event logs for hotplug/unplug actions, as implemented in QEMU for pseries guests. It uses packed structures, unions for variant identifiers, and preprocessor conditionals (e.g., #ifdef GUEST_SUPPORTS_MODERN) to distinguish between legacy and modern event formats. Key parameters include section headers, resource type, action, identifier type, and resource specifier (index, count, or name). All values are big-endian. Expected input is memory filled according to this structure; output consumers extract fields to interpret guest/host notifications, with constraints based on guest support flags. Dependencies include QEMU's QEMU_PACKED macro and the system RTAS interface.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/ppc-spapr-hotplug.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nstruct rtas_event_log_v6_hp {\n#define SECTION_ID_HOTPLUG              0x4850 /* HP */\n    struct section_header {\n        uint16_t section_id;            /* set to SECTION_ID_HOTPLUG */\n        uint16_t section_length;        /* sizeof(rtas_event_log_v6_hp),\n                                         * plus the length of the DRC name\n                                         * if a DRC name identifier is\n                                         * specified for hotplug_identifier\n                                         */\n        uint8_t section_version;        /* version 1 */\n        uint8_t section_subtype;        /* unused */\n        uint16_t creator_component_id;  /* unused */\n    } hdr;\n#define RTAS_LOG_V6_HP_TYPE_CPU         1\n#define RTAS_LOG_V6_HP_TYPE_MEMORY      2\n#define RTAS_LOG_V6_HP_TYPE_SLOT        3\n#define RTAS_LOG_V6_HP_TYPE_PHB         4\n#define RTAS_LOG_V6_HP_TYPE_PCI         5\n    uint8_t hotplug_type;               /* type of resource/device */\n#define RTAS_LOG_V6_HP_ACTION_ADD       1\n#define RTAS_LOG_V6_HP_ACTION_REMOVE    2\n    uint8_t hotplug_action;             /* action (add/remove) */\n#define RTAS_LOG_V6_HP_ID_DRC_NAME          1\n#define RTAS_LOG_V6_HP_ID_DRC_INDEX         2\n#define RTAS_LOG_V6_HP_ID_DRC_COUNT         3\n#ifdef GUEST_SUPPORTS_MODERN\n#define RTAS_LOG_V6_HP_ID_DRC_COUNT_INDEXED 4\n#endif\n    uint8_t hotplug_identifier;         /* type of the resource identifier,\n                                         * which serves as the discriminator\n                                         * for the 'drc' union field below\n                                         */\n#ifdef GUEST_SUPPORTS_MODERN\n    uint8_t capabilities;               /* capability flags, currently unused\n                                         * by QEMU\n                                         */\n#else\n    uint8_t reserved;\n#endif\n    union {\n        uint32_t index;                 /* DRC index of resource to take action\n                                         * on\n                                         */\n        uint32_t count;                 /* number of DR resources to take\n                                         * action on (guest chooses which)\n                                         */\n#ifdef GUEST_SUPPORTS_MODERN\n        struct {\n            uint32_t count;             /* number of DR resources to take\n                                         * action on\n                                         */\n            uint32_t index;             /* DRC index of first resource to take\n                                         * action on. guest will take action\n                                         * on DRC index <index> through\n                                         * DRC index <index + count - 1> in\n                                         * sequential order\n                                         */\n        } count_indexed;\n#endif\n        char name[1];                   /* string representing the name of the\n                                         * DRC to take action on\n                                         */\n    } drc;\n} QEMU_PACKED;\n```\n\n----------------------------------------\n\nTITLE: Splitting Tap Point Log Files with split_taps.py - Python\nDESCRIPTION: Shows the command-line usage and help output of the split_taps.py script, which is used to separate aggregate tap point logs (read_tap_buffers.txt.gz, write_tap_buffers.txt.gz) into files per tap point. The script takes as input a log file and a desired prefix for output files, with optional parameters for call context depth. Input files may be gzipped, and the script requires Python 3 along with any dependencies specified by the PANDA project. Outputs are raw data per tap point for further analysis.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/textprinter/README.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nusage: split_taps.py [-h] [-c CALLERS] logfile prefix\n\nSplit a logfile containing tap point data into its constitutent taps.\n\npositional arguments:\n  logfile               log file containing tap point data (can be gzipped)\n  prefix                prefix for output files\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -c CALLERS, --callers CALLERS\n                        levels of calling context to use when splitting\n```\n\n----------------------------------------\n\nTITLE: Explicit SCSI Controller and Device Attachment (QEMU CLI, Shell)\nDESCRIPTION: Outlines the modern two-step approach for adding a SCSI controller and then attaching a SCSI block device to its bus and SCSI ID, using QEMU's -device flag. DEVNAME can be scsi-hd, scsi-cd, or scsi-generic. You first create the controller, then attach the device, controlling PCI address if needed. Requires QEMU. Output is correct SCSI topology in virtual machine.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n-device lsi53c895a,id=ID\n-device DEVNAME,drive=DRIVE-ID,bus=ID.0,scsi-id=UNIT\n```\n\n----------------------------------------\n\nTITLE: Declaring Get Process Memory Callback Typedef in C\nDESCRIPTION: Defines a typedef for a callback that returns memory details for a specific process, currently only implemented for osi_linux. The output is a pointer to OsiProcMem, and due to implementation, multiple calls overwrite a static memory region. Plugins must not rely on persistent output across invocations. Input parameters include CPUState and an OsiProc pointer.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_get_proc_mem_t)(CPUState *, OsiProc *, OsiProcMem **)\n```\n\n----------------------------------------\n\nTITLE: Recording I/O Buffer to Port Transfer\nDESCRIPTION: Code from ide_data_readw that records transfers from I/O buffer to port, creating replay log entries for these operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/hd_taint.txt#_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nrr_record_hd_transfer\n  (RR_CALLSITE_IDE_DATA_READW,\n   HD_TRANSFER_IOB_TO_PORT,\n   (uint64_t) s->data_ptr, 2);\n```\n\n----------------------------------------\n\nTITLE: Flow Table ID 50: Bridging Table Structure - Technical Table - plaintext\nDESCRIPTION: Specifies the TLV list and their meanings for the OF-DPA bridging table (tableID=50), covering MAC/VLAN/tunnel match, output group info, and forwarding control. Designed for OpenFlow and hardware agents handling bridging (Layer2) operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/rocker.txt#_snippet_15\n\nLANGUAGE: plaintext\nCODE:\n```\nfield\\t\\t\\t\\twidth\\tdescription\\n----------------------------------------------------\\nOF_DPA_VLAN_ID\\t\\t2 (N)\\tvlan ID\\nOF_DPA_TUNNEL_ID\\t\\t4\\ttunnel ID\\nOF_DPA_DST_MAC\\t\\t6 (N)\\tdestination MAC\\nOF_DPA_DST_MAC_MASK\\t6 (N)\\tdestination MAC mask\\nOF_DPA_GOTO_TBL\\t\\t2\\tgoto table ID; zero to drop\\nOF_DPA_GROUP_ID\\t\\t4\\tdata for GROUP action must\\n\\t\\t\\t\\tbe a L2 Interface, L2\\n\\t\\t\\t\\tMulticast, L2 Flood,\\n\\t\\t\\t\\tor L2 Overlay group entry\\n\\t\\t\\t\\tas appropriate\\nOF_DPA_TUNNEL_LPORT\\t4\\tunicast Tenant Bridging\\n\\t\\t\\t\\tflows specify a tunnel\\n\\t\\t\\t\\tlogical port ID\\nOF_DPA_OUT_PPORT\\t\\t2\\tdata for OUTPUT action,\\n\\t\\t\\t\\trestricted to CONTROLLER,\\n\\t\\t\\t\\tset to 0 otherwise\n```\n\n----------------------------------------\n\nTITLE: Passing Through USB Devices Based on Host Topology - Bash/QEMU CLI\nDESCRIPTION: Details a full QEMU command-line example for passing through physical USB devices using host bus and port addresses. It specifies both UHCI and EHCI controller provisioning and maps specific host ports to virtual USB buses. Dependencies include QEMU compiled with usb-host support and knowledge of host device topology. Inputs include bus and port numbers; outputs are VM with USB devices mapped from host ports.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/usb2.txt#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nqemu -M pc ${otheroptions}                               \\\n    -usb                                                 \\\n    -device usb-ehci,id=ehci                             \\\n    -device usb-host,bus=usb-bus.0,hostbus=3,hostport=1  \\\n    -device usb-host,bus=ehci.0,hostbus=1,hostport=1\n```\n\n----------------------------------------\n\nTITLE: Recording Port to I/O Buffer Transfer\nDESCRIPTION: Code from ide_data_writew that records transfers from port to I/O buffer, creating replay log entries with appropriate parameters.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/hd_taint.txt#_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nrr_record_hd_transfer\n  (RR_CALLSITE_IDE_DATA_WRITEW,\n   HD_TRANSFER_PORT_TO_IOB,\n   (uint64_t) s->data_ptr, 2);\n```\n\n----------------------------------------\n\nTITLE: Symbol Resolution Function in C\nDESCRIPTION: Core function that resolves symbols within a specific Address Space ID (ASID). Takes CPU state, ASID, section name (substring match), and exact symbol name as parameters.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/dynamic_symbols/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nstruct symbol resolve_symbol(CPUState* cpu, target_ulong asid, char* section_name, char* symbol);\n```\n\n----------------------------------------\n\nTITLE: Configuring Audio Device Replay in PANDA\nDESCRIPTION: Example command line configuration for audio hardware specification, showing how to enable ac97 sound hardware for recording and replay.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/replay.txt#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n-soundhw ac97\n```\n\n----------------------------------------\n\nTITLE: Declaring Callback Registration APIs for pri Providers - C\nDESCRIPTION: This code snippet offers C API functions for pri provider plugins to invoke user-registered callbacks upon key introspection events (like line changes or function start). These functions allow provider plugins to signal the PANDA environment by invoking pre-registered callbacks, passing detailed execution state. Dependencies include PANDA and pri plugin callback registration. Key parameters include processor state, address, filenames, function names, and line numbers. Input events are managed by the provider plugin; output is via callback invocation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/pri/README.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n// run a line change callback\nvoid pri_runcb_on_before_line_change(CPUState *env, target_ulong pc, const char *file_name, const char *funct_name, unsigned long long lno);\nvoid pri_runcb_on_after_line_change(CPUState *env, target_ulong pc, const char *file_name, const char *funct_name, unsigned long long lno);\n// run a callback signaling the beginning of a function AFTER the function prologue\nvoid pri_runcb_on_fn_start(CPUState *env, target_ulong pc, const char *file_name, const char *funct_name);\n\n```\n\n----------------------------------------\n\nTITLE: Defining Callback Structure Namedtuple in PyPANDA (Python)\nDESCRIPTION: This snippet shows how to define the PandaCB namedtuple that enumerates all available callback types in PyPANDA. Modifying this structure allows adding new callbacks, which must match the corresponding union definition in C. Each callback is listed as a field, with lines ending in '\\' for multi-line readability.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/docs/extending_pypanda.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nPandaCB = namedtuple(\"PandaCB\", \"init \\\nbefore_block_exec_invalidate_opt \\\n...\n...\nafter_machine_init \\\ntop_loop\");\n```\n\n----------------------------------------\n\nTITLE: Mapping Legacy Serial and Parallel Ports via -device (QEMU CLI, Shell)\nDESCRIPTION: Offers detailed CLI options for configuring guest ISA serial or parallel ports, specifying I/O base, IRQ, and port index for each device. Indispensable for advanced serial or parallel port setup in QEMU. Requires QEMU. Inputs are IOADDR, IRQ, IDX; output is port at chosen address/IRQ.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n-device isa-serial,iobase=IOADDR,irq=IRQ,index=IDX\n-device isa-parallel,iobase=IOADDR,irq=IRQ,index=IDX\n```\n\n----------------------------------------\n\nTITLE: Declaring After Instruction Execution Callback Signature in PANDA (C)\nDESCRIPTION: Declares a function pointer for post-instruction execution hooks, triggered only for instructions selected via the dedicated after_insn_translate logic. Receives the CPU state and guest PC; return value is an integer (unused). The callback is costly and thus selectively enabled by the plugin's translate decision.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_37\n\nLANGUAGE: C\nCODE:\n```\nint (*after_insn_exec)(CPUState *env, target_ulong pc);\n```\n\n----------------------------------------\n\nTITLE: Declaring Process and Thread Management System Calls in C for FreeBSD\nDESCRIPTION: This snippet declares system calls related to process and thread management in FreeBSD, including process forking, thread killing, and CPU set operations for affinity control.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_22\n\nLANGUAGE: C\nCODE:\n```\nint thr_kill2(pid_t pid, long id, int sig);\nint cpuset(cpusetid_t *setid);\nint cpuset_setid(cpuwhich_t which, id_t id, cpusetid_t setid);\nint cpuset_getid(cpulevel_t level, cpuwhich_t which, id_t id, cpusetid_t *setid);\nint cpuset_getaffinity(cpulevel_t level, cpuwhich_t which, id_t id, size_t cpusetsize, cpuset_t *mask);\nint cpuset_setaffinity(cpulevel_t level, cpuwhich_t which, id_t id, size_t cpusetsize, const cpuset_t *mask);\n```\n\n----------------------------------------\n\nTITLE: Stopping Block Replication on Primary VM\nDESCRIPTION: These QMP commands remove the NBD client from the quorum and delete the replication drive on the primary VM. This is necessary before initiating failover on the secondary VM.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/COLO-FT.txt#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{ 'execute': 'x-blockdev-change', 'arguments': {'parent': 'colo-disk0', 'child': 'children.1'}}\n{ 'execute': 'human-monitor-command','arguments': {'command-line': 'drive_del blk-buddy0'}}\n```\n\n----------------------------------------\n\nTITLE: Allocating Memory and Invoking a Trace Event in QEMU C Source\nDESCRIPTION: This C function demonstrates how to invoke a trace event after memory allocation. It allocates memory with the proper alignment using 'qemu_memalign', adjusts alignment with 'getpagesize' if needed, and then calls 'trace_qemu_vmalloc' to log the allocation. Prerequisites include an included 'trace.h' and functions such as 'qemu_memalign', 'trace_qemu_vmalloc', and 'getpagesize'. Inputs: size (the amount of memory to allocate). Outputs: pointer to the allocated memory, also produces a trace event if tracing is enabled.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/tracing.txt#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n#include \"trace.h\"  /* needed for trace event prototype */\n\nvoid *qemu_vmalloc(size_t size)\n{\n    void *ptr;\n    size_t align = QEMU_VMALLOC_ALIGN;\n \n    if (size < align) {\n        align = getpagesize();\n    }\n    ptr = qemu_memalign(align, size);\n    trace_qemu_vmalloc(size, ptr);\n    return ptr;\n}\n```\n\n----------------------------------------\n\nTITLE: Simple 'stop' Command Execution Example in QMP\nDESCRIPTION: Shows an example of executing the 'stop' command in QMP and receiving a success response.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qmp-spec.txt#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{ \"execute\": \"stop\" }\n```\n\nLANGUAGE: json\nCODE:\n```\n{ \"return\": {} }\n```\n\n----------------------------------------\n\nTITLE: Writing a Log Entry using the PANDALOG C++ API with std::unique_ptr - C++\nDESCRIPTION: Illustrates how to allocate, populate, and write a log entry in a PANDA C++ plugin using std::unique_ptr for automatic cleanup. The LogEntry is constructed on the heap, multiple fields are set via protobuf-generated setters, and ownership is transferred to globalLog.write_entry. Requires 'plog.pb.h' and 'panda/src/plog-cc.cpp'.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_28\n\nLANGUAGE: C++\nCODE:\n```\nextern PandaLog globalLog;\\n...\\nif (pandalog){\\n    std::unique_ptr<panda::LogEntry> ple (new panda::LogEntry());\\n    ple->mutable_llvmentry()->set_type(FunctionCode::FUNC_CODE_INST_CALL);\\n    ple->mutable_llvmentry()->set_address(addr);\\n\\n    globalLog.write_entry(std::move(ple));\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Executing PANDA with memsavep Plugin (Instruction Count-based)\nDESCRIPTION: This command runs PANDA with the memsavep plugin, configured to dump memory when the instruction count reaches 3314667015, saving the output to 'mymem.dd'.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/memsavep/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo \\\n    -panda memsavep:instrcount=3314667015,file=mymem.dd\n```\n\n----------------------------------------\n\nTITLE: Declaring Before Physical Memory Read Callback Signature in PANDA (C)\nDESCRIPTION: Declares a function pointer for plugin hooks to inspect or intervene before a physical memory read, taking parameters for CPU state, PC, address, and size. No output result is returned. Requires explicit PANDA memory callback activation, enabling low-level physical memory instrumentation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_40\n\nLANGUAGE: C\nCODE:\n```\nvoid (*phys_mem_before_read)(CPUState *env, target_ulong pc, target_ulong addr, target_ulong size);\n```\n\n----------------------------------------\n\nTITLE: Enumerating RX Descriptor Status Return Codes - Technical Table - plaintext\nDESCRIPTION: Lists RX descriptor completion status codes and their meanings for handling RX DMA completions. Intended for error handling logic in drivers and troubleshooting buffer issues. Assumes the reader is maintaining descriptor rings and error codes for the platform.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/rocker.txt#_snippet_8\n\nLANGUAGE: plaintext\nCODE:\n```\nDESC_COMP_ERR\\treason\\n--------------------------------------------------------------------\\n0\\t\\tOK\\n-ROCKER_ENXIO\\taddress or data read err on desc buf\\n-ROCKER_ENOMEM\\tno memory for internal staging desc buf\\n-ROCKER_EMSGSIZE Rx descriptor buffer wasn't big enough to contain\\n\\t\\tpacket data TLV and other TLVs.\n```\n\n----------------------------------------\n\nTITLE: Defining Message Queue System Calls in C\nDESCRIPTION: Function declarations for Linux system calls related to POSIX message queues. These calls provide interfaces for creating, manipulating, and using message queues for inter-process communication.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_31\n\nLANGUAGE: C\nCODE:\n```\nlong sys_mq_open(const char __user *name, int oflag, umode_t mode, struct mq_attr __user *attr);\nlong sys_mq_unlink(const char __user *name);\nlong sys_mq_timedsend_time32(mqd_t mqdes, const char __user *u_msg_ptr, unsigned int msg_len, unsigned int msg_prio, const struct old_timespec32 __user *u_abs_timeout);\nlong sys_mq_timedreceive_time32(mqd_t mqdes, char __user *u_msg_ptr, unsigned int msg_len, unsigned int __user *u_msg_prio, const struct old_timespec32 __user *u_abs_timeout);\nlong sys_mq_notify(mqd_t mqdes, const struct sigevent __user *notification);\nlong sys_mq_getsetattr(mqd_t mqdes, const struct mq_attr __user *mqstat, struct mq_attr __user *omqstat);\n```\n\n----------------------------------------\n\nTITLE: Building the Plugin Release Binary - Rust - shell\nDESCRIPTION: Compiles the plugin in release mode, which enables optimizations suitable for deployment. Requires Cargo and a suitable Rust toolchain, as well as all dependencies correctly specified in Cargo.toml. Input is the source directory; the output is a release-optimized shared object (.so) placed in target/release.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/rust_skeleton/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo build --release\n```\n\n----------------------------------------\n\nTITLE: Running PANDA with the ida_taint2 Plugin - Shell\nDESCRIPTION: This shell command demonstrates how to run the PANDA framework, allocating 2GB of RAM and replaying a trace, while enabling the ida_taint2 plugin to produce taint analysis CSV output. It further illustrates chaining other plugins such as 'stringsearch' and 'tstringsearch'. The main arguments include the memory allocation (-m 2G), the replay file (-replay test), and the plugins, each invoked with relevant parameters. Input to the system consists of a recorded replay and optional arguments for plugins, resulting in CSV output suitable for subsequent analysis and visualization in IDA as described previously.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/ida_taint2/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npanda-system-i386 -m 2G -replay test \\\n    -panda stringsearch:str=\\\"hello world\\\" \\\n    -panda tstringsearch \\\n    -panda ida_taint2\n```\n\n----------------------------------------\n\nTITLE: Declaring Native API Object Creation Functions Using NTSTATUS - Windows NT, C\nDESCRIPTION: This snippet provides C function prototypes for numerous Windows Native API (NTAPI) routines, each returning an NTSTATUS and taking object-specific input parameters. The functions enable the creation and management of OS objects (sections, resources, profiles, processes, namespaces, ports, files, pipes, keys, events, jobs, etc.) as well as auxiliary operations such as commit, close, compare, and assignment. Dependencies include correct definitions for HANDLE, ACCESS_MASK, context structures, and NTSTATUS; these are only declarations (not implementations), suitable for use in headers before linking against the NT kernel or using dynamic loading. Most parameters are pointers to relevant structures, and all functions are expected to follow Windows kernel-mode calling conventions. Outputs are usually NTSTATUS codes, and no memory management is performed by these declarations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp0_x86_prototypes.txt#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);\nNTSTATUS NtCreateResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID RmGuid, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, PUNICODE_STRING Description);\nNTSTATUS NtCreateProfileEx (PHANDLE ProfileHandle, HANDLE Process, PVOID ProfileBase, SIZE_T ProfileSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, ULONG GroupAffinityCount, PGROUP_AFFINITY GroupAffinity);\nNTSTATUS NtCreateProfile (PHANDLE ProfileHandle, HANDLE Process, PVOID RangeBase, SIZE_T RangeSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);\nNTSTATUS NtCreateProcessEx (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel);\nNTSTATUS NtCreateProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort);\nNTSTATUS NtCreatePrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\nNTSTATUS NtCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtCreatePagingFile (PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority);\nNTSTATUS NtCreateNamedPipeFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout);\nNTSTATUS NtCreateMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN InitialOwner);\nNTSTATUS NtCreateMailslotFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout);\nNTSTATUS NtCreateKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, HANDLE TransactionHandle, PULONG Disposition);\nNTSTATUS NtCreateKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\nNTSTATUS NtCreateKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);\nNTSTATUS NtCreateJobSet (ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);\nNTSTATUS NtCreateJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Count);\nNTSTATUS NtCreateFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);\nNTSTATUS NtCreateEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);\nNTSTATUS NtCreateEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, HANDLE TransactionHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, NOTIFICATION_MASK NotificationMask, PVOID EnlistmentKey);\nNTSTATUS NtCreateDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateDebugObject (PHANDLE DebugObjectHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtContinue (PCONTEXT ContextRecord, BOOLEAN TestAlert);\nNTSTATUS NtConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\nNTSTATUS NtCompressKey (HANDLE Key);\nNTSTATUS NtCompleteConnectPort (HANDLE PortHandle);\nNTSTATUS NtCompareTokens (HANDLE FirstTokenHandle, HANDLE SecondTokenHandle, PBOOLEAN Equal);\nNTSTATUS NtCompactKeys (ULONG Count, HANDLE KeyArray[]);\nNTSTATUS NtCommitTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\nNTSTATUS NtCommitEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCommitComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCloseObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtClose (HANDLE Handle);\nNTSTATUS NtClearEvent (HANDLE EventHandle);\nNTSTATUS NtCancelTimer (HANDLE TimerHandle, PBOOLEAN CurrentState);\nNTSTATUS NtCancelSynchronousIoFile (HANDLE ThreadHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtCancelIoFileEx (HANDLE FileHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtCancelIoFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtCallbackReturn (PVOID OutputBuffer, ULONG OutputLength, NTSTATUS Status);\nNTSTATUS NtAssignProcessToJobObject (HANDLE JobHandle, HANDLE ProcessHandle);\nNTSTATUS NtAreMappedFilesTheSame (PVOID File1MappedAsAnImage, PVOID File2MappedAsFile);\nNTSTATUS NtApphelpCacheControl (APPHELPCOMMAND type, PVOID buf);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlpcSetInformation (HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length);\nNTSTATUS NtAlpcSendWaitReceivePort (HANDLE PortHandle, ULONG Flags, PPORT_MESSAGE SendMessage, PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes, PPORT_MESSAGE ReceiveMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes, PLARGE_INTEGER Timeout);\nNTSTATUS NtAlpcRevokeSecurityContext (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);\nNTSTATUS NtAlpcQueryInformationMessage (HANDLE PortHandle, PPORT_MESSAGE PortMessage, ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass, PVOID MessageInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtAlpcQueryInformation (HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtAlpcOpenSenderThread (PHANDLE ThreadHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtAlpcOpenSenderProcess (PHANDLE ProcessHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtAlpcImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE PortMessage, PVOID Reserved);\nNTSTATUS NtAlpcDisconnectPort (HANDLE PortHandle, ULONG Flags);\nNTSTATUS NtAlpcDeleteSecurityContext (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);\nNTSTATUS NtAlpcDeleteSectionView (HANDLE PortHandle, ULONG Flags, PVOID ViewBase);\nNTSTATUS NtAlpcDeleteResourceReserve (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ResourceId);\nNTSTATUS NtAlpcDeletePortSection (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE SectionHandle);\nNTSTATUS NtAlpcCreateSecurityContext (HANDLE PortHandle, ULONG Flags, PALPC_SECURITY_ATTR SecurityAttribute);\nNTSTATUS NtAlpcCreateSectionView (HANDLE PortHandle, ULONG Flags, PALPC_DATA_VIEW_ATTR ViewAttributes);\nNTSTATUS NtAlpcCreateResourceReserve (HANDLE PortHandle, ULONG Flags, SIZE_T MessageSize, PALPC_HANDLE ResourceId);\nNTSTATUS NtAlpcCreatePortSection (HANDLE PortHandle, ULONG Flags, HANDLE SectionHandle, SIZE_T SectionSize, PALPC_HANDLE AlpcSectionHandle, PSIZE_T ActualSectionSize);\nNTSTATUS NtAlpcCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes);\nNTSTATUS NtAlpcConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, ULONG Flags, PSID RequiredServerSid, PPORT_MESSAGE ConnectionMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes, PALPC_MESSAGE_ATTRIBUTES InMessageAttributes, PLARGE_INTEGER Timeout);\nNTSTATUS NtAlpcCancelMessage (HANDLE PortHandle, ULONG Flags, PALPC_CONTEXT_ATTR MessageContext);\nNTSTATUS NtAlpcAcceptConnectPort (PHANDLE PortHandle, HANDLE ConnectionPortHandle, ULONG Flags, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes, BOOLEAN AcceptConnection);\nNTSTATUS NtAllocateVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);\nNTSTATUS NtAllocateUuids (PULARGE_INTEGER Time, PULONG Range, PULONG Sequence, PCHAR Seed);\nNTSTATUS NtAllocateUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Syscall Prototypes in C\nDESCRIPTION: These code snippets declare function prototypes for native Windows NT syscalls in C. The prototypes provide the C signature for each syscall, defining the function name, return type (NTSTATUS), and a set of parameters matching undocumented or rarely documented system routines. These declarations require access to NT-specific data types and structure definitions (such as HANDLE, PVOID, OBJECT_ATTRIBUTES, and IO_STATUS_BLOCK). They serve as an interface for low-level code that needs to issue system calls directly, commonly used in advanced system tools, antivirus software, or custom kernel drivers. Each function expects arguments as pointers or handles, and all output and error information is communicated through status codes and out-parameter pointers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp0_x64_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWaitForSingleObject (HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCallbackReturn (PVOID OutputBuffer, ULONG OutputLength, NTSTATUS Status);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtReadFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWriteFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtRemoveIoCompletion (HANDLE IoCompletionHandle, PVOID *KeyContext, PVOID *ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtReleaseSemaphore (HANDLE SemaphoreHandle, LONG ReleaseCount, PLONG PreviousCount);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtReplyWaitReceivePort (HANDLE PortHandle, PVOID *PortContext , PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetEvent (HANDLE EventHandle, PLONG PreviousState);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtClose (HANDLE Handle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtOpenKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtEnumerateValueKey (HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtFindAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryDefaultLocale (BOOLEAN UserProfile, PLCID DefaultLocaleId);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryKey (HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAllocateVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWaitForMultipleObjects32 (ULONG Count, LONG Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWriteFileGather (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG FreeType);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE Message);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtReleaseMutant (HANDLE MutantHandle, PLONG PreviousCount);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtRequestWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage, PPORT_MESSAGE ReplyMessage);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtOpenThreadToken (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtOpenProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, WIN32_PROTECTION_MASK Win32Protect);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtUnmapViewOfSection (HANDLE ProcessHandle, PVOID BaseAddress);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtReplyWaitReceivePortEx (HANDLE PortHandle, PVOID *PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtTerminateProcess (HANDLE ProcessHandle, NTSTATUS ExitStatus);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetEventBoostPriority (HANDLE EventHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtReadFileScatter (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtOpenThreadTokenEx (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtOpenProcessTokenEx (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryPerformanceCounter (PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtEnumerateKey (HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtOpenFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDelayExecution (BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQuerySystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtOpenSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryTimer (HANDLE TimerHandle, TIMER_INFORMATION_CLASS TimerInformationClass, PVOID TimerInformation, ULONG TimerInformationLength, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtFsControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWriteVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCloseObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDuplicateObject (HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtClearEvent (HANDLE EventHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtReadVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtOpenEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAdjustPrivilegesToken (HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDuplicateToken (HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtContinue (PCONTEXT ContextRecord, BOOLEAN TestAlert);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryDefaultUILanguage (LANGID *DefaultUILanguageId);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueueApcThread (HANDLE ThreadHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtYieldExecution ();\n```\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAddAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\n```\n\n----------------------------------------\n\nTITLE: Blocking a Signal for All Processes using PANDA Plugin in C\nDESCRIPTION: This C function blocks a given UNIX signal (specified by signal number) for all processes running under PANDA's 'signal' plugin. It requires the PANDA platform and that the 'signal', 'syscalls2', and 'osi_linux' plugins are loaded. Call block_sig with the relevant signal number (e.g., 6 for SIGABRT, 11 for SIGSEGV) to suppress it globally. No return value; the effect is persistent during the analysis session.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/signal/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid block_sig(int32_t sig);\n```\n\n----------------------------------------\n\nTITLE: Declaring Native API System Function Prototypes - Windows NT - C\nDESCRIPTION: Declares a series of function prototypes for Windows NT native system calls. Each prototype exposes privileged functionality, such as process/thread control, system shutdown, registry operations, and debugging. Types like PUNICODE_STRING, HANDLE, and NTSTATUS, as well as custom enums and structures, must be defined elsewhere, typically in standard Windows or DDK headers. Each function call expects specific parameter types and semantics, returning an NTSTATUS for operation outcome. These declarations are not implementations and should be used for interfacing with system internals or in kernel-mode development.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp0_x64_prototypes.txt#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetSystemEnvironmentValue (PUNICODE_STRING VariableName, PUNICODE_STRING VariableValue);\nNTSTATUS NtSetSystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, ULONG ValueLength, ULONG Attributes);\nNTSTATUS NtSetSystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);\nNTSTATUS NtSetSystemPowerState (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags);\nNTSTATUS NtSetSystemTime (PLARGE_INTEGER SystemTime, PLARGE_INTEGER PreviousTime);\nNTSTATUS NtSetThreadExecutionState (EXECUTION_STATE esFlags, PEXECUTION_STATE PreviousFlags);\nNTSTATUS NtSetTimerEx (HANDLE TimerHandle, TIMER_SET_INFORMATION_CLASS TimerSetInformationClass, PVOID TimerSetInformation, ULONG TimerSetInformationLength);\nNTSTATUS NtSetTimerResolution (ULONG DesiredTime, BOOLEAN SetResolution, PULONG ActualTime);\nNTSTATUS NtSetUuidSeed (PCHAR Seed);\nNTSTATUS NtSetVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtShutdownSystem (SHUTDOWN_ACTION Action);\nNTSTATUS NtShutdownWorkerFactory (HANDLE WorkerFactoryHandle, LONG *PendingWorkerCount);\nNTSTATUS NtSignalAndWaitForSingleObject (HANDLE SignalHandle, HANDLE WaitHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtSinglePhaseReject (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtStartProfile (HANDLE ProfileHandle);\nNTSTATUS NtStopProfile (HANDLE ProfileHandle);\nNTSTATUS NtSuspendProcess (HANDLE ProcessHandle);\nNTSTATUS NtSuspendThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtSystemDebugControl (SYSDBG_COMMAND Command, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, PULONG ReturnLength);\nNTSTATUS NtTerminateJobObject (HANDLE JobHandle, NTSTATUS ExitStatus);\nNTSTATUS NtTestAlert ();\nNTSTATUS NtThawRegistry ();\nNTSTATUS NtThawTransactions ();\nNTSTATUS NtTraceControl (ULONG FunctionCode, PVOID InBuffer, ULONG InBufferLen, PVOID OutBuffer, ULONG OutBufferLen, PULONG ReturnLength);\nNTSTATUS NtTranslateFilePath (PFILE_PATH InputFilePath, ULONG OutputType, PFILE_PATH OutputFilePath, PULONG OutputFilePathLength);\nNTSTATUS NtUmsThreadYield (PVOID SchedulerParam);\nNTSTATUS NtUnloadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtUnloadKey (POBJECT_ATTRIBUTES TargetKey);\nNTSTATUS NtUnloadKey2 (POBJECT_ATTRIBUTES TargetKey, ULONG Flags);\nNTSTATUS NtUnloadKeyEx (POBJECT_ATTRIBUTES TargetKey, HANDLE Event);\nNTSTATUS NtUnlockFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key);\nNTSTATUS NtUnlockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtVdmControl (VDMSERVICECLASS Service, PVOID ServiceData);\nNTSTATUS NtWaitForDebugEvent (HANDLE DebugObjectHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PDBGUI_WAIT_STATE_CHANGE WaitStateChange);\nNTSTATUS NtWaitForKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitForWorkViaWorkerFactory (HANDLE WorkerFactoryHandle, PFILE_IO_COMPLETION_INFORMATION MiniPacket);\nNTSTATUS NtWaitHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtWaitLowEventPair (HANDLE EventPairHandle);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API Memory Management Functions in C\nDESCRIPTION: Function declarations for Windows NT native API calls related to memory management including virtual memory protection, section creation, and physical memory allocation. These functions provide control over memory resources in the system.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp0_x64_prototypes.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);\nNTSTATUS NtProtectVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, WIN32_PROTECTION_MASK NewProtectWin32, PULONG OldProtect);\nNTSTATUS NtQuerySection (HANDLE SectionHandle, SECTION_INFORMATION_CLASS SectionInformationClass, PVOID SectionInformation, SIZE_T SectionInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtAllocateUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n```\n\n----------------------------------------\n\nTITLE: Defining Device Event Formats - Markdown\nDESCRIPTION: This snippet describes TLV-based event structures for asynchronous device events using Markdown tables. It lists event types, followed by specific nested field definitions for both link changes and MAC/VLAN notifications. This aids driver writers in parsing and responding to hardware events; understanding of TLV and network events is needed. Expected input is device event data, output is a decoded structure for software event handling.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/rocker.txt#_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n    field       width   description\n    ---------------------------------------------------\n    TYPE        4   Event type, one of:\n                1: LINK_CHANGED\n                2: MAC_VLAN_SEEN\n    INFO        <nest>  Event info (details below)\n\n    INFO        <nest>\n      PPORT     4   Physical port\n      LINKUP    1   Link status:\n                    0: down\n                    1: up\n\n    INFO        <nest>\n      PPORT     4   Physical port\n      MAC       6   MAC address\n      VLAN      2   VLAN ID\n\n```\n\n----------------------------------------\n\nTITLE: Defining Process Management System Calls in C\nDESCRIPTION: Function declarations for Linux system calls related to process management including signal handling, scheduling, and process termination. These functions facilitate inter-process communication and process resource management.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_27\n\nLANGUAGE: C\nCODE:\n```\nlong sys_tkill(pid_t pid, int sig);\nlong sys_ni_syscall(void);\nlong sys_futex_time32(u32 __user *uaddr, int op, u32 val, struct old_timespec32 __user *utime, u32 __user *uaddr2, u32 val3);\nlong sys_sched_setaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\nlong sys_sched_getaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\nlong sys_exit_group(int error_code);\nlong sys_set_tid_address(int __user *tidptr);\nlong sys_restart_syscall(void);\nlong sys_tgkill(pid_t tgid, pid_t pid, int sig);\nlong sys_waitid(int which, pid_t pid, struct siginfo __user *infop, int options, struct rusage __user *ru);\n```\n\n----------------------------------------\n\nTITLE: QAPI Command Expression Documentation Block for Querying Structs - Python\nDESCRIPTION: Documents and defines a QAPI command for querying statistics across all block devices, with an illustrative example and versioning information. The documentation block precedes a Python dictionary expressing the command definition, with 'Returns' detailing the output type. Proper formatting of both the documentation and dictionary structures is essential to ensure compatibility with the QAPI parser and documentation generator.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n##\n# @query-blockstats:\n#\n# Query the @BlockStats for all virtual block devices.\n#\n# @query-nodes: If true, the command will query all the\n#               block nodes ... explain, explain ...  (since 2.3)\n#\n# Returns: A list of @BlockStats for each virtual block devices.\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"query-blockstats\" }\n# <- {\n#      ... lots of output ...\n#    }\n#\n##\n```\n\n----------------------------------------\n\nTITLE: Retrieving Plugin Handle by Name in PANDA using C\nDESCRIPTION: Provides a function that returns the handle to a loaded plugin given its base filename. This handle is required when linking plugins or invoking symbols from another plugin using APIs like dlsym. The function expects the plugin name as a string and returns a void pointer. No additional dependencies beyond PANDA core.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_14\n\nLANGUAGE: C\nCODE:\n```\nvoid * panda_get_plugin_by_name(const char *name);\n```\n\n----------------------------------------\n\nTITLE: Memory Management System Call Prototypes in C\nDESCRIPTION: Function prototypes for Linux system calls related to memory management including memory mapping, protection, and allocation. These functions allow processes to manage their virtual memory address space.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nlong sys_old_mmap(struct mmap_arg_struct __user *arg);\nlong sys_mprotect(unsigned long start, size_t len, unsigned long prot);\nlong sys_munmap(unsigned long addr, size_t len);\nlong sys_brk(unsigned long brk);\nlong sys_mlock2(unsigned long start, size_t len, int flags);\nlong sys_pkey_mprotect(unsigned long start, size_t len, unsigned long prot, int pkey);\nlong sys_pkey_alloc(unsigned long flags, unsigned long init_val);\nlong sys_pkey_free(int pkey);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Calls in C\nDESCRIPTION: This snippet contains function declarations for Windows NT system calls. These functions are part of the Windows NT native API and are typically used for low-level system operations. The declarations include parameters and return types for each function.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp12_x86_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAcceptConnectPort (PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView);\nNTSTATUS NtAccessCheck (PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\n// ... (additional function declarations omitted for brevity)\nNTSTATUS NtCreateKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);\n```\n\n----------------------------------------\n\nTITLE: Declaring Advanced I/O and Event Handling System Calls in C for FreeBSD\nDESCRIPTION: This snippet declares system calls for advanced I/O operations and event handling in FreeBSD, including asynchronous I/O, polling, and kernel event notification.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_26\n\nLANGUAGE: C\nCODE:\n```\nint pselect(int nd, fd_set *in, fd_set *ou, fd_set *ex, const struct timespec *ts, const sigset_t *sm);\nint posix_fallocate(int fd, off_t offset, off_t len);\nint posix_fadvise(int fd, off_t offset, off_t len, int advice);\nint ppoll(struct pollfd *fds, unsigned nfds, const struct timespec *ts, const sigset_t *set);\nint kevent(int fd, struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout);\nint aio_mlock(struct aiocb *aiocbp);\n```\n\n----------------------------------------\n\nTITLE: Configuring Schema Generation Behavior with Pragma Directive - JSON\nDESCRIPTION: Demonstrates use of the 'pragma' dictionary to adjust QAPI generator options (e.g., requiring documentation, whitelisting return types or case rules). Inputs are DICT-type fields setting booleans or arrays; scope is file-wide. Ensure pragma names and values are supported by the generator.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{ 'pragma': DICT }\n```\n\n----------------------------------------\n\nTITLE: Configuring Buffer Range for bufmon - Shell\nDESCRIPTION: This snippet demonstrates how to specify an address range and address space identifier in a text file (search_buffers.txt) for bufmon to monitor. No dependencies other than a text editor are required. Each line includes the buffer's start address, size, and address space; this configuration is used by bufmon to decide what memory region to trace.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/LINE_Censorship.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n0x41792080 0x2000 28210000\n```\n\n----------------------------------------\n\nTITLE: Defining a QAPI Event with Optional Data - JSON\nDESCRIPTION: This JSON object defines a QAPI event named EVENT_C with an optional integer field 'a' and a required string field 'b' in 'data'. The example illustrates how event data is structured and how the input payload is represented on the wire, including automatic timestamp information. The snippet expects a JSON object for 'data', where keys correspond to event fields, and demonstrates the 'event', 'data', and 'timestamp' structure as transmitted.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"event\\\": \\\"EVENT_C\\\",\\n  \\\"data\\\": { \\\"b\\\": \\\"test string\\\" },\\n  \\\"timestamp\\\": { \\\"seconds\\\": 1267020223, \\\"microseconds\\\": 435656 }\\n}\n```\n\n----------------------------------------\n\nTITLE: Converting QCOW2 Image for PANDA Compatibility\nDESCRIPTION: Command to convert a QCOW2 virtual machine image to a version compatible with PANDA using qemu-img.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/panda_ssltut.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nqemu-img convert -f qcow2 -O qcow2 -o compat=0.10 \\\ndebian_squeeze_i386_desktop.qcow2 debian_squeeze_i386_desktop_tut.qcow2\n```\n\n----------------------------------------\n\nTITLE: Stopping NBD Server on Secondary VM\nDESCRIPTION: This QMP command stops the NBD server on the secondary VM after the primary host is down. It's part of the failover process.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/COLO-FT.txt#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{ 'execute': 'nbd-server-stop' }\n```\n\n----------------------------------------\n\nTITLE: Creating multi-function PCIe Root Ports in QEMU\nDESCRIPTION: Command example for creating multiple PCIe Root Ports as functions of a single device. This approach helps maintain a flat hierarchy while efficiently using resources. Each port requires a unique chassis identifier and proper function address.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/pcie.txt#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n-device ioh3420,id=root_port1,multifunction=on,chassis=x,addr=z.0[,slot=y][,bus=pcie.0] \\\n-device ioh3420,id=root_port2,chassis=x1,addr=z.1[,slot=y1][,bus=pcie.0] \\\n-device ioh3420,id=root_port3,chassis=x2,addr=z.2[,slot=y2][,bus=pcie.0] \\\n```\n\n----------------------------------------\n\nTITLE: Memory Manipulation Functions in PANDA\nDESCRIPTION: Core memory manipulation and state inspection functions in PANDA including saving memory snapshots, getting architectural state information, and disassembly capabilities.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nvoid panda_memsavep(FILE *out);\ntarget_ulong panda_current_asid(CPUState *cpu);\nbool panda_in_kernel(CPUState *cpu);\ntarget_ulong panda_current_sp(CPUState *cpu);\ntarget_ulong panda_get_retval(CPUState *cpu);\nvoid panda_disas(FILE *out, void *code, unsigned long size);\ntarget_ulong panda_current_pc(CPUState *cpu);\n```\n\n----------------------------------------\n\nTITLE: Defining USB Serial/Braille Devices (QEMU CLI, Shell)\nDESCRIPTION: Documents usage of -device usb-serial or usb-braille devices in QEMU, with vendor/product parameters, plus mapping a chardev for braille. Inputs: CLI string(s). Output: USB serial/braille device connected to guest, including support for special needs peripherals.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n-device usb-serial,vendorid=VID,productid=PRID\n-device usb-braille,chardev=braille,vendorid=VID,productid=PRID\n-chardev braille,id=braille\n```\n\n----------------------------------------\n\nTITLE: Declaring Linux System Call Prototypes in C Header\nDESCRIPTION: Declares prototype signatures for Linux system call handlers using standard Linux kernel types and conventions (e.g., __user pointers for user memory, loff_t, uid_t, gid_t, etc.). These declarations are essential for linking syscall numbers to implementation functions and serve as references for kernel developers. The file covers a broad range of kernel services including file operations, process and user management, IPC (shared memory, message queues, semaphores), signals, and extended attributes, with each function typically returning a long to represent error or result codes. No bodies or logic are included; these are pure C function declarations intended for use within kernel build processes. All dependencies are standard Linux kernel types and headers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_arm_prototypes.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n192 long do_mmap2(unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags, unsigned long fd, unsigned long pgoff);\n193 long sys_truncate64(const char __user *path, loff_t length);\n194 long sys_ftruncate64(unsigned int fd, loff_t length);\n195 long sys_stat64(const char __user *filename, struct stat64 __user *statbuf);\n196 long sys_lstat64(const char __user *filename, struct stat64 __user *statbuf);\n197 long sys_fstat64(unsigned long fd, struct stat64 __user *statbuf);\n198 long sys_lchown(const char __user *filename, uid_t user, gid_t group);\n199 long sys_getuid(void);\n200 long sys_getgid(void);\n201 long sys_geteuid(void);\n202 long sys_getegid(void);\n203 long sys_setreuid(uid_t ruid, uid_t euid);\n204 long sys_setregid(gid_t rgid, gid_t egid);\n205 long sys_getgroups(int gidsetsize, gid_t __user *grouplist);\n206 long sys_setgroups(int gidsetsize, gid_t __user *grouplist);\n207 long sys_fchown(unsigned int fd, uid_t user, gid_t group);\n208 long sys_setresuid(uid_t ruid, uid_t euid, uid_t suid);\n209 long sys_getresuid(uid_t __user *ruid, uid_t __user *euid, uid_t __user *suid);\n210 long sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid);\n211 long sys_getresgid(gid_t __user *rgid, gid_t __user *egid, gid_t __user *sgid);\n212 long sys_chown(const char __user *filename, uid_t user, gid_t group);\n213 long sys_setuid(uid_t uid);\n214 long sys_setgid(gid_t gid);\n215 long sys_setfsuid(uid_t uid);\n216 long sys_setfsgid(gid_t gid);\n217 long sys_getdents64(unsigned int fd, struct linux_dirent64 __user *dirent, unsigned int count);\n218 long sys_pivot_root(const char __user *new_root, const char __user *put_old);\n219 long sys_mincore(unsigned long start, size_t len, unsigned char __user *vec);\n220 long sys_madvise(unsigned long start, size_t len, int behavior);\n221 long sys_fcntl64(unsigned int fd, unsigned int cmd, unsigned long arg);\n224 long sys_gettid(void);\n225 long sys_readahead(int fd, loff_t offset, size_t count);\n226 long sys_setxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\n227 long sys_lsetxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\n228 long sys_fsetxattr(int fd, const char __user *name, const void __user *value, size_t size, int flags);\n229 long sys_getxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\n230 long sys_lgetxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\n231 long sys_fgetxattr(int fd, const char __user *name, void __user *value, size_t size);\n232 long sys_listxattr(const char __user *path, char __user *list, size_t size);\n233 long sys_llistxattr(const char __user *path, char __user *list, size_t size);\n234 long sys_flistxattr(int fd, char __user *list, size_t size);\n235 long sys_removexattr(const char __user *path, const char __user *name);\n236 long sys_lremovexattr(const char __user *path, const char __user *name);\n237 long sys_fremovexattr(int fd, const char __user *name);\n238 long sys_tkill(int pid, int sig);\n239 long sys_sendfile64(int out_fd, int in_fd, loff_t __user *offset, size_t count);\n240 long sys_futex(u32 __user *uaddr, int op, u32 val, struct timespec __user *utime, u32 __user *uaddr2, u32 val3);\n241 long sys_sched_setaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\n242 long sys_sched_getaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\n243 long sys_io_setup(unsigned nr_reqs, aio_context_t __user *ctx);\n244 long sys_io_destroy(aio_context_t ctx);\n245 long sys_io_getevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct timespec __user *timeout);\n246 long sys_io_submit(aio_context_t, long, struct iocb __user * __user *);\n247 long sys_io_cancel(aio_context_t ctx_id, struct iocb __user *iocb, struct io_event __user *result);\n248 long sys_exit_group(int error_code);\n249 long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);\n250 long sys_epoll_create(int size);\n251 long sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user *event);\n252 long sys_epoll_wait(int epfd, struct epoll_event __user *events, int maxevents, int timeout);\n253 long sys_remap_file_pages(unsigned long start, unsigned long size, unsigned long prot, unsigned long pgoff, unsigned long flags);\n256 long sys_set_tid_address(int __user *tidptr);\n257 long sys_timer_create(clockid_t which_clock, struct sigevent __user *timer_event_spec, timer_t __user *created_timer_id);\n258 long sys_timer_settime(timer_t timer_id, int flags, const struct itimerspec __user *new_setting, struct itimerspec __user *old_setting);\n259 long sys_timer_gettime(timer_t timer_id, struct itimerspec __user *setting);\n260 long sys_timer_getoverrun(timer_t timer_id);\n261 long sys_timer_delete(timer_t timer_id);\n262 long sys_clock_settime(clockid_t which_clock, const struct timespec __user *tp);\n263 long sys_clock_gettime(clockid_t which_clock, struct timespec __user *tp);\n264 long sys_clock_getres(clockid_t which_clock, struct timespec __user *tp);\n265 long sys_clock_nanosleep(clockid_t which_clock, int flags, const struct timespec __user *rqtp, struct timespec __user *rmtp);\n266 long sys_statfs64(const char __user *path, size_t sz, struct statfs64 __user *buf);\n267 long sys_fstatfs64(unsigned int fd, size_t sz, struct statfs64 __user *buf);\n268 long sys_tgkill(int tgid, int pid, int sig);\n269 long sys_utimes(char __user *filename, struct timeval __user *utimes);\n270 long sys_arm_fadvise64_64(int fd, int advice, loff_t offset, loff_t len);\n271 long sys_pciconfig_iobase(long which, unsigned long bus, unsigned long devfn);\n272 long sys_pciconfig_read(unsigned long bus, unsigned long dfn, unsigned long off, unsigned long len, void __user *buf);\n273 long sys_pciconfig_write(unsigned long bus, unsigned long dfn, unsigned long off, unsigned long len, void __user *buf);\n274 long sys_mq_open(const char __user *name, int oflag, umode_t mode, struct mq_attr __user *attr);\n275 long sys_mq_unlink(const char __user *name);\n276 long sys_mq_timedsend(mqd_t mqdes, const char __user *msg_ptr, size_t msg_len, unsigned int msg_prio, const struct timespec __user *abs_timeout);\n277 long sys_mq_timedreceive(mqd_t mqdes, char __user *msg_ptr, size_t msg_len, unsigned int __user *msg_prio, const struct timespec __user *abs_timeout);\n278 long sys_mq_notify(mqd_t mqdes, const struct sigevent __user *notification);\n279 long sys_mq_getsetattr(mqd_t mqdes, const struct mq_attr __user *mqstat, struct mq_attr __user *omqstat);\n280 long sys_waitid(int which, pid_t pid, struct siginfo __user *infop, int options, struct rusage __user *ru);\n281 long sys_socket(int, int, int);\n282 long sys_bind(int, struct sockaddr __user *, int);\n283 long sys_connect(int, struct sockaddr __user *, int);\n284 long sys_listen(int, int);\n285 long sys_accept(int, struct sockaddr __user *, int __user *);\n286 long sys_getsockname(int, struct sockaddr __user *, int __user *);\n287 long sys_getpeername(int, struct sockaddr __user *, int __user *);\n288 long sys_socketpair(int, int, int, int __user *);\n289 long sys_send(int, void __user *, size_t, unsigned);\n290 long sys_sendto(int, void __user *, size_t, unsigned, struct sockaddr __user *, int);\n291 long sys_recv(int, void __user *, size_t, unsigned);\n292 long sys_recvfrom(int, void __user *, size_t, unsigned, struct sockaddr __user *, int __user *);\n293 long sys_shutdown(int, int);\n294 long sys_setsockopt(int fd, int level, int optname, char __user *optval, int optlen);\n295 long sys_getsockopt(int fd, int level, int optname, char __user *optval, int __user *optlen);\n296 long sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\n297 long sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\n298 long sys_semop(int semid, struct sembuf __user *sops, unsigned nsops);\n299 long sys_semget(key_t key, int nsems, int semflg);\n300 long sys_semctl(int semid, int semnum, int cmd, unsigned long arg);\n301 long sys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz, int msgflg);\n302 long sys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz, long msgtyp, int msgflg);\n303 long sys_msgget(key_t key, int msgflg);\n304 long sys_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);\n305 long sys_shmat(int shmid, char __user *shmaddr, int shmflg);\n306 long sys_shmdt(char __user *shmaddr);\n307 long sys_shmget(key_t key, size_t size, int flag);\n308 long sys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);\n309 long sys_add_key(const char __user *_type, const char __user *_description, const void __user *_payload, size_t plen, key_serial_t destringid);\n310 long sys_request_key(const char __user *_type, const char __user *_description, const char __user *_callout_info, key_serial_t destringid);\n311 long sys_keyctl(int cmd, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\n312 long sys_semtimedop(int semid, struct sembuf __user *sops, unsigned nsops, const struct timespec __user *timeout);\n314 long sys_ioprio_set(int which, int who, int ioprio);\n315 long sys_ioprio_get(int which, int who);\n316 long sys_inotify_init(void);\n317 long sys_inotify_add_watch(int fd, const char __user *path, u32 mask);\n318 long sys_inotify_rm_watch(int fd, __s32 wd);\n319 long sys_mbind(unsigned long start, unsigned long len, unsigned long mode, const unsigned long __user *nmask, unsigned long maxnode, unsigned flags);\n320 long sys_get_mempolicy(int __user *policy, unsigned long __user *nmask, unsigned long maxnode, unsigned long addr, unsigned long flags);\n321 long sys_set_mempolicy(int mode, const unsigned long __user *nmask, unsigned long maxnode);\n322 long sys_openat(int dfd, const char __user *filename, int flags, umode_t mode);\n323 long sys_mkdirat(int dfd, const char __user *pathname, umode_t mode);\n324 long sys_mknodat(int dfd, const char __user *filename, umode_t mode, unsigned dev);\n```\n\n----------------------------------------\n\nTITLE: Jail and Extended Attribute Listing Operations in C\nDESCRIPTION: Function declarations for attaching to jails and listing extended attributes. Includes jail attachment function and extended attribute listing for files, descriptors, and links.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_17\n\nLANGUAGE: c\nCODE:\n```\nint jail_attach(int jid);\nssize_t extattr_list_fd(int fd, int attrnamespace, void *data, size_t nbytes);\nssize_t extattr_list_file(const char *path, int attrnamespace, void *data, size_t nbytes);\nssize_t extattr_list_link(const char *path, int attrnamespace, void *data, size_t nbytes);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API Functions in C\nDESCRIPTION: This snippet contains multiple function declarations for Windows NT native API calls. These functions provide low-level access to various system operations such as process creation, thread management, file handling, and inter-process communication.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x64_prototypes.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueueApcThread (HANDLE ThreadHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\nNTSTATUS NtYieldExecution ();\nNTSTATUS NtAddAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\nNTSTATUS NtCreateEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);\nNTSTATUS NtQueryVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);\nNTSTATUS NtFlushBuffersFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtApphelpCacheControl (APPHELPCOMMAND type, PVOID buf);\nNTSTATUS NtCreateProcessEx (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel);\nNTSTATUS NtCreateThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended);\nNTSTATUS NtIsProcessInJob (HANDLE ProcessHandle, HANDLE JobHandle);\nNTSTATUS NtProtectVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, WIN32_PROTECTION_MASK NewProtectWin32, PULONG OldProtect);\nNTSTATUS NtQuerySection (HANDLE SectionHandle, SECTION_INFORMATION_CLASS SectionInformationClass, PVOID SectionInformation, SIZE_T SectionInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtTerminateThread (HANDLE ThreadHandle, NTSTATUS ExitStatus);\nNTSTATUS NtReadRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtCreateFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);\nNTSTATUS NtQueryEvent (HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ReturnLength);\nNTSTATUS NtWriteRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\nNTSTATUS NtOpenDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtAccessCheckByTypeAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtWaitForMultipleObjects (ULONG Count, HANDLE Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtSetInformationObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength);\nNTSTATUS NtCancelIoFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtTraceEvent (HANDLE TraceHandle, ULONG Flags, ULONG FieldSize, PVOID Fields);\nNTSTATUS NtPowerInformation (POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtSetValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);\nNTSTATUS NtCancelTimer (HANDLE TimerHandle, PBOOLEAN CurrentState);\nNTSTATUS NtSetTimer (HANDLE TimerHandle, PLARGE_INTEGER DueTime, PTIMER_APC_ROUTINE TimerApcRoutine, PVOID TimerContext, BOOLEAN WakeTimer, LONG Period, PBOOLEAN PreviousState);\nNTSTATUS NtAccessCheck (PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByType (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByTypeResultList (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarmByHandle (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAddBootEntry (PBOOT_ENTRY BootEntry, PULONG Id);\nNTSTATUS NtAddDriverEntry (PEFI_DRIVER_ENTRY DriverEntry, PULONG Id);\nNTSTATUS NtAdjustGroupsToken (HANDLE TokenHandle, BOOLEAN ResetToDefault, PTOKEN_GROUPS NewState, ULONG BufferLength, PTOKEN_GROUPS PreviousState, PULONG ReturnLength);\nNTSTATUS NtAlertResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtAlertThread (HANDLE ThreadHandle);\nNTSTATUS NtAllocateLocallyUniqueId (PLUID Luid);\nNTSTATUS NtAllocateReserveObject (PHANDLE MemoryReserveHandle, POBJECT_ATTRIBUTES ObjectAttributes, MEMORY_RESERVE_TYPE Type);\nNTSTATUS NtAllocateUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtAllocateUuids (PULARGE_INTEGER Time, PULONG Range, PULONG Sequence, PCHAR Seed);\nNTSTATUS NtAlpcAcceptConnectPort (PHANDLE PortHandle, HANDLE ConnectionPortHandle, ULONG Flags, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes, BOOLEAN AcceptConnection);\nNTSTATUS NtAlpcCancelMessage (HANDLE PortHandle, ULONG Flags, PALPC_CONTEXT_ATTR MessageContext);\nNTSTATUS NtAlpcConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, ULONG Flags, PSID RequiredServerSid, PPORT_MESSAGE ConnectionMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes, PALPC_MESSAGE_ATTRIBUTES InMessageAttributes, PLARGE_INTEGER Timeout);\nNTSTATUS NtAlpcCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes);\nNTSTATUS NtAlpcCreatePortSection (HANDLE PortHandle, ULONG Flags, HANDLE SectionHandle, SIZE_T SectionSize, PALPC_HANDLE AlpcSectionHandle, PSIZE_T ActualSectionSize);\nNTSTATUS NtAlpcCreateResourceReserve (HANDLE PortHandle, ULONG Flags, SIZE_T MessageSize, PALPC_HANDLE ResourceId);\nNTSTATUS NtAlpcCreateSectionView (HANDLE PortHandle, ULONG Flags, PALPC_DATA_VIEW_ATTR ViewAttributes);\nNTSTATUS NtAlpcCreateSecurityContext (HANDLE PortHandle, ULONG Flags, PALPC_SECURITY_ATTR SecurityAttribute);\nNTSTATUS NtAlpcDeletePortSection (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE SectionHandle);\nNTSTATUS NtAlpcDeleteResourceReserve (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ResourceId);\nNTSTATUS NtAlpcDeleteSectionView (HANDLE PortHandle, ULONG Flags, PVOID ViewBase);\nNTSTATUS NtAlpcDeleteSecurityContext (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);\nNTSTATUS NtAlpcDisconnectPort (HANDLE PortHandle, ULONG Flags);\nNTSTATUS NtAlpcImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE PortMessage, PVOID Reserved);\nNTSTATUS NtAlpcOpenSenderProcess (PHANDLE ProcessHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtAlpcOpenSenderThread (PHANDLE ThreadHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtAlpcQueryInformation (HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtAlpcQueryInformationMessage (HANDLE PortHandle, PPORT_MESSAGE PortMessage, ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass, PVOID MessageInformation, ULONG Length, PULONG ReturnLength);\n```\n\n----------------------------------------\n\nTITLE: Using Trace Event Properties in QEMU C Code\nDESCRIPTION: Demonstrates how to use the 'disable' trace event property in C code to optimize performance for frequently invoked events.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/tracing.txt#_snippet_15\n\nLANGUAGE: c\nCODE:\n```\n#include \"trace.h\"  /* needed for trace event prototype */\n\nvoid *qemu_vmalloc(size_t size)\n{\n    void *ptr;\n    size_t align = QEMU_VMALLOC_ALIGN;\n\n    if (size < align) {\n        align = getpagesize();\n    }\n    ptr = qemu_memalign(align, size);\n    if (TRACE_QEMU_VMALLOC_ENABLED) { /* preprocessor macro */\n        void *complex;\n        /* some complex computations to produce the 'complex' value */\n        trace_qemu_vmalloc(size, ptr, complex);\n    }\n    return ptr;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Audio Devices in QEMU\nDESCRIPTION: Shows the mapping from -soundhw syntax to -device syntax for various audio device types including AC97, ES1370, HDA, and others. Each device has specific configuration options such as IO address, IRQ, and DMA channels.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nac97        -device AC97\ncs4231a     -device cs4231a,iobase=IOADDR,irq=IRQ,dma=DMA\nes1370      -device ES1370\ngus         -device gus,iobase=IOADDR,irq=IRQ,dma=DMA,freq=F\nhda         -device intel-hda,msi=MSI -device hda-duplex\nsb16        -device sb16,iobase=IOADDR,irq=IRQ,dma=DMA,dma16=DMA16,version=V\nadlib       not yet available with -device\npcspk       not yet available with -device\n```\n\n----------------------------------------\n\nTITLE: Toggling Recording from Guest Utility - Shell\nDESCRIPTION: This shell command runs the 'recctrlu' binary with the 'toggle' argument and a required recording name, from within the guest OS. It issues a hypercall to PANDA via the recctrl plugin, which will start or stop a recording session as appropriate. The utility must have been built and copied onto the guest, and PANDA must be running with the plugin active. Recording name specification is mandatory for proper operation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/recctrl/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nrecctrlu toggle myrecording\n```\n\n----------------------------------------\n\nTITLE: Querying Arbitrary ASID Instruction Count Using Panda Plugin APIs in C\nDESCRIPTION: Provides a C function signature for obtaining the instruction count for an arbitrary ASID, after subtracting out instructions from all other ASIDs. Takes a 'target_ulong asid' parameter specifying the ASID of interest, and returns a corrected instruction count as an 'Instr' value. This function is part of a plugin intended for use by other plugins within the panda architecture, requires no further dependencies, and is safe for calculating instruction deltas. The scope is limited to querying corrected counts rather than raw trace counts.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/asid_instr_count/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nInstr get_instr_count_by_asid(target_ulong asid);\n```\n\n----------------------------------------\n\nTITLE: User and Group Management System Call Declarations in C\nDESCRIPTION: Function declarations for Linux system calls related to user and group identity management. These declarations define the interface for retrieving and modifying user and group IDs and privileges.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_22\n\nLANGUAGE: C\nCODE:\n```\nlong sys_getuid(void);\nlong sys_getgid(void);\nlong sys_setuid(uid_t uid);\nlong sys_setgid(gid_t gid);\nlong sys_geteuid(void);\nlong sys_getegid(void);\nlong sys_setreuid(uid_t ruid, uid_t euid);\nlong sys_setregid(gid_t rgid, gid_t egid);\nlong sys_getgroups(int gidsetsize, gid_t __user *grouplist);\nlong sys_setgroups(int gidsetsize, gid_t __user *grouplist);\nlong sys_setresuid(uid_t ruid, uid_t euid, uid_t suid);\nlong sys_getresuid(uid_t __user *ruid, uid_t __user *euid, uid_t __user *suid);\nlong sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid);\nlong sys_getresgid(gid_t __user *rgid, gid_t __user *egid, gid_t __user *sgid);\nlong sys_setfsuid(uid_t uid);\nlong sys_setfsgid(gid_t gid);\nlong sys_capget(cap_user_header_t header, cap_user_data_t dataptr);\nlong sys_capset(cap_user_header_t header, const cap_user_data_t data);\n```\n\n----------------------------------------\n\nTITLE: Building Main and Graphical Subsystem Binaries for QEMU on Windows - Makefile\nDESCRIPTION: This Makefile snippet shows the approach for generating two types of QEMU system emulator binaries on Windows: one for the console and one for the graphical subsystem. It demonstrates use of $(EXESUF) for platform-agnostic suffix handling and outlines the practice of first generating a graphical binary and then relinking with objcopy to produce a console version. Required dependencies include GNU make, a suitable linker, and objcopy on Windows. Inputs are the object file build targets and EXESUF variable; outputs are properly suffixed binaries for each subsystem. Limitations include being applicable only to Windows builds.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/build-system.txt#_snippet_3\n\nLANGUAGE: Makefile\nCODE:\n```\nqemu-img$(EXESUF): qemu-img.o ..snip.. libqemuutil.a libqemustub.a\n```\n\nLANGUAGE: Makefile\nCODE:\n```\nqemu-img$(EXESUF): qemu-img.o ..snip..\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT 'NtQuery*' and 'NtSet*' Native APIs - C\nDESCRIPTION: This snippet provides C function prototypes for various undocumented Windows NT Native API system calls prefixed with 'NtQuery' and 'NtSet'. These declarations enable direct invocation of kernel-level routines for querying and modifying system objects (files, processes, directory objects, jobs, keys, timers, events, etc.) in system-level software or drivers. Dependencies include Windows data types and structures like HANDLE, ULONG, PVOID, and specific enums or structures for each API; the APIs are available only in certain Windows NT/XP-class systems, and should be used cautiously as they are subject to change or may be unavailable in future OS versions. Each function takes parameters specific to the object or information class it targets, and typically returns an NTSTATUS error code.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_xpsp3_x86_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryDebugFilterState (ULONG ComponentId, ULONG Level);\nNTSTATUS NtQueryDefaultLocale (BOOLEAN UserProfile, PLCID DefaultLocaleId);\nNTSTATUS NtQueryDefaultUILanguage (LANGID *DefaultUILanguageId);\nNTSTATUS NtQueryDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);\nNTSTATUS NtQueryDirectoryObject (HANDLE DirectoryHandle, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, BOOLEAN RestartScan, PULONG Context, PULONG ReturnLength);\nNTSTATUS NtQueryEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan);\nNTSTATUS NtQueryEvent (HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryFullAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);\nNTSTATUS NtQueryInformationAtom (RTL_ATOM Atom, ATOM_INFORMATION_CLASS InformationClass, PVOID AtomInformation, ULONG AtomInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\nNTSTATUS NtQueryInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationPort (HANDLE PortHandle, PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtQueryInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInstallUILanguage (LANGID *InstallUILanguageId);\nNTSTATUS NtQueryIntervalProfile (KPROFILE_SOURCE ProfileSource, PULONG Interval);\nNTSTATUS NtQueryIoCompletion (HANDLE IoCompletionHandle, IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass, PVOID IoCompletionInformation, ULONG IoCompletionInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryKey (HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtQueryMultipleValueKey (HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength);\nNTSTATUS NtQueryMutant (HANDLE MutantHandle, MUTANT_INFORMATION_CLASS MutantInformationClass, PVOID MutantInformation, ULONG MutantInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryOpenSubKeys (POBJECT_ATTRIBUTES TargetKey, PULONG HandleCount);\nNTSTATUS NtQueryPerformanceCounter (PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);\nNTSTATUS NtQueryQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID SidList, ULONG SidListLength, PULONG StartSid, BOOLEAN RestartScan);\nNTSTATUS NtQuerySection (HANDLE SectionHandle, SECTION_INFORMATION_CLASS SectionInformationClass, PVOID SectionInformation, SIZE_T SectionInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtQuerySecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Length, PULONG LengthNeeded);\nNTSTATUS NtQuerySemaphore (HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG SemaphoreInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySymbolicLinkObject (HANDLE LinkHandle, PUNICODE_STRING LinkTarget, PULONG ReturnedLength);\nNTSTATUS NtQuerySystemEnvironmentValue (PUNICODE_STRING VariableName, PWSTR VariableValue, USHORT ValueLength, PUSHORT ReturnLength);\nNTSTATUS NtQuerySystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, PULONG ValueLength, PULONG Attributes);\nNTSTATUS NtQuerySystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySystemTime (PLARGE_INTEGER SystemTime);\nNTSTATUS NtQueryTimer (HANDLE TimerHandle, TIMER_INFORMATION_CLASS TimerInformationClass, PVOID TimerInformation, ULONG TimerInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryTimerResolution (PULONG MaximumTime, PULONG MinimumTime, PULONG CurrentTime);\nNTSTATUS NtQueryValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtQueryVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtQueryVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtQueueApcThread (HANDLE ThreadHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\nNTSTATUS NtRaiseException (PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ContextRecord, BOOLEAN FirstChance);\nNTSTATUS NtRaiseHardError (NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask, PULONG_PTR Parameters, ULONG ValidResponseOptions, PULONG Response);\nNTSTATUS NtReadFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtReadFileScatter (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtReadRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtReadVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtRegisterThreadTerminatePort (HANDLE PortHandle);\nNTSTATUS NtReleaseMutant (HANDLE MutantHandle, PLONG PreviousCount);\nNTSTATUS NtReleaseSemaphore (HANDLE SemaphoreHandle, LONG ReleaseCount, PLONG PreviousCount);\nNTSTATUS NtRemoveIoCompletion (HANDLE IoCompletionHandle, PVOID *KeyContext, PVOID *ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER Timeout);\nNTSTATUS NtRemoveProcessDebug (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtRenameKey (HANDLE KeyHandle, PUNICODE_STRING NewName);\nNTSTATUS NtReplaceKey (POBJECT_ATTRIBUTES NewFile, HANDLE TargetHandle, POBJECT_ATTRIBUTES OldFile);\nNTSTATUS NtReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtReplyWaitReceivePort (HANDLE PortHandle, PVOID *PortContext , PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage);\nNTSTATUS NtReplyWaitReceivePortEx (HANDLE PortHandle, PVOID *PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage, PLARGE_INTEGER Timeout);\nNTSTATUS NtReplyWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtRequestPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage);\nNTSTATUS NtRequestWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtResetEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtResetWriteWatch (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T RegionSize);\nNTSTATUS NtRestoreKey (HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags);\nNTSTATUS NtResumeProcess (HANDLE ProcessHandle);\nNTSTATUS NtResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtSaveKey (HANDLE KeyHandle, HANDLE FileHandle);\nNTSTATUS NtSaveKeyEx (HANDLE KeyHandle, HANDLE FileHandle, ULONG Format);\nNTSTATUS NtSaveMergedKeys (HANDLE HighPrecedenceKeyHandle, HANDLE LowPrecedenceKeyHandle, HANDLE FileHandle);\nNTSTATUS NtSecureConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PSID RequiredServerSid, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\nNTSTATUS NtSetBootEntryOrder (PULONG Ids, ULONG Count);\nNTSTATUS NtSetBootOptions (PBOOT_OPTIONS BootOptions, ULONG FieldsToChange);\nNTSTATUS NtSetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nNTSTATUS NtSetDebugFilterState (ULONG ComponentId, ULONG Level, BOOLEAN State);\nNTSTATUS NtSetDefaultHardErrorPort (HANDLE DefaultHardErrorPort);\nNTSTATUS NtSetDefaultLocale (BOOLEAN UserProfile, LCID DefaultLocaleId);\nNTSTATUS NtSetDefaultUILanguage (LANGID DefaultUILanguageId);\nNTSTATUS NtSetEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\nNTSTATUS NtSetEvent (HANDLE EventHandle, PLONG PreviousState);\n```\n\n----------------------------------------\n\nTITLE: Defining QAPI Struct Type - QAPI Python-Like (JSON) Schema\nDESCRIPTION: This schema definition outlines a new QAPI struct type 'QemuAlarmClock' intended to represent alarm clock metadata. It carries a required string field 'clock-name' and an optional integer field 'next-deadline'. This type is later used as a return value from QMP commands. Required for code generation by the QAPI toolchain, and must be declared before use in command schemas or C code.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/writing-qmp-commands.txt#_snippet_9\n\nLANGUAGE: qapi\nCODE:\n```\n{ 'type': 'QemuAlarmClock',\n  'data': { 'clock-name': 'str', '*next-deadline': 'int' } }\n```\n\n----------------------------------------\n\nTITLE: Defining VMState for IDE Drive PIO State in C\nDESCRIPTION: This VMStateDescription defines the structure for saving the PIO state of an IDE drive. It includes version information, callbacks, and a list of fields to be saved.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/migration.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nconst VMStateDescription vmstate_ide_drive_pio_state = {\n    .name = \"ide_drive/pio_state\",\n    .version_id = 1,\n    .minimum_version_id = 1,\n    .pre_save = ide_drive_pio_pre_save,\n    .post_load = ide_drive_pio_post_load,\n    .needed = ide_drive_pio_state_needed,\n    .fields = (VMStateField[]) {\n        VMSTATE_INT32(req_nb_sectors, IDEState),\n        VMSTATE_VARRAY_INT32(io_buffer, IDEState, io_buffer_total_len, 1,\n                             vmstate_info_uint8, uint8_t),\n        VMSTATE_INT32(cur_io_buffer_offset, IDEState),\n        VMSTATE_INT32(cur_io_buffer_len, IDEState),\n        VMSTATE_UINT8(end_transfer_fn_idx, IDEState),\n        VMSTATE_INT32(elementary_transfer_size, IDEState),\n        VMSTATE_INT32(packet_transfer_size, IDEState),\n        VMSTATE_END_OF_LIST()\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Defining File Path Operation System Calls in C\nDESCRIPTION: Function declarations for Linux system calls related to file path operations, particularly those that take directory file descriptors. These calls provide relative path operations and enhance security by avoiding race conditions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_34\n\nLANGUAGE: C\nCODE:\n```\nlong sys_openat(int dfd, const char __user *filename, int flags, umode_t mode);\nlong sys_mkdirat(int dfd, const char __user *pathname, umode_t mode);\nlong sys_mknodat(int dfd, const char __user *filename, umode_t mode, unsigned dev);\nlong sys_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group, int flag);\nlong sys_futimesat_time32(unsigned int dfd, const char __user *filename, struct old_timeval32 __user *t);\nlong sys_newfstatat(int dfd, const char __user *filename, struct stat __user *statbuf, int flag);\nlong sys_unlinkat(int dfd, const char __user *pathname, int flag);\nlong sys_renameat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname);\nlong sys_linkat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, int flags);\nlong sys_symlinkat(const char __user *oldname, int newdfd, const char __user *newname);\nlong sys_readlinkat(int dfd, const char __user *path, char __user *buf, int bufsiz);\nlong sys_fchmodat(int dfd, const char __user *filename, umode_t mode);\nlong sys_faccessat(int dfd, const char __user *filename, int mode);\nlong sys_utimensat_time32(unsigned int dfd, const char __user *filename, struct old_timespec32 __user *t, int flags);\n```\n\n----------------------------------------\n\nTITLE: Marshaling and Dispatching QAPI Commands with Visitors in C\nDESCRIPTION: This C code, generated by qapi-commands.py, implements marshaling of command inputs and outputs to and from wire format using visitor functions. It requires the generated QAPI types, visitors, QDict handling, and error propagation support. Inputs are QDict argument objects and output/return pointers; outputs are QObjects suitable for return over QMP channels, with careful error checking and resource deallocation to ensure robust command handling.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_22\n\nLANGUAGE: C\nCODE:\n```\n#ifndef EXAMPLE_QMP_COMMANDS_H\\n#define EXAMPLE_QMP_COMMANDS_H\\n\\n#include \\\"example-qapi-types.h\\\"\\n#include \\\"qapi/qmp/qdict.h\\\"\\n#include \\\"qapi/error.h\\\"\\n\\nUserDefOne *qmp_my_command(UserDefOneList *arg1, Error **errp);\\n\\n#endif\n```\n\nLANGUAGE: C\nCODE:\n```\nstatic void qmp_marshal_output_UserDefOne(UserDefOne *ret_in, QObject **ret_out, Error **errp)\\n{\\n    Error *err = NULL;\\n    Visitor *v;\\n\\n    v = qobject_output_visitor_new(ret_out);\\n    visit_type_UserDefOne(v, \\\"unused\\\", &ret_in, &err);\\n    if (!err) {\\n        visit_complete(v, ret_out);\\n    }\\n    error_propagate(errp, err);\\n    visit_free(v);\\n    v = qapi_dealloc_visitor_new();\\n    visit_type_UserDefOne(v, \\\"unused\\\", &ret_in, NULL);\\n    visit_free(v);\\n}\\n\\nstatic void qmp_marshal_my_command(QDict *args, QObject **ret, Error **errp)\\n{\\n    Error *err = NULL;\\n    UserDefOne *retval;\\n    Visitor *v;\\n    UserDefOneList *arg1 = NULL;\\n\\n    v = qobject_input_visitor_new(QOBJECT(args));\\n    visit_start_struct(v, NULL, NULL, 0, &err);\\n    if (err) {\\n        goto out;\\n    }\\n    visit_type_UserDefOneList(v, \\\"arg1\\\", &arg1, &err);\\n    if (!err) {\\n        visit_check_struct(v, &err);\\n    }\\n    visit_end_struct(v, NULL);\\n    if (err) {\\n        goto out;\\n    }\n```\n\n----------------------------------------\n\nTITLE: Running PANDA with win7proc and syscalls2\nDESCRIPTION: PANDA command-line argument for running a replay with win7proc and syscalls2 plugins. It specifies the Windows 7 x86 profile for syscalls2.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/stuw.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n-panda \"syscalls2:profile=windows7_x86;win7proc\"\n```\n\n----------------------------------------\n\nTITLE: Listing LTTng Events for QEMU\nDESCRIPTION: Lists all available LTTng events for an instrumented QEMU instance.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/tracing.txt#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nlttng list -u\n```\n\n----------------------------------------\n\nTITLE: Securing recctrlu Utilities with Ownership and Permissions - Shell\nDESCRIPTION: These commands secure the guest-installed utilities by setting restrictive ownership and permissions, preventing unauthorized users from executing or modifying the binaries and scripts. The 'chown' and 'chmod' commands require root privileges and ensure only root may run or alter the tools. This provides a security measure in environments where users have shell access to the guest.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/recctrl/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nsudo chown root:root /usr/local/sbin/recctrlu /usr/local/bin/recctrlu.sh\\nsudo chmod 700 /usr/local/sbin/recctrlu /usr/local/bin/recctrlu.sh\n```\n\n----------------------------------------\n\nTITLE: Defining Key Management System Calls in C\nDESCRIPTION: Function declarations for Linux system calls related to kernel key management. These calls provide interfaces for managing cryptographic and authorization keys in the kernel keyring.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_32\n\nLANGUAGE: C\nCODE:\n```\nlong sys_add_key(const char __user *_type, const char __user *_description, const void __user *_payload, size_t plen, key_serial_t destringid);\nlong sys_request_key(const char __user *_type, const char __user *_description, const char __user *_callout_info, key_serial_t destringid);\nlong sys_keyctl(int cmd, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\n```\n\n----------------------------------------\n\nTITLE: Timer and Clock Management Prototypes in C\nDESCRIPTION: Function prototypes for Linux system calls related to timer and clock management. These functions provide interfaces for creating and managing timers, as well as accessing and adjusting system clocks.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nlong sys_utimensat(int dfd, const char __user *filename, struct __kernel_timespec __user *utimes, int flags);\nlong sys_timerfd_create(int clockid, int flags);\nlong sys_timerfd_gettime(int ufd, struct __kernel_itimerspec __user *otmr);\nlong sys_timerfd_settime(int ufd, int flags, const struct __kernel_itimerspec __user *utmr, struct __kernel_itimerspec __user *otmr);\nlong sys_clock_adjtime(clockid_t which_clock, struct __kernel_timex __user *tx);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Calls for System Configuration in C\nDESCRIPTION: This snippet declares Windows NT system calls related to system configuration, including setting boot options, default locales, and driver entry orders. These functions are used for modifying system-wide settings and configurations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x64_prototypes.txt#_snippet_10\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetBootEntryOrder (PULONG Ids, ULONG Count);\nNTSTATUS NtSetBootOptions (PBOOT_OPTIONS BootOptions, ULONG FieldsToChange);\nNTSTATUS NtSetDefaultLocale (BOOLEAN UserProfile, LCID DefaultLocaleId);\nNTSTATUS NtSetDefaultUILanguage (LANGID DefaultUILanguageId);\nNTSTATUS NtSetDriverEntryOrder (PULONG Ids, ULONG Count);\n```\n\n----------------------------------------\n\nTITLE: Structure Definition for RCU-Managed Resizable Array in C\nDESCRIPTION: This snippet defines the structure of a dynamically sized array suitable for RCU-safe operations. The struct arr contains size, allocation count, and a flexible array member for data. No functions are called directly, but correct use requires contiguous allocation and careful memory management. Used to ensure size and data pointer consistency between concurrent readers and writers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/rcu.txt#_snippet_12\n\nLANGUAGE: C\nCODE:\n```\nstruct arr {\n    int size;\n    int alloc;\n    T   data[];\n};\nstruct arr *global_array;\n```\n\n----------------------------------------\n\nTITLE: Declaring Linux Kernel System Call Prototypes - C\nDESCRIPTION: This collection of function prototypes declares system call entry points in the Linux kernel, defining the signatures for sys_* functions that implement various system-level operations. These declarations require standard Linux kernel types and user-space pointer qualifiers. All functions return a long value indicating the result or error code. Parameters range from file descriptors and paths to custom structs for different subsystems. Inputs are generally values or pointers to user-space structs, and output is a syscall return value (typically 0 on success, or a negative error code). These prototypes are foundational and do not include implementation logic.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_37\n\nLANGUAGE: C\nCODE:\n```\n6294 long sys_pwritev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);\n6295 long sys_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t __user *uinfo);\n6296 long sys_perf_event_open(struct perf_event_attr __user *attr_uptr, pid_t pid, int cpu, int group_fd, unsigned long flags);\n6297 long sys_accept4(int, struct sockaddr __user *, int __user *, int);\n6298 long sys_ppoll_time32(struct pollfd __user *, unsigned int, struct old_timespec32 __user *, const sigset_t __user *, size_t);\n6299 long sys_getdents64(unsigned int fd, struct linux_dirent64 __user *dirent, unsigned int count);\n6300 long sys_fanotify_init(unsigned int flags, unsigned int event_f_flags);\n6301 long sys_fanotify_mark(int fanotify_fd, unsigned int flags, u64 mask, int fd, const char __user *pathname);\n6302 long sys_prlimit64(pid_t pid, unsigned int resource, const struct rlimit64 __user *new_rlim, struct rlimit64 __user *old_rlim);\n6303 long sys_name_to_handle_at(int dfd, const char __user *name, struct file_handle __user *handle, int __user *mnt_id, int flag);\n6304 long sys_open_by_handle_at(int mountdirfd, struct file_handle __user *handle, int flags);\n6305 long sys_clock_adjtime32(clockid_t which_clock, struct old_timex32 __user *tx);\n6306 long sys_syncfs(int fd);\n6307 long sys_sendmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags);\n6308 long sys_setns(int fd, int nstype);\n6309 long sys_process_vm_readv(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);\n6310 long sys_process_vm_writev(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);\n6311 long sys_kcmp(pid_t pid1, pid_t pid2, int type, unsigned long idx1, unsigned long idx2);\n6312 long sys_finit_module(int fd, const char __user *uargs, int flags);\n6313 long sys_sched_setattr(pid_t pid, struct sched_attr __user *attr, unsigned int flags);\n6314 long sys_sched_getattr(pid_t pid, struct sched_attr __user *attr, unsigned int size, unsigned int flags);\n6315 long sys_renameat2(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, unsigned int flags);\n6316 long sys_seccomp(unsigned int op, unsigned int flags, void __user *uargs);\n6317 long sys_getrandom(char __user *buf, size_t count, unsigned int flags);\n6318 long sys_memfd_create(const char __user *uname_ptr, unsigned int flags);\n6319 long sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);\n6320 long sys_execveat(int dfd, const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp, int flags);\n6321 long sys_userfaultfd(int flags);\n6322 long sys_membarrier(int cmd, int flags);\n6323 long sys_mlock2(unsigned long start, size_t len, int flags);\n6324 long sys_copy_file_range(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);\n6325 long sys_preadv2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);\n6326 long sys_pwritev2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);\n6327 long sys_pkey_mprotect(unsigned long start, size_t len, unsigned long prot, int pkey);\n6328 long sys_pkey_alloc(unsigned long flags, unsigned long init_val);\n6329 long sys_pkey_free(int pkey);\n6330 long sys_statx(int dfd, const char __user *path, unsigned flags, unsigned mask, struct statx __user *buffer);\n6331 long sys_rseq(struct rseq __user *rseq, uint32_t rseq_len, int flags, uint32_t sig);\n6332 long sys_io_pgetevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct __kernel_timespec __user *timeout, const struct __aio_sigset *sig);\n6403 long sys_clock_gettime(clockid_t which_clock, struct __kernel_timespec __user *tp);\n6404 long sys_clock_settime(clockid_t which_clock, const struct __kernel_timespec __user *tp);\n6405 long sys_clock_adjtime(clockid_t which_clock, struct __kernel_timex __user *tx);\n6406 long sys_clock_getres(clockid_t which_clock, struct __kernel_timespec __user *tp);\n6407 long sys_clock_nanosleep(clockid_t which_clock, int flags, const struct __kernel_timespec __user *rqtp, struct __kernel_timespec __user *rmtp);\n6408 long sys_timer_gettime(timer_t timer_id, struct __kernel_itimerspec __user *setting);\n6409 long sys_timer_settime(timer_t timer_id, int flags, const struct __kernel_itimerspec __user *new_setting, struct __kernel_itimerspec __user *old_setting);\n6410 long sys_timerfd_gettime(int ufd, struct __kernel_itimerspec __user *otmr);\n6411 long sys_timerfd_settime(int ufd, int flags, const struct __kernel_itimerspec __user *utmr, struct __kernel_itimerspec __user *otmr);\n6412 long sys_utimensat(int dfd, const char __user *filename, struct __kernel_timespec __user *utimes, int flags);\n6416 long sys_io_pgetevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct __kernel_timespec __user *timeout, const struct __aio_sigset *sig);\n6418 long sys_mq_timedsend(mqd_t mqdes, const char __user *msg_ptr, size_t msg_len, unsigned int msg_prio, const struct __kernel_timespec __user *abs_timeout);\n6419 long sys_mq_timedreceive(mqd_t mqdes, char __user *msg_ptr, size_t msg_len, unsigned int __user *msg_prio, const struct __kernel_timespec __user *abs_timeout);\n6420 long sys_semtimedop(int semid, struct sembuf __user *sops, unsigned nsops, const struct __kernel_timespec __user *timeout);\n6422 long sys_futex(u32 __user *uaddr, int op, u32 val, struct __kernel_timespec __user *utime, u32 __user *uaddr2, u32 val3);\n6423 long sys_sched_rr_get_interval(pid_t pid, struct __kernel_timespec __user *interval);\n6424 long sys_pidfd_send_signal(int pidfd, int sig, siginfo_t __user *info, unsigned int flags);\n6425 long sys_io_uring_setup(u32 entries, struct io_uring_params __user *p);\n6426 long sys_io_uring_enter(unsigned int fd, u32 to_submit, u32 min_complete, u32 flags, const sigset_t __user *sig, size_t sigsz);\n6427 long sys_io_uring_register(unsigned int fd, unsigned int op, void __user *arg, unsigned int nr_args);\n6428 long sys_open_tree(int dfd, const char __user *path, unsigned flags);\n6429 long sys_move_mount(int from_dfd, const char __user *from_path, int to_dfd, const char __user *to_path, unsigned int ms_flags);\n6430 long sys_fsopen(const char __user *fs_name, unsigned int flags);\n6431 long sys_fsconfig(int fs_fd, unsigned int cmd, const char __user *key, const void __user *value, int aux);\n6432 long sys_fsmount(int fs_fd, unsigned int flags, unsigned int ms_flags);\n6433 long sys_fspick(int dfd, const char __user *path, unsigned int flags);\n6434 long sys_pidfd_open(pid_t pid, unsigned int flags);\n6435 long sys_clone3(struct clone_args __user *uargs, size_t size);\n6437 long sys_openat2(int dfd, const char __user *filename, struct open_how *how, size_t size);\n6438 long sys_pidfd_getfd(int pidfd, int fd, unsigned int flags);\n6439 long sys_faccessat2(int dfd, const char __user *filename, int mode, int flags);\n```\n\n----------------------------------------\n\nTITLE: Protobuf Error Message Example\nDESCRIPTION: Example error message when dealing with protobuf version compatibility issues and suggested workarounds.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/README.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nTypeError: Descriptors cannot be created directly.\nIf this call came from a _pb2.py file, your generated code is out of date and must be regenerated with protoc >= 3.19.0.\nIf you cannot immediately regenerate your protos, some other possible workarounds are:\n 1. Downgrade the protobuf package to 3.20.x or lower.\n 2. Set PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION=python (but this will use pure-Python parsing and will be much slower).\n\nMore information: https://developers.google.com/protocol-buffers/docs/news/2022-05-06#python-updates\n```\n\n----------------------------------------\n\nTITLE: Enabling or Disabling LLVM JIT Compilation in QEMU via C\nDESCRIPTION: These functions switch between the TCG backend and LLVM JIT for binary translation in QEMU. When enabled, code passes through an extra translation step to LLVM IR, then executes on the LLVM JIT, which can be beneficial for analysis and instrumentation. These are parameterless, and enabling/disabling LLVM must occur at startup; dynamic switching is not yet fully supported.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nvoid panda_enable_llvm(void);\n```\n\nLANGUAGE: C\nCODE:\n```\nvoid panda_disable_llvm(void);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API System Call Functions\nDESCRIPTION: This code block declares multiple Windows NT system call functions (NtXxx) that provide direct access to Windows kernel functionality. These functions handle various operations including process management, thread control, memory operations, file I/O, registry access, and debugging. Each function returns an NTSTATUS value to indicate success or failure.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x86_prototypes.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtShutdownWorkerFactory (HANDLE WorkerFactoryHandle, LONG *PendingWorkerCount);\nNTSTATUS NtSignalAndWaitForSingleObject (HANDLE SignalHandle, HANDLE WaitHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtSinglePhaseReject (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtStartProfile (HANDLE ProfileHandle);\nNTSTATUS NtStopProfile (HANDLE ProfileHandle);\nNTSTATUS NtSuspendProcess (HANDLE ProcessHandle);\nNTSTATUS NtSuspendThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtSystemDebugControl (SYSDBG_COMMAND Command, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, PULONG ReturnLength);\nNTSTATUS NtTerminateJobObject (HANDLE JobHandle, NTSTATUS ExitStatus);\nNTSTATUS NtTerminateProcess (HANDLE ProcessHandle, NTSTATUS ExitStatus);\nNTSTATUS NtTerminateThread (HANDLE ThreadHandle, NTSTATUS ExitStatus);\nNTSTATUS NtTestAlert ();\nNTSTATUS NtThawRegistry ();\nNTSTATUS NtThawTransactions ();\nNTSTATUS NtTraceControl (ULONG FunctionCode, PVOID InBuffer, ULONG InBufferLen, PVOID OutBuffer, ULONG OutBufferLen, PULONG ReturnLength);\nNTSTATUS NtTraceEvent (HANDLE TraceHandle, ULONG Flags, ULONG FieldSize, PVOID Fields);\nNTSTATUS NtTranslateFilePath (PFILE_PATH InputFilePath, ULONG OutputType, PFILE_PATH OutputFilePath, PULONG OutputFilePathLength);\nNTSTATUS NtUmsThreadYield (PVOID SchedulerParam);\nNTSTATUS NtUnloadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtUnloadKey (POBJECT_ATTRIBUTES TargetKey);\nNTSTATUS NtUnloadKey2 (POBJECT_ATTRIBUTES TargetKey, ULONG Flags);\nNTSTATUS NtUnloadKeyEx (POBJECT_ATTRIBUTES TargetKey, HANDLE Event);\nNTSTATUS NtUnlockFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key);\nNTSTATUS NtUnlockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtUnmapViewOfSection (HANDLE ProcessHandle, PVOID BaseAddress);\nNTSTATUS NtVdmControl (VDMSERVICECLASS Service, PVOID ServiceData);\nNTSTATUS NtWaitForDebugEvent (HANDLE DebugObjectHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PDBGUI_WAIT_STATE_CHANGE WaitStateChange);\nNTSTATUS NtWaitForKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitForMultipleObjects (ULONG Count, HANDLE Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitForMultipleObjects32 (ULONG Count, LONG Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitForSingleObject (HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWaitForWorkViaWorkerFactory (HANDLE WorkerFactoryHandle, PFILE_IO_COMPLETION_INFORMATION MiniPacket);\nNTSTATUS NtWaitHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtWaitLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtWorkerFactoryWorkerReady (HANDLE WorkerFactoryHandle);\nNTSTATUS NtWriteFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtWriteFileGather (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtWriteRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\nNTSTATUS NtWriteVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\nNTSTATUS NtYieldExecution ();\n```\n\n----------------------------------------\n\nTITLE: Declaring NT System Call Prototypes using C Function Signatures\nDESCRIPTION: This snippet declares a series of NT system call function prototypes in C for the Windows NT Native API. Each function returns an NTSTATUS code and uses standard Windows types such as HANDLE, PVOID, ULONG, and specialized structures. This header allows applications and system utilities to reference native NT functions directly for system programming, provided that they have proper system-level privileges and access. Input and output parameters, as well as structure pointers, provide access to or control over kernel services, but the actual function implementations are provided by the NT kernel, and improper use can lead to instability or access violations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x86_prototypes.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n210 NTSTATUS NtPrivilegeCheck (HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, PBOOLEAN Result);\n211 NTSTATUS NtPrivilegedServiceAuditAlarm (PUNICODE_STRING SubsystemName, PUNICODE_STRING ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\n212 NTSTATUS NtPrivilegeObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\n213 NTSTATUS NtPropagationComplete (HANDLE ResourceManagerHandle, ULONG RequestCookie, ULONG BufferLength, PVOID Buffer);\n214 NTSTATUS NtPropagationFailed (HANDLE ResourceManagerHandle, ULONG RequestCookie, NTSTATUS PropStatus);\n215 NTSTATUS NtProtectVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, WIN32_PROTECTION_MASK NewProtectWin32, PULONG OldProtect);\n216 NTSTATUS NtPulseEvent (HANDLE EventHandle, PLONG PreviousState);\n217 NTSTATUS NtQueryAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);\n218 NTSTATUS NtQueryBootEntryOrder (PULONG Ids, PULONG Count);\n219 NTSTATUS NtQueryBootOptions (PBOOT_OPTIONS BootOptions, PULONG BootOptionsLength);\n220 NTSTATUS NtQueryDebugFilterState (ULONG ComponentId, ULONG Level);\n221 NTSTATUS NtQueryDefaultLocale (BOOLEAN UserProfile, PLCID DefaultLocaleId);\n222 NTSTATUS NtQueryDefaultUILanguage (LANGID *DefaultUILanguageId);\n223 NTSTATUS NtQueryDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);\n224 NTSTATUS NtQueryDirectoryObject (HANDLE DirectoryHandle, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, BOOLEAN RestartScan, PULONG Context, PULONG ReturnLength);\n225 NTSTATUS NtQueryDriverEntryOrder (PULONG Ids, PULONG Count);\n226 NTSTATUS NtQueryEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan);\n227 NTSTATUS NtQueryEvent (HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ReturnLength);\n228 NTSTATUS NtQueryFullAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);\n229 NTSTATUS NtQueryInformationAtom (RTL_ATOM Atom, ATOM_INFORMATION_CLASS InformationClass, PVOID AtomInformation, ULONG AtomInformationLength, PULONG ReturnLength);\n230 NTSTATUS NtQueryInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength, PULONG ReturnLength);\n231 NTSTATUS NtQueryInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\n232 NTSTATUS NtQueryInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength, PULONG ReturnLength);\n233 NTSTATUS NtQueryInformationPort (HANDLE PortHandle, PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\n234 NTSTATUS NtQueryInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);\n235 NTSTATUS NtQueryInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength, PULONG ReturnLength);\n236 NTSTATUS NtQueryInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);\n237 NTSTATUS NtQueryInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);\n238 NTSTATUS NtQueryInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength, PULONG ReturnLength);\n239 NTSTATUS NtQueryInformationTransactionManager (HANDLE TransactionManagerHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength, PULONG ReturnLength);\n240 NTSTATUS NtQueryInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength, PULONG ReturnLength);\n241 NTSTATUS NtQueryInstallUILanguage (LANGID *InstallUILanguageId);\n242 NTSTATUS NtQueryIntervalProfile (KPROFILE_SOURCE ProfileSource, PULONG Interval);\n243 NTSTATUS NtQueryIoCompletion (HANDLE IoCompletionHandle, IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass, PVOID IoCompletionInformation, ULONG IoCompletionInformationLength, PULONG ReturnLength);\n244 NTSTATUS NtQueryKey (HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\n245 NTSTATUS NtQueryLicenseValue (PUNICODE_STRING Name, PULONG Type, PVOID Buffer, ULONG Length, PULONG ReturnedLength);\n246 NTSTATUS NtQueryMultipleValueKey (HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength);\n247 NTSTATUS NtQueryMutant (HANDLE MutantHandle, MUTANT_INFORMATION_CLASS MutantInformationClass, PVOID MutantInformation, ULONG MutantInformationLength, PULONG ReturnLength);\n248 NTSTATUS NtQueryObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);\n249 NTSTATUS NtQueryOpenSubKeys (POBJECT_ATTRIBUTES TargetKey, PULONG HandleCount);\n250 NTSTATUS NtQueryOpenSubKeysEx (POBJECT_ATTRIBUTES TargetKey, ULONG BufferLength, PVOID Buffer, PULONG RequiredSize);\n251 NTSTATUS NtQueryPerformanceCounter (PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);\n252 NTSTATUS NtQueryPortInformationProcess ();\n253 NTSTATUS NtQueryQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID SidList, ULONG SidListLength, PULONG StartSid, BOOLEAN RestartScan);\n254 NTSTATUS NtQuerySection (HANDLE SectionHandle, SECTION_INFORMATION_CLASS SectionInformationClass, PVOID SectionInformation, SIZE_T SectionInformationLength, PSIZE_T ReturnLength);\n255 NTSTATUS NtQuerySecurityAttributesToken (HANDLE TokenHandle, PUNICODE_STRING Attributes, ULONG NumberOfAttributes, PVOID Buffer, ULONG Length, PULONG ReturnLength);\n256 NTSTATUS NtQuerySecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Length, PULONG LengthNeeded);\n257 NTSTATUS NtQuerySemaphore (HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG SemaphoreInformationLength, PULONG ReturnLength);\n258 NTSTATUS NtQuerySymbolicLinkObject (HANDLE LinkHandle, PUNICODE_STRING LinkTarget, PULONG ReturnedLength);\n259 NTSTATUS NtQuerySystemEnvironmentValue (PUNICODE_STRING VariableName, PWSTR VariableValue, USHORT ValueLength, PUSHORT ReturnLength);\n260 NTSTATUS NtQuerySystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, PULONG ValueLength, PULONG Attributes);\n261 NTSTATUS NtQuerySystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\n262 NTSTATUS NtQuerySystemInformationEx (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID QueryInformation, ULONG QueryInformationLength, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\n263 NTSTATUS NtQuerySystemTime (PLARGE_INTEGER SystemTime);\n264 NTSTATUS NtQueryTimer (HANDLE TimerHandle, TIMER_INFORMATION_CLASS TimerInformationClass, PVOID TimerInformation, ULONG TimerInformationLength, PULONG ReturnLength);\n265 NTSTATUS NtQueryTimerResolution (PULONG MaximumTime, PULONG MinimumTime, PULONG CurrentTime);\n266 NTSTATUS NtQueryValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\n267 NTSTATUS NtQueryVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);\n268 NTSTATUS NtQueryVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\n269 NTSTATUS NtQueueApcThread (HANDLE ThreadHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\n270 NTSTATUS NtQueueApcThreadEx (HANDLE ThreadHandle, HANDLE UserApcReserveHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\n271 NTSTATUS NtRaiseException (PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ContextRecord, BOOLEAN FirstChance);\n272 NTSTATUS NtRaiseHardError (NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask, PULONG_PTR Parameters, ULONG ValidResponseOptions, PULONG Response);\n273 NTSTATUS NtReadFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n```\n\n----------------------------------------\n\nTITLE: File Handle and Kernel Module Operations in C\nDESCRIPTION: Function declarations for file handle operations and kernel module management in FreeBSD. These include statfs operations on file handles and functions to load, unload, and query kernel modules.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nint fhstatfs(const struct fhandle *u_fhp, struct ostatfs *buf);\nint fhopen(const struct fhandle *u_fhp, int flags);\nint fhstat(const struct fhandle *u_fhp, struct freebsd11_stat *sb);\nint modnext(int modid);\nint modstat(int modid, struct module_stat *stat);\nint modfnext(int modid);\nint modfind(const char *name);\nint kldload(const char *file);\nint kldunload(int fileid);\nint kldfind(const char *file);\nint kldnext(int fileid);\nint kldstat(int fileid, struct kld_file_stat *stat);\nint kldfirstmod(int fileid);\nint getsid(pid_t pid);\nint setresuid(uid_t ruid, uid_t euid, uid_t suid);\nint setresgid(gid_t rgid, gid_t egid, gid_t sgid);\n```\n\n----------------------------------------\n\nTITLE: Configuring QEMU for Simple Trace Backend in Shell\nDESCRIPTION: This shell command configures the QEMU project to enable the 'simple' trace backend during build configuration and then builds the project. It is used as part of the setup for capturing trace events. Requires the QEMU source code and build dependencies. The first command runs QEMU's configure script with the '--enable-trace-backends=simple' option, and the second compiles the project. Input: none. Output: compiled QEMU binaries with simple trace support.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/tracing.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./configure --enable-trace-backends=simple\nmake\n```\n\n----------------------------------------\n\nTITLE: Cloning and Checking Out PANDA Repository - Bash\nDESCRIPTION: This snippet shows how to clone a specific revision of the PANDA repository from GitHub using the 'git clone' command and checkout a particular commit hash with 'git checkout'. These steps are prerequisites for setting up the PANDA environment to ensure reproducibility of results, as all subsequent instructions and plugin usages rely on this exact version. Dependencies include git itself and a working internet connection. Input is not required beyond the commands; output is a checked-out working directory with the specified PANDA code.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/Starcraft.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/moyix/panda.git\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout 186fcec\n```\n\n----------------------------------------\n\nTITLE: Generating and Freeing Pandalog Call Stack Structures in C\nDESCRIPTION: This snippet demonstrates how to create and free call stack messages in pandalog format using the callstack_instr plugin's API. The creation function allocates a Panda__CallStack object, which encapsulates callstack info; the free function releases associated resources. The caller must ensure proper freeing of objects to avoid memory leaks. Requires the PANDA pandalog and callstack_instr headers, and the library must be initialized prior to calling.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/callstack_instr/README.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n// Create pandalog message for callstack info\nPanda__CallStack *pandalog_callstack_create(void);\n\n// Free a Panda__CallStack struct\nvoid pandalog_callstack_free(Panda__CallStack *cs);\n```\n\n----------------------------------------\n\nTITLE: I/O Multiplexing and Event Notification Prototypes in C\nDESCRIPTION: Function prototypes for Linux system calls related to I/O multiplexing, event notification, and asynchronous I/O operations. These functions provide mechanisms for efficiently handling multiple file descriptors and I/O events.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nlong sys_pselect6(int, fd_set __user *, fd_set __user *, fd_set __user *, struct __kernel_timespec __user *, void __user *);\nlong sys_ppoll(struct pollfd __user *, unsigned int, struct __kernel_timespec __user *, const sigset_t __user *, size_t);\nlong sys_epoll_pwait(int epfd, struct epoll_event __user *events, int maxevents, int timeout, const sigset_t __user *sigmask, size_t sigsetsize);\nlong sys_epoll_create1(int flags);\nlong sys_signalfd(int ufd, sigset_t __user *user_mask, size_t sizemask);\nlong sys_eventfd(unsigned int count);\nlong sys_signalfd4(int ufd, sigset_t __user *user_mask, size_t sizemask, int flags);\nlong sys_eventfd2(unsigned int count, int flags);\nlong sys_io_uring_setup(u32 entries, struct io_uring_params __user *p);\nlong sys_io_uring_enter(unsigned int fd, u32 to_submit, u32 min_complete, u32 flags, const sigset_t __user *sig, size_t sigsz);\nlong sys_io_uring_register(unsigned int fd, unsigned int op, void __user *arg, unsigned int nr_args);\nlong sys_io_pgetevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct __kernel_timespec __user *timeout, const struct __aio_sigset *sig);\n```\n\n----------------------------------------\n\nTITLE: Formatting Target Search Strings for Memory Analysis (Text Example)\nDESCRIPTION: This snippet shows the creation of a plain text file containing target UTF-8-encoded strings in colon-separated hexadecimal. It is used as input for PANDA's stringsearch plugin to look for evidence of specific censorship keywords in emulator memory. Inputs are hex-encoded sensitive terms, each on a new line. Output is a search file consumed by the replay command.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/LINE_Censorship.md#_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\ne5:a4:a9:e5:ae:89:e9:97:a8\\ne6:b3:95:e8:bd:ae\n```\n\n----------------------------------------\n\nTITLE: Reading Ftrace Trace Output in Shell\nDESCRIPTION: This shell command reads and outputs the entire contents of the current ftrace trace buffer, which contains both QEMU and (if enabled) KVM trace data. Requires root privileges and ftrace support. Input: none. Output: raw trace buffer printed to standard output.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/tracing.txt#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n# cat /sys/kernel/debug/tracing/trace\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Calls in C\nDESCRIPTION: This snippet contains function declarations for various Windows NT system calls. These functions are part of the Native API and are used for low-level system operations such as process creation, file handling, and registry manipulation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2003sp12_x64_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateProfile (PHANDLE ProfileHandle, HANDLE Process, PVOID RangeBase, SIZE_T RangeSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);\nNTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);\nNTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);\nNTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);\nNTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);\nNTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtDebugActiveProcess (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtDebugContinue (HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);\nNTSTATUS NtDeleteAtom (RTL_ATOM Atom);\nNTSTATUS NtDeleteBootEntry (ULONG Id);\nNTSTATUS NtDeleteDriverEntry (ULONG Id);\nNTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtDeleteKey (HANDLE KeyHandle);\nNTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);\nNTSTATUS NtDisplayString (PUNICODE_STRING String);\nNTSTATUS NtEnumerateBootEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateDriverEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateSystemEnvironmentValuesEx (ULONG InformationClass, PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);\nNTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);\nNTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);\nNTSTATUS NtFlushKey (HANDLE KeyHandle);\nNTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);\nNTSTATUS NtFlushWriteBuffer ();\nNTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nULONG NtGetCurrentProcessorNumber ();\nNTSTATUS NtGetDevicePowerState (HANDLE Device, DEVICE_POWER_STATE *State);\nNTSTATUS NtGetPlugPlayEvent (HANDLE EventHandle, PVOID Context, PPLUGPLAY_EVENT_BLOCK EventBlock, ULONG EventBufferSize);\nNTSTATUS NtGetWriteWatch (HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, SIZE_T RegionSize, PVOID *UserAddressArray, PULONG_PTR EntriesInUserAddressArray, PULONG Granularity);\nNTSTATUS NtImpersonateAnonymousToken (HANDLE ThreadHandle);\nNTSTATUS NtImpersonateThread (HANDLE ServerThreadHandle, HANDLE ClientThreadHandle, PSECURITY_QUALITY_OF_SERVICE SecurityQos);\nNTSTATUS NtInitializeRegistry (USHORT BootCondition);\nNTSTATUS NtInitiatePowerAction (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);\nBOOLEAN NtIsSystemResumeAutomatic ();\nNTSTATUS NtListenPort (HANDLE PortHandle, PPORT_MESSAGE ConnectionRequest);\nNTSTATUS NtLoadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtLoadKey (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile);\nNTSTATUS NtLoadKey2 (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags);\nNTSTATUS NtLoadKeyEx (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags, HANDLE TrustClassKey );\nNTSTATUS NtLockFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);\nNTSTATUS NtLockProductActivationKeys (ULONG *pPrivateVer, ULONG *pSafeMode);\nNTSTATUS NtLockRegistryKey (HANDLE KeyHandle);\nNTSTATUS NtLockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtMakePermanentObject (HANDLE Handle);\nNTSTATUS NtMakeTemporaryObject (HANDLE Handle);\nNTSTATUS NtMapUserPhysicalPages (PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtModifyBootEntry (PBOOT_ENTRY BootEntry);\nNTSTATUS NtModifyDriverEntry (PEFI_DRIVER_ENTRY DriverEntry);\nNTSTATUS NtNotifyChangeDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree);\nNTSTATUS NtNotifyChangeKey (HANDLE KeyHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtNotifyChangeMultipleKeys (HANDLE MasterKeyHandle, ULONG Count, OBJECT_ATTRIBUTES SlaveObjects[], HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtOpenEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, ACCESS_MASK GrantedAccess, PPRIVILEGE_SET Privileges, BOOLEAN ObjectCreation, BOOLEAN AccessGranted, PBOOLEAN GenerateOnClose);\nNTSTATUS NtOpenProcessToken (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);\nNTSTATUS NtOpenSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtPlugPlayControl (PLUGPLAY_CONTROL_CLASS PnPControlClass, PVOID PnPControlData, ULONG PnPControlDataLength);\nNTSTATUS NtPrivilegeCheck (HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, PBOOLEAN Result);\nNTSTATUS NtPrivilegeObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\nNTSTATUS NtPrivilegedServiceAuditAlarm (PUNICODE_STRING SubsystemName, PUNICODE_STRING ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\nNTSTATUS NtPulseEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtQueryBootEntryOrder (PULONG Ids, PULONG Count);\nNTSTATUS NtQueryBootOptions (PBOOT_OPTIONS BootOptions, PULONG BootOptionsLength);\nNTSTATUS NtQueryDebugFilterState (ULONG ComponentId, ULONG Level);\nNTSTATUS NtQueryDirectoryObject (HANDLE DirectoryHandle, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, BOOLEAN RestartScan, PULONG Context, PULONG ReturnLength);\nNTSTATUS NtQueryDriverEntryOrder (PULONG Ids, PULONG Count);\nNTSTATUS NtQueryEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan);\nNTSTATUS NtQueryFullAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);\nNTSTATUS NtQueryInformationAtom (RTL_ATOM Atom, ATOM_INFORMATION_CLASS InformationClass, PVOID AtomInformation, ULONG AtomInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationPort (HANDLE PortHandle, PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtQueryInstallUILanguage (LANGID *InstallUILanguageId);\nNTSTATUS NtQueryIntervalProfile (KPROFILE_SOURCE ProfileSource, PULONG Interval);\nNTSTATUS NtQueryIoCompletion (HANDLE IoCompletionHandle, IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass, PVOID IoCompletionInformation, ULONG IoCompletionInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryMultipleValueKey (HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength);\n```\n\n----------------------------------------\n\nTITLE: Signal Handling and ACL Functions in C\nDESCRIPTION: Function declarations for signal management and access control list (ACL) operations. Includes functions for manipulating signal masks, waiting for signals, handling actions, and managing file ACLs.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nint nnpfs_syscall(int operation, char *a_pathP, int a_opcode, void *a_paramsP, int a_followSymlinks);\nint sigprocmask(int how, const sigset_t *set, sigset_t *oset);\nint sigsuspend(const sigset_t *sigmask);\nint sigaction(int sig, const struct sigaction *act, struct sigaction *oact);\nint sigpending(sigset_t *set);\nint sigreturn(const struct ucontext4 *sigcntxp);\nint sigtimedwait(const sigset_t *set, siginfo_t *info, const struct timespec *timeout);\nint sigwaitinfo(const sigset_t *set, siginfo_t *info);\nint __acl_get_file(const char *path, acl_type_t type, struct acl *aclp);\nint __acl_set_file(const char *path, acl_type_t type, struct acl *aclp);\nint __acl_get_fd(int filedes, acl_type_t type, struct acl *aclp);\nint __acl_set_fd(int filedes, acl_type_t type, struct acl *aclp);\nint __acl_delete_file(const char *path, acl_type_t type);\nint __acl_delete_fd(int filedes, acl_type_t type);\nint __acl_aclcheck_file(const char *path, acl_type_t type, struct acl *aclp);\nint __acl_aclcheck_fd(int filedes, acl_type_t type, struct acl *aclp);\n```\n\n----------------------------------------\n\nTITLE: Memory Management System Call Declarations in C\nDESCRIPTION: Function declarations for Linux system calls related to memory operations. These declarations define the interface for memory allocation, mapping, synchronization, and protection mechanisms.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_19\n\nLANGUAGE: C\nCODE:\n```\nlong sys_mremap(unsigned long addr, unsigned long old_len, unsigned long new_len, unsigned long flags, unsigned long new_addr);\nlong sys_msync(unsigned long start, size_t len, int flags);\nlong sys_mincore(unsigned long start, size_t len, unsigned char __user *vec);\nlong sys_madvise(unsigned long start, size_t len, int behavior);\nlong sys_mlock(unsigned long start, size_t len);\nlong sys_munlock(unsigned long start, size_t len);\nlong sys_mlockall(int flags);\nlong sys_munlockall(void);\n```\n\n----------------------------------------\n\nTITLE: Assigning QEMU Floppy Drives via -global Option (QEMU CLI, Shell)\nDESCRIPTION: Shows how to connect virtual floppy drives to the ISA floppy controller using -global options, instead of -device. Only two drives (A, B) are supported via isa-fdc.driveA/driveB. Dependencies: QEMU process with floppy controller. Input is the global assignment; output is attachment of the drive(s) to the controller.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n-global isa-fdc.driveA=DRIVE-ID\n-global isa-fdc.driveB=DRIVE-ID\n```\n\n----------------------------------------\n\nTITLE: QED Header Structure Definition in C\nDESCRIPTION: C structure defining the header format for QED disk images, containing magic number, size specifications, feature flags, and backing file information.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/qed_spec.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nHeader {\n    uint32_t magic;               /* QED\\0 */\n\n    uint32_t cluster_size;        /* in bytes */\n    uint32_t table_size;          /* for L1 and L2 tables, in clusters */\n    uint32_t header_size;         /* in clusters */\n\n    uint64_t features;            /* format feature bits */\n    uint64_t compat_features;     /* compat feature bits */\n    uint64_t autoclear_features;  /* self-resetting feature bits */\n\n    uint64_t l1_table_offset;     /* in bytes */\n    uint64_t image_size;          /* total logical image size, in bytes */\n\n    /* if (features & QED_F_BACKING_FILE) */\n    uint32_t backing_filename_offset; /* in bytes from start of header */\n    uint32_t backing_filename_size;   /* in bytes */\n}\n```\n\n----------------------------------------\n\nTITLE: File Operation System Calls in C\nDESCRIPTION: System call declarations for file operations including chown, unlink, rename, symlink and chmod operations with file descriptor support\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_arm_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nlong sys_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group, int flag);\nlong sys_futimesat(int dfd, const char __user *filename, struct timeval __user *utimes);\nlong sys_fstatat64(int dfd, const char __user *filename, struct stat64 __user *statbuf, int flag);\nlong sys_unlinkat(int dfd, const char __user *pathname, int flag);\nlong sys_renameat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname);\n```\n\n----------------------------------------\n\nTITLE: Defining Event Polling and Timer System Calls in C\nDESCRIPTION: Function declarations for Linux system calls related to event polling (epoll), timer operations, and clock management. These calls provide mechanisms for efficient event handling, timing, and synchronization in applications.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_29\n\nLANGUAGE: C\nCODE:\n```\nlong sys_epoll_create(int size);\nlong sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user *event);\nlong sys_epoll_wait(int epfd, struct epoll_event __user *events, int maxevents, int timeout);\nlong sys_timerfd_create(int clockid, int flags);\nlong sys_timer_settime32(timer_t timer_id, int flags, struct old_itimerspec32 __user *new, struct old_itimerspec32 __user *old);\nlong sys_timer_gettime32(timer_t timer_id, struct old_itimerspec32 __user *setting);\nlong sys_timer_getoverrun(timer_t timer_id);\nlong sys_timer_delete(timer_t timer_id);\nlong sys_clock_settime32(clockid_t which_clock, struct old_timespec32 __user *tp);\nlong sys_clock_gettime32(clockid_t which_clock, struct old_timespec32 __user *tp);\nlong sys_clock_getres_time32(clockid_t which_clock, struct old_timespec32 __user *tp);\nlong sys_clock_nanosleep_time32(clockid_t which_clock, int flags, struct old_timespec32 __user *rqtp, struct old_timespec32 __user *rmtp);\nlong sys_epoll_pwait(int epfd, struct epoll_event __user *events, int maxevents, int timeout, const sigset_t __user *sigmask, size_t sigsetsize);\nlong sys_epoll_create1(int flags);\nlong sys_timerfd_gettime32(int ufd, struct old_itimerspec32 __user *otmr);\nlong sys_timerfd_settime32(int ufd, int flags, const struct old_itimerspec32 __user *utmr, struct old_itimerspec32 __user *otmr);\n```\n\n----------------------------------------\n\nTITLE: Defining File and Registry System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to file and registry key operations. These functions handle deletion of files, registry keys, and related operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_17\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtDeleteKey (HANDLE KeyHandle);\nNTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtDeletePrivateNamespace (HANDLE NamespaceHandle);\nNTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);\n```\n\n----------------------------------------\n\nTITLE: Starting NBD Server on Secondary VM - QEMU Machine Protocol - JSON\nDESCRIPTION: This QMP command sequence starts the built-in NBD server in Secondary QEMU and exposes the replicated disk for network access. The first command starts the NBD server, specifying address type, host, and port. The second adds an export for the disk (by device ID), making it writable. Prerequisites: QEMU compiled with NBD support, export device must exist, and address details must match primary configuration.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/block-replication.txt#_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n{ 'execute': 'nbd-server-start',\n  'arguments': {\n      'addr': {\n          'type': 'inet',\n          'data': {\n              'host': 'xxx',\n              'port': 'xxx'\n          }\n      }\n  }\n}\n```\n\nLANGUAGE: JSON\nCODE:\n```\n{ 'execute': 'nbd-server-add',\n  'arguments': {\n      'device': 'colo1',\n      'writable': true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating and Logging Stack and Environment Memory - LLVM IR\nDESCRIPTION: This snippet handles pointer dereferencing, arithmetic transformations, bitwise masking, and value truncation/extension for stack and environment memory addresses. It invokes PANDA-specific functions to log and store values, demonstrating stack slot updating and environment pointer arithmetics. Dependencies include custom logging and memory access functions. Key parameters manipulate addresses and values for precise instrumentation. Resulting changes are persisted in emulated memory/register state.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/dynslice.md#_snippet_6\n\nLANGUAGE: llvm\nCODE:\n```\n%rsp_v = load i64* %rsp_ptr\n```\n\nLANGUAGE: llvm\nCODE:\n```\n%tmp2_v3 = add i64 %rsp_v, -4\n```\n\nLANGUAGE: llvm\nCODE:\n```\n%tmp2_v4 = and i64 %tmp2_v3, 4294967295\n%24 = trunc i64 %tmp0_v to i32\ncall void @__stl_mmu_panda(i64 %tmp2_v4, i32 %24, i32 1)\n```\n\n----------------------------------------\n\nTITLE: Adding Replication Driver via QMP Command - QEMU Machine Protocol - JSON\nDESCRIPTION: This JSON snippet illustrates issuing a QEMU Machine Protocol (QMP) command to add a replication driver in 'primary' mode to a running QEMU instance. Dependencies include a running QEMU process with QMP enabled and prior setup of the required NBD (Network Block Device) target. Parameters specify the connection to the secondary host (file.host/file.port), export name, and node name. The command should be run after configuring the secondary, ensuring only one NBD client per disk.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/block-replication.txt#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{ 'execute': 'human-monitor-command',\n  'arguments': {\n      'command-line': 'drive_add -n buddy driver=replication,mode=primary,file.driver=nbd,file.host=xxxx,file.port=xxxx,file.export=colo1,node-name=nbd_client1'\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native Query/Set Functions - C\nDESCRIPTION: This snippet provides C-language prototypes for native Windows functions starting with NtQuery* and NtSet* related to transactions, keys, worker factories, ports, profiles, and more. Each function receives input/output handles and structures, usually requires correct type/length/capacity, and returns an NTSTATUS code indicating success or error. Usage requires windows headers and linking against ntdll or the correct native subsystem; these APIs are reserved for advanced or privileged code, and improper use can severely affect system stability.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp0_x64_prototypes.txt#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationTransactionManager (HANDLE TransactionManagerHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInstallUILanguage (LANGID *InstallUILanguageId);\nNTSTATUS NtQueryIntervalProfile (KPROFILE_SOURCE ProfileSource, PULONG Interval);\nNTSTATUS NtQueryIoCompletion (HANDLE IoCompletionHandle, IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass, PVOID IoCompletionInformation, ULONG IoCompletionInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryLicenseValue (PUNICODE_STRING Name, PULONG Type, PVOID Buffer, ULONG Length, PULONG ReturnedLength);\nNTSTATUS NtQueryMultipleValueKey (HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength);\nNTSTATUS NtQueryMutant (HANDLE MutantHandle, MUTANT_INFORMATION_CLASS MutantInformationClass, PVOID MutantInformation, ULONG MutantInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryOpenSubKeys (POBJECT_ATTRIBUTES TargetKey, PULONG HandleCount);\nNTSTATUS NtQueryOpenSubKeysEx (POBJECT_ATTRIBUTES TargetKey, ULONG BufferLength, PVOID Buffer, PULONG RequiredSize);\nNTSTATUS NtQueryPortInformationProcess ();\nNTSTATUS NtQueryQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID SidList, ULONG SidListLength, PULONG StartSid, BOOLEAN RestartScan);\nNTSTATUS NtQuerySecurityAttributesToken (HANDLE TokenHandle, PUNICODE_STRING Attributes, ULONG NumberOfAttributes, PVOID Buffer, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtQuerySecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Length, PULONG LengthNeeded);\nNTSTATUS NtQuerySemaphore (HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG SemaphoreInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySymbolicLinkObject (HANDLE LinkHandle, PUNICODE_STRING LinkTarget, PULONG ReturnedLength);\nNTSTATUS NtQuerySystemEnvironmentValue (PUNICODE_STRING VariableName, PWSTR VariableValue, USHORT ValueLength, PUSHORT ReturnLength);\nNTSTATUS NtQuerySystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, PULONG ValueLength, PULONG Attributes);\nNTSTATUS NtQuerySystemInformationEx (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID QueryInformation, ULONG QueryInformationLength, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryTimerResolution (PULONG MaximumTime, PULONG MinimumTime, PULONG CurrentTime);\nNTSTATUS NtQueueApcThreadEx (HANDLE ThreadHandle, HANDLE UserApcReserveHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\nNTSTATUS NtRaiseException (PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ContextRecord, BOOLEAN FirstChance);\nNTSTATUS NtRaiseHardError (NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask, PULONG_PTR Parameters, ULONG ValidResponseOptions, PULONG Response);\nNTSTATUS NtReadOnlyEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRecoverEnlistment (HANDLE EnlistmentHandle, PVOID EnlistmentKey);\nNTSTATUS NtRecoverResourceManager (HANDLE ResourceManagerHandle);\nNTSTATUS NtRecoverTransactionManager (HANDLE TransactionManagerHandle);\nNTSTATUS NtRegisterProtocolAddressInformation (HANDLE ResourceManager, PCRM_PROTOCOL_ID ProtocolId, ULONG ProtocolInformationSize, PVOID ProtocolInformation, ULONG CreateOptions);\nNTSTATUS NtRegisterThreadTerminatePort (HANDLE PortHandle);\nNTSTATUS NtReleaseKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtReleaseWorkerFactoryWorker (HANDLE WorkerFactoryHandle);\nNTSTATUS NtRemoveIoCompletionEx (HANDLE IoCompletionHandle, PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation, ULONG Count, PULONG NumEntriesRemoved, PLARGE_INTEGER Timeout, BOOLEAN Alertable);\nNTSTATUS NtRemoveProcessDebug (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtRenameKey (HANDLE KeyHandle, PUNICODE_STRING NewName);\nNTSTATUS NtRenameTransactionManager (PUNICODE_STRING LogFileName, LPGUID ExistingTransactionManagerGuid);\nNTSTATUS NtReplaceKey (POBJECT_ATTRIBUTES NewFile, HANDLE TargetHandle, POBJECT_ATTRIBUTES OldFile);\nNTSTATUS NtReplacePartitionUnit (PUNICODE_STRING TargetInstancePath, PUNICODE_STRING SpareInstancePath, ULONG Flags);\nNTSTATUS NtReplyWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtRequestPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage);\nNTSTATUS NtResetEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtResetWriteWatch (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T RegionSize);\nNTSTATUS NtRestoreKey (HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags);\nNTSTATUS NtResumeProcess (HANDLE ProcessHandle);\nNTSTATUS NtRollbackComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRollbackEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRollbackTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\nNTSTATUS NtRollforwardTransactionManager (HANDLE TransactionManagerHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtSaveKey (HANDLE KeyHandle, HANDLE FileHandle);\nNTSTATUS NtSaveKeyEx (HANDLE KeyHandle, HANDLE FileHandle, ULONG Format);\nNTSTATUS NtSaveMergedKeys (HANDLE HighPrecedenceKeyHandle, HANDLE LowPrecedenceKeyHandle, HANDLE FileHandle);\nNTSTATUS NtSecureConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PSID RequiredServerSid, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\nNTSTATUS NtSerializeBoot ();\nNTSTATUS NtSetBootEntryOrder (PULONG Ids, ULONG Count);\nNTSTATUS NtSetBootOptions (PBOOT_OPTIONS BootOptions, ULONG FieldsToChange);\nNTSTATUS NtSetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nNTSTATUS NtSetDebugFilterState (ULONG ComponentId, ULONG Level, BOOLEAN State);\nNTSTATUS NtSetDefaultHardErrorPort (HANDLE DefaultHardErrorPort);\nNTSTATUS NtSetDefaultLocale (BOOLEAN UserProfile, LCID DefaultLocaleId);\nNTSTATUS NtSetDefaultUILanguage (LANGID DefaultUILanguageId);\nNTSTATUS NtSetDriverEntryOrder (PULONG Ids, ULONG Count);\nNTSTATUS NtSetEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\nNTSTATUS NtSetHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetHighWaitLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetInformationDebugObject (HANDLE DebugObjectHandle, DEBUGOBJECTINFOCLASS DebugObjectInformationClass, PVOID DebugInformation, ULONG DebugInformationLength, PULONG ReturnLength);\nNTSTATUS NtSetInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength);\nNTSTATUS NtSetInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength);\nNTSTATUS NtSetInformationKey (HANDLE KeyHandle, KEY_SET_INFORMATION_CLASS KeySetInformationClass, PVOID KeySetInformation, ULONG KeySetInformationLength);\nNTSTATUS NtSetInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength);\nNTSTATUS NtSetInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength);\nNTSTATUS NtSetInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength);\nNTSTATUS NtSetInformationTransactionManager (HANDLE TmHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength);\nNTSTATUS NtSetInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength);\nNTSTATUS NtSetIntervalProfile (ULONG Interval, KPROFILE_SOURCE Source);\nNTSTATUS NtSetIoCompletion (HANDLE IoCompletionHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);\nNTSTATUS NtSetIoCompletionEx (HANDLE IoCompletionHandle, HANDLE IoCompletionReserveHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);\nNTSTATUS NtSetLdtEntries (ULONG Selector0, ULONG Entry0Low, ULONG Entry0Hi, ULONG Selector1, ULONG Entry1Low, ULONG Entry1Hi);\nNTSTATUS NtSetLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetLowWaitHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\nNTSTATUS NtSetSecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);\n```\n\n----------------------------------------\n\nTITLE: Using Memory Barrier Atomic Primitives for Volatile Semantics in QEMU (C)\nDESCRIPTION: This code presents atomic_mb_read and atomic_mb_set for enforcing Java-like volatile semantics and strong memory ordering. atomic_mb_read(ptr) retrieves a value with a subsequent acquire barrier, and atomic_mb_set(ptr, val) stores a value with a prior release barrier, making them suitable for shared variables accessed without locks by multiple threads. These macros are defined in qemu/atomic.h, operate on any int-width or smaller types, and must be applied to the same variable for correct semantics. Excessive use may introduce unnecessary performance costs due to memory barriers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/atomics.txt#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\ntypeof(*ptr) atomic_mb_read(ptr)\nvoid         atomic_mb_set(ptr, val)\n```\n\n----------------------------------------\n\nTITLE: Implementing RCU-Protected Data Structure in C\nDESCRIPTION: Example showing how to add an rcu_head structure to a data structure for use with RCU synchronization. This allows the structure to be protected by RCU and safely reclaimed when no longer needed.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/rcu.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct foo {\n    struct rcu_head rcu;\n    int a;\n    char b;\n    long c;\n};\n```\n\n----------------------------------------\n\nTITLE: Extracting TLS Ciphersuite ID from PCAP with Tshark (Shell)\nDESCRIPTION: This shell command utilizes tshark to extract the TLS ciphersuite identifier from a packet capture file. It filters for handshake packets, outputs relevant ciphersuite fields, and results in the ciphersuite ID needed for subsequent steps. Required dependency: tshark. Input: capture.pcap file; Output: ciphersuite IDs printed to stdout. This is a prerequisite for configuring the keyfind plugin when the name of the ciphersuite is not known.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/keyfind/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ tshark -Y \"ssl.handshake.type == 2\" -V -e tls.handshake.ciphersuite -Tfields -nr capture.pcap\n```\n\n----------------------------------------\n\nTITLE: Recording Port to I/O Buffer Transfer (Long)\nDESCRIPTION: Code from ide_data_writel that records 4-byte transfers from port to I/O buffer, similar to the word (2-byte) transfer but with different size.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/hd_taint.txt#_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nrr_record_hd_transfer\n  (RR_CALLSITE_IDE_DATA_WRITEL,\n   HD_TRANSFER_PORT_TO_IOB,\n   (uint64_t) s->data_ptr, 4);\n```\n\n----------------------------------------\n\nTITLE: Declaring Get Modules Callback Typedef in C\nDESCRIPTION: Declares a typedef for an OSI provider callback to enumerate loaded kernel modules (or process modules) in the guest OS. The function receives CPUState and populates a GArray with OsiModule entries, using g_array_free for cleanup. Key for analysis of loaded binary code in OS introspection.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi/README.md#_snippet_10\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_get_modules_t)(CPUState *, GArray **)\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API Syscall Prototypes in C\nDESCRIPTION: This code snippet defines C-language prototypes for multiple Windows NT Native API (commonly called Zw/Nt) functions, each of which provides a direct gateway to kernel-mode operations such as process, file, registry, and system management. These prototypes require inclusion of types such as NTSTATUS, HANDLE, PLARGE_INTEGER, and others typically provided by Windows SDK headers. Input parameters are often pointers to structures or buffers, and outputs generally follow Windows conventions for reporting status (via NTSTATUS) and returning results through output arguments. These declarations are intended for use in system programming, custom runtime libraries, or reverse-engineering tools that need to invoke undocumented or low-level Windows functionality. Appropriate privileges, careful parameter validation, and an understanding of the underlying Windows kernel subsystems are necessary when using these APIs.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/all_windows_prototypes.txt#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtReleaseKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtReleaseMutant (HANDLE MutantHandle, PLONG PreviousCount);\nNTSTATUS NtReleaseSemaphore (HANDLE SemaphoreHandle, LONG ReleaseCount, PLONG PreviousCount);\nNTSTATUS NtReleaseWorkerFactoryWorker (HANDLE WorkerFactoryHandle);\nNTSTATUS NtRemoveIoCompletion (HANDLE IoCompletionHandle, PVOID *KeyContext, PVOID *ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER Timeout);\nNTSTATUS NtRemoveIoCompletionEx (HANDLE IoCompletionHandle, PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation, ULONG Count, PULONG NumEntriesRemoved, PLARGE_INTEGER Timeout, BOOLEAN Alertable);\nNTSTATUS NtRemoveProcessDebug (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtRenameKey (HANDLE KeyHandle, PUNICODE_STRING NewName);\nNTSTATUS NtRenameTransactionManager (PUNICODE_STRING LogFileName, LPGUID ExistingTransactionManagerGuid);\nNTSTATUS NtReplaceKey (POBJECT_ATTRIBUTES NewFile, HANDLE TargetHandle, POBJECT_ATTRIBUTES OldFile);\nNTSTATUS NtReplacePartitionUnit (PUNICODE_STRING TargetInstancePath, PUNICODE_STRING SpareInstancePath, ULONG Flags);\nNTSTATUS NtReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtReplyWaitReceivePort (HANDLE PortHandle, PVOID *PortContext , PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage);\nNTSTATUS NtReplyWaitReceivePortEx (HANDLE PortHandle, PVOID *PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage, PLARGE_INTEGER Timeout);\nNTSTATUS NtReplyWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtRequestPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage);\nNTSTATUS NtRequestWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtResetEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtResetWriteWatch (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T RegionSize);\nNTSTATUS NtRestoreKey (HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags);\nNTSTATUS NtResumeProcess (HANDLE ProcessHandle);\nNTSTATUS NtResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtRollbackComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRollbackEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRollbackTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\nNTSTATUS NtRollforwardTransactionManager (HANDLE TransactionManagerHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtSaveKey (HANDLE KeyHandle, HANDLE FileHandle);\nNTSTATUS NtSaveKeyEx (HANDLE KeyHandle, HANDLE FileHandle, ULONG Format);\nNTSTATUS NtSaveMergedKeys (HANDLE HighPrecedenceKeyHandle, HANDLE LowPrecedenceKeyHandle, HANDLE FileHandle);\nNTSTATUS NtSecureConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PSID RequiredServerSid, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\nNTSTATUS NtSerializeBoot ();\nNTSTATUS NtSetBootEntryOrder (PULONG Ids, ULONG Count);\nNTSTATUS NtSetBootOptions (PBOOT_OPTIONS BootOptions, ULONG FieldsToChange);\nNTSTATUS NtSetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nNTSTATUS NtSetDebugFilterState (ULONG ComponentId, ULONG Level, BOOLEAN State);\nNTSTATUS NtSetDefaultHardErrorPort (HANDLE DefaultHardErrorPort);\nNTSTATUS NtSetDefaultLocale (BOOLEAN UserProfile, LCID DefaultLocaleId);\nNTSTATUS NtSetDefaultUILanguage (LANGID DefaultUILanguageId);\nNTSTATUS NtSetDriverEntryOrder (PULONG Ids, ULONG Count);\nNTSTATUS NtSetEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\nNTSTATUS NtSetEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtSetEventBoostPriority (HANDLE EventHandle);\nNTSTATUS NtSetHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetHighWaitLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetInformationDebugObject (HANDLE DebugObjectHandle, DEBUGOBJECTINFOCLASS DebugObjectInformationClass, PVOID DebugInformation, ULONG DebugInformationLength, PULONG ReturnLength);\nNTSTATUS NtSetInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength);\nNTSTATUS NtSetInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\nNTSTATUS NtSetInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength);\nNTSTATUS NtSetInformationKey (HANDLE KeyHandle, KEY_SET_INFORMATION_CLASS KeySetInformationClass, PVOID KeySetInformation, ULONG KeySetInformationLength);\nNTSTATUS NtSetInformationObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength);\nNTSTATUS NtSetInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);\nNTSTATUS NtSetInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength);\nNTSTATUS NtSetInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);\nNTSTATUS NtSetInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength);\nNTSTATUS NtSetInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength);\nNTSTATUS NtSetInformationTransactionManager (HANDLE TmHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength);\nNTSTATUS NtSetInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength);\nNTSTATUS NtSetIntervalProfile (ULONG Interval, KPROFILE_SOURCE Source);\nNTSTATUS NtSetIoCompletion (HANDLE IoCompletionHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);\nNTSTATUS NtSetIoCompletionEx (HANDLE IoCompletionHandle, HANDLE IoCompletionReserveHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);\nNTSTATUS NtSetLdtEntries (ULONG Selector0, ULONG Entry0Low, ULONG Entry0Hi, ULONG Selector1, ULONG Entry1Low, ULONG Entry1Hi);\nNTSTATUS NtSetLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetLowWaitHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\nNTSTATUS NtSetSecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);\nNTSTATUS NtSetSystemEnvironmentValue (PUNICODE_STRING VariableName, PUNICODE_STRING VariableValue);\nNTSTATUS NtSetSystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, ULONG ValueLength, ULONG Attributes);\nNTSTATUS NtSetSystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);\nNTSTATUS NtSetSystemPowerState (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags);\nNTSTATUS NtSetSystemTime (PLARGE_INTEGER SystemTime, PLARGE_INTEGER PreviousTime);\nNTSTATUS NtSetThreadExecutionState (EXECUTION_STATE esFlags, PEXECUTION_STATE PreviousFlags);\nNTSTATUS NtSetTimer (HANDLE TimerHandle, PLARGE_INTEGER DueTime, PTIMER_APC_ROUTINE TimerApcRoutine, PVOID TimerContext, BOOLEAN WakeTimer, LONG Period, PBOOLEAN PreviousState);\nNTSTATUS NtSetTimerEx (HANDLE TimerHandle, TIMER_SET_INFORMATION_CLASS TimerSetInformationClass, PVOID TimerSetInformation, ULONG TimerSetInformationLength);\nNTSTATUS NtSetTimerResolution (ULONG DesiredTime, BOOLEAN SetResolution, PULONG ActualTime);\nNTSTATUS NtSetUuidSeed (PCHAR Seed);\nNTSTATUS NtSetValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);\nNTSTATUS NtSetVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtShutdownSystem (SHUTDOWN_ACTION Action);\nNTSTATUS NtShutdownWorkerFactory (HANDLE WorkerFactoryHandle, LONG *PendingWorkerCount);\nNTSTATUS NtSignalAndWaitForSingleObject (HANDLE SignalHandle, HANDLE WaitHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtSinglePhaseReject (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtStartProfile (HANDLE ProfileHandle);\nNTSTATUS NtStopProfile (HANDLE ProfileHandle);\nNTSTATUS NtSuspendProcess (HANDLE ProcessHandle);\nNTSTATUS NtSuspendThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtSystemDebugControl (SYSDBG_COMMAND Command, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, PULONG ReturnLength);\nNTSTATUS NtTerminateJobObject (HANDLE JobHandle, NTSTATUS ExitStatus);\nNTSTATUS NtTerminateProcess (HANDLE ProcessHandle, NTSTATUS ExitStatus);\nNTSTATUS NtTerminateThread (HANDLE ThreadHandle, NTSTATUS ExitStatus);\nNTSTATUS NtTestAlert ();\nNTSTATUS NtThawRegistry ();\nNTSTATUS NtThawTransactions ();\nNTSTATUS NtTraceControl (ULONG FunctionCode, PVOID InBuffer, ULONG InBufferLen, PVOID OutBuffer, ULONG OutBufferLen, PULONG ReturnLength);\nNTSTATUS NtTraceEvent (HANDLE TraceHandle, ULONG Flags, ULONG FieldSize, PVOID Fields);\nNTSTATUS NtTranslateFilePath (PFILE_PATH InputFilePath, ULONG OutputType, PFILE_PATH OutputFilePath, PULONG OutputFilePathLength);\nNTSTATUS NtUmsThreadYield (PVOID SchedulerParam);\n```\n\n----------------------------------------\n\nTITLE: Live Block Copy Commands in QEMU\nDESCRIPTION: Two-step process for copying an in-use image to a new destination, involving creating a live snapshot and then streaming to that image.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/live-block-ops.txt#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n(qemu) snapshot_blkdev ide0-hd0 /new-path/disk.img qcow2\n\n(qemu) block_stream ide0-hd0\n```\n\n----------------------------------------\n\nTITLE: Creating Certificates with NSS for Smart Card Emulation - Shell\nDESCRIPTION: This block walks through the creation of a new directory, database initialization, and generation of a root CA and three user certificates for QEMU smartcard emulation, using the NSS 'certutil' tool. Prerequisites are the NSS tools installed, and execution within the intended working directory. The parameters '-d', '-s', and '-n' specify the location and properties of each certificate. Output is a populated NSS database with the necessary certificates, to be used by QEMU for smartcard emulation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/ccid.txt#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nmkdir fake-smartcard\ncd fake-smartcard\ncertutil -N -d sql:$PWD\ncertutil -S -d sql:$PWD -s \"CN=Fake Smart Card CA\" -x -t TC,TC,TC -n fake-smartcard-ca\ncertutil -S -d sql:$PWD -t ,, -s \"CN=John Doe\" -n id-cert -c fake-smartcard-ca\ncertutil -S -d sql:$PWD -t ,, -s \"CN=John Doe (signing)\" --nsCertType smime -n signing-cert -c fake-smartcard-ca\ncertutil -S -d sql:$PWD -t ,, -s \"CN=John Doe (encryption)\" --nsCertType sslClient -n encryption-cert -c fake-smartcard-ca\n```\n\n----------------------------------------\n\nTITLE: Logging Simple Syscall Parameters - PANDALOG Output - JSON\nDESCRIPTION: This code snippet shows a sample PANDALOG log entry in JSON format representing a simple system call parameter logging event for sys_newuname where only primitive argument types (a struct pointer) are recorded. No structure decoding occurs. The snippet describes the log schema used by the syscall_logger plugin and the types of fields reported, including context such as process/thread information, system call name, return code, and argument pointers. There are no required dependencies except that the plugin must run under PANDA with standard configuration; no special arguments needed.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls_logger/README.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"pc\": \"1996222360\",\n  \"instr\": \"0\",\n  \"asid\": \"4294967295\",\n  \"syscall\": {\n    \"pid\": 1,\n    \"ppid\": 0,\n    \"tid\": 1,\n    \"createTime\": \"180000000\",\n    \"retcode\": \"0\",\n    \"callName\": \"sys_newuname\",\n    \"args\": [\n      {\n        \"argName\": \"name\",\n        \"ptr\": \"2122525392\"\n      }\n    ]\n  }\n},\n```\n\n----------------------------------------\n\nTITLE: Creating Raw and QCOW2 Images for blkverify Testing (Shell)\nDESCRIPTION: Shows how to create two new 16GB disk images: one in raw format (raw.img), the other in QCOW2 format (test.qcow2), for use with blkverify comparison. Dependencies include qemu-img. These commands initialize blank images of specified size for further block driver testing scenarios.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/blkverify.txt#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ ./qemu-img create raw.img 16G\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ ./qemu-img create -f qcow2 test.qcow2 16G\n```\n\n----------------------------------------\n\nTITLE: Executing PANDA with CallWithArg Plugin in Python\nDESCRIPTION: This snippet demonstrates how to run PANDA with the CallWithArg plugin using Python. It sets specific targets and enables verbose output.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/callwitharg/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n$(python3 -m pandare.qcows x86_64) -panda callwitharg:targets=root_hello_0x41414141,verbose=1\n```\n\n----------------------------------------\n\nTITLE: Formatting a prog_point Object as a Stack ID String with PANDA API in C\nDESCRIPTION: This API function converts a prog_point structure into a stack ID string. The string must be freed by the caller with g_free to prevent memory leaks. It can be called independently of the plugin's load state. Requires PANDA's prog_point.h header and GLib support for g_free. Outputs a null-terminated string identifying the stack, provided a valid prog_point input.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/callstack_instr/README.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\n// Get the stack ID, as a string, from the given program point. The returned\n// object must be freed with g_free when it is no longer needed.\nchar *get_stackid_string(prog_point p);\n```\n\n----------------------------------------\n\nTITLE: SchemaInfo for Array Type Reference - JSON\nDESCRIPTION: This snippet provides the structure of a SchemaInfo for an array type, where 'name' shows the array type as '[str]' and 'element-type' provides the type of elements in the array. Clients should rely on 'element-type' for validation rather than inferring type from array name conventions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_19\n\nLANGUAGE: json\nCODE:\n```\n{ \\\"name\\\": \\\"[str]\\\", \\\"meta-type\\\": \\\"array\\\",\\n  \\\"element-type\\\": \\\"str\\\" }\n```\n\n----------------------------------------\n\nTITLE: Defining Windows NT System Call Prototypes in C\nDESCRIPTION: This snippet declares numerous function prototypes for Windows NT Native API calls (Nt*), allowing low-level access to kernel services such as file, process, and memory management. The functions return an NTSTATUS code and accept pointers to system structures, object handles, and value parameters. These declarations require the inclusion of Windows SDK headers for type definitions (e.g., NTSTATUS, HANDLE, PVOID), and are typically used in kernel, driver, or advanced user-mode system utilities targeting Windows internals. Each function's parameters reflect the required structure or data for kernel interactions, and the absence of implementation body means these prototypes must be backed by the corresponding system library at link or run-time. Limitations include reliance on correct parameter usage and the unstable nature of some undocumented APIs.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/all_windows_prototypes.txt#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtPropagationFailed (HANDLE ResourceManagerHandle, ULONG RequestCookie, NTSTATUS PropStatus);\nNTSTATUS NtProtectVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, WIN32_PROTECTION_MASK NewProtectWin32, PULONG OldProtect);\nNTSTATUS NtPulseEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtQueryAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);\nNTSTATUS NtQueryBootEntryOrder (PULONG Ids, PULONG Count);\nNTSTATUS NtQueryBootOptions (PBOOT_OPTIONS BootOptions, PULONG BootOptionsLength);\nNTSTATUS NtQueryDebugFilterState (ULONG ComponentId, ULONG Level);\nNTSTATUS NtQueryDefaultLocale (BOOLEAN UserProfile, PLCID DefaultLocaleId);\nNTSTATUS NtQueryDefaultUILanguage (LANGID *DefaultUILanguageId);\nNTSTATUS NtQueryDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);\nNTSTATUS NtQueryDirectoryObject (HANDLE DirectoryHandle, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, BOOLEAN RestartScan, PULONG Context, PULONG ReturnLength);\nNTSTATUS NtQueryDriverEntryOrder (PULONG Ids, PULONG Count);\nNTSTATUS NtQueryEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan);\nNTSTATUS NtQueryEvent (HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryFullAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);\nNTSTATUS NtQueryInformationAtom (RTL_ATOM Atom, ATOM_INFORMATION_CLASS InformationClass, PVOID AtomInformation, ULONG AtomInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\nNTSTATUS NtQueryInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationPort (HANDLE PortHandle, PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtQueryInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationTransactionManager (HANDLE TransactionManagerHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInstallUILanguage (LANGID *InstallUILanguageId);\nNTSTATUS NtQueryIntervalProfile (KPROFILE_SOURCE ProfileSource, PULONG Interval);\nNTSTATUS NtQueryIoCompletion (HANDLE IoCompletionHandle, IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass, PVOID IoCompletionInformation, ULONG IoCompletionInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryKey (HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtQueryMultipleValueKey (HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength);\nNTSTATUS NtQueryMutant (HANDLE MutantHandle, MUTANT_INFORMATION_CLASS MutantInformationClass, PVOID MutantInformation, ULONG MutantInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryOpenSubKeys (POBJECT_ATTRIBUTES TargetKey, PULONG HandleCount);\nNTSTATUS NtQueryOpenSubKeysEx (POBJECT_ATTRIBUTES TargetKey, ULONG BufferLength, PVOID Buffer, PULONG RequiredSize);\nNTSTATUS NtQueryPerformanceCounter (PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);\nNTSTATUS NtQueryPortInformationProcess ();\nNTSTATUS NtQueryQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID SidList, ULONG SidListLength, PULONG StartSid, BOOLEAN RestartScan);\nNTSTATUS NtQuerySection (HANDLE SectionHandle, SECTION_INFORMATION_CLASS SectionInformationClass, PVOID SectionInformation, SIZE_T SectionInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtQuerySecurityAttributesToken (HANDLE TokenHandle, PUNICODE_STRING Attributes, ULONG NumberOfAttributes, PVOID Buffer, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtQuerySecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Length, PULONG LengthNeeded);\nNTSTATUS NtQuerySemaphore (HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG SemaphoreInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySymbolicLinkObject (HANDLE LinkHandle, PUNICODE_STRING LinkTarget, PULONG ReturnedLength);\nNTSTATUS NtQuerySystemEnvironmentValue (PUNICODE_STRING VariableName, PWSTR VariableValue, USHORT ValueLength, PUSHORT ReturnLength);\nNTSTATUS NtQuerySystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, PULONG ValueLength, PULONG Attributes);\nNTSTATUS NtQuerySystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySystemInformationEx (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID QueryInformation, ULONG QueryInformationLength, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySystemTime (PLARGE_INTEGER SystemTime);\nNTSTATUS NtQueryTimer (HANDLE TimerHandle, TIMER_INFORMATION_CLASS TimerInformationClass, PVOID TimerInformation, ULONG TimerInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryTimerResolution (PULONG MaximumTime, PULONG MinimumTime, PULONG CurrentTime);\nNTSTATUS NtQueryValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtQueryVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtQueryVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtQueueApcThread (HANDLE ThreadHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\nNTSTATUS NtQueueApcThreadEx (HANDLE ThreadHandle, HANDLE UserApcReserveHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\nNTSTATUS NtRaiseException (PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ContextRecord, BOOLEAN FirstChance);\nNTSTATUS NtRaiseHardError (NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask, PULONG_PTR Parameters, ULONG ValidResponseOptions, PULONG Response);\nNTSTATUS NtReadFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtReadFileScatter (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtReadOnlyEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtReadRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtReadVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtRecoverEnlistment (HANDLE EnlistmentHandle, PVOID EnlistmentKey);\nNTSTATUS NtRecoverResourceManager (HANDLE ResourceManagerHandle);\nNTSTATUS NtRecoverTransactionManager (HANDLE TransactionManagerHandle);\nNTSTATUS NtRegisterProtocolAddressInformation (HANDLE ResourceManager, PCRM_PROTOCOL_ID ProtocolId, ULONG ProtocolInformationSize, PVOID ProtocolInformation, ULONG CreateOptions);\nNTSTATUS NtRegisterThreadTerminatePort (HANDLE PortHandle);\n```\n\n----------------------------------------\n\nTITLE: Instrumenting Memory Address Calculation and Register Handling - LLVM IR\nDESCRIPTION: The snippet demonstrates register pointer conversion, address calculation, and initial pointer-int manipulations within LLVM IR, as used in binary translation or analysis tools. This code requires the PANDA project's custom helper functions such as @log_dynval. The code expects i64 and i32 operands as inputs and logs dynamic values during execution for emulation or analysis purposes. It outputs updated memory/register values for further processing.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/dynslice.md#_snippet_5\n\nLANGUAGE: llvm\nCODE:\n```\n%rsp_ptr = inttoptr i64 %22 to i64*\n%23 = ptrtoint i64* %rsp_ptr to i64\ncall void @log_dynval(i64 59634320, i32 0, i32 0, i64 %23)\n```\n\n----------------------------------------\n\nTITLE: Including Generated Trace Header in C Source Files\nDESCRIPTION: To use trace events in a QEMU source file, the local generated 'trace.h' must be included. This C preprocessor directive ensures the trace event prototypes are available for use in the source file. This pattern expects the build system to have generated 'trace.h' in the relevant sub-directory. There are no parameters or outputs; it simply provides trace prototypes for further usage.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/tracing.txt#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n#include \"trace.h\"\n```\n\n----------------------------------------\n\nTITLE: Inspecting CPU Registers via GDB - GDB\nDESCRIPTION: This code demonstrates querying register state via the 'info reg' command within GDB while attached to a PANDA target. No dependencies beyond a running remote debugging session are needed. Output reflects the current state of general purpose and special registers on the guest system. Results may differ by system architecture and guest state.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/gdb/README.md#_snippet_3\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) info reg\nrax            0x1c                28\nrbx            0x4                 4\nrcx            0x7ffff7de59a0      140737351932320\nrdx            0x0                 0\nrsi            0x7fffffffeba0      140737488350112\nrdi            0x0                 0\nrbp            0x7ffff7ffe700      0x7ffff7ffe700\nrsp            0x1                 0x1\nr8             0x3028              12328\nr9             0x1000000           16777216\nr10            0x1                 1\nr11            0x0                 0\nr12            0x555555556710      93824992241424\nr13            0x7fffffffeba0      140737488350112\nr14            0x0                 0\nr15            0x0                 0\nrip            0x555555556710      0x555555556710\neflags         0x202               [ IF ]\ncs             0x0                 0\nss             0x0                 0\nds             0x0                 0\nes             0x0                 0\nfs             0xf7fef540          -134286016\ngs             0x0                 0\n```\n\n----------------------------------------\n\nTITLE: Assigning Physical Ports for USB Devices - QEMU CLI\nDESCRIPTION: Provides QEMU '-device' command-line examples for explicitly assigning devices to particular ports on a given USB controller bus. Requires understanding of bus and port mapping in the virtual machine. Key parameters include 'bus' and 'port'. Ensures devices appear at defined locations for the guest OS.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/usb2.txt#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n-device usb-tablet,bus=usb-bus.0,port=1\n```\n\nLANGUAGE: bash\nCODE:\n```\n-device usb-hub,bus=usb-bus.0,port=2\n```\n\nLANGUAGE: bash\nCODE:\n```\n-device usb-storage,bus=usb-bus.0,port=2.4,drive=...\n```\n\n----------------------------------------\n\nTITLE: Recording I/O Buffer to HD Transfer\nDESCRIPTION: Code from ide_sector_write that records transfers from I/O buffer to hard drive, similar to the read operation but in reverse direction.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/hd_taint.txt#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nrr_record_hd_transfer\n  (RR_CALLSITE_IDE_SECTOR_WRITE,\n   HD_TRANSFER_IOB_TO_HD,\n   (uint64_t) s->io_buffer,\n   HD_BASE_ADDR + sector_num*512, \n   n*512);\n```\n\n----------------------------------------\n\nTITLE: Launching Secondary VM with QEMU-KVM for COLO\nDESCRIPTION: This command starts the secondary VM using QEMU-KVM with specific configurations for COLO, including disk replication setup and incoming migration preparation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/COLO-FT.txt#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# qemu-kvm -enable-kvm -m 2048 -smp 2 -qmp stdio -vnc :7 -name secondary \\\n  -device piix3-usb-uhci \\\n  -device usb-tablet -netdev tap,id=hn0,vhost=off \\\n  -device virtio-net-pci,id=net-pci0,netdev=hn0 \\\n  -drive if=none,id=secondary-disk0,file.filename=1.raw,driver=raw,node-name=node0 \\\n  -drive if=virtio,id=active-disk0,driver=replication,mode=secondary,\\\n         file.driver=qcow2,top-id=active-disk0,\\\n         file.file.filename=/mnt/ramfs/active_disk.img,\\\n         file.backing.driver=qcow2,\\\n         file.backing.file.filename=/mnt/ramfs/hidden_disk.img,\\\n         file.backing.backing=secondary-disk0 \\\n  -incoming tcp:0:8888\n```\n\n----------------------------------------\n\nTITLE: Defining Process Start Callback in PANDA hooks2 Plugin\nDESCRIPTION: Defines the signature for the on_process_start callback function that gets triggered when a new process starts. The callback provides CPU state, process name, address space ID (asid), and process ID information.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/hooks2/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid on_process_start(\n    CPUState *cpu,\n    const char *procname,\n    target_ulong asid,\n    target_pid_t pid);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Call Function Signatures in C\nDESCRIPTION: This snippet declares function signatures for various Windows NT system calls. These functions are part of the Windows Native API and provide low-level access to system resources and operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp0_x64_prototypes.txt#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAlpcSendWaitReceivePort (HANDLE PortHandle, ULONG Flags, PPORT_MESSAGE SendMessage, PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes, PPORT_MESSAGE ReceiveMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes, PLARGE_INTEGER Timeout);\nNTSTATUS NtAlpcSetInformation (HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length);\nNTSTATUS NtAreMappedFilesTheSame (PVOID File1MappedAsAnImage, PVOID File2MappedAsFile);\nNTSTATUS NtAssignProcessToJobObject (HANDLE JobHandle, HANDLE ProcessHandle);\nNTSTATUS NtCancelIoFileEx (HANDLE FileHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtCancelSynchronousIoFile (HANDLE ThreadHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtCommitComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCommitEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCommitTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\nNTSTATUS NtCompactKeys (ULONG Count, HANDLE KeyArray[]);\nNTSTATUS NtCompareTokens (HANDLE FirstTokenHandle, HANDLE SecondTokenHandle, PBOOLEAN Equal);\nNTSTATUS NtCompleteConnectPort (HANDLE PortHandle);\nNTSTATUS NtCompressKey (HANDLE Key);\nNTSTATUS NtConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\nNTSTATUS NtCreateDebugObject (PHANDLE DebugObjectHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\nNTSTATUS NtCreateDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, HANDLE TransactionHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, NOTIFICATION_MASK NotificationMask, PVOID EnlistmentKey);\nNTSTATUS NtCreateEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Count);\nNTSTATUS NtCreateJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateJobSet (ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);\nNTSTATUS NtCreateKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, HANDLE TransactionHandle, PULONG Disposition);\nNTSTATUS NtCreateKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\nNTSTATUS NtCreateMailslotFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout);\nNTSTATUS NtCreateMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN InitialOwner);\nNTSTATUS NtCreateNamedPipeFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout);\nNTSTATUS NtCreatePagingFile (PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority);\nNTSTATUS NtCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtCreatePrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\nNTSTATUS NtCreateProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort);\nNTSTATUS NtCreateProfile (PHANDLE ProfileHandle, HANDLE Process, PVOID RangeBase, SIZE_T RangeSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);\nNTSTATUS NtCreateResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID RmGuid, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, PUNICODE_STRING Description);\nNTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);\nNTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);\nNTSTATUS NtCreateThreadEx (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument, ULONG CreateFlags, ULONG_PTR ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, PPS_ATTRIBUTE_LIST AttributeList);\nNTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);\nNTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);\nNTSTATUS NtCreateTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle, ULONG CreateOptions, ULONG IsolationLevel, ULONG IsolationFlags, PLARGE_INTEGER Timeout, PUNICODE_STRING Description);\nNTSTATUS NtCreateTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, ULONG CreateOptions, ULONG CommitStrength);\nNTSTATUS NtCreateUserProcess (PHANDLE ProcessHandle, PHANDLE ThreadHandle, ACCESS_MASK ProcessDesiredAccess, ACCESS_MASK ThreadDesiredAccess, POBJECT_ATTRIBUTES ProcessObjectAttributes, POBJECT_ATTRIBUTES ThreadObjectAttributes, ULONG ProcessFlags, ULONG ThreadFlags, PRTL_USER_PROCESS_PARAMETERS ProcessParameters, PPROCESS_CREATE_INFO CreateInfo, PPROCESS_ATTRIBUTE_LIST AttributeList);\nNTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtCreateWorkerFactory (PHANDLE WorkerFactoryHandleReturn, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE CompletionPortHandle, HANDLE WorkerProcessHandle, PVOID StartRoutine, PVOID StartParameter, ULONG MaxThreadCount, SIZE_T StackReserve, SIZE_T StackCommit);\nNTSTATUS NtDebugActiveProcess (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtDebugContinue (HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);\nNTSTATUS NtDeleteAtom (RTL_ATOM Atom);\nNTSTATUS NtDeleteBootEntry (ULONG Id);\nNTSTATUS NtDeleteDriverEntry (ULONG Id);\nNTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtDeleteKey (HANDLE KeyHandle);\nNTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtDeletePrivateNamespace (HANDLE NamespaceHandle);\nNTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);\nNTSTATUS NtDisplayString (PUNICODE_STRING String);\nNTSTATUS NtEnumerateBootEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateDriverEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateSystemEnvironmentValuesEx (ULONG InformationClass, PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateTransactionObject (HANDLE RootObjectHandle, KTMOBJECT_TYPE QueryType, PKTMOBJECT_CURSOR ObjectCursor, ULONG ObjectCursorLength, PULONG ReturnLength);\nNTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);\nNTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);\nNTSTATUS NtFlushInstallUILanguage (LANGID InstallUILanguage, ULONG SetComittedFlag);\nNTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);\nNTSTATUS NtFlushKey (HANDLE KeyHandle);\nVOID NtFlushProcessWriteBuffers ();\nNTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);\nNTSTATUS NtFlushWriteBuffer ();\nNTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtFreezeRegistry (ULONG TimeOutInSeconds);\nNTSTATUS NtFreezeTransactions (PLARGE_INTEGER FreezeTimeout, PLARGE_INTEGER ThawTimeout);\nNTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nULONG NtGetCurrentProcessorNumber ();\nNTSTATUS NtGetDevicePowerState (HANDLE Device, DEVICE_POWER_STATE *State);\nNTSTATUS NtGetMUIRegistryInfo (ULONG Flags, PULONG DataSize, PVOID Data);\nNTSTATUS NtGetNextProcess (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewProcessHandle);\nNTSTATUS NtGetNextThread (HANDLE ProcessHandle, HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewThreadHandle);\n```\n\n----------------------------------------\n\nTITLE: Compiling STUW in C++\nDESCRIPTION: Command to compile the STUW tool using g++. It links against necessary libraries and includes required header files.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/stuw.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ng++ -g -o stuw stuw.cpp pandalog.c pandalog_print.c pandalog.pb-c.c  -L/usr/local/lib -lprotobuf-c -I .. -lz -D PANDALOG_READER  -std=c++11\n```\n\n----------------------------------------\n\nTITLE: Stack Pointer Arithmetic and Masking Before Store - LLVM IR\nDESCRIPTION: This code adjusts the stack pointer, applies a bitmask, and prepares to store or further process the result using helper functions. It demonstrates standard stack manipulation in low-level IR and expects i64 values as inputs. It outputs masked addresses for later instrumentation or storage operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/dynslice.md#_snippet_11\n\nLANGUAGE: llvm\nCODE:\n```\n%tmp2_v9 = add i64 %tmp-12_v, -4\n```\n\nLANGUAGE: llvm\nCODE:\n```\n%tmp2_v10 = and i64 %tmp2_v9, 4294967295\n%44 = trunc i64 %rax_v to i32\ncall void @__stl_mmu_panda(i64 %tmp2_v10, i32 %44, i32 1)\n```\n\n----------------------------------------\n\nTITLE: Declaring IPC and Shared Memory System Calls in C for FreeBSD\nDESCRIPTION: This snippet declares system calls for inter-process communication (IPC) and shared memory operations in FreeBSD, including semaphore, message queue, and shared memory segment control functions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_24\n\nLANGUAGE: C\nCODE:\n```\nint __semctl(int semid, int semnum, int cmd, union semun *arg);\nint msgctl(int msqid, int cmd, struct msqid_ds *buf);\nint shmctl(int shmid, int cmd, struct shmid_ds *buf);\nint shm_open(const char *path, int flags, mode_t mode);\nint shm_unlink(const char *path);\n```\n\n----------------------------------------\n\nTITLE: Mapping Virtual Disk Range from Bitmap Bit Index - Pseudo-code\nDESCRIPTION: This pseudo-code snippet computes the precise byte range covered by a specific bit in a QCOW2 bitmap extension, supporting features like dirty tracking. It expresses how a bitmap granularity parameter defines the section of the disk that is represented by a single bit, necessary for both reading and updating bitmap metadata. Dependencies include prior knowledge of bitmap granularity and bit indexing; inputs are the bit number and bitmap granularity, and the output is the byte range on the virtual disk to which the bit corresponds.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/qcow2.txt#_snippet_2\n\nLANGUAGE: pseudo-code\nCODE:\n```\n[bit_nr * bitmap_granularity .. (bit_nr + 1) * bitmap_granularity - 1]\n\n```\n\n----------------------------------------\n\nTITLE: Resetting All Search Strings in PANDA Plugin (C)\nDESCRIPTION: This C function clears all search patterns currently being tracked by the stringsearch plugin. It takes no parameters and has no return value. Must be called after plugin initialization; use it when you want to start fresh with an empty set of search strings. Dependencies include PANDA and the stringsearch plugin.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/stringsearch/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nvoid reset_strings()\n```\n\n----------------------------------------\n\nTITLE: Windows NT System Functions Declarations - File and Registry Operations\nDESCRIPTION: Function declarations for Windows NT native API calls handling file system and registry operations. These functions provide low-level access to file and registry manipulation capabilities.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp0_x86_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtReadFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtQueryKey (HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtSaveKey (HANDLE KeyHandle, HANDLE FileHandle);\nNTSTATUS NtRestoreKey (HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags);\n```\n\n----------------------------------------\n\nTITLE: Custom Rule Definition in QEMU Makefile.objs Files\nDESCRIPTION: Example of defining custom rules in Makefile.objs files, showing how to use the $(obj) prefix for target paths.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/build-system.txt#_snippet_5\n\nLANGUAGE: Makefile\nCODE:\n```\n$(obj)/generated-tcg-tracers.h: $(obj)/generated-tcg-tracers.h-timestamp\n```\n\n----------------------------------------\n\nTITLE: Thread Control and Audit Functions in C\nDESCRIPTION: Function declarations for thread control operations and system auditing. Includes semaphore operations with timeouts, thread suspension/waking, and audit control functions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_18\n\nLANGUAGE: c\nCODE:\n```\nint ksem_timedwait(semid_t id, const struct timespec *abstime);\nint thr_suspend(const struct timespec *timeout);\nint thr_wake(long id);\nint kldunloadf(int fileid, int flags);\nint audit(const void *record, unsigned length);\nint auditon(int cmd, void *data, unsigned length);\nint getauid(uid_t *auid);\nint setauid(uid_t *auid);\nint getaudit(struct auditinfo *auditinfo);\nint setaudit(struct auditinfo *auditinfo);\nint getaudit_addr(struct auditinfo_addr *auditinfo_addr, unsigned length);\nint setaudit_addr(struct auditinfo_addr *auditinfo_addr, unsigned length);\nint auditctl(const char *path);\nint _umtx_op(void *obj, int op, u_long val, void *uaddr1, void *uaddr2);\nint thr_new(struct thr_param *param, int param_size);\nint sigqueue(pid_t pid, int signum, void *value);\n```\n\n----------------------------------------\n\nTITLE: Detailed Taint Analysis Log Output\nDESCRIPTION: Detailed log output showing instruction count, program counter, callstack information and taint query results. Each entry includes instruction number, PC address, and associated callstack trace.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/tainted_instructions.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\ninstr=434857690 pc=0xb722c9b6 : callstack=(9,[ 0xb74cb385, 0xb754d3ce, 0xb754519d, 0xb74d280e, 0xb76ec565, 0xb76e252c, 0xb76eae75, 0xb76ae5bd, 0xb76af985])\ninstr=434857690 pc=0xb722c9b6 : taint query: labels ptr 7f16142b9000 tcn=0\n```\n\n----------------------------------------\n\nTITLE: Launching PANDA VM with recctrl Plugin - Shell\nDESCRIPTION: This shell command demonstrates starting a QEMU-based PANDA VM with the 'recctrl' plugin enabled using the '-panda recctrl' flag. Dependencies include PANDA's system emulation binary, an appropriately prepared VM image, and proper device/networking parameters. The command enables the guest to communicate recording start/stop requests through hypercalls, which are processed by the recctrl plugin.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/recctrl/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npanda-system-i386 -m 512 -hda ubuntu.qcow2 -device e1000,netdev=unet0 -netdev user,id=unet0,hostfwd=tcp::10022-:22 -panda recctrl\n```\n\n----------------------------------------\n\nTITLE: Enabling EXT4 Partition Support for Android Images - QEMU Argument - Shell\nDESCRIPTION: This command fragment demonstrates enabling ext4 filesystem support when launching PANDA with Android images that use ext4 rather than YAFFS partitions. The parameter should be added to the main PANDA/QEMU command line. The global argument sets the relevant device emulation for NAND. No additional dependencies beyond those for standard PANDA usage are required; users must be sure their images are in the required format.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/Android.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n-global goldfish_nand.ext4=on\n```\n\n----------------------------------------\n\nTITLE: Configuring Primary VM Network and COLO-proxy in QEMU\nDESCRIPTION: This snippet demonstrates how to configure the network devices, chardev sockets, and COLO-proxy objects for the primary VM in QEMU. It sets up the tap device, e1000 NIC, mirror and compare sockets, and various filter objects.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/colo-proxy.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n-netdev tap,id=hn0,vhost=off,script=/etc/qemu-ifup,downscript=/etc/qemu-ifdown\n-device e1000,id=e0,netdev=hn0,mac=52:a4:00:12:78:66\n-chardev socket,id=mirror0,host=3.3.3.3,port=9003,server,nowait\n-chardev socket,id=compare1,host=3.3.3.3,port=9004,server,nowait\n-chardev socket,id=compare0,host=3.3.3.3,port=9001,server,nowait\n-chardev socket,id=compare0-0,host=3.3.3.3,port=9001\n-chardev socket,id=compare_out,host=3.3.3.3,port=9005,server,nowait\n-chardev socket,id=compare_out0,host=3.3.3.3,port=9005\n-object filter-mirror,id=m0,netdev=hn0,queue=tx,outdev=mirror0\n-object filter-redirector,netdev=hn0,id=redire0,queue=rx,indev=compare_out\n-object filter-redirector,netdev=hn0,id=redire1,queue=rx,outdev=compare0\n-object colo-compare,id=comp0,primary_in=compare0-0,secondary_in=compare1,outdev=compare_out0\n```\n\n----------------------------------------\n\nTITLE: Reading, Incrementing, and Updating Environment State - LLVM IR\nDESCRIPTION: This block retrieves an environment state variable, increments it, logs both the old and new values, and writes it back. Analogous patterns are repeated for several environment offsets throughout the code, helping model register increments within the emulated system. It expects prior computed addresses and modifies associated values. Outputs include updated state in specific environment offsets for use in emulation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/dynslice.md#_snippet_9\n\nLANGUAGE: llvm\nCODE:\n```\n%36 = add i64 %env_v, 56016\n%37 = inttoptr i64 %36 to i64*\n%38 = ptrtoint i64* %37 to i64\ncall void @log_dynval(i64 59634320, i32 0, i32 0, i64 %38)\n%tmp12_v7 = load i64* %37\n%tmp12_v8 = add i64 %tmp12_v7, 1\n%39 = add i64 %env_v, 56016\n%40 = inttoptr i64 %39 to i64*\n%41 = ptrtoint i64* %40 to i64\ncall void @log_dynval(i64 59634320, i32 0, i32 2, i64 %41)\nstore i64 %tmp12_v8, i64* %40\n```\n\n----------------------------------------\n\nTITLE: Taint2 Example Usage\nDESCRIPTION: Example command showing how to use taint2 plugin with PANDA to track tainted data from a file and analyze tainted branches.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/taint2/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo -panda osi \\\n    -panda osi_linux:kconf_group=debian-3.2.63-i686 \\\n    -panda syscalls2:profile=linux_x86 \\\n    -panda file_taint:filename=foo.dat \\\n    -panda tainted_branch \\\n    -pandalog foo.plog\n```\n\n----------------------------------------\n\nTITLE: Enabling QMP in QEMU via Command-line (Bash)\nDESCRIPTION: Demonstrates how to launch QEMU with QMP enabled on a specific TCP port using the -qmp option. No additional dependencies are required beyond QEMU itself. The command specifies localhost with listening port 4444, sets the instance to act as a server, and disables blocking (nowait). Inputs: n/a (command line arguments). Output: QEMU started with QMP listening. Limitations: Only enables one QMP interface; advanced chardev usage is handled in a separate snippet.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qmp-intro.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ qemu [...] -qmp tcp:localhost:4444,server,nowait\n```\n\n----------------------------------------\n\nTITLE: Defining Tap Point Program Context Structure in C\nDESCRIPTION: This snippet defines the 'prog_point' struct in C, which represents tap point context in the PANDA plugin. Each struct holds the caller address, program counter (PC), and address space (CR3) as target_ulong integers. These fields are used to uniquely identify the source of memory writes for later correlation. There are no parameters and the struct is typically used when producing binary records for analyzing correlated tap points.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/correlatetaps/README.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n    struct prog_point {\n        target_ulong caller;\n        target_ulong pc;\n        target_ulong cr3;\n    };\n```\n\n----------------------------------------\n\nTITLE: Defining Enumeration System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to enumerating various system objects including boot entries, driver entries, environment values, and transaction objects. These functions provide listing capabilities for system configuration.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_19\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtEnumerateBootEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateDriverEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateSystemEnvironmentValuesEx (ULONG InformationClass, PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateTransactionObject (HANDLE RootObjectHandle, KTMOBJECT_TYPE QueryType, PKTMOBJECT_CURSOR ObjectCursor, ULONG ObjectCursorLength, PULONG ReturnLength);\n```\n\n----------------------------------------\n\nTITLE: Locating Tap Data in Compressed Log with zgrep and less (Shell)\nDESCRIPTION: This snippet uses zgrep to extract tap-related lines matching a particular address tuple from a compressed PANDA log and inspects them with less. It is a method for correlating binary buffer data with original, context-rich memory logs. Dependencies are zgrep, less, and the .gz log. Inputs include a search pattern indicating tap point; outputs are displayed lines for manual examination.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/LINE_Censorship.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n$ zgrep '40796784 40038688 28210000' write_tap_buffers.txt.gz | less\n```\n\n----------------------------------------\n\nTITLE: Invoking Dynamic Slicing with dynslice Utility via Shell Command\nDESCRIPTION: This shell snippet shows how to use the dynslice utility to perform dynamic slicing based on user-specified slicing criteria. It takes the reversed LLVM bitcode module and TUBT log, along with a list of address-based criteria (here, four consecutive memory bytes at address 0x12000). dynslice outputs information on instructions included in the slice and generates additional binary logs (e.g., slice_report.bin) for inspection. It requires the reversed trace log, bitcode, and criteria in the format expected by dynslice. The main arguments are the paths to the inputs and the slicing criterion, which can be memory or register locations as hexadecimal identifiers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/dynslice.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n./dynslice llvm-mod.bc tubtf.log MEM_12000 MEM_12001 MEM_12002 MEM_1203\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for PANDA\nDESCRIPTION: Lists required Python packages and their versions for the PANDA project. It includes pyelftools for ELF file parsing and capstone for disassembly capabilities.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/tests/requirements.txt#_snippet_0\n\nLANGUAGE: Plain Text\nCODE:\n```\npyelftools==0.27\ncapstone==4.0.1\n```\n\n----------------------------------------\n\nTITLE: Declaring Linux System Call Prototypes - C\nDESCRIPTION: This code snippet defines function prototypes for a range of Linux kernel system calls, specifying their names, parameters, and return types. The declarations require POSIX-compliant type definitions (such as aio_context_t, struct iocb, struct epoll_event, etc.) and user-space pointer conventions. Inputs mainly consist of file descriptors, pointers to data structures or user buffers, size parameters, and flags, producing a return value of type 'long' to indicate status or result. These prototypes are essential when describing the syscall interface in kernel source code or in stubs for syscall tables; without their definitions, kernel code cannot properly resolve or call system-level functions. There are no implementationsâ€”only declarationsâ€”so the file does not execute any logic but instead establishes a contract for the syscall interface.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_arm64_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n0 long sys_io_setup(unsigned nr_reqs, aio_context_t __user *ctx);\n1 long sys_io_destroy(aio_context_t ctx);\n2 long sys_io_submit(aio_context_t, long, struct iocb __user * __user *);\n3 long sys_io_cancel(aio_context_t ctx_id, struct iocb __user *iocb, struct io_event __user *result);\n4 long sys_io_getevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct timespec __user *timeout);\n5 long sys_setxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\n6 long sys_lsetxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\n7 long sys_fsetxattr(int fd, const char __user *name, const void __user *value, size_t size, int flags);\n8 long sys_getxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\n9 long sys_lgetxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\n10 long sys_fgetxattr(int fd, const char __user *name, void __user *value, size_t size);\n11 long sys_listxattr(const char __user *path, char __user *list, size_t size);\n12 long sys_llistxattr(const char __user *path, char __user *list, size_t size);\n13 long sys_flistxattr(int fd, char __user *list, size_t size);\n14 long sys_removexattr(const char __user *path, const char __user *name);\n15 long sys_lremovexattr(const char __user *path, const char __user *name);\n16 long sys_fremovexattr(int fd, const char __user *name);\n17 long sys_getcwd(char __user *buf, unsigned long size);\n18 long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);\n19 long sys_eventfd2(unsigned int count, int flags);\n20 long sys_epoll_create1(int flags);\n21 long sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user *event);\n22 long sys_epoll_pwait(int epfd, struct epoll_event __user *events, int maxevents, int timeout, const sigset_t __user *sigmask, size_t sigsetsize);\n23 long sys_dup(unsigned int fildes);\n24 long sys_dup3(unsigned int oldfd, unsigned int newfd, int flags);\n25 long sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg);\n26 long sys_inotify_init1(int flags);\n27 long sys_inotify_add_watch(int fd, const char __user *path, u32 mask);\n28 long sys_inotify_rm_watch(int fd, __s32 wd);\n29 long sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);\n30 long sys_ioprio_set(int which, int who, int ioprio);\n31 long sys_ioprio_get(int which, int who);\n32 long sys_flock(unsigned int fd, unsigned int cmd);\n33 long sys_mknodat(int dfd, const char __user *filename, umode_t mode, unsigned dev);\n34 long sys_mkdirat(int dfd, const char __user *pathname, umode_t mode);\n35 long sys_unlinkat(int dfd, const char __user *pathname, int flag);\n36 long sys_symlinkat(const char __user *oldname, int newdfd, const char __user *newname);\n37 long sys_linkat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, int flags);\n38 long sys_renameat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname);\n39 long sys_umount2(const char* target, int flags);\n40 long sys_mount(char __user *dev_name, char __user *dir_name, char __user *type, unsigned long flags, void __user *data);\n41 long sys_pivot_root(const char __user *new_root, const char __user *put_old);\n42 long sys_nfsservctl(int cmd, struct nfsctl_arg *argp, union nfsctl_res *resp);\n43 long sys_statfs(const char * path, struct statfs *buf);\n44 long sys_fstatfs(unsigned int fd, struct statfs *buf);\n45 long sys_truncate(const char *path, long length);\n46 long sys_ftruncate(unsigned int fd, unsigned long length);\n47 long sys_fallocate(int fd, int mode, loff_t offset, loff_t len);\n48 long sys_faccessat(int dfd, const char __user *filename, int mode);\n49 long sys_chdir(const char __user *filename);\n50 long sys_fchdir(unsigned int fd);\n51 long sys_chroot(const char __user *filename);\n52 long sys_fchmod(unsigned int fd, umode_t mode);\n53 long sys_fchmodat(int dfd, const char __user *filename, umode_t mode);\n54 long sys_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group, int flag);\n55 long sys_fchown(unsigned int fd, uid_t user, gid_t group);\n56 long sys_openat(int dfd, const char __user *filename, int flags, umode_t mode);\n57 long sys_close(unsigned int fd);\n58 long sys_vhangup(void);\n59 long sys_pipe2(int *fildes, int flags);\n60 long sys_quotactl(unsigned int cmd, const char __user *special, qid_t id, void __user *addr);\n61 long sys_getdents64(unsigned int fd, struct linux_dirent64 *dirent, unsigned int count);\n62 long sys_lseek(unsigned int fd, off_t offset, unsigned int whence);\n63 long sys_read(unsigned int fd, char __user *buf, size_t count);\n64 long sys_write(unsigned int fd, const char __user *buf, size_t count);\n65 long sys_readv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\n66 long sys_writev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\n67 long sys_pread64(unsigned int fd, char *buf, size_t count, loff_t pos);\n68 long sys_pwrite64(unsigned int fd, const char *buf, size_t count, loff_t pos);\n69 long sys_preadv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);\n70 long sys_pwritev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);\n71 long sys_sendfile(int out_fd, int in_fd, off_t *offset, size_t count);\n72 long sys_pselect6(int, fd_set *, fd_set *, fd_set *, struct __kernel_timespec *, void *);\n73 long sys_ppoll(struct pollfd __user *, unsigned int, struct timespec __user *, const sigset_t __user *, size_t);\n74 long sys_signalfd4(int ufd, sigset_t *user_mask, size_t sizemask, int flags);\n75 long sys_vmsplice(int fd, const struct iovec __user *iov, unsigned long nr_segs, unsigned int flags);\n76 long sys_splice(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);\n77 long sys_tee(int fdin, int fdout, size_t len, unsigned int flags);\n78 long sys_readlinkat(int dfd, const char __user *path, char __user *buf, int bufsiz);\n79 long sys_newfstatat(int dfd, const char *filename, struct stat *statbuf, int flag);\n80 long sys_fstat(unsigned int fd, struct __old_kernel_stat *statbuf);\n81 long sys_sync(void);\n82 long sys_fsync(unsigned int fd);\n83 long sys_fdatasync(unsigned int fd);\n84 long sys_sync_file_range(int fd, loff_t offset, loff_t nbytes, unsigned int flags);\n85 long sys_timerfd_create(int clockid, int flags);\n86 long sys_timerfd_settime(int ufd, int flags, const struct itimerspec __user *utmr, struct itimerspec __user *otmr);\n87 long sys_timerfd_gettime(int ufd, struct itimerspec __user *otmr);\n88 long sys_utimensat(int dfd, const char __user *filename, struct timespec __user *utimes, int flags);\n89 long sys_acct(const char __user *name);\n90 long sys_capget(cap_user_header_t header, cap_user_data_t dataptr);\n91 long sys_capset(cap_user_header_t header, const cap_user_data_t data);\n92 long sys_personality(unsigned int personality);\n93 long sys_exit(int error_code);\n94 long sys_exit_group(int error_code);\n95 long sys_waitid(int which, pid_t pid, struct siginfo __user *infop, int options, struct rusage __user *ru);\n96 long sys_set_tid_address(int __user *tidptr);\n97 long sys_unshare(unsigned long unshare_flags);\n98 long sys_futex(u32 __user *uaddr, int op, u32 val, struct timespec __user *utime, u32 __user *uaddr2, u32 val3);\n99 long sys_set_robust_list(struct robust_list_head __user *head, size_t len);\n100 long sys_get_robust_list(int pid, struct robust_list_head __user * __user *head_ptr, size_t __user *len_ptr);\n101 long sys_nanosleep(struct timespec __user *rqtp, struct timespec __user *rmtp);\n102 long sys_getitimer(int which, struct itimerval __user *value);\n103 long sys_setitimer(int which, struct itimerval __user *value, struct itimerval __user *ovalue);\n104 long sys_kexec_load(unsigned long entry, unsigned long nr_segments, struct kexec_segment __user *segments, unsigned long flags);\n105 long sys_init_module(void __user *umod, unsigned long len, const char __user *uargs);\n106 long sys_delete_module(const char __user *name_user, unsigned int flags);\n107 long sys_timer_create(clockid_t which_clock, struct sigevent __user *timer_event_spec, timer_t __user *created_timer_id);\n108 long sys_timer_gettime(timer_t timer_id, struct itimerspec __user *setting);\n109 long sys_timer_getoverrun(timer_t timer_id);\n110 long sys_timer_settime(timer_t timer_id, int flags, const struct itimerspec __user *new_setting, struct itimerspec __user *old_setting);\n111 long sys_timer_delete(timer_t timer_id);\n112 long sys_clock_settime(clockid_t which_clock, const struct timespec __user *tp);\n113 long sys_clock_gettime(clockid_t which_clock, struct timespec __user *tp);\n114 long sys_clock_getres(clockid_t which_clock, struct timespec __user *tp);\n115 long sys_clock_nanosleep(clockid_t which_clock, int flags, const struct timespec __user *rqtp, struct timespec __user *rmtp);\n116 long sys_syslog(int type, char __user *buf, int len);\n117 long sys_ptrace(long request, long pid, unsigned long addr, unsigned long data);\n118 long sys_sched_setparam(pid_t pid, struct sched_param __user *param);\n119 long sys_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param);\n120 long sys_sched_getscheduler(pid_t pid);\n121 long sys_sched_getparam(pid_t pid, struct sched_param __user *param);\n122 long sys_sched_setaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\n123 long sys_sched_getaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\n124 long sys_sched_yield(void);\n125 long sys_sched_get_priority_max(int policy);\n126 long sys_sched_get_priority_min(int policy);\n127 long sys_sched_rr_get_interval(pid_t pid, struct timespec __user *interval);\n128 long sys_restart_syscall(void);\n129 long sys_kill(pid_t pid, int sig);\n130 long sys_tkill(pid_t pid, int sig);\n```\n\n----------------------------------------\n\nTITLE: Sample Syscall Trace Output from cosi_strace - Text\nDESCRIPTION: This text block displays typical syscall trace output as emitted by the cosi_strace plugin for monitored commands, providing syscall names, arguments, and return values. It includes a variety of common Linux syscalls with arguments and result codes, in a format compatible with traditional strace tools. Inputs are system activities within the VM; output is printed to the console. This output is for inspection and debugging purposes only; it is not directly parsed by code.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/cosi_strace/README.md#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\nsys_rt_sigaction(sig=15, act={sa_flags=0x0, sa_handler=NULL, sa_mask=(unnamed_6ae8a4e8352b722a*)0xbf825094, sa_restorer=(pointer)0x5410}, oact=(sigaction*)0xbf825114, sigsetsize=0x8) = 0\nsys_rt_sigaction(sig=17, act={sa_flags=0x10000000, sa_handler=NULL, sa_mask=(unnamed_6ae8a4e8352b722a*)0xbf825094, sa_restorer=(pointer)0x5410}, oact=(sigaction*)0xbf825114, sigsetsize=0x8) = 0\nsys_ioctl(fd=0xff, cmd=0x540f, arg=0xbf82511c) = 0\nsys_rt_sigprocmask(how=2, nset=(pointer)0xbf8251fc, oset=(pointer)0x0, sigsetsize=0x8) = 0\nsys_rt_sigprocmask(how=0, nset=(pointer)0xbf82527c, oset=(pointer)0xbf8252fc, sigsetsize=0x8) = 0\nsys_waitpid(pid=0xffffffff, stat_addr=0, options=10)\nsys_execve(filename=\"/bin/ls\", argv=\"ls\", envp=\"XDG_SESSION_ID=1\")\nsys_brk(brk=0x0) = 136523776\nsys_access(filename=\"/etc/ld.so.nohwcap\", mode=0) = -2 (ENOENT)\nsys_mmap_pgoff(addr=0x0, len=0x1000, prot=0x3, flags=0x22, fd=0xffffffff, pgoff=0x0) = -1217208320\nsys_access(filename=\"/etc/ld.so.preload\", mode=4) = -2 (ENOENT)\nsys_open(filename=\"/etc/ld.so.cache\", flags=524288, mode=0x0) = 3\nsys_fstat64(fd=0x3, statbuf=(stat64*)0xbff68430) = 0\nsys_mmap_pgoff(addr=0x0, len=0x50a9, prot=0x1, flags=0x2, fd=0x3, pgoff=0x0) = -1217232896\nsys_close(fd=0x3) = 0\nsys_access(filename=\"/etc/ld.so.nohwcap\", mode=0) = -2 (ENOENT)\nsys_open(filename=\"/lib/i386-linux-gnu/libselinux.so.1\", flags=524288, mode=0x0) = 3\nsys_read(fd=0x3, buf=(char*)0xbff68550, count=0x200) = 512\nsys_fstat64(fd=0x3, statbuf=(stat64*)0xbff68470) = 0\nsys_mmap_pgoff(addr=0x0, len=0x25bd4, prot=0x5, flags=0x802, fd=0x3, pgoff=0x0) = -1217388544\nsys_mprotect(start=0xb7724000, len=0x1000, prot=0x0) = 0\nsys_mmap_pgoff(addr=0xb7725000, len=0x2000, prot=0x3, flags=0x812, fd=0x3, pgoff=0x22) = -1217245184\nsys_mmap_pgoff(addr=0xb7727000, len=0xbd4, prot=0x3, flags=0x32, fd=0xffffffff, pgoff=0x0) = -1217236992\nsys_close(fd=0x3) = 0\n```\n\n----------------------------------------\n\nTITLE: Running Memdump Plugin in PANDA (Bash)\nDESCRIPTION: This command runs QEMU with PANDA, replaying a session named 'foo' and using the memdump plugin to create memory dumps.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/tapindex/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/qemu-system-x86_64 -replay foo \\\n    -panda memdump\n```\n\n----------------------------------------\n\nTITLE: Windows NT Power and Device Management Function Declarations\nDESCRIPTION: System call declarations for managing device power states, registry access, and power actions. These functions handle device state queries and power state transitions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x64_prototypes.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtGetDevicePowerState(HANDLE Device, DEVICE_POWER_STATE *State);\nNTSTATUS NtGetMUIRegistryInfo(ULONG Flags, PULONG DataSize, PVOID Data);\nNTSTATUS NtInitiatePowerAction(POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);\nBOOLEAN NtIsSystemResumeAutomatic();\n```\n\n----------------------------------------\n\nTITLE: Declaring Linux syscall prototypes - Linux kernel C header\nDESCRIPTION: This snippet declares prototypes for numerous Linux syscalls as C function declarations. No bodies are defined here; only the argument types, names, and return types are specified. Used by the kernel for syscall definition, dispatch, and ABI correctness. The macros (e.g., __user) designate user-space pointers for static/dynamic analysis. No additional dependencies are required except standard kernel headers. Function parameters reflect the syscall interface; return values are typically long integers to encode error codes or syscall data. There are no implementation details or variable initializations in this file.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n4289 long sys_mkdirat(int dfd, const char __user *pathname, umode_t mode);\n4290 long sys_mknodat(int dfd, const char __user *filename, umode_t mode, unsigned dev);\n4291 long sys_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group, int flag);\n4292 long sys_futimesat_time32(unsigned int dfd, const char __user *filename, struct old_timeval32 __user *t);\n4293 long sys_fstatat64(int dfd, const char __user *filename, struct stat64 __user *statbuf, int flag);\n4294 long sys_unlinkat(int dfd, const char __user *pathname, int flag);\n4295 long sys_renameat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname);\n4296 long sys_linkat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, int flags);\n4297 long sys_symlinkat(const char __user *oldname, int newdfd, const char __user *newname);\n4298 long sys_readlinkat(int dfd, const char __user *path, char __user *buf, int bufsiz);\n4299 long sys_fchmodat(int dfd, const char __user *filename, umode_t mode);\n4300 long sys_faccessat(int dfd, const char __user *filename, int mode);\n4301 long sys_pselect6_time32(int, fd_set __user *, fd_set __user *, fd_set __user *, struct old_timespec32 __user *, void __user *);\n4302 long sys_ppoll_time32(struct pollfd __user *, unsigned int, struct old_timespec32 __user *, const sigset_t __user *, size_t);\n4303 long sys_unshare(unsigned long unshare_flags);\n4304 long sys_splice(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);\n4305 long sys_sync_file_range(int fd, loff_t offset, loff_t nbytes, unsigned int flags);\n4306 long sys_tee(int fdin, int fdout, size_t len, unsigned int flags);\n4307 long sys_vmsplice(int fd, const struct iovec __user *iov, unsigned long nr_segs, unsigned int flags);\n4308 long sys_move_pages(pid_t pid, unsigned long nr_pages, const void __user * __user *pages, const int __user *nodes, int __user *status, int flags);\n4309 long sys_set_robust_list(struct robust_list_head __user *head, size_t len);\n4310 long sys_get_robust_list(int pid, struct robust_list_head __user * __user *head_ptr, size_t __user *len_ptr);\n4311 long sys_kexec_load(unsigned long entry, unsigned long nr_segments, struct kexec_segment __user *segments, unsigned long flags);\n4312 long sys_getcpu(unsigned __user *cpu, unsigned __user *node, struct getcpu_cache __user *cache);\n4313 long sys_epoll_pwait(int epfd, struct epoll_event __user *events, int maxevents, int timeout, const sigset_t __user *sigmask, size_t sigsetsize);\n4314 long sys_ioprio_set(int which, int who, int ioprio);\n4315 long sys_ioprio_get(int which, int who);\n4316 long sys_utimensat_time32(unsigned int dfd, const char __user *filename, struct old_timespec32 __user *t, int flags);\n4317 long sys_signalfd(int ufd, sigset_t __user *user_mask, size_t sizemask);\n4318 long sys_ni_syscall(void);\n4319 long sys_eventfd(unsigned int count);\n4320 long sys_fallocate(int fd, int mode, loff_t offset, loff_t len);\n4321 long sys_timerfd_create(int clockid, int flags);\n4322 long sys_timerfd_gettime32(int ufd, struct old_itimerspec32 __user *otmr);\n4323 long sys_timerfd_settime32(int ufd, int flags, const struct old_itimerspec32 __user *utmr, struct old_itimerspec32 __user *otmr);\n4324 long sys_signalfd4(int ufd, sigset_t __user *user_mask, size_t sizemask, int flags);\n4325 long sys_eventfd2(unsigned int count, int flags);\n4326 long sys_epoll_create1(int flags);\n4327 long sys_dup3(unsigned int oldfd, unsigned int newfd, int flags);\n4328 long sys_pipe2(int __user *fildes, int flags);\n4329 long sys_inotify_init1(int flags);\n4330 long sys_preadv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);\n4331 long sys_pwritev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);\n4332 long sys_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t __user *uinfo);\n4333 long sys_perf_event_open(struct perf_event_attr __user *attr_uptr, pid_t pid, int cpu, int group_fd, unsigned long flags);\n4334 long sys_accept4(int, struct sockaddr __user *, int __user *, int);\n4335 long sys_recvmmsg_time32(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags, struct old_timespec32 __user *timeout);\n4336 long sys_fanotify_init(unsigned int flags, unsigned int event_f_flags);\n4337 long sys_fanotify_mark(int fanotify_fd, unsigned int flags, u64 mask, int fd, const char __user *pathname);\n4338 long sys_prlimit64(pid_t pid, unsigned int resource, const struct rlimit64 __user *new_rlim, struct rlimit64 __user *old_rlim);\n4339 long sys_name_to_handle_at(int dfd, const char __user *name, struct file_handle __user *handle, int __user *mnt_id, int flag);\n4340 long sys_open_by_handle_at(int mountdirfd, struct file_handle __user *handle, int flags);\n4341 long sys_clock_adjtime32(clockid_t which_clock, struct old_timex32 __user *tx);\n4342 long sys_syncfs(int fd);\n4343 long sys_sendmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags);\n4344 long sys_setns(int fd, int nstype);\n4345 long sys_process_vm_readv(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);\n4346 long sys_process_vm_writev(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);\n4347 long sys_kcmp(pid_t pid1, pid_t pid2, int type, unsigned long idx1, unsigned long idx2);\n4348 long sys_finit_module(int fd, const char __user *uargs, int flags);\n4349 long sys_sched_setattr(pid_t pid, struct sched_attr __user *attr, unsigned int flags);\n4350 long sys_sched_getattr(pid_t pid, struct sched_attr __user *attr, unsigned int size, unsigned int flags);\n4351 long sys_renameat2(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, unsigned int flags);\n4352 long sys_seccomp(unsigned int op, unsigned int flags, void __user *uargs);\n4353 long sys_getrandom(char __user *buf, size_t count, unsigned int flags);\n4354 long sys_memfd_create(const char __user *uname_ptr, unsigned int flags);\n4355 long sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);\n4356 long sys_execveat(int dfd, const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp, int flags);\n4357 long sys_userfaultfd(int flags);\n4358 long sys_membarrier(int cmd, int flags);\n4359 long sys_mlock2(unsigned long start, size_t len, int flags);\n4360 long sys_copy_file_range(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);\n4361 long sys_preadv2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);\n4362 long sys_pwritev2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);\n4363 long sys_pkey_mprotect(unsigned long start, size_t len, unsigned long prot, int pkey);\n4364 long sys_pkey_alloc(unsigned long flags, unsigned long init_val);\n4365 long sys_pkey_free(int pkey);\n4366 long sys_statx(int dfd, const char __user *path, unsigned flags, unsigned mask, struct statx __user *buffer);\n4367 long sys_rseq(struct rseq __user *rseq, uint32_t rseq_len, int flags, uint32_t sig);\n4368 long sys_io_pgetevents_time32(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct old_timespec32 __user *timeout, const struct __aio_sigset *sig);\n// Arch-specfic syscalls go here\n4393 long sys_semget(key_t key, int nsems, int semflg);\n4394 long sys_semctl(int semid, int semnum, int cmd, unsigned long arg);\n4395 long sys_shmget(key_t key, size_t size, int flag);\n4396 long sys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);\n4397 long sys_shmat(int shmid, char __user *shmaddr, int shmflg);\n4398 long sys_shmdt(char __user *shmaddr);\n4399 long sys_msgget(key_t key, int msgflg);\n4400 long sys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz, int msgflg);\n4401 long sys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz, long msgtyp, int msgflg);\n4402 long sys_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);\n4403 long sys_clock_gettime(clockid_t which_clock, struct __kernel_timespec __user *tp);\n4404 long sys_clock_settime(clockid_t which_clock, const struct __kernel_timespec __user *tp);\n4405 long sys_clock_adjtime(clockid_t which_clock, struct __kernel_timex __user *tx);\n4406 long sys_clock_getres(clockid_t which_clock, struct __kernel_timespec __user *tp);\n4407 long sys_clock_nanosleep(clockid_t which_clock, int flags, const struct __kernel_timespec __user *rqtp, struct __kernel_timespec __user *rmtp);\n4408 long sys_timer_gettime(timer_t timer_id, struct __kernel_itimerspec __user *setting);\n4409 long sys_timer_settime(timer_t timer_id, int flags, const struct __kernel_itimerspec __user *new_setting, struct __kernel_itimerspec __user *old_setting);\n4410 long sys_timerfd_gettime(int ufd, struct __kernel_itimerspec __user *otmr);\n4411 long sys_timerfd_settime(int ufd, int flags, const struct __kernel_itimerspec __user *utmr, struct __kernel_itimerspec __user *otmr);\n4412 long sys_utimensat(int dfd, const char __user *filename, struct __kernel_timespec __user *utimes, int flags);\n4413 long sys_pselect6(int, fd_set __user *, fd_set __user *, fd_set __user *, struct __kernel_timespec __user *, void __user *);\n4414 long sys_ppoll(struct pollfd __user *, unsigned int, struct __kernel_timespec __user *, const sigset_t __user *, size_t);\n4416 long sys_io_pgetevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct __kernel_timespec __user *timeout, const struct __aio_sigset *sig);\n4417 long sys_recvmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags, struct __kernel_timespec __user *timeout);\n```\n\n----------------------------------------\n\nTITLE: Defining QMP Query Command Schema - QAPI Python-Like (JSON) Schema\nDESCRIPTION: This snippet establishes the schema for the 'query-alarm-clock' QMP command, which returns a 'QemuAlarmClock' struct. The 'returns' clause specifies the output type created in previous schema definitions, enabling the QAPI system to generate proper stub functions and serialization logic. This declaration must appear in the QAPI schema to enable the command for front-end clients.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/writing-qmp-commands.txt#_snippet_10\n\nLANGUAGE: qapi\nCODE:\n```\n{ 'command': 'query-alarm-clock', 'returns': 'QemuAlarmClock' }\n```\n\n----------------------------------------\n\nTITLE: Loop Barrier Hoisting with Atomic Reads - C\nDESCRIPTION: Shows how implicit barriers in atomic_mb_read() can be hoisted outside a loop for efficiency. The snippet transforms a loop that reads array elements with an acquire barrier per iteration to a version where standard atomic reads are used in the loop, and a single acquire barrier is placed at the end. This assumes independent variable access and is valid when only one other thread accesses each variable. Useful for optimizing multi-variable reads in array-processing loops, using C atomic/barrier intrinsics.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/atomics.txt#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nn = 0;                                  n = 0;\\nfor (i = 0; i < 10; i++)          =>    for (i = 0; i < 10; i++)\\n  n += atomic_mb_read(&a[i]);             n += atomic_read(&a[i]);\\n                                         smp_mb_acquire();\n```\n\n----------------------------------------\n\nTITLE: Traversing and Displaying Alarm Methods via HMP in C\nDESCRIPTION: Defines the HMP handler hmp_info_alarm_methods, which invokes qmp_query_alarm_methods and iterates through the returned TimerAlarmMethodList, displaying each method and indicating the currently active one. Dependencies: QEMU monitor interface, QAPI-generated list/free routines, and error management utilities. Inputs: Monitor pointer (mon). Outputs: Printed list of alarm methods with asterisks marking the active one. Limitations: Requires proper cleanup of list allocations and error conditions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/writing-qmp-commands.txt#_snippet_16\n\nLANGUAGE: C\nCODE:\n```\nvoid hmp_info_alarm_methods(Monitor *mon)\n{\n    TimerAlarmMethodList *method_list, *method;\n    Error *err = NULL;\n\n    method_list = qmp_query_alarm_methods(&err);\n    if (err) {\n        monitor_printf(mon, \"Could not query alarm methods\\n\");\n        error_free(err);\n        return;\n    }\n\n    for (method = method_list; method; method = method->next) {\n        monitor_printf(mon, \"%c %s\\n\", method->value->current ? '*' : ' ',\n                                       method->value->method_name);\n    }\n\n    qapi_free_TimerAlarmMethodList(method_list);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating SystemTap Wrapper Probes for QEMU\nDESCRIPTION: Shows how to manually generate a .stp file with wrapper probes for SystemTap integration with QEMU.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/tracing.txt#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nscripts/tracetool.py --backends=dtrace --format=stap \\\n                         --binary path/to/qemu-binary \\\n                         --target-type system \\\n                         --target-name x86_64 \\\n                         <trace-events-all >qemu.stp\n```\n\n----------------------------------------\n\nTITLE: Installing PANDA Python Interface via pip (Shell)\nDESCRIPTION: This single-line shell command installs the PyPANDA interface to PANDA using pip. It requires a working Python environment with pip3 available. The command fetches PyPANDA from the PyPI repository, making it possible to conduct analyses in Python but does NOT provide core PANDA binaries for standalone execution. Supported architectures are mainly 64-bit Ubuntu, and other environments may not work as expected.\nSOURCE: https://github.com/panda-re/panda/blob/dev/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\npip3 install pandare\n```\n\n----------------------------------------\n\nTITLE: Declaring Linux System Call Prototypes - C\nDESCRIPTION: This snippet declares a series of system call function prototypes, each representing a kernel entry point for user-level requests. Dependencies include kernel headers for types such as sigset_t, struct iovec, and various __user-marked pointers to enforce user/kernel boundary checks. These functions take carefully specified parameters (like descriptors, structures, buffer sizes, and flags) and return long integers to indicate syscall status, allowing the kernel to offer a stable ABI for process, file, timer, or IPC operations. Expected inputs are syscall arguments passed from userspace; outputs are returned via syscall convention or by writing to output pointers. Limitations include strict parameter typing and reliance on corresponding kernel implementations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64n32_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n6275 long sys_getcpu(unsigned __user *cpu, unsigned __user *node, struct getcpu_cache __user *cache);\n6276 long sys_epoll_pwait(int epfd, struct epoll_event __user *events, int maxevents, int timeout, const sigset_t __user *sigmask, size_t sigsetsize);\n6277 long sys_ioprio_set(int which, int who, int ioprio);\n6278 long sys_ioprio_get(int which, int who);\n6279 long sys_utimensat_time32(unsigned int dfd, const char __user *filename, struct old_timespec32 __user *t, int flags);\n6280 long sys_signalfd(int ufd, sigset_t __user *user_mask, size_t sizemask);\n6281 long sys_ni_syscall(void);\n6282 long sys_eventfd(unsigned int count);\n6283 long sys_fallocate(int fd, int mode, loff_t offset, loff_t len);\n6284 long sys_timerfd_create(int clockid, int flags);\n6285 long sys_timerfd_gettime32(int ufd, struct old_itimerspec32 __user *otmr);\n6286 long sys_timerfd_settime32(int ufd, int flags, const struct old_itimerspec32 __user *utmr, struct old_itimerspec32 __user *otmr);\n6287 long sys_signalfd4(int ufd, sigset_t __user *user_mask, size_t sizemask, int flags);\n6288 long sys_eventfd2(unsigned int count, int flags);\n6289 long sys_epoll_create1(int flags);\n6290 long sys_dup3(unsigned int oldfd, unsigned int newfd, int flags);\n6291 long sys_pipe2(int __user *fildes, int flags);\n6292 long sys_inotify_init1(int flags);\n6293 long sys_preadv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);\n6294 long sys_pwritev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);\n6295 long sys_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t __user *uinfo);\n6296 long sys_perf_event_open(struct perf_event_attr __user *attr_uptr, pid_t pid, int cpu, int group_fd, unsigned long flags);\n6297 long sys_accept4(int, struct sockaddr __user *, int __user *, int);\n6298 long sys_ppoll_time32(struct pollfd __user *, unsigned int, struct old_timespec32 __user *, const sigset_t __user *, size_t);\n6299 long sys_getdents64(unsigned int fd, struct linux_dirent64 __user *dirent, unsigned int count);\n6300 long sys_fanotify_init(unsigned int flags, unsigned int event_f_flags);\n6301 long sys_fanotify_mark(int fanotify_fd, unsigned int flags, u64 mask, int fd, const char __user *pathname);\n6302 long sys_prlimit64(pid_t pid, unsigned int resource, const struct rlimit64 __user *new_rlim, struct rlimit64 __user *old_rlim);\n6303 long sys_name_to_handle_at(int dfd, const char __user *name, struct file_handle __user *handle, int __user *mnt_id, int flag);\n6304 long sys_open_by_handle_at(int mountdirfd, struct file_handle __user *handle, int flags);\n6305 long sys_clock_adjtime32(clockid_t which_clock, struct old_timex32 __user *tx);\n6306 long sys_syncfs(int fd);\n6307 long sys_sendmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags);\n6308 long sys_setns(int fd, int nstype);\n6309 long sys_process_vm_readv(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);\n6310 long sys_process_vm_writev(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);\n6311 long sys_kcmp(pid_t pid1, pid_t pid2, int type, unsigned long idx1, unsigned long idx2);\n6312 long sys_finit_module(int fd, const char __user *uargs, int flags);\n6313 long sys_sched_setattr(pid_t pid, struct sched_attr __user *attr, unsigned int flags);\n6314 long sys_sched_getattr(pid_t pid, struct sched_attr __user *attr, unsigned int size, unsigned int flags);\n6315 long sys_renameat2(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, unsigned int flags);\n6316 long sys_seccomp(unsigned int op, unsigned int flags, void __user *uargs);\n6317 long sys_getrandom(char __user *buf, size_t count, unsigned int flags);\n6318 long sys_memfd_create(const char __user *uname_ptr, unsigned int flags);\n6319 long sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);\n6320 long sys_execveat(int dfd, const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp, int flags);\n6321 long sys_userfaultfd(int flags);\n6322 long sys_membarrier(int cmd, int flags);\n6323 long sys_mlock2(unsigned long start, size_t len, int flags);\n6324 long sys_copy_file_range(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);\n6325 long sys_preadv2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);\n6326 long sys_pwritev2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);\n6327 long sys_pkey_mprotect(unsigned long start, size_t len, unsigned long prot, int pkey);\n6328 long sys_pkey_alloc(unsigned long flags, unsigned long init_val);\n6329 long sys_pkey_free(int pkey);\n6330 long sys_statx(int dfd, const char __user *path, unsigned flags, unsigned mask, struct statx __user *buffer);\n6331 long sys_rseq(struct rseq __user *rseq, uint32_t rseq_len, int flags, uint32_t sig);\n6332 long sys_io_pgetevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct __kernel_timespec __user *timeout, const struct __aio_sigset *sig);\n6403 long sys_clock_gettime(clockid_t which_clock, struct __kernel_timespec __user *tp);\n6404 long sys_clock_settime(clockid_t which_clock, const struct __kernel_timespec __user *tp);\n6405 long sys_clock_adjtime(clockid_t which_clock, struct __kernel_timex __user *tx);\n6406 long sys_clock_getres(clockid_t which_clock, struct __kernel_timespec __user *tp);\n6407 long sys_clock_nanosleep(clockid_t which_clock, int flags, const struct __kernel_timespec __user *rqtp, struct __kernel_timespec __user *rmtp);\n6408 long sys_timer_gettime(timer_t timer_id, struct __kernel_itimerspec __user *setting);\n6409 long sys_timer_settime(timer_t timer_id, int flags, const struct __kernel_itimerspec __user *new_setting, struct __kernel_itimerspec __user *old_setting);\n6410 long sys_timerfd_gettime(int ufd, struct __kernel_itimerspec __user *otmr);\n6411 long sys_timerfd_settime(int ufd, int flags, const struct __kernel_itimerspec __user *utmr, struct __kernel_itimerspec __user *otmr);\n6412 long sys_utimensat(int dfd, const char __user *filename, struct __kernel_timespec __user *utimes, int flags);\n6416 long sys_io_pgetevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct __kernel_timespec __user *timeout, const struct __aio_sigset *sig);\n6418 long sys_mq_timedsend(mqd_t mqdes, const char __user *msg_ptr, size_t msg_len, unsigned int msg_prio, const struct __kernel_timespec __user *abs_timeout);\n6419 long sys_mq_timedreceive(mqd_t mqdes, char __user *msg_ptr, size_t msg_len, unsigned int __user *msg_prio, const struct __kernel_timespec __user *abs_timeout);\n6420 long sys_semtimedop(int semid, struct sembuf __user *sops, unsigned nsops, const struct __kernel_timespec __user *timeout);\n6422 long sys_futex(u32 __user *uaddr, int op, u32 val, struct __kernel_timespec __user *utime, u32 __user *uaddr2, u32 val3);\n6423 long sys_sched_rr_get_interval(pid_t pid, struct __kernel_timespec __user *interval);\n6424 long sys_pidfd_send_signal(int pidfd, int sig, siginfo_t __user *info, unsigned int flags);\n6425 long sys_io_uring_setup(u32 entries, struct io_uring_params __user *p);\n6426 long sys_io_uring_enter(unsigned int fd, u32 to_submit, u32 min_complete, u32 flags, const sigset_t __user *sig, size_t sigsz);\n6427 long sys_io_uring_register(unsigned int fd, unsigned int op, void __user *arg, unsigned int nr_args);\n6428 long sys_open_tree(int dfd, const char __user *path, unsigned flags);\n6429 long sys_move_mount(int from_dfd, const char __user *from_path, int to_dfd, const char __user *to_path, unsigned int ms_flags);\n6430 long sys_fsopen(const char __user *fs_name, unsigned int flags);\n6431 long sys_fsconfig(int fs_fd, unsigned int cmd, const char __user *key, const void __user *value, int aux);\n6432 long sys_fsmount(int fs_fd, unsigned int flags, unsigned int ms_flags);\n6433 long sys_fspick(int dfd, const char __user *path, unsigned int flags);\n6434 long sys_pidfd_open(pid_t pid, unsigned int flags);\n6435 long sys_clone3(struct clone_args __user *uargs, size_t size);\n6437 long sys_openat2(int dfd, const char __user *filename, struct open_how *how, size_t size);\n6438 long sys_pidfd_getfd(int pidfd, int fd, unsigned int flags);\n6439 long sys_faccessat2(int dfd, const char __user *filename, int mode, int flags);\n```\n\n----------------------------------------\n\nTITLE: Querying Alarm Clock Implementation - C for QEMU\nDESCRIPTION: This function provides the C implementation behind the 'query-alarm-clock' QMP handler, constructing and returning a QemuAlarmClock instance. It obtains data from lower-level timer routines, initializes all struct members defensively, and sets optional fields according to returned state. Dependencies include memory allocation APIs and external timer infrastructure. Function expects an error double-pointer for reporting, and returns a pointer to a dynamically-allocated QAPI struct. The caller is responsible for freeing the result via generated QAPI free functions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/writing-qmp-commands.txt#_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nQemuAlarmClock *qmp_query_alarm_clock(Error **errp)\n{\n    QemuAlarmClock *clock;\n    int64_t deadline;\n\n    clock = g_malloc0(sizeof(*clock));\n\n    deadline = qemu_next_alarm_deadline();\n    if (deadline > 0) {\n        clock->has_next_deadline = true;\n        clock->next_deadline = deadline;\n    }\n    clock->clock_name = g_strdup(alarm_timer->name);\n\n    return clock;\n}\n```\n\n----------------------------------------\n\nTITLE: Activating Compression for QEMU Migration\nDESCRIPTION: Commands to verify compression support, activate compression, set compression parameters, and initiate migration in QEMU.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/multi-thread-compression.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n{qemu} info migrate_capabilities\n{qemu} migrate_set_capability compress on\n{qemu} migrate_set_parameter compress_threads 12\n{qemu} migrate_set_parameter compress_level 1\n{qemu} migrate_set_parameter decompress_threads 3\n{qemu} migrate -d tcp:destination.host:4444\n{qemu} info migrate\n```\n\n----------------------------------------\n\nTITLE: Calling a Guest Kernel Function with PANDA callfunc - Shell\nDESCRIPTION: This shell command uses QEMU's PANDA instrumentation with the 'callfunc' plugin to call the ARM kernel function 'kmalloc' at a specific program counter (when 'do_execve' executes), allocating 64KB of memory. No external dependencies are needed except for the specified PANDA setup, the correct disk images, and knowledge of the appropriate memory addresses. Key parameters include the 'when' (PC to trigger), 'func' (target function), and 'args' (hex-dash delimited arguments); all addresses are image-specific and should be adjusted for your test environment. The standard output is the side effect within the guest (memory allocation), and the command needs to be run within an appropriately configured PANDA/QEMU environment.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/callfunc/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\narm-softmmu/panda-system-arm -M versatilepb -kernel ~/.panda/vmlinuz-3.2.0-4-versatile \\\n    -initrd ~/.panda/initrd.img-3.2.0-4-versatile -hda ~/.panda/arm_wheezy.qcow \\\n    -serial stdio -loadvm root -display none \\\n    -panda callfunc:when=0xc00ca05c,func=0xc00bb0cc,args=\"0x10000-0xd0\"\n```\n\n----------------------------------------\n\nTITLE: Stack Offset Arithmetic and Zero-Extension Before Store - LLVM IR\nDESCRIPTION: These instructions adjust stack offset by subtraction, mask it, and use helper functions to store a predefined value with further address computation. Post-processing includes truncating, zero-extending, and logging the resulting address before writing to stack. All stages ensure proper state tracking for emulated stack behavior.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/dynslice.md#_snippet_14\n\nLANGUAGE: llvm\nCODE:\n```\n%tmp2_v18 = add i64 %tmp-12_v12, -4\n```\n\nLANGUAGE: llvm\nCODE:\n```\n%tmp2_v19 = and i64 %tmp2_v18, 4294967295\ncall void @__stl_mmu_panda(i64 %tmp2_v19, i32 1958292470, i32 1)\n```\n\nLANGUAGE: llvm\nCODE:\n```\n%63 = trunc i64 %tmp2_v19 to i32\n```\n\nLANGUAGE: llvm\nCODE:\n```\n%tmp-12_v21 = zext i32 %63 to i64\n%64 = ptrtoint i64* %rsp_ptr to i64\ncall void @log_dynval(i64 59634320, i32 0, i32 2, i64 %64)\n```\n\nLANGUAGE: llvm\nCODE:\n```\nstore i64 %tmp-12_v21, i64* %rsp_ptr\n%65 = add i64 %env_v, 128\n%66 = inttoptr i64 %65 to i64*\n%67 = ptrtoint i64* %66 to i64\ncall void @log_dynval(i64 59634320, i32 0, i32 2, i64 %67)\nstore i64 %tmp0_v17, i64* %66\nret i64 0\n```\n\n----------------------------------------\n\nTITLE: Referencing Makefile in Markdown\nDESCRIPTION: This snippet provides a Markdown link to the Makefile in the current directory. The Makefile is used to build any binaries required for the tests, excluding PANDA itself.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/tests/README.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n[`./Makefile`](./Makefile)\n```\n\n----------------------------------------\n\nTITLE: Callback Function for Numeric Argument Match in C\nDESCRIPTION: This C function signature represents the callback triggered when a numeric argument matches a target value. It provides CPU state, argument array, matching index, and number of arguments read.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/callwitharg/README.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\non_call_match_num(CPUState *cpu, target_ulong* args, uint matching_idx, uint args_read);\n```\n\n----------------------------------------\n\nTITLE: Changing Block Device Hierarchy for Replication - QEMU Machine Protocol - JSON\nDESCRIPTION: This QMP JSON command alters the block device graph in the running Primary QEMU instance to include the previously added NBD-backed replication node under the specified quorum parent. This requires a QEMU process with QMP access and the earlier drive_add operation. Key arguments are 'parent' (id of quorum node) and 'node' (id of the nbd_client replication node). Should be executed after configuring the replication driver.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/block-replication.txt#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{ 'execute': 'x-blockdev-change',\n  'arguments': {\n      'parent': 'colo1',\n      'node': 'nbd_client1'\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Block Device Removal via QMP - JSON\nDESCRIPTION: This snippet demonstrates how to issue a QMP command to remove a block device, using the 'human-monitor-command' execute value and specifying the 'drive_del' command for a target device. No direct QMP command exists for removing block devices, so the human command interface is used. Prerequisites include a running QEMU process with QMP enabled, and valid drive identifiers. Input is a JSON object specifying the execute and arguments fields; output is QEMU's response to the command.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/block-replication.txt#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"execute\": \"human-monitor-command\",\n  \"arguments\": {\n    \"command-line\": \"drive_del xxxx\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Replay Packet Handler Function Pointer - C\nDESCRIPTION: Declares a function pointer type named replay_handle_packet which expects arguments for capturing and processing a packet in the context of PANDA's CPUState. This snippet is part of the PANDA replay interface, handling packet replay by taking in buffer pointers, direction, size, and recorded buffer addresses. Dependencies include the presence of PANDA's CPUState structure and matching data types; primary inputs are CPUState, a data buffer, its size, direction, and a buffer address.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_55\n\nLANGUAGE: C\nCODE:\n```\nint (*replay_handle_packet)(CPUState *env, uint8_t *buf, int size,\\n                            uint8_t direction, uint64_t buf_addr_rec);\n```\n\n----------------------------------------\n\nTITLE: Creating a Movie from Captured Frames\nDESCRIPTION: Shell command to run the movie.sh script provided by the replaymovie plugin. This script uses ffmpeg to generate an MP4 video from the sequence of PPM files.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/replaymovie/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$PLUGINS_PATH/replaymovie/movie.sh\n```\n\n----------------------------------------\n\nTITLE: Memory Locking and Scheduling Functions in C\nDESCRIPTION: Function declarations for memory locking operations and process scheduling control. These include functions to lock/unlock memory pages and to get/set scheduling parameters.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nint mlockall(int how);\nint munlockall(void); \nint __getcwd(char *buf, size_t buflen);\nint sched_setparam(pid_t pid, const struct sched_param *param);\nint sched_getparam(pid_t pid, struct sched_param *param);\nint sched_setscheduler(pid_t pid, int policy, const struct sched_param *param);\nint sched_getscheduler(pid_t pid);\nint sched_yield(void);\nint sched_get_priority_max(int policy);\nint sched_get_priority_min(int policy);\nint sched_rr_get_interval(pid_t pid, struct timespec *interval);\nint utrace(const void *addr, size_t len);\nint sendfile(int fd, int s, off_t offset, size_t nbytes, struct sf_hdtr *hdtr, off_t *sbytes, int flags);\nint kldsym(int fileid, int cmd, void *data);\nint jail(struct jail *jail);\n```\n\n----------------------------------------\n\nTITLE: Declaring Before Block Translation Callback Signature in PANDA (C)\nDESCRIPTION: Declares the function pointer type for the 'before block translate' callback, allowing plugin authors to insert custom logic just before each basic block is translated by PANDA. Depends on the PANDA framework, with arguments for the current CPU state and guest program counter, no return value required. Input parameters are pointers to the CPU state and the target PC; the output is unused.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_30\n\nLANGUAGE: C\nCODE:\n```\nvoid (*before_block_translate)(CPUState *env, target_ulong pc);\n```\n\n----------------------------------------\n\nTITLE: QAPI Documentation Example with List and Example Blocks - Markdown\nDESCRIPTION: Combines several documentation comment features in a comprehensive block, including section titles, styled text, numbered lists, and embedded code examples. This serves as a template for writing well-formatted QAPI schema documentation. The block must be enclosed between '##' lines and is parsed by the QAPI doc generator.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_4\n\nLANGUAGE: Markdown\nCODE:\n```\n##\n# = Section\n# == Subsection\n#\n# Some text foo with *strong* and _emphasis_\n# 1. with a list\n# 2. like that\n#\n# And some code:\n# | $ echo foo\n# | -> do this\n# | <- get that\n#\n##\n```\n\n----------------------------------------\n\nTITLE: Implementing Visitor Functions for Schema-Generated Types in C\nDESCRIPTION: These visitor functions, produced by qapi-visit.py, traverse struct members and handle conversion and validation between QAPI C structs and external representations. Required dependencies are the previously generated struct definitions, QObject visitor API, and error handling infrastructure. Key parameters include pointers to visitor objects and error containers; expected behavior is to visit or convert each member (including handling optional fields) and propagate any errors encountered.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_21\n\nLANGUAGE: C\nCODE:\n```\n#ifndef EXAMPLE_QAPI_VISIT_H\\n#define EXAMPLE_QAPI_VISIT_H\\n\\nvoid visit_type_UserDefOne_members(Visitor *v, UserDefOne *obj, Error **errp);\\nvoid visit_type_UserDefOne(Visitor *v, const char *name, UserDefOne **obj, Error **errp);\\nvoid visit_type_UserDefOneList(Visitor *v, const char *name, UserDefOneList **obj, Error **errp);\\n\\n#endif\n```\n\nLANGUAGE: C\nCODE:\n```\nvoid visit_type_UserDefOne_members(Visitor *v, UserDefOne *obj, Error **errp)\\n{\\n    Error *err = NULL;\\n\\n    visit_type_int(v, \\\"integer\\\", &obj->integer, &err);\\n    if (err) {\\n        goto out;\\n    }\\n    if (visit_optional(v, \\\"string\\\", &obj->has_string)) {\\n        visit_type_str(v, \\\"string\\\", &obj->string, &err);\\n        if (err) {\\n            goto out;\\n        }\\n    }\\n\\nout:\\n    error_propagate(errp, err);\\n}\\n\\nvoid visit_type_UserDefOne(Visitor *v, const char *name, UserDefOne **obj, Error **errp)\\n{\\n    Error *err = NULL;\\n\\n    visit_start_struct(v, name, (void **)obj, sizeof(UserDefOne), &err);\\n    if (err) {\\n        goto out;\\n    }\\n    if (!*obj) {\\n        goto out_obj;\\n    }\\n    visit_type_UserDefOne_members(v, *obj, &err);\\n    if (err) {\\n        goto out_obj;\\n    }\\n    visit_check_struct(v, &err);\\nout_obj:\\n    visit_end_struct(v, (void **)obj);\\n    if (err && visit_is_input(v)) {\\n        qapi_free_UserDefOne(*obj);\\n        *obj = NULL;\\n    }\\nout:\\n    error_propagate(errp, err);\\n}\\n\\nvoid visit_type_UserDefOneList(Visitor *v, const char *name, UserDefOneList **obj, Error **errp)\\n{\\n    Error *err = NULL;\\n    UserDefOneList *tail;\\n    size_t size = sizeof(**obj);\\n\\n    visit_start_list(v, name, (GenericList **)obj, size, &err);\\n    if (err) {\\n        goto out;\\n    }\\n\\n    for (tail = *obj; tail;\\n         tail = (UserDefOneList *)visit_next_list(v, (GenericList *)tail, size)) {\\n        visit_type_UserDefOne(v, NULL, &tail->value, &err);\\n        if (err) {\\n            break;\\n        }\\n    }\\n\\n    visit_end_list(v, (void **)obj);\\n    if (err && visit_is_input(v)) {\\n        qapi_free_UserDefOneList(*obj);\\n        *obj = NULL;\\n    }\\nout:\\n    error_propagate(errp, err);\\n}\n```\n\n----------------------------------------\n\nTITLE: FreeBSD Stat Functions in C\nDESCRIPTION: Function declarations for retrieving file statistics in FreeBSD. These variants (nstat, nfstat, nlstat) likely represent newer versions of the traditional stat functions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nint nstat(const char *path, struct nstat *ub);\nint nfstat(int fd, struct nstat *sb);\nint nlstat(const char *path, struct nstat *ub);\n```\n\n----------------------------------------\n\nTITLE: Combining Decrement and Lock for Safe Object Free in C\nDESCRIPTION: This snippet combines a visit (inc/dec) to a shared object with safe finalization if required. After accessing the object as normal, it decrements the QemuLockCnt and, if the lock is now acquired (no more users), it frees the object and unlocks. It uses QEMU's QemuLockCnt and atomic RCU API and GLib memory handling.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/lockcnt.txt#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nqemu_lockcnt_inc(&xyz_lockcnt);\nif (xyz) {\n    XYZ *p = atomic_rcu_read(&xyz);\n    ...\n    /* Accesses can now be done through \"p\".  */\n}\nif (qemu_lockcnt_dec_and_lock(&xyz_lockcnt)) {\n    g_free(xyz);\n    xyz = NULL;\n    qemu_lockcnt_unlock(&xyz_lockcnt);\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API Functions for System Objects and Transactions\nDESCRIPTION: Function declarations for Windows NT native system calls (NtXxx functions). These declarations specify the interfaces for creating, opening, manipulating, and querying various system objects including keys, files, processes, transactions, and other kernel resources.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp12_x86_prototypes.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, HANDLE TransactionHandle, PULONG Disposition);\nNTSTATUS NtCreateMailslotFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout);\nNTSTATUS NtCreateMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN InitialOwner);\nNTSTATUS NtCreateNamedPipeFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout);\nNTSTATUS NtCreatePrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\nNTSTATUS NtCreatePagingFile (PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority);\nNTSTATUS NtCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtCreateProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort);\nNTSTATUS NtCreateProcessEx (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel);\nNTSTATUS NtCreateProfile (PHANDLE ProfileHandle, HANDLE Process, PVOID RangeBase, SIZE_T RangeSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);\nNTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);\nNTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);\nNTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);\nNTSTATUS NtCreateThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended);\nNTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);\nNTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);\nNTSTATUS NtCreateTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle, ULONG CreateOptions, ULONG IsolationLevel, ULONG IsolationFlags, PLARGE_INTEGER Timeout, PUNICODE_STRING Description);\nNTSTATUS NtOpenTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle);\nNTSTATUS NtQueryInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationTransactionManager (HANDLE TransactionManagerHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength, PULONG ReturnLength);\nNTSTATUS NtPrePrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCommitEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtReadOnlyEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRollbackComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRollbackEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCommitTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\nNTSTATUS NtRollbackTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\nNTSTATUS NtPrePrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCommitComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtSinglePhaseReject (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtSetInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength);\nNTSTATUS NtSetInformationTransactionManager (HANDLE TmHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength);\nNTSTATUS NtSetInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength);\nNTSTATUS NtCreateTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, ULONG CreateOptions, ULONG CommitStrength);\nNTSTATUS NtOpenTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, LPGUID TmIdentity, ULONG OpenOptions);\nNTSTATUS NtRenameTransactionManager (PUNICODE_STRING LogFileName, LPGUID ExistingTransactionManagerGuid);\nNTSTATUS NtRollforwardTransactionManager (HANDLE TransactionManagerHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRecoverEnlistment (HANDLE EnlistmentHandle, PVOID EnlistmentKey);\nNTSTATUS NtRecoverResourceManager (HANDLE ResourceManagerHandle);\nNTSTATUS NtRecoverTransactionManager (HANDLE TransactionManagerHandle);\nNTSTATUS NtCreateResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID RmGuid, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, PUNICODE_STRING Description);\nNTSTATUS NtOpenResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID ResourceManagerGuid, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtGetNotificationResourceManager (HANDLE ResourceManagerHandle, PTRANSACTION_NOTIFICATION TransactionNotification, ULONG NotificationLength, PLARGE_INTEGER Timeout, PULONG ReturnLength, ULONG Asynchronous, ULONG_PTR AsynchronousContext);\nNTSTATUS NtQueryInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength, PULONG ReturnLength);\nNTSTATUS NtCreateEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, HANDLE TransactionHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, NOTIFICATION_MASK NotificationMask, PVOID EnlistmentKey);\nNTSTATUS NtOpenEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, LPGUID EnlistmentGuid, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtSetInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength);\nNTSTATUS NtQueryInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength, PULONG ReturnLength);\nNTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtDebugActiveProcess (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtDebugContinue (HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);\nNTSTATUS NtDelayExecution (BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);\nNTSTATUS NtDeleteAtom (RTL_ATOM Atom);\nNTSTATUS NtDeleteBootEntry (ULONG Id);\nNTSTATUS NtDeleteDriverEntry (ULONG Id);\nNTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtDeleteKey (HANDLE KeyHandle);\nNTSTATUS NtDeletePrivateNamespace (HANDLE NamespaceHandle);\nNTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);\nNTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtDisplayString (PUNICODE_STRING String);\nNTSTATUS NtDuplicateObject (HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);\n```\n\n----------------------------------------\n\nTITLE: Defining Debug and Atom Management System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to process debugging and atom table management. These functions provide debugging control and atom table manipulation capabilities.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_15\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtDebugActiveProcess (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtDebugContinue (HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);\nNTSTATUS NtDeleteAtom (RTL_ATOM Atom);\n```\n\n----------------------------------------\n\nTITLE: Creating Udev Rules for Auto Seat Assignment on Guest - Udev Rules\nDESCRIPTION: These snippets are udev rule file contents to automate seat assignment in the guest. They define static device rules for PCI bridges using either devpath or vendor/device IDs. Place the file in /etc/udev/rules.d/ in the guest. No special runtime dependencies beyond udev. Key parameters are SUBSYSTEM, DEVPATH/ATTR filters, and the assignment of TAG+=\\\"seat\\\", ENV{ID_AUTOSEAT}=\\\"1\\\" which lets systemd logind know these devices belong to a new seat. Output: on reboot, seats are automatically detected and registered.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/multiseat.txt#_snippet_4\n\nLANGUAGE: udev\nCODE:\n```\nSUBSYSTEMS==\"pci\", DEVPATH==\"*/0000:00:12.0\", TAG+=\"seat\", ENV{ID_AUTOSEAT}=\"1\"\n```\n\nLANGUAGE: udev\nCODE:\n```\nSUBSYSTEM==\"pci\", ATTR{vendor}==\"0x1b36\", ATTR{device}==\"0x000a\", \\\n        TAG+=\"seat\", ENV{ID_AUTOSEAT}=\"1\"\n```\n\n----------------------------------------\n\nTITLE: Launching QEMU System for Guest OS Installation with blkverify Block Layer (Shell)\nDESCRIPTION: Invokes QEMU to start a virtual machine with a CD-ROM ISO (debian.iso) and a blkverify device combining raw.img and test.qcow2 as storage. Facilitates active block driver testing during live OS installation, with corruption detection by blkverify. Requires QEMU installation and prepared disk images.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/blkverify.txt#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ x86_64-softmmu/qemu-system-x86_64 -cdrom debian.iso \\\n                                        -drive file=blkverify:raw.img:test.qcow2\n```\n\n----------------------------------------\n\nTITLE: Viewing the Dynamic Slice in a Basic Block with slice_viewer Utility via Shell Command\nDESCRIPTION: This shell snippet demonstrates invoking the slice_viewer utility to display which instructions in a particular LLVM basic block were included in the computed dynamic slice. The command takes as arguments the LLVM bitcode file, the slice report binary log (from dynslice), and the function/block name (e.g., tcg-llvm-tb-31408-74b92bec). It prints a listing of the block with marked (sliced) instructions for inspection, facilitating understanding of sliced code regions. Prerequisites are completion of earlier steps and having the relevant report/log files present.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/dynslice.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n./slice_viewer llvm-mod.bc slice_report.bin tcg-llvm-tb-31408-74b92bec\n```\n\n----------------------------------------\n\nTITLE: Enabling and Disabling Named Callbacks in PyPANDA with Python\nDESCRIPTION: This code demonstrates how to assign a custom name and disabled state to a callback function via @panda.cb_before_block_exec decorator arguments, and then enable the callback at runtime using panda.enable_callback(). This pattern is used for managing which callbacks are active during different analysis phases. No direct dependencies beyond PyPANDA base; arguments: callback name and enabled flag; Output: enables or disables execution of callback functions as the guest runs.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/docs/USAGE.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@panda.cb_before_block_exec(name='my_callback', enabled=False)\ndef my_before_block_fn(cpustate, translation_block):\n  ...\npanda.enable_callback('my_callback')\n```\n\n----------------------------------------\n\nTITLE: Running PANDA with Network Plugin to Capture Traffic\nDESCRIPTION: This command demonstrates how to use the network plugin with PANDA to save network traffic from a replay to a PCAP file. It specifies the replay file and the output PCAP filename.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/network/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo \\\n    -panda network:file=foo.pcap\n```\n\n----------------------------------------\n\nTITLE: Splitting Loops to Hoist Barriers and Eliminate smp_mb() - C\nDESCRIPTION: This transformation splits a loop to allow hoisting of memory barriers out of the loop and eliminating an expensive smp_mb(). Each array element is updated using atomic_set() and a write memory barrier (smp_wmb()) is inserted between the loops. This approach is beneficial when independent variables are modified and threads require minimal synchronization overhead, with correctness preserved using QEMU/C atomic and memory barrier functions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/atomics.txt#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nsmp_mb_release();\\nfor (i = 0; i < 10; i++) {        =>    for (i = 0; i < 10; i++)\\n  atomic_mb_set(&a[i], false);            atomic_set(&a[i], false);\\n  atomic_mb_set(&b[i], false);          smb_wmb();\\n}                                       for (i = 0; i < 10; i++)\\n                                           atomic_set(&a[i], false);\\n                                         smp_mb();\n```\n\n----------------------------------------\n\nTITLE: Declaring NT System Service Prototypes - Windows Native API - C\nDESCRIPTION: These code snippets declare a set of C function prototypes for native Windows system services (NTAPI). The prototypes rely on Windows platform data types and are typically used in contexts where direct interaction with the kernel or low-level subsystems is required. Each declaration specifies the function name, return type (usually NTSTATUS or BOOLEAN), and typed parameters following Windows conventions. No implementation is provided; these are meant to be included in C header files for linking with corresponding system libraries or for FFI. Parameters must be compatible with Windows system structures, and the prototypes require appropriate privilege and context for meaningful invocation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2003sp0_x86_prototypes.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDebugContinue (HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDelayExecution (BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeleteAtom (RTL_ATOM Atom);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeleteBootEntry (ULONG Id);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeleteDriverEntry (ULONG Id);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeleteKey (HANDLE KeyHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDisplayString (PUNICODE_STRING String);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDuplicateObject (HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDuplicateToken (HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtEnumerateBootEntries (PVOID Buffer, PULONG BufferLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtEnumerateDriverEntries (PVOID Buffer, PULONG BufferLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtEnumerateKey (HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtEnumerateSystemEnvironmentValuesEx (ULONG InformationClass, PVOID Buffer, PULONG BufferLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtEnumerateValueKey (HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFindAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFlushBuffersFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFlushKey (HANDLE KeyHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFlushWriteBuffer ();\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG FreeType);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFsControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtGetDevicePowerState (HANDLE Device, DEVICE_POWER_STATE *State);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtGetPlugPlayEvent (HANDLE EventHandle, PVOID Context, PPLUGPLAY_EVENT_BLOCK EventBlock, ULONG EventBufferSize);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtGetWriteWatch (HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, SIZE_T RegionSize, PVOID *UserAddressArray, PULONG_PTR EntriesInUserAddressArray, PULONG Granularity);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtImpersonateAnonymousToken (HANDLE ThreadHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE Message);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtImpersonateThread (HANDLE ServerThreadHandle, HANDLE ClientThreadHandle, PSECURITY_QUALITY_OF_SERVICE SecurityQos);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtInitializeRegistry (USHORT BootCondition);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtInitiatePowerAction (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtIsProcessInJob (HANDLE ProcessHandle, HANDLE JobHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nBOOLEAN NtIsSystemResumeAutomatic ();\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtListenPort (HANDLE PortHandle, PPORT_MESSAGE ConnectionRequest);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtLoadDriver (PUNICODE_STRING DriverServiceName);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtLoadKey (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtLoadKey2 (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtLoadKeyEx (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags, HANDLE TrustClassKey );\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtLockFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtLockProductActivationKeys (ULONG *pPrivateVer, ULONG *pSafeMode);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtLockRegistryKey (HANDLE KeyHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtLockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtMakePermanentObject (HANDLE Handle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtMakeTemporaryObject (HANDLE Handle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtMapUserPhysicalPages (PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, WIN32_PROTECTION_MASK Win32Protect);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtModifyBootEntry (PBOOT_ENTRY BootEntry);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtModifyDriverEntry (PEFI_DRIVER_ENTRY DriverEntry);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtNotifyChangeDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtNotifyChangeKey (HANDLE KeyHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtNotifyChangeMultipleKeys (HANDLE MasterKeyHandle, ULONG Count, OBJECT_ATTRIBUTES SlaveObjects[], HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, ACCESS_MASK GrantedAccess, PPRIVILEGE_SET Privileges, BOOLEAN ObjectCreation, BOOLEAN AccessGranted, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenProcessToken (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenProcessTokenEx (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenThreadToken (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenThreadTokenEx (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtPlugPlayControl (PLUGPLAY_CONTROL_CLASS PnPControlClass, PVOID PnPControlData, ULONG PnPControlDataLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtPowerInformation (POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtPrivilegeCheck (HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, PBOOLEAN Result);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtPrivilegeObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtPrivilegedServiceAuditAlarm (PUNICODE_STRING SubsystemName, PUNICODE_STRING ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\n```\n\n----------------------------------------\n\nTITLE: Declaring Linux System Call Prototypes - C\nDESCRIPTION: This snippet lists the function prototypes for a large set of Linux system calls in C, each prefixed with its syscall table offset. The code serves as a reference or header for syscall interface definitions, specifying return types, parameter types (including user-space pointers and kernel structs), and syscall-specific arguments. It does not provide implementations, only declarations, and relies on various kernel/user structs and typedefs (e.g., stat, sigaction, sockaddr) to define syscall parameters.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64n32_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n6000 long sys_read(unsigned int fd, char __user *buf, size_t count);\n6001 long sys_write(unsigned int fd, const char __user *buf, size_t count);\n6002 long sys_open(const char __user *filename, int flags, umode_t mode);\n6003 long sys_close(unsigned int fd);\n6004 long sys_newstat(const char __user *filename, struct stat __user *statbuf);\n6005 long sys_newfstat(unsigned int fd, struct stat __user *statbuf);\n6006 long sys_newlstat(const char __user *filename, struct stat __user *statbuf);\n6007 long sys_poll(struct pollfd __user *ufds, unsigned int nfds, int timeout);\n6008 long sys_lseek(unsigned int fd, off_t offset, unsigned int whence);\n6009 long sys_old_mmap(struct mmap_arg_struct __user *arg);\n6010 long sys_mprotect(unsigned long start, size_t len, unsigned long prot);\n6011 long sys_munmap(unsigned long addr, size_t len);\n6012 long sys_brk(unsigned long brk);\n6013 long sys_rt_sigaction(int, const struct sigaction __user *, struct sigaction __user *, size_t);\n6014 long sys_rt_sigprocmask(int how, sigset_t __user *set, sigset_t __user *oset, size_t sigsetsize);\n6015 long sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);\n6016 long sys_pread64(unsigned int fd, char __user *buf, size_t count, loff_t pos);\n6017 long sys_pwrite64(unsigned int fd, const char __user *buf, size_t count, loff_t pos);\n6018 long sys_readv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\n6019 long sys_writev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\n6020 long sys_access(const char __user *filename, int mode);\n6021 long sys_pipe(int __user *fildes);\n6022 long sys_select(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct __kernel_old_timeval __user *tvp);\n6023 long sys_sched_yield(void);\n6024 long sys_mremap(unsigned long addr, unsigned long old_len, unsigned long new_len, unsigned long flags, unsigned long new_addr);\n6025 long sys_msync(unsigned long start, size_t len, int flags);\n6026 long sys_mincore(unsigned long start, size_t len, unsigned char __user *vec);\n6027 long sys_madvise(unsigned long start, size_t len, int behavior);\n6028 long sys_shmget(key_t key, size_t size, int flag);\n6029 long sys_shmat(int shmid, char __user *shmaddr, int shmflg);\n6030 long sys_old_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);\n6031 long sys_dup(unsigned int fildes);\n6032 long sys_dup2(unsigned int oldfd, unsigned int newfd);\n6033 long sys_pause(void);\n6034 long sys_nanosleep_time32(struct old_timespec32 __user *rqtp, struct old_timespec32 __user *rmtp);\n6035 long sys_getitimer(int which, struct __kernel_old_itimerval __user *value);\n6036 long sys_setitimer(int which, struct __kernel_old_itimerval __user *value, struct __kernel_old_itimerval __user *ovalue);\n6037 long sys_alarm(unsigned int seconds);\n6038 long sys_getpid(void);\n6039 long sys_sendfile(int out_fd, int in_fd, off_t __user *offset, size_t count);\n6040 long sys_socket(int, int, int);\n6041 long sys_connect(int, struct sockaddr __user *, int);\n6042 long sys_accept(int, struct sockaddr __user *, int __user *);\n6043 long sys_sendto(int, void __user *, size_t, unsigned, struct sockaddr __user *, int);\n6044 long sys_recvfrom(int, void __user *, size_t, unsigned, struct sockaddr __user *, int __user *);\n6045 long sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\n6046 long sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\n6047 long sys_shutdown(int, int);\n6048 long sys_bind(int, struct sockaddr __user *, int);\n6049 long sys_listen(int, int);\n6050 long sys_getsockname(int, struct sockaddr __user *, int __user *);\n6051 long sys_getpeername(int, struct sockaddr __user *, int __user *);\n6052 long sys_socketpair(int, int, int, int __user *);\n6053 long sys_setsockopt(int fd, int level, int optname, char __user *optval, int optlen);\n6054 long sys_getsockopt(int fd, int level, int optname, char __user *optval, int __user *optlen);\n6055 long sys_clone(unsigned long, unsigned long, int __user *, int __user *, unsigned long);\n6056 long sys_fork(void);\n6057 long sys_execve(const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp);\n6058 long sys_exit(int error_code);\n6059 long sys_wait4(pid_t pid, int __user *stat_addr, int options, struct rusage __user *ru);\n6060 long sys_kill(pid_t pid, int sig);\n6061 long sys_newuname(struct new_utsname __user *name);\n6062 long sys_semget(key_t key, int nsems, int semflg);\n6063 long sys_semop(int semid, struct sembuf __user *sops, unsigned nsops);\n6064 long sys_semctl(int semid, int semnum, int cmd, unsigned long arg);\n6065 long sys_shmdt(char __user *shmaddr);\n6066 long sys_msgget(key_t key, int msgflg);\n6067 long sys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz, int msgflg);\n6068 long sys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz, long msgtyp, int msgflg);\n6069 long sys_old_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);\n6070 long sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg);\n6071 long sys_flock(unsigned int fd, unsigned int cmd);\n6072 long sys_fsync(unsigned int fd);\n6073 long sys_fdatasync(unsigned int fd);\n6074 long sys_truncate(const char __user *path, long length);\n6075 long sys_ftruncate(unsigned int fd, unsigned long length);\n6076 long sys_getdents(unsigned int fd, struct linux_dirent __user *dirent, unsigned int count);\n6077 long sys_getcwd(char __user *buf, unsigned long size);\n6078 long sys_chdir(const char __user *filename);\n6079 long sys_fchdir(unsigned int fd);\n6080 long sys_rename(const char __user *oldname, const char __user *newname);\n6081 long sys_mkdir(const char __user *pathname, umode_t mode);\n6082 long sys_rmdir(const char __user *pathname);\n6083 long sys_creat(const char __user *pathname, umode_t mode);\n6084 long sys_link(const char __user *oldname, const char __user *newname);\n6085 long sys_unlink(const char __user *pathname);\n6086 long sys_symlink(const char __user *old, const char __user *new);\n6087 long sys_readlink(const char __user *path, char __user *buf, int bufsiz);\n6088 long sys_chmod(const char __user *filename, umode_t mode);\n6089 long sys_fchmod(unsigned int fd, umode_t mode);\n6090 long sys_chown(const char __user *filename, uid_t user, gid_t group);\n6091 long sys_fchown(unsigned int fd, uid_t user, gid_t group);\n6092 long sys_lchown(const char __user *filename, uid_t user, gid_t group);\n6093 long sys_umask(int mask);\n6094 long sys_gettimeofday(struct __kernel_old_timeval __user *tv, struct timezone __user *tz);\n6095 long sys_getrlimit(unsigned int resource, struct rlimit __user *rlim);\n6096 long sys_getrusage(int who, struct rusage __user *ru);\n6097 long sys_sysinfo(struct sysinfo __user *info);\n6098 long sys_times(struct tms __user *tbuf);\n6099 long sys_ptrace(long request, long pid, unsigned long addr, unsigned long data);\n6100 long sys_getuid(void);\n6101 long sys_syslog(int type, char __user *buf, int len);\n6102 long sys_getgid(void);\n6103 long sys_setuid(uid_t uid);\n6104 long sys_setgid(gid_t gid);\n6105 long sys_geteuid(void);\n6106 long sys_getegid(void);\n6107 long sys_setpgid(pid_t pid, pid_t pgid);\n6108 long sys_getppid(void);\n6109 long sys_getpgrp(void);\n6110 long sys_setsid(void);\n6111 long sys_setreuid(uid_t ruid, uid_t euid);\n6112 long sys_setregid(gid_t rgid, gid_t egid);\n6113 long sys_getgroups(int gidsetsize, gid_t __user *grouplist);\n6114 long sys_setgroups(int gidsetsize, gid_t __user *grouplist);\n6115 long sys_setresuid(uid_t ruid, uid_t euid, uid_t suid);\n6116 long sys_getresuid(uid_t __user *ruid, uid_t __user *euid, uid_t __user *suid);\n6117 long sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid);\n6118 long sys_getresgid(gid_t __user *rgid, gid_t __user *egid, gid_t __user *sgid);\n6119 long sys_getpgid(pid_t pid);\n6120 long sys_setfsuid(uid_t uid);\n6121 long sys_setfsgid(gid_t gid);\n6122 long sys_getsid(pid_t pid);\n6123 long sys_capget(cap_user_header_t header, cap_user_data_t dataptr);\n6124 long sys_capset(cap_user_header_t header, const cap_user_data_t data);\n6125 long sys_rt_sigpending(sigset_t __user *set, size_t sigsetsize);\n6126 long sys_io_getevents_time32(__u32 ctx_id, __s32 min_nr, __s32 nr, struct io_event __user *events, struct old_timespec32 __user *timeout);\n6127 long sys_rt_sigqueueinfo(pid_t pid, int sig, siginfo_t __user *uinfo);\n6128 long sys_rt_sigsuspend(sigset_t __user *unewset, size_t sigsetsize);\n6129 long sys_sigaltstack(const struct sigaltstack __user *uss, struct sigaltstack __user *uoss);\n6130 long sys_utime32(const char __user *filename, struct old_utimbuf32 __user *t);\n6131 long sys_mknod(const char __user *filename, umode_t mode, unsigned dev);\n6132 long sys_personality(unsigned int personality);\n6133 long sys_ustat(unsigned dev, struct ustat __user *ubuf);\n6134 long sys_statfs(const char __user *path, struct statfs __user *buf);\n6135 long sys_fstatfs(unsigned int fd, struct statfs __user *buf);\n6136 long sys_sysfs(int option, unsigned long arg1, unsigned long arg2);\n6137 long sys_getpriority(int which, int who);\n6138 long sys_setpriority(int which, int who, int niceval);\n6139 long sys_sched_setparam(pid_t pid, struct sched_param __user *param);\n6140 long sys_sched_getparam(pid_t pid, struct sched_param __user *param);\n6141 long sys_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param);\n6142 long sys_sched_getscheduler(pid_t pid);\n6143 long sys_sched_get_priority_max(int policy);\n6144 long sys_sched_get_priority_min(int policy);\n6145 long sys_sched_rr_get_interval_time32(pid_t pid, struct old_timespec32 __user *interval);\n6146 long sys_mlock(unsigned long start, size_t len);\n6147 long sys_munlock(unsigned long start, size_t len);\n6148 long sys_mlockall(int flags);\n6149 long sys_munlockall(void);\n6150 long sys_vhangup(void);\n6151 long sys_pivot_root(const char __user *new_root, const char __user *put_old);\n6152 long sys_sysctl(struct __sysctl_args __user *args);\n```\n\n----------------------------------------\n\nTITLE: Including Example Blocks in QAPI Documentation - Markdown\nDESCRIPTION: Shows the use of the '|' character to indicate example sections within documentation comments in a QAPI schema. This is used by the documentation generator to embed concrete usage samples. Input requires Markdown-like formatting in comments; QAPI documentation tooling interprets and formats examples accordingly.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n# | Text of the example, may span\n# | multiple lines\n```\n\n----------------------------------------\n\nTITLE: Simplified RCU Memory Freeing in C\nDESCRIPTION: Example of using the g_free_rcu macro, which simplifies memory freeing for RCU-protected structures where the rcu_head is the first field. This is a convenience wrapper around call_rcu1.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/rcu.txt#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\ng_free_rcu(&foo, rcu);\n```\n\n----------------------------------------\n\nTITLE: Directory Entry Reading Functions in C\nDESCRIPTION: Function declaration for reading directory entries. The getdents function reads multiple directory entries into a buffer.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nint getdents(int fd, char *buf, size_t count);\n```\n\n----------------------------------------\n\nTITLE: ASID Change Callback Signature\nDESCRIPTION: Callback function signature for handling changes to the CPU ASID register (e.g. cr3 for x86).\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_50\n\nLANGUAGE: C\nCODE:\n```\nint (*asid_changed)(CPUState *env, target_ulong oldval, target_ulong newval);\n```\n\n----------------------------------------\n\nTITLE: Node-Specific Block Stream Command in QEMU\nDESCRIPTION: Example of streaming data using block_stream with a specific node name and backing file.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/live-block-ops.txt#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n(qemu) block_stream node-D file-B.img\n```\n\n----------------------------------------\n\nTITLE: Tainted Instructions Summary Output\nDESCRIPTION: Summary mode output showing tainted instructions organized by ASID (Address Space ID). Each line displays the ASID and program counter (PC) address of a tainted instruction.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/tainted_instructions.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nasid=0x503d000\tpc=b71c9470\nasid=0x503d000\tpc=b71c9475\nasid=0x503d000\tpc=b71c947b\n```\n\n----------------------------------------\n\nTITLE: Specifying Search Strings for PANDA Stringsearch Plugin - Plaintext\nDESCRIPTION: This snippet creates a file named search_strings.txt containing the quoted substring to be detected in memory accesses by PANDA's stringsearch plugin. This serves as the input dictionary for monitoring specific sequences during dynamic analysis. The expected input is the literal string representing part of the CD-key, without dashes and inside quotes. Output is a properly formatted text file used by the plugin. No additional dependencies are required beyond file writing permissions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/Starcraft.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n\"N68KTDHEKM\"\n```\n\n----------------------------------------\n\nTITLE: Declaring NT Native System Service Prototypes in C\nDESCRIPTION: This collection of C function prototypes defines the signature for numerous Native API system calls in the Windows NT operating system. The declarations specify the NTSTATUS return type and use a variety of pointer types and structures as parameters, many of which require corresponding Windows headers and type definitions (e.g., HANDLE, UNICODE_STRING, OBJECT_ATTRIBUTES). These function declarations do not provide implementation; they are meant for inclusion in user or kernel modules that interact with Native NT system services. Inputs and outputs vary by function, but typically revolve around handles, attributes, and buffers, with most functions returning an NTSTATUS code representing success or failure of the operation. Usage requires understanding of Windows NT architecture and conventions, and the prototypes are not directly usable without proper context and linking against the correct system libraries.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x86_prototypes.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Count);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateJobSet (ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, HANDLE TransactionHandle, PULONG Disposition);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateMailslotFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN InitialOwner);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateNamedPipeFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreatePagingFile (PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreatePrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateProcessEx (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateProfile (PHANDLE ProfileHandle, HANDLE Process, PVOID RangeBase, SIZE_T RangeSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateProfileEx (PHANDLE ProfileHandle, HANDLE Process, PVOID ProfileBase, SIZE_T ProfileSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, ULONG GroupAffinityCount, PGROUP_AFFINITY GroupAffinity);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID RmGuid, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, PUNICODE_STRING Description);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateThreadEx (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument, ULONG CreateFlags, ULONG_PTR ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, PPS_ATTRIBUTE_LIST AttributeList);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle, ULONG CreateOptions, ULONG IsolationLevel, ULONG IsolationFlags, PLARGE_INTEGER Timeout, PUNICODE_STRING Description);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, ULONG CreateOptions, ULONG CommitStrength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateUserProcess (PHANDLE ProcessHandle, PHANDLE ThreadHandle, ACCESS_MASK ProcessDesiredAccess, ACCESS_MASK ThreadDesiredAccess, POBJECT_ATTRIBUTES ProcessObjectAttributes, POBJECT_ATTRIBUTES ThreadObjectAttributes, ULONG ProcessFlags, ULONG ThreadFlags, PRTL_USER_PROCESS_PARAMETERS ProcessParameters, PPROCESS_CREATE_INFO CreateInfo, PPROCESS_ATTRIBUTE_LIST AttributeList);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateWorkerFactory (PHANDLE WorkerFactoryHandleReturn, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE CompletionPortHandle, HANDLE WorkerProcessHandle, PVOID StartRoutine, PVOID StartParameter, ULONG MaxThreadCount, SIZE_T StackReserve, SIZE_T StackCommit);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDebugActiveProcess (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDebugContinue (HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDelayExecution (BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeleteAtom (RTL_ATOM Atom);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeleteBootEntry (ULONG Id);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeleteDriverEntry (ULONG Id);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeleteKey (HANDLE KeyHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeletePrivateNamespace (HANDLE NamespaceHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDisableLastKnownGood ();\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDisplayString (PUNICODE_STRING String);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDrawText (PUNICODE_STRING Text);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDuplicateObject (HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDuplicateToken (HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtEnableLastKnownGood ();\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtEnumerateBootEntries (PVOID Buffer, PULONG BufferLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtEnumerateDriverEntries (PVOID Buffer, PULONG BufferLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtEnumerateKey (HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtEnumerateSystemEnvironmentValuesEx (ULONG InformationClass, PVOID Buffer, PULONG BufferLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtEnumerateTransactionObject (HANDLE RootObjectHandle, KTMOBJECT_TYPE QueryType, PKTMOBJECT_CURSOR ObjectCursor, ULONG ObjectCursorLength, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtEnumerateValueKey (HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFindAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFlushBuffersFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFlushInstallUILanguage (LANGID InstallUILanguage, ULONG SetComittedFlag);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFlushKey (HANDLE KeyHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nVOID NtFlushProcessWriteBuffers ();\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFlushWriteBuffer ();\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG FreeType);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFreezeRegistry (ULONG TimeOutInSeconds);\n```\n\n----------------------------------------\n\nTITLE: Cleaning Up PPM Files After Movie Creation\nDESCRIPTION: Command to remove the individual PPM frame files after the movie has been created, to free up disk space.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/replaymovie/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrm replay_movie_*.ppm\n```\n\n----------------------------------------\n\nTITLE: Enumerating Values with QAPI Enum Types - JSON\nDESCRIPTION: Shows how to define an enum type in QAPI schema using a 'data' array of unique lower-case strings. Optionally, a 'prefix' can customize constant naming. The values are transmitted as JSON strings and mapped to C enums in generated code; constraints prohibit 'max' and repeated names.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{ 'enum': 'MyEnum', 'data': [ 'value1', 'value2', 'value3' ] }\n```\n\n----------------------------------------\n\nTITLE: Iterating List with Safe Deletion Using QLIST_FOREACH_SAFE in C\nDESCRIPTION: This C code demonstrates traversing a QLIST while safely removing elements if they are marked for deletion. The use of QLIST_FOREACH_SAFE ensures iteration remains valid even as nodes are removed. No explicit locking is shown here, so this is safe only for single-threaded or externally synchronized cases, and is dependent on the GLib memory management functions and QEMU's QLIST macros.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/lockcnt.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nQLIST_FOREACH_SAFE(ioh, &io_handlers, next, pioh) {\n    if (ioh->revents & G_IO_OUT) {\n        ioh->fd_write(ioh->opaque);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding File-Backed RAM to QEMU Guest - QEMU Monitor\nDESCRIPTION: This example shows QEMU monitor commands to hotplug a 1GB memory device that is backed by a file (e.g., a hugepage file), essential for leveraging features like hugetlbfs. The first command (object_add) configures a RAM backend mapped to a specific filesystem path, while the second (device_add) attaches it as a pc-dimm device to an empty slot. Requires host support for hugepages and proper permissions for the backing file.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/memory-hotplug.txt#_snippet_2\n\nLANGUAGE: qemu-monitor\nCODE:\n```\n(qemu) object_add memory-backend-file,id=mem1,size=1G,mem-path=/mnt/hugepages-1GB\n(qemu) device_add pc-dimm,id=dimm1,memdev=mem1\n```\n\n----------------------------------------\n\nTITLE: Downloading the Kernel Info Module via SVN\nDESCRIPTION: Alternative method to download the kernel information module using SVN, though this approach may no longer work as of 2020.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi_linux/utils/kernelinfo/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsvn export https://github.com/panda-re/panda/trunk/panda/plugins/osi_linux/utils/kernelinfo\n```\n\n----------------------------------------\n\nTITLE: Interpreting bufmon Buffer Write Output - Shell\nDESCRIPTION: This snippet shows typical bufmon output lines indicating WRITE operations to the monitored buffer region, detailing source addresses, address spaces, write size, and hex contents. Outputs are used for manual extraction and analysisâ€”no external dependencies except the bufmon tool and readable output logs. Each entry logs a memory write: region address, value written, and origin, aiding forensic reverse engineering.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/LINE_Censorship.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\nWRITE 40759e88 40038998 28210000 41793e38 00000004 00 00 00 00\nWRITE 40759e88 40038998 28210000 41793e3c 00000004 00 00 00 00\nWRITE 40759e88 400389ac 28210000 41793e40 00000004 00 00 00 00\nWRITE 40759e88 400389ac 28210000 41793e44 00000004 00 00 00 00\nWRITE 40796784 40038688 28210000 41792080 00000004 31 39 38 39\nWRITE 40796784 40038688 28210000 41792084 00000004 36 34 0a 46\nWRITE 40796784 40038688 28210000 41792088 00000004 4c 47 0a 47\nWRITE 40796784 40038688 28210000 4179208c 00000004 43 44 0a 47\n```\n\n----------------------------------------\n\nTITLE: Registering a Hypercall Handler â€” C\nDESCRIPTION: Provides the API for registering a hypercall with a unique magic number and a handler function of type hypercall_t. Dependencies include the 'hypercaller' plugin and the typedef above. Magic is a uint32_t identifier for the hypercall; 'hypercall_t' is the pointer to the handler. This registers the handler so that guest hypercalls with the given magic invoke it. The registration must be repeated for each magic/handler pair.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/hypercaller/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nvoid register_hypercall(uint32_t magic, hypercall_t);\n```\n\n----------------------------------------\n\nTITLE: Invoking PANDA with pc_search for a Range of PCs - Shell\nDESCRIPTION: This snippet shows how to search for a range of PC values with the pc_search plugin in PANDA. The pc_range argument is formatted as two hex values separated by a hyphen, and out_file customizes the output filename. This invocation will output all guest instructions matching any PC in the specified range, making it suitable for broader or uncertain search targets.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/pc_search/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo \\\n    -panda pc_search:pc_range=0x79a33c06-0x79a33d32,out_file=\"my_pc_matches.txt\"\n```\n\n----------------------------------------\n\nTITLE: SCTP Network Protocol Operations in C\nDESCRIPTION: Function declarations for Stream Control Transmission Protocol (SCTP) operations. Includes functions for peeling off an association from a socket and generic send operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_20\n\nLANGUAGE: c\nCODE:\n```\nint sctp_peeloff(int sd, uint32_t name);\nint sctp_generic_sendmsg(int sd, void *msg, int mlen, struct sockaddr *to, __socklen_t tolen, struct sctp_sndrcvinfo *sinfo, int flags);\nint sctp_generic_sendmsg_iov(int sd, struct iovec *iov, int iovlen, struct sockaddr *to, __socklen_t tolen, struct sctp_sndrcvinfo *sinfo, int flags);\n```\n\n----------------------------------------\n\nTITLE: Monitoring and Notification System Call Prototypes in C\nDESCRIPTION: Function prototypes for Linux system calls related to file and system monitoring, notifications, and event handling. These functions provide mechanisms for receiving notifications about system events.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_16\n\nLANGUAGE: c\nCODE:\n```\nlong sys_inotify_init1(int flags);\nlong sys_fanotify_init(unsigned int flags, unsigned int event_f_flags);\nlong sys_fanotify_mark(int fanotify_fd, unsigned int flags, u64 mask, int fd, const char __user *pathname);\nlong sys_perf_event_open(struct perf_event_attr __user *attr_uptr, pid_t pid, int cpu, int group_fd, unsigned long flags);\nlong sys_ni_syscall(void);\n```\n\n----------------------------------------\n\nTITLE: Configuring Replication Disk Stack on Secondary - QEMU Command Line - shell\nDESCRIPTION: This QEMU command-line snippet configures the replicated disk stack on the Secondary VM by defining raw and replication drives, plus associated qcow2 files for active and hidden disks. Dependencies are QEMU, valid disk image files, and sufficient storage. Key parameters include driver types, file names, operating modes, top-level IDs, and proper backing chain structure. Disk length and export names must be consistent with the primary setup.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/block-replication.txt#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n-drive if=none,driver=raw,file.filename=1.raw,id=colo1 \\\n-drive if=xxx,id=topxxx,driver=replication,mode=secondary,top-id=topxxx\\\n       file.file.filename=active_disk.qcow2,\\\n       file.driver=qcow2,\\\n       file.backing.file.filename=hidden_disk.qcow2,\\\n       file.backing.driver=qcow2,\\\n       file.backing.backing=colo1\n```\n\n----------------------------------------\n\nTITLE: QEMU Configure Script - Helper Shell Functions for Feature and Toolchain Probing\nDESCRIPTION: This section enumerates and describes helper shell functions used by the configure script to abstract common tasks such as checking for compiler/tool presence, testing compile/link operations, and reporting feature status or errors. Each function aids maintainers in writing portable, self-checking build scripts. Input parameters vary by function (e.g., $ARGS, $NAME), with outputs generally being status codes, direct stdout/stderr messages, or file modifications. The functions rely on a POSIX shell and, for compile checks, an accessible system toolchain. Limitations include coupling to naming conventions (like $TMPC for source files) and assumptions about compiler locations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/build-system.txt#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n# do_cc $ARGS...\\n\\n# Attempt to run the system C compiler passing it $ARGS...\\n\\n# do_cxx $ARGS...\\n\\n# Attempt to run the system C++ compiler passing it $ARGS...\\n\\n# compile_object $CFLAGS\\n\\n# Attempt to compile a test program with the system C compiler using\\n# $CFLAGS. The test program must have been previously written to a file\\n# called $TMPC.\\n\\n# compile_prog $CFLAGS $LDFLAGS\\n\\n# Attempt to compile a test program with the system C compiler using\\n# $CFLAGS and link it with the system linker using $LDFLAGS. The test\\n# program must have been previously written to a file called $TMPC.\\n\\n# has $COMMAND\\n\\n# Determine if $COMMAND exists in the current environment, either as a\\n# shell builtin, or executable binary, returning 0 on success.\\n\\n# path_of $COMMAND\\n\\n# Return the fully qualified path of $COMMAND, printing it to stdout,\\n# and returning 0 on success.\\n\\n# check_define $NAME\\n\\n# Determine if the macro $NAME is defined by the system C compiler\\n\\n# check_include $NAME\\n\\n# Determine if the include $NAME file is available to the system C\\n# compiler\\n\\n# write_c_skeleton\\n\\n# Write a minimal C program main() function to the temporary file\\n# indicated by $TMPC\\n\\n# feature_not_found $NAME $REMEDY\\n\\n# Print a message to stderr that the feature $NAME was not available\\n# on the system, suggesting the user try $REMEDY to address the\\n# problem.\\n\\n# error_exit $MESSAGE $MORE...\\n\\n# Print $MESSAGE to stderr, followed by $MORE... and then exit from the\\n# configure script with non-zero status\\n\\n# query_pkg_config $ARGS...\\n\\n# Run pkg-config passing it $ARGS. If QEMU is doing a static build,\\n# then --static will be automatically added to $ARGS\n```\n\n----------------------------------------\n\nTITLE: Iterating and Selectively Cleaning List Elements with qemu_lockcnt_dec_if_lock in C\nDESCRIPTION: This pattern uses qemu_lockcnt_inc and qemu_lockcnt_dec_if_lock to handle list iteration and selective synchronous cleanup in a possibly concurrent setting. When a node is marked deleted, it attempts to atomically acquire the lock and decrement in one step before removing and freeing it, then increments and unlocks to maintain correctness. It utilizes QEMU's QemuLockCnt and RCU APIs and expects the list macros and GLib memory functions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/lockcnt.txt#_snippet_9\n\nLANGUAGE: C\nCODE:\n```\nqemu_lockcnt_inc(&io_handlers_lockcnt);\nQLIST_FOREACH_SAFE_RCU(ioh, &io_handlers, next, pioh) {\n    if (ioh->deleted) {\n        if (qemu_lockcnt_dec_if_lock(&io_handlers_lockcnt)) {\n            QLIST_REMOVE(ioh, next);\n            g_free(ioh);\n            qemu_lockcnt_inc_and_unlock(&io_handlers_lockcnt);\n        }\n    } else {\n        if (ioh->revents & G_IO_OUT) {\n            ioh->fd_write(ioh->opaque);\n        }\n    }\n}\nqemu_lockcnt_dec(&io_handlers_lockcnt);\n```\n\n----------------------------------------\n\nTITLE: Whole System Log Format Example\nDESCRIPTION: Example output showing system-wide tracing format. Each line starts with ASID and kernel mode indicator, followed by register changes and memory operations. Includes both memory reads (mr) and writes (mw).\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/trace/README.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nasid=0x34c0ad20,kernel=1,eip=0xc17efb88,eax=0xc10343f0,ecx=0x00000001,edx=0xc1b16000,esp=0xc1b17f6c,ebp=0xc1b17f78,mw=0xc1b17f68:44000,esp=0xc1b17f68\nasid=0x34c0ad20,kernel=1,eip=0xc17f0140,mr=0xc1b17f68:44000,mw=0xc1b17f68:c4ffffff,mw=0xc1b17f64:e0000,esp=0xc1b17f64,mw=0xc1b17f60:d8000,esp=0xc1b17f60,mw=0xc1b17f5c:7b000,esp=0xc1b17f5c,mw=0xc1b17f58:7b000,esp=0xc1b17f58,mw=0xc1b17f54:f0433c1,esp=0xc1b17f54,mw=0xc1b17f50:787fb1c1,esp=0xc1b17f50,mw=0xc1b17f4c:0000,esp=0xc1b17f4c,mw=0xc1b17f48:0000,esp=0xc1b17f48,mw=0xc1b17f44:060b1c1,esp=0xc1b17f44,mw=0xc1b17f40:1000,esp=0xc1b17f40,mw=0xc1b17f3c:0000,esp=0xc1b17f3c,edx=0x0000007b\nasid=0x34c0ad20,kernel=1,eip=0xc17f015c\nasid=0x34c0ad20,kernel=1,eip=0xc17f015e,edx=0x000000d8,edx=0x000000e0,eax=0xc1b17f3c,mw=0xc1b17f38:7317fc1\nasid=0x34c0ad20,kernel=1,eip=0xc17f0cd0,esp=0xc1b17f38,mw=0xc1b17f34:787fb1c1,esp=0xc1b17f34,ebp=0xc1b17f34,mw=0xc1b17f30:0000,esp=0xc1b17f30,mw=0xc1b17f2c:0000,esp=0xc1b17f2c,mw=0xc1b17f28:0000,esp=0xc1b17f28,esp=0xc1b17f14,mr=0xf63aec80:0000,mr=0xc1b17f68:c4ffffff,ebx=0xffffffc4,mw=0xc1b17f24:3c7fb1c1,mw=0xf63aec80:3c7fb1c1,mw=0xc1b17f10:f6c7fc1\n```\n\n----------------------------------------\n\nTITLE: Replaying Execution and Generating Movie Output - PANDA/QEMU and Plugin - Bash\nDESCRIPTION: This command runs the PANDA instrumented version of QEMU to execute the unpacked replay ('cve-2011-1255-crash') in a virtual x86_64 system with 1 GB of RAM. The 'replaymovie' plugin collects screenshot data for every executed instruction block. Output is a directory of raw image files. Prerequisites include a built PANDA/qemu binary and the existence of the unpacked replay file.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/UAF.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npanda/qemu/x86_64-softmmu/panda-system-x86_64 -m 1024 -replay cve-2011-1255-crash \\\n    -display none -panda 'replaymovie'\n```\n\n----------------------------------------\n\nTITLE: Defining ALPC and Port Management System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to ALPC (Advanced Local Procedure Call) and port communications. These functions handle communication channels between processes in the Windows NT environment.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAlpcRevokeSecurityContext (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);\nNTSTATUS NtAlpcSendWaitReceivePort (HANDLE PortHandle, ULONG Flags, PPORT_MESSAGE SendMessage, PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes, PPORT_MESSAGE ReceiveMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes, PLARGE_INTEGER Timeout);\nNTSTATUS NtAlpcSetInformation (HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length);\n```\n\n----------------------------------------\n\nTITLE: Executing NBD Server Stop via QMP - JSON\nDESCRIPTION: This snippet shows how to use QMP to stop the Network Block Device (NBD) server on the QEMU host by sending the 'nbd-server-stop' execute command. This is typically required after primary host failure during secondary operations. Prerequisites include NBD server running on QEMU with a QMP endpoint. Input is a JSON object with an execute field; output is the result of the NBD server termination.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/block-replication.txt#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{ \"execute\": \"nbd-server-stop\" }\n```\n\n----------------------------------------\n\nTITLE: Executing and Comparing Regression Tests with Python Driver\nDESCRIPTION: This command runs all Pandas tests and compares test outputs in '/tmpout' with previously blessed outputs to check for inconsistencies. It uses 'ptest.py test' as the main interface for running full regression testing. Environment and reference outputs must be set up in advance. Test failures result from mismatches in outputs.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/testing/README.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nptest.py test\n```\n\n----------------------------------------\n\nTITLE: Reference Counting with Mutex Lock for Safe Traversal in C\nDESCRIPTION: This C code sequence uses a mutex to serialize access when incrementing or decrementing the walking_handlers reference counter, providing thread safety for traversing and cleaning up the QLIST. It protects the counter with a lock to avoid race conditions, allowing deterministic and safe cleanup of deleted nodes. The code assumes the presence of QEMU mutex and list macros and GLib memory management.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/lockcnt.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n// (1)\nqemu_mutex_lock(&walking_handlers_mutex);\nwalking_handlers++;\nqemu_mutex_unlock(&walking_handlers_mutex);\n\n...\n\n// (2)\nqemu_mutex_lock(&walking_handlers_mutex);\nif (--walking_handlers == 0) {\n    QLIST_FOREACH_SAFE(ioh, &io_handlers, next, pioh) {\n        if (ioh->deleted) {\n            QLIST_REMOVE(ioh, next);\n            g_free(ioh);\n        }\n    }\n}\nqemu_mutex_unlock(&walking_handlers_mutex);\n```\n\n----------------------------------------\n\nTITLE: Windows NT System Call Function Declarations\nDESCRIPTION: Function prototypes for Windows NT native API calls that provide direct access to kernel functionality. These functions handle operations like process/thread management, file I/O, registry access, and system configuration.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp0_x86_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWorkerFactoryWorkerReady (HANDLE WorkerFactoryHandle);\nNTSTATUS NtYieldExecution ();\nNTSTATUS NtWriteVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\nNTSTATUS NtWriteRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\nNTSTATUS NtWriteFileGather (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtWriteFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n// ... additional function declarations omitted for brevity\n```\n\n----------------------------------------\n\nTITLE: Running PANDA Android Emulator Replay with String Search Plugins (Shell)\nDESCRIPTION: This command launches a PANDA replay of the LINE emulator action using the callstack_instr and stringsearch plugins. It passes in the previously created QCOW2 image paths and uses the trace file 'line2', searching for the specified strings. This has dependencies on PANDA being built with Android support and the necessary images available. Inputs are trace and search configuration; outputs include memory match logs. Key parameters configure emulator memory, CPU, replay file, and plugin arguments.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/LINE_Censorship.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n../arm-softmmu/panda-system-arm -m 2048 -replay line2 -M android_arm -android -cpu cortex-a9 -kernel /dev/null \\\n  -global goldfish_mmc.sd_path=/dev/null -global goldfish_nand.system_path=dummy2.qcow2 \\\n  -global goldfish_nand.user_data_path=dummy.qcow2 \\\n  -panda 'callstack_instr;stringsearch:name=line'\n```\n\n----------------------------------------\n\nTITLE: Cold-Plugging RAM and Advanced Memory Backend Configuration in QEMU - Shell\nDESCRIPTION: This shell example combines base and file-backed memory allocations with explicit memory slot management at QEMU process startup. The command composes regular RAM, 1GB hugepages, and 2MB page-backed memory, and initializes additional DIMM slots for future hotplug, demonstrating advanced memory configuration capability. Dependencies include host support for hugepages and the correct mount paths. Key parameters adjust RAM sizes, slot count, and attach memory-backend objects/devices at boot.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/memory-hotplug.txt#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nqemu [...] -m 6GB,slots=4,maxmem=10G \\\n  -object memory-backend-file,id=mem1,size=1G,mem-path=/mnt/hugepages-1G \\\n  -device pc-dimm,id=dimm1,memdev=mem1 \\\n  -object memory-backend-file,id=mem2,size=256M,mem-path=/mnt/hugepages-2MB \\\n  -device pc-dimm,id=dimm2,memdev=mem2\n```\n\n----------------------------------------\n\nTITLE: Example Output Snippet from textprinter Log File - Log Format\nDESCRIPTION: Provides an excerpt from the read_tap_buffers.txt.gz or write_tap_buffers.txt.gz files produced by textprinter, illustrating how each entry encodes callstack, program counter, stack type, address space, virtual address, access count, and byte value. This output is essential for verifying correct monitoring operation and preparing data for post-processing. The format and the meaning of each field are described in the documentation and depend on the tap_points.txt stack type.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/textprinter/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n77fa15db [...] 7800f6a8 7800fc9a 2 0000019c 00000210 003f3830 6520348 62\n77fa15db [...] 7800f6a8 7800fc9a 2 0000019c 00000210 003f3831 6520348 72\n77fa15db [...] 7800f6a8 7800fc9a 2 0000019c 00000210 003f3832 6520348 61\n77fa15db [...] 7800f6a8 7800fc9a 2 0000019c 00000210 003f3833 6520348 6e\n```\n\n----------------------------------------\n\nTITLE: Disassembling ACPI SSDT Table for VM Generation ID in ASL\nDESCRIPTION: This ASL code defines the ACPI Secondary System Description Table (SSDT) for the VM Generation ID device. It includes the device definition, hardware ID, compatible ID, status method, and address method.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/vmgenid.txt#_snippet_0\n\nLANGUAGE: ASL\nCODE:\n```\nDefinitionBlock (\"/sys/firmware/acpi/tables/SSDT.aml\", \"SSDT\", 1, \"BOCHS \",\n\"VMGENID\", 0x00000001)\n{\n    Name (VGIA, 0x07FFF000)\n    Scope (\\_SB)\n    {\n        Device (VGEN)\n        {\n            Name (_HID, \"QEMUVGID\")  // _HID: Hardware ID\n            Name (_CID, \"VM_Gen_Counter\")  // _CID: Compatible ID\n            Name (_DDN, \"VM_Gen_Counter\")  // _DDN: DOS Device Name\n            Method (_STA, 0, NotSerialized)  // _STA: Status\n            {\n                Local0 = 0x0F\n                If ((VGIA == Zero))\n                {\n                    Local0 = Zero\n                }\n\n                Return (Local0)\n            }\n\n            Method (ADDR, 0, NotSerialized)\n            {\n                Local0 = Package (0x02) {}\n                Index (Local0, Zero) = (VGIA + 0x28)\n                Index (Local0, One) = Zero\n                Return (Local0)\n            }\n        }\n    }\n\n    Method (\\_GPE._E05, 0, NotSerialized)  // _Exx: Edge-Triggered GPE\n    {\n        Notify (\\_SB.VGEN, 0x80) // Status Change\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Format String File and Using PANDA callfunc with Memory-Mapped Arguments - Shell\nDESCRIPTION: This sequence first writes a null-terminated format string to a host file, then executes PANDA/QEMU with the 'callfunc' plugin, mapping the file into guest memory and invoking 'printk' with the mapped string and several integer arguments. Dependencies include the 'echo' utility and appropriate permissions for file writing, as well as PANDA/QEMU configured for ARM emulation, and the target guest kernel/disk images. Parameters 'mm_file' and 'mm_dst' determine which file is mapped and where in guest memory it is placed, while 'args' passes the string address and several integers to 'printk'. The output is the invocation within the guest kernel of a formatted print statement, and care must be taken that memory addresses match those in your own setup.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/callfunc/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\necho -ne \"Hello from kernel's printk! %d %d %d %d %d %d %d\\n\\0\" > fmt_str.txt\n```\n\nLANGUAGE: shell\nCODE:\n```\narm-softmmu/panda-system-arm -M versatilepb -kernel ~/.panda/vmlinuz-3.2.0-4-versatile \\\n    -initrd ~/.panda/initrd.img-3.2.0-4-versatile -hda ~/.panda/arm_wheezy.qcow \\\n    -serial stdio -loadvm root -display none \\\n    -panda callfunc:when=0xc00ca05c,func=0xc026feb4,mm_file=\"fmt_str.txt\",mm_dst=0xc0000000,args=\"0xc0000000-0x1-0x2-0x3-0x4-0x5-0x6-0x7\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Native NT API Functions for System Querying and Setting - C/C++\nDESCRIPTION: Declares a comprehensive set of NTSTATUS-returning NT API functions for direct interaction with operating system internals, including I/O completion, license querying, registry key operations, security management, process and thread control, and more. These declarations require NT-specific data types (e.g., HANDLE, PVOID, PUNICODE_STRING) and depend on corresponding system headers. Parameters typically include object handles, information classes, input/output buffers, and status/result variables, enabling fine-grained control and detailed status feedback; intended for inclusion in kernel-mode drivers or privileged system tools. Usage requires link-time and run-time access to the NT kernel library; not supported in standard user-mode applications.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp12_x64_prototypes.txt#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryIoCompletion (HANDLE IoCompletionHandle, IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass, PVOID IoCompletionInformation, ULONG IoCompletionInformationLength, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryLicenseValue (PUNICODE_STRING Name, PULONG Type, PVOID Buffer, ULONG Length, PULONG ReturnedLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryMultipleValueKey (HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryMutant (HANDLE MutantHandle, MUTANT_INFORMATION_CLASS MutantInformationClass, PVOID MutantInformation, ULONG MutantInformationLength, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryOpenSubKeys (POBJECT_ATTRIBUTES TargetKey, PULONG HandleCount);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryOpenSubKeysEx (POBJECT_ATTRIBUTES TargetKey, ULONG BufferLength, PVOID Buffer, PULONG RequiredSize);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryPortInformationProcess ();\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID SidList, ULONG SidListLength, PULONG StartSid, BOOLEAN RestartScan);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQuerySecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Length, PULONG LengthNeeded);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQuerySemaphore (HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG SemaphoreInformationLength, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQuerySymbolicLinkObject (HANDLE LinkHandle, PUNICODE_STRING LinkTarget, PULONG ReturnedLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQuerySystemEnvironmentValue (PUNICODE_STRING VariableName, PWSTR VariableValue, USHORT ValueLength, PUSHORT ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQuerySystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, PULONG ValueLength, PULONG Attributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryTimerResolution (PULONG MaximumTime, PULONG MinimumTime, PULONG CurrentTime);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRaiseException (PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ContextRecord, BOOLEAN FirstChance);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRaiseHardError (NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask, PULONG_PTR Parameters, ULONG ValidResponseOptions, PULONG Response);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtReadOnlyEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRecoverEnlistment (HANDLE EnlistmentHandle, PVOID EnlistmentKey);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRecoverResourceManager (HANDLE ResourceManagerHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRecoverTransactionManager (HANDLE TransactionManagerHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRegisterProtocolAddressInformation (HANDLE ResourceManager, PCRM_PROTOCOL_ID ProtocolId, ULONG ProtocolInformationSize, PVOID ProtocolInformation, ULONG CreateOptions);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRegisterThreadTerminatePort (HANDLE PortHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtReleaseKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtReleaseWorkerFactoryWorker (HANDLE WorkerFactoryHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRemoveIoCompletionEx (HANDLE IoCompletionHandle, PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation, ULONG Count, PULONG NumEntriesRemoved, PLARGE_INTEGER Timeout, BOOLEAN Alertable);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRemoveProcessDebug (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRenameKey (HANDLE KeyHandle, PUNICODE_STRING NewName);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRenameTransactionManager (PUNICODE_STRING LogFileName, LPGUID ExistingTransactionManagerGuid);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtReplaceKey (POBJECT_ATTRIBUTES NewFile, HANDLE TargetHandle, POBJECT_ATTRIBUTES OldFile);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtReplacePartitionUnit (PUNICODE_STRING TargetInstancePath, PUNICODE_STRING SpareInstancePath, ULONG Flags);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtReplyWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRequestPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtResetEvent (HANDLE EventHandle, PLONG PreviousState);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtResetWriteWatch (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T RegionSize);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRestoreKey (HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtResumeProcess (HANDLE ProcessHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRollbackComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRollbackEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRollbackTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRollforwardTransactionManager (HANDLE TransactionManagerHandle, PLARGE_INTEGER TmVirtualClock);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSaveKey (HANDLE KeyHandle, HANDLE FileHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSaveKeyEx (HANDLE KeyHandle, HANDLE FileHandle, ULONG Format);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSaveMergedKeys (HANDLE HighPrecedenceKeyHandle, HANDLE LowPrecedenceKeyHandle, HANDLE FileHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSecureConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PSID RequiredServerSid, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetBootEntryOrder (PULONG Ids, ULONG Count);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetBootOptions (PBOOT_OPTIONS BootOptions, ULONG FieldsToChange);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetDebugFilterState (ULONG ComponentId, ULONG Level, BOOLEAN State);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetDefaultHardErrorPort (HANDLE DefaultHardErrorPort);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetDefaultLocale (BOOLEAN UserProfile, LCID DefaultLocaleId);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetDefaultUILanguage (LANGID DefaultUILanguageId);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetDriverEntryOrder (PULONG Ids, ULONG Count);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetHighEventPair (HANDLE EventPairHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetHighWaitLowEventPair (HANDLE EventPairHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetInformationDebugObject (HANDLE DebugObjectHandle, DEBUGOBJECTINFOCLASS DebugObjectInformationClass, PVOID DebugInformation, ULONG DebugInformationLength, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetInformationKey (HANDLE KeyHandle, KEY_SET_INFORMATION_CLASS KeySetInformationClass, PVOID KeySetInformation, ULONG KeySetInformationLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetInformationTransactionManager (HANDLE TmHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetIntervalProfile (ULONG Interval, KPROFILE_SOURCE Source);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetIoCompletion (HANDLE IoCompletionHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetLdtEntries (ULONG Selector0, ULONG Entry0Low, ULONG Entry0Hi, ULONG Selector1, ULONG Entry1Low, ULONG Entry1Hi);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetLowEventPair (HANDLE EventPairHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetLowWaitHighEventPair (HANDLE EventPairHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetSecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetSystemEnvironmentValue (PUNICODE_STRING VariableName, PUNICODE_STRING VariableValue);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetSystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, ULONG ValueLength, ULONG Attributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetSystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetSystemPowerState (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetSystemTime (PLARGE_INTEGER SystemTime, PLARGE_INTEGER PreviousTime);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetThreadExecutionState (EXECUTION_STATE esFlags, PEXECUTION_STATE PreviousFlags);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetTimerResolution (ULONG DesiredTime, BOOLEAN SetResolution, PULONG ActualTime);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetUuidSeed (PCHAR Seed);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtShutdownSystem (SHUTDOWN_ACTION Action);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtShutdownWorkerFactory (HANDLE WorkerFactoryHandle, LONG *PendingWorkerCount);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSignalAndWaitForSingleObject (HANDLE SignalHandle, HANDLE WaitHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSinglePhaseReject (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtStartProfile (HANDLE ProfileHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtStopProfile (HANDLE ProfileHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSuspendProcess (HANDLE ProcessHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSuspendThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\n```\n\n----------------------------------------\n\nTITLE: Assembly Dump Example for Function Entrypoint and Program Counter - Assembly (Pseudo-code)\nDESCRIPTION: This snippet gives example assembly output for a code region in a PANDA replay, mapping specific instructions to both a program counter (pc) and function entrypoint. Key addresses such as the instruction responsible for the function call and the entrypoint address are correlated with JSON fields from func_stats output. This assembly context allows users to manually verify and analyze reported function calls and their stack traces. No dependencies, but requires ability to generate disassemblies using PANDA's QEMU output.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/func_stats/README.md#_snippet_2\n\nLANGUAGE: assembly\nCODE:\n```\n0x00000000b7eb3358:  push   ebp\n\t0x00000000b7eb3359:  mov    ebp,esp\n\t0x00000000b7eb335b:  push   ebx\n\t0x00000000b7eb335c:  sub    esp,0x4\n\t0x00000000b7eb335f:  call   0xb7eb3364 --> {pc}: call {entrypoint}\n\n```\n\n----------------------------------------\n\nTITLE: Declaring and Defining QAPI Schema Introspection Structures - C\nDESCRIPTION: This snippet, generated by qapi-introspect.py, shows the declaration and definition of a C string containing the JSON representation of the QAPI schema. The header declares the JSON string as an extern, and the source defines its value as a concatenated JSON array. Requires proper inclusion and linkage in related QAPI code; the JSON fragments capture schema meta-information as structured data for later runtime use.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_24\n\nLANGUAGE: C\nCODE:\n```\n#ifndef EXAMPLE_QMP_INTROSPECT_H\\n#define EXAMPLE_QMP_INTROSPECT_H\\n\\nextern const char example_qmp_schema_json[];\\n\\n#endif\n```\n\nLANGUAGE: C\nCODE:\n```\nconst char example_qmp_schema_json[] = \\\"[\\\"\\n    \\\"{\\\\\\\"arg-type\\\\\\\": \\\\\\\"0\\\\\\\", \\\\\\\"meta-type\\\\\\\": \\\\\\\"event\\\\\\\", \\\\\\\"name\\\\\\\": \\\\\\\"MY_EVENT\\\\\\\"}\\\", \\\"\\n    \\\"{\\\\\\\"arg-type\\\\\\\": \\\\\\\"1\\\\\\\", \\\\\\\"meta-type\\\\\\\": \\\\\\\"command\\\\\\\", \\\\\\\"name\\\\\\\": \\\\\\\"my-command\\\\\\\", \\\\\\\"ret-type\\\\\\\": \\\\\\\"2\\\\\\\"}\\\", \\\"\\n    \\\"{\\\\\\\"members\\\\\\\": [], \\\\\\\"meta-type\\\\\\\": \\\\\\\"object\\\\\\\", \\\\\\\"name\\\\\\\": \\\\\\\"0\\\\\\\"}\\\", \\\"\\n    \\\"{\\\\\\\"members\\\\\\\": [{\\\\\\\"name\\\\\\\": \\\\\\\"arg1\\\\\\\", \\\\\\\"type\\\\\\\": \\\\\\\"[2]\\\\\\\"}], \\\\\\\"meta-type\\\\\\\": \\\\\\\"object\\\\\\\", \\\\\\\"name\\\\\\\": \\\\\\\"1\\\\\\\"}\\\", \\\"\\n    \\\"{\\\\\\\"members\\\\\\\": [{\\\\\\\"name\\\\\\\": \\\\\\\"integer\\\\\\\", \\\\\\\"type\\\\\\\": \\\\\\\"int\\\\\\\"}, {\\\\\\\"default\\\\\\\": null, \\\\\\\"name\\\\\\\": \\\\\\\"string\\\\\\\", \\\\\\\"type\\\\\\\": \\\\\\\"str\\\\\\\"}], \\\\\\\"meta-type\\\\\\\": \\\\\\\"object\\\\\\\", \\\\\\\"name\\\\\\\": \\\\\\\"2\\\\\\\"}\\\", \\\"\\n    \\\"{\\\\\\\"element-type\\\\\\\": \\\\\\\"2\\\\\\\", \\\\\\\"meta-type\\\\\\\": \\\\\\\"array\\\\\\\", \\\\\\\"name\\\\\\\": \\\\\\\"[2]\\\\\\\"}\\\", \\\"\\n    \\\"{\\\\\\\"json-type\\\\\\\": \\\\\\\"int\\\\\\\", \\\\\\\"meta-type\\\\\\\": \\\\\\\"builtin\\\\\\\", \\\\\\\"name\\\\\\\": \\\\\\\"int\\\\\\\"}\\\", \\\"\\n    \\\"{\\\\\\\"json-type\\\\\\\": \\\\\\\"string\\\\\\\", \\\\\\\"meta-type\\\\\\\": \\\\\\\"builtin\\\\\\\", \\\\\\\"name\\\\\\\": \\\\\\\"str\\\\\\\"}\\\"]\\\";\n```\n\n----------------------------------------\n\nTITLE: SchemaInfo for Struct Type - JSON\nDESCRIPTION: This example describes SchemaInfo for a QAPI 'object' (struct) type, 'MyType', which contains three fields including one optional member ('member3'). It shows how struct members and their types are listed, with 'default' indicating optionality, informing clients how to interpret presence and default values of struct fields in wire responses.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n{ \\\"name\\\": \\\"MyType\\\", \\\"meta-type\\\": \\\"object\\\",\\n  \\\"members\\\": [\\n      { \\\"name\\\": \\\"member1\\\", \\\"type\\\": \\\"str\\\" },\\n      { \\\"name\\\": \\\"member2\\\", \\\"type\\\": \\\"int\\\" },\\n      { \\\"name\\\": \\\"member3\\\", \\\"type\\\": \\\"str\\\", \\\"default\\\": null } ] }\n```\n\n----------------------------------------\n\nTITLE: Launching PANDA with Android/ARM Guest - QEMU-Style Command Line - Shell\nDESCRIPTION: This shell command demonstrates launching PANDA with an Android/ARM guest using QEMU-style arguments. It specifies the machine type, CPU, kernel/initramfs, NAND global parameters for system and user partition QCOW2 images, memory, serial devices, networking, and additional runtime arguments. The command should be run from a shell in an environment where PANDA and the necessary images are present. It assumes GNU/Linux and a compatible 64-bit host. Certain images may require additional flags (e.g., for ext4 support).\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/Android.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n-M android_arm -cpu cortex-a9  -kernel /androidstuff/kernel-qemu -initrd /androidstuff/ramdisk.img  -global goldfish_nand.system_path=/androidstuff/system.img.qcow2 -global goldfish_nand.user_data_path=/androidstuff/userdata-qemu.img.qcow2  -global goldfish_nand.cache_path=/androidstuff/cache.img.qcow2 -append  \"console=ttyS0 ndns=2 qemu=1 no_console_suspend=1 qemu.gles=0 android.qemud=ttyS1\" -m 2G -no-reboot -monitor telnet:localhost:4321,server,nowait -show-cursor -serial stdio -serial telnet:localhost:4421,server,nowait -display sdl -net nic,vlan=1 -net user,vlan=1,hostfwd=tcp::5555-:5555,hostfwd=tcp::5039-:5039 -global goldfish_mmc.sd_path=/androidstuff/sdcard.qcow2  -android\n```\n\n----------------------------------------\n\nTITLE: Pretty Printing QEMU Trace Logs Using Simpletrace Script in Shell\nDESCRIPTION: This shell command runs the 'simpletrace.py' script to format QEMU's binary trace files into a human-readable format. The event description file and the trace output file are given as arguments. Requires Python, QEMU scripts, and matching event and trace files. Input: trace events file and binary trace file. Output: formatted trace log.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/tracing.txt#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n./scripts/simpletrace.py trace-events-all trace-12345\n```\n\n----------------------------------------\n\nTITLE: Setup Phase with Python Script in Panda Testing\nDESCRIPTION: This snippet runs only the setup scripts for all enabled tests within the Panda regression testing framework. It uses the ptest.py driver script and the 'setup' argument to trigger this phase. Setup typically involves preparing test cases and any required environments. PANDA_REGRESSION_DIR must be configured beforehand. Input is 'setup' as a command; output consists of completed setup routines for each enabled test.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/testing/README.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nptest.py setup        # only runs setup scripts\n```\n\n----------------------------------------\n\nTITLE: Windows NT System Functions Declarations - Memory and Process Management\nDESCRIPTION: Function declarations for core Windows NT system calls related to memory access, process control, and thread management. These functions are part of the native API and typically require kernel mode access.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp0_x86_prototypes.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtReadVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtQueryVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtResumeProcess (HANDLE ProcessHandle);\n```\n\n----------------------------------------\n\nTITLE: Program Point Annotation with Instruction Count - Assembly (Pseudo-code)\nDESCRIPTION: This snippet corresponds to an annotated disassembly entry that marks a program point (the entrypoint address of a function) together with the guest instruction count at that address, as logged in PANDA replays. These program annotations are derived from the QEMU/PANDA disassembly dump and directly relate to the JSON log fields like entrypoint and instr_count. No special dependencies beyond the PANDA trace output.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/func_stats/README.md#_snippet_3\n\nLANGUAGE: assembly\nCODE:\n```\nProg point: 0x00000000b7eb3364 {guest_instr_count=120206427} \n```\n\n----------------------------------------\n\nTITLE: Windows NT System Call Memory and Object Functions\nDESCRIPTION: Function prototypes for NT memory allocation, thread manipulation, and object management operations. These system calls are low-level kernel functions that manage system resources like memory reserves, thread states, and unique identifiers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp0_x86_prototypes.txt#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAllocateReserveObject (PHANDLE MemoryReserveHandle, POBJECT_ATTRIBUTES ObjectAttributes, MEMORY_RESERVE_TYPE Type);\nNTSTATUS NtAllocateLocallyUniqueId (PLUID Luid);\n\nNTSTATUS NtAlertThread (HANDLE ThreadHandle);\nNTSTATUS NtAlertResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtAdjustPrivilegesToken (HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);\nNTSTATUS NtAdjustGroupsToken (HANDLE TokenHandle, BOOLEAN ResetToDefault, PTOKEN_GROUPS NewState, ULONG BufferLength, PTOKEN_GROUPS PreviousState, PULONG ReturnLength);\n\nNTSTATUS NtAddDriverEntry (PEFI_DRIVER_ENTRY DriverEntry, PULONG Id);\nNTSTATUS NtAddBootEntry (PBOOT_ENTRY BootEntry, PULONG Id);\nNTSTATUS NtAddAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\n```\n\n----------------------------------------\n\nTITLE: Storing Volatile Values and Updating Emulated PC - LLVM IR\nDESCRIPTION: This code performs volatile stores to specific memory locations, likely for updating the program counter and related state within an emulator. The !pcupdate.md !0 metadata indicates instrumentation for program counter management. It expects specific addresses and values related to the emulated environment and propagates updates to relevant offsets for further execution steps.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/dynslice.md#_snippet_8\n\nLANGUAGE: llvm\nCODE:\n```\nstore volatile i64 26, i64* inttoptr (i64 29287216 to i64*)\nstore volatile i64 1958292463, i64* inttoptr (i64 29287224 to i64*), !pcupdate.md !0\n```\n\nLANGUAGE: llvm\nCODE:\n```\n%33 = add i64 %env_v, 56032\n%34 = inttoptr i64 %33 to i64*\n%35 = ptrtoint i64* %34 to i64\ncall void @log_dynval(i64 59634320, i32 0, i32 2, i64 %35)\nstore i64 1958292463, i64* %34\n```\n\n----------------------------------------\n\nTITLE: Including External Schema Files with QAPI Directive - JSON\nDESCRIPTION: Illustrates how to modularize QAPI schema by including an external file. Requires specifying the path as a string in the 'include' key. Dependencies are the availability of the specified file and correct relative path calculation, and input should not contain additional keys.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{ 'include': 'path/to/file.json' }\n```\n\n----------------------------------------\n\nTITLE: Declaring pri User Callback Typedefs - C\nDESCRIPTION: This snippet specifies C typedefs for callbacks expected to be implemented by pri users for notification when execution hits new source lines or functions. These allow PANDA plugin consumers to respond to code execution milestones by registering these function pointers with pri. Callbacks receive state, address, and contextual file/function information. These definitions must match exactly for the callbacks to be registered and invoked properly.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/pri/README.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*on_before_line_change_t)(CPUState *env, target_ulong pc, const char *file_name, const char *funct_name, unsigned long long lno)\n\ntypedef void (*on_after_line_change_t)(CPUState *env, target_ulong pc, const char *file_name, const char *funct_name, unsigned long long lno)\n\ntypedef void (*on_fn_start_t)(CPUState *env, target_ulong pc, const char *file_name, const char *funct_name)\n\n```\n\n----------------------------------------\n\nTITLE: Adding a Virtual xHCI Host Controller - Bash/QEMU CLI\nDESCRIPTION: Shows the command-line for adding a virtual xHCI (USB 3.0) controller to a QEMU VM. The controller is assigned an ID for explicit bus referencing. Requires QEMU's xHCI controller support; outputs a VM with an xHCI controller present and usable by assigned USB devices.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/usb2.txt#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nqemu -device nec-usb-xhci,id=xhci\n```\n\n----------------------------------------\n\nTITLE: Defining Thread Context and Processor Information System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to thread context access and processor information. These functions provide access to execution context of threads and processor details.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_23\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nULONG NtGetCurrentProcessorNumber ();\n```\n\n----------------------------------------\n\nTITLE: Loading Data into Memory with QEMU Loader Device\nDESCRIPTION: This snippet demonstrates the syntax for loading data into memory using the QEMU loader device. It allows specifying the address, data, data length, endianness, and CPU number.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/generic-loader.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n-device loader,addr=<addr>,data=<data>,data-len=<data-len>[,data-be=<data-be>][,cpu-num=<cpu-num>]\n```\n\n----------------------------------------\n\nTITLE: Playing Generated Movie with ffplay\nDESCRIPTION: Command to play the generated MP4 movie file using ffplay, which is part of the ffmpeg suite of tools.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/replaymovie/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nffplay replay.mp4\n```\n\n----------------------------------------\n\nTITLE: Reporting Memory Access Log Entries for Reads/Writes - JSON Array Example - JSON\nDESCRIPTION: This example demonstrates the array format used by func_stats to log details about each memory buffer accessed during function calls, either for reads or writes. Each array entry records the buffer base address, entropy, length, number of null bytes, program counter, and the count of printable ASCII characters, correlating to pc and instruction addresses reported in other plugin outputs. The fields are reported in hex and floating point formats and are collected only when such memory accesses are observed.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/func_stats/README.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n[{\"base\":\"2fef50\",\"entropy\":2.0,\"len\":4,\"nulls\":0,\"pc\":\"77a6563a\",\"printableChars\":3},{\"base\":\"2fef64\",\"entropy\":1.5,\"len\":4,\"nulls\":2,\"pc\":\"77a6557f\",\"printableChars\":0},{\"base\":\"2fef70\",\"entropy\":2.1666159629821777,\"len\":32,\"nulls\":18,\"pc\":\"77a65590\",\"printableChars\":9},{\"base\":\"2fefa0\",\"entropy\":3.022055149078369,\"len\":12,\"nulls\":3,\"pc\":\"77a6555c\",\"printableChars\":5},{\"base\":\"2fefb8\",\"entropy\":2.0,\"len\":4,\"nulls\":0,\"pc\":\"77a65597\",\"printableChars\":3},{\"base\":\"77551000\",\"entropy\":5.467597484588623,\"len\":352,\"nulls\":3,\"pc\":\"77a655d2\",\"printableChars\":179}]\n```\n\n----------------------------------------\n\nTITLE: Extracting Buffer Data Via Textprinter Plugin - Bash\nDESCRIPTION: Performs a memory buffer dump during replay at specified tap points using the 'textprinter' plugin and 'callstack_instr'. Results are written to compressed output files (e.g., 'read_tap_buffers.txt.gz'). Prerequisites: reduced replay, correct tap_points.txt, and required PANDA plugins. Extraction points must coincide with interesting moments uncovered in prior analysis.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/UAF.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\npanda/qemu/x86_64-softmmu/panda-system-x86_64 -display none -m 1024 -replay crash_reduced \\\n    -panda 'callstack_instr;textprinter'\n```\n\n----------------------------------------\n\nTITLE: Defining and Registering a Hypercall Handler â€” Python\nDESCRIPTION: Demonstrates registering a Python function as a hypercall handler using the 'panda.hypercall' decorator. Requires a constant magic number and that the PANDA runtime supports the decorator interface. The decorated function receives a CPU object; on invocation, prints a message to standard output. Intended as the canonical example for Pythonic hypercall registration.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/hypercaller/README.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nMAGIC = 0x12345678\n@panda.hypercall(MAGIC)\ndef hypercall(cpu):\n    print(\"Hello from my hypercall!\"\n\n```\n\n----------------------------------------\n\nTITLE: Pre-DMA Replay Callback Signature\nDESCRIPTION: Callback function signature for operations before DMA transfers during replay.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_53\n\nLANGUAGE: C\nCODE:\n```\nint (*replay_before_cpu_physical_mem_rw_ram)(CPUState *env, uint32_t is_write, uint64_t src_addr, uint64_t dest_addr, uint32_t num_bytes);\n```\n\n----------------------------------------\n\nTITLE: Declaring System Call Prototypes - Linux Kernel - C\nDESCRIPTION: This code declares function prototypes for various Linux system calls as they might appear in a kernel syscall table or interface header. Each prototype defines the syscallâ€™s expected parameters and types, required for the kernel to expose these calls to user-space programs. No function bodies are provided; these declarations require a Linux-compatible toolchain, the right environment for kernel symbols, and definitions for types such as 'struct statx' or 'struct iovec'. Inputs are syscall arguments (pointers, integers, flags), and outputs are typically long integer return codes (success/error). This approach is constrained by architecture (only some syscalls are implemented for AArch64), as noted in inline comments, and by kernel version compatibility.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_arm64_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n277 long sys_seccomp(unsigned int op, unsigned int flags, const char __user *uargs);\n```\n\nLANGUAGE: C\nCODE:\n```\n278 long sys_getrandom(char __user *buf, size_t count, unsigned int flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n279 long sys_memfd_create(const char __user *uname_ptr, unsigned int flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n280 long sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);\n```\n\nLANGUAGE: C\nCODE:\n```\n281 long sys_execveat(int dfd, const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp, int flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n282 long sys_userfaultfd(int flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n283 long sys_membarrier(int cmd, int flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n284 long sys_mlock2(unsigned long start, size_t len, int flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n285 long sys_copy_file_range(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n286 long sys_preadv2(unsigned long fd, const struct iovec *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n287 long sys_pwritev2(unsigned long fd, const struct iovec *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n288 long sys_pkey_mprotect(unsigned long start, size_t len, unsigned long prot, int pkey);\n```\n\nLANGUAGE: C\nCODE:\n```\n289 long sys_pkey_alloc(unsigned long flags, unsigned long init_val);\n```\n\nLANGUAGE: C\nCODE:\n```\n290 long sys_pkey_free(int pkey);\n```\n\nLANGUAGE: C\nCODE:\n```\n291 long sys_statx(int dfd, const char *path, unsigned flags, unsigned mask, struct statx *buffer);\n```\n\nLANGUAGE: C\nCODE:\n```\n// TODO: 292 long sys_io_pgetevents_time64\n```\n\nLANGUAGE: C\nCODE:\n```\n// TODO: 293 long sys_rseq\n```\n\nLANGUAGE: C\nCODE:\n```\n294 long sys_kexec_file_load (int kernel_fd, int initrd_fd, unsigned long cmdline_len, const char *cmdline, unsigned long flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n// 295-423: no uses on AArch64\n```\n\nLANGUAGE: C\nCODE:\n```\n424 long sys_pidfd_send_signal(int pidfd, int sig, siginfo_t *info, unsigned int flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n// TODO: 425 long sys_io_uring_setup\n```\n\nLANGUAGE: C\nCODE:\n```\n// TODO: 426 long sys_io_uring_enter\n```\n\nLANGUAGE: C\nCODE:\n```\n// TODO: 427 long sys_io_uring_register\n```\n\nLANGUAGE: C\nCODE:\n```\n// TODO: 428 long sys_open_tree\n```\n\nLANGUAGE: C\nCODE:\n```\n// TODO: 429 long sys_move_mount\n```\n\nLANGUAGE: C\nCODE:\n```\n// TODO: 430 long sys_fsopen\n```\n\nLANGUAGE: C\nCODE:\n```\n// TODO: 431 long sys_fsconfig\n```\n\nLANGUAGE: C\nCODE:\n```\n// TODO: 432 long sys_fsmount\n```\n\nLANGUAGE: C\nCODE:\n```\n// TODO: 433 long sys_fspick\n```\n\nLANGUAGE: C\nCODE:\n```\n434 long sys_pidfd_open(pid_t pid, unsigned int flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n435 long sys_clone3(struct clone_args *cl_args, size_t size);\n```\n\nLANGUAGE: C\nCODE:\n```\n// TODO: 436 long sys_close_range\n```\n\nLANGUAGE: C\nCODE:\n```\n437 long sys_openat2(int dirfd, const char *pathname, struct open_how *how, size_t size);\n```\n\nLANGUAGE: C\nCODE:\n```\n438 long sys_pidfd_getfd(int pidfd, int targetfd, unsigned int flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n439 long sys_faccessat2(int dirfd, const char *pathname, int mode, int flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n// TODO: 440 long sys_process_madvise\n```\n\nLANGUAGE: C\nCODE:\n```\n// TODO: 441 long sys_epoll_pwait2\n```\n\n----------------------------------------\n\nTITLE: Defining File and Resource Management System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to file management, including file comparisons, cancellation operations, and transaction management. These functions handle core file system and resource operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAreMappedFilesTheSame (PVOID File1MappedAsAnImage, PVOID File2MappedAsFile);\nNTSTATUS NtAssignProcessToJobObject (HANDLE JobHandle, HANDLE ProcessHandle);\nNTSTATUS NtCancelIoFileEx (HANDLE FileHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtCancelSynchronousIoFile (HANDLE ThreadHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);\n```\n\n----------------------------------------\n\nTITLE: SchemaInfo for Simple Union and Implicit Enumeration - JSON\nDESCRIPTION: This JSON object provides SchemaInfo for 'BlockdevOptionsSimple', a simple union that auto-defines a discriminator field ('type') with an enumeration and object types for each variant. The 'variants' list ties discriminator values to wrapper types, demonstrating the relationship between a top-level type and its variants used in QAPI wire data.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_17\n\nLANGUAGE: json\nCODE:\n```\n{ \\\"name\\\": \\\"BlockdevOptionsSimple\\\", \\\"meta-type\\\": \\\"object\\\",\\n  \\\"members\\\": [\\n      { \\\"name\\\": \\\"type\\\", \\\"type\\\": \\\"BlockdevOptionsSimpleKind\\\" } ],\\n  \\\"tag\\\": \\\"type\\\",\\n  \\\"variants\\\": [\\n      { \\\"case\\\": \\\"file\\\", \\\"type\\\": \\\"q_obj-BlockdevOptionsFile-wrapper\\\" },\\n      { \\\"case\\\": \\\"qcow2\\\", \\\"type\\\": \\\"q_obj-BlockdevOptionsQcow2-wrapper\\\" } ] }\n```\n\n----------------------------------------\n\nTITLE: Defining Memory and Section Management System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to section extension, token filtering, and language installation. These functions handle memory management and security operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_20\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);\nNTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);\nNTSTATUS NtFlushInstallUILanguage (LANGID InstallUILanguage, ULONG SetComittedFlag);\n```\n\n----------------------------------------\n\nTITLE: Registering system call entry callback using PPP mechanism - C\nDESCRIPTION: This C code snippet demonstrates how to register a callback function for system call entry events when using the syscalls2 plugin in a PANDA plugin. The function my_NtTerminateProcess_enter must have a signature matching on_NtTerminateProcess_enter_t, and the registration is performed using the PPP_REG_CB macro during plugin initialization. Requires PANDA/build environment and ppp.h/PPP infrastructure.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/syscalls2.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nPPP_REG_CB(\"syscalls2\", on_NtTerminateProcess_enter, my_NtTerminateProcess_enter);\n```\n\n----------------------------------------\n\nTITLE: Defining File Creation System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to creating specialized file types like mailslots and named pipes. These functions set up communication channels through the file system interface.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_9\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateMailslotFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout);\nNTSTATUS NtCreateNamedPipeFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout);\n```\n\n----------------------------------------\n\nTITLE: Deleting Nodes During List Traversal with QLIST_FOREACH_SAFE in C\nDESCRIPTION: This C snippet uses QLIST_FOREACH_SAFE to traverse and conditionally remove and free deleted nodes from a linked list, found in QEMU's infrastructure. It ensures that deleted elements are removed immediately and memory is freed using g_free. This approach requires that the QLIST and memory management macros are available and that any reentrant calls do not disrupt the invariants.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/lockcnt.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nQLIST_FOREACH_SAFE(ioh, &io_handlers, next, pioh) {\n    if (ioh->deleted) {\n        QLIST_REMOVE(ioh, next);\n        g_free(ioh);\n    } else {\n        if (ioh->revents & G_IO_OUT) {\n            ioh->fd_write(ioh->opaque);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring IOPS Bursts in QEMU Command-line - Shell\nDESCRIPTION: This example illustrates how to set both a regular IOPS limit and a burst mode with higher throughput for a short duration on a QEMU drive. The throttling.iops-total restricts normal IOPS, while throttling.iops-total-max and throttling.iops-total-max-length permit short-term bursts at a higher rate. Input is a lengthy shell line broken for readability; output is enforced throttling based on these settings.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/throttle.txt#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n-drive file=hd0.qcow2,\\\n       throttling.iops-total=100,\\\n       throttling.iops-total-max=2000,\\\n       throttling.iops-total-max-length=60\n```\n\n----------------------------------------\n\nTITLE: Declaring NT API System Call Prototypes - Windows NT Native API - C\nDESCRIPTION: This snippet lists NTSTATUS-returning function declarations for the Windows NT native API, intended for use in C header files. Each function serves as a forward declaration that users or implementers can call to invoke NT system calls directly, usually via ntdll.dll or through syscall stubs, assuming the appropriate linking and privilege context. Dependencies include Windows/internals headers for type definitions (such as HANDLE, PVOID, ULONG, etc.), and the Windows NT environment. Inputs and outputs are specified by each function signature, with parameters for handles, pointers to structures, lengths, flags, and output buffers. The main constraint is that these declarations alone do not provide implementationâ€”actual function resolution occurs at runtime, so linking and run context must be considered.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp0_x86_prototypes.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapUserPhysicalPages (PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapCMFModule (ULONG What, ULONG Index, PULONG CacheIndexOut, PULONG CacheFlagsOut, PULONG ViewSizeOut, PVOID *BaseAddress);\nNTSTATUS NtMakeTemporaryObject (HANDLE Handle);\nNTSTATUS NtMakePermanentObject (HANDLE Handle);\nNTSTATUS NtLockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtLockRegistryKey (HANDLE KeyHandle);\nNTSTATUS NtLockProductActivationKeys (ULONG *pPrivateVer, ULONG *pSafeMode);\nNTSTATUS NtLockFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);\nNTSTATUS NtLoadKeyEx (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags, HANDLE TrustClassKey );\nNTSTATUS NtLoadKey2 (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags);\nNTSTATUS NtLoadKey (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile);\nNTSTATUS NtLoadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtListenPort (HANDLE PortHandle, PPORT_MESSAGE ConnectionRequest);\nNTSTATUS NtIsUILanguageComitted ();\nBOOLEAN NtIsSystemResumeAutomatic ();\nNTSTATUS NtIsProcessInJob (HANDLE ProcessHandle, HANDLE JobHandle);\nNTSTATUS NtInitiatePowerAction (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);\nNTSTATUS NtInitializeRegistry (USHORT BootCondition);\nNTSTATUS NtInitializeNlsFiles (PVOID *BaseAddress, PLCID DefaultLocaleId, PLARGE_INTEGER DefaultCasingTableSize);\nNTSTATUS NtImpersonateThread (HANDLE ServerThreadHandle, HANDLE ClientThreadHandle, PSECURITY_QUALITY_OF_SERVICE SecurityQos);\nNTSTATUS NtImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE Message);\nNTSTATUS NtImpersonateAnonymousToken (HANDLE ThreadHandle);\nNTSTATUS NtGetWriteWatch (HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, SIZE_T RegionSize, PVOID *UserAddressArray, PULONG_PTR EntriesInUserAddressArray, PULONG Granularity);\nNTSTATUS NtGetNotificationResourceManager (HANDLE ResourceManagerHandle, PTRANSACTION_NOTIFICATION TransactionNotification, ULONG NotificationLength, PLARGE_INTEGER Timeout, PULONG ReturnLength, ULONG Asynchronous, ULONG_PTR AsynchronousContext);\nNTSTATUS NtGetNlsSectionPtr (ULONG SectionType, ULONG SectionData, PVOID ContextData, PVOID *SectionPointer, PULONG SectionSize);\nNTSTATUS NtGetNextThread (HANDLE ProcessHandle, HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewThreadHandle);\nNTSTATUS NtGetNextProcess (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewProcessHandle);\nNTSTATUS NtGetMUIRegistryInfo (ULONG Flags, PULONG DataSize, PVOID Data);\nNTSTATUS NtGetDevicePowerState (HANDLE Device, DEVICE_POWER_STATE *State);\nULONG NtGetCurrentProcessorNumber ();\nNTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nNTSTATUS NtFsControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtFreezeTransactions (PLARGE_INTEGER FreezeTimeout, PLARGE_INTEGER ThawTimeout);\nNTSTATUS NtFreezeRegistry (ULONG TimeOutInSeconds);\nNTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG FreeType);\nNTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtFlushWriteBuffer ();\nNTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);\nVOID NtFlushProcessWriteBuffers ();\nNTSTATUS NtFlushKey (HANDLE KeyHandle);\nNTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);\nNTSTATUS NtFlushInstallUILanguage (LANGID InstallUILanguage, ULONG SetComittedFlag);\nNTSTATUS NtFlushBuffersFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtFindAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\nNTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);\nNTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);\nNTSTATUS NtEnumerateValueKey (HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtEnumerateTransactionObject (HANDLE RootObjectHandle, KTMOBJECT_TYPE QueryType, PKTMOBJECT_CURSOR ObjectCursor, ULONG ObjectCursorLength, PULONG ReturnLength);\nNTSTATUS NtEnumerateSystemEnvironmentValuesEx (ULONG InformationClass, PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateKey (HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtEnumerateDriverEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateBootEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnableLastKnownGood ();\nNTSTATUS NtDuplicateToken (HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);\nNTSTATUS NtDuplicateObject (HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);\nNTSTATUS NtDrawText (PUNICODE_STRING Text);\nNTSTATUS NtDisplayString (PUNICODE_STRING String);\nNTSTATUS NtDisableLastKnownGood ();\nNTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);\nNTSTATUS NtDeletePrivateNamespace (HANDLE NamespaceHandle);\nNTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtDeleteKey (HANDLE KeyHandle);\nNTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtDeleteDriverEntry (ULONG Id);\nNTSTATUS NtDeleteBootEntry (ULONG Id);\nNTSTATUS NtDeleteAtom (RTL_ATOM Atom);\nNTSTATUS NtDelayExecution (BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);\nNTSTATUS NtDebugContinue (HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);\nNTSTATUS NtDebugActiveProcess (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtCreateWorkerFactory (PHANDLE WorkerFactoryHandleReturn, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE CompletionPortHandle, HANDLE WorkerProcessHandle, PVOID StartRoutine, PVOID StartParameter, ULONG MaxThreadCount, SIZE_T StackReserve, SIZE_T StackCommit);\nNTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtCreateUserProcess (PHANDLE ProcessHandle, PHANDLE ThreadHandle, ACCESS_MASK ProcessDesiredAccess, ACCESS_MASK ThreadDesiredAccess, POBJECT_ATTRIBUTES ProcessObjectAttributes, POBJECT_ATTRIBUTES ThreadObjectAttributes, ULONG ProcessFlags, ULONG ThreadFlags, PRTL_USER_PROCESS_PARAMETERS ProcessParameters, PPROCESS_CREATE_INFO CreateInfo, PPROCESS_ATTRIBUTE_LIST AttributeList);\nNTSTATUS NtCreateTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, ULONG CreateOptions, ULONG CommitStrength);\nNTSTATUS NtCreateTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle, ULONG CreateOptions, ULONG IsolationLevel, ULONG IsolationFlags, PLARGE_INTEGER Timeout, PUNICODE_STRING Description);\nNTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);\nNTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);\nNTSTATUS NtCreateThreadEx (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument, ULONG CreateFlags, ULONG_PTR ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, PPS_ATTRIBUTE_LIST AttributeList);\nNTSTATUS NtCreateThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended);\nNTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);\nNTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);\n```\n\n----------------------------------------\n\nTITLE: Reading and Verifying Test Image Sector Data with qemu-io (Shell)\nDESCRIPTION: Uses qemu-io to inspect the first 512-byte sector of a test disk image, expected to contain valid (non-zero) data. The output helps compare the data against another image to detect corruption. Requires qemu-io; the target file ('test.img') should exist. Input is a filename and byte range, output is sector data in hex/ASCII.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/blkverify.txt#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ ./qemu-io -c 'read -v 0 512' test.img\n```\n\n----------------------------------------\n\nTITLE: Defining System Call Prototypes for Process, IPC, and Filesystem Operations - Linux Kernel - C\nDESCRIPTION: This collection of function prototypes declares advanced Linux system calls, including message queue operations (timed send and receive), semaphore operations with timeouts, real-time signal timed waits, futex operations, scheduler queries, sending signals through pidfd, I/O uring setup and management, advanced filesystem operations (open_tree, move_mount, fsopen, fsconfig, fsmount, fspick), and pidfd operations. These prototypes (each prefixed with sys_) are for kernel implementation only and not for direct user invocation. They require standard Linux kernel types and pointer conventions, relying on user-space data passed into the kernel; most return a long to indicate either success with a result or an error code. Each parameter type, such as __user pointers and various structs, must match kernel expectations. Limitations: declared for the kernel context only, safe access to user-provided pointers must be observed in implementation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips_prototypes.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n4418 long sys_mq_timedsend(mqd_t mqdes, const char __user *msg_ptr, size_t msg_len, unsigned int msg_prio, const struct __kernel_timespec __user *abs_timeout);\n```\n\nLANGUAGE: C\nCODE:\n```\n4419 long sys_mq_timedreceive(mqd_t mqdes, char __user *msg_ptr, size_t msg_len, unsigned int __user *msg_prio, const struct __kernel_timespec __user *abs_timeout);\n```\n\nLANGUAGE: C\nCODE:\n```\n4420 long sys_semtimedop(int semid, struct sembuf __user *sops, unsigned nsops, const struct __kernel_timespec __user *timeout);\n```\n\nLANGUAGE: C\nCODE:\n```\n4421 long sys_rt_sigtimedwait(const sigset_t __user *uthese, siginfo_t __user *uinfo, const struct __kernel_timespec __user *uts, size_t sigsetsize);\n```\n\nLANGUAGE: C\nCODE:\n```\n4422 long sys_futex(u32 __user *uaddr, int op, u32 val, struct __kernel_timespec __user *utime, u32 __user *uaddr2, u32 val3);\n```\n\nLANGUAGE: C\nCODE:\n```\n4423 long sys_sched_rr_get_interval(pid_t pid, struct __kernel_timespec __user *interval);\n```\n\nLANGUAGE: C\nCODE:\n```\n4424 long sys_pidfd_send_signal(int pidfd, int sig, siginfo_t __user *info, unsigned int flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n4425 long sys_io_uring_setup(u32 entries, struct io_uring_params __user *p);\n```\n\nLANGUAGE: C\nCODE:\n```\n4426 long sys_io_uring_enter(unsigned int fd, u32 to_submit, u32 min_complete, u32 flags, const sigset_t __user *sig, size_t sigsz);\n```\n\nLANGUAGE: C\nCODE:\n```\n4427 long sys_io_uring_register(unsigned int fd, unsigned int op, void __user *arg, unsigned int nr_args);\n```\n\nLANGUAGE: C\nCODE:\n```\n4428 long sys_open_tree(int dfd, const char __user *path, unsigned flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n4429 long sys_move_mount(int from_dfd, const char __user *from_path, int to_dfd, const char __user *to_path, unsigned int ms_flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n4430 long sys_fsopen(const char __user *fs_name, unsigned int flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n4431 long sys_fsconfig(int fs_fd, unsigned int cmd, const char __user *key, const void __user *value, int aux);\n```\n\nLANGUAGE: C\nCODE:\n```\n4432 long sys_fsmount(int fs_fd, unsigned int flags, unsigned int ms_flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n4433 long sys_fspick(int dfd, const char __user *path, unsigned int flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n4434 long sys_pidfd_open(pid_t pid, unsigned int flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n4437 long sys_openat2(int dfd, const char __user *filename, struct open_how *how, size_t size);\n```\n\nLANGUAGE: C\nCODE:\n```\n4438 long sys_pidfd_getfd(int pidfd, int fd, unsigned int flags);\n```\n\nLANGUAGE: C\nCODE:\n```\n4439 long sys_faccessat2(int dfd, const char __user *filename, int mode, int flags);\n```\n\n----------------------------------------\n\nTITLE: Adding Label Support to vNVDIMM in QEMU (Shell)\nDESCRIPTION: This shell snippet extends the basic vNVDIMM configuration by enabling label support through the label-size option. Requires QEMU v2.7.0 or later. The 'label-size' parameter (minimum 128K) reserves space at the end of the backend storage file for the NVDIMM label area, which is inaccessible to the guest. Caution must be taken to avoid data corruption if reusing storage files previously used without labels.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/nvdimm.txt#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n-device nvdimm,id=nvdimm1,memdev=mem1,label-size=128K\n```\n\n----------------------------------------\n\nTITLE: Loading Files into Memory with QEMU Loader Device\nDESCRIPTION: This snippet demonstrates the syntax for loading files (raw or ELF) into memory using the QEMU loader device. It allows specifying the file path, load address, CPU number, and whether to force raw loading.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/generic-loader.txt#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n-device loader,file=<file>[,addr=<addr>][,cpu-num=<cpu-num>][,force-raw=<raw>]\n```\n\n----------------------------------------\n\nTITLE: Booting Ubuntu 18.04.4 DVD in PANDA with nokaslr\nDESCRIPTION: This command demonstrates starting the PANDA emulator with an Ubuntu Live DVD for a controlled guest environment. The user should add the 'nokaslr' kernel boot parameter interactively during boot to disable KASLR in the guest. The command sets up a 4GB guest with a Linux desktop ISO mounted. Useful for environments that require precise kernel memory layouts for introspection.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi_linux/README.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 --monitor stdio \\\n-m 4096 \\\n-cdrom 'ubuntu-18.04.4-desktop-amd64.iso'\n\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Calls for Process and Thread Management in C\nDESCRIPTION: This snippet declares Windows NT system calls related to process and thread management, including operations like queuing APCs, raising exceptions, and managing worker factories. These functions are crucial for low-level process and thread control.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x64_prototypes.txt#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueueApcThreadEx (HANDLE ThreadHandle, HANDLE UserApcReserveHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\nNTSTATUS NtRaiseException (PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ContextRecord, BOOLEAN FirstChance);\nNTSTATUS NtReleaseWorkerFactoryWorker (HANDLE WorkerFactoryHandle);\nNTSTATUS NtRemoveProcessDebug (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtResumeProcess (HANDLE ProcessHandle);\n```\n\n----------------------------------------\n\nTITLE: Wrapping C Function in Python for PyPANDA (Python)\nDESCRIPTION: This Python method wraps the new C function (panda_current_pc), exposing it through the panda class. It forwards the CPU state object directly to the C layer. The pattern shown is extensible to other C functions; more complex signatures may require argument translation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/docs/extending_pypanda.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef current_pc(self,cpustate):\n\treturn self.libpanda.panda_current_pc(cpustate)\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API File System Functions in C\nDESCRIPTION: Function declarations for Windows NT native API calls related to file system operations including creating files, querying information, file section management, and I/O operations. These functions provide low-level access to file system resources.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp0_x64_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtFlushBuffersFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtCreateFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);\nNTSTATUS NtCancelIoFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Call Prototypes in C\nDESCRIPTION: This snippet declares function prototypes for Windows NT native API calls. These functions are typically used for low-level system operations and are not part of the standard Win32 API. They include calls for memory management, file operations, process control, and system information queries.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtWaitForSingleObject (HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtCallbackReturn (PVOID OutputBuffer, ULONG OutputLength, NTSTATUS Status);\nNTSTATUS NtReadFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtWriteFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtRemoveIoCompletion (HANDLE IoCompletionHandle, PVOID *KeyContext, PVOID *ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER Timeout);\nNTSTATUS NtReleaseSemaphore (HANDLE SemaphoreHandle, LONG ReleaseCount, PLONG PreviousCount);\nNTSTATUS NtReplyWaitReceivePort (HANDLE PortHandle, PVOID *PortContext , PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage);\nNTSTATUS NtReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtSetInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);\nNTSTATUS NtSetEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtClose (HANDLE Handle);\nNTSTATUS NtQueryObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\nNTSTATUS NtOpenKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtEnumerateValueKey (HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtFindAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\nNTSTATUS NtQueryDefaultLocale (BOOLEAN UserProfile, PLCID DefaultLocaleId);\nNTSTATUS NtQueryKey (HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtQueryValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtAllocateVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);\nNTSTATUS NtQueryInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);\nNTSTATUS NtWaitForMultipleObjects32 (ULONG Count, LONG Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtWriteFileGather (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtSetInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);\nNTSTATUS NtCreateKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);\nNTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG FreeType);\nNTSTATUS NtImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE Message);\nNTSTATUS NtReleaseMutant (HANDLE MutantHandle, PLONG PreviousCount);\nNTSTATUS NtQueryInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);\nNTSTATUS NtRequestWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtQueryVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtOpenThreadToken (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);\nNTSTATUS NtQueryInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);\nNTSTATUS NtOpenProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtSetInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\nNTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, WIN32_PROTECTION_MASK Win32Protect);\nNTSTATUS NtAccessCheckAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtUnmapViewOfSection (HANDLE ProcessHandle, PVOID BaseAddress);\nNTSTATUS NtReplyWaitReceivePortEx (HANDLE PortHandle, PVOID *PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage, PLARGE_INTEGER Timeout);\nNTSTATUS NtTerminateProcess (HANDLE ProcessHandle, NTSTATUS ExitStatus);\nNTSTATUS NtSetEventBoostPriority (HANDLE EventHandle);\nNTSTATUS NtReadFileScatter (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtOpenThreadTokenEx (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenProcessTokenEx (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtQueryPerformanceCounter (PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);\nNTSTATUS NtEnumerateKey (HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtOpenFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);\nNTSTATUS NtDelayExecution (BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);\nNTSTATUS NtQueryDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);\nNTSTATUS NtQuerySystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\nNTSTATUS NtOpenSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtQueryTimer (HANDLE TimerHandle, TIMER_INFORMATION_CLASS TimerInformationClass, PVOID TimerInformation, ULONG TimerInformationLength, PULONG ReturnLength);\nNTSTATUS NtFsControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtWriteVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\nNTSTATUS NtCloseObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtDuplicateObject (HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);\nNTSTATUS NtQueryAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);\nNTSTATUS NtClearEvent (HANDLE EventHandle);\nNTSTATUS NtReadVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtOpenEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtAdjustPrivilegesToken (HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);\nNTSTATUS NtDuplicateToken (HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);\nNTSTATUS NtContinue (PCONTEXT ContextRecord, BOOLEAN TestAlert);\nNTSTATUS NtQueryDefaultUILanguage (LANGID *DefaultUILanguageId);\nNTSTATUS NtQueueApcThread (HANDLE ThreadHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\nNTSTATUS NtYieldExecution ();\nNTSTATUS NtAddAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Calls in C\nDESCRIPTION: This snippet contains function declarations for Windows NT system calls. These functions are part of the native API and cover various system operations such as querying information, opening handles, and managing system resources.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp0_x86_prototypes.txt#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationPort (HANDLE PortHandle, PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtQueryInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\nNTSTATUS NtQueryInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationAtom (RTL_ATOM Atom, ATOM_INFORMATION_CLASS InformationClass, PVOID AtomInformation, ULONG AtomInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryFullAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);\nNTSTATUS NtQueryEvent (HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan);\nNTSTATUS NtQueryDriverEntryOrder (PULONG Ids, PULONG Count);\nNTSTATUS NtQueryDirectoryObject (HANDLE DirectoryHandle, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, BOOLEAN RestartScan, PULONG Context, PULONG ReturnLength);\nNTSTATUS NtQueryDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);\nNTSTATUS NtQueryDefaultUILanguage (LANGID *DefaultUILanguageId);\nNTSTATUS NtQueryDefaultLocale (BOOLEAN UserProfile, PLCID DefaultLocaleId);\nNTSTATUS NtQueryDebugFilterState (ULONG ComponentId, ULONG Level);\nNTSTATUS NtQueryBootOptions (PBOOT_OPTIONS BootOptions, PULONG BootOptionsLength);\nNTSTATUS NtQueryBootEntryOrder (PULONG Ids, PULONG Count);\nNTSTATUS NtQueryAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);\nNTSTATUS NtPulseEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtProtectVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, WIN32_PROTECTION_MASK NewProtectWin32, PULONG OldProtect);\nNTSTATUS NtPropagationFailed (HANDLE ResourceManagerHandle, ULONG RequestCookie, NTSTATUS PropStatus);\nNTSTATUS NtPropagationComplete (HANDLE ResourceManagerHandle, ULONG RequestCookie, ULONG BufferLength, PVOID Buffer);\nNTSTATUS NtPrivilegeObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\nNTSTATUS NtPrivilegedServiceAuditAlarm (PUNICODE_STRING SubsystemName, PUNICODE_STRING ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\nNTSTATUS NtPrivilegeCheck (HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, PBOOLEAN Result);\nNTSTATUS NtPrePrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrePrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPowerInformation (POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtPlugPlayControl (PLUGPLAY_CONTROL_CLASS PnPControlClass, PVOID PnPControlData, ULONG PnPControlDataLength);\nNTSTATUS NtOpenTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, LPGUID TmIdentity, ULONG OpenOptions);\nNTSTATUS NtOpenTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle);\nNTSTATUS NtOpenTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenThreadTokenEx (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenThreadToken (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);\nNTSTATUS NtOpenThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSession (PHANDLE SessionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID ResourceManagerGuid, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenProcessTokenEx (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenProcessToken (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);\nNTSTATUS NtOpenProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenPrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\nNTSTATUS NtOpenObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, ACCESS_MASK GrantedAccess, PPRIVILEGE_SET Privileges, BOOLEAN ObjectCreation, BOOLEAN AccessGranted, PBOOLEAN GenerateOnClose);\nNTSTATUS NtOpenMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKeyTransactedEx (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG OpenOptions, HANDLE TransactionHandle);\nNTSTATUS NtOpenKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE TransactionHandle);\nNTSTATUS NtOpenKeyEx (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG OpenOptions);\nNTSTATUS NtOpenKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);\nNTSTATUS NtOpenEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, LPGUID EnlistmentGuid, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtNotifyChangeSession (HANDLE Session, ULONG IoStateSequence, PVOID Reserved, ULONG Action, IO_SESSION_STATE IoState, IO_SESSION_STATE IoState2, PVOID Buffer, ULONG BufferSize);\nNTSTATUS NtNotifyChangeMultipleKeys (HANDLE MasterKeyHandle, ULONG Count, OBJECT_ATTRIBUTES SlaveObjects[], HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtNotifyChangeKey (HANDLE KeyHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtNotifyChangeDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree);\nNTSTATUS NtModifyDriverEntry (PEFI_DRIVER_ENTRY DriverEntry);\nNTSTATUS NtModifyBootEntry (PBOOT_ENTRY BootEntry);\nNTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, WIN32_PROTECTION_MASK Win32Protect);\n```\n\n----------------------------------------\n\nTITLE: Exporting and Importing CA Certificate for NSS Databases - Shell\nDESCRIPTION: This collection of 'certutil' commands illustrates exporting the smartcard CA certificate from the local NSS database for transfer, and importing it into the guest system's NSS database. Inputs are existing NSS database and certificate files; outputs are the CA certificate file on disk and its import into a guest environment. Required parameters include directories ('-d', '-dbdir'), input/output file paths ('-i', '-o'), and certificate nicknames ('-n').\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/ccid.txt#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncertutil -L -r -d sql:$PWD -o fake-smartcard-ca.cer -n fake-smartcard-ca\n```\n\nLANGUAGE: shell\nCODE:\n```\ncertutil -A -d /etc/pki/nssdb -i fake-smartcard-ca.cer -t TC,TC,TC -n fake-smartcard-ca\n```\n\n----------------------------------------\n\nTITLE: Defining Advanced I/O System Calls in C\nDESCRIPTION: Function declarations for Linux system calls related to advanced I/O operations such as splice, tee, and vmsplice. These calls enable efficient data transfer between file descriptors without additional copying.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_35\n\nLANGUAGE: C\nCODE:\n```\nlong sys_pselect6_time32(int, fd_set __user *, fd_set __user *, fd_set __user *, struct old_timespec32 __user *, void __user *);\nlong sys_unshare(unsigned long unshare_flags);\nlong sys_splice(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);\nlong sys_sync_file_range(int fd, loff_t offset, loff_t nbytes, unsigned int flags);\nlong sys_tee(int fdin, int fdout, size_t len, unsigned int flags);\nlong sys_vmsplice(int fd, const struct iovec __user *iov, unsigned long nr_segs, unsigned int flags);\nlong sys_utimes_time32(const char __user *filename, struct old_timeval32 __user *t);\nlong sys_ioprio_set(int which, int who, int ioprio);\nlong sys_ioprio_get(int which, int who);\nlong sys_preadv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);\n```\n\n----------------------------------------\n\nTITLE: Loading and Handling Register Values via Pointer Arithmetic - LLVM IR\nDESCRIPTION: This section converts the environment variable offset into a register pointer, logs its address, and loads its value for further computations. It is part of the register-value update chain, expecting prior computed addresses. Outputs the loaded value for use in subsequent stack or memory instructions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/dynslice.md#_snippet_10\n\nLANGUAGE: llvm\nCODE:\n```\n%42 = add i64 %env_v, 0\n%rax_ptr = inttoptr i64 %42 to i64*\n%43 = ptrtoint i64* %rax_ptr to i64\ncall void @log_dynval(i64 59634320, i32 0, i32 0, i64 %43)\n%rax_v = load i64* %rax_ptr\n```\n\n----------------------------------------\n\nTITLE: Launching QEMU with Emulated Smart Card Using Hardware - Shell\nDESCRIPTION: This snippet provides an example QEMU invocation for attaching the USB CCID device and using the emulated card backend with host hardware via NSS. The command assumes prior configuration and the presence of a smart card on the host, as well as QEMU built with smartcard support. The '-usb', '-device usb-ccid', and '-device ccid-card-emulated' options configure the virtual USB stack and smart card emulation. Input is the QEMU command; the output is a guest VM with an attached virtual smart card reader.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/ccid.txt#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nqemu -usb -device usb-ccid -device ccid-card-emulated\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API Functions (NtFreezeTransactions to NtPrePrepareEnlistment)\nDESCRIPTION: This snippet contains Windows NT Native API function declarations that represent the raw system calls available to interact with the Windows kernel. These functions provide low-level access to operating system services such as file operations, process management, registry manipulation, and transaction handling.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x86_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtFreezeTransactions (PLARGE_INTEGER FreezeTimeout, PLARGE_INTEGER ThawTimeout);\nNTSTATUS NtFsControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nULONG NtGetCurrentProcessorNumber ();\nNTSTATUS NtGetDevicePowerState (HANDLE Device, DEVICE_POWER_STATE *State);\nNTSTATUS NtGetMUIRegistryInfo (ULONG Flags, PULONG DataSize, PVOID Data);\nNTSTATUS NtGetNextProcess (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewProcessHandle);\nNTSTATUS NtGetNextThread (HANDLE ProcessHandle, HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewThreadHandle);\nNTSTATUS NtGetNlsSectionPtr (ULONG SectionType, ULONG SectionData, PVOID ContextData, PVOID *SectionPointer, PULONG SectionSize);\nNTSTATUS NtGetNotificationResourceManager (HANDLE ResourceManagerHandle, PTRANSACTION_NOTIFICATION TransactionNotification, ULONG NotificationLength, PLARGE_INTEGER Timeout, PULONG ReturnLength, ULONG Asynchronous, ULONG_PTR AsynchronousContext);\nNTSTATUS NtGetPlugPlayEvent (HANDLE EventHandle, PVOID Context, PPLUGPLAY_EVENT_BLOCK EventBlock, ULONG EventBufferSize);\nNTSTATUS NtGetWriteWatch (HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, SIZE_T RegionSize, PVOID *UserAddressArray, PULONG_PTR EntriesInUserAddressArray, PULONG Granularity);\nNTSTATUS NtImpersonateAnonymousToken (HANDLE ThreadHandle);\nNTSTATUS NtImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE Message);\nNTSTATUS NtImpersonateThread (HANDLE ServerThreadHandle, HANDLE ClientThreadHandle, PSECURITY_QUALITY_OF_SERVICE SecurityQos);\nNTSTATUS NtInitializeNlsFiles (PVOID *BaseAddress, PLCID DefaultLocaleId, PLARGE_INTEGER DefaultCasingTableSize);\nNTSTATUS NtInitializeRegistry (USHORT BootCondition);\nNTSTATUS NtInitiatePowerAction (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);\nNTSTATUS NtIsProcessInJob (HANDLE ProcessHandle, HANDLE JobHandle);\nBOOLEAN NtIsSystemResumeAutomatic ();\nNTSTATUS NtIsUILanguageComitted ();\nNTSTATUS NtListenPort (HANDLE PortHandle, PPORT_MESSAGE ConnectionRequest);\nNTSTATUS NtLoadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtLoadKey (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile);\nNTSTATUS NtLoadKey2 (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags);\nNTSTATUS NtLoadKeyEx (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags, HANDLE TrustClassKey );\nNTSTATUS NtLockFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);\nNTSTATUS NtLockProductActivationKeys (ULONG *pPrivateVer, ULONG *pSafeMode);\nNTSTATUS NtLockRegistryKey (HANDLE KeyHandle);\nNTSTATUS NtLockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtMakePermanentObject (HANDLE Handle);\nNTSTATUS NtMakeTemporaryObject (HANDLE Handle);\nNTSTATUS NtMapCMFModule (ULONG What, ULONG Index, PULONG CacheIndexOut, PULONG CacheFlagsOut, PULONG ViewSizeOut, PVOID *BaseAddress);\nNTSTATUS NtMapUserPhysicalPages (PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, WIN32_PROTECTION_MASK Win32Protect);\nNTSTATUS NtModifyBootEntry (PBOOT_ENTRY BootEntry);\nNTSTATUS NtModifyDriverEntry (PEFI_DRIVER_ENTRY DriverEntry);\nNTSTATUS NtNotifyChangeDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree);\nNTSTATUS NtNotifyChangeKey (HANDLE KeyHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtNotifyChangeMultipleKeys (HANDLE MasterKeyHandle, ULONG Count, OBJECT_ATTRIBUTES SlaveObjects[], HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\nNTSTATUS NtNotifyChangeSession (HANDLE Session, ULONG IoStateSequence, PVOID Reserved, ULONG Action, IO_SESSION_STATE IoState, IO_SESSION_STATE IoState2, PVOID Buffer, ULONG BufferSize);\nNTSTATUS NtOpenDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, LPGUID EnlistmentGuid, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);\nNTSTATUS NtOpenIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKeyEx (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG OpenOptions);\nNTSTATUS NtOpenKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE TransactionHandle);\nNTSTATUS NtOpenKeyTransactedEx (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG OpenOptions, HANDLE TransactionHandle);\nNTSTATUS NtOpenMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, ACCESS_MASK GrantedAccess, PPRIVILEGE_SET Privileges, BOOLEAN ObjectCreation, BOOLEAN AccessGranted, PBOOLEAN GenerateOnClose);\nNTSTATUS NtOpenPrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\nNTSTATUS NtOpenProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenProcessToken (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);\nNTSTATUS NtOpenProcessTokenEx (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID ResourceManagerGuid, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSession (PHANDLE SessionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\nNTSTATUS NtOpenThreadToken (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);\nNTSTATUS NtOpenThreadTokenEx (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle);\nNTSTATUS NtOpenTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtOpenTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle);\nNTSTATUS NtOpenTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, LPGUID TmIdentity, ULONG OpenOptions);\nNTSTATUS NtPlugPlayControl (PLUGPLAY_CONTROL_CLASS PnPControlClass, PVOID PnPControlData, ULONG PnPControlDataLength);\nNTSTATUS NtPowerInformation (POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtPrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrePrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtPrePrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\n```\n\n----------------------------------------\n\nTITLE: Windows NT Query Functions\nDESCRIPTION: Function declarations for querying various system objects and information, including I/O completion, ports, processes, threads, and tokens.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2000_x86_prototypes.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryIoCompletion(HANDLE IoCompletionHandle, IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass, PVOID IoCompletionInformation, ULONG IoCompletionInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);\n```\n\n----------------------------------------\n\nTITLE: Declaring Native Windows System Call Prototypes in C\nDESCRIPTION: Each code snippet declares a native NT system call as a C function prototype, specifying parameter types and the NTSTATUS return value. These declarations are intended for inclusion in C/C++ projects requiring direct access to NT kernel interfaces. Dependencies include prior definition of all structure and type names (e.g., HANDLE, NTSTATUS, OBJECT_ATTRIBUTES). Inputs are handles, pointers to data, or configuration values; outputs are status codes or populated structures. These functions are not directly usable without suitable import libraries and privileges, and many are undocumented or subject to change across Windows versions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2003sp12_x64_prototypes.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtWaitForSingleObject (HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCallbackReturn (PVOID OutputBuffer, ULONG OutputLength, NTSTATUS Status);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtReadFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtWriteFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRemoveIoCompletion (HANDLE IoCompletionHandle, PVOID *KeyContext, PVOID *ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtReleaseSemaphore (HANDLE SemaphoreHandle, LONG ReleaseCount, PLONG PreviousCount);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtReplyWaitReceivePort (HANDLE PortHandle, PVOID *PortContext , PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetEvent (HANDLE EventHandle, PLONG PreviousState);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtClose (HANDLE Handle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtEnumerateValueKey (HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFindAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryDefaultLocale (BOOLEAN UserProfile, PLCID DefaultLocaleId);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryKey (HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAllocateVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtWaitForMultipleObjects32 (ULONG Count, LONG Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtWriteFileGather (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG FreeType);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE Message);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtReleaseMutant (HANDLE MutantHandle, PLONG PreviousCount);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtRequestWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage, PPORT_MESSAGE ReplyMessage);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenThreadToken (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, WIN32_PROTECTION_MASK Win32Protect);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAccessCheckAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtUnmapViewOfSection (HANDLE ProcessHandle, PVOID BaseAddress);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtReplyWaitReceivePortEx (HANDLE PortHandle, PVOID *PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage, PLARGE_INTEGER Timeout);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtTerminateProcess (HANDLE ProcessHandle, NTSTATUS ExitStatus);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetEventBoostPriority (HANDLE EventHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtReadFileScatter (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenThreadTokenEx (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenProcessTokenEx (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryPerformanceCounter (PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtEnumerateKey (HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDelayExecution (BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQuerySystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryTimer (HANDLE TimerHandle, TIMER_INFORMATION_CLASS TimerInformationClass, PVOID TimerInformation, ULONG TimerInformationLength, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtFsControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtWriteVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCloseObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDuplicateObject (HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtClearEvent (HANDLE EventHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtReadVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtOpenEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAdjustPrivilegesToken (HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDuplicateToken (HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtContinue (PCONTEXT ContextRecord, BOOLEAN TestAlert);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueryDefaultUILanguage (LANGID *DefaultUILanguageId);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtQueueApcThread (HANDLE ThreadHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtYieldExecution ();\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAddAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\n```\n\n----------------------------------------\n\nTITLE: Viewing LTTng Traces with Babeltrace\nDESCRIPTION: Demonstrates how to use Babeltrace to view LTTng traces at a later time.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/tracing.txt#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nbabeltrace $HOME/lttng-traces/mysession-<date>-<time>\n```\n\n----------------------------------------\n\nTITLE: Defining Key and Event Object Creation System Calls in Windows NT API\nDESCRIPTION: Function declarations for Windows NT system calls related to creating registry keys in transactions and keyed events. These functions provide access to Windows registry operations and synchronization primitives.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, HANDLE TransactionHandle, PULONG Disposition);\nNTSTATUS NtCreateKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\n```\n\n----------------------------------------\n\nTITLE: Sample Syscall Prototype Dump Output from cosi_strace - C\nDESCRIPTION: This C code block gives a sample output when using cosi_strace's dump_prototypes feature. It lists Linux syscall prototypes with their index, return type, name, and arguments, formatted for direct compatibility with C or strace tools. The output is intended to be written to a file and can be parsed by tooling or humans to understand syscall signatures. Limitation: no runtime effect; these are meant for reference and not for execution.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/cosi_strace/README.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n0 long sys_restart_syscall(void);\n1 long sys_exit(int error_code);\n2 long sys_fork(void);\n3 long sys_read(unsigned int fd, char __user *buf, size_t count);\n4 long sys_write(unsigned int fd, const char __user *buf, size_t count);\n5 long sys_open(const char __user *filename, int flags, umode_t mode);\n6 long sys_close(unsigned int fd);\n7 long sys_waitpid(pid_t pid, int __user *stat_addr, int options);\n8 long sys_creat(const char __user *pathname, umode_t mode);\n9 long sys_link(const char __user *oldname, const char __user *newname);\n10 long sys_unlink(const char __user *pathname);\n11 long sys_execve(const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp);\n12 long sys_chdir(const char __user *filename);\n```\n\n----------------------------------------\n\nTITLE: Configuring QEMU for Multiseat with SDL2/GTK UI - Shell/Bash\nDESCRIPTION: This snippet illustrates building QEMU with specific UI backends (SDL2 or GTK) by passing the appropriate flags to the configure script. The configure command enables multihead/multiseat support and event input routing. Prerequisite: QEMU build dependencies need to be installed (e.g., sdl2 or gtk development libraries). Output is a QEMU binary with the specified UI support. Ensure that relevant dev libraries (libgtk-3-dev, libsdl2-dev) are present before running these commands.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/multiseat.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure --enable-sdl --with-sdlabi=2.0\n```\n\nLANGUAGE: bash\nCODE:\n```\n./configure --enable-gtk\n```\n\n----------------------------------------\n\nTITLE: Storing Updated Values and Incrementing Environment Offsets - LLVM IR\nDESCRIPTION: This snippet conducts further address masking, zero-extension, logging, and stores back manipulated values to the register stack pointer. It incrementally updates environment memory (likely modeling x86 GPRs) and logs each stage. Dependencies include custom log_dynval and store/load commands. The code expects addresses and intermediate results, and outputs modified stack or environment register slots for continued emulation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/dynslice.md#_snippet_7\n\nLANGUAGE: llvm\nCODE:\n```\n%25 = trunc i64 %tmp2_v4 to i32\n```\n\nLANGUAGE: llvm\nCODE:\n```\n%tmp-12_v = zext i32 %25 to i64\n%26 = ptrtoint i64* %rsp_ptr to i64\ncall void @log_dynval(i64 59634320, i32 0, i32 2, i64 %26)\nstore i64 %tmp-12_v, i64* %rsp_ptr\n%27 = add i64 %env_v, 128\n%28 = inttoptr i64 %27 to i64*\n%29 = ptrtoint i64* %28 to i64\ncall void @log_dynval(i64 59634320, i32 0, i32 0, i64 %29)\n%tmp4_v = load i64* %28\n%tmp4_v6 = add i64 %tmp4_v, 3\n%30 = add i64 %env_v, 128\n%31 = inttoptr i64 %30 to i64*\n%32 = ptrtoint i64* %31 to i64\ncall void @log_dynval(i64 59634320, i32 0, i32 2, i64 %32)\nstore i64 %tmp4_v6, i64* %31\n```\n\n----------------------------------------\n\nTITLE: Running PANDA with Plugins via Shell Command (Shell)\nDESCRIPTION: This shell command demonstrates how to run PANDA's QEMU executable for the x86_64 target with both callstack_instr and stringsearch plugins loaded. It expects appropriate input files (such as a replay named 'foo' and a search strings file like 'jpeg_search_strings.txt'). Parameters should be adjusted for target system and file locations. Output is written to a determined .txt file and shown on screen.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/stringsearch/README.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo \\\n    -panda callstack_instr -panda stringsearch:name=jpeg\n```\n\n----------------------------------------\n\nTITLE: Declaring a Callback for Ending Block Execution via TCG - C\nDESCRIPTION: Presents a function pointer end_block_exec, used similarly to after_block_exec but as part of the TCG stream, for callback upon finishing block execution. It takes CPUState and TranslationBlock pointers, facilitating post-block-instrumentation in PANDA. It is void and requires prior definition of PANDA structures; called automatically by the framework at block execution end.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_61\n\nLANGUAGE: C\nCODE:\n```\nvoid (*end_block_exec)(CPUState *cpu, TranslationBlock* tb);\n```\n\n----------------------------------------\n\nTITLE: Defining File Notification System Calls in C\nDESCRIPTION: Function declarations for Linux system calls related to file system notifications (inotify). These calls provide mechanisms for monitoring file system events such as file modifications, creation, or deletion.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_33\n\nLANGUAGE: C\nCODE:\n```\nlong sys_inotify_init(void);\nlong sys_inotify_add_watch(int fd, const char __user *path, u32 mask);\nlong sys_inotify_rm_watch(int fd, __s32 wd);\nlong sys_inotify_init1(int flags);\n```\n\n----------------------------------------\n\nTITLE: Registering Asynchronous Guest Commands with PyPANDA in Python\nDESCRIPTION: This example shows registering multiple functions using @panda.queue_blocking to execute guest commands asynchronously without blocking the main guest CPU. Each function can interact with the guest serial port and analysis ends upon completion. Dependencies: a Panda object and guest image supporting serial console; Input: serial commands; Output: response strings printed to Python stdout in correct order.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/docs/USAGE.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npanda = ...\n\n@panda.queue_blocking\ndef first_cmd():\n    print(panda.run_serial_cmd(\"uname -a\"))\n\n@panda.queue_blocking\ndef second_cmd():\n    print(panda.run_serial_cmd(\"whoami\"))\n    panda.end_analysis()\n\npanda.run()\n```\n\n----------------------------------------\n\nTITLE: Declaring NT Worker Factory and Process System Calls - Windows NT - C\nDESCRIPTION: This snippet provides a sequence of extern function declarations for Windows NT system calls related to worker factory management, thread and process creation, licensing, and localization. Each function uses NT-specific types and is typically linked against native API libraries or resolved dynamically. The API functions expect handles, structure pointers, flags, and various scalar types as parameters; return values are NTSTATUS codes indicating operation results. Usage requires a project configured to target Windows internals and inclusion of relevant NT header definitions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp12_x86_prototypes.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtReleaseWorkerFactoryWorker (HANDLE WorkerFactoryHandle);\nNTSTATUS NtWaitForWorkViaWorkerFactory (HANDLE WorkerFactoryHandle, PFILE_IO_COMPLETION_INFORMATION MiniPacket);\nNTSTATUS NtSetInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength);\nNTSTATUS NtQueryInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength, PULONG ReturnLength);\nNTSTATUS NtWorkerFactoryWorkerReady (HANDLE WorkerFactoryHandle);\nNTSTATUS NtShutdownWorkerFactory (HANDLE WorkerFactoryHandle, LONG *PendingWorkerCount);\nNTSTATUS NtCreateThreadEx (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument, ULONG CreateFlags, ULONG_PTR ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, PPS_ATTRIBUTE_LIST AttributeList);\nNTSTATUS NtCreateUserProcess (PHANDLE ProcessHandle, PHANDLE ThreadHandle, ACCESS_MASK ProcessDesiredAccess, ACCESS_MASK ThreadDesiredAccess, POBJECT_ATTRIBUTES ProcessObjectAttributes, POBJECT_ATTRIBUTES ThreadObjectAttributes, ULONG ProcessFlags, ULONG ThreadFlags, PRTL_USER_PROCESS_PARAMETERS ProcessParameters, PPROCESS_CREATE_INFO CreateInfo, PPROCESS_ATTRIBUTE_LIST AttributeList);\nNTSTATUS NtQueryLicenseValue (PUNICODE_STRING Name, PULONG Type, PVOID Buffer, ULONG Length, PULONG ReturnedLength);\nNTSTATUS NtMapCMFModule (ULONG What, ULONG Index, PULONG CacheIndexOut, PULONG CacheFlagsOut, PULONG ViewSizeOut, PVOID *BaseAddress);\nNTSTATUS NtIsUILanguageComitted ();\nNTSTATUS NtFlushInstallUILanguage (LANGID InstallUILanguage, ULONG SetComittedFlag);\nNTSTATUS NtGetMUIRegistryInfo (ULONG Flags, PULONG DataSize, PVOID Data);\n```\n\n----------------------------------------\n\nTITLE: Declaring NT System Call Prototypes in C\nDESCRIPTION: This snippet defines a large collection of NT kernel system call function prototypes in C. Each function returns an NTSTATUS code and takes parameters using standard Windows data types (e.g., HANDLE, PVOID, ULONG), with pointer parameters used to return output values from system calls. The code has no runtime dependencies but expects inclusion of proper type definitions and linking to Windows headers. Intended inputs/outputs are described by each prototype's argument list; return is typically NTSTATUS indication of system call success or failure. This source is commonly used by low-level Windows applications, tools, or drivers interfacing directly with the native API, and is not portable outside NT-based systems.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x86_prototypes.txt#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapUserPhysicalPages (PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtMapCMFModule (ULONG What, ULONG Index, PULONG CacheIndexOut, PULONG CacheFlagsOut, PULONG ViewSizeOut, PVOID *BaseAddress);\nNTSTATUS NtMakeTemporaryObject (HANDLE Handle);\nNTSTATUS NtMakePermanentObject (HANDLE Handle);\nNTSTATUS NtLockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\nNTSTATUS NtLockRegistryKey (HANDLE KeyHandle);\nNTSTATUS NtLockProductActivationKeys (ULONG *pPrivateVer, ULONG *pSafeMode);\nNTSTATUS NtLockFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);\nNTSTATUS NtLoadKeyEx (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags, HANDLE TrustClassKey );\nNTSTATUS NtLoadKey2 (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags);\nNTSTATUS NtLoadKey (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile);\nNTSTATUS NtLoadDriver (PUNICODE_STRING DriverServiceName);\nNTSTATUS NtListenPort (HANDLE PortHandle, PPORT_MESSAGE ConnectionRequest);\nNTSTATUS NtIsUILanguageComitted ();\nBOOLEAN NtIsSystemResumeAutomatic ();\nNTSTATUS NtIsProcessInJob (HANDLE ProcessHandle, HANDLE JobHandle);\nNTSTATUS NtInitiatePowerAction (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);\nNTSTATUS NtInitializeRegistry (USHORT BootCondition);\nNTSTATUS NtInitializeNlsFiles (PVOID *BaseAddress, PLCID DefaultLocaleId, PLARGE_INTEGER DefaultCasingTableSize);\nNTSTATUS NtImpersonateThread (HANDLE ServerThreadHandle, HANDLE ClientThreadHandle, PSECURITY_QUALITY_OF_SERVICE SecurityQos);\nNTSTATUS NtImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE Message);\nNTSTATUS NtImpersonateAnonymousToken (HANDLE ThreadHandle);\nNTSTATUS NtGetWriteWatch (HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, SIZE_T RegionSize, PVOID *UserAddressArray, PULONG_PTR EntriesInUserAddressArray, PULONG Granularity);\nNTSTATUS NtGetNotificationResourceManager (HANDLE ResourceManagerHandle, PTRANSACTION_NOTIFICATION TransactionNotification, ULONG NotificationLength, PLARGE_INTEGER Timeout, PULONG ReturnLength, ULONG Asynchronous, ULONG_PTR AsynchronousContext);\nNTSTATUS NtGetNlsSectionPtr (ULONG SectionType, ULONG SectionData, PVOID ContextData, PVOID *SectionPointer, PULONG SectionSize);\nNTSTATUS NtGetNextThread (HANDLE ProcessHandle, HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewThreadHandle);\nNTSTATUS NtGetNextProcess (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewProcessHandle);\nNTSTATUS NtGetMUIRegistryInfo (ULONG Flags, PULONG DataSize, PVOID Data);\nNTSTATUS NtGetDevicePowerState (HANDLE Device, DEVICE_POWER_STATE *State);\nULONG NtGetCurrentProcessorNumber ();\nNTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nNTSTATUS NtFsControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtFreezeTransactions (PLARGE_INTEGER FreezeTimeout, PLARGE_INTEGER ThawTimeout);\nNTSTATUS NtFreezeRegistry (ULONG TimeOutInSeconds);\nNTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG FreeType);\nNTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtFlushWriteBuffer ();\nNTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);\nVOID NtFlushProcessWriteBuffers ();\nNTSTATUS NtFlushKey (HANDLE KeyHandle);\nNTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);\nNTSTATUS NtFlushInstallUILanguage (LANGID InstallUILanguage, ULONG SetComittedFlag);\nNTSTATUS NtFlushBuffersFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtFindAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\nNTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);\nNTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);\nNTSTATUS NtEnumerateValueKey (HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtEnumerateTransactionObject (HANDLE RootObjectHandle, KTMOBJECT_TYPE QueryType, PKTMOBJECT_CURSOR ObjectCursor, ULONG ObjectCursorLength, PULONG ReturnLength);\nNTSTATUS NtEnumerateSystemEnvironmentValuesEx (ULONG InformationClass, PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateKey (HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\nNTSTATUS NtEnumerateDriverEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnumerateBootEntries (PVOID Buffer, PULONG BufferLength);\nNTSTATUS NtEnableLastKnownGood ();\nNTSTATUS NtDuplicateToken (HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);\nNTSTATUS NtDuplicateObject (HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);\nNTSTATUS NtDrawText (PUNICODE_STRING Text);\nNTSTATUS NtDisplayString (PUNICODE_STRING String);\nNTSTATUS NtDisableLastKnownGood ();\nNTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);\nNTSTATUS NtDeletePrivateNamespace (HANDLE NamespaceHandle);\nNTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtDeleteKey (HANDLE KeyHandle);\nNTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtDeleteDriverEntry (ULONG Id);\nNTSTATUS NtDeleteBootEntry (ULONG Id);\nNTSTATUS NtDeleteAtom (RTL_ATOM Atom);\nNTSTATUS NtDelayExecution (BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);\nNTSTATUS NtDebugContinue (HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);\nNTSTATUS NtDebugActiveProcess (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtCreateWorkerFactory (PHANDLE WorkerFactoryHandleReturn, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE CompletionPortHandle, HANDLE WorkerProcessHandle, PVOID StartRoutine, PVOID StartParameter, ULONG MaxThreadCount, SIZE_T StackReserve, SIZE_T StackCommit);\nNTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtCreateUserProcess (PHANDLE ProcessHandle, PHANDLE ThreadHandle, ACCESS_MASK ProcessDesiredAccess, ACCESS_MASK ThreadDesiredAccess, POBJECT_ATTRIBUTES ProcessObjectAttributes, POBJECT_ATTRIBUTES ThreadObjectAttributes, ULONG ProcessFlags, ULONG ThreadFlags, PRTL_USER_PROCESS_PARAMETERS ProcessParameters, PPROCESS_CREATE_INFO CreateInfo, PPROCESS_ATTRIBUTE_LIST AttributeList);\nNTSTATUS NtCreateTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, ULONG CreateOptions, ULONG CommitStrength);\nNTSTATUS NtCreateTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle, ULONG CreateOptions, ULONG IsolationLevel, ULONG IsolationFlags, PLARGE_INTEGER Timeout, PUNICODE_STRING Description);\nNTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);\nNTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);\nNTSTATUS NtCreateThreadEx (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument, ULONG CreateFlags, ULONG_PTR ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, PPS_ATTRIBUTE_LIST AttributeList);\nNTSTATUS NtCreateThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended);\nNTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);\nNTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);\n```\n\n----------------------------------------\n\nTITLE: Flow Table ID 0: Ingress Port Table Structure - Technical Table - plaintext\nDESCRIPTION: Describes the TLVs and their sizes for the ingress port table in OF-DPA, used to match on input port with possible forwarding or drop. To be used in conjunction with the OF_DPA_CMD=ADD or MOD for tableID=0. Prerequisites: field names refer to previously described DPA command request structures.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/rocker.txt#_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\nfield\\t\\t\\t\\twidth\\tdescription\\n----------------------------------------------------\\nOF_DPA_IN_PPORT\\t\\t4\\tingress physical port number\\nOF_DPA_GOTO_TBL\\t\\t2\\tgoto table ID; zero to drop\n```\n\n----------------------------------------\n\nTITLE: Building and Installing PyPANDA Package\nDESCRIPTION: Commands to navigate to the PyPANDA core directory and install the pandare Python package using setup.py.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ cd panda/panda/python/core\n$ python setup.py install\n```\n\n----------------------------------------\n\nTITLE: Declaring NT System Call Prototypes for Win32 Native API in C/C++\nDESCRIPTION: This snippet defines a series of function prototypes for Windows NT native system calls using the NTSTATUS return type in C/C++. Each function maps directly to a corresponding system call and provides low-level access to functions such as setting events, configuring system information, manipulating files, and controlling processes and threads. No implementation or dependency is included beyond the requirement for proper NT data structure and type definitions; use of these prototypes assumes linking with the appropriate system libraries and running at privilege levels sufficient to invoke the NT native API. Inputs and outputs vary per function but generally include Windows HANDLEs, pointers to data structures or buffers, and status/length fields. This header is not meant for general application development but for advanced users requiring direct system call invocation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2003sp12_x86_prototypes.txt#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n219 NTSTATUS NtSetBootEntryOrder (PULONG Ids, ULONG Count);\n220 NTSTATUS NtSetBootOptions (PBOOT_OPTIONS BootOptions, ULONG FieldsToChange);\n221 NTSTATUS NtSetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\n222 NTSTATUS NtSetDebugFilterState (ULONG ComponentId, ULONG Level, BOOLEAN State);\n223 NTSTATUS NtSetDefaultHardErrorPort (HANDLE DefaultHardErrorPort);\n224 NTSTATUS NtSetDefaultLocale (BOOLEAN UserProfile, LCID DefaultLocaleId);\n225 NTSTATUS NtSetDefaultUILanguage (LANGID DefaultUILanguageId);\n226 NTSTATUS NtSetDriverEntryOrder (PULONG Ids, ULONG Count);\n227 NTSTATUS NtSetEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\n228 NTSTATUS NtSetEvent (HANDLE EventHandle, PLONG PreviousState);\n229 NTSTATUS NtSetEventBoostPriority (HANDLE EventHandle);\n230 NTSTATUS NtSetHighEventPair (HANDLE EventPairHandle);\n231 NTSTATUS NtSetHighWaitLowEventPair (HANDLE EventPairHandle);\n232 NTSTATUS NtSetInformationDebugObject (HANDLE DebugObjectHandle, DEBUGOBJECTINFOCLASS DebugObjectInformationClass, PVOID DebugInformation, ULONG DebugInformationLength, PULONG ReturnLength);\n233 NTSTATUS NtSetInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\n234 NTSTATUS NtSetInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength);\n235 NTSTATUS NtSetInformationKey (HANDLE KeyHandle, KEY_SET_INFORMATION_CLASS KeySetInformationClass, PVOID KeySetInformation, ULONG KeySetInformationLength);\n236 NTSTATUS NtSetInformationObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength);\n237 NTSTATUS NtSetInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);\n238 NTSTATUS NtSetInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);\n239 NTSTATUS NtSetInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength);\n240 NTSTATUS NtSetIntervalProfile (ULONG Interval, KPROFILE_SOURCE Source);\n241 NTSTATUS NtSetIoCompletion (HANDLE IoCompletionHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);\n242 NTSTATUS NtSetLdtEntries (ULONG Selector0, ULONG Entry0Low, ULONG Entry0Hi, ULONG Selector1, ULONG Entry1Low, ULONG Entry1Hi);\n243 NTSTATUS NtSetLowEventPair (HANDLE EventPairHandle);\n244 NTSTATUS NtSetLowWaitHighEventPair (HANDLE EventPairHandle);\n245 NTSTATUS NtSetQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\n246 NTSTATUS NtSetSecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);\n247 NTSTATUS NtSetSystemEnvironmentValue (PUNICODE_STRING VariableName, PUNICODE_STRING VariableValue);\n248 NTSTATUS NtSetSystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, ULONG ValueLength, ULONG Attributes);\n249 NTSTATUS NtSetSystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);\n250 NTSTATUS NtSetSystemPowerState (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags);\n251 NTSTATUS NtSetSystemTime (PLARGE_INTEGER SystemTime, PLARGE_INTEGER PreviousTime);\n252 NTSTATUS NtSetThreadExecutionState (EXECUTION_STATE esFlags, PEXECUTION_STATE PreviousFlags);\n253 NTSTATUS NtSetTimer (HANDLE TimerHandle, PLARGE_INTEGER DueTime, PTIMER_APC_ROUTINE TimerApcRoutine, PVOID TimerContext, BOOLEAN WakeTimer, LONG Period, PBOOLEAN PreviousState);\n254 NTSTATUS NtSetTimerResolution (ULONG DesiredTime, BOOLEAN SetResolution, PULONG ActualTime);\n255 NTSTATUS NtSetUuidSeed (PCHAR Seed);\n256 NTSTATUS NtSetValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);\n257 NTSTATUS NtSetVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\n258 NTSTATUS NtShutdownSystem (SHUTDOWN_ACTION Action);\n259 NTSTATUS NtSignalAndWaitForSingleObject (HANDLE SignalHandle, HANDLE WaitHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n260 NTSTATUS NtStartProfile (HANDLE ProfileHandle);\n261 NTSTATUS NtStopProfile (HANDLE ProfileHandle);\n262 NTSTATUS NtSuspendProcess (HANDLE ProcessHandle);\n263 NTSTATUS NtSuspendThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\n264 NTSTATUS NtSystemDebugControl (SYSDBG_COMMAND Command, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, PULONG ReturnLength);\n265 NTSTATUS NtTerminateJobObject (HANDLE JobHandle, NTSTATUS ExitStatus);\n266 NTSTATUS NtTerminateProcess (HANDLE ProcessHandle, NTSTATUS ExitStatus);\n267 NTSTATUS NtTerminateThread (HANDLE ThreadHandle, NTSTATUS ExitStatus);\n268 NTSTATUS NtTestAlert ();\n269 NTSTATUS NtTraceEvent (HANDLE TraceHandle, ULONG Flags, ULONG FieldSize, PVOID Fields);\n270 NTSTATUS NtTranslateFilePath (PFILE_PATH InputFilePath, ULONG OutputType, PFILE_PATH OutputFilePath, PULONG OutputFilePathLength);\n271 NTSTATUS NtUnloadDriver (PUNICODE_STRING DriverServiceName);\n272 NTSTATUS NtUnloadKey (POBJECT_ATTRIBUTES TargetKey);\n273 NTSTATUS NtUnloadKey2 (POBJECT_ATTRIBUTES TargetKey, ULONG Flags);\n274 NTSTATUS NtUnloadKeyEx (POBJECT_ATTRIBUTES TargetKey, HANDLE Event);\n275 NTSTATUS NtUnlockFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key);\n276 NTSTATUS NtUnlockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\n277 NTSTATUS NtUnmapViewOfSection (HANDLE ProcessHandle, PVOID BaseAddress);\n278 NTSTATUS NtVdmControl (VDMSERVICECLASS Service, PVOID ServiceData);\n279 NTSTATUS NtWaitForDebugEvent (HANDLE DebugObjectHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PDBGUI_WAIT_STATE_CHANGE WaitStateChange);\n280 NTSTATUS NtWaitForMultipleObjects (ULONG Count, HANDLE Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n281 NTSTATUS NtWaitForSingleObject (HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n282 NTSTATUS NtWaitHighEventPair (HANDLE EventPairHandle);\n283 NTSTATUS NtWaitLowEventPair (HANDLE EventPairHandle);\n284 NTSTATUS NtWriteFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n285 NTSTATUS NtWriteFileGather (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n286 NTSTATUS NtWriteRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\n287 NTSTATUS NtWriteVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\n288 NTSTATUS NtYieldExecution ();\n289 NTSTATUS NtCreateKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\n290 NTSTATUS NtOpenKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n291 NTSTATUS NtReleaseKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n292 NTSTATUS NtWaitForKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n293 NTSTATUS NtQueryPortInformationProcess ();\n294 ULONG NtGetCurrentProcessorNumber ();\n295 NTSTATUS NtWaitForMultipleObjects32 (ULONG Count, LONG Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API System Call Prototypes in C\nDESCRIPTION: This snippet succinctly declares multiple function prototypes for Windows NT Native API operations, each returning an NTSTATUS code. The functions interface directly with low-level system facilities, including file, registry, memory management, power operations, and security tokens. To use these prototypes, it is expected that appropriate Windows headers are included (such as <windows.h>, <winternl.h> for data types like RTL_ATOM, HANDLE, POBJECT_ATTRIBUTES, etc.), and that calls are made from a privileged or kernel-level context, as these functions bypass standard Win32 abstractions. All arguments must be correctly constructed Windows structures or handles, and error codes returned are NTSTATUS values. Inputs are typically pointers to system structures or primitive values, with outputs (where applicable) written to caller-allocated buffers. Improper usage can destabilize the system, so these are intended strictly for low-level system programming.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_xpsp2_x86_prototypes.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n60 NTSTATUS NtDeleteAtom (RTL_ATOM Atom);\n61 NTSTATUS NtDeleteBootEntry (ULONG Id);\n62 NTSTATUS NtDeleteFile (POBJECT_ATTRIBUTES ObjectAttributes);\n63 NTSTATUS NtDeleteKey (HANDLE KeyHandle);\n64 NTSTATUS NtDeleteObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\n65 NTSTATUS NtDeleteValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName);\n66 NTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\n67 NTSTATUS NtDisplayString (PUNICODE_STRING String);\n68 NTSTATUS NtDuplicateObject (HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);\n69 NTSTATUS NtDuplicateToken (HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);\n70 NTSTATUS NtEnumerateBootEntries (PVOID Buffer, PULONG BufferLength);\n71 NTSTATUS NtEnumerateKey (HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\n72 NTSTATUS NtEnumerateSystemEnvironmentValuesEx (ULONG InformationClass, PVOID Buffer, PULONG BufferLength);\n73 NTSTATUS NtEnumerateValueKey (HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\n74 NTSTATUS NtExtendSection (HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);\n75 NTSTATUS NtFilterToken (HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);\n76 NTSTATUS NtFindAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\n77 NTSTATUS NtFlushBuffersFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\n78 NTSTATUS NtFlushInstructionCache (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);\n79 NTSTATUS NtFlushKey (HANDLE KeyHandle);\n80 NTSTATUS NtFlushVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);\n81 NTSTATUS NtFlushWriteBuffer ();\n82 NTSTATUS NtFreeUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n83 NTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG FreeType);\n84 NTSTATUS NtFsControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\n85 NTSTATUS NtGetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\n86 NTSTATUS NtGetDevicePowerState (HANDLE Device, DEVICE_POWER_STATE *State);\n87 NTSTATUS NtGetPlugPlayEvent (HANDLE EventHandle, PVOID Context, PPLUGPLAY_EVENT_BLOCK EventBlock, ULONG EventBufferSize);\n88 NTSTATUS NtGetWriteWatch (HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, SIZE_T RegionSize, PVOID *UserAddressArray, PULONG_PTR EntriesInUserAddressArray, PULONG Granularity);\n89 NTSTATUS NtImpersonateAnonymousToken (HANDLE ThreadHandle);\n90 NTSTATUS NtImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE Message);\n91 NTSTATUS NtImpersonateThread (HANDLE ServerThreadHandle, HANDLE ClientThreadHandle, PSECURITY_QUALITY_OF_SERVICE SecurityQos);\n92 NTSTATUS NtInitializeRegistry (USHORT BootCondition);\n93 NTSTATUS NtInitiatePowerAction (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);\n94 NTSTATUS NtIsProcessInJob (HANDLE ProcessHandle, HANDLE JobHandle);\n95 BOOLEAN NtIsSystemResumeAutomatic ();\n96 NTSTATUS NtListenPort (HANDLE PortHandle, PPORT_MESSAGE ConnectionRequest);\n97 NTSTATUS NtLoadDriver (PUNICODE_STRING DriverServiceName);\n98 NTSTATUS NtLoadKey (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile);\n99 NTSTATUS NtLoadKey2 (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags);\n100 NTSTATUS NtLockFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);\n101 NTSTATUS NtLockProductActivationKeys (ULONG *pPrivateVer, ULONG *pSafeMode);\n102 NTSTATUS NtLockRegistryKey (HANDLE KeyHandle);\n103 NTSTATUS NtLockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\n104 NTSTATUS NtMakePermanentObject (HANDLE Handle);\n105 NTSTATUS NtMakeTemporaryObject (HANDLE Handle);\n106 NTSTATUS NtMapUserPhysicalPages (PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n107 NTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n108 NTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, WIN32_PROTECTION_MASK Win32Protect);\n109 NTSTATUS NtModifyBootEntry (PBOOT_ENTRY BootEntry);\n110 NTSTATUS NtNotifyChangeDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree);\n111 NTSTATUS NtNotifyChangeKey (HANDLE KeyHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\n112 NTSTATUS NtNotifyChangeMultipleKeys (HANDLE MasterKeyHandle, ULONG Count, OBJECT_ATTRIBUTES SlaveObjects[], HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\n113 NTSTATUS NtOpenDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n114 NTSTATUS NtOpenEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n115 NTSTATUS NtOpenEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n116 NTSTATUS NtOpenFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);\n117 NTSTATUS NtOpenIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n118 NTSTATUS NtOpenJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n119 NTSTATUS NtOpenKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n120 NTSTATUS NtOpenMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n121 NTSTATUS NtOpenObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, ACCESS_MASK GrantedAccess, PPRIVILEGE_SET Privileges, BOOLEAN ObjectCreation, BOOLEAN AccessGranted, PBOOLEAN GenerateOnClose);\n122 NTSTATUS NtOpenProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\n123 NTSTATUS NtOpenProcessToken (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);\n124 NTSTATUS NtOpenProcessTokenEx (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle);\n125 NTSTATUS NtOpenSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n126 NTSTATUS NtOpenSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n127 NTSTATUS NtOpenSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n128 NTSTATUS NtOpenThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\n129 NTSTATUS NtOpenThreadToken (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);\n130 NTSTATUS NtOpenThreadTokenEx (HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle);\n131 NTSTATUS NtOpenTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n132 NTSTATUS NtPlugPlayControl (PLUGPLAY_CONTROL_CLASS PnPControlClass, PVOID PnPControlData, ULONG PnPControlDataLength);\n133 NTSTATUS NtPowerInformation (POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\n134 NTSTATUS NtPrivilegeCheck (HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, PBOOLEAN Result);\n135 NTSTATUS NtPrivilegeObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\n136 NTSTATUS NtPrivilegedServiceAuditAlarm (PUNICODE_STRING SubsystemName, PUNICODE_STRING ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\n137 NTSTATUS NtProtectVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, WIN32_PROTECTION_MASK NewProtectWin32, PULONG OldProtect);\n138 NTSTATUS NtPulseEvent (HANDLE EventHandle, PLONG PreviousState);\n139 NTSTATUS NtQueryAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);\n140 NTSTATUS NtQueryBootEntryOrder (PULONG Ids, PULONG Count);\n141 NTSTATUS NtQueryBootOptions (PBOOT_OPTIONS BootOptions, PULONG BootOptionsLength);\n```\n\n----------------------------------------\n\nTITLE: Configuring recctrlu Utility Script for User Session Tracking - Shell\nDESCRIPTION: This shell configuration demonstrates setting environment variables in the 'utils/recctrlu.sh' script to specify the location of the main utility and designate a list of usernames for session tracking. The variables 'RECCTRL' and 'USERS' are customized for deployment and determine which accounts are monitored for session-based recording. The script must be copied and invoked with the correct paths set, and the relevant users must exist in the guest system.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/recctrl/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nRECCTRL=/usr/local/sbin/recctrl\\nUSERS=(panda ubuntu mstamat)\n```\n\n----------------------------------------\n\nTITLE: Limiting User SSH Sessions with PAM Configuration - Shell\nDESCRIPTION: This PAM configuration line, for '/etc/pam.d/sshd', sets the 'pam_limits.so' control to 'requisite', enforcing session limits and aborting new SSH logins if the user's session cap is exceeded. Used alongside '/etc/security/limits.conf', this helps restrict the number of simultaneous sessions per user, aligning with the design of highly controlled environments. Prerequisites include proper editing of PAM configuration files and correctly set limits in the security policy.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/recctrl/README.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nsession    requisite    pam_limits.so\n```\n\n----------------------------------------\n\nTITLE: Running vscclient for Connecting to QEMU Passthrough Server - Shell\nDESCRIPTION: This command launches vscclient, a tool built alongside QEMU, to connect to a QEMU passthrough smart card server at a given host and port. Precondition is a running QEMU passthrough listener. Input parameters are the target QEMU host and TCP port; output is the establishment of a smart card communication tunnel over network.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/ccid.txt#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nvscclient <qemu-host> 2001\n```\n\n----------------------------------------\n\nTITLE: Defining Kernel Symbol Table Structure Format in JSON\nDESCRIPTION: The provided JSON snippet shows the structure for a kernel symbol table entry ('task_struct'), mapping field offsets and types used by COSI for parsing and introspection. Each entry includes a size, fields dictionary (with type and offset), and a kind. This structure is consumed by COSI at runtime and should be saved as a .json file (preferably compressed with .xz for plugin use).\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/cosi/README.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n\"task_struct\": {\n    \"size\": 9088,\n    \"fields\": {\n      \"acct_rss_mem1\": {\n        \"type\": {\n          \"kind\": \"base\",\n          \"name\": \"long long unsigned int\"\n        },\n        \"offset\": 3024\n      },\n      ...\n      [snip]\n      ...\n      \"wakee_flips\": {\n        \"type\": {\n          \"kind\": \"base\",\n          \"name\": \"unsigned int\"\n        },\n        \"offset\": 64\n      }\n    },\n    \"kind\": \"struct\"\n  },\n```\n\n----------------------------------------\n\nTITLE: Configuring QEMU VNC Displays for Multiple Seats - Shell/Bash\nDESCRIPTION: These command-line arguments for QEMU start two VNC servers, one per seat, binding the secondary display to the second set of devices. This facilitates remote access to individual seat displays. Required dependencies include QEMU compiled with VNC support. The 'id' and 'display' parameters ensure correct device-target binding. Expected result: remote access to each seatâ€™s display via different VNC ports.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/multiseat.txt#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n\t-display vnc=:1,id=primary \\\n\t-display vnc=:2,id=secondary,display=video.2\n```\n\n----------------------------------------\n\nTITLE: Running PANDA with tstringsearch Plugin\nDESCRIPTION: Example command demonstrating how to use the tstringsearch plugin to taint a string 'bogart' and track tainted branches in a pandalog file. The command uses multiple PANDA plugins including stringsearch, tstringsearch, and tainted_branch.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/tstringsearch/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo \\\n    -panda stringsearch:str=bogart -panda tstringsearch \\\n    -panda tainted_branch -pandalog bogart.plog\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Calls in C\nDESCRIPTION: This snippet contains multiple declarations for Windows NT system calls. These functions are part of the Windows Native API and are used for low-level system operations. The declarations include parameters and return types for various system calls.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x86_prototypes.txt#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);\nNTSTATUS NtCreateResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID RmGuid, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, PUNICODE_STRING Description);\nNTSTATUS NtCreateProfileEx (PHANDLE ProfileHandle, HANDLE Process, PVOID ProfileBase, SIZE_T ProfileSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, ULONG GroupAffinityCount, PGROUP_AFFINITY GroupAffinity);\n// ... (additional function declarations omitted for brevity)\nNTSTATUS NtAllocateUuids (PULARGE_INTEGER Time, PULONG Range, PULONG Sequence, PCHAR Seed);\nNTSTATUS NtAllocateUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n```\n\n----------------------------------------\n\nTITLE: Querying Current ASID Instruction Count Using Panda Plugin APIs in C\nDESCRIPTION: Defines a C function signature for retrieving the instruction count associated with the current ASID, where the count is adjusted to exclude instructions executed by other ASIDs. This function is part of a plugin intended for use in the panda framework. No external dependencies or arguments are required, and the result is a value of type 'Instr' giving the corrected count; the function can be safely used for arithmetic between two counts to determine the instructions executed between two events. Limitations include that this is not the raw replay instruction count.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/asid_instr_count/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nInstr get_instr_count_current_asid(void);\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Callback Functions in a Loop with PyPANDA in Python\nDESCRIPTION: This snippet shows how to define multiple callback functions inside a loop by giving each a unique name using the decorator's 'name' parameter. This allows unrelated or parametric callbacks to be registered under separate identifiers, avoiding function overwrites. Useful for batch registration of similar callbacks; Input: loop variable x; Output: print statements with callback context.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/docs/USAGE.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfor x in range(10):\n  @panda.cb_before_block_exec(name=f\"bbe_{x}\")\n  def bbe_loop(cpu, tb):\n     print(f\"Before block exec function #{x}\")\n```\n\n----------------------------------------\n\nTITLE: NT System Call Function Declarations\nDESCRIPTION: Comprehensive list of Windows NT kernel system call function declarations including operations for process management, thread control, file I/O, memory management, security, and system information. These functions represent the native API interface of the Windows NT kernel.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp0_x86_prototypes.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetBootEntryOrder (PULONG Ids, ULONG Count);\nNTSTATUS NtSetBootOptions (PBOOT_OPTIONS BootOptions, ULONG FieldsToChange);\nNTSTATUS NtSetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\n// ... additional function declarations ...\nNTSTATUS NtWaitForWorkViaWorkerFactory (HANDLE WorkerFactoryHandle, PFILE_IO_COMPLETION_INFORMATION MiniPacket);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Call Prototypes - C\nDESCRIPTION: This snippet defines a series of function prototypes for Windows NT Native API calls in C. Each declaration specifies the NTSTATUS return type, function name (NT-prefixed), and associated parameters with explicit types and relevant pointer usage. Intended for inclusion in headers, these prototypes enable external code (such as drivers or system utilities) to link against system DLLs that implement NTAPI, or to define their own stubs for hooking and analysis. Dependency on standard Windows datatype definitions is assumed, and no actual implementation is provided.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_xpsp3_x86_prototypes.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAcceptConnectPort (PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView);\nNTSTATUS NtAccessCheck (PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheckByType (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByTypeAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheckByTypeResultList (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarmByHandle (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAddAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\nNTSTATUS NtAddBootEntry (PBOOT_ENTRY BootEntry, PULONG Id);\nNTSTATUS NtAdjustGroupsToken (HANDLE TokenHandle, BOOLEAN ResetToDefault, PTOKEN_GROUPS NewState, ULONG BufferLength, PTOKEN_GROUPS PreviousState, PULONG ReturnLength);\nNTSTATUS NtAdjustPrivilegesToken (HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);\nNTSTATUS NtAlertResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtAlertThread (HANDLE ThreadHandle);\nNTSTATUS NtAllocateLocallyUniqueId (PLUID Luid);\nNTSTATUS NtAllocateUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtAllocateUuids (PULARGE_INTEGER Time, PULONG Range, PULONG Sequence, PCHAR Seed);\nNTSTATUS NtAllocateVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);\nNTSTATUS NtAreMappedFilesTheSame (PVOID File1MappedAsAnImage, PVOID File2MappedAsFile);\nNTSTATUS NtAssignProcessToJobObject (HANDLE JobHandle, HANDLE ProcessHandle);\nNTSTATUS NtCallbackReturn (PVOID OutputBuffer, ULONG OutputLength, NTSTATUS Status);\nNTSTATUS NtCancelIoFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtCancelTimer (HANDLE TimerHandle, PBOOLEAN CurrentState);\nNTSTATUS NtClearEvent (HANDLE EventHandle);\nNTSTATUS NtClose (HANDLE Handle);\nNTSTATUS NtCloseObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtCompactKeys (ULONG Count, HANDLE KeyArray[]);\nNTSTATUS NtCompareTokens (HANDLE FirstTokenHandle, HANDLE SecondTokenHandle, PBOOLEAN Equal);\nNTSTATUS NtCompleteConnectPort (HANDLE PortHandle);\nNTSTATUS NtCompressKey (HANDLE Key);\nNTSTATUS NtConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\nNTSTATUS NtContinue (PCONTEXT ContextRecord, BOOLEAN TestAlert);\nNTSTATUS NtCreateDebugObject (PHANDLE DebugObjectHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\nNTSTATUS NtCreateDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);\nNTSTATUS NtCreateEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);\nNTSTATUS NtCreateIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Count);\nNTSTATUS NtCreateJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateJobSet (ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);\nNTSTATUS NtCreateKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);\nNTSTATUS NtCreateMailslotFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout);\nNTSTATUS NtCreateMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN InitialOwner);\nNTSTATUS NtCreateNamedPipeFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout);\nNTSTATUS NtCreatePagingFile (PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority);\nNTSTATUS NtCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtCreateProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort);\nNTSTATUS NtCreateProcessEx (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel);\nNTSTATUS NtCreateProfile (PHANDLE ProfileHandle, HANDLE Process, PVOID RangeBase, SIZE_T RangeSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);\nNTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);\nNTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);\nNTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);\nNTSTATUS NtCreateThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended);\nNTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);\nNTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);\nNTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\nNTSTATUS NtDebugActiveProcess (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtDebugContinue (HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);\nNTSTATUS NtDelayExecution (BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);\n```\n\n----------------------------------------\n\nTITLE: Defining Native Windows Worker Factory and User Process API - C\nDESCRIPTION: This code snippet declares a series of native Windows NT API function prototypes in C. The functions support operations such as setting/querying worker factory information, marking worker readiness, shutting down worker factories, creating threads and user processes, querying license values, mapping modules, and handling multilingual UI operations. All APIs use standard Windows HANDLE types, NTSTATUS returns, and typical parameter conventions. These functions are used for interacting with low-level Windows services and require inclusion of the appropriate Windows headers and correct privileges for calling functions like thread/process creation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp0_x86_prototypes.txt#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtSetInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength);\nNTSTATUS NtQueryInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength, PULONG ReturnLength);\nNTSTATUS NtWorkerFactoryWorkerReady (HANDLE WorkerFactoryHandle);\nNTSTATUS NtShutdownWorkerFactory (HANDLE WorkerFactoryHandle, LONG *PendingWorkerCount);\nNTSTATUS NtCreateThreadEx (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument, ULONG CreateFlags, ULONG_PTR ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, PPS_ATTRIBUTE_LIST AttributeList);\nNTSTATUS NtCreateUserProcess (PHANDLE ProcessHandle, PHANDLE ThreadHandle, ACCESS_MASK ProcessDesiredAccess, ACCESS_MASK ThreadDesiredAccess, POBJECT_ATTRIBUTES ProcessObjectAttributes, POBJECT_ATTRIBUTES ThreadObjectAttributes, ULONG ProcessFlags, ULONG ThreadFlags, PRTL_USER_PROCESS_PARAMETERS ProcessParameters, PPROCESS_CREATE_INFO CreateInfo, PPROCESS_ATTRIBUTE_LIST AttributeList);\nNTSTATUS NtQueryLicenseValue (PUNICODE_STRING Name, PULONG Type, PVOID Buffer, ULONG Length, PULONG ReturnedLength);\nNTSTATUS NtMapCMFModule (ULONG What, ULONG Index, PULONG CacheIndexOut, PULONG CacheFlagsOut, PULONG ViewSizeOut, PVOID *BaseAddress);\nNTSTATUS NtIsUILanguageComitted ();\nNTSTATUS NtFlushInstallUILanguage (LANGID InstallUILanguage, ULONG SetComittedFlag);\nNTSTATUS NtGetMUIRegistryInfo (ULONG Flags, PULONG DataSize, PVOID Data);\n```\n\n----------------------------------------\n\nTITLE: Server Greeting JSON Structure in QMP\nDESCRIPTION: Defines the JSON structure for the server greeting message in QMP. It includes version information and available capabilities.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qmp-spec.txt#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{ \"QMP\": { \"version\": json-object, \"capabilities\": json-array } }\n```\n\n----------------------------------------\n\nTITLE: KVM Information Query Example in QMP\nDESCRIPTION: Demonstrates querying KVM information using QMP, including a transaction ID in the request and response.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qmp-spec.txt#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{ \"execute\": \"query-kvm\", \"id\": \"example\" }\n```\n\nLANGUAGE: json\nCODE:\n```\n{ \"return\": { \"enabled\": true, \"present\": true }, \"id\": \"example\"}\n```\n\n----------------------------------------\n\nTITLE: Invoking the PANDA Loaded Plugin via Command Line - Bash\nDESCRIPTION: This example demonstrates how to run the PANDA platform using the loaded plugin on a Linux virtual machine replay. It requires PANDA to be built with the 'loaded', 'syscalls2', 'osi', and 'osi_linux' plugins. The key parameters used include '-replay' to specify the recorded execution, '-panda loaded' to enable the plugin, and '-os' to define the guest OS. The command outputs to standard output when executable pages are mapped. Inputs are the recorded replay name 'foo' and the target OS specification.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/loaded/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/i386-softmmu/panda-system-i386 -replay foo \\\n    -panda loaded -os linux-32-debian-3.2.81-686-pae\n```\n\n----------------------------------------\n\nTITLE: Running QEMU Passthrough with Certificates Backend and vscclient - Shell\nDESCRIPTION: These commands demonstrate using QEMU passthrough together with a certificates backend (as in the emulated case), with vscclient providing software-backed smartcard functionality by referencing the certificate database. Key parameters include specifying the backend, database path, certificates, and network ports. Inputs are the QEMU host, working directory, and setup certificates; outputs are a VM and vscclient tunnel with certificate-based card emulation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/ccid.txt#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nqemu -chardev socket,server,host=0.0.0.0,port=2001,id=ccid,nowait -usb -device usb-ccid -device ccid-card-passthru,chardev=ccid\n```\n\nLANGUAGE: shell\nCODE:\n```\nvscclient -e \"db=\\\"sql:$PWD\\\" use_hw=no soft=(,Test,CAC,,id-cert,signing-cert,encryption-cert)\" <qemu-host> 2001\n```\n\n----------------------------------------\n\nTITLE: Server Greeting Example in QMP\nDESCRIPTION: Provides an example of a server greeting message in QMP, including version information and an empty capabilities array.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qmp-spec.txt#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{ \"QMP\": { \"version\": { \"qemu\": { \"micro\": 50, \"minor\": 6, \"major\": 1 }, \"package\": \"\"}, \"capabilities\": []}}\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Calls for Resource and Transaction Management in C\nDESCRIPTION: This snippet declares Windows NT system calls for managing resources, transactions, and enlistments. These functions are essential for implementing transactional operations and managing system resources in a Windows environment.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x64_prototypes.txt#_snippet_9\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtRecoverResourceManager (HANDLE ResourceManagerHandle);\nNTSTATUS NtRecoverTransactionManager (HANDLE TransactionManagerHandle);\nNTSTATUS NtRegisterProtocolAddressInformation (HANDLE ResourceManager, PCRM_PROTOCOL_ID ProtocolId, ULONG ProtocolInformationSize, PVOID ProtocolInformation, ULONG CreateOptions);\nNTSTATUS NtRollbackComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRollbackEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRollbackTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\n```\n\n----------------------------------------\n\nTITLE: Declaring NT Native API Function Signatures - Win32 C\nDESCRIPTION: This code snippet declares multiple NTSTATUS-returning functions corresponding to NT system calls in C header style, specifying parameters and types for each system operation. It does not provide implementation, only the interface, and is intended for inclusion in C or C++ programs that interact directly with ntdll.dll functions. Prerequisites include a Windows development environment with access to the appropriate headers (e.g., Windows.h, ntdef.h), and the types (such as HANDLE, PVOID, etc.) must be defined beforehand. No inputs or outputs are present at this stage, but the declarations must match the actual ntdll.dll exported functions for correct linking; function misuse may crash the host application.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp12_x86_prototypes.txt#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n210 NTSTATUS NtProtectVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, WIN32_PROTECTION_MASK NewProtectWin32, PULONG OldProtect);\n211 NTSTATUS NtPulseEvent (HANDLE EventHandle, PLONG PreviousState);\n212 NTSTATUS NtQueryAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);\n213 NTSTATUS NtQueryBootEntryOrder (PULONG Ids, PULONG Count);\n214 NTSTATUS NtQueryBootOptions (PBOOT_OPTIONS BootOptions, PULONG BootOptionsLength);\n215 NTSTATUS NtQueryDebugFilterState (ULONG ComponentId, ULONG Level);\n216 NTSTATUS NtQueryDefaultLocale (BOOLEAN UserProfile, PLCID DefaultLocaleId);\n217 NTSTATUS NtQueryDefaultUILanguage (LANGID *DefaultUILanguageId);\n218 NTSTATUS NtQueryDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);\n219 NTSTATUS NtQueryDirectoryObject (HANDLE DirectoryHandle, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, BOOLEAN RestartScan, PULONG Context, PULONG ReturnLength);\n220 NTSTATUS NtQueryDriverEntryOrder (PULONG Ids, PULONG Count);\n221 NTSTATUS NtQueryEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan);\n222 NTSTATUS NtQueryEvent (HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ReturnLength);\n223 NTSTATUS NtQueryFullAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);\n224 NTSTATUS NtQueryInformationAtom (RTL_ATOM Atom, ATOM_INFORMATION_CLASS InformationClass, PVOID AtomInformation, ULONG AtomInformationLength, PULONG ReturnLength);\n225 NTSTATUS NtQueryInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\n226 NTSTATUS NtQueryInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength, PULONG ReturnLength);\n227 NTSTATUS NtQueryInformationPort (HANDLE PortHandle, PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\n228 NTSTATUS NtQueryInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);\n229 NTSTATUS NtQueryInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);\n230 NTSTATUS NtQueryInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);\n231 NTSTATUS NtQueryInstallUILanguage (LANGID *InstallUILanguageId);\n232 NTSTATUS NtQueryIntervalProfile (KPROFILE_SOURCE ProfileSource, PULONG Interval);\n233 NTSTATUS NtQueryIoCompletion (HANDLE IoCompletionHandle, IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass, PVOID IoCompletionInformation, ULONG IoCompletionInformationLength, PULONG ReturnLength);\n234 NTSTATUS NtQueryKey (HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);\n235 NTSTATUS NtQueryMultipleValueKey (HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength);\n236 NTSTATUS NtQueryMutant (HANDLE MutantHandle, MUTANT_INFORMATION_CLASS MutantInformationClass, PVOID MutantInformation, ULONG MutantInformationLength, PULONG ReturnLength);\n237 NTSTATUS NtQueryObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);\n238 NTSTATUS NtQueryOpenSubKeys (POBJECT_ATTRIBUTES TargetKey, PULONG HandleCount);\n239 NTSTATUS NtQueryOpenSubKeysEx (POBJECT_ATTRIBUTES TargetKey, ULONG BufferLength, PVOID Buffer, PULONG RequiredSize);\n240 NTSTATUS NtQueryPerformanceCounter (PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);\n241 NTSTATUS NtQueryQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID SidList, ULONG SidListLength, PULONG StartSid, BOOLEAN RestartScan);\n242 NTSTATUS NtQuerySection (HANDLE SectionHandle, SECTION_INFORMATION_CLASS SectionInformationClass, PVOID SectionInformation, SIZE_T SectionInformationLength, PSIZE_T ReturnLength);\n243 NTSTATUS NtQuerySecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Length, PULONG LengthNeeded);\n244 NTSTATUS NtQuerySemaphore (HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG SemaphoreInformationLength, PULONG ReturnLength);\n245 NTSTATUS NtQuerySymbolicLinkObject (HANDLE LinkHandle, PUNICODE_STRING LinkTarget, PULONG ReturnedLength);\n246 NTSTATUS NtQuerySystemEnvironmentValue (PUNICODE_STRING VariableName, PWSTR VariableValue, USHORT ValueLength, PUSHORT ReturnLength);\n247 NTSTATUS NtQuerySystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, PULONG ValueLength, PULONG Attributes);\n248 NTSTATUS NtQuerySystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\n249 NTSTATUS NtQuerySystemTime (PLARGE_INTEGER SystemTime);\n250 NTSTATUS NtQueryTimer (HANDLE TimerHandle, TIMER_INFORMATION_CLASS TimerInformationClass, PVOID TimerInformation, ULONG TimerInformationLength, PULONG ReturnLength);\n251 NTSTATUS NtQueryTimerResolution (PULONG MaximumTime, PULONG MinimumTime, PULONG CurrentTime);\n252 NTSTATUS NtQueryValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);\n253 NTSTATUS NtQueryVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);\n254 NTSTATUS NtQueryVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\n255 NTSTATUS NtQueueApcThread (HANDLE ThreadHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\n256 NTSTATUS NtRaiseException (PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ContextRecord, BOOLEAN FirstChance);\n257 NTSTATUS NtRaiseHardError (NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask, PULONG_PTR Parameters, ULONG ValidResponseOptions, PULONG Response);\n258 NTSTATUS NtReadFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n259 NTSTATUS NtReadFileScatter (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\n260 NTSTATUS NtReadRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\n261 NTSTATUS NtReadVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\n262 NTSTATUS NtRegisterThreadTerminatePort (HANDLE PortHandle);\n263 NTSTATUS NtReleaseMutant (HANDLE MutantHandle, PLONG PreviousCount);\n264 NTSTATUS NtReleaseSemaphore (HANDLE SemaphoreHandle, LONG ReleaseCount, PLONG PreviousCount);\n265 NTSTATUS NtRemoveIoCompletion (HANDLE IoCompletionHandle, PVOID *KeyContext, PVOID *ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER Timeout);\n266 NTSTATUS NtRemoveProcessDebug (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\n267 NTSTATUS NtRenameKey (HANDLE KeyHandle, PUNICODE_STRING NewName);\n268 NTSTATUS NtReplaceKey (POBJECT_ATTRIBUTES NewFile, HANDLE TargetHandle, POBJECT_ATTRIBUTES OldFile);\n269 NTSTATUS NtReplacePartitionUnit (PUNICODE_STRING TargetInstancePath, PUNICODE_STRING SpareInstancePath, ULONG Flags);\n270 NTSTATUS NtReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\n271 NTSTATUS NtReplyWaitReceivePort (HANDLE PortHandle, PVOID *PortContext , PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage);\n272 NTSTATUS NtReplyWaitReceivePortEx (HANDLE PortHandle, PVOID *PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage, PLARGE_INTEGER Timeout);\n273 NTSTATUS NtReplyWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\n275 NTSTATUS NtRequestPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage);\n276 NTSTATUS NtRequestWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage, PPORT_MESSAGE ReplyMessage);\n278 NTSTATUS NtResetEvent (HANDLE EventHandle, PLONG PreviousState);\n279 NTSTATUS NtResetWriteWatch (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T RegionSize);\n280 NTSTATUS NtRestoreKey (HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags);\n281 NTSTATUS NtResumeProcess (HANDLE ProcessHandle);\n282 NTSTATUS NtResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\n283 NTSTATUS NtSaveKey (HANDLE KeyHandle, HANDLE FileHandle);\n284 NTSTATUS NtSaveKeyEx (HANDLE KeyHandle, HANDLE FileHandle, ULONG Format);\n285 NTSTATUS NtSaveMergedKeys (HANDLE HighPrecedenceKeyHandle, HANDLE LowPrecedenceKeyHandle, HANDLE FileHandle);\n```\n\n----------------------------------------\n\nTITLE: Defining Error Injection Rule in blkdebug Configuration - INI - ini\nDESCRIPTION: This snippet demonstrates an INI-style configuration file for blkdebug that injects an ENOSPC (errno 28) error for all asynchronous read requests. The file contains a section representing a rule with attributes such as the event type and the corresponding error number to inject. This configuration file should be supplied as a parameter to QEMU's blkdebug device. Prerequisites include the blkdebug driver and valid errno according to the host system.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/blkdebug.txt#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[inject-error]\nevent = \"read_aio\"\nerrno = \"28\"\n\n```\n\n----------------------------------------\n\nTITLE: Deferring Object Destruction with call_rcu in C\nDESCRIPTION: This code defines a foo_unref function that uses atomic reference counting, invoking call_rcu to schedule the foo_destroy call when the last reference is dropped. It depends on atomic_fetch_dec and call_rcu. The input parameter is a pointer with a refcount field. The function ensures deletion happens only when the last reference is released, avoiding premature deallocation during ongoing RCU read-side critical sections.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/rcu.txt#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\n foo_unref(struct foo *p) {\n    if (atomic_fetch_dec(&p->refcount) == 1) {\n        call_rcu(foo_destroy, p, rcu);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining RCU with Real Reference Counting in C\nDESCRIPTION: This snippet extends the RCU idiom by incrementing a reference count under RCU read-side protection, allowing the object to stay valid beyond the critical section. It requires the functions rcu_read_lock, atomic_rcu_read, foo_ref, rcu_read_unlock, and foo_unref. The input is the shared pointer 'foo'; outputs are a retained reference 'p' and correct decrementing of its reference count. Reference management must ensure that the object is not prematurely reclaimed.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/rcu.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nrcu_read_lock();\np = atomic_rcu_read(&foo);\nfoo_ref(p);\nrcu_read_unlock();\n/* do something with p. */\nfoo_unref(p);\n```\n\n----------------------------------------\n\nTITLE: Defining VhostUserMsg Structure in C\nDESCRIPTION: C structure representing the vhost-user message format with union for different payload types. This structure implements the message specification with fields for request type, flags, size and various payload types.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/vhost-user.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\ntypedef struct VhostUserMsg {\n    VhostUserRequest request;\n    uint32_t flags;\n    uint32_t size;\n    union {\n        uint64_t u64;\n        struct vhost_vring_state state;\n        struct vhost_vring_addr addr;\n        VhostUserMemory memory;\n        VhostUserLog log;\n        struct vhost_iotlb_msg iotlb;\n        VhostUserConfig config;\n    };\n} QEMU_PACKED VhostUserMsg;\n```\n\n----------------------------------------\n\nTITLE: Calculating Cluster Refcount in QCOW2 Image Format\nDESCRIPTION: This code snippet demonstrates how to calculate the refcount of a cluster given an offset into the QCOW2 image file. It shows the process of navigating the two-level refcount table structure to find the appropriate refcount block and entry.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/qcow2.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nrefcount_block_entries = (cluster_size * 8 / refcount_bits)\n\nrefcount_block_index = (offset / cluster_size) % refcount_block_entries\nrefcount_table_index = (offset / cluster_size) / refcount_block_entries\n\nrefcount_block = load_cluster(refcount_table[refcount_table_index]);\nreturn refcount_block[refcount_block_index];\n```\n\n----------------------------------------\n\nTITLE: Guest PCI Device and Seat Detection - Bash\nDESCRIPTION: These are command-line checks used within the guest Linux system to verify PCI bridge and device layout, and to list available seats recognized by systemd. Dependencies: tools like lspci, loginctl, and root privileges. Input: none, commands typed interactively. Output: hardware device and seat status, as verified in the sample output. These are mainly diagnostic and verification steps during configuration.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/multiseat.txt#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n[root@fedora ~]# lspci -vt\n-[0000:00]-+-00.0  Intel Corporation 440FX - 82441FX PMC [Natoma]\n           [ ... ]\n           \\-12.0-[01]--+-02.0  Device 1234:1111\n                        \\-0f.0  NEC Corporation USB 3.0 Host Controller\n```\n\nLANGUAGE: bash\nCODE:\n```\n[root@fedora ~]# loginctl list-seats\nSEAT\nseat0\nseat-pci-pci-0000_00_12_0\n\n2 seats listed.\n```\n\nLANGUAGE: bash\nCODE:\n```\nloginctl seat-status seat-pci-pci-0000_00_12_0\n```\n\n----------------------------------------\n\nTITLE: PANDA Trace Plugin Usage Command\nDESCRIPTION: Command example showing how to run PANDA with the trace plugin to generate a log file from a replay.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/trace/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n-replay my_replay -panda trace:log=log.txt\n```\n\n----------------------------------------\n\nTITLE: Declaring a PyPlugin Class for PANDA - Python\nDESCRIPTION: Demonstrates the declaration of a custom PyPlugin class for use with PANDA via the snake_hook plugin. Shows the usage of argument retrieval methods 'get_arg' and 'get_arg_bool' within the class initializer, enabling dynamic configuration from command-line arguments passed through the snake_hook interface. This snippet depends on the PyPlugin base class provided by PyPANDA and expects to be invoked via the PANDA command with appropriate files and arguments. Parameters such as 'path' and 'should_print_hello' are retrieved from the command line, with outputs printed accordingly. This usage scenario strictly requires the PANDA target to be loaded with the snake_hook plugin and the Python file to be available at load time.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/snake_hook/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass TestPlugin(PyPlugin):\n    def __init__(self, panda):\n        path = self.get_arg('path')\n        print(f\"path = {path}\")\n        should_print_hello = self.get_arg_bool('should_print_hello')\n        if should_print_hello:\n            print(\"Hello!\")\n```\n\n----------------------------------------\n\nTITLE: Expressing Dynamic Slicing Algorithm in Python Pseudocode\nDESCRIPTION: This Python pseudocode describes a simplified dynamic slicing algorithm that works backwards over an execution trace. It initializes a working set to track variables of interest on assignment, iterates in reverse over the instruction list, and updates the working set based on variables used/defined by each instruction. The code expects helper functions like defines(insn) and uses(insn) to provide variable sets; full functionality requires dynamic code information for memory access instructions. Input is an execution trace and a starting set of slice criterion variables, while output is a set of marked/relevant instructions. The code is conceptual and is not executable without concrete definitions for trace/model objects.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/dynslice.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# initialize a working set containing the data whose computation we\n# want to understand\nwork = { initial slice variables }\n\n# walk backward through the trace\nfor insn in reversed(trace):\n    if work âˆ© defines(insn) != âˆ…:\n        mark(insn)\n        work = work âˆ– defines(insn)\n        work = work âˆª uses(insn)\n```\n\n----------------------------------------\n\nTITLE: Launching QEMU with blkdebug Configuration - QEMU CLI - bash\nDESCRIPTION: This shell command demonstrates how to launch a QEMU virtual machine with a blkdebug block device configured via a user-supplied configuration file. It shows connecting the blkdebug engine, an error injection config file, and a test image to the block subsystem, and attaches a virtio-blk-pci device to utilize the injected errors. Required dependencies are qemu-system-x86_64 and access to correctly formatted blkdebug configuration and disk image files.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/blkdebug.txt#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ qemu-system-x86_64\n      -drive if=none,cache=none,file=blkdebug:blkdebug.conf:test.img,id=drive0 \\\n      -device virtio-blk-pci,drive=drive0,id=virtio-blk-pci0\n\n```\n\n----------------------------------------\n\nTITLE: Not Implemented System Call Declarations in C\nDESCRIPTION: Function declarations for Linux system calls that are not implemented in this system. These placeholders return an error code indicating the functionality is not available.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_25\n\nLANGUAGE: C\nCODE:\n```\nlong sys_ni_syscall(void);\n```\n\n----------------------------------------\n\nTITLE: Windows NT Native API Function Declarations in C\nDESCRIPTION: A collection of Windows NT Native API function declarations including process, memory, security, and IPC operations. These are low-level system calls that provide direct access to kernel functionality in Windows operating systems.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x86_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAcceptConnectPort (PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView);\nNTSTATUS NtAccessCheck (PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheckByType (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByTypeAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheckByTypeResultList (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarmByHandle (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAddAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\nNTSTATUS NtAddBootEntry (PBOOT_ENTRY BootEntry, PULONG Id);\nNTSTATUS NtAddDriverEntry (PEFI_DRIVER_ENTRY DriverEntry, PULONG Id);\nNTSTATUS NtAdjustGroupsToken (HANDLE TokenHandle, BOOLEAN ResetToDefault, PTOKEN_GROUPS NewState, ULONG BufferLength, PTOKEN_GROUPS PreviousState, PULONG ReturnLength);\nNTSTATUS NtAdjustPrivilegesToken (HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);\nNTSTATUS NtAlertResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtAlertThread (HANDLE ThreadHandle);\nNTSTATUS NtAllocateLocallyUniqueId (PLUID Luid);\nNTSTATUS NtAllocateReserveObject (PHANDLE MemoryReserveHandle, POBJECT_ATTRIBUTES ObjectAttributes, MEMORY_RESERVE_TYPE Type);\nNTSTATUS NtAllocateUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtAllocateUuids (PULARGE_INTEGER Time, PULONG Range, PULONG Sequence, PCHAR Seed);\nNTSTATUS NtAllocateVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);\nNTSTATUS NtAlpcAcceptConnectPort (PHANDLE PortHandle, HANDLE ConnectionPortHandle, ULONG Flags, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes, BOOLEAN AcceptConnection);\nNTSTATUS NtAlpcCancelMessage (HANDLE PortHandle, ULONG Flags, PALPC_CONTEXT_ATTR MessageContext);\nNTSTATUS NtAlpcConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, ULONG Flags, PSID RequiredServerSid, PPORT_MESSAGE ConnectionMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes, PALPC_MESSAGE_ATTRIBUTES InMessageAttributes, PLARGE_INTEGER Timeout);\nNTSTATUS NtAlpcCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes);\nNTSTATUS NtAlpcCreatePortSection (HANDLE PortHandle, ULONG Flags, HANDLE SectionHandle, SIZE_T SectionSize, PALPC_HANDLE AlpcSectionHandle, PSIZE_T ActualSectionSize);\nNTSTATUS NtAlpcCreateResourceReserve (HANDLE PortHandle, ULONG Flags, SIZE_T MessageSize, PALPC_HANDLE ResourceId);\nNTSTATUS NtAlpcCreateSectionView (HANDLE PortHandle, ULONG Flags, PALPC_DATA_VIEW_ATTR ViewAttributes);\nNTSTATUS NtAlpcCreateSecurityContext (HANDLE PortHandle, ULONG Flags, PALPC_SECURITY_ATTR SecurityAttribute);\nNTSTATUS NtAlpcDeletePortSection (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE SectionHandle);\nNTSTATUS NtAlpcDeleteResourceReserve (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ResourceId);\nNTSTATUS NtAlpcDeleteSectionView (HANDLE PortHandle, ULONG Flags, PVOID ViewBase);\nNTSTATUS NtAlpcDeleteSecurityContext (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);\nNTSTATUS NtAlpcDisconnectPort (HANDLE PortHandle, ULONG Flags);\nNTSTATUS NtAlpcImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE PortMessage, PVOID Reserved);\nNTSTATUS NtAlpcOpenSenderProcess (PHANDLE ProcessHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtAlpcOpenSenderThread (PHANDLE ThreadHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtAlpcQueryInformation (HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtAlpcQueryInformationMessage (HANDLE PortHandle, PPORT_MESSAGE PortMessage, ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass, PVOID MessageInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtAlpcRevokeSecurityContext (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);\nNTSTATUS NtAlpcSendWaitReceivePort (HANDLE PortHandle, ULONG Flags, PPORT_MESSAGE SendMessage, PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes, PPORT_MESSAGE ReceiveMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes, PLARGE_INTEGER Timeout);\nNTSTATUS NtAlpcSetInformation (HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length);\nNTSTATUS NtApphelpCacheControl (APPHELPCOMMAND type, PVOID buf);\nNTSTATUS NtAreMappedFilesTheSame (PVOID File1MappedAsAnImage, PVOID File2MappedAsFile);\nNTSTATUS NtAssignProcessToJobObject (HANDLE JobHandle, HANDLE ProcessHandle);\nNTSTATUS NtCallbackReturn (PVOID OutputBuffer, ULONG OutputLength, NTSTATUS Status);\nNTSTATUS NtCancelIoFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtCancelIoFileEx (HANDLE FileHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtCancelSynchronousIoFile (HANDLE ThreadHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtCancelTimer (HANDLE TimerHandle, PBOOLEAN CurrentState);\nNTSTATUS NtClearEvent (HANDLE EventHandle);\nNTSTATUS NtClose (HANDLE Handle);\nNTSTATUS NtCloseObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\nNTSTATUS NtCommitComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCommitEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtCommitTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\nNTSTATUS NtCompactKeys (ULONG Count, HANDLE KeyArray[]);\nNTSTATUS NtCompareTokens (HANDLE FirstTokenHandle, HANDLE SecondTokenHandle, PBOOLEAN Equal);\nNTSTATUS NtCompleteConnectPort (HANDLE PortHandle);\nNTSTATUS NtCompressKey (HANDLE Key);\nNTSTATUS NtConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\nNTSTATUS NtContinue (PCONTEXT ContextRecord, BOOLEAN TestAlert);\nNTSTATUS NtCreateDebugObject (PHANDLE DebugObjectHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\nNTSTATUS NtCreateDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtCreateEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, HANDLE TransactionHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, NOTIFICATION_MASK NotificationMask, PVOID EnlistmentKey);\nNTSTATUS NtCreateEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);\nNTSTATUS NtCreateEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\n----------------------------------------\n\nTITLE: Logging PANDA QEMU Replay With Disassembly Output - Bash\nDESCRIPTION: This example shell command demonstrates how to launch a PANDA replay run with QEMU and enable output of disassembly and instruction trace to a file. The command line specifies the binary, replay file, disassembly options with -d flags, and redirects both stdout and stderr to an output file. It assumes PANDA and the appropriate QEMU binary are installed and the environment variable $PANDA_PATH is set. This is crucial for correlating reported program counters (pc) and entrypoint addresses with actual assembly code.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/func_stats/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/qemu-system-x86_64 -replay foo -d in_asm,op,int,rr > asm.out 2>&113.\n```\n\n----------------------------------------\n\nTITLE: Reporting Function Call Statistics - JSON Structure Example - JSON\nDESCRIPTION: This snippet shows a sample output record from the func_stats plugin, logged as a single line JSON object per function call. The record contains fields describing the calling context, stack traces, instruction counts (both architectural and lifted via LLVM), data buffer statistics, and information about memory reads and writes. This output requires using PANDA's func_stats plugin and produces fields such as asid, caller, entrypoint, stack traces, instruction counts, and entropy metrics, with addresses commonly in hex format when hex=true is set. The output is suitable for further analysis and visualization, and can be parsed programmatically.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/func_stats/README.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\\\"asid\\\":\\\"8ca0000\\\",\\\"caller\\\":\\\"b7eb3364\\\",\\\"callstack\\\":[\\\"b7fe388f\\\",\\\"b7ff1029\\\",\\\"b7ff0f0c\\\",\\\"b7eb3364\\\"],\\\"distinct_blocks\\\":1,\\\"entrypoint\\\":\\\"b7eb3364\\\",\\\"functionstack\\\":[\\\"b7ff0fb0\\\",\\\"b7ff0e90\\\",\\\"b7eb3358\\\",\\\"b7eb3364\\\"],\\\"insn_arith\\\":1,\\\"insn_movs\\\":1,\\\"insn_total\\\":5,\\\"instr_count\\\":120206427,\\\"llvm_bb\\\":3,\\\"llvm_fn\\\":1,\\\"llvm_insn_alloc\\\":1,\\\"llvm_insn_arit\\\":17,\\\"llvm_insn_call\\\":3,\\\"llvm_insn_intrinsic\\\":0,\\\"llvm_insn_load\\\":5,\\\"llvm_insn_store\\\":20,\\\"llvm_insn_tot\\\":23,\\\"llvm_modules\\\":0,\\\"maxexecs\\\":1,\\\"maxexecs_addr\\\":\\\"b7eb3358\\\",\\\"nreads\\\":0,\\\"nwrites\\\":0,\\\"pc\\\":\\\"b7eb335f\\\",\\\"reads\\\":[],\\\"sumexecs\\\":1,\\\"writes\\\":[]}\n```\n\n----------------------------------------\n\nTITLE: Defining PCI Test Device Header Struct in C\nDESCRIPTION: This typedef defines the PCITestDevHdr struct, which models the layout of a PCI test device BAR header. Fields are annotated with expected usage (write-only, read-only), data width, and purpose. Dependencies include the presence of stdint.h for fixed-width data types. The struct organizes test control, access properties, offsets, data registers, a write count for debugging, and a null-terminated name string. All fields are little-endian, and correct alignment/packing is assumed for hardware compatibility. Limitations: structure assumes a specific hardware register layout, and correct field ordering must be preserved.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/pci-testdev.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\ntypedef struct PCITestDevHdr {\n    uint8_t test;  <- write-only, starts a given test number\n    uint8_t width_type; <- read-only, type and width of access for a given test.\n                           1,2,4 for byte,word or long write.\n                           any other value if test not supported on this BAR\n    uint8_t pad0[2];\n    uint32_t offset; <- read-only, offset in this BAR for a given test\n    uint32_t data;    <- read-only, data to use for a given test\n    uint32_t count;  <- for debugging. number of writes detected.\n    uint8_t name[]; <- for debugging. 0-terminated ASCII string.\n} PCITestDevHdr;\n```\n\n----------------------------------------\n\nTITLE: Defining Vhost-User Protocol Feature Flags in C\nDESCRIPTION: Declares a set of #define constants representing protocol feature flags used by the Vhost-User protocol. Each flag is given an integer identifier allowing conditional compilation or runtime checks for protocol capabilities. No external dependencies are required beyond a standard C preprocessor. These flags are typically used when negotiating or checking for protocol support in host and guest components.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/vhost-user.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#define VHOST_USER_PROTOCOL_F_MQ             0\\n#define VHOST_USER_PROTOCOL_F_LOG_SHMFD      1\\n#define VHOST_USER_PROTOCOL_F_RARP           2\\n#define VHOST_USER_PROTOCOL_F_REPLY_ACK      3\\n#define VHOST_USER_PROTOCOL_F_MTU            4\\n#define VHOST_USER_PROTOCOL_F_SLAVE_REQ      5\\n#define VHOST_USER_PROTOCOL_F_CROSS_ENDIAN   6\\n\n```\n\n----------------------------------------\n\nTITLE: Analyzing Callstack Filtering with zgrep - Unix Shell\nDESCRIPTION: Demonstrates how to use the 'zgrep' tool to count occurrences of specific call stack patterns in a gzipped memory trace file output by PANDA. This approach helps determine the minimal calling context needed to isolate exactly the SSL/TLS master key writes. No extra dependencies are needed beyond Unix tools and the compressed trace file; key parameters include the target call stack sequence and file path. Outputs the count of matching lines, used to fine-tune key extraction logic.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/panda_ssltut.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ zgrep -c \"00000000b7e82bad 00000000b7d3cb16\" write_tap_buffers.txt.gz\n504\n$ zgrep -c \"00000000b7fa72aa 00000000b7e82bad 00000000b7d3cb16\" write_tap_buffers.txt.gz\n192\n$ zgrep -c \"00000000b7fa8aab 00000000b7fa72aa 00000000b7e82bad 00000000b7d3cb16\" write_tap_buffers.txt.gz\n24\n```\n\n----------------------------------------\n\nTITLE: Executing qemu-io Read Operations for Disk Sector Verification (Shell)\nDESCRIPTION: Demonstrates the use of qemu-io to perform a verbose read of the first 512 bytes from a raw disk image. The command allows inspection of sector contents by outputting hexadecimal and ASCII representations. No external dependencies aside from qemu-io itself are needed. This command reads data at offset 0 for 512 bytes; outputs are for manual inspection and verification.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/blkverify.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ ./qemu-io -c 'read -v 0 512' raw.img\n```\n\n----------------------------------------\n\nTITLE: Inspecting Guest Memory Mapping in Host with GDB - GDB Commands\nDESCRIPTION: These GDB commands are used to track the mapping of a guest's physical address in the host memory. 'memory_region_find' locates the memory region for a given guest physical address (GUEST_PHYS_ADDR), and then prints the region's name, host pointer, and offset within the region. The 'p/10x' command is used to dump the actual host memory corresponding to the guest's RAM. The commands require the PANDA/QEMU binary and appropriate debugging symbols for introspection.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/src/rr/README.md#_snippet_2\n\nLANGUAGE: gdb\nCODE:\n```\np memory_region_find(get_system_memory(), GUEST_PHYS_ADDR, 0).mr->name\n```\n\nLANGUAGE: gdb\nCODE:\n```\np/x memory_region_find(get_system_memory(), GUEST_PHYS_ADDR, 0).mr->ram_block.host\n```\n\nLANGUAGE: gdb\nCODE:\n```\np/x memory_region_find(get_system_memory(), GUEST_PHYS_ADDR, 0).offset_within_region\n```\n\nLANGUAGE: gdb\nCODE:\n```\np/10x [ram_block.host] + [offset_within_region]\n```\n\n----------------------------------------\n\nTITLE: Initializing PANDA in Python\nDESCRIPTION: Basic code example showing how to import and initialize PANDA with an i386 architecture. This is the minimal setup required to start using PANDA's features through Python.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/core/README.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pandare import Panda\npanda = Panda(generic='i386')\n...\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows Native API Nt* Function Prototypes in C\nDESCRIPTION: This code snippet provides C function declarations for a broad set of Windows Native API (Nt*) system calls. Each prototype defines the function signature, parameter names, and types necessary for system-level operations in the Windows kernel. No function bodies are present; these declarations are typically placed in a header to enable linking against the Windows kernel's native API. Prerequisites include the definitions of types such as HANDLE, NTSTATUS, PUNICODE_STRING, as well as inclusion of relevant system and header files. Inputs and outputs (parameters and return values) are specific to each NT function and correspond to actions like querying objects, changing registry values, managing security descriptors, and more. The code is intended as an interface specification and cannot be run standalone.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp0_x64_prototypes.txt#_snippet_10\n\nLANGUAGE: C\nCODE:\n```\n285 NTSTATUS NtQueryIoCompletion (HANDLE IoCompletionHandle, IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass, PVOID IoCompletionInformation, ULONG IoCompletionInformationLength, PULONG ReturnLength);\n286 NTSTATUS NtQueryLicenseValue (PUNICODE_STRING Name, PULONG Type, PVOID Buffer, ULONG Length, PULONG ReturnedLength);\n287 NTSTATUS NtQueryMultipleValueKey (HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength);\n288 NTSTATUS NtQueryMutant (HANDLE MutantHandle, MUTANT_INFORMATION_CLASS MutantInformationClass, PVOID MutantInformation, ULONG MutantInformationLength, PULONG ReturnLength);\n289 NTSTATUS NtQueryOpenSubKeys (POBJECT_ATTRIBUTES TargetKey, PULONG HandleCount);\n290 NTSTATUS NtQueryOpenSubKeysEx (POBJECT_ATTRIBUTES TargetKey, ULONG BufferLength, PVOID Buffer, PULONG RequiredSize);\n291 NTSTATUS NtQueryPortInformationProcess ();\n292 NTSTATUS NtQueryQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID SidList, ULONG SidListLength, PULONG StartSid, BOOLEAN RestartScan);\n293 NTSTATUS NtQuerySecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Length, PULONG LengthNeeded);\n294 NTSTATUS NtQuerySemaphore (HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG SemaphoreInformationLength, PULONG ReturnLength);\n295 NTSTATUS NtQuerySymbolicLinkObject (HANDLE LinkHandle, PUNICODE_STRING LinkTarget, PULONG ReturnedLength);\n296 NTSTATUS NtQuerySystemEnvironmentValue (PUNICODE_STRING VariableName, PWSTR VariableValue, USHORT ValueLength, PUSHORT ReturnLength);\n297 NTSTATUS NtQuerySystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, PULONG ValueLength, PULONG Attributes);\n298 NTSTATUS NtQueryTimerResolution (PULONG MaximumTime, PULONG MinimumTime, PULONG CurrentTime);\n299 NTSTATUS NtRaiseException (PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ContextRecord, BOOLEAN FirstChance);\n300 NTSTATUS NtRaiseHardError (NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask, PULONG_PTR Parameters, ULONG ValidResponseOptions, PULONG Response);\n301 NTSTATUS NtReadOnlyEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\n302 NTSTATUS NtRecoverEnlistment (HANDLE EnlistmentHandle, PVOID EnlistmentKey);\n303 NTSTATUS NtRecoverResourceManager (HANDLE ResourceManagerHandle);\n304 NTSTATUS NtRecoverTransactionManager (HANDLE TransactionManagerHandle);\n305 NTSTATUS NtRegisterProtocolAddressInformation (HANDLE ResourceManager, PCRM_PROTOCOL_ID ProtocolId, ULONG ProtocolInformationSize, PVOID ProtocolInformation, ULONG CreateOptions);\n306 NTSTATUS NtRegisterThreadTerminatePort (HANDLE PortHandle);\n308 NTSTATUS NtReleaseKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n309 NTSTATUS NtReleaseWorkerFactoryWorker (HANDLE WorkerFactoryHandle);\n310 NTSTATUS NtRemoveIoCompletionEx (HANDLE IoCompletionHandle, PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation, ULONG Count, PULONG NumEntriesRemoved, PLARGE_INTEGER Timeout, BOOLEAN Alertable);\n311 NTSTATUS NtRemoveProcessDebug (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\n312 NTSTATUS NtRenameKey (HANDLE KeyHandle, PUNICODE_STRING NewName);\n313 NTSTATUS NtReplaceKey (POBJECT_ATTRIBUTES NewFile, HANDLE TargetHandle, POBJECT_ATTRIBUTES OldFile);\n314 NTSTATUS NtReplyWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\n316 NTSTATUS NtRequestPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage);\n318 NTSTATUS NtResetEvent (HANDLE EventHandle, PLONG PreviousState);\n319 NTSTATUS NtResetWriteWatch (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T RegionSize);\n320 NTSTATUS NtRestoreKey (HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags);\n321 NTSTATUS NtResumeProcess (HANDLE ProcessHandle);\n322 NTSTATUS NtRollbackComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\n323 NTSTATUS NtRollbackEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\n325 NTSTATUS NtRollbackTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\n326 NTSTATUS NtRollforwardTransactionManager (HANDLE TransactionManagerHandle, PLARGE_INTEGER TmVirtualClock);\n327 NTSTATUS NtSaveKey (HANDLE KeyHandle, HANDLE FileHandle);\n328 NTSTATUS NtSaveKeyEx (HANDLE KeyHandle, HANDLE FileHandle, ULONG Format);\n329 NTSTATUS NtSaveMergedKeys (HANDLE HighPrecedenceKeyHandle, HANDLE LowPrecedenceKeyHandle, HANDLE FileHandle);\n332 NTSTATUS NtSecureConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PSID RequiredServerSid, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\n333 NTSTATUS NtSetBootEntryOrder (PULONG Ids, ULONG Count);\n334 NTSTATUS NtSetBootOptions (PBOOT_OPTIONS BootOptions, ULONG FieldsToChange);\n335 NTSTATUS NtSetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\n336 NTSTATUS NtSetDebugFilterState (ULONG ComponentId, ULONG Level, BOOLEAN State);\n337 NTSTATUS NtSetDefaultHardErrorPort (HANDLE DefaultHardErrorPort);\n338 NTSTATUS NtSetDefaultLocale (BOOLEAN UserProfile, LCID DefaultLocaleId);\n339 NTSTATUS NtSetDefaultUILanguage (LANGID DefaultUILanguageId);\n340 NTSTATUS NtSetDriverEntryOrder (PULONG Ids, ULONG Count);\n341 NTSTATUS NtSetEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\n342 NTSTATUS NtSetHighEventPair (HANDLE EventPairHandle);\n343 NTSTATUS NtSetHighWaitLowEventPair (HANDLE EventPairHandle);\n344 NTSTATUS NtSetInformationDebugObject (HANDLE DebugObjectHandle, DEBUGOBJECTINFOCLASS DebugObjectInformationClass, PVOID DebugInformation, ULONG DebugInformationLength, PULONG ReturnLength);\n345 NTSTATUS NtSetInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength);\n346 NTSTATUS NtSetInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength);\n347 NTSTATUS NtSetInformationKey (HANDLE KeyHandle, KEY_SET_INFORMATION_CLASS KeySetInformationClass, PVOID KeySetInformation, ULONG KeySetInformationLength);\n348 NTSTATUS NtSetInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength);\n349 NTSTATUS NtSetInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength);\n350 NTSTATUS NtSetInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength);\n351 NTSTATUS NtSetInformationTransactionManager (HANDLE TmHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength);\n352 NTSTATUS NtSetInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength);\n353 NTSTATUS NtSetIntervalProfile (ULONG Interval, KPROFILE_SOURCE Source);\n354 NTSTATUS NtSetIoCompletion (HANDLE IoCompletionHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);\n355 NTSTATUS NtSetLdtEntries (ULONG Selector0, ULONG Entry0Low, ULONG Entry0Hi, ULONG Selector1, ULONG Entry1Low, ULONG Entry1Hi);\n356 NTSTATUS NtSetLowEventPair (HANDLE EventPairHandle);\n357 NTSTATUS NtSetLowWaitHighEventPair (HANDLE EventPairHandle);\n358 NTSTATUS NtSetQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\n359 NTSTATUS NtSetSecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);\n360 NTSTATUS NtSetSystemEnvironmentValue (PUNICODE_STRING VariableName, PUNICODE_STRING VariableValue);\n361 NTSTATUS NtSetSystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, ULONG ValueLength, ULONG Attributes);\n362 NTSTATUS NtSetSystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);\n363 NTSTATUS NtSetSystemPowerState (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags);\n364 NTSTATUS NtSetSystemTime (PLARGE_INTEGER SystemTime, PLARGE_INTEGER PreviousTime);\n365 NTSTATUS NtSetThreadExecutionState (EXECUTION_STATE esFlags, PEXECUTION_STATE PreviousFlags);\n366 NTSTATUS NtSetTimerResolution (ULONG DesiredTime, BOOLEAN SetResolution, PULONG ActualTime);\n367 NTSTATUS NtSetUuidSeed (PCHAR Seed);\n368 NTSTATUS NtSetVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\n369 NTSTATUS NtShutdownSystem (SHUTDOWN_ACTION Action);\n370 NTSTATUS NtShutdownWorkerFactory (HANDLE WorkerFactoryHandle, LONG *PendingWorkerCount);\n371 NTSTATUS NtSignalAndWaitForSingleObject (HANDLE SignalHandle, HANDLE WaitHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\n372 NTSTATUS NtSinglePhaseReject (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\n373 NTSTATUS NtStartProfile (HANDLE ProfileHandle);\n375 NTSTATUS NtStopProfile (HANDLE ProfileHandle);\n376 NTSTATUS NtSuspendProcess (HANDLE ProcessHandle);\n377 NTSTATUS NtSuspendThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\n378 NTSTATUS NtSystemDebugControl (SYSDBG_COMMAND Command, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, PULONG ReturnLength);\n379 NTSTATUS NtTerminateJobObject (HANDLE JobHandle, NTSTATUS ExitStatus);\n\n```\n\n----------------------------------------\n\nTITLE: Running PANDROID with runandroid.py - Python Script - Python\nDESCRIPTION: The runandroid.py script is provided to simplify running PANDROID with Android/ARM QCOW images. The script is invoked from the /scripts directory, requiring the directory containing the four QCOW image files and the API version number as main arguments. Additional script options are available and can be listed using the -h flag. Any further arguments are forwarded directly to the PANDA emulator. Limitations include the assumption that all relevant QCOW files are in the specified directory, and that users have pre-generated these images correctly.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/Android.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example usage: Run Android with PANDA using runandroid.py wrapper\n# Located in /scripts directory\npython3 runandroid.py /androidstuff 19 -h\n```\n\n----------------------------------------\n\nTITLE: Running Memory String Search with PANDA Plugins - Bash\nDESCRIPTION: Executes a PANDA QEMU guest replay with two plugins: 'callstack_instr' and 'stringsearch'. These analyze memory accesses during replay and search for the specified strings, producing both console output and match metadata files. User must prepare the replay logs, edit 'search_strings.txt', and supply appropriate plugin arguments. Intermediate and result files are created in the invocation directory.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/UAF.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npanda/qemu/x86_64-softmmu/panda-system-x86_64 -m 1024 -replay cve-2011-1255-crash \\\n    -display none -panda 'callstack_instr;stringsearch'\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building PANDA - Shell\nDESCRIPTION: This snippet instructs to edit the build.sh script to exclude LLVM-related build steps and then execute build.sh inside the panda/qemu directory. The steps help customize PANDA's QEMU build for this tutorial, avoiding unnecessary dependencies on LLVM. The expected input is manual editing of build.sh; output is the compiled PANDA QEMU binaries. Dependencies are a working shell environment and prerequisite system packages for building QEMU.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/Starcraft.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncd panda/qemu\n```\n\nLANGUAGE: shell\nCODE:\n```\n# Edit build.sh to remove lines about LLVM\n# (manual step; exact lines not specified in snippet)\n```\n\nLANGUAGE: shell\nCODE:\n```\n./build.sh\n```\n\n----------------------------------------\n\nTITLE: Flow Table ID 40: Multicast Routing Table Structure - Technical Table - plaintext\nDESCRIPTION: Documents TLV structure for multicast routing table (tableID=40), for matching multicast IPv4/IPv6 flows, source/group matching, and forwarding actions. Used by OpenFlow agents for group-based multicast processing and hardware offload. Special handling for optional fields and mask use.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/rocker.txt#_snippet_14\n\nLANGUAGE: plaintext\nCODE:\n```\nfield\\t\\t\\t\\twidth\\tdescription\\n----------------------------------------------------\\nOF_DPA_ETHERTYPE\\t\\t2 (N)\\tmust be either 0x0800 or 0x86dd\\nOF_DPA_VLAN_ID\\t\\t2 (N)\\tvlan ID\\nOF_DPA_SRC_IP\\t\\t4 (N)\\tsource IPv4. Optional,\\n\\t\\t\\t\\tcan contain IPv4 address,\\n\\t\\t\\t\\tmust be completely masked\\n\\t\\t\\t\\tif not used\\nOF_DPA_SRC_IP_MASK\\t4 (N)\\tIP Mask\\nOF_DPA_DST_IP\\t\\t4 (N)\\tdestination IPv4 address.\\n\\t\\t\\t\\tMust be multicast address\\nOF_DPA_SRC_IPV6\\t\\t16 (N)\\tsource IPv6 Address. Optional.\\n\\t\\t\\t\\tCan contain IPv6 address,\\n\\t\\t\\t\\tmust be completely masked\\n\\t\\t\\t\\tif not used\\nOF_DPA_SRC_IPV6_MASK\\t16 (N)\\tIPv6 mask.\\nOF_DPA_DST_IPV6\\t\\t16 (N)\\tdestination IPv6 Address. Must\\n\\t\\t\\t\\tbe multicast address\\n\\t\\t\\t\\tMust be multicast address\\nOF_DPA_GOTO_TBL\\t\\t2\\tgoto table ID; zero to drop\\nOF_DPA_GROUP_ID\\t\\t4\\tdata for GROUP action must\\n\\t\\t\\t\\tbe an L3 multicast group entry\n```\n\n----------------------------------------\n\nTITLE: Checking Plugin Build State with Cargo - Rust - shell\nDESCRIPTION: Runs a preliminary check to validate that the plugin compiles correctly without generating output artifacts. No external dependencies are needed besides Cargo itself. No arguments are required; output includes success and error messages related to code compilation, not binary generation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/rust_skeleton/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo check\n```\n\n----------------------------------------\n\nTITLE: Configuring QEMU Network Devices with -device (QEMU CLI, Shell)\nDESCRIPTION: Explains the transition from -net nic and -usbdevice net syntax to -device for adding network adapters identified by netdev, MAC, and device ID/model. Inputs are CLI device parameters; output is virtual NIC creation appropriately mapped. QEMU-only dependency.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\n-device DEVNAME,netdev=NET-ID,mac=MACADDR,DEV-OPTS...\n```\n\n----------------------------------------\n\nTITLE: Defining System Call Prototypes - Linux Kernel - C\nDESCRIPTION: These C code snippets each declare a Linux system call function prototype, intended for use within kernel source files to define the entrypoints for system-level operations. Each prototype matches the expected ABI for its syscall number, describing the return type, function name (e.g., sys_read), and parameter types (such as file descriptors, pointers, or mode values). These declarations require standard Linux kernel data types (e.g., size_t, time_t, umode_t) and are only meaningful in a kernel build environment. Input parameters correspond precisely to expected system call arguments; output is typically a long integer result code or error code, unless otherwise specified.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_arm_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n0 long sys_restart_syscall(void);\n1 long sys_exit(int error_code);\n2 long sys_fork(void);\n3 long sys_read(unsigned int fd, char __user *buf, size_t count);\n4 long sys_write(unsigned int fd, const char __user *buf, size_t count);\n5 long sys_open(const char __user *filename, int flags, umode_t mode);\n6 long sys_close(unsigned int fd);\n8 long sys_creat(const char __user *pathname, umode_t mode);\n9 long sys_link(const char __user *oldname, const char __user *newname);\n10 long sys_unlink(const char __user *pathname);\n11 long sys_execve(const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp);\n12 long sys_chdir(const char __user *filename);\n13 long sys_time(time_t __user *tloc);\n14 long sys_mknod(const char __user *filename, umode_t mode, unsigned dev);\n15 long sys_chmod(const char __user *filename, umode_t mode);\n16 long sys_lchown16(const char __user *filename, old_uid_t user, old_gid_t group);\n19 long sys_lseek(unsigned int fd, off_t offset, unsigned int whence);\n20 long sys_getpid(void);\n21 long sys_mount(char __user *dev_name, char __user *dir_name, char __user *type, unsigned long flags, void __user *data);\n23 long sys_setuid16(old_uid_t uid);\n24 long sys_getuid16(void);\n25 long sys_stime(time_t __user *tptr);\n26 long sys_ptrace(long request, long pid, unsigned long addr, unsigned long data);\n27 long sys_alarm(unsigned int seconds);\n29 long sys_pause(void);\n30 long sys_utime(char __user *filename, struct utimbuf __user *times);\n33 long sys_access(const char __user *filename, int mode);\n34 long sys_nice(int increment);\n36 long sys_sync(void);\n37 long sys_kill(int pid, int sig);\n38 long sys_rename(const char __user *oldname, const char __user *newname);\n39 long sys_mkdir(const char __user *pathname, umode_t mode);\n40 long sys_rmdir(const char __user *pathname);\n41 long sys_dup(unsigned int fildes);\n42 long sys_pipe(int __user *fildes);\n43 long sys_times(struct tms __user *tbuf);\n45 long sys_brk(unsigned long brk);\n46 long sys_setgid16(old_gid_t gid);\n47 long sys_getgid16(void);\n49 long sys_geteuid16(void);\n50 long sys_getegid16(void);\n51 long sys_acct(const char __user *name);\n52 long sys_umount(char __user *name, int flags);\n54 long sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);\n55 long sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg);\n57 long sys_setpgid(pid_t pid, pid_t pgid);\n60 long sys_umask(int mask);\n61 long sys_chroot(const char __user *filename);\n62 long sys_ustat(unsigned dev, struct ustat __user *ubuf);\n63 long sys_dup2(unsigned int oldfd, unsigned int newfd);\n64 long sys_getppid(void);\n65 long sys_getpgrp(void);\n66 long sys_setsid(void);\n67 long sys_sigaction(int, const struct old_sigaction __user *, struct old_sigaction __user *);\n70 long sys_setreuid16(old_uid_t ruid, old_uid_t euid);\n71 long sys_setregid16(old_gid_t rgid, old_gid_t egid);\n72 long sys_sigsuspend(int unused1, int unused2, old_sigset_t mask);\n73 long sys_sigpending(old_sigset_t __user *set);\n74 long sys_sethostname(char __user *name, int len);\n75 long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim);\n77 long sys_getrusage(int who, struct rusage __user *ru);\n78 long sys_gettimeofday(struct timeval __user *tv, struct timezone __user *tz);\n79 long sys_settimeofday(struct timeval __user *tv, struct timezone __user *tz);\n80 long sys_getgroups16(int gidsetsize, old_gid_t __user *grouplist);\n81 long sys_setgroups16(int gidsetsize, old_gid_t __user *grouplist);\n83 long sys_symlink(const char __user *old, const char __user *new);\n85 long sys_readlink(const char __user *path, char __user *buf, int bufsiz);\n86 long sys_uselib(const char __user *library);\n87 long sys_swapon(const char __user *specialfile, int swap_flags);\n88 long sys_reboot(int magic1, int magic2, unsigned int cmd, void __user *arg);\n91 long sys_munmap(unsigned long addr, size_t len);\n92 long sys_truncate(const char __user *path, long length);\n93 long sys_ftruncate(unsigned int fd, unsigned long length);\n94 long sys_fchmod(unsigned int fd, umode_t mode);\n95 long sys_fchown16(unsigned int fd, old_uid_t user, old_gid_t group);\n96 long sys_getpriority(int which, int who);\n97 long sys_setpriority(int which, int who, int niceval);\n99 long sys_statfs(const char __user *path, struct statfs __user *buf);\n100 long sys_fstatfs(unsigned int fd, struct statfs __user *buf);\n102 long sys_socketcall(int call, unsigned long __user *args);\n103 long sys_syslog(int type, char __user *buf, int len);\n104 long sys_setitimer(int which, struct itimerval __user *value, struct itimerval __user *ovalue);\n105 long sys_getitimer(int which, struct itimerval __user *value);\n106 long sys_newstat(const char __user *filename, struct stat __user *statbuf);\n107 long sys_newlstat(const char __user *filename, struct stat __user *statbuf);\n108 long sys_newfstat(unsigned int fd, struct stat __user *statbuf);\n111 long sys_vhangup(void);\n114 long sys_wait4(pid_t pid, int __user *stat_addr, int options, struct rusage __user *ru);\n115 long sys_swapoff(const char __user *specialfile);\n116 long sys_sysinfo(struct sysinfo __user *info);\n117 long sys_ipc(unsigned int call, int first, unsigned long second, unsigned long third, void __user *ptr, long fifth);\n118 long sys_fsync(unsigned int fd);\n119 int sys_sigreturn(struct pt_regs *regs);\n120 long sys_clone(unsigned long, unsigned long, int __user *, int __user *, unsigned long);\n121 long sys_setdomainname(char __user *name, int len);\n122 long sys_newuname(struct new_utsname __user *name);\n124 long sys_adjtimex(struct timex __user *txc_p);\n125 long sys_mprotect(unsigned long start, size_t len, unsigned long prot);\n126 long sys_sigprocmask(int how, old_sigset_t __user *set, old_sigset_t __user *oset);\n128 long sys_init_module(void __user *umod, unsigned long len, const char __user *uargs);\n129 long sys_delete_module(const char __user *name_user, unsigned int flags);\n131 long sys_quotactl(unsigned int cmd, const char __user *special, qid_t id, void __user *addr);\n132 long sys_getpgid(pid_t pid);\n133 long sys_fchdir(unsigned int fd);\n134 long sys_bdflush(int func, long data);\n135 long sys_sysfs(int option, unsigned long arg1, unsigned long arg2);\n136 long sys_personality(unsigned int personality);\n138 long sys_setfsuid16(old_uid_t uid);\n139 long sys_setfsgid16(old_gid_t gid);\n140 long sys_llseek(unsigned int fd, unsigned long offset_high, unsigned long offset_low, loff_t __user *result, unsigned int whence);\n141 long sys_getdents(unsigned int fd, struct linux_dirent __user *dirent, unsigned int count);\n142 long sys_select(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct timeval __user *tvp);\n143 long sys_flock(unsigned int fd, unsigned int cmd);\n144 long sys_msync(unsigned long start, size_t len, int flags);\n145 long sys_readv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\n146 long sys_writev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\n147 long sys_getsid(pid_t pid);\n148 long sys_fdatasync(unsigned int fd);\n149 long sys_sysctl(struct __sysctl_args __user *args);\n150 long sys_mlock(unsigned long start, size_t len);\n151 long sys_munlock(unsigned long start, size_t len);\n152 long sys_mlockall(int flags);\n153 long sys_munlockall(void);\n154 long sys_sched_setparam(pid_t pid, struct sched_param __user *param);\n155 long sys_sched_getparam(pid_t pid, struct sched_param __user *param);\n156 long sys_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param);\n157 long sys_sched_getscheduler(pid_t pid);\n158 long sys_sched_yield(void);\n159 long sys_sched_get_priority_max(int policy);\n160 long sys_sched_get_priority_min(int policy);\n161 long sys_sched_rr_get_interval(pid_t pid, struct timespec __user *interval);\n162 long sys_nanosleep(struct timespec __user *rqtp, struct timespec __user *rmtp);\n163 long sys_mremap(unsigned long addr, unsigned long old_len, unsigned long new_len, unsigned long flags, unsigned long new_addr);\n164 long sys_setresuid16(old_uid_t ruid, old_uid_t euid, old_uid_t suid);\n165 long sys_getresuid16(old_uid_t __user *ruid, old_uid_t __user *euid, old_uid_t __user *suid);\n168 long sys_poll(struct pollfd __user *ufds, unsigned int nfds, int timeout);\n170 long sys_setresgid16(old_gid_t rgid, old_gid_t egid, old_gid_t sgid);\n171 long sys_getresgid16(old_gid_t __user *rgid, old_gid_t __user *egid, old_gid_t __user *sgid);\n172 long sys_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\n173 int sys_rt_sigreturn(struct pt_regs *regs);\n174 long sys_rt_sigaction(int, const struct sigaction __user *, struct sigaction __user *, size_t);\n175 long sys_rt_sigprocmask(int how, sigset_t __user *set, sigset_t __user *oset, size_t sigsetsize);\n176 long sys_rt_sigpending(sigset_t __user *set, size_t sigsetsize);\n177 long sys_rt_sigtimedwait(const sigset_t __user *uthese, siginfo_t __user *uinfo, const struct timespec __user *uts, size_t sigsetsize);\n178 long sys_rt_sigqueueinfo(int pid, int sig, siginfo_t __user *uinfo);\n179 long sys_rt_sigsuspend(sigset_t __user *unewset, size_t sigsetsize);\n180 long sys_pread64(unsigned int fd, char __user *buf, size_t count, loff_t pos);\n181 long sys_pwrite64(unsigned int fd, const char __user *buf, size_t count, loff_t pos);\n182 long sys_chown16(const char __user *filename, old_uid_t user, old_gid_t group);\n183 long sys_getcwd(char __user *buf, unsigned long size);\n184 long sys_capget(cap_user_header_t header, cap_user_data_t dataptr);\n185 long sys_capset(cap_user_header_t header, const cap_user_data_t data);\n186 long sys_sigaltstack(const struct sigaltstack __user *uss, struct sigaltstack __user *uoss);\n187 long sys_sendfile(int out_fd, int in_fd, off_t __user *offset, size_t count);\n190 long sys_vfork(void);\n191 long sys_getrlimit(unsigned int resource, struct rlimit __user *rlim);\n\n```\n\n----------------------------------------\n\nTITLE: Initializing QEMUFile for Migration in C\nDESCRIPTION: This snippet shows the function signature for creating a QEMUFile abstraction, which is used for migration operations. It defines the required callback functions for putting and getting buffers, as well as closing the file.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/migration.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nQEMUFile *qemu_fopen_ops(void *opaque,\n                         QEMUFilePutBufferFunc *put_buffer,\n                         QEMUFileGetBufferFunc *get_buffer,\n                         QEMUFileCloseFunc *close);\n```\n\n----------------------------------------\n\nTITLE: Calculating Disk Coverage of L2 and Refcount Caches - Shell\nDESCRIPTION: These example formulas, shown as shell-style pseudo-code, illustrate how to compute the amount of virtual disk (in bytes) covered by the L2 and refcount caches based on respective cache sizes, cluster_size, and refcount_bits. These calculations are essential for estimating how much of the virtual disk benefits from caching, and are useful when tuning QEMU's performance. Inputs must be integer values matching cache settings and qcow2 configuration. Formulas are for guidance in computational tools such as bash, Python, or manual calculation, and are not directly executable shell commands.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qcow2-cache.txt#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ndisk_size = l2_cache_size * cluster_size / 8\ndisk_size = refcount_cache_size * cluster_size * 8 / refcount_bits\n```\n\n----------------------------------------\n\nTITLE: Pulling and Running PANDA Docker Container (Shell)\nDESCRIPTION: These shell commands demonstrate how to pull the latest PANDA container image from Docker Hub and run the main i386 QEMU binary with the '--help' flag. Dependencies include Docker installed on the system. The expected input is executed at the shell prompt; the output is the PANDA help message printed to stdout. These commands offer a quick way to get started without building from source, but provide only the PANDA binaries and not source code or build artifacts.\nSOURCE: https://github.com/panda-re/panda/blob/dev/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ docker pull pandare/panda\\n$ docker run --rm pandare/panda panda-system-i386 --help\n```\n\n----------------------------------------\n\nTITLE: Loading the Coverage Plugin on a Live System via QEMU Monitor (Shell and Interactive Monitor Commands)\nDESCRIPTION: This sequence demonstrates how to launch PANDA and dynamically load the 'coverage' plugin on a live system using QEMU's monitor interface. Essential dependencies include the PANDA build with the 'osi' and 'coverage' plugins available, as well as a valid disk image and OSI configuration. Commands shown cover launching with required plugins and options, loading 'coverage' with specified arguments, and sample monitor commands to start and stop coverage collection. Key arguments include the coverage output filename and mode. Inputs and outputs are controlled interactively in the monitor. Limitations: appropriate privileges and guest configurations are necessary for OSI functionality.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/coverage/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npanda-system-i386 -monitor stdio -m 2G -net nic -net user -os linux-32-.+ -panda osi -panda osi_linux:kconf_file=myconf.conf,kconf_group=mygroup -hda myimage.img\n(qemu) load_plugin coverage,filename=test01.csv,mode=osi-block\nPANDA[core]:initializing coverage\nPANDA[coverage]:output file name test01.csv\nPANDA[coverage]:log all records DISABLED\nPANDA[coverage]:mode process\nPANDA[core]:loading required plugin osi\nPANDA[core]:/omitted/for/sake/of/security/panda_osi.so already loaded\nPANDA[coverage]:start disabled DISABLED\n(qemu) plugin_cmd help\nPANDA[coverage]:coverage_enable=filename:  start logging coverage information to the named file\nPANDA[coverage]:coverage_disable:  stop logging coverage information and close the current file\n...(do something interesting in the guest)...\n(qemu) plugin_cmd coverage_disable\n...(do something do not want recorded)...\n(qemu) plugin_cmd coverage_enable=test02.csv\n...(do something interesting in the guest)...\n(qemu) plugin_cmd coverage_disable\n```\n\n----------------------------------------\n\nTITLE: Starting QEMU with Multiseat Devices and Input Routing - Shell/Bash\nDESCRIPTION: This set of QEMU invocation snippets demonstrates how to start a VM with multihead/multiseat support. It incrementally adds a VGA display, multiple input and USB devices, and uses bus addressing to tie specific devices to specific seats. Dependencies include a compiled QEMU (with required UI backend), and a Linux host capable of KVM. The key parameters are device assignment (--device), memory and disk configuration, and the -display flag which specifies the GUI backend. The output is a running VM instance with multiple independent seat setups. Input routing is ensured via the 'display' parameter attached to certain devices.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/multiseat.txt#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nqemu\t-enable-kvm -usb $memory $disk $whatever \\\n\t-display [ sdl | gtk ] \\\n\t-vga std \\\n\t-device usb-tablet\n```\n\nLANGUAGE: bash\nCODE:\n```\n\t-device pci-bridge,addr=12.0,chassis_nr=2,id=head.2 \\\n\t-device secondary-vga,bus=head.2,addr=02.0,id=video.2 \\\n\t-device nec-usb-xhci,bus=head.2,addr=0f.0,id=usb.2 \\\n\t-device usb-kbd,bus=usb.2.0,port=1,display=video.2 \\\n\t-device usb-tablet,bus=usb.2.0,port=2,display=video.2\n```\n\nLANGUAGE: bash\nCODE:\n```\n\t-device pci-bridge,addr=12.0,chassis_nr=2,id=head.2 \\\n\t-device secondary-vga,bus=head.2,addr=02.0,id=video.2 \\\n\t-device virtio-keyboard-pci,bus=head.2,addr=03.0,display=video.2 \\\n\t-device virtio-tablet-pci,bus=head.2,addr=03.0,display=video.2\n```\n\n----------------------------------------\n\nTITLE: Attaching GDB to a PANDA Remote Target - GDB\nDESCRIPTION: This snippet illustrates attaching GDB to a remote debug target provided by PANDA. It depends on a GDB instance launched previously and a PANDA instance exposing the GDB remote debugging port (typically localhost:4444). No parameters are strictly required except the connection string; successful connection will enable use of standard GDB debugging commands. Only one GDB client should be attached to a PANDA target at a time.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/gdb/README.md#_snippet_2\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) target remote localhost:4444\n```\n\n----------------------------------------\n\nTITLE: Declaring Hypercall Function Type â€” C\nDESCRIPTION: Defines a typedef for a hypercall handler, taking a CPUState pointer as its only parameter. This is used to ensure all registered hypercall handlers have a consistent function signature. Required for type safety when registering callbacks with the hypercaller plugin.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/hypercaller/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*hypercall_t)(CPUState *cpu);\n```\n\n----------------------------------------\n\nTITLE: Configuring Search Strings for Memory Analysis - Text File - Text\nDESCRIPTION: This snippet provides the content to place in 'search_strings.txt', specifying the strings to be searched in VM memory during the replay. These directives guide the 'stringsearch' plugin to look for HTML page load and crash indicators. Each string should be on its own line; contains both case-sensitive variations and an error message.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/UAF.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n\"<html\"\n\"<HTML\"\n\"has stopped working\"\n```\n\n----------------------------------------\n\nTITLE: Physical Memory Access Callbacks During Replay\nDESCRIPTION: Code that executes all registered callbacks for physical memory access during replay, used for taint tracking when DMA transfers occur between I/O buffer and RAM.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/hd_taint.txt#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nif (rr_in_replay()) {\n  // run all callbacks registered for cpu_physical_memory_rw ram case             \n  panda_cb_list *plist;\n  for (plist = panda_cbs[PANDA_CB_REPLAY_BEFORE_CPU_PHYSICAL_MEM_RW_RAM]; plist != NULL; plist = plist->next) {\n    plist->entry.replay_before_cpu_physical_mem_rw_ram\n      (env, is_write, buf, dest, l);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Kernel Info Extraction Script in Bash\nDESCRIPTION: This bash command demonstrates how to run the kernel information extraction script using the provided run.sh file. It takes two arguments: the path to the vmlinux file and the desired output file.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi_linux/utils/kernelinfo_gdb/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./run.sh vmlinux file.out\n```\n\n----------------------------------------\n\nTITLE: Cloning the PANDA Framework Using git (Shell)\nDESCRIPTION: This snippet clones the PANDA dynamic analysis framework using git for further use in emulator trace replay and plugin execution. The dependency is git, and the output is a panda directory containing PANDA sources. This is the base setup requirement for all later PANDA-based actions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/LINE_Censorship.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ git clone https://github.com/moyix/panda.git\n```\n\n----------------------------------------\n\nTITLE: Extended Attribute and AIO Management in C\nDESCRIPTION: Function declarations for extended attribute manipulation and additional asynchronous I/O operations. These functions allow getting, setting, and deleting extended attributes on files.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nint extattrctl(const char *path, int cmd, const char *filename, int attrnamespace, const char *attrname);\nssize_t extattr_set_file(const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes);\nssize_t extattr_get_file(const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes);\nint extattr_delete_file(const char *path, int attrnamespace, const char *attrname);\nssize_t aio_waitcomplete(struct aiocb **aiocbp, struct timespec *timeout);\nint getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);\nint getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);\nint kqueue(void);\nint kevent(int fd, struct kevent_freebsd11 *changelist, int nchanges, struct kevent_freebsd11 *eventlist, int nevents, const struct timespec *timeout);\n```\n\n----------------------------------------\n\nTITLE: Kernelinfo Extraction Sample Output (dmesg output, annotated)\nDESCRIPTION: This sample demonstrates the expected output in the system log (dmesg) after building and inserting the `kernelinfo.ko` kernel module. These logged lines detail gathered offset and version information using the specified field names and their computed addresses. Users should copy these values (excluding the KERNELINFO-BEGIN/END markers) into their kernelinfo.conf for use by `osi_linux`. Output lines are used verbatim as configuration entries.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi_linux/README.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n[  335.936312] --KERNELINFO-BEGIN--\n[  335.936352] name = 4.9.0-6-686-pae|#1 SMP Debian 4.9.82-1+deb9u3 (2018-03-02)|i686\n[  335.936371] version.a = 4\n[  335.936380] version.b = 9\n[  335.936389] version.c = 88\n[  335.936400] task.init_addr = 3245807232\n[  335.936415] #task.init_addr = 0xC1771680\n[  335.936425] #task.per_cpu_offset_0 = 0x36127000\n[  335.936435] task.per_cpu_offset_0 = 907177984\n[  335.936443] #task.current_task_addr = 0xC18C3208\n[  335.936452] task.current_task_addr = 3247190536\n[  335.936473] task.size = 5888\n[  335.936502] task.tasks_offset = 708\n[  335.936528] task.pid_offset = 864\n[  335.936553] task.tgid_offset = 868\n[  335.936578] task.group_leader_offset = 900\n[  335.936602] task.thread_group_offset = 956\n[  335.936627] task.real_parent_offset = 876\n[  335.936651] task.parent_offset = 880\n[  335.936676] task.mm_offset = 748\n[  335.936700] task.stack_offset = 12\n[  335.936724] task.real_cred_offset = 1092\n[  335.936748] task.cred_offset = 1096\n[  335.936772] task.comm_offset = 1100\n[...]\n[  335.937668] path.mnt_parent_offset = -8\n[  335.937694] path.mnt_mountpoint_offset = -4\n[  335.937701] ---KERNELINFO-END---\n```\n\n----------------------------------------\n\nTITLE: Defining OF-DPA Flow Table Command TLVs - Technical Table - plaintext\nDESCRIPTION: Documents the list of TLVs (Type-Length-Value fields) used for adding, modifying, deleting, and retrieving OF-DPA flow entries via the DMA CMD ring. Each TLV has field name, width, and contextual meaning as per the table type. Dependency: understanding of OF-DPA, OpenFlow, and their hardware translation via the Rocker switch API. Key parameters: command type, table ID, priorities, timeouts, and match/action fields per table. Used as a blueprint for translating controller intent to hardware.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/rocker.txt#_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\nfield\\t\\t\\t\\twidth\\tdescription\\n----------------------------------------------------\\nOF_DPA_CMD\\t\\t\\t2\\tCMD_[ADD|MOD]\\nOF_DPA_TBL\\t\\t\\t2\\tFlow table ID\\n\\t\\t\\t\\t  0: ingress port\\n\\t\\t\\t\\t  10: vlan\\n\\t\\t\\t\\t  20: termination mac\\n\\t\\t\\t\\t  30: unicast routing\\n\\t\\t\\t\\t  40: multicast routing\\n\\t\\t\\t\\t  50: bridging\\n\\t\\t\\t\\t  60: ACL policy\\nOF_DPA_PRIORITY\\t\\t4\\tFlow priority\\nOF_DPA_HARDTIME\\t\\t4\\tHard timeout for flow\\nOF_DPA_IDLETIME\\t\\t4\\tIdle timeout for flow\\nOF_DPA_COOKIE\\t\\t8\\tCookie\n```\n\n----------------------------------------\n\nTITLE: Launching QEMU Passthrough Device with Hardware Backed Smart Card - Shell\nDESCRIPTION: This example command starts QEMU with a chardev listening on a TCP socket and attaches a USB CCID and passthrough device, allowing smart card passthrough from client hardware to the guest. Requirements include network access on the specified port, built QEMU with smart card support, and compatible chardev configuration. Inputs are host, port, and device IDs; outputs are a virtual machine waiting for a client connection and ready for card passthrough.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/ccid.txt#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nqemu -chardev socket,server,host=0.0.0.0,port=2001,id=ccid,nowait -usb -device usb-ccid -device ccid-card-passthru,chardev=ccid\n```\n\n----------------------------------------\n\nTITLE: Success Response JSON Structure in QMP\nDESCRIPTION: Defines the JSON structure for a successful command response in QMP. It includes the returned data and the transaction ID if provided.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qmp-spec.txt#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{ \"return\": json-value, \"id\": json-value }\n```\n\n----------------------------------------\n\nTITLE: Using Compiler Memory Barriers in QEMU with C\nDESCRIPTION: This snippet presents the use of the barrier() macro, which implements a compiler memory barrier as defined in qemu/atomic.h. It prevents the compiler from reordering memory accesses across the barrier but has no effect on the CPU's runtime ordering. The key dependency for using barrier() is including the qemu/atomic.h header, and its main parameter is its placement in code to protect critical references, specifically useful when signals or concurrency may interrupt code execution. It requires no other inputs or outputs, and is typically used inside low-level concurrent data structures or interrupt-sensitive regions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/atomics.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbarrier();\n```\n\n----------------------------------------\n\nTITLE: Splitting Tap Buffer Dump into Per-Event Files - Python Script - Bash\nDESCRIPTION: Uses the 'split_taps.py' script to divide large compressed memory buffer logs into individual data files based on tap points. The command must be run separately for both read and write buffers if those files exist. Requires Python and the relevant input files. The output will be per-tap data files for detailed inspection.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/UAF.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\npanda/scripts/split_taps.py read_tap_buffers.txt.gz crash.read\npanda/scripts/split_taps.py write_tap_buffers.txt.gz crash.write\n```\n\n----------------------------------------\n\nTITLE: Checking IDE Drive PIO State Necessity in C\nDESCRIPTION: This function determines if the PIO state of an IDE drive needs to be saved during migration. It checks if the DRQ_STAT bit is set in the status or if there's a PIO retry status.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/migration.txt#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nstatic bool ide_drive_pio_state_needed(void *opaque)\n{\n    IDEState *s = opaque;\n\n    return ((s->status & DRQ_STAT) != 0)\n        || (s->bus->error_status & BM_STATUS_PIO_RETRY);\n}\n```\n\n----------------------------------------\n\nTITLE: Installing QEMU Build Dependencies\nDESCRIPTION: Comprehensive list of packages needed to build QEMU, which is a core component of PANDA. Includes various development libraries for device support and system emulation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/dependencies/ubuntu_18.04_build.txt#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Qemu build deps\ndevice-tree-compiler\nlibgnutls28-dev\nlibaio-dev\nlibasound2-dev\nlibattr1-dev\nlibbluetooth-dev\nlibbrlapi-dev\nlibcacard-dev\nlibcap-dev\nlibcap-ng-dev\nlibcurl4-gnutls-dev\nlibfdt-dev\nlibibverbs-dev\nlibiscsi-dev\nlibjpeg-dev\nlibncursesw5-dev\nlibnuma-dev\nlibpixman-1-dev\nlibpng-dev\nlibpulse-dev\nlibrados-dev\nlibrbd-dev\nlibrdmacm-dev\nlibsasl2-dev\nlibsdl1.2-dev\nlibseccomp-dev\nlibspice-protocol-dev\nlibspice-server-dev\nlibusb-1.0-0-dev\nlibusbredirparser-dev\nlibx11-dev\npython\ntexinfo\nuuid-dev\nxfslibs-dev\nzlib1g-dev\n```\n\n----------------------------------------\n\nTITLE: Enabling KVM Trace Events via Ftrace in Shell\nDESCRIPTION: This shell command is used on Linux systems to enable tracing of KVM events in the ftrace subsystem, useful when collecting both QEMU and KVM trace data. It writes '1' to the appropriate sysfs node. Requires root privileges, Linux, and ftrace support. Input: none. Output: ftrace subsystem records KVM events.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/tracing.txt#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n# echo 1 > /sys/kernel/debug/tracing/events/kvm/enable\n```\n\n----------------------------------------\n\nTITLE: Windows NT File and Registry Operations\nDESCRIPTION: System calls for file, registry and object management including locking, mapping and notification functions. These handle file system operations and registry key management.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp1_x64_prototypes.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtLockFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);\nNTSTATUS NtLoadKey(POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile);\nNTSTATUS NtQueryEaFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan);\n```\n\n----------------------------------------\n\nTITLE: Referencing CI Configuration in Markdown\nDESCRIPTION: This snippet provides a Markdown link to the GitHub Actions workflow file that specifies which tests to run. It specifically mentions the 'pypanda_tests' tag.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/tests/README.md#_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n[`/panda/.github/parallel_tests.yml](../../../../.github/parallel_tests.yml)\n```\n\n----------------------------------------\n\nTITLE: Generating Still Frames with PANDA Replaymovie Plugin\nDESCRIPTION: Command to run the PANDA system emulator with the replaymovie plugin enabled. This generates screenshot frames from a replay named 'foo'.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/replaymovie/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$PANDA_PATH/x86_64-softmmu/panda-system-x86_64 -replay foo \\\n    -panda replaymovie\n```\n\n----------------------------------------\n\nTITLE: Error Response JSON Structure in QMP\nDESCRIPTION: Specifies the JSON structure for an error response in QMP. It includes the error class, description, and the transaction ID if provided.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qmp-spec.txt#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{ \"error\": { \"class\": json-string, \"desc\": json-string }, \"id\": json-value }\n```\n\n----------------------------------------\n\nTITLE: Pairing of Memory Barriers Across Threads - C\nDESCRIPTION: Demonstrates how to correctly pair memory barriersâ€”write and readâ€”between producer and consumer threads. The producer uses smp_wmb() after the first store, while the consumer performs a corresponding smp_rmb() between loads. This ensures writes before the barrier are visible after the barrier in the other thread. All variables should be properly aligned and shared, and QEMU/C barrier primitives are expected.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/atomics.txt#_snippet_9\n\nLANGUAGE: C\nCODE:\n```\nthread 1             thread 2\\n===============      ===============\\na = 1;\\nsmp_wmb();\\nb = 2;               x = b;\\n                     smp_rmb();\\n                     y = a;\n```\n\n----------------------------------------\n\nTITLE: Running bufmon with PANDA QEMU System Replay - Shell\nDESCRIPTION: This shell command launches the PANDA-instrumented QEMU ARM emulator with buffer monitoring enabled via the bufmon plugin, using a specified replay, machine profile, and kernel, along with NAND and MMC settings. The -panda options activate both callstack_instr and bufmon PANDA plugins, which monitor and record events for later analysis. Key parameters include the replay file (line2), memory size, target ARM CPU model, and relevant paths; successful execution produces logs/files for extracting buffer write events.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/LINE_Censorship.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\n../arm-softmmu/panda-system-arm -m 2048 -replay line2 -M android_arm -android -cpu cortex-a9 -kernel /dev/null \\\n  -global goldfish_mmc.sd_path=/dev/null -global goldfish_nand.system_path=dummy2.qcow2 \\\n  -global goldfish_nand.user_data_path=dummy.qcow2 \\\n  -panda 'callstack_instr;bufmon'\n```\n\n----------------------------------------\n\nTITLE: Integrating recctrlu Script with PAM SSH Sessions - Shell\nDESCRIPTION: This configuration line, intended for appending to the '/etc/pam.d/sshd' file, instructs PAM to execute the recctrlu shell script at the start of SSH sessions. The integration enables per-user session-based recording by executing logic within recctrlu.sh during session management. Prerequisites include correct placement and permissions of the script and utility, and careful PAM configuration to avoid accidental lockouts.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/recctrl/README.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nsession    optional     pam_exec.so seteuid /usr/local/bin/recctrlu.sh\n```\n\n----------------------------------------\n\nTITLE: Replay Skipped Calls Processing in CPU Exec\nDESCRIPTION: Code from cpu-exec.c that handles replay of skipped calls during replay mode, which executes all skipped calls that were logged in the I/O thread during record.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/hd_taint.txt#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nif (rr_in_replay()) {\n  rr_skipped_callsite_location = RR_CALLSITE_MAIN_LOOP_WAIT;\n  rr_set_program_point();\n  rr_replay_skipped_calls();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring VGA Devices in QEMU\nDESCRIPTION: Shows the syntax for configuring different VGA device types in QEMU using both old and new command styles. Options include standard VGA, QXL, and Cirrus, with options to disable VGA or control PCI addressing.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nqxl         -device qxl-vga\nnone        -nodefaults\n                disables more than just VGA, see \"Default Devices\"\n```\n\n----------------------------------------\n\nTITLE: STUW Output: Interprocess Communication Adjacency Matrix\nDESCRIPTION: Sample output from STUW showing the adjacency matrix of interprocess communication. Each line represents a process and its interactions with other processes, including the type and frequency of communication.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/stuw.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nproc(3448,WmiPrvSE.exe) : 92\n  proc(1404,avp.exe) : {[section, 19]}\nproc(1404,avp.exe) : 55\n  proc(3448,WmiPrvSE.exe) : {[section, 19]}\n  proc(440,csrss.exe) : {[ALPC, 14][section, 2][virtualmemory, 8]}\n  proc(2344,explorer.exe) : {[section, 7][virtualmemory, 2]}\n  proc(588,lsass.exe) : {[section, 2]}\n  proc(696,svchost.exe) : {[section, 1]}\nproc(2448,avp.exe) : 39\n  proc(2448,avp.exe) : {[virtualmemory, 15]}\n  proc(496,csrss.exe) : {[ALPC, 4][section, 1]}\n  proc(2344,explorer.exe) : {[virtualmemory, 6]}\n  proc(3556,rundll32.exe) : {[section, 2][virtualmemory, 5]}\n  proc(1180,svchost.exe) : {[file, 6]}\nproc(440,csrss.exe) : 72\n  proc(1404,avp.exe) : {[ALPC, 14][section, 2][virtualmemory, 5]}\nproc(496,csrss.exe) : 138\n  proc(2448,avp.exe) : {[ALPC, 4][section, 1]}\nproc(2344,explorer.exe) : 816\n  proc(1404,avp.exe) : {[section, 7][virtualmemory, 684]}\nproc(588,lsass.exe) : 6\n  proc(1404,avp.exe) : {[section, 2]}\nproc(3556,rundll32.exe) : 122\n  proc(2448,avp.exe) : {[section, 2]}\nproc(696,svchost.exe) : 9\n  proc(1404,avp.exe) : {[section, 1]}\nproc(1180,svchost.exe) : 5\n  proc(2448,avp.exe) : {[file, 5]}\n```\n\n----------------------------------------\n\nTITLE: Flow Table ID 20: Termination MAC Table Structure - Technical Table - plaintext\nDESCRIPTION: Outlines the TLV structure for the termination MAC table (tableID=20) in OF-DPA, used to match on MAC/vlan/ethertype fields at termination. To be used for ADD/MOD flow commands. Dependencies: OF-DPA command/request semantics and field meaning as per previous section.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/rocker.txt#_snippet_12\n\nLANGUAGE: plaintext\nCODE:\n```\nfield\\t\\t\\t\\twidth\\tdescription\\n----------------------------------------------------\\nOF_DPA_IN_PPORT\\t\\t4\\tingress physical port number\\nOF_DPA_IN_PPORT_MASK\\t4\\tingress physical port number mask\\nOF_DPA_ETHERTYPE\\t\\t2 (N)\\tmust be either 0x0800 or 0x86dd\\nOF_DPA_DST_MAC\\t\\t6 (N)\\tdestination MAC\\nOF_DPA_DST_MAC_MASK\\t6 (N)\\tdestination MAC mask\\nOF_DPA_VLAN_ID\\t\\t2 (N)\\tvlan ID\\nOF_DPA_VLAN_ID_MASK\\t2 (N)\\tvlan ID mask\\nOF_DPA_GOTO_TBL\\t\\t2\\tonly acceptable values are\\n\\tunicast or multicast routing\\n\\ttable IDs\\nOF_DPA_OUT_PPORT\\t\\t2\\tif specified, must be\\n\\tcontroller, set zero otherwise\n```\n\n----------------------------------------\n\nTITLE: Downloading and Unpacking LINE Trace Data Using Shell Commands (Shell)\nDESCRIPTION: This shell snippet downloads a recording of LINE emulator execution from rrshare.org and extracts its contents using a provided Python script. It performs checksum verification and unpacks the trace log files for later analysis. Dependencies are wget for file download and a working Python interpreter for running rrunpack.py. The primary input is the line2.rr trace, and the output is a set of decompressed trace files. This operation is foundational for subsequent replay and analysis steps.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/LINE_Censorship.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ wget http://www.rrshare.org/content/rrlogs/line2.rr\\n$ scripts/rrunpack.py line2.rr\\nVerifying checksum... Success.\\nline2-rr-snp\\nline2-rr-nondet.log\\nUnacking RR log line2.rr with 10367712943 instructions... Done.\n```\n\n----------------------------------------\n\nTITLE: Legacy iFerret Information Flow Logging for Port Input\nDESCRIPTION: Legacy iFerret code from ops_template.h that logs information flow operations for transfers from port to register (T1), used for taint tracking.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/hd_taint.txt#_snippet_10\n\nLANGUAGE: c\nCODE:\n```\niferret_log_info_flow_op_write_81(IFLO_HD_TRANSFER_6_DEST, T1_BASE, 2);\n```\n\n----------------------------------------\n\nTITLE: Enumerating TX Descriptor Status Return Codes - Technical Table - plaintext\nDESCRIPTION: Lists possible status/error codes that may be returned after a TX operation is completed. Used by drivers and diagnostics to interpret TX completion. Dependencies: knowledge of driver error codes and switch DMA operations. Input: completion status; Output: reason for error or success for TX descriptor.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/rocker.txt#_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\nDESC_COMP_ERR\\treason\\n--------------------------------------------------------------------\\n0\\t\\tOK\\n-ROCKER_ENXIO\\taddress or data read err on desc buf or packet\\n\\t\\tfragment\\n-ROCKER_EINVAL\\tbad pport or TSO or csum offloading error\\n-ROCKER_ENOMEM\\tno memory for internal staging tx fragment\n```\n\n----------------------------------------\n\nTITLE: Adding, Removing, and Overlapping QEMU Memory Subregions in C\nDESCRIPTION: Illustrates the use of QEMU memory API functions for manipulating subregions within a parent MemoryRegion, including memory_region_add_subregion(), memory_region_del_subregion(), and memory_region_add_subregion_overlap(). These routines are used post-initialization to build complex container regions (e.g., PCI BARs or controllers that aggregate RAM and MMIO) and to set the priority/overlap behavior of memory blocks. Required dependencies are properly initialized parent and child MemoryRegion structures; inputs include parent/child pointers, offsets, and optional overlap priorities. Output is the reconfiguration of the memory map as seen by QEMU and the guest; overlapping and priority behaviors are determined by priorities set, allowing for flexible region masking and fallbacks. These operations have constraints: subregions cannot be added to alias regions, and care must be taken to maintain a valid non-circular region graph.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/memory.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n/* Add a subregion at a given offset */\\nmemory_region_add_subregion(&parent, offset, &child);\\n\\n/* Remove a subregion */\\nmemory_region_del_subregion(&parent, &subregion);\\n\\n/* Add a subregion with overlap and priority */\\nmemory_region_add_subregion_overlap(&parent, offset, &child, priority);\n```\n\n----------------------------------------\n\nTITLE: Booting VM with PANDA for Packet Capture\nDESCRIPTION: Command to boot a virtual machine using PANDA, enabling network packet capture for SSL analysis.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/panda_ssltut.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nx86_64-softmmu/panda-system-x86_64 -hda debian_squeeze_i386_desktop_tut.qcow2 \\\n    -m a256 -monitor stdio -net nic,model=e1000 \\\n    -net user -net dump,file=ssltut.pcap\n```\n\n----------------------------------------\n\nTITLE: Manual Extraction of Monitored Buffer Data - Shell\nDESCRIPTION: This snippet provides a second example of bufmon WRITE log output, showing a different source address and data segment written to the target buffer. These lines serve for further manual extraction or scripting; the expected use is to identify contiguous memory region writes and recover complete buffer content. Typical workflow involves copying output from the logs and reassembling the original data.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/LINE_Censorship.md#_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\nWRITE 40796784 40038688 28210000 41793e38 00000004 e5 85 b1 e6\nWRITE 40796784 40038688 28210000 41793e3c 00000004 9d 83 e6 96\nWRITE 40796784 400386ac 28210000 41793e40 00000004 97 0a e4 b9\nWRITE 40796784 400386ac 28210000 41793e44 00000004 b0 e6 9e aa\nWRITE 4079ff5a 4079e8aa 28210000 41793e4c 00000004 91 51 00 00\n```\n\n----------------------------------------\n\nTITLE: Flow Table ID 60: ACL Policy Table Structure - Technical Table - plaintext\nDESCRIPTION: Outlines the fields, sizing, and usage for defining match/action entries in the OF-DPA ACL policy table (tableID=60). Used by controller logic to encode flow policies matching on port/VLAN/MAC fields. To be referenced for implementing policy flow commands.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/rocker.txt#_snippet_16\n\nLANGUAGE: plaintext\nCODE:\n```\nfield\\t\\t\\t\\twidth\\tdescription\\n----------------------------------------------------\\nOF_DPA_IN_PPORT\\t\\t4\\tingress physical port number\\nOF_DPA_IN_PPORT_MASK\\t4\\tingress physical port number mask\\nOF_DPA_ETHERTYPE\\t\\t2 (N)\\tethertype\\nOF_DPA_VLAN_ID\\t\\t2 (N)\\tvlan ID\\nOF_DPA_VLAN_ID_MASK\\t2 (N)\\tvlan ID mask\\nOF_DPA_VLAN_PCP\\t\\t2 (N)\\tvlan Priority Code Point\\nOF_DPA_VLAN_PCP_MASK\\t2 (N)\\tvlan Priority Code Point mask\\nOF_DPA_SRC_MAC\\t\\t6 (N)\\tsource MAC\\nOF_DPA_SRC_MAC_MASK\\t6 (N)\\tsource MAC mask\\nOF_DPA_DST_MAC\\t\\t6 (N)\\tdestination MAC\n```\n\n----------------------------------------\n\nTITLE: Resolving Stack Addresses Using GDB - GDB Script\nDESCRIPTION: Shows how to use GDB to resolve raw addresses found in a PANDA memory trace to symbolic names (function + offset) after launching or attaching to the monitored process. Prerequisites include a relevant GDB session, running the traced binary, and having debug symbols or symbol files available. Key commands used: 'run' to start the process, break with Ctrl-C, and 'info symbol' to map addresses to symbols. Outputs function names and code section information, crucial for interpreting call stacks in trace analysis.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/panda_ssltut.md#_snippet_6\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) run\n^C\nProgram received signal SIGINT, Interrupt.\n0xb7fe2424 in __kernel_vsyscall ()\n(gdb)\n(gdb) info symbol 0xb7d3cb16\nmemcpy + 70 in section .text of /lib/i686/cmov/libc.so.6\n(gdb) info symbol 0xb7e82bad\nHMAC_Init_ex + 141 in section .text of /usr/lib/i686/cmov/libcrypto.so.0.9.8\n(gdb) info symbol 0xb7fa72aa\ntls1_P_hash + 154 in section .text of /usr/lib/i686/cmov/libssl.so.0.9.8\n```\n\n----------------------------------------\n\nTITLE: Defining RX Descriptor Buffer Fields and Flags - Technical Table - plaintext\nDESCRIPTION: Specifies the RX (receive) descriptor TLVs, including packet source, hardware parse/validation flags, checksum results, and buffer addresses. Designed for host CPU and driver software to interpret incoming packets and offload results. Lists key flag bits, fragment info, and expected field meanings. Outputs guideline for RX descriptor layout implementation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/rocker.txt#_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\nfield\\t\\twidth\\tdescription\\n---------------------------------------------------\\nPPORT\\t\\t4\\tSource physical port #\\nRX_FLAGS\\t2\\tPacket parsing flags:\\n\\t\\t\\t  (1 << 0): IPv4 packet\\n\\t\\t\\t  (1 << 1): IPv6 packet\\n\\t\\t\\t  (1 << 2): csum calculated\\n\\t\\t\\t  (1 << 3): IPv4 csum good\\n\\t\\t\\t  (1 << 4): IP fragment\\n\\t\\t\\t  (1 << 5): TCP packet\\n\\t\\t\\t  (1 << 6): UDP packet\\n\\t\\t\\t  (1 << 7): TCP/UDP csum good\\n\\t\\t\\t  (1 << 8): Offload forward\\nRX_CSUM\\t2\\tIP calculated checksum:\\n\\t\\t\\t  IPv4: IP payload csum\\n\\t\\t\\t  IPv6: header and payload csum\\n\\t\\t\\t(Only valid is RX_FLAGS:csum calc is set)\\nRX_FRAG_ADDR\\t8\\tDMA address of packet fragment\\nRX_FRAG_MAX_LEN\\t2\\tPacket maximum fragment length\\nRX_FRAG_LEN\\t2\\tActual packet fragment length after receive\n```\n\n----------------------------------------\n\nTITLE: Using Reverse Execution and Guest Debugging Commands in GDB - GDB\nDESCRIPTION: This GDB session snippet illustrates stepwise reverse debugging, manual manipulation of the guest's instruction pointer, and breakpoint management during a PANDA replay session. It demonstrates use of commands such as 'reverse-stepi', 'reverse-continue', setting breakpoints, stepping through instructions, and reverse execution. These capabilities require PANDA to be launched with the appropriate options for reverse execution and GDB to be attached as described. Expected interaction is via the GDB CLI; output such as 'Breakpoint' notifications is provided by GDB.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/time-travel.md#_snippet_2\n\nLANGUAGE: gdb\nCODE:\n```\nRemote debugging using localhost:1234\n0xffffffff81030c64 in ?? ()\nBreakpoint 1 at 0xffffffff810422d6\nContinuing.\n\nBreakpoint 1, 0xffffffff810422d6 in ?? ()\n(gdb) rsi 10 <----- step back 10 instructions\n0xffffffff81063e59 in ?? ()\n(gdb) si 10\nBreakpoint 1, 0xffffffff810422d6 in ?? ()\n(gdb) b *0xffffffff81063e59\nBreakpoint 2 at 0xffffffff81063e59\n(gdb) rc <----- step back until breakpoint\nContinuing.\n\nBreakpoint 2, 0xffffffff81063e59 in ?? ()\n(gdb)\n```\n\n----------------------------------------\n\nTITLE: QEMU CPU Memory Map Output - PANDA mmio_trace Context\nDESCRIPTION: This plaintext snippet shows QEMU's reported CPU memory address space layout, indicating device address regions with priorities and (for SysTick) the start/end addresses. It provides a context for matching logged MMIO addresses to QEMU peripherals. No dependencies, intended as a reference for understanding log address mappings and for troubleshooting or verifying plugin output.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/mmio_trace/README.md#_snippet_3\n\nLANGUAGE: plain\nCODE:\n```\naddress-space: cpu-memory\\n  0000000000000000-ffffffffffffffff (prio 0, i/o): armv7m-container\\n    ... (entries omitted)\\n    00000000e000e000-00000000e000efff (prio 0, i/o): nvic\\n      00000000e000e000-00000000e000efff (prio 0, i/o): nvic_sysregs\\n      00000000e000e010-00000000e000e0ef (prio 1, i/o): systick\n```\n\n----------------------------------------\n\nTITLE: Example system call prototypes entries (Windows 7) - Markdown/Plain Text\nDESCRIPTION: These two blocks illustrate the typical format for system call prototypes used as input to the syscalls2 autogeneration process. Each prototype defines the return type, function name, and parameter types for a system call (e.g., NtCreateUserProcess, NtTerminateProcess). These serve as the interface for callback autogeneration and must be present in OS-specific prototype files (e.g., windows_7_x86_prototypes.txt).\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/syscalls2.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n NTSTATUS NtCreateUserProcess \n   (PHANDLE ProcessHandle, \n    PHANDLE ThreadHandle, \n    ACCESS_MASK ProcessDesiredAccess, \n    ACCESS_MASK ThreadDesiredAccess, \n    POBJECT_ATTRIBUTES ProcessObjectAttributes, \n    POBJECT_ATTRIBUTES ThreadObjectAttributes,\n    ULONG ProcessFlags, \n    ULONG ThreadFlags,\n    PRTL_USER_PROCESS_PARAMETERS ProcessParameters, \n    PPROCESS_CREATE_INFO CreateInfo, \n    PPROCESS_ATTRIBUTE_LIST AttributeList)\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n NTSTATUS NtTerminateProcess\n   (HANDLE ProcessHandle, \n    NTSTATUS ExitStatus)\n```\n\n----------------------------------------\n\nTITLE: Building PANDA Plugin with Custom Makefile (Makefile)\nDESCRIPTION: This Makefile defines build rules for a PANDA plugin named 'syscalls'. It includes standard PANDA and QEMU makefile logic, allowing additional CFLAGS or LIBS customization, and outputs the plugin as a shared library (.so). Required dependencies include the PANDA build system and a registered entry in config.panda. The main target builds panda_syscalls.so from the plugin's object file, adhering to naming conventions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/case_study_syscallmon.md#_snippet_0\n\nLANGUAGE: Makefile\nCODE:\n```\n# Don\\'t forget to add your plugin to config.panda!\\n\\n# Set your plugin name here. It does not have to correspond to the name\\n# of the directory in which your plugin resides.\\nPLUGIN_NAME=syscalls\\n\\n# Include the PANDA Makefile rules\\ninclude ../panda.mak\\n\\n# If you need custom CFLAGS or LIBS, set them up here\\n# CFLAGS+=\\n# LIBS+=\\n\\n# The main rule for your plugin. Please stick with the panda_ naming\\n# convention.\\npanda_$(PLUGIN_NAME).so: $(PLUGIN_TARGET_DIR)/$(PLUGIN_NAME).o\\n    $(call quiet-command,$(CC) $(QEMU_CFLAGS) -shared -o $(SRC_PATH)/$(TARGET_DIR)/$@ $^ $(LIBS),\"  PLUGIN  $@\")\\n\\nall: panda_$(PLUGIN_NAME).so\n```\n\n----------------------------------------\n\nTITLE: Running PANDA Core Binary from PATH (Shell)\nDESCRIPTION: This example demonstrates how to run the primary PANDA system binary from the shell, assuming it is present in the user's PATH after installation. The command starts the QEMU-based system with 2GB memory, a specified disk image, and attaches a monitor on stdio. This invocation requires the binary to be properly installed and system libraries satisfied. Input parameters specify VM memory, disk image, and monitor setup; output is the QEMU/PANDA VM session.\nSOURCE: https://github.com/panda-re/panda/blob/dev/README.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\npanda-system-i386 -m 2G -hda guest.img -monitor stdio\n```\n\n----------------------------------------\n\nTITLE: Mapping Switch Port Spaces - Markdown\nDESCRIPTION: This snippet defines the mapping of physical and logical switch ports, their corresponding ranges, and port assignments. Using a Markdown table and explanation, it clarifies which port numbers map to CPU, front-panel, loopback, reserved, and logical tunnel ports. Dependencies include device register infrastructure; expected output is a port-mapping framework for driver software logic.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/rocker.txt#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n    port            mapping\n    -------------------------------------------------------\n    0           CPU port (for packets to/from host CPU)\n    1-62            front-panel physical ports\n    63          loopback port\n    64-0x0000ffff       RSVD\n    0x00010000-0x0001ffff   logical tunnel ports\n    0x00020000-0xffffffff   RSVD\n\n```\n\n----------------------------------------\n\nTITLE: Registering Callback in Callback Dictionary (Python)\nDESCRIPTION: In this snippet, callbacks are mapped to their type representations in the callback_dictionary, associating each PandaCB field with a descriptive pandacbtype instance. Extending the dictionary is necessary when adding new callback types, ensuring linkage to the C enumeration that codes callback identifiers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/docs/extending_pypanda.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncallback_dictionary = {\npcb.init : pandacbtype(\"init\", -1),\n...\npcb.top_loop : pandacbtype(\"top_loop\", C.PANDA_CB_TOP_LOOP)}\n```\n\n----------------------------------------\n\nTITLE: Reference Management with Reader/Writer Locks in C\nDESCRIPTION: This dual snippet contrasts the usage of reader/writer locks for critical section management, both with and without explicit reference counting. The left side shows using read locks for access, while the right side demonstrates write locking, updating, and freeing the object. Prerequisites are read_lock, write_mutex_lock, and free. Inputs include a shared pointer and locks; outputs are successful concurrent protection and object reclamation. Useful as an alternative to RCU.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/rcu.txt#_snippet_9\n\nLANGUAGE: C\nCODE:\n```\nread_lock(&foo_rwlock);         write_mutex_lock(&foo_rwlock);\np = foo;                        p = foo;\n/* do something with p. */      foo = new;\nread_unlock(&foo_rwlock);       free(p);\n                                write_mutex_unlock(&foo_rwlock);\n                                free(p);\n```\n\nLANGUAGE: C\nCODE:\n```\nread_lock(&foo_rwlock);         write_mutex_lock(&foo_rwlock);\np = foo;                        old = foo;\nfoo_ref(p);                     foo = new;\nread_unlock(&foo_rwlock);       foo_unref(old);\n/* do something with p. */      write_mutex_unlock(&foo_rwlock);\nread_lock(&foo_rwlock);\nfoo_unref(p);\nread_unlock(&foo_rwlock);\n```\n\n----------------------------------------\n\nTITLE: Defining Tap Points for Memory Dump - Text File - Text\nDESCRIPTION: The content of 'tap_points.txt', listing crucial memory addresses and context for the 'textprinter' plugin. Each line contains three hexadecimal addresses corresponding to occurrences of interest from memory match logs. Inputs must match those extracted from previous plugin outputs; no output beyond providing configuration for subsequent analysis.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/UAF.md#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n000000006da68ba1 000000006da803e0 000000003f98b320\n000000006d9cfd1f 0000000075ab9f11 000000003f98b320\n```\n\n----------------------------------------\n\nTITLE: Initializing cosi_strace Plugin in Panda - Python\nDESCRIPTION: This Python snippet demonstrates initializing a Panda instance for a generic i386 machine, loading the cosi_strace plugin, and orchestrating a command execution in a virtual machine environment. It utilizes the pandare Python package and requires an appropriate QEMU image. The snippet reverts the VM state, runs the 'ls' command over serial, and then ends analysis. Inputs include the target image and command, outputting strace-like syscall traces; dependencies include Panda and pandare installed. Limitations: the 'dump_prototypes' option is not enabled, so syscall prototype dumping is not performed.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/cosi_strace/README.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom pandare import Panda\n\npanda = Panda(generic=\"i386\")\npanda.load_plugin(\"cosi_strace\")\n\n@panda.queue_blocking\ndef run_cmd():\n    panda.revert_sync(\"root\")\n    panda.run_serial_cmd(\"ls\")\n    panda.end_analysis()\n\npanda.run()\n```\n\n----------------------------------------\n\nTITLE: Connecting USB Block Storage Devices (QEMU CLI, Shell)\nDESCRIPTION: Compares legacy -usbdevice with enhanced -device syntax for adding USB storage, showing how to create a usb-storage device with a linked drive and a removable attribute. Input: CLI string. Output: QEMU adds USB block storage with correct removable state.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n-device usb-storage,drive=DRIVE-ID,removable=RMB\n```\n\n----------------------------------------\n\nTITLE: Running OpenSSL Client in GDB for Debugging\nDESCRIPTION: Command to launch OpenSSL client within GDB for debugging and symbol resolution during the SSL connection.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/panda_ssltut.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngdb --args openssl s_client -connect google.com:443\n```\n\n----------------------------------------\n\nTITLE: Configuring QEMU vNVDIMM via Command Line (Shell)\nDESCRIPTION: This shell command snippet demonstrates initializing a QEMU virtual machine with a virtual NVDIMM device by specifying machine options, memory slots, backend memory, and device association. Dependencies include QEMU v2.6.0 or later, and a guest OS with NVDIMM driver support. Key parameters such as $RAM_SIZE, $N, $MAX_SIZE, $PATH, and $NVDIMM_SIZE must be set appropriately, and the configuration enables persistent memory mode with file-backed storage. The output is a QEMU VM with vNVDIMM accessible to the guest system. Limitations: slot and maxmem values must be correctly set to avoid errors or data corruption.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/nvdimm.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n-machine pc,nvdimm\n-m $RAM_SIZE,slots=$N,maxmem=$MAX_SIZE\n-object memory-backend-file,id=mem1,share=on,mem-path=$PATH,size=$NVDIMM_SIZE\n-device nvdimm,id=nvdimm1,memdev=mem1\n```\n\n----------------------------------------\n\nTITLE: Extracting Context Switch Address from System.map (Shell Command)\nDESCRIPTION: These shell commands search /boot/System.map-<Kernel Version> for function addresses needed to enable task change notifications in osi_linux. For Linux 2.6+ kernels, 'finish_task_switch' is the hook; for 2.4.x, '__switch_to' is used. The address found is set in the kernel configuration file for use by the plugin.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi_linux/README.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ngrep finish_task_switch /boot/System.map-<Kernel Version>\n```\n\nLANGUAGE: sh\nCODE:\n```\ngrep __switch_to /boot/System.map-<Kernel Version>\n```\n\n----------------------------------------\n\nTITLE: Defining TX Descriptor Buffer Fields and Offloads - Technical Table - plaintext\nDESCRIPTION: Documents the field names, widths, and purposes for the TX (transmit) descriptor buffer, including packet fragmentation, hardware checksum, and segmentation offload support. Prerequisite: familiarity with DMA buffer rings and switch driver programming. Parameters include per-packet offload indicators, fragment addressing/length, and special handling for hardware checksum and segmentation offloads. Output is a reference for authoring TX descriptors in code or hardware API implementations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/rocker.txt#_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\nfield\t\t\twidth\tdescription\\n---------------------------------------------------------------------\\nPPORT\t\t\t4\tDestination physical port #\\nTX_OFFLOAD\t\t1\tHardware offload modes:\\n\t\t\t\t  0: no offload\\n\t\t\t\t  1: insert IP csum (ipv4 only)\\n\t\t\t\t  2: insert TCP/UDP csum\\n\t\t\t\t  3: L3 csum calc and insert\\n                         \\t\\t             into csum offset (TX_L3_CSUM_OFF)\\n                  \\t\\t            16-bit 1's complement csum value.\\n                                 \\t     IPv4 pseudo-header and IP\\n                         \\t\\t             already calculated by OS\\n                   \\t\\t           and inserted.\\n\t\t\t\t  4: TSO (TCP Segmentation Offload)\\nTX_L3_CSUM_OFF\\t\\t2\\tFor L3 csum offload mode, the offset,\\n\\t\\t\\t\\tfrom the beginning of the packet,\\n\\t\\t\\t\\tof the csum field in the L3 header\\nTX_TSO_MSS\\t\\t2\\tFor TSO offload mode, the\\n\\t\\t\\t\\tMaximum Segment Size in bytes\\nTX_TSO_HDR_LEN\\t\\t2\\tFor TSO offload mode, the\\n\\t\\t\\t\\tlength of ethernet, IP, and\\n\\t\\t\\t\\tTCP/UDP headers, including IP\\n\\t\\t\\t\\tand TCP options.\\nTX_FRAGS\\t\\t<array>\\tPacket fragments\\n  TX_FRAG\\t\\t<nest>\\tPacket fragment\\n    TX_FRAG_ADDR\\t8\\tDMA address of packet fragment\\n    TX_FRAG_LEN\\t2\\tPacket fragment length\n```\n\n----------------------------------------\n\nTITLE: Configuring Virtio Console Devices with Port Mapping (QEMU CLI, Shell)\nDESCRIPTION: Shows two-stage virtio-serial-pci/virtconsole configuration, including PCI class, vector, ioeventfd, port count, and virtconsole properties. Inputs are CLI lines specifying virtio and console options. Used for advanced virtio I/O and console mapping. QEMU required.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n-device virtio-serial-pci,class=C,vectors=V,ioeventfd=IOEVENTFD,max_ports=N\n-device virtconsole,is_console=NUM,nr=NR,name=NAME\n```\n\n----------------------------------------\n\nTITLE: Setting QEMU Cache Clean Interval for Memory Reduction - Shell\nDESCRIPTION: This shell snippet shows how to set the cache-clean-interval option via QEMU's -drive parameter, configuring automatic purging of unused cache entries after a specified interval in seconds. In the example, the interval is 900 seconds (15 minutes). This helps reduce memory usage during idle periods, but actual memory reclamation depends on Linux's MADV_DONTNEED feature. The parameter is ignored on non-Linux platforms. Requires QEMU 2.2+.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qcow2-cache.txt#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n-drive file=hd.qcow2,cache-clean-interval=900\n```\n\n----------------------------------------\n\nTITLE: Basic Block Stream Command in QEMU\nDESCRIPTION: Example of streaming data from backing files into the active image using block_stream command with a file parameter.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/live-block-ops.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n(qemu) block_stream virtio0 file-A.img\n```\n\n----------------------------------------\n\nTITLE: Reading Guest Memory via Address Translation and Debugger - Python and GDB\nDESCRIPTION: This workflow demonstrates how to read guest memory by translating a guest virtual address to guest physical, locating the memory region, and retrieving a host pointer using GDB. The steps involve using the PANDA API function 'panda_virt_to_phys', followed by evaluating C functions like 'memory_region_find' within the GDB debugger to fetch region names, host RAM pointers, and offsets. Finally, host memory is accessed with a GDB print command to examine guest data. This process depends on PANDA's in-memory object layout and requires GDB access to the emulator process for inspection.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/src/rr/README.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npanda_virt_to_phys(current_cpu, ZZZ)\n```\n\n----------------------------------------\n\nTITLE: Applying Grouped IOPS Limits to Multiple Drives - Shell\nDESCRIPTION: This multi-line snippet showcases assigning several QEMU drives into groups using the throttling.group parameter, allowing them to share combined IOPS limits. Drives with the same group name share the same IOPS cap, while devices omitted from a group act independently. The shell syntax is used for QEMU command-line; input is a set of -drive statements, and output is enforced group throttling.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/throttle.txt#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n-drive file=hd1.qcow2,throttling.iops-total=6000,throttling.group=foo\n-drive file=hd2.qcow2,throttling.iops-total=6000,throttling.group=foo\n-drive file=hd3.qcow2,throttling.iops-total=3000,throttling.group=bar\n-drive file=hd4.qcow2,throttling.iops-total=6000,throttling.group=foo\n-drive file=hd5.qcow2,throttling.iops-total=3000,throttling.group=bar\n-drive file=hd6.qcow2,throttling.iops-total=5000\n```\n\n----------------------------------------\n\nTITLE: Adding Classic USB Bulk-only Storage Device - QEMU - Shell\nDESCRIPTION: This snippet demonstrates how to attach a classic bulk-only USB mass storage emulation ('usb-storage') to QEMU, typically representing a standard USB flash drive. It requires QEMU installed and an image file to use as the storage medium. Key parameters include the VM arguments, drive ID/file, USB controller device, and the usb-storage device binding the image. The output is a VM with an attached emulated USB storage device; supported by most guest OSes.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/usb-storage.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nqemu ${other_vm_args}                                \\\n     -drive if=none,id=stick,file=/path/to/file.img  \\\n     -device nec-usb-xhci,id=xhci                    \\\n     -device usb-storage,bus=xhci.0,drive=stick\n```\n\n----------------------------------------\n\nTITLE: Creating Virtio Block Devices with PCI Parameters (QEMU CLI, Shell)\nDESCRIPTION: Illustrates allocation of a PCI-attached virtio block deviceâ€”controlling class, MSI-X vectors, and optionally using ioeventfd. Adjustable via class, vectors, and ioeventfd parameters. Appropriate for advanced QEMU setups requiring virtual PCI configuration. Requires QEMU. Input: CLI string; effect is custom PCI virtio block device configuration.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n-device virtio-blk-pci,drive=DRIVE-ID,class=C,vectors=V,ioeventfd=IOEVENTFD\n```\n\n----------------------------------------\n\nTITLE: Installing NSS and Build Dependencies - Shell\nDESCRIPTION: This sequence demonstrates the installation of the required NSS development libraries required for cryptographic operations in QEMU's smart card functionality. Supported for Red Hat/Fedora and Ubuntu/Debian systems, the commands prepare the environment prior to building QEMU with smart card support. These shell commands must be run with sufficient privileges and may require internet access for package fetching. Inputs are the respective operating system environments, and output is the installation of system packages.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/ccid.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyum install nss-devel\n```\n\nLANGUAGE: shell\nCODE:\n```\napt-get install libnss3-dev\n# (not tested on ubuntu)\n```\n\n----------------------------------------\n\nTITLE: Producing an LLVM Execution Trace with PANDA via Shell Command\nDESCRIPTION: This shell command uses PANDA to execute a replay in LLVM mode with the llvm_trace plugin. It captures the dynamic LLVM code and logs it for later analysis, outputting the files llvm-mod.bc and tubtf.log in the specified output directory. Prerequisites include a built PANDA instance for the target architecture, a valid replay, and PANDA plugins configured correctly. Key parameters are the architecture name, replay identifier, and output directory location; enabling tubt=1 triggers the TUBTF binary trace recording mode. The output files are used for downstream slicing analysis.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/dynslice.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncd <arch>-softmmu\n./panda-system-<arch> -replay <replay> -panda 'llvm_trace:tubt=1,base=<output_dir>'\n```\n\n----------------------------------------\n\nTITLE: Triggering Use-After-Free Bug via HTML/JavaScript in Internet Explorer\nDESCRIPTION: This HTML/JavaScript snippet constructs a web page meant to expose potential use-after-free issues in Internet Explorer by dynamically clearing element contents and invoking explicit garbage collection. It requires an environment where Internet Explorer's legacy features, such as the `CollectGarbage()` function and time-based elements, are available. The code initializes a div, manipulates its contents, and reloads the page. Inputs include the user loading the page in the targeted browser; outputs are the triggered browser-side actions, potentially exposing memory safety issues when analyzed with external tooling. It is mainly constrained by dependency on Internet Explorer-specific features and ActiveX behaviors, making it unlikely to function as intended in modern browsers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/UAF.md#_snippet_11\n\nLANGUAGE: html\nCODE:\n```\n<?IMPORT namespace=\\\"t\\\" implementation=\\\"#default#time2\\\">\\n<body>\\n<div id=\\\"x\\\" contenteditable=\\\"true\\\">\\nHELLOWORLD\\n<t:TRANSITIONFILTER></t:TRANSITIONFILTER>\\n<script>\\n   document.getElementById(\\\"x\\\").innerHTML = \\\"\\\";\\n   CollectGarbage();\\n   window.onclick;\\n   document.location.reload();\\n</script>\\n</div>\\n</body>\\n</HTML>\n```\n\n----------------------------------------\n\nTITLE: Configuring State Transitions for Targeted Error Injection - INI - ini\nDESCRIPTION: This INI-style configuration demonstrates the use of multiple rules to manage an internal state machine within blkdebug. One rule transitions the internal state after a matching write_aio operation, and another injects an EIO (errno 5) error once the engine enters the specified state. This pattern is useful for injecting errors based on precise sequences of block I/O, and requires knowledge of the engine's state progression.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/blkdebug.txt#_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\n[set-state]\nevent = \"write_aio\"\nstate = \"1\"\nnew_state = \"2\"\n\n[inject-error]\nevent = \"write_aio\"\nstate = \"2\"\nerrno = \"5\"\n\n```\n\n----------------------------------------\n\nTITLE: Querying Block Statistics with QAPI Command - JSON\nDESCRIPTION: Defines a QAPI command named 'query-blockstats' that requests block statistics. The command requires a 'data' dictionary, supporting the optional boolean '*query-nodes', and specifies it returns an array of 'BlockStats'. Dependencies include predefined 'BlockStats' types and QAPI schema validation, and input/output follows QAPI wire format constraints.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{ 'command': 'query-blockstats',\n  'data': { '*query-nodes': 'bool' },\n  'returns': ['BlockStats'] }\n```\n\n----------------------------------------\n\nTITLE: Setting QEMU Graphics Devices with -device (QEMU CLI, Shell)\nDESCRIPTION: Lists -device commands for selecting a guest graphics adapter corresponding to legacy -vga options in QEMU. Each model (std, cirrus, vmware) is mapped to its -device form. Input is chosen CLI arg; effect is correct VGA device presented to guest VM.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n-device VGA\n-device cirrus-vga\n-device vmware-svga\n```\n\n----------------------------------------\n\nTITLE: Calculating Cluster Mapping for QCOW2 Images - Pseudo-code\nDESCRIPTION: This pseudo-code demonstrates how to determine the offset of a virtual disk address within a QCOW2 image file by traversing its two-level cluster mapping structure (L1 and L2 tables). It illustrates the mathematical relationship between cluster size, L1/L2 indices, and file offsets, which must be implemented accurately in image parsing tools. The calculation relies on cluster size and assumes the presence of helper functions like load_cluster(). The inputs are the virtual disk offset and cluster size; the output is the resolved host cluster offset for the given virtual address.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/qcow2.txt#_snippet_1\n\nLANGUAGE: pseudo-code\nCODE:\n```\nl2_entries = (cluster_size / sizeof(uint64_t))\n\nl2_index = (offset / cluster_size) % l2_entries\nl1_index = (offset / cluster_size) / l2_entries\n\nl2_table = load_cluster(l1_table[l1_index]);\ncluster_offset = l2_table[l2_index];\n\nreturn cluster_offset + (offset % cluster_size)\n\n```\n\n----------------------------------------\n\nTITLE: Adjusting COLO Checkpoint Delay\nDESCRIPTION: This QMP command allows changing the checkpoint period time for the COLO process, which affects how often the primary VM state is synchronized with the secondary VM.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/COLO-FT.txt#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{ \"execute\": \"migrate-set-parameters\" , \"arguments\":{ \"x-checkpoint-delay\": 2000 } }\n```\n\n----------------------------------------\n\nTITLE: Host USB Device Assignment in QEMU\nDESCRIPTION: Shows the syntax for assigning host USB devices to QEMU guests, comparing old -usbdevice syntax with new -device syntax. Includes options for matching devices by bus, address, vendor ID, and product ID.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qdev-device-use.txt#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n-usbdevice host:auto:BUS.ADDR:VID:PRID\n```\n\nLANGUAGE: bash\nCODE:\n```\n-device usb-host,hostbus=BUS,hostaddr=ADDR,vendorid=VID,productid=PRID\n```\n\n----------------------------------------\n\nTITLE: Describing Port Settings and Status - Markdown\nDESCRIPTION: This snippet summarizes port status and configurable properties in Markdown tables for both get/set operations. It specifies each field's name, byte width, and description, thus providing a schema for DMA command descriptors and their completion outputs. This documentation assists developers in constructing proper command packets for driver-device communication. Understanding TLV/descriptor layouts is required, and the snippet assumes familiarity with device data structures.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/rocker.txt#_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n    field       width   description\n    ----------------------------------------------\n    PORT_SETTINGS   2   CMD_GET\n    PPORT       4   Physical port #\n\n    field       width   description\n    ----------------------------------------------\n    PPORT       4   Physical port #\n    SPEED       4   Current port interface speed, in Mbps\n    DUPLEX      1   1 = Full, 0 = Half\n    AUTONEG     1   1 = enabled, 0 = disabled\n    MACADDR     6   Port MAC address\n    MODE        1   0 = OF-DPA\n    LEARNING    1   MAC address learning on port\n                        1 = enabled\n                        0 = disabled\n    PHYS_NAME   <var>   Physical port name (string)\n\n    field       width   description\n    ----------------------------------------------\n    PORT_SETTINGS   2   CMD_SET\n    PPORT       4   Physical port #\n    SPEED       4   Port interface speed, in Mbps\n    DUPLEX      1   1 = Full, 0 = Half\n    AUTONEG     1   1 = enabled, 0 = disabled\n    MACADDR     6   Port MAC address\n    MODE        1   0 = OF-DPA\n\n```\n\n----------------------------------------\n\nTITLE: Configuring QEMU RAM Hotplug Slots and Max Memory - Shell\nDESCRIPTION: This shell snippet shows a QEMU command-line example configuring a VM with 1GB RAM, three hotpluggable memory slots, and an upper memory limit of 4GB. It demonstrates setting the memory parameters with the -m option, which controls startup RAM, slot count for memory devices, and the total potential memory for hotplug. All hardware sizing is handled by QEMU without extra dependencies outside of installed QEMU. Arguments replaced by ellipsis may need to be set as appropriate for your instance.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/memory-hotplug.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nqemu [...] 1G,slots=3,maxmem=4G\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Requirements - requirements.txt - plaintext\nDESCRIPTION: This snippet lists three Python packages (cffi, protobuf, colorama) with version constraints for cffi and protobuf, and no minimum version for colorama. Intended for use with the Python package manager pip, these dependencies ensure that the project and its scripts are executed in a consistent environment. The file uses standard requirements.txt syntax and should be placed in the root of the Python project; compatible with pip and related Python tooling.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/core/requirements.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ncffi>=1.14.3\nprotobuf>=4.25.1\ncolorama\n```\n\n----------------------------------------\n\nTITLE: YARA Rule Definition for LIGHTWORK Malware Detection\nDESCRIPTION: YARA rule from Mandiant for detecting IEC-104 related strings in LIGHTWORK malware. Includes specific string patterns and PE file structure validation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/examples/yara-rules/README.md#_snippet_0\n\nLANGUAGE: yara\nCODE:\n```\nrule M_Hunting_Disrupt_LIGHTWORK_Strings\n{\n     meta:\n          author = \"Mandiant\"\n          description = \"Searching for strings associated with IEC-104 used in LIGHTWORK.\"\n          date = \"2023-04-19\"\n\n     strings:\n          $s1 = \"Connecting to: %s:%i\\n\" ascii wide nocase\n          $s2 = \"Connected!\" ascii wide nocase\n          $s3 = \"Send control command C_SC_NA_1\" ascii wide nocase\n          $s4 = \"Connect failed!\" ascii wide nocase\n          $s5 = \"Send time sync command\" ascii wide nocase\n          $s6 = \"Wait ...\" ascii wide nocase\n          $s7 = \"exit 0\" ascii wide nocase\n\n     condition:\n          filesize < 5MB and\n          uint16(0) == 0x5A4D and uint32(uint32(0x3C)) == 0x00004550 and\n          all of them\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Alarm Methods via QAPI in C\nDESCRIPTION: Implements the QMP command handler qmp_query_alarm_methods, which builds and returns a linked list (TimerAlarmMethodList) of available alarm timer methods. Requires QEMU platform, QAPI-generated structures, and dynamic memory allocation utilities (g_malloc0, g_strdup). Inputs: Error pointer for error reporting. Outputs: Head of a linked TimerAlarmMethodList where the first element indicates the current method. Constraints: Manual management of QAPI list node allocations and content, awareness of the alarm_timers array, and proper handling of the 'current' flag for the active method.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/writing-qmp-commands.txt#_snippet_15\n\nLANGUAGE: C\nCODE:\n```\nTimerAlarmMethodList *qmp_query_alarm_methods(Error **errp)\n{\n    TimerAlarmMethodList *method_list = NULL;\n    const struct qemu_alarm_timer *p;\n    bool current = true;\n\n    for (p = alarm_timers; p->name; p++) {\n        TimerAlarmMethodList *info = g_malloc0(sizeof(*info));\n        info->value = g_malloc0(sizeof(*info->value));\n        info->value->method_name = g_strdup(p->name);\n        info->value->current = current;\n\n        current = false;\n\n        info->next = method_list;\n        method_list = info;\n    }\n\n    return method_list;\n}\n```\n\n----------------------------------------\n\nTITLE: Powerdown Event Example in QMP\nDESCRIPTION: Illustrates an example of a POWERDOWN event in QMP, including the event timestamp.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qmp-spec.txt#_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{ \"timestamp\": { \"seconds\": 1258551470, \"microseconds\": 802384 }, \"event\": \"POWERDOWN\" }\n```\n\n----------------------------------------\n\nTITLE: SchemaInfo for Flat Union with Tag and Variants - JSON\nDESCRIPTION: This SchemaInfo example shows a union type object ('BlockdevOptions') with a tag field ('driver') and multiple variant cases mapping to subtypes. Clients use the 'driver' field value to identify and validate which variant's schema applies to the wire data. Optional fields (e.g., 'read-only') use the 'default' property to indicate their status.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n{ \\\"name\\\": \\\"BlockdevOptions\\\", \\\"meta-type\\\": \\\"object\\\",\\n  \\\"members\\\": [\\n      { \\\"name\\\": \\\"driver\\\", \\\"type\\\": \\\"BlockdevDriver\\\" },\\n      { \\\"name\\\": \\\"read-only\\\", \\\"type\\\": \\\"bool\\\", \\\"default\\\": null } ],\\n  \\\"tag\\\": \\\"driver\\\",\\n  \\\"variants\\\": [\\n      { \\\"case\\\": \\\"file\\\", \\\"type\\\": \\\"BlockdevOptionsFile\\\" },\\n      { \\\"case\\\": \\\"qcow2\\\", \\\"type\\\": \\\"BlockdevOptionsQcow2\\\" } ] }\n```\n\n----------------------------------------\n\nTITLE: Setting IOPS Burst Via QMP - JSON\nDESCRIPTION: This snippet details the QMP method to configure a device to allow both sustained and burst IOPS rates using the block_set_io_throttle command. Core parameters include iops (100) for sustained throughput, and iops_max (2000) plus iops_max_length (60) for burst period. All other limits default to unlimited. Requires QEMU QMP session; applies burst logic as soon as parameters are set.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/throttle.txt#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"execute\": \"block_set_io_throttle\",\n  \"arguments\": {\n    \"device\": \"virtio0\",\n    \"iops\": 100,\n    \"iops_rd\": 0,\n    \"iops_wr\": 0,\n    \"bps\": 0,\n    \"bps_rd\": 0,\n    \"bps_wr\": 0,\n    \"iops_max\": 2000,\n    \"iops_max_length\": 60\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Reading and Cleaning Up List Elements with QemuLockCnt and RCU in C\nDESCRIPTION: This code demonstrates safe iteration and cleanup over a list protected by QemuLockCnt in a concurrent environment. It first increments the reference count and walks the list with QLIST_FOREACH_RCU to allow concurrent additions, then on final dec/lock, safely removes and frees deleted nodes. This pattern expects QEMU's QLIST, QemuLockCnt, and RCU APIs, and GLib memory management.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/lockcnt.txt#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nqemu_lockcnt_inc(&io_handlers_lockcnt);\nQLIST_FOREACH_RCU(ioh, &io_handlers, pioh) {\n    if (ioh->revents & G_IO_OUT) {\n        ioh->fd_write(ioh->opaque);\n    }\n}\n\nif (qemu_lockcnt_dec_and_lock(&io_handlers_lockcnt)) {\n    QLIST_FOREACH_SAFE(ioh, &io_handlers, next, pioh) {\n        if (ioh->deleted) {\n            QLIST_REMOVE(ioh, next);\n            g_free(ioh);\n        }\n    }\n    qemu_lockcnt_unlock(&io_handlers_lockcnt);\n}\n```\n\n----------------------------------------\n\nTITLE: Logical to Cluster Offset Translation in Python\nDESCRIPTION: Python function demonstrating how logical offsets are translated to cluster offsets in the QED format using L1 and L2 tables.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/qed_spec.txt#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\noffset_mask = ~(cluster_size - 1) # mask for the image file byte offset\n\ndef logical_to_cluster_offset(l1_index, l2_index, byte_offset):\n  l2_offset = l1_table[l1_index]\n  l2_table = load_table(l2_offset)\n  cluster_offset = l2_table[l2_index] & offset_mask\n  return cluster_offset + byte_offset\n```\n\n----------------------------------------\n\nTITLE: Running OSI_Test via PANDA-System (Shell Command) - sh\nDESCRIPTION: This snippet demonstrates how to launch PANDA with the osi_test plugin on a Windows 7 32-bit replay using a shell command. Before running this, ensure PANDA is installed and $PANDA_PATH points to your PANDA build directory. This command assumes your replay and plugin paths are correctly set and that the appropriate OS and introspection plugins are available. Inputs include the path to the replay trace and the OS identifier; the output will be a PANDA session with osi_test activated.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/osi_test/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n  $PANDA_PATH/i386-softmmu/panda-system-i386 -replay mytrace \\\n    -os windows-32-7sp1 -panda osi_test\n```\n\n----------------------------------------\n\nTITLE: Storing Volatile Values and Performing Instrumented Loads - LLVM IR\nDESCRIPTION: This code keeps track of program state via volatile stores and logs, updating environment variables and memory addresses with PANDA log helpers. It includes a call to the __ldl_mmu_panda helper to load an i32 value, whose result is zero-extended for storage or use. It expects prior address computation and value updates, and outputs modified state and memory for use in dynamic translation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/dynslice.md#_snippet_13\n\nLANGUAGE: llvm\nCODE:\n```\nstore volatile i64 45, i64* inttoptr (i64 29287216 to i64*)\nstore volatile i64 1958292464, i64* inttoptr (i64 29287224 to i64*), !pcupdate.md !0\n```\n\nLANGUAGE: llvm\nCODE:\n```\n%53 = add i64 %env_v, 56032\n%54 = inttoptr i64 %53 to i64*\n%55 = ptrtoint i64* %54 to i64\ncall void @log_dynval(i64 59634320, i32 0, i32 2, i64 %55)\nstore i64 1958292464, i64* %54\n```\n\nLANGUAGE: llvm\nCODE:\n```\n%56 = add i64 %env_v, 56016\n%57 = inttoptr i64 %56 to i64*\n%58 = ptrtoint i64* %57 to i64\ncall void @log_dynval(i64 59634320, i32 0, i32 0, i64 %58)\n%tmp12_v15 = load i64* %57\n%tmp12_v16 = add i64 %tmp12_v15, 1\n%59 = add i64 %env_v, 56016\n%60 = inttoptr i64 %59 to i64*\n%61 = ptrtoint i64* %60 to i64\ncall void @log_dynval(i64 59634320, i32 0, i32 2, i64 %61)\nstore i64 %tmp12_v16, i64* %60\n%62 = call i32 @__ldl_mmu_panda(i64 1958221188, i32 1)\n%tmp0_v17 = zext i32 %62 to i64\n```\n\n----------------------------------------\n\nTITLE: Defining Optional Python Dependencies for PANDA Examples\nDESCRIPTION: Lists required Python packages for running PANDA RE framework examples. These packages are not installed by default during setup.py installation but can be installed using pip with the requirements.txt file.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/python/examples/requirements.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nscapy\nnumpy\npyelftools\ncapstone\n```\n\n----------------------------------------\n\nTITLE: Flow Table ID 30: Unicast Routing Table Structure - Technical Table - plaintext\nDESCRIPTION: Describes the TLV fields and sizes for matching on unicast IPv4/IPv6 destinations in the unicast routing OF-DPA table (tableID=30), including prefix mask handling. To be used in hardware programming by controller agent. Key fields: ethertype, IP address/mask, goto, group ID.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/rocker.txt#_snippet_13\n\nLANGUAGE: plaintext\nCODE:\n```\nfield\\t\\t\\t\\twidth\\tdescription\\n----------------------------------------------------\\nOF_DPA_ETHERTYPE\\t\\t2 (N)\\tmust be either 0x0800 or 0x86dd\\nOF_DPA_DST_IP\\t\\t4 (N)\\tdestination IPv4 address.\\n\\t\\t\\t\\tMust be unicast address\\nOF_DPA_DST_IP_MASK\\t\\t4 (N)\\tIP mask.  Must be prefix mask\\nOF_DPA_DST_IPV6\\t\\t16 (N)\\tdestination IPv6 address.\\n\\t\\t\\t\\tMust be unicast address\\nOF_DPA_DST_IPV6_MASK\\t\\t16 (N)\\tIPv6 mask. Must be prefix mask\\nOF_DPA_GOTO_TBL\\t\\t2\\tgoto table ID; zero to drop\\nOF_DPA_GROUP_ID\\t\\t4\\tdata for GROUP action must\\n\\t\\t\\t\\tbe an L3 Unicast group entry\n```\n\n----------------------------------------\n\nTITLE: Dumping RR Log Data with rr_print Tool - Shell\nDESCRIPTION: This shell command runs the rr_print utility (with architecture-specific suffix) to parse and display the contents of a nondeterministic log file, such as 'dd-rr-nondet.log', generated by record-replay systems in PANDA. The command prints log metadata and event entries, including guest instruction counts and interrupt/input records, which are crucial for debugging execution flows. The tool should be present in the build directory and may require architecture-specific binaries.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/src/rr/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrr_print_[arch] [infile]\n```\n\n----------------------------------------\n\nTITLE: Installing libosi Dependencies\nDESCRIPTION: Packages required for installing libosi, which is likely a library used in the PANDA project. Includes build tools and a JSON parsing library.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/dependencies/ubuntu_18.04_build.txt#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# libosi install deps\ncmake\nninja-build\nrapidjson-dev\n```\n\n----------------------------------------\n\nTITLE: Installing pypanda Dependencies\nDESCRIPTION: Packages required for building and running pypanda, the Python interface for PANDA. Includes both runtime and test dependencies.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/dependencies/ubuntu_18.04_build.txt#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# pypanda dependencies\npython3-setuptools\npython3-wheel\n\n# pypanda test dependencies\ngcc-multilib\nlibc6-dev-i386\nnasm\n```\n\n----------------------------------------\n\nTITLE: Windows NT System Call Declarations\nDESCRIPTION: Declarations of core Windows NT system calls used for low-level system operations. These functions represent the native API layer between user mode and kernel mode operations in Windows NT systems.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp0_x64_prototypes.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtWorkerFactoryWorkerReady (HANDLE WorkerFactoryHandle);\nNTSTATUS NtMapUserPhysicalPagesScatter (PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtWaitForSingleObject (HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtCallbackReturn (PVOID OutputBuffer, ULONG OutputLength, NTSTATUS Status);\nNTSTATUS NtReadFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtDeviceIoControlFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\n// ... Additional 64 system call declarations omitted for brevity ...\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic PANDA PyPlugin Class in Python\nDESCRIPTION: Defines a simple PyPlugin subclass that initializes with a message, sets a single callback on block execution to print and then disables itself, and provides an optional cleanup lifecycle via uninit. Requires the pandare Python package and expects to be managed by PANDA's plugin system. No input/output parameters are defined other than those provided by PANDA callback interfaces.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/pyplugins.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pandare import PyPlugin\n\nclass TestPlugin(PyPlugin):\n    def __init__(self, panda):\n        print(\"Initialized test plugin\")\n        \n        @panda.cb_before_block_exec\n        def test_before_block(cpustate, transblock):\n            print(\"Running test plugin\")\n            panda.disable_callback('test_before_block')\n\n    def uninit(self):\n        print(\"Uninitialized test plugin\")\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows Native API Functions for System Operations in C\nDESCRIPTION: This snippet contains function declarations for various Windows Native API calls, including process creation, thread management, file operations, and system information queries. These functions are part of the internal Windows API and provide low-level access to system resources.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp0_x64_prototypes.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtCreateEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);\nNTSTATUS NtQueryVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);\nNTSTATUS NtFlushBuffersFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtApphelpCacheControl (APPHELPCOMMAND type, PVOID buf);\nNTSTATUS NtCreateProcessEx (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel);\nNTSTATUS NtCreateThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended);\nNTSTATUS NtIsProcessInJob (HANDLE ProcessHandle, HANDLE JobHandle);\nNTSTATUS NtProtectVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, WIN32_PROTECTION_MASK NewProtectWin32, PULONG OldProtect);\nNTSTATUS NtQuerySection (HANDLE SectionHandle, SECTION_INFORMATION_CLASS SectionInformationClass, PVOID SectionInformation, SIZE_T SectionInformationLength, PSIZE_T ReturnLength);\nNTSTATUS NtResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtTerminateThread (HANDLE ThreadHandle, NTSTATUS ExitStatus);\nNTSTATUS NtReadRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtCreateFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);\nNTSTATUS NtQueryEvent (HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ReturnLength);\nNTSTATUS NtWriteRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);\nNTSTATUS NtOpenDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtAccessCheckByTypeAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtWaitForMultipleObjects (ULONG Count, HANDLE Handles[], WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtSetInformationObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength);\nNTSTATUS NtCancelIoFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\nNTSTATUS NtTraceEvent (HANDLE TraceHandle, ULONG Flags, ULONG FieldSize, PVOID Fields);\nNTSTATUS NtPowerInformation (POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);\nNTSTATUS NtSetValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);\nNTSTATUS NtCancelTimer (HANDLE TimerHandle, PBOOLEAN CurrentState);\nNTSTATUS NtSetTimer (HANDLE TimerHandle, PLARGE_INTEGER DueTime, PTIMER_APC_ROUTINE TimerApcRoutine, PVOID TimerContext, BOOLEAN WakeTimer, LONG Period, PBOOLEAN PreviousState);\nNTSTATUS NtAcceptConnectPort (PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView);\nNTSTATUS NtAccessCheck (PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByType (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByTypeResultList (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarmByHandle (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAddBootEntry (PBOOT_ENTRY BootEntry, PULONG Id);\nNTSTATUS NtAddDriverEntry (PEFI_DRIVER_ENTRY DriverEntry, PULONG Id);\nNTSTATUS NtAdjustGroupsToken (HANDLE TokenHandle, BOOLEAN ResetToDefault, PTOKEN_GROUPS NewState, ULONG BufferLength, PTOKEN_GROUPS PreviousState, PULONG ReturnLength);\nNTSTATUS NtAlertResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtAlertThread (HANDLE ThreadHandle);\nNTSTATUS NtAllocateLocallyUniqueId (PLUID Luid);\nNTSTATUS NtAllocateReserveObject (PHANDLE MemoryReserveHandle, POBJECT_ATTRIBUTES ObjectAttributes, MEMORY_RESERVE_TYPE Type);\nNTSTATUS NtAllocateUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\nNTSTATUS NtAllocateUuids (PULARGE_INTEGER Time, PULONG Range, PULONG Sequence, PCHAR Seed);\nNTSTATUS NtAlpcAcceptConnectPort (PHANDLE PortHandle, HANDLE ConnectionPortHandle, ULONG Flags, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes, BOOLEAN AcceptConnection);\nNTSTATUS NtAlpcCancelMessage (HANDLE PortHandle, ULONG Flags, PALPC_CONTEXT_ATTR MessageContext);\nNTSTATUS NtAlpcConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, ULONG Flags, PSID RequiredServerSid, PPORT_MESSAGE ConnectionMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes, PALPC_MESSAGE_ATTRIBUTES InMessageAttributes, PLARGE_INTEGER Timeout);\nNTSTATUS NtAlpcCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes);\nNTSTATUS NtAlpcCreatePortSection (HANDLE PortHandle, ULONG Flags, HANDLE SectionHandle, SIZE_T SectionSize, PALPC_HANDLE AlpcSectionHandle, PSIZE_T ActualSectionSize);\nNTSTATUS NtAlpcCreateResourceReserve (HANDLE PortHandle, ULONG Flags, SIZE_T MessageSize, PALPC_HANDLE ResourceId);\nNTSTATUS NtAlpcCreateSectionView (HANDLE PortHandle, ULONG Flags, PALPC_DATA_VIEW_ATTR ViewAttributes);\nNTSTATUS NtAlpcCreateSecurityContext (HANDLE PortHandle, ULONG Flags, PALPC_SECURITY_ATTR SecurityAttribute);\nNTSTATUS NtAlpcDeletePortSection (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE SectionHandle);\nNTSTATUS NtAlpcDeleteResourceReserve (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ResourceId);\nNTSTATUS NtAlpcDeleteSectionView (HANDLE PortHandle, ULONG Flags, PVOID ViewBase);\nNTSTATUS NtAlpcDeleteSecurityContext (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);\nNTSTATUS NtAlpcDisconnectPort (HANDLE PortHandle, ULONG Flags);\nNTSTATUS NtAlpcImpersonateClientOfPort (HANDLE PortHandle, PPORT_MESSAGE PortMessage, PVOID Reserved);\nNTSTATUS NtAlpcOpenSenderProcess (PHANDLE ProcessHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtAlpcOpenSenderThread (PHANDLE ThreadHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\nNTSTATUS NtAlpcQueryInformation (HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtAlpcQueryInformationMessage (HANDLE PortHandle, PPORT_MESSAGE PortMessage, ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass, PVOID MessageInformation, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtAlpcRevokeSecurityContext (HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);\n```\n\n----------------------------------------\n\nTITLE: Windows NT System Call Security Access Check Functions\nDESCRIPTION: Function prototypes for NT security access checking and auditing operations. These system calls handle security descriptor validation, access right checks, and security auditing functionality within the Windows NT kernel.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_8sp0_x86_prototypes.txt#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarmByHandle (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheckByTypeResultList (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByTypeAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheckByType (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheck (PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAcceptConnectPort (PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView);\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Reclamation with call_rcu in C\nDESCRIPTION: This example shows how to schedule object reclamation with call_rcu, improving performance over synchronize_rcu by deferring object deletion until it is safe. It depends on qemu_mutex_lock, atomic_rcu_set, qemu_mutex_unlock, and call_rcu. Inputs are the mutex, pointers, and a callback. Outputs are eventual invocation of foo_unref on the old object. Suitable when object destruction can be postponed post-RCU grace period.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/rcu.txt#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nqemu_mutex_lock(&foo_mutex);\nold = foo;\natomic_rcu_set(&foo, new);\nqemu_mutex_unlock(&foo_mutex);\ncall_rcu(foo_unref, old, rcu);\n```\n\n----------------------------------------\n\nTITLE: Declaring a Callback for CPU Exec Exit Event - C\nDESCRIPTION: Defines the before_cpu_exec_exit callback signature, intended for invocation before cpu_exec calls cpu_exec_exit. It takes CPUState pointer and a boolean ranBlock to indicate if a block has run since last entry. The function doesn't return a value, and is used for pre-exit instrumentation or state checks; inputs are CPUState and a run indicator, requiring PANDA structures to be in scope.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_57\n\nLANGUAGE: C\nCODE:\n```\nint before_cpu_exec_exit(CPUState *env, bool ranBlock);\n```\n\n----------------------------------------\n\nTITLE: Declaring Query and Set Native API Functions - Windows NT - C\nDESCRIPTION: This snippet declares a list of NTSTATUS-returning C functions using the NT Native API for querying and setting attributes of various kernel objects. Each function specifies typed handles and data structures relevant to the resource being manipulated, employing the Windows-specific types (e.g., HANDLE, PUNICODE_STRING, PIO_STATUS_BLOCK). These declarations require inclusion of corresponding NT system headers and are intended for use in low-level kernel modules or advanced system utilities. Inputs typically include handles, classification enums, buffers, and sizes; outputs are via pointers or direct return status. No macro definitions or implementations are present, and error handling depends on NTSTATUS codes returned by the functions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x64_prototypes.txt#_snippet_25\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtQueryInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationTransactionManager (HANDLE TransactionManagerHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryInstallUILanguage (LANGID *InstallUILanguageId);\nNTSTATUS NtQueryIntervalProfile (KPROFILE_SOURCE ProfileSource, PULONG Interval);\nNTSTATUS NtQueryIoCompletion (HANDLE IoCompletionHandle, IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass, PVOID IoCompletionInformation, ULONG IoCompletionInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryLicenseValue (PUNICODE_STRING Name, PULONG Type, PVOID Buffer, ULONG Length, PULONG ReturnedLength);\nNTSTATUS NtQueryMultipleValueKey (HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength);\nNTSTATUS NtQueryMutant (HANDLE MutantHandle, MUTANT_INFORMATION_CLASS MutantInformationClass, PVOID MutantInformation, ULONG MutantInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryOpenSubKeys (POBJECT_ATTRIBUTES TargetKey, PULONG HandleCount);\nNTSTATUS NtQueryOpenSubKeysEx (POBJECT_ATTRIBUTES TargetKey, ULONG BufferLength, PVOID Buffer, PULONG RequiredSize);\nNTSTATUS NtQueryPortInformationProcess ();\nNTSTATUS NtQueryQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID SidList, ULONG SidListLength, PULONG StartSid, BOOLEAN RestartScan);\nNTSTATUS NtQuerySecurityAttributesToken (HANDLE TokenHandle, PUNICODE_STRING Attributes, ULONG NumberOfAttributes, PVOID Buffer, ULONG Length, PULONG ReturnLength);\nNTSTATUS NtQuerySecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Length, PULONG LengthNeeded);\nNTSTATUS NtQuerySemaphore (HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG SemaphoreInformationLength, PULONG ReturnLength);\nNTSTATUS NtQuerySymbolicLinkObject (HANDLE LinkHandle, PUNICODE_STRING LinkTarget, PULONG ReturnedLength);\nNTSTATUS NtQuerySystemEnvironmentValue (PUNICODE_STRING VariableName, PWSTR VariableValue, USHORT ValueLength, PUSHORT ReturnLength);\nNTSTATUS NtQuerySystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, PULONG ValueLength, PULONG Attributes);\nNTSTATUS NtQuerySystemInformationEx (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID QueryInformation, ULONG QueryInformationLength, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);\nNTSTATUS NtQueryTimerResolution (PULONG MaximumTime, PULONG MinimumTime, PULONG CurrentTime);\nNTSTATUS NtQueueApcThreadEx (HANDLE ThreadHandle, HANDLE UserApcReserveHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);\nNTSTATUS NtRaiseException (PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ContextRecord, BOOLEAN FirstChance);\nNTSTATUS NtRaiseHardError (NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask, PULONG_PTR Parameters, ULONG ValidResponseOptions, PULONG Response);\nNTSTATUS NtReadOnlyEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRecoverEnlistment (HANDLE EnlistmentHandle, PVOID EnlistmentKey);\nNTSTATUS NtRecoverResourceManager (HANDLE ResourceManagerHandle);\nNTSTATUS NtRecoverTransactionManager (HANDLE TransactionManagerHandle);\nNTSTATUS NtRegisterProtocolAddressInformation (HANDLE ResourceManager, PCRM_PROTOCOL_ID ProtocolId, ULONG ProtocolInformationSize, PVOID ProtocolInformation, ULONG CreateOptions);\nNTSTATUS NtRegisterThreadTerminatePort (HANDLE PortHandle);\nNTSTATUS NtReleaseKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtReleaseWorkerFactoryWorker (HANDLE WorkerFactoryHandle);\nNTSTATUS NtRemoveIoCompletionEx (HANDLE IoCompletionHandle, PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation, ULONG Count, PULONG NumEntriesRemoved, PLARGE_INTEGER Timeout, BOOLEAN Alertable);\nNTSTATUS NtRemoveProcessDebug (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtRenameKey (HANDLE KeyHandle, PUNICODE_STRING NewName);\nNTSTATUS NtRenameTransactionManager (PUNICODE_STRING LogFileName, LPGUID ExistingTransactionManagerGuid);\nNTSTATUS NtReplaceKey (POBJECT_ATTRIBUTES NewFile, HANDLE TargetHandle, POBJECT_ATTRIBUTES OldFile);\nNTSTATUS NtReplacePartitionUnit (PUNICODE_STRING TargetInstancePath, PUNICODE_STRING SpareInstancePath, ULONG Flags);\nNTSTATUS NtReplyWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtRequestPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage);\nNTSTATUS NtResetEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtResetWriteWatch (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T RegionSize);\nNTSTATUS NtRestoreKey (HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags);\nNTSTATUS NtResumeProcess (HANDLE ProcessHandle);\nNTSTATUS NtRollbackComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRollbackEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRollbackTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\nNTSTATUS NtRollforwardTransactionManager (HANDLE TransactionManagerHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtSaveKey (HANDLE KeyHandle, HANDLE FileHandle);\nNTSTATUS NtSaveKeyEx (HANDLE KeyHandle, HANDLE FileHandle, ULONG Format);\nNTSTATUS NtSaveMergedKeys (HANDLE HighPrecedenceKeyHandle, HANDLE LowPrecedenceKeyHandle, HANDLE FileHandle);\nNTSTATUS NtSecureConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PSID RequiredServerSid, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\nNTSTATUS NtSerializeBoot ();\nNTSTATUS NtSetBootEntryOrder (PULONG Ids, ULONG Count);\nNTSTATUS NtSetBootOptions (PBOOT_OPTIONS BootOptions, ULONG FieldsToChange);\nNTSTATUS NtSetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nNTSTATUS NtSetDebugFilterState (ULONG ComponentId, ULONG Level, BOOLEAN State);\nNTSTATUS NtSetDefaultHardErrorPort (HANDLE DefaultHardErrorPort);\nNTSTATUS NtSetDefaultLocale (BOOLEAN UserProfile, LCID DefaultLocaleId);\nNTSTATUS NtSetDefaultUILanguage (LANGID DefaultUILanguageId);\nNTSTATUS NtSetDriverEntryOrder (PULONG Ids, ULONG Count);\nNTSTATUS NtSetEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\nNTSTATUS NtSetHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetHighWaitLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetInformationDebugObject (HANDLE DebugObjectHandle, DEBUGOBJECTINFOCLASS DebugObjectInformationClass, PVOID DebugInformation, ULONG DebugInformationLength, PULONG ReturnLength);\nNTSTATUS NtSetInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength);\nNTSTATUS NtSetInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength);\nNTSTATUS NtSetInformationKey (HANDLE KeyHandle, KEY_SET_INFORMATION_CLASS KeySetInformationClass, PVOID KeySetInformation, ULONG KeySetInformationLength);\nNTSTATUS NtSetInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength);\nNTSTATUS NtSetInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength);\nNTSTATUS NtSetInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength);\nNTSTATUS NtSetInformationTransactionManager (HANDLE TmHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength);\nNTSTATUS NtSetInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength);\nNTSTATUS NtSetIntervalProfile (ULONG Interval, KPROFILE_SOURCE Source);\nNTSTATUS NtSetIoCompletion (HANDLE IoCompletionHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);\nNTSTATUS NtSetIoCompletionEx (HANDLE IoCompletionHandle, HANDLE IoCompletionReserveHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);\nNTSTATUS NtSetLdtEntries (ULONG Selector0, ULONG Entry0Low, ULONG Entry0Hi, ULONG Selector1, ULONG Entry1Low, ULONG Entry1Hi);\nNTSTATUS NtSetLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetLowWaitHighEventPair (HANDLE EventPairHandle);\n```\n\n----------------------------------------\n\nTITLE: Manual Installation of PyPANDA After Building PANDA (Shell)\nDESCRIPTION: This command shows how to install the Python interface (pypanda) locally after building PANDA from source. It presumes successful compilation and that the user is in the appropriate directory. 'python3 setup.py install' must be run from 'panda/panda/python/core'; it installs necessary Python modules system-wide. Limitations include requiring a corresponding build and matching Python version.\nSOURCE: https://github.com/panda-re/panda/blob/dev/README.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\npython3 setup.py install\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Call Functions in C\nDESCRIPTION: This snippet declares multiple Windows NT system call functions. These functions are part of the Windows Native API and are used for various system-level operations such as file I/O, process management, and system information retrieval.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_7_x86_prototypes.txt#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtReadFileScatter (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);\nNTSTATUS NtReadOnlyEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtReadRequestData (HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtReadVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);\nNTSTATUS NtRecoverEnlistment (HANDLE EnlistmentHandle, PVOID EnlistmentKey);\nNTSTATUS NtRecoverResourceManager (HANDLE ResourceManagerHandle);\nNTSTATUS NtRecoverTransactionManager (HANDLE TransactionManagerHandle);\nNTSTATUS NtRegisterProtocolAddressInformation (HANDLE ResourceManager, PCRM_PROTOCOL_ID ProtocolId, ULONG ProtocolInformationSize, PVOID ProtocolInformation, ULONG CreateOptions);\nNTSTATUS NtRegisterThreadTerminatePort (HANDLE PortHandle);\nNTSTATUS NtReleaseKeyedEvent (HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);\nNTSTATUS NtReleaseMutant (HANDLE MutantHandle, PLONG PreviousCount);\nNTSTATUS NtReleaseSemaphore (HANDLE SemaphoreHandle, LONG ReleaseCount, PLONG PreviousCount);\nNTSTATUS NtReleaseWorkerFactoryWorker (HANDLE WorkerFactoryHandle);\nNTSTATUS NtRemoveIoCompletion (HANDLE IoCompletionHandle, PVOID *KeyContext, PVOID *ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER Timeout);\nNTSTATUS NtRemoveIoCompletionEx (HANDLE IoCompletionHandle, PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation, ULONG Count, PULONG NumEntriesRemoved, PLARGE_INTEGER Timeout, BOOLEAN Alertable);\nNTSTATUS NtRemoveProcessDebug (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\nNTSTATUS NtRenameKey (HANDLE KeyHandle, PUNICODE_STRING NewName);\nNTSTATUS NtRenameTransactionManager (PUNICODE_STRING LogFileName, LPGUID ExistingTransactionManagerGuid);\nNTSTATUS NtReplaceKey (POBJECT_ATTRIBUTES NewFile, HANDLE TargetHandle, POBJECT_ATTRIBUTES OldFile);\nNTSTATUS NtReplacePartitionUnit (PUNICODE_STRING TargetInstancePath, PUNICODE_STRING SpareInstancePath, ULONG Flags);\nNTSTATUS NtReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtReplyWaitReceivePort (HANDLE PortHandle, PVOID *PortContext , PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage);\nNTSTATUS NtReplyWaitReceivePortEx (HANDLE PortHandle, PVOID *PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage, PLARGE_INTEGER Timeout);\nNTSTATUS NtReplyWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtRequestPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage);\nNTSTATUS NtRequestWaitReplyPort (HANDLE PortHandle, PPORT_MESSAGE RequestMessage, PPORT_MESSAGE ReplyMessage);\nNTSTATUS NtResetEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtResetWriteWatch (HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T RegionSize);\nNTSTATUS NtRestoreKey (HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags);\nNTSTATUS NtResumeProcess (HANDLE ProcessHandle);\nNTSTATUS NtResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\nNTSTATUS NtRollbackComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRollbackEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtRollbackTransaction (HANDLE TransactionHandle, BOOLEAN Wait);\nNTSTATUS NtRollforwardTransactionManager (HANDLE TransactionManagerHandle, PLARGE_INTEGER TmVirtualClock);\nNTSTATUS NtSaveKey (HANDLE KeyHandle, HANDLE FileHandle);\nNTSTATUS NtSaveKeyEx (HANDLE KeyHandle, HANDLE FileHandle, ULONG Format);\nNTSTATUS NtSaveMergedKeys (HANDLE HighPrecedenceKeyHandle, HANDLE LowPrecedenceKeyHandle, HANDLE FileHandle);\nNTSTATUS NtSecureConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PSID RequiredServerSid, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\nNTSTATUS NtSerializeBoot ();\nNTSTATUS NtSetBootEntryOrder (PULONG Ids, ULONG Count);\nNTSTATUS NtSetBootOptions (PBOOT_OPTIONS BootOptions, ULONG FieldsToChange);\nNTSTATUS NtSetContextThread (HANDLE ThreadHandle, PCONTEXT ThreadContext);\nNTSTATUS NtSetDebugFilterState (ULONG ComponentId, ULONG Level, BOOLEAN State);\nNTSTATUS NtSetDefaultHardErrorPort (HANDLE DefaultHardErrorPort);\nNTSTATUS NtSetDefaultLocale (BOOLEAN UserProfile, LCID DefaultLocaleId);\nNTSTATUS NtSetDefaultUILanguage (LANGID DefaultUILanguageId);\nNTSTATUS NtSetDriverEntryOrder (PULONG Ids, ULONG Count);\nNTSTATUS NtSetEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\nNTSTATUS NtSetEvent (HANDLE EventHandle, PLONG PreviousState);\nNTSTATUS NtSetEventBoostPriority (HANDLE EventHandle);\nNTSTATUS NtSetHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetHighWaitLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetInformationDebugObject (HANDLE DebugObjectHandle, DEBUGOBJECTINFOCLASS DebugObjectInformationClass, PVOID DebugInformation, ULONG DebugInformationLength, PULONG ReturnLength);\nNTSTATUS NtSetInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength);\nNTSTATUS NtSetInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\nNTSTATUS NtSetInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength);\nNTSTATUS NtSetInformationKey (HANDLE KeyHandle, KEY_SET_INFORMATION_CLASS KeySetInformationClass, PVOID KeySetInformation, ULONG KeySetInformationLength);\nNTSTATUS NtSetInformationObject (HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength);\nNTSTATUS NtSetInformationProcess (HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);\nNTSTATUS NtSetInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength);\nNTSTATUS NtSetInformationThread (HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);\nNTSTATUS NtSetInformationToken (HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength);\nNTSTATUS NtSetInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength);\nNTSTATUS NtSetInformationTransactionManager (HANDLE TmHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength);\nNTSTATUS NtSetInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength);\nNTSTATUS NtSetIntervalProfile (ULONG Interval, KPROFILE_SOURCE Source);\nNTSTATUS NtSetIoCompletion (HANDLE IoCompletionHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);\nNTSTATUS NtSetIoCompletionEx (HANDLE IoCompletionHandle, HANDLE IoCompletionReserveHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);\nNTSTATUS NtSetLdtEntries (ULONG Selector0, ULONG Entry0Low, ULONG Entry0Hi, ULONG Selector1, ULONG Entry1Low, ULONG Entry1Hi);\nNTSTATUS NtSetLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetLowWaitHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetQuotaInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);\nNTSTATUS NtSetSecurityObject (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);\nNTSTATUS NtSetSystemEnvironmentValue (PUNICODE_STRING VariableName, PUNICODE_STRING VariableValue);\nNTSTATUS NtSetSystemEnvironmentValueEx (PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, ULONG ValueLength, ULONG Attributes);\nNTSTATUS NtSetSystemInformation (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);\nNTSTATUS NtSetSystemPowerState (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags);\nNTSTATUS NtSetSystemTime (PLARGE_INTEGER SystemTime, PLARGE_INTEGER PreviousTime);\nNTSTATUS NtSetThreadExecutionState (EXECUTION_STATE esFlags, PEXECUTION_STATE PreviousFlags);\nNTSTATUS NtSetTimer (HANDLE TimerHandle, PLARGE_INTEGER DueTime, PTIMER_APC_ROUTINE TimerApcRoutine, PVOID TimerContext, BOOLEAN WakeTimer, LONG Period, PBOOLEAN PreviousState);\nNTSTATUS NtSetTimerEx (HANDLE TimerHandle, TIMER_SET_INFORMATION_CLASS TimerSetInformationClass, PVOID TimerSetInformation, ULONG TimerSetInformationLength);\nNTSTATUS NtSetTimerResolution (ULONG DesiredTime, BOOLEAN SetResolution, PULONG ActualTime);\nNTSTATUS NtSetUuidSeed (PCHAR Seed);\nNTSTATUS NtSetValueKey (HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);\nNTSTATUS NtSetVolumeInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass);\nNTSTATUS NtShutdownSystem (SHUTDOWN_ACTION Action);\n```\n\n----------------------------------------\n\nTITLE: Controlling Switch Register Fields - Markdown\nDESCRIPTION: This snippet documents the switch-wide CONTROL register and SWITCH_ID, using Markdown for bitfield layout. It describes register offsets, bit meanings (e.g., reset), and expected behaviors. Intended readers are hardware and device driver programmers who set or monitor low-level device control flags. Proper understanding of bitmask and register semantics is required.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/rocker.txt#_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n    CONTROL: offset 0x0300, 32-bit, (W)\n\n    bit name     description\n    ------------------------------------------------------------------------\n    [0] CONTROL_RESET   If set, device will perform reset\n    [1:31]  Reserved\n\n    SWITCH_ID: offset 0x0320, 64-bit, (R)\n\n```\n\n----------------------------------------\n\nTITLE: Listing Available Certificates in Guest with NSS - Shell\nDESCRIPTION: This command uses 'certutil' to list all certificates by hardware slot in the guest system's NSS database, verifying correct import and presence of the virtual smart card and its certificates. Requires certutil, the CoolKey PKCS #11 module, and the target database. The command prompts for a PIN/password for authentication and outputs a list of available certificates and attributes.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/ccid.txt#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ncertutil -d /etc/pki/nssdb -L -h all\n```\n\n----------------------------------------\n\nTITLE: Formatting QEMU Trace Output with Simpletrace Script in Shell\nDESCRIPTION: This shell command invokes Python's simpletrace.py script to pretty-print the binary trace file generated by QEMU. 'trace-events-all' is provided as the events description, and 'trace-*' should be replaced with the matching trace output file (often suffixing the QEMU process ID). Requires Python, the simpletrace script, and the relevant trace files. Inputs: event description file and trace output file. Outputs: Human-readable trace logs.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/tracing.txt#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n./scripts/simpletrace.py trace-events-all trace-* # Override * with QEMU <pid>\n```\n\n----------------------------------------\n\nTITLE: System call entry callback type for NtTerminateProcess - C\nDESCRIPTION: This snippet defines the typedef for the function pointer type used for registering system call entry callbacks for NtTerminateProcess in the syscalls2 plugin. The callback receives the current CPU state, the program counter, and the system call arguments ProcessHandle and ExitStatus as uint32_t values. The CPUState and target_ulong types require including PANDA's or QEMU's relevant headers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/syscalls2.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\ntypedef void (*on_NtTerminateProcess_enter_t)\n  (CPUState* env,\n   target_ulong pc,\n   uint32_t ProcessHandle,\n   uint32_t ExitStatus);\n```\n\n----------------------------------------\n\nTITLE: Calculating Bitmap Granularity from Granularity Bits - Pseudo-code\nDESCRIPTION: This pseudo-code shows how to derive the byte-level granularity of a QCOW2 bitmap using a power-of-two calculation. This calculation defines how many bytes of the image are represented by one bit in the bitmap, a critical factor for storage and tracking. The key parameter is granularity_bits; the snippet outputs the computed granularity. Limitations may apply in software implementations (e.g., limitations on the value as noted for QEMU).\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/qcow2.txt#_snippet_3\n\nLANGUAGE: pseudo-code\nCODE:\n```\ngranularity = 1 << granularity_bits\n\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API Security and Access Control Functions in C\nDESCRIPTION: Function declarations for Windows NT native API calls related to security, access control, and auditing. These functions enable checking and managing security permissions for objects and operations within the Windows security model.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp0_x64_prototypes.txt#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheck (PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByType (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByTypeResultList (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarmByHandle (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\nNTSTATUS NtAdjustGroupsToken (HANDLE TokenHandle, BOOLEAN ResetToDefault, PTOKEN_GROUPS NewState, ULONG BufferLength, PTOKEN_GROUPS PreviousState, PULONG ReturnLength);\n```\n\n----------------------------------------\n\nTITLE: Declaring Struct Types with Inheritance in QAPI Schema - JSON\nDESCRIPTION: Shows how to define a struct and a derived struct with 'base' for inheritance. Each struct has a 'struct' name and 'data' dictionary of members. Optional members use an asterisk, and the 'base' field allows member reuse across types, following strict naming and backward compatibility semantics.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{ 'struct': 'MyType',\n  'data': { 'member1': 'str', 'member2': 'int', '*member3': 'str' } }\n```\n\nLANGUAGE: json\nCODE:\n```\n{ 'struct': 'BlockdevOptionsGenericFormat', 'data': { 'file': 'str' } }\n```\n\nLANGUAGE: json\nCODE:\n```\n{ 'struct': 'BlockdevOptionsGenericCOWFormat',\n  'base': 'BlockdevOptionsGenericFormat',\n  'data': { '*backing': 'str' } }\n```\n\n----------------------------------------\n\nTITLE: Registering CoolKey PKCS #11 Module with NSS - Shell\nDESCRIPTION: These 'modutil' commands add and list the CoolKey PKCS #11 module in the NSS database, allowing smart card access in the guest. Prerequisites are the NSS database and CoolKey module filepath (platform-dependent). Parameters are '-dbdir', '-add', '-libfile', and '-list'. The output is module registration and a listing of all registered PKCS #11 modules.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/ccid.txt#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nmodutil -dbdir /etc/pki/nssdb -add \"CAC Module\" -libfile /usr/lib64/pkcs11/libcoolkeypk11.so\n```\n\nLANGUAGE: shell\nCODE:\n```\nmodutil -dbdir /etc/pki/nssdb -list\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT Native API System Call Prototypes - C/C++\nDESCRIPTION: This code snippet declares the prototypes for a large set of native NT API system calls in C/C++. It enables low-level programs or system modules to reference and call Windows kernel services not typically exposed by standard Win32 headers. Each operator uses strongly typed parameters (such as HANDLE, PVOID, etc.) and always returns an NTSTATUS value for OS-specific error reporting. No function implementations are included; only the external linkage needed for manual linkage or dynamic import is represented.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_vistasp12_x64_prototypes.txt#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n205 NTSTATUS NtGetNlsSectionPtr (ULONG SectionType, ULONG SectionData, PVOID ContextData, PVOID *SectionPointer, PULONG SectionSize);\n206 NTSTATUS NtGetNotificationResourceManager (HANDLE ResourceManagerHandle, PTRANSACTION_NOTIFICATION TransactionNotification, ULONG NotificationLength, PLARGE_INTEGER Timeout, PULONG ReturnLength, ULONG Asynchronous, ULONG_PTR AsynchronousContext);\n207 NTSTATUS NtGetPlugPlayEvent (HANDLE EventHandle, PVOID Context, PPLUGPLAY_EVENT_BLOCK EventBlock, ULONG EventBufferSize);\n208 NTSTATUS NtGetWriteWatch (HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, SIZE_T RegionSize, PVOID *UserAddressArray, PULONG_PTR EntriesInUserAddressArray, PULONG Granularity);\n209 NTSTATUS NtImpersonateAnonymousToken (HANDLE ThreadHandle);\n210 NTSTATUS NtImpersonateThread (HANDLE ServerThreadHandle, HANDLE ClientThreadHandle, PSECURITY_QUALITY_OF_SERVICE SecurityQos);\n211 NTSTATUS NtInitializeNlsFiles (PVOID *BaseAddress, PLCID DefaultLocaleId, PLARGE_INTEGER DefaultCasingTableSize);\n212 NTSTATUS NtInitializeRegistry (USHORT BootCondition);\n213 NTSTATUS NtInitiatePowerAction (POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);\n214 BOOLEAN NtIsSystemResumeAutomatic ();\n215 NTSTATUS NtIsUILanguageComitted ();\n216 NTSTATUS NtListenPort (HANDLE PortHandle, PPORT_MESSAGE ConnectionRequest);\n217 NTSTATUS NtLoadDriver (PUNICODE_STRING DriverServiceName);\n218 NTSTATUS NtLoadKey (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile);\n219 NTSTATUS NtLoadKey2 (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags);\n220 NTSTATUS NtLoadKeyEx (POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags, HANDLE TrustClassKey );\n221 NTSTATUS NtLockFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);\n222 NTSTATUS NtLockProductActivationKeys (ULONG *pPrivateVer, ULONG *pSafeMode);\n223 NTSTATUS NtLockRegistryKey (HANDLE KeyHandle);\n224 NTSTATUS NtLockVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG MapType);\n225 NTSTATUS NtMakePermanentObject (HANDLE Handle);\n226 NTSTATUS NtMakeTemporaryObject (HANDLE Handle);\n227 NTSTATUS NtMapCMFModule (ULONG What, ULONG Index, PULONG CacheIndexOut, PULONG CacheFlagsOut, PULONG ViewSizeOut, PVOID *BaseAddress);\n228 NTSTATUS NtMapUserPhysicalPages (PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n229 NTSTATUS NtModifyBootEntry (PBOOT_ENTRY BootEntry);\n230 NTSTATUS NtModifyDriverEntry (PEFI_DRIVER_ENTRY DriverEntry);\n231 NTSTATUS NtNotifyChangeDirectoryFile (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree);\n232 NTSTATUS NtNotifyChangeKey (HANDLE KeyHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\n233 NTSTATUS NtNotifyChangeMultipleKeys (HANDLE MasterKeyHandle, ULONG Count, OBJECT_ATTRIBUTES SlaveObjects[], HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);\n234 NTSTATUS NtOpenEnlistment (PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, LPGUID EnlistmentGuid, POBJECT_ATTRIBUTES ObjectAttributes);\n235 NTSTATUS NtOpenEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n236 NTSTATUS NtOpenIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n237 NTSTATUS NtOpenJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n238 NTSTATUS NtOpenKeyTransacted (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE TransactionHandle);\n239 NTSTATUS NtOpenKeyedEvent (PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n240 NTSTATUS NtOpenMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n241 NTSTATUS NtOpenObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, ACCESS_MASK GrantedAccess, PPRIVILEGE_SET Privileges, BOOLEAN ObjectCreation, BOOLEAN AccessGranted, PBOOLEAN GenerateOnClose);\n242 NTSTATUS NtOpenPrivateNamespace (PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);\n243 NTSTATUS NtOpenProcessToken (HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);\n244 NTSTATUS NtOpenResourceManager (PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID ResourceManagerGuid, POBJECT_ATTRIBUTES ObjectAttributes);\n245 NTSTATUS NtOpenSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n246 NTSTATUS NtOpenSession (PHANDLE SessionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n247 NTSTATUS NtOpenSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n248 NTSTATUS NtOpenThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);\n249 NTSTATUS NtOpenTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n250 NTSTATUS NtOpenTransaction (PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle);\n251 NTSTATUS NtOpenTransactionManager (PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, LPGUID TmIdentity, ULONG OpenOptions);\n252 NTSTATUS NtPlugPlayControl (PLUGPLAY_CONTROL_CLASS PnPControlClass, PVOID PnPControlData, ULONG PnPControlDataLength);\n253 NTSTATUS NtPrePrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\n254 NTSTATUS NtPrePrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\n255 NTSTATUS NtPrepareComplete (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\n256 NTSTATUS NtPrepareEnlistment (HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);\n257 NTSTATUS NtPrivilegeCheck (HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, PBOOLEAN Result);\n258 NTSTATUS NtPrivilegeObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\n259 NTSTATUS NtPrivilegedServiceAuditAlarm (PUNICODE_STRING SubsystemName, PUNICODE_STRING ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);\n260 NTSTATUS NtPropagationComplete (HANDLE ResourceManagerHandle, ULONG RequestCookie, ULONG BufferLength, PVOID Buffer);\n261 NTSTATUS NtPropagationFailed (HANDLE ResourceManagerHandle, ULONG RequestCookie, NTSTATUS PropStatus);\n262 NTSTATUS NtPulseEvent (HANDLE EventHandle, PLONG PreviousState);\n263 NTSTATUS NtQueryBootEntryOrder (PULONG Ids, PULONG Count);\n264 NTSTATUS NtQueryBootOptions (PBOOT_OPTIONS BootOptions, PULONG BootOptionsLength);\n265 NTSTATUS NtQueryDebugFilterState (ULONG ComponentId, ULONG Level);\n266 NTSTATUS NtQueryDirectoryObject (HANDLE DirectoryHandle, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, BOOLEAN RestartScan, PULONG Context, PULONG ReturnLength);\n267 NTSTATUS NtQueryDriverEntryOrder (PULONG Ids, PULONG Count);\n268 NTSTATUS NtQueryEaFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan);\n269 NTSTATUS NtQueryFullAttributesFile (POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);\n270 NTSTATUS NtQueryInformationAtom (RTL_ATOM Atom, ATOM_INFORMATION_CLASS InformationClass, PVOID AtomInformation, ULONG AtomInformationLength, PULONG ReturnLength);\n271 NTSTATUS NtQueryInformationEnlistment (HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength, PULONG ReturnLength);\n272 NTSTATUS NtQueryInformationJobObject (HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength, PULONG ReturnLength);\n273 NTSTATUS NtQueryInformationPort (HANDLE PortHandle, PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);\n274 NTSTATUS NtQueryInformationResourceManager (HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength, PULONG ReturnLength);\n275 NTSTATUS NtQueryInformationTransaction (HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength, PULONG ReturnLength);\n276 NTSTATUS NtQueryInformationTransactionManager (HANDLE TransactionManagerHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength, PULONG ReturnLength);\n277 NTSTATUS NtQueryInformationWorkerFactory (HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength, PULONG ReturnLength);\n278 NTSTATUS NtQueryInstallUILanguage (LANGID *InstallUILanguageId);\n279 NTSTATUS NtQueryIntervalProfile (KPROFILE_SOURCE ProfileSource, PULONG Interval);\n```\n\n----------------------------------------\n\nTITLE: Blessing Known Good Outputs in Panda Testing with Python\nDESCRIPTION: This snippet designates outputs from test runs as the blessed reference set, using the 'bless' command with the ptest.py script. It records and stores output in the '/blessed' directory for future regression comparison. Prerequisites include completion of test setup and successful Python environment configuration. Main input is 'bless'; output is a set of verified reference outputs for regression checks.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/testing/README.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nptest.py bless\n```\n\n----------------------------------------\n\nTITLE: Initializing Object Between qemu_lockcnt_lock and qemu_lockcnt_unlock in C\nDESCRIPTION: This snippet illustrates how to safely initialize an object and set a pointer using QEMU's qemu_lockcnt_lock and qemu_lockcnt_unlock. It checks if the object is already present, allocates and assigns it if necessary, using atomic_rcu_set to ensure a safe publish with RCU semantics. Prerequisites include QEMU's QemuLockCnt API and atomic RCU helpers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/lockcnt.txt#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nqemu_lockcnt_lock(&xyz_lockcnt);\nif (!xyz) {\n    new_xyz = g_new(XYZ, 1);\n    ...\n    atomic_rcu_set(&xyz, new_xyz);\n}\nqemu_lockcnt_unlock(&xyz_lockcnt);\n```\n\n----------------------------------------\n\nTITLE: Defining QAPI Struct for Timer Alarm Methods - QAPI Python-Like (JSON) Schema\nDESCRIPTION: This snippet declares the 'TimerAlarmMethod' QAPI type to represent timer alarm options. It comprises a required string field 'method-name' and a required boolean 'current' indicating if the method is active. This is used for list-returning commands that enumerate available timer alarm approaches. Required in the QAPI schema before usage in command schemas or C logic.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/writing-qmp-commands.txt#_snippet_14\n\nLANGUAGE: qapi\nCODE:\n```\n{ 'type': 'TimerAlarmMethod',\n  'data': { 'method-name': 'str', 'current': 'bool' } }\n```\n\n----------------------------------------\n\nTITLE: Declaring NT Native System Call Stubs - C\nDESCRIPTION: These C function prototypes declare NT Native API system calls, required for invoking kernel-level Windows features directly from user-mode code. No external code dependencies beyond Windows native types and C preprocessor declarations are required, but correct use expects prior inclusion of all referenced data structures and type definitions (e.g., HANDLE, NTSTATUS, PUNICODE_STRING). Each function specifies precise input, output, and context parameters, matching the underlying NT implementation. Outputs are typically returned by reference pointers or via NTSTATUS results, and improper parameters may produce undefined system behavior.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_xpsp2_x86_prototypes.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAcceptConnectPort (PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAccessCheck (PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAccessCheckAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAccessCheckByType (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeResultList (PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAccessCheckByTypeResultListAndAuditAlarmByHandle (PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAddAtom (PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAddBootEntry (PBOOT_ENTRY BootEntry, PULONG Id);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAdjustGroupsToken (HANDLE TokenHandle, BOOLEAN ResetToDefault, PTOKEN_GROUPS NewState, ULONG BufferLength, PTOKEN_GROUPS PreviousState, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAdjustPrivilegesToken (HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlertResumeThread (HANDLE ThreadHandle, PULONG PreviousSuspendCount);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAlertThread (HANDLE ThreadHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAllocateLocallyUniqueId (PLUID Luid);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAllocateUserPhysicalPages (HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAllocateUuids (PULARGE_INTEGER Time, PULONG Range, PULONG Sequence, PCHAR Seed);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAllocateVirtualMemory (HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAreMappedFilesTheSame (PVOID File1MappedAsAnImage, PVOID File2MappedAsFile);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtAssignProcessToJobObject (HANDLE JobHandle, HANDLE ProcessHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCallbackReturn (PVOID OutputBuffer, ULONG OutputLength, NTSTATUS Status);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCancelIoFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCancelTimer (HANDLE TimerHandle, PBOOLEAN CurrentState);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtClearEvent (HANDLE EventHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtClose (HANDLE Handle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCloseObjectAuditAlarm (PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCompactKeys (ULONG Count, HANDLE KeyArray[]);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCompareTokens (HANDLE FirstTokenHandle, HANDLE SecondTokenHandle, PBOOLEAN Equal);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCompleteConnectPort (HANDLE PortHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCompressKey (HANDLE Key);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtConnectPort (PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtContinue (PCONTEXT ContextRecord, BOOLEAN TestAlert);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateDebugObject (PHANDLE DebugObjectHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateDirectoryObject (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateEvent (PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateEventPair (PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateFile (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateIoCompletion (PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Count);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateJobObject (PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateJobSet (ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateKey (PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateMailslotFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateMutant (PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN InitialOwner);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateNamedPipeFile (PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreatePagingFile (PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreatePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateProcess (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateProcessEx (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateProfile (PHANDLE ProfileHandle, HANDLE Process, PVOID RangeBase, SIZE_T RangeSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateSection (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateSemaphore (PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateSymbolicLinkObject (PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateThread (PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateTimer (PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateToken (PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtCreateWaitablePort (PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDebugActiveProcess (HANDLE ProcessHandle, HANDLE DebugObjectHandle);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDebugContinue (HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);\n```\n\nLANGUAGE: c\nCODE:\n```\nNTSTATUS NtDelayExecution (BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);\n```\n\n----------------------------------------\n\nTITLE: Initiating COLO Migration on Primary VM\nDESCRIPTION: These QMP commands prepare the primary VM for COLO migration. They add a replication drive, change the block device, enable COLO capabilities, and start the migration process to the secondary VM.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/COLO-FT.txt#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{'execute':'qmp_capabilities'}\n{ 'execute': 'human-monitor-command',\n  'arguments': {'command-line': 'drive_add -n buddy driver=replication,mode=primary,file.driver=nbd,file.host=xx.xx.xx.xx,file.port=8889,file.export=secondary-disk0,node-name=nbd_client0'}}\n{ 'execute':'x-blockdev-change', 'arguments':{'parent': 'primary-disk0', 'node': 'nbd_client0' } }\n{ 'execute': 'migrate-set-capabilities',\n      'arguments': {'capabilities': [ {'capability': 'x-colo', 'state': true } ] } }\n{ 'execute': 'migrate', 'arguments': {'uri': 'tcp:xx.xx.xx.xx:8888' } }\n```\n\n----------------------------------------\n\nTITLE: Detecting Sector Mismatches with blkverify and qemu-io (Shell)\nDESCRIPTION: Reads 512 bytes from a blkverify-combined device to trigger data comparison between two backends (a.img and b.img). If data differs between them, blkverify prints an error indicating the precise sector and nature of the mismatch. Requires QEMU built with blkverify and the qemu-io tool. Command format: specify blkverify:<raw_device>:<test_device>.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/blkverify.txt#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ ./qemu-io -c 'read 0 512' blkverify:a.img:b.img\n```\n\n----------------------------------------\n\nTITLE: Declaring Before Virtual Memory Read Callback Signature in PANDA (C)\nDESCRIPTION: Specifies the function pointer for a plugin callback invoked before virtual memory is read, using PANDA's memory callback enabling functions. Inputs include CPU state, PC, target address, and size; no return value. Activation requires calling panda_enable_memcb, and is intended for memory access monitoring or emulation.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_38\n\nLANGUAGE: C\nCODE:\n```\nvoid (*virt_mem_before_read)(CPUState *env, target_ulong pc,target_ulong addr, target_ulong size);\n```\n\n----------------------------------------\n\nTITLE: Declaring Windows NT System Call Functions in C\nDESCRIPTION: This snippet contains multiple function declarations for Windows NT system calls. These functions are part of the Native API (NTAPI) and provide low-level access to system resources and operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_xpsp2_x86_prototypes.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetEventBoostPriority (HANDLE EventHandle);\nNTSTATUS NtSetHighEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetHighWaitLowEventPair (HANDLE EventPairHandle);\nNTSTATUS NtSetInformationDebugObject (HANDLE DebugObjectHandle, DEBUGOBJECTINFOCLASS DebugObjectInformationClass, PVOID DebugInformation, ULONG DebugInformationLength, PULONG ReturnLength);\nNTSTATUS NtSetInformationFile (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);\n// ... [truncated for brevity] ...\nNTSTATUS NtQueryPortInformationProcess ();\n```\n\n----------------------------------------\n\nTITLE: Windows NT System Management Functions\nDESCRIPTION: Function declarations for managing system resources including files, memory, events, and system state operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/windows_2000_x86_prototypes.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nNTSTATUS NtSetSystemTime(PLARGE_INTEGER SystemTime, PLARGE_INTEGER PreviousTime);\nNTSTATUS NtSetSystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);\nNTSTATUS NtSetSystemPowerState(POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags);\n```\n\n----------------------------------------\n\nTITLE: Defining Hook Registration API in PANDA hooks2 Plugin\nDESCRIPTION: Defines the ADD_HOOKS2 function that registers a callback for address ranges in specific processes and libraries. Parameters include the hook function, callback data, kernel mode flag, process name, library name, trace boundaries, and memory address range to hook.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/hooks2/README.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\ntypedef bool (*hooks2_func_t)(CPUState *, TranslationBlock *, void *);\n\nint ADD_HOOKS2(\n        hooks2_func_t hook,\n        void *cb_data,\n        bool is_kernel,\n        const char *procname,\n        const char *libname,\n        target_ulong trace_start,\n        target_ulong trace_stop,\n        target_ulong range_begin,\n        target_ulong range_end);\n```\n\n----------------------------------------\n\nTITLE: Launching Primary QEMU VM with COLO Support\nDESCRIPTION: Command to start the primary QEMU virtual machine with COLO configuration including network, storage, and checkpoint capabilities. Uses KVM acceleration, 2GB RAM, 2 CPUs, and QMP control.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/COLO-FT.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nqemu-kvm -enable-kvm -m 2048 -smp 2 -qmp stdio -vnc :7 -name primary \\\n  -device piix3-usb-uhci \\\n  -device usb-tablet -netdev tap,id=hn0,vhost=off \\\n  -device virtio-net-pci,id=net-pci0,netdev=hn0 \\\n  -drive if=virtio,id=primary-disk0,driver=quorum,read-pattern=fifo,vote-threshold=1,\\\n         children.0.file.filename=1.raw,\\\n         children.0.driver=raw -S\n```\n\n----------------------------------------\n\nTITLE: Defining Linux System Call Prototypes in C\nDESCRIPTION: This collection of C function declarations provides the full set of Linux kernel system call prototypes, matching the syscall numbers with interfaces needed for kernel or low-level OS development. Dependencies include Linux kernel typedefs (such as pid_t, time_t, struct stat, etc.), and may require specific user-space/kernel-space pointer management marked by __user annotations. Intended to be included in a kernel or emulation context, expected inputs and outputs adhere to kernel convention, with parameters for file descriptors, buffers, and many struct pointers; all return types are long, following Linux syscall ABI conventions. Inputs must satisfy type and structural requirements set by the Linux kernel.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_x86_prototypes.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n0 long sys_restart_syscall(void);\n1 long sys_exit(int error_code);\n2 long sys_fork(void);\n3 long sys_read(unsigned int fd, char __user *buf, size_t count);\n4 long sys_write(unsigned int fd, const char __user *buf, size_t count);\n5 long sys_open(const char __user *filename, int flags, umode_t mode);\n6 long sys_close(unsigned int fd);\n7 long sys_waitpid(pid_t pid, int __user *stat_addr, int options);\n8 long sys_creat(const char __user *pathname, umode_t mode);\n9 long sys_link(const char __user *oldname, const char __user *newname);\n10 long sys_unlink(const char __user *pathname);\n11 long sys_execve(const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp);\n12 long sys_chdir(const char __user *filename);\n13 long sys_time(time_t __user *tloc);\n14 long sys_mknod(const char __user *filename, umode_t mode, unsigned dev);\n15 long sys_chmod(const char __user *filename, umode_t mode);\n16 long sys_lchown16(const char __user *filename, old_uid_t user, old_gid_t group);\n18 long sys_stat(const char __user *filename, struct __old_kernel_stat __user *statbuf);\n19 long sys_lseek(unsigned int fd, off_t offset, unsigned int whence);\n20 long sys_getpid(void);\n21 long sys_mount(char __user *dev_name, char __user *dir_name, char __user *type, unsigned long flags, void __user *data);\n22 long sys_oldumount(char __user *name);\n23 long sys_setuid16(old_uid_t uid);\n24 long sys_getuid16(void);\n25 long sys_stime(time_t __user *tptr);\n26 long sys_ptrace(long request, long pid, unsigned long addr, unsigned long data);\n27 long sys_alarm(unsigned int seconds);\n28 long sys_fstat(unsigned int fd, struct __old_kernel_stat __user *statbuf);\n29 long sys_pause(void);\n30 long sys_utime(char __user *filename, struct utimbuf __user *times);\n33 long sys_access(const char __user *filename, int mode);\n34 long sys_nice(int increment);\n36 long sys_sync(void);\n37 long sys_kill(pid_t pid, int sig);\n38 long sys_rename(const char __user *oldname, const char __user *newname);\n39 long sys_mkdir(const char __user *pathname, umode_t mode);\n40 long sys_rmdir(const char __user *pathname);\n41 long sys_dup(unsigned int fildes);\n42 long sys_pipe(int __user *fildes);\n43 long sys_times(struct tms __user *tbuf);\n45 long sys_brk(unsigned long brk);\n46 long sys_setgid16(old_gid_t gid);\n47 long sys_getgid16(void);\n48 long sys_signal(int sig, __sighandler_t handler);\n49 long sys_geteuid16(void);\n50 long sys_getegid16(void);\n51 long sys_acct(const char __user *name);\n52 long sys_umount(char __user *name, int flags);\n54 long sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);\n55 long sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg);\n57 long sys_setpgid(pid_t pid, pid_t pgid);\n59 long sys_olduname(struct oldold_utsname __user *);\n60 long sys_umask(int mask);\n61 long sys_chroot(const char __user *filename);\n62 long sys_ustat(unsigned dev, struct ustat __user *ubuf);\n63 long sys_dup2(unsigned int oldfd, unsigned int newfd);\n64 long sys_getppid(void);\n65 long sys_getpgrp(void);\n66 long sys_setsid(void);\n67 long sys_sigaction(int, const struct old_sigaction __user *, struct old_sigaction __user *);\n68 long sys_sgetmask(void);\n69 long sys_ssetmask(int newmask);\n70 long sys_setreuid16(old_uid_t ruid, old_uid_t euid);\n71 long sys_setregid16(old_gid_t rgid, old_gid_t egid);\n72 long sys_sigsuspend(int unused1, int unused2, old_sigset_t mask);\n73 long sys_sigpending(old_sigset_t __user *set);\n74 long sys_sethostname(char __user *name, int len);\n75 long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim);\n76 long sys_old_getrlimit(unsigned int resource, struct rlimit __user *rlim);\n77 long sys_getrusage(int who, struct rusage __user *ru);\n78 long sys_gettimeofday(struct timeval __user *tv, struct timezone __user *tz);\n79 long sys_settimeofday(struct timeval __user *tv, struct timezone __user *tz);\n80 long sys_getgroups16(int gidsetsize, old_gid_t __user *grouplist);\n81 long sys_setgroups16(int gidsetsize, old_gid_t __user *grouplist);\n82 long sys_old_select(struct sel_arg_struct __user *arg);\n83 long sys_symlink(const char __user *old, const char __user *new);\n84 long sys_lstat(const char __user *filename, struct __old_kernel_stat __user *statbuf);\n85 long sys_readlink(const char __user *path, char __user *buf, int bufsiz);\n86 long sys_uselib(const char __user *library);\n87 long sys_swapon(const char __user *specialfile, int swap_flags);\n88 long sys_reboot(int magic1, int magic2, unsigned int cmd, void __user *arg);\n89 long sys_old_readdir(unsigned int, struct old_linux_dirent __user *, unsigned int);\n90 long sys_old_mmap(struct mmap_arg_struct __user *arg);\n91 long sys_munmap(unsigned long addr, size_t len);\n92 long sys_truncate(const char __user *path, long length);\n93 long sys_ftruncate(unsigned int fd, unsigned long length);\n94 long sys_fchmod(unsigned int fd, umode_t mode);\n95 long sys_fchown16(unsigned int fd, old_uid_t user, old_gid_t group);\n96 long sys_getpriority(int which, int who);\n97 long sys_setpriority(int which, int who, int niceval);\n99 long sys_statfs(const char __user *path, struct statfs __user *buf);\n100 long sys_fstatfs(unsigned int fd, struct statfs __user *buf);\n101 long sys_ioperm(unsigned long, unsigned long, int);\n102 long sys_socketcall(int call, unsigned long __user *args);\n103 long sys_syslog(int type, char __user *buf, int len);\n104 long sys_setitimer(int which, struct itimerval __user *value, struct itimerval __user *ovalue);\n105 long sys_getitimer(int which, struct itimerval __user *value);\n106 long sys_newstat(const char __user *filename, struct stat __user *statbuf);\n107 long sys_newlstat(const char __user *filename, struct stat __user *statbuf);\n108 long sys_newfstat(unsigned int fd, struct stat __user *statbuf);\n109 long sys_uname(struct old_utsname __user *);\n110 long sys_iopl(unsigned int);\n111 long sys_vhangup(void);\n113 long sys_vm86old(struct vm86_struct __user *);\n114 long sys_wait4(pid_t pid, int __user *stat_addr, int options, struct rusage __user *ru);\n115 long sys_swapoff(const char __user *specialfile);\n116 long sys_sysinfo(struct sysinfo __user *info);\n117 long sys_ipc(unsigned int call, int first, unsigned long second, unsigned long third, void __user *ptr, long fifth);\n118 long sys_fsync(unsigned int fd);\n119 long sys_sigreturn(void);\n120 long sys_clone(unsigned long, unsigned long, int __user *, int __user *, unsigned long);\n121 long sys_setdomainname(char __user *name, int len);\n122 long sys_newuname(struct new_utsname __user *name);\n123 long sys_modify_ldt(int, void __user *, unsigned long);\n124 long sys_adjtimex(struct timex __user *txc_p);\n125 long sys_mprotect(unsigned long start, size_t len, unsigned long prot);\n126 long sys_sigprocmask(int how, old_sigset_t __user *set, old_sigset_t __user *oset);\n128 long sys_init_module(void __user *umod, unsigned long len, const char __user *uargs);\n129 long sys_delete_module(const char __user *name_user, unsigned int flags);\n131 long sys_quotactl(unsigned int cmd, const char __user *special, qid_t id, void __user *addr);\n132 long sys_getpgid(pid_t pid);\n133 long sys_fchdir(unsigned int fd);\n134 long sys_bdflush(int func, long data);\n135 long sys_sysfs(int option, unsigned long arg1, unsigned long arg2);\n136 long sys_personality(unsigned int personality);\n138 long sys_setfsuid16(old_uid_t uid);\n139 long sys_setfsgid16(old_gid_t gid);\n140 long sys_llseek(unsigned int fd, unsigned long offset_high, unsigned long offset_low, loff_t __user *result, unsigned int whence);\n141 long sys_getdents(unsigned int fd, struct linux_dirent __user *dirent, unsigned int count);\n142 long sys_select(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct timeval __user *tvp);\n143 long sys_flock(unsigned int fd, unsigned int cmd);\n144 long sys_msync(unsigned long start, size_t len, int flags);\n145 long sys_readv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\n146 long sys_writev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);\n147 long sys_getsid(pid_t pid);\n148 long sys_fdatasync(unsigned int fd);\n149 long sys_sysctl(struct __sysctl_args __user *args);\n150 long sys_mlock(unsigned long start, size_t len);\n151 long sys_munlock(unsigned long start, size_t len);\n152 long sys_mlockall(int flags);\n153 long sys_munlockall(void);\n154 long sys_sched_setparam(pid_t pid, struct sched_param __user *param);\n155 long sys_sched_getparam(pid_t pid, struct sched_param __user *param);\n156 long sys_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param);\n157 long sys_sched_getscheduler(pid_t pid);\n158 long sys_sched_yield(void);\n159 long sys_sched_get_priority_max(int policy);\n160 long sys_sched_get_priority_min(int policy);\n161 long sys_sched_rr_get_interval(pid_t pid, struct timespec __user *interval);\n162 long sys_nanosleep(struct timespec __user *rqtp, struct timespec __user *rmtp);\n163 long sys_mremap(unsigned long addr, unsigned long old_len, unsigned long new_len, unsigned long flags, unsigned long new_addr);\n164 long sys_setresuid16(old_uid_t ruid, old_uid_t euid, old_uid_t suid);\n165 long sys_getresuid16(old_uid_t __user *ruid, old_uid_t __user *euid, old_uid_t __user *suid);\n166 long sys_vm86(unsigned long, unsigned long);\n168 long sys_poll(struct pollfd __user *ufds, unsigned int nfds, int timeout);\n170 long sys_setresgid16(old_gid_t rgid, old_gid_t egid, old_gid_t sgid);\n171 long sys_getresgid16(old_gid_t __user *rgid, old_gid_t __user *egid, old_gid_t __user *sgid);\n172 long sys_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\n173 long sys_rt_sigreturn(void);\n174 long sys_rt_sigaction(int, const struct sigaction __user *, struct sigaction __user *, size_t);\n175 long sys_rt_sigprocmask(int how, sigset_t __user *set, sigset_t __user *oset, size_t sigsetsize);\n176 long sys_rt_sigpending(sigset_t __user *set, size_t sigsetsize);\n```\n\n----------------------------------------\n\nTITLE: Formatting Emphasis and Strong Styles in QAPI Documentation - Markdown\nDESCRIPTION: Illustrates the use of *asterisks* and _underscores_ within documentation comments to produce strong and emphasis text in documentation outputs. These styles only apply within single lines and are for improving readability of generated documentation. Automated tools consuming comments will render these as bold or italic.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qapi-code-gen.txt#_snippet_3\n\nLANGUAGE: Markdown\nCODE:\n```\n# Some text foo with *strong* and _emphasis_\n```\n\n----------------------------------------\n\nTITLE: Declaring Linux System Call Prototypes in C\nDESCRIPTION: This snippet contains C function prototypes for various Linux kernel system calls, typically located in system header files or syscall tables. Each declaration exposes the calling convention, argument types, and expected return type, using conventional Linux types (e.g., size_t, __user pointers, pid_t) for interaction between kernel and user space. Prerequisites include kernel header knowledge, and many parameters use __user pointers denoting user address space, which is a critical context for security and correctness. The set covers low-level OS features such as networking, file I/O, process management, signals, and extended attributes. Inputs are detailed in the arguments, outputs are usually long values or pointers passed back through parameters, and all declarations must match the kernel's expected ABI and data structure definitions.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips_prototypes.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n4169 long sys_bind(int, struct sockaddr __user *, int);\n4170 long sys_connect(int, struct sockaddr __user *, int);\n4171 long sys_getpeername(int, struct sockaddr __user *, int __user *);\n4172 long sys_getsockname(int, struct sockaddr __user *, int __user *);\n4173 long sys_getsockopt(int fd, int level, int optname, char __user *optval, int __user *optlen);\n4174 long sys_listen(int, int);\n4175 long sys_recv(int, void __user *, size_t, unsigned);\n4176 long sys_recvfrom(int, void __user *, size_t, unsigned, struct sockaddr __user *, int __user *);\n4177 long sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\n4178 long sys_send(int, void __user *, size_t, unsigned);\n4179 long sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\n4180 long sys_sendto(int, void __user *, size_t, unsigned, struct sockaddr __user *, int);\n4181 long sys_setsockopt(int fd, int level, int optname, char __user *optval, int optlen);\n4182 long sys_shutdown(int, int);\n4183 long sys_socket(int, int, int);\n4184 long sys_socketpair(int, int, int, int __user *);\n4185 long sys_setresuid(uid_t ruid, uid_t euid, uid_t suid);\n4186 long sys_getresuid(uid_t __user *ruid, uid_t __user *euid, uid_t __user *suid);\n4187 long sys_query_module(const char *name, int which, void *buf, size_t bufsize, size_t *ret);\n4188 long sys_poll(struct pollfd __user *ufds, unsigned int nfds, int timeout);\n4189 long sys_nfsservctl(int cmd, struct nfsctl_arg *argp, union nfsctl_res *resp);\n4190 long sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid);\n4191 long sys_getresgid(gid_t __user *rgid, gid_t __user *egid, gid_t __user *sgid);\n4192 long sys_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\n4193 void sys_rt_sigreturn(void);\n4194 long sys_rt_sigaction(int, const struct sigaction __user *, struct sigaction __user *, size_t);\n4195 long sys_rt_sigprocmask(int how, sigset_t __user *set, sigset_t __user *oset, size_t sigsetsize);\n4196 long sys_rt_sigpending(sigset_t __user *set, size_t sigsetsize);\n4197 long sys_rt_sigtimedwait_time32(const sigset_t __user *uthese, siginfo_t __user *uinfo, const struct old_timespec32 __user *uts, size_t sigsetsize);\n4198 long sys_rt_sigqueueinfo(pid_t pid, int sig, siginfo_t __user *uinfo);\n4199 long sys_rt_sigsuspend(sigset_t __user *unewset, size_t sigsetsize);\n4200 long sys_pread64(unsigned int fd, char __user *buf, size_t count, loff_t pos);\n4201 long sys_pwrite64(unsigned int fd, const char __user *buf, size_t count, loff_t pos);\n4202 long sys_chown(const char __user *filename, uid_t user, gid_t group);\n4203 long sys_getcwd(char __user *buf, unsigned long size);\n4204 long sys_capget(cap_user_header_t header, cap_user_data_t dataptr);\n4205 long sys_capset(cap_user_header_t header, const cap_user_data_t data);\n4206 long sys_sigaltstack(const struct sigaltstack __user *uss, struct sigaltstack __user *uoss);\n4207 long sys_sendfile(int out_fd, int in_fd, off_t __user *offset, size_t count);\n// 4208 sys_getpmsg - UNIMPLEMENTED\n// 4209 sys_getpmsg - UNIMPLEMENTED\n4210 void* mmap2(void *addr, size_t length, int prot, int flags, int fd, off_t pgoffset);\n4211 long sys_truncate64(const char __user *path, loff_t length);\n4212 long sys_ftruncate64(unsigned int fd, loff_t length);\n4213 long sys_stat64(const char __user *filename, struct stat64 __user *statbuf);\n4214 long sys_lstat64(const char __user *filename, struct stat64 __user *statbuf);\n4215 long sys_fstat64(unsigned long fd, struct stat64 __user *statbuf);\n4216 long sys_pivot_root(const char __user *new_root, const char __user *put_old);\n4217 long sys_mincore(unsigned long start, size_t len, unsigned char __user *vec);\n4218 long sys_madvise(unsigned long start, size_t len, int behavior);\n4219 long sys_getdents64(unsigned int fd, struct linux_dirent64 __user *dirent, unsigned int count);\n4220 long sys_fcntl64(unsigned int fd, unsigned int cmd, unsigned long arg);\n// 4221 - RESERVED\n4222 long sys_gettid(void);\n4223 long sys_readahead(int fd, loff_t offset, size_t count);\n4224 long sys_setxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\n4225 long sys_lsetxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);\n4226 long sys_fsetxattr(int fd, const char __user *name, const void __user *value, size_t size, int flags);\n4227 long sys_getxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\n4228 long sys_lgetxattr(const char __user *path, const char __user *name, void __user *value, size_t size);\n4229 long sys_fgetxattr(int fd, const char __user *name, void __user *value, size_t size);\n4230 long sys_listxattr(const char __user *path, char __user *list, size_t size);\n4231 long sys_llistxattr(const char __user *path, char __user *list, size_t size);\n4232 long sys_flistxattr(int fd, char __user *list, size_t size);\n4233 long sys_removexattr(const char __user *path, const char __user *name);\n4234 long sys_lremovexattr(const char __user *path, const char __user *name);\n4235 long sys_fremovexattr(int fd, const char __user *name);\n4236 long sys_tkill(pid_t pid, int sig);\n4237 long sys_sendfile64(int out_fd, int in_fd, loff_t __user *offset, size_t count);\n4238 long sys_futex_time32(u32 __user *uaddr, int op, u32 val, struct old_timespec32 __user *utime, u32 __user *uaddr2, u32 val3);\n4239 long sys_sched_setaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\n4240 long sys_sched_getaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);\n4241 long sys_io_setup(unsigned nr_reqs, aio_context_t __user *ctx);\n4242 long sys_io_destroy(aio_context_t ctx);\n4243 long sys_io_getevents_time32(__u32 ctx_id, __s32 min_nr, __s32 nr, struct io_event __user *events, struct old_timespec32 __user *timeout);\n4244 long sys_io_submit(aio_context_t, long, struct iocb __user * __user *);\n4245 long sys_io_cancel(aio_context_t ctx_id, struct iocb __user *iocb, struct io_event __user *result);\n4246 long sys_exit_group(int error_code);\n4247 long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);\n4248 long sys_epoll_create(int size);\n4249 long sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user *event);\n4250 long sys_epoll_wait(int epfd, struct epoll_event __user *events, int maxevents, int timeout);\n4251 long sys_remap_file_pages(unsigned long start, unsigned long size, unsigned long prot, unsigned long pgoff, unsigned long flags);\n4252 long sys_set_tid_address(int __user *tidptr);\n4253 long sys_restart_syscall(void);\n4254 long sys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice);\n4255 long sys_statfs64(const char __user *path, size_t sz, struct statfs64 __user *buf);\n4256 long sys_fstatfs64(unsigned int fd, size_t sz, struct statfs64 __user *buf);\n4257 long sys_timer_create(clockid_t which_clock, struct sigevent __user *timer_event_spec, timer_t __user *created_timer_id);\n4258 long sys_timer_settime32(timer_t timer_id, int flags, struct old_itimerspec32 __user *new, struct old_itimerspec32 __user *old);\n4259 long sys_timer_gettime32(timer_t timer_id, struct old_itimerspec32 __user *setting);\n4260 long sys_timer_getoverrun(timer_t timer_id);\n4261 long sys_timer_delete(timer_t timer_id);\n4262 long sys_clock_settime32(clockid_t which_clock, struct old_timespec32 __user *tp);\n4263 long sys_clock_gettime32(clockid_t which_clock, struct old_timespec32 __user *tp);\n4264 long sys_clock_getres_time32(clockid_t which_clock, struct old_timespec32 __user *tp);\n4265 long sys_clock_nanosleep_time32(clockid_t which_clock, int flags, struct old_timespec32 __user *rqtp, struct old_timespec32 __user *rmtp);\n4266 long sys_tgkill(pid_t tgid, pid_t pid, int sig);\n4267 long sys_utimes_time32(const char __user *filename, struct old_timeval32 __user *t);\n4268 long sys_mbind(unsigned long start, unsigned long len, unsigned long mode, const unsigned long __user *nmask, unsigned long maxnode, unsigned flags);\n4269 long sys_get_mempolicy(int __user *policy, unsigned long __user *nmask, unsigned long maxnode, unsigned long addr, unsigned long flags);\n4270 long sys_set_mempolicy(int mode, const unsigned long __user *nmask, unsigned long maxnode);\n4271 long sys_mq_open(const char __user *name, int oflag, umode_t mode, struct mq_attr __user *attr);\n4272 long sys_mq_unlink(const char __user *name);\n4273 long sys_mq_timedsend_time32(mqd_t mqdes, const char __user *u_msg_ptr, unsigned int msg_len, unsigned int msg_prio, const struct old_timespec32 __user *u_abs_timeout);\n4274 long sys_mq_timedreceive_time32(mqd_t mqdes, char __user *u_msg_ptr, unsigned int msg_len, unsigned int __user *u_msg_prio, const struct old_timespec32 __user *u_abs_timeout);\n4275 long sys_mq_notify(mqd_t mqdes, const struct sigevent __user *notification);\n4276 long sys_mq_getsetattr(mqd_t mqdes, const struct mq_attr __user *mqstat, struct mq_attr __user *omqstat);\n// 4277 sys_vserver - UNIMPLEMENTED\n4278 long sys_waitid(int which, pid_t pid, struct siginfo __user *infop, int options, struct rusage __user *ru);\n// 4279 - ???\n4280 long sys_add_key(const char __user *_type, const char __user *_description, const void __user *_payload, size_t plen, key_serial_t destringid);\n4281 long sys_request_key(const char __user *_type, const char __user *_description, const char __user *_callout_info, key_serial_t destringid);\n4282 long sys_keyctl(int cmd, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\n4283 long set_thread_area(unsigned long tp);\n4284 long sys_inotify_init(void);\n4285 long sys_inotify_add_watch(int fd, const char __user *path, u32 mask);\n4286 long sys_inotify_rm_watch(int fd, __s32 wd);\n4287 long sys_migrate_pages(pid_t pid, unsigned long maxnode, const unsigned long __user *from, const unsigned long __user *to);\n4288 long sys_openat(int dfd, const char __user *filename, int flags, umode_t mode);\n```\n\n----------------------------------------\n\nTITLE: Loading PANDA PyPlugins by File Path and Class Name(s) (Python)\nDESCRIPTION: Presents methods for loading plugins from file paths, specifying one, multiple, or all classes using panda.pyplugins.load and load_all. Plugin file must define classes of interest. The argument dictionary is used for plugin configuration. Shows flexibility in loading strategy for general and advanced use.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/pyplugins.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\npanda.pyplugins.load((\"/tmp/plugin.py\", \"YourPlugin\"), {'path': '/foo'})\n```\n\nLANGUAGE: python\nCODE:\n```\npanda.pyplugins.load((\"/tmp/plugin.py\", [\"YourPlugin\", \"AnotherPlugin\"]), {'path': '/foo'})\n```\n\nLANGUAGE: python\nCODE:\n```\npanda.pyplugins.load_all(\"/tmp/plugin.py\", {'path': '/foo'})\n```\n\n----------------------------------------\n\nTITLE: Process Management System Call Declarations in C\nDESCRIPTION: Function declarations for Linux system calls related to process creation, termination, and management. These declarations define the interface for operations like creating new processes, managing execution flow, and gathering process information.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_18\n\nLANGUAGE: C\nCODE:\n```\nlong sys_sched_yield(void);\nlong sys_getpid(void);\nlong sys_clone(unsigned long, unsigned long, int __user *, int __user *, unsigned long);\nlong sys_fork(void);\nlong sys_execve(const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp);\nlong sys_exit(int error_code);\nlong sys_wait4(pid_t pid, int __user *stat_addr, int options, struct rusage __user *ru);\nlong sys_kill(pid_t pid, int sig);\nlong sys_pause(void);\nlong sys_getitimer(int which, struct __kernel_old_itimerval __user *value);\nlong sys_setitimer(int which, struct __kernel_old_itimerval __user *value, struct __kernel_old_itimerval __user *ovalue);\nlong sys_alarm(unsigned int seconds);\nlong sys_nanosleep_time32(struct old_timespec32 __user *rqtp, struct old_timespec32 __user *rmtp);\nlong sys_times(struct tms __user *tbuf);\nlong sys_ptrace(long request, long pid, unsigned long addr, unsigned long data);\nlong sys_setpgid(pid_t pid, pid_t pgid);\nlong sys_getppid(void);\nlong sys_getpgrp(void);\nlong sys_setsid(void);\nlong sys_getpgid(pid_t pid);\nlong sys_getsid(pid_t pid);\nlong sys_gettid(void);\nlong sys_sched_setparam(pid_t pid, struct sched_param __user *param);\nlong sys_sched_getparam(pid_t pid, struct sched_param __user *param);\nlong sys_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param);\nlong sys_sched_getscheduler(pid_t pid);\nlong sys_sched_get_priority_max(int policy);\nlong sys_sched_get_priority_min(int policy);\nlong sys_sched_rr_get_interval_time32(pid_t pid, struct old_timespec32 __user *interval);\nlong sys_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\n```\n\n----------------------------------------\n\nTITLE: System Information and Configuration System Call Declarations in C\nDESCRIPTION: Function declarations for Linux system calls related to system information retrieval and configuration. These declarations define the interface for querying and modifying system-wide settings and information.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/linux_mips64_prototypes.txt#_snippet_23\n\nLANGUAGE: C\nCODE:\n```\nlong sys_newuname(struct new_utsname __user *name);\nlong sys_sysinfo(struct sysinfo __user *info);\nlong sys_syslog(int type, char __user *buf, int len);\nlong sys_gettimeofday(struct __kernel_old_timeval __user *tv, struct timezone __user *tz);\nlong sys_getrlimit(unsigned int resource, struct rlimit __user *rlim);\nlong sys_getrusage(int who, struct rusage __user *ru);\nlong sys_personality(unsigned int personality);\nlong sys_getpriority(int which, int who);\nlong sys_setpriority(int which, int who, int niceval);\nlong sys_vhangup(void);\nlong sys_pivot_root(const char __user *new_root, const char __user *put_old);\nlong sys_sysctl(struct __sysctl_args __user *args);\nlong sys_adjtimex_time32(struct old_timex32 __user *txc_p);\nlong sys_setrlimit(unsigned int resource, struct rlimit __user *rlim);\nlong sys_chroot(const char __user *filename);\nlong sys_sync(void);\nlong sys_acct(const char __user *name);\nlong sys_settimeofday(struct __kernel_old_timeval __user *tv, struct timezone __user *tz);\nlong sys_swapon(const char __user *specialfile, int swap_flags);\nlong sys_swapoff(const char __user *specialfile);\nlong sys_reboot(int magic1, int magic2, unsigned int cmd, void __user *arg);\nlong sys_sethostname(char __user *name, int len);\nlong sys_setdomainname(char __user *name, int len);\nlong sys_init_module(void __user *umod, unsigned long len, const char __user *uargs);\nlong sys_delete_module(const char __user *name_user, unsigned int flags);\nlong sys_quotactl(unsigned int cmd, const char __user *special, qid_t id, void __user *addr);\nlong sys_utime32(const char __user *filename, struct old_utimbuf32 __user *t);\nlong sys_io_getevents_time32(__u32 ctx_id, __s32 min_nr, __s32 nr, struct io_event __user *events, struct old_timespec32 __user *timeout);\n```\n\n----------------------------------------\n\nTITLE: Using AioContext Functions in C for IOThread Support\nDESCRIPTION: This snippet demonstrates the recommended AioContext functions to use for IOThread-compatible code, replacing legacy main loop APIs. These functions allow monitoring file descriptors, event notifiers, creating timers and bottom halves, and running event loop iterations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/multiple-iothreads.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\naio_set_fd_handler() - monitor a file descriptor\naio_set_event_notifier() - monitor an event notifier\naio_timer_new() - create a timer\naio_bh_new() - create a BH\naio_poll() - run an event loop iteration\n```\n\n----------------------------------------\n\nTITLE: Access Check and Mount Operations in C\nDESCRIPTION: Function declarations for checking access permissions and mounting filesystems. Includes eaccess for effective permission checks and nmount for mounting filesystems.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_13\n\nLANGUAGE: c\nCODE:\n```\nint eaccess(const char *path, int amode);\nint afs3_syscall(long syscall, long parm1, long parm2, long parm3, long parm4, long parm5, long parm6);\nint nmount(struct iovec *iovp, unsigned int iovcnt, int flags);\n```\n\n----------------------------------------\n\nTITLE: Defining VMState for Keyboard Device in C\nDESCRIPTION: This snippet demonstrates how to define a VMState structure for a keyboard device using the VMState approach. It specifies the device name, version information, and the fields to be saved/loaded during migration.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/migration.txt#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nstatic const VMStateDescription vmstate_kbd = {\n    .name = \"pckbd\",\n    .version_id = 3,\n    .minimum_version_id = 3,\n    .fields = (VMStateField[]) {\n        VMSTATE_UINT8(write_cmd, KBDState),\n        VMSTATE_UINT8(status, KBDState),\n        VMSTATE_UINT8(mode, KBDState),\n        VMSTATE_UINT8(pending, KBDState),\n        VMSTATE_END_OF_LIST()\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Declaring Capability and Resource Control System Calls in C for FreeBSD\nDESCRIPTION: This snippet declares system calls for capability-based security and resource control in FreeBSD, including functions for managing capability rights, resource limits, and jails.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_25\n\nLANGUAGE: C\nCODE:\n```\nint __cap_rights_get(int version, int fd, cap_rights_t *rightsp);\nint cap_enter(void);\nint cap_getmode(unsigned *modep);\nint rctl_get_racct(const void *inbufp, size_t inbuflen, void *outbufp, size_t outbuflen);\nint rctl_get_rules(const void *inbufp, size_t inbuflen, void *outbufp, size_t outbuflen);\nint rctl_get_limits(const void *inbufp, size_t inbuflen, void *outbufp, size_t outbuflen);\nint rctl_add_rule(const void *inbufp, size_t inbuflen, void *outbufp, size_t outbuflen);\nint rctl_remove_rule(const void *inbufp, size_t inbuflen, void *outbufp, size_t outbuflen);\nint jail_get(struct iovec *iovp, unsigned int iovcnt, int flags);\nint jail_set(struct iovec *iovp, unsigned int iovcnt, int flags);\nint jail_remove(int jid);\n```\n\n----------------------------------------\n\nTITLE: Declaring Miscellaneous System Calls in C for FreeBSD\nDESCRIPTION: This snippet declares various miscellaneous system calls in FreeBSD, including functions for getting random data, managing file handles, and performing system-specific operations.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_27\n\nLANGUAGE: C\nCODE:\n```\nint getrandom(void *buf, size_t buflen, unsigned int flags);\nint getfhat(int fd, char *path, struct fhandle *fhp, int flags);\nint fhlink(struct fhandle *fhp, const char *to);\nint fhlinkat(struct fhandle *fhp, int tofd, const char *to,);\nint fhreadlink(struct fhandle *fhp, char *buf, size_t bufsize);\nssize_t copy_file_range(int infd, off_t *inoffp, int outfd, off_t *outoffp, size_t len, unsigned int flags);\nint __sysctlbyname(const char *name, size_t namelen, void *old, size_t *oldlenp, void *new, size_t newlen);\nint sigfastblock(int cmd, uint32_t *ptr);\nint __realpathat(int fd, const char *path, char *buf, size_t size, int flags);\nint close_range(unsigned lowfd, unsigned highfd, int flags);\nint rpctls_syscall(int op, const char *path);\n```\n\n----------------------------------------\n\nTITLE: Using TCG and VCPU Trace Event Properties in QEMU\nDESCRIPTION: Shows how to use the 'tcg' and 'vcpu' trace event properties in QEMU's C code for tracing guest code execution and vCPU-specific information.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/tracing.txt#_snippet_16\n\nLANGUAGE: c\nCODE:\n```\n#include \"trace-tcg.h\"\n\nCPUArchState *env;\nTCGv_ptr cpu_env;\n\nvoid some_disassembly_func(...)\n{\n    /* trace emitted at this point */\n    trace_foo(0xd1);\n    /* trace emitted at this point */\n    trace_bar(ENV_GET_CPU(env), 0xd2);\n    /* trace emitted at this point (env) and when guest code is executed (cpu_env) */\n    trace_baz_tcg(ENV_GET_CPU(env), cpu_env, 0xd3);\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting Root Ports and DMI-PCI bridges to a secondary PCIe Root Bus\nDESCRIPTION: Commands for connecting PCIe Root Ports or DMI-PCI bridges to a secondary PCIe Root Bus (pcie.1). These are the only device types that should be connected directly to additional root buses.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/pcie.txt#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n-device ioh3420,id=root_port1[,bus=pcie.1][,chassis=x][,slot=y][,addr=z]\n-device i82801b11-bridge,id=dmi_pci_bridge1,bus=pcie.1\n```\n\n----------------------------------------\n\nTITLE: Creating Drained Sections for Block Devices in C\nDESCRIPTION: This snippet illustrates how to create a drained section for block devices running in an IOThread. It ensures that past requests from the guest are completed and allows safe access to the block device from the monitor.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/multiple-iothreads.txt#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\naio_context_acquire(bdrv_get_aio_context(bs))\nbdrv_drained_begin()\n// Your code here\nbdrv_drained_end()\naio_context_release(bdrv_get_aio_context(bs))\n```\n\n----------------------------------------\n\nTITLE: Detecting PCI Express Devices using lspci\nDESCRIPTION: This command uses the lspci tool to check if a specific PCI device is PCI Express. It displays detailed information about the device, including its capabilities. The presence of the 'Express Endpoint' capability indicates a PCI Express device.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/pcie.txt#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nlspci -s 03:00.0 -v\n```\n\n----------------------------------------\n\nTITLE: Executing Hot-Plug Operation in QEMU Monitor\nDESCRIPTION: This command demonstrates how to add a device using hot-plug in the QEMU Human Monitor Interface (HMP). It requires specifying the device type, a unique ID, and the target bus for the new device.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/pcie.txt#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ndevice_add <dev>,id=<id>,bus=<PCI Express Root Port Id/PCI Express Downstream Port Id/PCI-PCI Bridge Id/>\n```\n\n----------------------------------------\n\nTITLE: Recording HD to I/O Buffer Transfer in C\nDESCRIPTION: Code from ide_sector_read that records hard drive to I/O buffer transfers during record mode, which inserts entries into the replay log using rr_record_hd_transfer.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/hd_taint.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nrr_record_hd_transfer\n  (RR_CALLSITE_IDE_SECTOR_READ,\n   HD_TRANSFER_HD_TO_IOB,\n   HD_BASE_ADDR + sector_num*512,\n   (uint64_t) s->io_buffer,\n   n*512);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating QMP Downstream Command Naming Convention\nDESCRIPTION: This example shows the recommended naming convention for downstream-specific QMP commands. It uses a reverse fully qualified domain name (RFQDN) prefix to ensure uniqueness and compatibility.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/qmp-spec.txt#_snippet_11\n\nLANGUAGE: qmp\nCODE:\n```\n(qemu) __org.linux-kvm_enable_irqchip\n```\n\n----------------------------------------\n\nTITLE: Vector I/O Operations with Position in C\nDESCRIPTION: Function declarations for position-specific vector I/O operations. These functions perform scatter/gather I/O at a specific offset in the file.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/syscalls2/generated-in/freebsd_x64_prototypes.txt#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nssize_t preadv(int fd, struct iovec *iovp, unsigned iovcnt, off_t offset);\nssize_t pwritev(int fd, struct iovec *iovp, unsigned iovcnt, off_t offset);\n```\n\n----------------------------------------\n\nTITLE: Changing Polling Interval for Virtio Balloon Memory Statistics in QEMU\nDESCRIPTION: This snippet shows how to change the polling interval to 10 seconds for memory statistics using the QEMU Object Model (QOM) interface.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/virtio-balloon-stats.txt#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{ \"execute\": \"qom-set\",\n             \"arguments\": { \"path\": \"/machine/peripheral-anon/device[1]\",\n\t\t\t \"property\": \"guest-stats-polling-interval\", \"value\": 10 } }\n\n{ \"return\": {} }\n```\n\n----------------------------------------\n\nTITLE: Disabling Polling for Virtio Balloon Memory Statistics in QEMU\nDESCRIPTION: This snippet shows how to disable polling for memory statistics by setting the polling interval to 0 using the QEMU Object Model (QOM) interface.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/virtio-balloon-stats.txt#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{ \"execute\": \"qom-set\",\n             \"arguments\": { \"path\": \"/machine/peripheral-anon/device[1]\",\n\t\t\t \"property\": \"stats-polling-interval\", \"value\": 0 } }\n\n{ \"return\": {} }\n```\n\n----------------------------------------\n\nTITLE: Running PANDA Replay with Keyfind Plugin\nDESCRIPTION: Command to replay a PANDA recording with the keyfind plugin enabled for detecting SSL/TLS master secret generation code.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/panda_ssltut.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\necho \"begin_replay ssltut\" | \\\n    x86_64-softmmu/panda-system-x86_64 -hda debian_squeeze_i386_desktop_tut.qcow2 \\\n    -m 256 -monitor stdio -vnc :0 -net nic,model=e1000 -net user \\\n    -panda \"callstack_instr;keyfind\"\n```\n\n----------------------------------------\n\nTITLE: Symbol Resolution Hook Function in C\nDESCRIPTION: Function that allows setting up callbacks for when specific symbols are resolved. Used by the 'hooks' system to establish hooks on future resolved symbols.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/dynamic_symbols/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nvoid hook_symbol_resolution(struct symbol_hook *h)\n```\n\n----------------------------------------\n\nTITLE: Searching for Pattern in Memory Dump (Bash)\nDESCRIPTION: This command searches for 'foo' in the tap_reads.bin file, extracts the byte offsets, and saves them to foo_offsets.txt.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/plugins/tapindex/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngrep -bao 'foo' tap_reads.bin | cut -d: -f1 > foo_offsets.txt\n```\n\n----------------------------------------\n\nTITLE: Hard Drive Transfer Replay Callback Signature\nDESCRIPTION: Callback function signature for replaying hard drive data transfers.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#_snippet_51\n\nLANGUAGE: C\nCODE:\n```\nint (*replay_hd_transfer)(CPUState *env, uint32_t type, uint64_t src_addr, uint64_t dest_addr, uint32_t num_bytes);\n```\n\n----------------------------------------\n\nTITLE: QED Table Structure Definition in C\nDESCRIPTION: Definition of the table structure used for L1 and L2 tables in QED format, with a macro for calculating the number of offsets.\nSOURCE: https://github.com/panda-re/panda/blob/dev/docs/specs/qed_spec.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#define TABLE_NOFFSETS (table_size * cluster_size / sizeof(uint64_t))\n\nTable {\n    uint64_t offsets[TABLE_NOFFSETS];\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Pandalog Output File\nDESCRIPTION: PANDA command-line argument to specify the output pandalog file for recording the replay data.\nSOURCE: https://github.com/panda-re/panda/blob/dev/panda/docs/stuw.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n-pandalog mypandalogfile\n```"
  }
]