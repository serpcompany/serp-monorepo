[
  {
    "owner": "rust-lang",
    "repo": "reference.git",
    "content": "TITLE: Printing Hello World in Rust\nDESCRIPTION: This Rust code snippet demonstrates a basic 'Hello World' program. It includes a 'main' function that utilizes the 'println!' macro to output the string to the console. This is a straightforward example illustrating the syntax for function definition and output in Rust. No additional dependencies are required for this snippet; it's suitable for a command-line execution environment.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/introduction.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# // This is a hidden line.\\nfn main() {\\n    println!(\\\"This is a code example\\\");\\n}\n```\n\n----------------------------------------\n\nTITLE: Basic If-Else Conditional Branching in Rust\nDESCRIPTION: Example showing a basic if-else if-else conditional structure for program flow control based on evaluating a variable, and another example showing assignment of a value based on an if condition.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/if-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# let x = 3;\nif x == 4 {\n    println!(\"x is four\");\n} else if x == 3 {\n    println!(\"x is three\");\n} else {\n    println!(\"x is something else\");\n}\n\nlet y = if 12 * 15 > 150 {\n    \"Bigger\"\n} else {\n    \"Smaller\"\n};\nassert_eq!(y, \"Bigger\");\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Traits in Rust\nDESCRIPTION: Example of a generic trait definition with type parameters, including methods that use the generic type.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/traits.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait Seq<T> {\n    fn len(&self) -> u32;\n    fn elt_at(&self, n: u32) -> T;\n    fn iter<F>(&self, f: F) where F: Fn(T);\n}\n```\n\n----------------------------------------\n\nTITLE: Refutable Pattern Matching in Rust\nDESCRIPTION: Demonstrates the concept of refutable and irrefutable patterns, showing how different pattern matching scenarios behave\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet (x, y) = (1, 2);               // \"(x, y)\" is an irrefutable pattern\n\nif let (a, 3) = (1, 2) {           // \"(a, 3)\" is refutable, and will not match\n    panic!(\"Shouldn't reach here\");\n} else if let (a, 4) = (3, 4) {    // \"(a, 4)\" is refutable, and will match\n    println!(\"Matched ({}, 4)\", a);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Basic Closure Usage and Type Representation in Rust\nDESCRIPTION: This example demonstrates how a closure captures variables from its environment and shows a simplified representation of the anonymous struct type that the compiler generates for the closure.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nstruct Point { x: i32, y: i32 }\nstruct Rectangle { left_top: Point, right_bottom: Point }\n\nfn f<F : FnOnce() -> String> (g: F) {\n    println!(\"{}\", g());\n}\n\nlet mut rect = Rectangle {\n    left_top: Point { x: 1, y: 1 },\n    right_bottom: Point { x: 0, y: 0 }\n};\n\nlet c = || {\n    rect.left_top.x += 1;\n    rect.right_bottom.x += 1;\n    format!(\"{:?}\", rect.left_top)\n};\nf(c); // Prints \"Point { x: 2, y: 1 }\".\n```\n\n----------------------------------------\n\nTITLE: Path Expression Usage Examples in Rust\nDESCRIPTION: Demonstrates various uses of path expressions including local variables, static variables, mutable static variables in unsafe blocks, and type-associated functions. Shows how to access different kinds of variables and constructors safely.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/path-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# mod globals {\n#     pub static STATIC_VAR: i32 = 5;\n#     pub static mut STATIC_MUT_VAR: i32 = 7;\n# }\n# let local_var = 3;\nlocal_var;\nglobals::STATIC_VAR;\nunsafe { globals::STATIC_MUT_VAR };\nlet some_constructor = Some::<i32>;\nlet push_integer = Vec::<i32>::push;\nlet slice_reverse = <[i32]>::reverse;\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Function in Rust\nDESCRIPTION: This snippet demonstrates the basic syntax for creating a function in Rust that returns an integer value. The function is named `answer_to_life_the_universe_and_everything` and returns the integer 42.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/functions.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn answer_to_life_the_universe_and_everything() -> i32 {\n    return 42;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Match Expression Example in Rust\nDESCRIPTION: Demonstrates a simple match expression matching an integer value against multiple patterns.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/match-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 1;\n\nmatch x {\n    1 => println!(\"one\"),\n    2 => println!(\"two\"),\n    3 => println!(\"three\"),\n    4 => println!(\"four\"),\n    5 => println!(\"five\"),\n    _ => println!(\"something else\"),\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Dyn-Incompatible Traits in Rust\nDESCRIPTION: Examples of traits that are not compatible with trait objects, including associated constants, non-sized associated functions, and generic methods.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/traits.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# use std::rc::Rc;\n// Examples of dyn-incompatible traits.\ntrait DynIncompatible {\n    const CONST: i32 = 1;  // ERROR: cannot have associated const\n\n    fn foo() {}  // ERROR: associated function without Sized\n    fn returns(&self) -> Self; // ERROR: Self in return type\n    fn typed<T>(&self, x: T) {} // ERROR: has generic type parameters\n    fn nested(self: Rc<Box<Self>>) {} // ERROR: nested receiver not yet supported\n}\n\nstruct S;\nimpl DynIncompatible for S {\n    fn returns(&self) -> Self { S }\n}\nlet obj: Box<dyn DynIncompatible> = Box::new(S); // ERROR\n```\n\n----------------------------------------\n\nTITLE: Implementing Traits for a Circle Struct in Rust\nDESCRIPTION: Demonstrates implementing multiple traits (Copy, Clone, Shape) for a Circle struct, including method definitions and associated functions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/implementations.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Circle {\n    radius: f64,\n    center: Point,\n}\n\nimpl Copy for Circle {}\n\nimpl Clone for Circle {\n    fn clone(&self) -> Circle { *self }\n}\n\nimpl Shape for Circle {\n    fn draw(&self, s: Surface) { do_draw_circle(s, *self); }\n    fn bounding_box(&self) -> BoundingBox {\n        let r = self.radius;\n        BoundingBox {\n            x: self.center.x - r,\n            y: self.center.y - r,\n            width: 2.0 * r,\n            height: 2.0 * r,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a New Function for a Struct in Rust\nDESCRIPTION: This code snippet defines a new associated function for a struct named 'Struct'. The 'new' function initializes a new instance of the struct with a default field value. It demonstrates how to define associated functions within an `impl` block in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Struct {\n    field: i32\n}\n\nimpl Struct {\n    fn new() -> Struct {\n        Struct {\n            field: 0i32\n        }\n    }\n}\n\nfn main () {\n    let _struct = Struct::new();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Module with Functions in Rust\nDESCRIPTION: This code snippet demonstrates the definition of a module named `math` in Rust, which contains type and function declarations for trigonometric computations. It illustrates how to create a module with nested functions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/modules.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod math {\n    type Complex = (f64, f64);\n    fn sin(f: f64) -> f64 {\n        /* ... */\n#       unimplemented!();\n    }\n    fn cos(f: f64) -> f64 {\n        /* ... */\n#       unimplemented!();\n    }\n    fn tan(f: f64) -> f64 {\n        /* ... */\n#       unimplemented!();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Trait and Using `impl Trait` in Argument Position - Rust\nDESCRIPTION: Demonstrates how to define a trait and utilize `impl Trait` as an anonymous type parameter in function definitions. It shows how `impl Trait` can be used for function arguments instead of a generic type parameter.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/impl-trait.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {}\n\n// argument position: anonymous type parameter\nfn foo(arg: impl Trait) {\n}\n\n// return position: abstract return type\nfn bar() -> impl Trait {\n}\n```\n\n----------------------------------------\n\nTITLE: Associated Constant Example in Rust\nDESCRIPTION: This code demonstrates a basic example of using associated constants in a Rust trait. It defines a trait `ConstantId` with an associated constant `ID` and implements it for a struct `Struct`. The `main` function asserts that the value of `Struct::ID` is 1.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n```rust\ntrait ConstantId {\n    const ID: i32;\n}\n\nstruct Struct;\n\nimpl ConstantId for Struct {\n    const ID: i32 = 1;\n}\n\nfn main() {\n    assert_eq!(1, Struct::ID);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing While Loop in Rust\nDESCRIPTION: This code demonstrates a while loop in Rust that prints 'hello' 10 times. It uses a mutable variable 'i' as a counter to control the loop execution.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/loop-expr.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet mut i = 0;\n\nwhile i < 10 {\n    println!(\"hello\");\n    i = i + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Parameters Syntax\nDESCRIPTION: This snippet describes the grammar rules for defining generic parameters in Rust, including syntax for lifetime, type, and const parameters.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/generics.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```grammar,items\nGenericParams -> `<` ( GenericParam (`,` GenericParam)* `,`? )? `>`\n\nGenericParam -> OuterAttribute* ( LifetimeParam | TypeParam | ConstParam )\n\nLifetimeParam -> Lifetime ( `:` LifetimeBounds )?\n\nTypeParam -> IDENTIFIER ( `:` TypeParamBounds? )? ( `=` Type )?\n\nConstParam ->\n    `const` IDENTIFIER `:` Type\n    ( `=` BlockExpression | IDENTIFIER | `-`?LiteralExpression )?\n```\n```\n\n----------------------------------------\n\nTITLE: Trait Object Implementation Example\nDESCRIPTION: Practical example demonstrating trait object usage with a Printable trait implementation, showing virtual dispatch and dynamic binding.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/trait-object.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Printable {\n    fn stringify(&self) -> String;\n}\n\nimpl Printable for i32 {\n    fn stringify(&self) -> String { self.to_string() }\n}\n\nfn print(a: Box<dyn Printable>) {\n    println!(\"{}\", a.stringify());\n}\n\nfn main() {\n    print(Box::new(10) as Box<dyn Printable>);\n}\n```\n\n----------------------------------------\n\nTITLE: Trait Implementation and Usage in Rust\nDESCRIPTION: This example demonstrates how trait bounds enable calling methods and using associated constants of a trait within a generic function. It shows how the `Shape` trait is used in `draw_twice`, `copy_and_draw_twice`, and `name_figure` functions to operate on types that implement the trait.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/trait-bounds.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n\"# type Surface = i32;\ntrait Shape {\n    fn draw(&self, surface: Surface);\n    fn name() -> &'static str;\n}\n\nfn draw_twice<T: Shape>(surface: Surface, sh: T) {\n    sh.draw(surface);           // Can call method because T: Shape\n    sh.draw(surface);\n}\n\nfn copy_and_draw_twice<T: Copy>(surface: Surface, sh: T) where T: Shape {\n    let shape_copy = sh;        // doesn't move sh because T: Copy\n    draw_twice(surface, sh);    // Can use generic function because T: Shape\n}\n\nstruct Figure<S: Shape>(S, S);\n\nfn name_figure<U: Shape>(\n    figure: Figure<U>,          // Type Figure<U> is well-formed because U: Shape\n) {\n    println!(\n        \\\"Figure of two {}\\\",\n        U::name(),              // Can use associated function\n    );\n}\"\n```\n\n----------------------------------------\n\nTITLE: Basic Struct Type Reference in Rust\nDESCRIPTION: Demonstrates the basic syntax reference for a struct type in Rust. Structs are heterogeneous products of other types, with their fields being accessible by name.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/struct.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n`struct`\n```\n\n----------------------------------------\n\nTITLE: Generic Function Definition in Rust\nDESCRIPTION: This example shows how to define a generic function in Rust with type parameters A and B. The function `foo` takes two parameters of generic types.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/functions.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// foo is generic over A and B\n\nfn foo<A, B>(x: A, y: B) {\n# }\n\n```\n\n----------------------------------------\n\nTITLE: Comparing Slices with Implicit Borrows in Rust\nDESCRIPTION: Demonstrates how Rust implicitly borrows operands when comparing two unsized slices for equality. The example shows both the direct comparison and its equivalent explicit form using the PartialEq trait.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# let c = [1, 2, 3];\n# let d = vec![1, 2, 3];\nlet a: &[i32];\nlet b: &[i32];\n# a = &c;\n# b = &d;\n// ...\n*a == *b;\n// Equivalent form:\n::std::cmp::PartialEq::eq(&*a, &*b);\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Regular Struct in Rust\nDESCRIPTION: Example of defining a regular struct 'Point' with two integer fields and creating an instance of it.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/structs.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point {x: i32, y: i32}\nlet p = Point {x: 10, y: 11};\nlet px: i32 = p.x;\n```\n\n----------------------------------------\n\nTITLE: Complex Pattern Matching Example in Rust\nDESCRIPTION: Demonstrates pattern matching with struct fields, testing conditions, binding variables, and using multiple matching techniques\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nif let\n    Person {\n        car: Some(_),\n        age: person_age @ 13..=19,\n        name: ref person_name,\n        ..\n    } = person\n{\n    println!(\"{} has a car and is {} years old.\", person_name, person_age);\n}\n```\n\n----------------------------------------\n\nTITLE: Using asm! Macro for Inline Assembly in Rust\nDESCRIPTION: Shows how to use the asm! macro to embed inline assembly within a Rust function. The example demonstrates passing a value to the assembly code using an input register.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nunsafe { core::arch::asm!(\"/* {} */\", in(reg) 0); }\n```\n\n----------------------------------------\n\nTITLE: Creating Enum with Named and Unnamed Fields in Rust\nDESCRIPTION: Shows how to define an enum with both tuple-like and struct-like variants, including field declarations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/enumerations.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum Animal {\n    Dog(String, f64),\n    Cat { name: String, weight: f64 },\n}\n\nlet mut a: Animal = Animal::Dog(\"Cocoa\".to_string(), 37.2);\na = Animal::Cat { name: \"Spotty\".to_string(), weight: 2.7 };\n```\n\n----------------------------------------\n\nTITLE: Implementing Recursive Types in Rust\nDESCRIPTION: Demonstrates how to create and use a recursive data structure in Rust using a Box pointer type to ensure the size remains finite. This example implements a linked list as an enum.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nenum List<T> {\n    Nil,\n    Cons(T, Box<List<T>>)\n}\n\nlet a: List<i32> = List::Cons(7, Box::new(List::Cons(13, Box::new(List::Nil))));\n```\n\n----------------------------------------\n\nTITLE: Generic Function with Trait Bounds in Rust\nDESCRIPTION: This snippet demonstrates defining a generic function `foo` with a trait bound specifying that the type parameter T must implement the Debug trait.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/functions.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# use std::fmt::Debug;\nfn foo<T>(x: T) where T: Debug {\n# }\n\n```\n\n----------------------------------------\n\nTITLE: Basic Closure Examples in Rust\nDESCRIPTION: Examples showing different ways to use closures, including basic usage, type annotations, and moving values from the environment.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/closure-expr.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn ten_times<F>(f: F) where F: Fn(i32) {\n    for index in 0..10 {\n        f(index);\n    }\n}\n\nten_times(|j| println!(\"hello, {}\", j));\n// With type annotations\nten_times(|j: i32| -> () { println!(\"hello, {}\", j) });\n\nlet word = \"konnichiwa\".to_owned();\nten_times(move |j| println!(\"{}, {}\", word, j));\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Rust Attribute Usage\nDESCRIPTION: Provides examples of various attribute types in Rust, including crate-level attributes, function attributes, conditional compilation, and lint suppression.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// General metadata applied to the enclosing module or crate.\n#![crate_type = \"lib\"]\n\n// A function marked as a unit test\n#[test]\nfn test_foo() {\n    /* ... */\n}\n\n// A conditionally-compiled module\n#[cfg(target_os = \"linux\")]\nmod bar {\n    /* ... */\n}\n\n// A lint attribute used to suppress a warning/error\n#[allow(non_camel_case_types)]\ntype int8_t = i8;\n\n// Inner attribute applies to the entire function.\nfn some_unused_variables() {\n  #![allow(unused_variables)]\n\n  let x = ();\n  let y = ();\n  let z = ();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Arithmetic and Logical Operators in Rust\nDESCRIPTION: This snippet provides examples of how various arithmetic and logical binary operators are utilized in Rust code. The examples assert expected results for operations including addition, multiplication, and logical operations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nassert_eq!(3 + 6, 9);\nassert_eq!(5.5 - 1.25, 4.25);\nassert_eq!(-5 * 14, -70);\nassert_eq!(14 / 3, 4);\nassert_eq!(100 % 7, 2);\nassert_eq!(0b1010 & 0b1100, 0b1000);\nassert_eq!(0b1010 | 0b1100, 0b1110);\nassert_eq!(0b1010 ^ 0b1100, 0b110);\nassert_eq!(13 << 3, 104);\nassert_eq!(-10 >> 2, -3);\n```\n\n----------------------------------------\n\nTITLE: Type Alias Example\nDESCRIPTION: Illustrates a simple type alias declaration, defining `Point` as an alias for a tuple of two `u8` integers. It shows how to declare a variable of the alias type and assign a value to it.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/type-aliases.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n\"type Point = (u8, u8);\nlet p: Point = (41, 68);\"\n```\n\n----------------------------------------\n\nTITLE: Defining Trait Methods with Parameter Types in Rust\nDESCRIPTION: This snippet demonstrates how to define a trait with methods that include parameters. The 'Shape' trait specifies methods for drawing and bounding box calculations, and an example implementation for a 'Circle' struct is provided.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# type Surface = i32;\n# type BoundingBox = i32;\ntrait Shape {\n    fn draw(&self, surface: Surface);\n    fn bounding_box(&self) -> BoundingBox;\n}\n\n# struct Circle {\n    // ...\n}\n\nimpl Shape for Circle {\n    // ...\n#   fn draw(&self, _: Surface) {}\n#   fn bounding_box(&self) -> BoundingBox { 0i32 }\n}\n\n# impl Circle {\n#     fn new() -> Circle { Circle{} }\n# }\n#\nlet circle_shape = Circle::new();\nlet bounding_box = circle_shape.bounding_box();\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Enum in Rust\nDESCRIPTION: Demonstrates the declaration and usage of a simple enum with unit variants.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/enumerations.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum Animal {\n    Dog,\n    Cat,\n}\n\nlet mut a: Animal = Animal::Dog;\na = Animal::Cat;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Various Struct Expressions in Rust\nDESCRIPTION: Provides examples of different struct expressions in Rust, including regular structs, tuple structs, and unit structs. It also demonstrates the use of struct expressions in function calls.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/struct-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# struct Point { x: f64, y: f64 }\n# struct NothingInMe { }\n# struct TuplePoint(f64, f64);\n# mod game { pub struct User<'a> { pub name: &'a str, pub age: u32, pub score: usize } }\n# struct Cookie; fn some_fn<T>(t: T) {}\nPoint {x: 10.0, y: 20.0};\nNothingInMe {};\nTuplePoint(10.0, 20.0);\nTuplePoint { 0: 10.0, 1: 20.0 }; // Results in the same value as the above line\nlet u = game::User {name: \"Joe\", age: 35, score: 100_000};\nsome_fn::<Cookie>(Cookie);\n```\n\n----------------------------------------\n\nTITLE: Overloading Compound Assignments Using Traits in Rust\nDESCRIPTION: Explains how compound assignments can be syntactic sugar for trait function calls. The sample code defines an `AddAssign` trait implementation for a custom type. Understanding of Rust's trait system and operator overloading is necessary.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_36\n\nLANGUAGE: rust\nCODE:\n```\n# struct Addable;\n# use std::ops::AddAssign;\n\nimpl AddAssign<Addable> for Addable {\n    /* */\n# fn add_assign(&mut self, other: Addable) {}\n}\n\nfn example() {\n# let (mut a1, a2) = (Addable, Addable);\n  a1 += a2;\n\n# let (mut a1, a2) = (Addable, Addable);\n  AddAssign::add_assign(&mut a1, a2);\n}\n```\n\n----------------------------------------\n\nTITLE: Example Methods Implementation on a Struct in Rust\nDESCRIPTION: This snippet defines multiple methods on a struct 'Example' and demonstrates the usage of different types for the 'self' parameter. Various types are permitted for the 'self' parameter, which is used to call methods in different contexts.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use std::rc::Rc;\n# use std::sync::Arc;\n# use std::pin::Pin;\n// Examples of methods implemented on struct `Example`.\nstruct Example;\ntype Alias = Example;\ntrait Trait { type Output; }\nimpl Trait for Example { type Output = Example; }\nimpl Example {\n    fn by_value(self: Self) {}\n    fn by_ref(self: &Self) {}\n    fn by_ref_mut(self: &mut Self) {}\n    fn by_box(self: Box<Self>) {}\n    fn by_rc(self: Rc<Self>) {}\n    fn by_arc(self: Arc<Self>) {}\n    fn by_pin(self: Pin<&Self>) {}\n    fn explicit_type(self: Arc<Example>) {}\n    fn with_lifetime<'a>(self: &'a Self) {}\n    fn nested<'a>(self: &mut &'a Arc<Rc<Box<Alias>>>) {}\n    fn via_projection(self: <Example as Trait>::Output) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Canonical Paths in Rust\nDESCRIPTION: An example illustrating canonical paths in Rust. This shows how different items are canonically referenced within a crate, including modules, structs, traits, and implementations. The code demonstrates both items with and without canonical paths.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/paths.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n// Comments show the canonical path of the item.\n\nmod a { // crate::a\n    pub struct Struct; // crate::a::Struct\n\n    pub trait Trait { // crate::a::Trait\n        fn f(&self); // crate::a::Trait::f\n    }\n\n    impl Trait for Struct {\n        fn f(&self) {} // <crate::a::Struct as crate::a::Trait>::f\n    }\n\n    impl Struct {\n        fn g(&self) {} // <crate::a::Struct>::g\n    }\n}\n\nmod without { // crate::without\n    fn canonicals() { // crate::without::canonicals\n        struct OtherStruct; // None\n\n        trait OtherTrait { // None\n            fn g(&self); // None\n        }\n\n        impl OtherTrait for OtherStruct {\n            fn g(&self) {} // None\n        }\n\n        impl OtherTrait for crate::a::Struct {\n            fn g(&self) {} // None\n        }\n\n        impl crate::a::Trait for OtherStruct {\n            fn f(&self) {} // None\n        }\n    }\n}\n\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Using Supertrait Methods in Rust\nDESCRIPTION: Examples of calling supertrait methods on generic parameters and trait objects.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/traits.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n# trait Shape { fn area(&self) -> f64; }\n# trait Circle: Shape { fn radius(&self) -> f64; }\nfn print_area_and_radius<C: Circle>(c: C) {\n    // Here we call the area method from the supertrait `Shape` of `Circle`.\n    println!(\"Area: {}\", c.area());\n    println!(\"Radius: {}\", c.radius());\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n# trait Shape { fn area(&self) -> f64; }\n# trait Circle: Shape { fn radius(&self) -> f64; }\n# struct UnitCircle;\n# impl Shape for UnitCircle { fn area(&self) -> f64 { std::f64::consts::PI } }\n# impl Circle for UnitCircle { fn radius(&self) -> f64 { 1.0 } }\n# let circle = UnitCircle;\nlet circle = Box::new(circle) as Box<dyn Circle>;\nlet nonsense = circle.radius() * circle.area();\n```\n\n----------------------------------------\n\nTITLE: Usage Examples of Generic Parameters\nDESCRIPTION: This snippet provides examples of various Rust items that are parameterized by types, constants, and lifetimes, demonstrating valid declarations of functions, traits, structs, and generics.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/generics.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nfn foo<'a, T>() {}\ntrait A<U> {}\nstruct Ref<'a, T> where T: 'a { r: &'a T }\nstruct InnerArray<T, const N: usize>([T; N]);\nstruct EitherOrderWorks<const N: bool, U>(U);\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Identifier Grammar Rules in Rust\nDESCRIPTION: Formal grammar specification for Rust identifiers, including regular and raw identifiers. Defines the lexical structure using XID_Start and XID_Continue Unicode properties, with special handling for keywords and raw identifiers prefixed with r#.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/identifiers.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nIDENTIFIER_OR_KEYWORD ->\n      XID_Start XID_Continue*\n    | `_` XID_Continue+\n\nXID_Start -> <`XID_Start` defined by Unicode>\n\nXID_Continue -> <`XID_Continue` defined by Unicode>\n\nRAW_IDENTIFIER -> `r#` IDENTIFIER_OR_KEYWORD _except `crate`, `self`, `super`, `Self`_\n\nNON_KEYWORD_IDENTIFIER -> IDENTIFIER_OR_KEYWORD _except a [strict][lex.keywords.strict] or [reserved][lex.keywords.reserved] keyword_\n\nIDENTIFIER -> NON_KEYWORD_IDENTIFIER | RAW_IDENTIFIER\n\nRESERVED_RAW_IDENTIFIER -> `r#_`\n```\n\n----------------------------------------\n\nTITLE: Defining Supertraits in Rust\nDESCRIPTION: Examples of declaring supertraits using trait bounds and where clauses, including a default implementation using a supertrait method.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/traits.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\ntrait Shape { fn area(&self) -> f64; }\ntrait Circle: Shape { fn radius(&self) -> f64; }\n```\n\nLANGUAGE: rust\nCODE:\n```\ntrait Shape { fn area(&self) -> f64; }\ntrait Circle where Self: Shape { fn radius(&self) -> f64; }\n```\n\nLANGUAGE: rust\nCODE:\n```\n# trait Shape { fn area(&self) -> f64; }\ntrait Circle where Self: Shape {\n    fn radius(&self) -> f64 {\n        // A = pi * r^2\n        // so algebraically,\n        // r = sqrt(A / pi)\n        (self.area() / std::f64::consts::PI).sqrt()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Associated Type Implementation in Rust\nDESCRIPTION: Demonstrates a complete example of defining and using associated types. Shows trait declaration, implementation for a struct, and usage of the associated type reference syntax.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\ntrait AssociatedType {\n    // Associated type declaration\n    type Assoc;\n}\n\nstruct Struct;\n\nstruct OtherStruct;\n\nimpl AssociatedType for Struct {\n    // Associated type definition\n    type Assoc = OtherStruct;\n}\n\nimpl OtherStruct {\n    fn new() -> OtherStruct {\n        OtherStruct\n    }\n}\n\nfn main() {\n    // Usage of the associated type to refer to OtherStruct as <Struct as AssociatedType>::Assoc\n    let _other_struct: OtherStruct = <Struct as AssociatedType>::Assoc::new();\n}\n```\n\n----------------------------------------\n\nTITLE: Must Use Attribute in Rust\nDESCRIPTION: Showcases the must_use attribute to ensure that certain return values are used in Rust. This snippet demonstrates its application on structs, functions, and traits. Requires a Rust environment to enforce the unused_must_use lint.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/diagnostics.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n#[must_use]\nstruct MustUse {\n    // some fields\n}\n\n# impl MustUse {\n#   fn new() -> MustUse { MustUse {} }\n# }\n#\n// Violates the `unused_must_use` lint.\nMustUse::new();\n```\n\nLANGUAGE: rust\nCODE:\n```\n#[must_use]\nfn five() -> i32 { 5i32 }\n\n// Violates the unused_must_use lint.\nfive();\n```\n\nLANGUAGE: rust\nCODE:\n```\n#[must_use]\ntrait Critical {}\nimpl Critical for i32 {}\n\nfn get_critical() -> impl Critical {\n    4i32\n}\n\n// Violates the `unused_must_use` lint.\nget_critical();\n```\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n    #[must_use]\n    fn use_me(&self) -> i32;\n}\n\nimpl Trait for i32 {\n    fn use_me(&self) -> i32 { 0i32 }\n}\n\n// Violates the `unused_must_use` lint.\n5i32.use_me();\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Method Calls in Rust\nDESCRIPTION: Example of method calls in Rust, showing parsing a string to a float and then calculating its logarithm. This snippet demonstrates both error handling with Result and chaining of method calls.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/method-call-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet pi: Result<f32, _> = \"3.14\".parse();\nlet log_pi = pi.unwrap_or(1.0).log(2.72);\n# assert!(1.14 < log_pi && log_pi < 1.15)\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with If Let in Rust\nDESCRIPTION: Examples demonstrating if let expressions for pattern matching, showing both refutable and irrefutable patterns, and how the flow control works based on pattern matching results.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/if-expr.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet dish = (\"Ham\", \"Eggs\");\n\n// this body will be skipped because the pattern is refuted\nif let (\"Bacon\", b) = dish {\n    println!(\"Bacon is served with {}\", b);\n} else {\n    // This block is evaluated instead.\n    println!(\"No bacon will be served\");\n}\n\n// this body will execute\nif let (\"Ham\", b) = dish {\n    println!(\"Ham is served with {}\", b);\n}\n\nif let _ = 5 {\n    println!(\"Irrefutable patterns are always true\");\n}\n```\n\n----------------------------------------\n\nTITLE: Re-Exporting with Public Use Declarations in Rust\nDESCRIPTION: This example demonstrates how to use public 'use' declarations in Rust to re-export module contents. The 'quux' module re-exports 'bar' and 'baz' from the inner 'foo' module, allowing them to be publicly accessible. This feature facilitates modular code design by enabling the redirection of public names.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/use-declarations.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nmod quux {\n    pub use self::foo::{bar, baz};\n    pub mod foo {\n        pub fn bar() {}\n        pub fn baz() {}\n    }\n}\n\nfn main() {\n    quux::bar();\n    quux::baz();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lifetime-Based Subtyping in Rust\nDESCRIPTION: Demonstrates how subtyping based on lifetimes works in Rust, where a \\'static lifetime can be assigned to a shorter-lived lifetime parameter. No external dependencies are needed. It shows that a \\'static lifetime outlives any other, hence being a subtype of any other lifetime. Inputs involve string literals, with outputs depicting subtypes based on lifetime constraints.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/subtyping.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn bar<'a>() {\n    let s: &'static str = \"hi\";\n    let t: &'a str = s;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Grouped Patterns in Rust\nDESCRIPTION: Shows how to use parentheses to control precedence in compound patterns, specifically with reference and range patterns.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nlet int_reference = &3;\nmatch int_reference {\n    &(0..=5) => (),\n    _ => (),\n}\n```\n\n----------------------------------------\n\nTITLE: Enum Pattern Matching in Rust\nDESCRIPTION: Shows pattern matching with enum variants, demonstrating destructuring and different matching strategies including wildcards and field matching\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nmatch message {\n    Message::Quit => println!(\"Quit\"),\n    Message::WriteString(write) => println!(\"{}\", &write),\n    Message::Move{ x, y: 0 } => println!(\"move {} horizontally\", x),\n    Message::Move{ .. } => println!(\"other move\"),\n    Message::ChangeColor { 0: red, 1: green, 2: _ } => {\n        println!(\"color change, red: {}, green: {}\", red, green);\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Non-Capturing Closure Coercion to Function Pointer in Rust\nDESCRIPTION: Shows how non-capturing, non-async closures can be coerced to function pointers with matching signatures.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nlet add = |x, y| x + y;\n\nlet mut x = add(5,7);\n\ntype Binop = fn(i32, i32) -> i32;\nlet bo: Binop = add;\nx = bo(5,7);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Constant Usage in Rust\nDESCRIPTION: Example of defining and using constants in Rust, including bit flags, strings, and struct initialization with constant values.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/constant-items.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nconst BIT1: u32 = 1 << 0;\\nconst BIT2: u32 = 1 << 1;\\n\\nconst BITS: [u32; 2] = [BIT1, BIT2];\\nconst STRING: &'static str = \"bitstring\";\\n\\nstruct BitsNStrings<'a> {\\n    mybits: [u32; 2],\\n    mystring: &'a str,\\n}\\n\\nconst BITS_N_STRINGS: BitsNStrings<'static> = BitsNStrings {\\n    mybits: BITS,\\n    mystring: STRING,\\n};\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Macro Usage in Various Rust Contexts\nDESCRIPTION: Illustrates the use of macros in different contexts including expressions, statements, patterns, types, items, and associated items. Also shows nested macro calls.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Used as an expression.\nlet x = vec![1,2,3];\n\n// Used as a statement.\nprintln!(\"Hello!\");\n\n// Used in a pattern.\nmacro_rules! pat {\n    ($i:ident) => (Some($i))\n}\n\nif let pat!(x) = Some(1) {\n    assert_eq!(x, 1);\n}\n\n// Used in a type.\nmacro_rules! Tuple {\n    { $A:ty, $B:ty } => { ($A, $B) };\n}\n\ntype N2 = Tuple!(i32, i32);\n\n// Used as an item.\n# use std::cell::RefCell;\nthread_local!(static FOO: RefCell<u32> = RefCell::new(1));\n\n// Used as an associated item.\nmacro_rules! const_maker {\n    ($t:ty, $v:tt) => { const CONST: $t = $v; };\n}\ntrait T {\n    const_maker!{i32, 7}\n}\n\n// Macro calls within macros.\nmacro_rules! example {\n    () => { println!(\"Macro call in a macro!\") };\n}\n// Outer macro `example` is expanded, then inner macro `println` is expanded.\nexample!();\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Functional Update Syntax in Rust Struct Expressions\nDESCRIPTION: Shows how to use the functional update syntax (`..`) in struct expressions to create a new struct instance based on an existing one, while updating specific fields.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/struct-expr.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# struct Point3d { x: i32, y: i32, z: i32 }\nlet mut base = Point3d {x: 1, y: 2, z: 3};\nlet y_ref = &mut base.y;\nPoint3d {y: 0, z: 10, .. base}; // OK, only base.x is accessed\ndrop(y_ref);\n```\n\n----------------------------------------\n\nTITLE: Using Destructuring Assignment in Rust\nDESCRIPTION: Demonstrates the use of destructuring assignment to swap two mutable variables. This feature allows for assigning complex values like tuples or structs. There are no prerequisites other than understanding Rust's basic variable assignment and mutability concepts. The input example involves two integer variables being swapped using destructuring assignment.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_32\n\nLANGUAGE: rust\nCODE:\n```\nlet (mut a, mut b) = (0, 1);\n// Swap `a` and `b` using destructuring assignment.\n(b, a) = (a, b);\n```\n\n----------------------------------------\n\nTITLE: Matching Slice Patterns in Rust\nDESCRIPTION: Demonstrates how to use slice patterns to match arrays of fixed size and slices of dynamic size in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\n// Fixed size\nlet arr = [1, 2, 3];\nmatch arr {\n    [1, _, _] => \"starts with one\",\n    [a, b, c] => \"starts with something else\",\n};\n```\n\nLANGUAGE: rust\nCODE:\n```\n// Dynamic size\nlet v = vec![1, 2, 3];\nmatch v[..] {\n    [a, b] => { /* this arm will not apply because the length doesn't match */ }\n    [a, b, c] => { /* this arm will apply */ }\n    _ => { /* this wildcard is required, since the length is not known statically */ }\n};\n```\n\n----------------------------------------\n\nTITLE: Breaking from a Loop and Returning a Value in Rust\nDESCRIPTION: This code snippet demonstrates how to use a break expression to return a value from a loop in Rust. The loop calculates Fibonacci numbers until one exceeds 10, at which point it breaks and returns that value.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/loop-expr.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet (mut a, mut b) = (1, 1);\nlet result = loop {\n    if b > 10 {\n        break b;\n    }\n    let c = a + b;\n    a = b;\n    b = c;\n};\n// first number in Fibonacci sequence over 10:\nassert_eq!(result, 13);\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation with Attributes on Function Parameters in Rust\nDESCRIPTION: This example demonstrates how to use the cfg attribute on function parameters to conditionally compile different parameter types based on the target platform (Windows vs non-Windows). The function accepts different slice types depending on the platform while maintaining the same function signature.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/functions.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn len(\n    #[cfg(windows)] slice: &[u16],\n    #[cfg(not(windows))] slice: &[u8],\n) -> usize {\n    slice.len()\n}\n```\n\n----------------------------------------\n\nTITLE: Using Track Caller Attribute in Rust\nDESCRIPTION: This code demonstrates the usage of the `#[track_caller]` attribute to observe the caller's location in a Rust program. It provides a mechanism to trace function calls more effectively by printing the caller's stack location.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/codegen.md#2025-04-21_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n#[track_caller]\nfn f() {\n    println!(\"{}\", std::panic::Location::caller());\n}\n\n```\n\nLANGUAGE: Rust\nCODE:\n```\nfn calls_f() {\n    f(); // <-- f() prints this location\n}\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#[track_caller]\nfn g() {\n    println!(\"{}\", std::panic::Location::caller());\n    f();\n}\n\n```\n\nLANGUAGE: Rust\nCODE:\n```\nfn calls_g() {\n    g(); // <-- g() prints this location twice, once itself and once from f()\n}\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#[track_caller]\nfn h() {\n    println!(\"{}\", std::panic::Location::caller());\n    g();\n}\n\n```\n\nLANGUAGE: Rust\nCODE:\n```\nfn calls_h() {\n    h(); // <-- prints this location three times, once itself, once from g(), once from f()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Tuple Structs with Field Indices in Rust\nDESCRIPTION: Demonstrates how to create tuple structs using both the typical syntax and by specifying fields by index. It also shows how to use the functional update syntax with tuple structs.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/struct-expr.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstruct Color(u8, u8, u8);\nlet c1 = Color(0, 0, 0);  // Typical way of creating a tuple struct.\nlet c2 = Color{0: 255, 1: 127, 2: 0};  // Specifying fields by index.\nlet c3 = Color{1: 0, ..c2};  // Fill out all other fields using a base struct.\n```\n\n----------------------------------------\n\nTITLE: Using Comparison Operators in Rust\nDESCRIPTION: This snippet shows real-world examples of comparison operators in Rust code. Each example uses assertions to validate the outcome of the comparison operations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nassert!(123 == 123);\nassert!(23 != -12);\nassert!(12.5 > 12.2);\nassert!([1, 2, 3] < [1, 3, 4]);\nassert!('A' <= 'B');\nassert!(\"World\" >= \"Hello\");\n```\n\n----------------------------------------\n\nTITLE: Using Function Pointer Types in Rust\nDESCRIPTION: Example demonstrating how to define and use function pointer types in Rust. Shows defining a function, creating a function pointer type alias, and using a function pointer variable.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/function-pointer.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn add(x: i32, y: i32) -> i32 {\n    x + y\n}\n\nlet mut x = add(5,7);\n\ntype Binop = fn(i32, i32) -> i32;\nlet bo: Binop = add;\nx = bo(5,7);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tuple Indexing in Rust\nDESCRIPTION: Examples of tuple indexing expressions in Rust, including indexing a regular tuple and a tuple struct.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/tuple-expr.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Indexing a tuple\nlet pair = (\"a string\", 2);\nassert_eq!(pair.1, 2);\n\n// Indexing a tuple struct\n# struct Point(f32, f32);\nlet point = Point(1.0, 0.0);\nassert_eq!(point.0, 1.0);\nassert_eq!(point.1, 0.0);\n```\n\n----------------------------------------\n\nTITLE: Basic Rust Visibility Examples\nDESCRIPTION: Demonstrates basic visibility modifiers with struct and enum declarations, showing private and public items with their fields and variants.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/visibility-and-privacy.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# fn main() {}\n// Declare a private struct\nstruct Foo;\n\n// Declare a public struct with a private field\npub struct Bar {\n    field: i32,\n}\n\n// Declare a public enum with two public variants\npub enum State {\n    PubliclyAccessibleState,\n    PubliclyAccessibleState2,\n}\n```\n\n----------------------------------------\n\nTITLE: Using While Let Loop in Rust\nDESCRIPTION: This snippet shows two examples of while let loops in Rust. The first example pops elements from a vector and prints them, while the second demonstrates an irrefutable pattern.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/loop-expr.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet mut x = vec![1, 2, 3];\n\nwhile let Some(y) = x.pop() {\n    println!(\"y = {}\", y);\n}\n\nwhile let _ = 5 {\n    println!(\"Irrefutable patterns are always true\");\n    break;\n}\n```\n\n----------------------------------------\n\nTITLE: Signed Integer Types in Rust\nDESCRIPTION: Specification of signed two's complement integer types (i8, i16, i32, i64, i128) with their minimum and maximum values. Each type represents signed integers with different bit widths.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/numeric.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nType   | Minimum            | Maximum\n-------|--------------------|-------------------\n`i8`   | -(2<sup>7</sup>)   | 2<sup>7</sup>-1\n`i16`  | -(2<sup>15</sup>)  | 2<sup>15</sup>-1\n`i32`  | -(2<sup>31</sup>)  | 2<sup>31</sup>-1\n`i64`  | -(2<sup>63</sup>)  | 2<sup>63</sup>-1\n`i128` | -(2<sup>127</sup>) | 2<sup>127</sup>-1\n```\n\n----------------------------------------\n\nTITLE: Defining Async Functions with Unsafe Context in Rust\nDESCRIPTION: Demonstrates defining async functions, optionally combining them with `unsafe` to handle operations requiring explicit safety guarantees. Dependencies include Rust 2018 edition for async support. Parameters include pointers requiring safety checks, where unsafe blocks ensure proper dereferencing. The snippet illustrates behavior changes when futures are awaited.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/functions.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nasync unsafe fn unsafe_example(x: *const i32) -> i32 {\n  *x\n}\n\nasync fn safe_example() {\n    // An `unsafe` block is required to invoke the function initially:\n    let p = 22;\n    let future = unsafe { unsafe_example(&p) };\n\n    // But no `unsafe` block required here. This will\n    // read the value of `p`:\n    let q = future.await;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Mixing If and If Let Expressions in Rust\nDESCRIPTION: Example showing how if and if let expressions can be intermixed in the same conditional chain, demonstrating versatile pattern matching and condition checking.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/if-expr.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet x = Some(3);\nlet a = if let Some(1) = x {\n    1\n} else if x == Some(2) {\n    2\n} else if let Some(y) = x {\n    y\n} else {\n    -1\n};\nassert_eq!(a, 3);\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Tuple Struct in Rust\nDESCRIPTION: Example of defining a tuple struct 'Point' with two integer fields, creating an instance, and pattern matching to access a field.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/structs.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point(i32, i32);\nlet p = Point(10, 11);\nlet px: i32 = match p { Point(x, _) => x };\n```\n\n----------------------------------------\n\nTITLE: Defining Associated Types in Rust\nDESCRIPTION: Shows the syntax for defining associated types in implementations. Unlike declarations, definitions must specify the concrete type and cannot contain bounds directly.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\ntype Assoc = Type;\ntype Assoc<Params> = Type; // the type `Type` here may reference `Params`\ntype Assoc<Params> = Type where WhereBounds;\ntype Assoc<Params> where WhereBounds = Type; // deprecated, prefer the form above\n```\n\n----------------------------------------\n\nTITLE: If Let Desugaring to Match Expression in Rust\nDESCRIPTION: Demonstration of how if let expressions are equivalent to match expressions, showing the conceptual translation between the two syntax forms.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/if-expr.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nif let PATS = EXPR {\n    /* body */\n} else {\n    /*else */\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nmatch EXPR {\n    PATS => { /* body */ },\n    _ => { /* else */ },    // () if there is no else\n}\n```\n\n----------------------------------------\n\nTITLE: Main Function Examples\nDESCRIPTION: Shows various valid implementations of the main function, including different return types that implement the Termination trait.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/crates-and-source-files.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() -> ! {\n    std::process::exit(0);\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() -> impl std::process::Termination {\n    std::process::ExitCode::SUCCESS\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Break Expression in Rust\nDESCRIPTION: This code snippet shows how to use a break expression in a for loop to exit the loop when a condition is met. It also demonstrates using a label with break to exit from an outer loop.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/loop-expr.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet mut last = 0;\nfor x in 1..100 {\n    if x > 12 {\n        break;\n    }\n    last = x;\n}\nassert_eq!(last, 12);\n\n'outer: loop {\n    while true {\n        break 'outer;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing For Loop in Rust\nDESCRIPTION: This code snippet demonstrates two examples of for loops in Rust. The first iterates over an array of strings, while the second sums a range of integers.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/loop-expr.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet v = &[\"apples\", \"cake\", \"coffee\"];\n\nfor text in v {\n    println!(\"I like {}.\", text);\n}\n\nlet mut sum = 0;\nfor n in 1..11 {\n    sum += n;\n}\nassert_eq!(sum, 55);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Variable Initialization Rules in Rust\nDESCRIPTION: This example shows how Rust handles variable initialization in different control flow paths. It demonstrates that variables must be initialized in all possible execution paths to be considered properly initialized.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/variables.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# fn random_bool() -> bool { true }\nfn initialization_example() {\n    let init_after_if: ();\n    let uninit_after_if: ();\n\n    if random_bool() {\n        init_after_if = ();\n        uninit_after_if = ();\n    } else {\n        init_after_if = ();\n    }\n\n    init_after_if; // ok\n    // uninit_after_if; // err: use of possibly uninitialized `uninit_after_if`\n}\n```\n\n----------------------------------------\n\nTITLE: Higher-Ranked Trait Bound Scopes in Rust\nDESCRIPTION: These examples demonstrate the scoping rules for lifetime parameters declared as higher-ranked trait bounds in various Rust scenarios.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/names/scopes.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n# trait Trait<'a>{}\n\nfn where_clause<T>()\n    // 'a is in scope in both the type and the type bounds.\n    where for <'a> &'a T: Trait<'a>\n{}\n\nfn bound<T>()\n    // 'a is in scope within the bound.\n    where T: for <'a> Trait<'a>\n{}\n\n# struct Example<'a> {\n#     field: &'a u32\n# }\n\n// 'a is in scope in both the parameters and return type.\ntype FnExample = for<'a> fn(x: Example<'a>) -> Example<'a>;\n```\n\n----------------------------------------\n\nTITLE: Match Expression with Or Patterns in Rust\nDESCRIPTION: Shows how to use the | operator to combine multiple patterns in a match arm and demonstrates pattern matching order.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/match-expr.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 9;\nlet message = match x {\n    0 | 1  => \"not many\",\n    2 ..= 9 => \"a few\",\n    _      => \"lots\"\n};\n\nassert_eq!(message, \"a few\");\n\n// Demonstration of pattern match order.\nstruct S(i32, i32);\n\nmatch S(1, 2) {\n    S(z @ 1, _) | S(_, z @ 2) => assert_eq!(z, 1),\n    _ => panic!(),\n}\n```\n\n----------------------------------------\n\nTITLE: Integer Literal Expressions in Rust\nDESCRIPTION: Provides examples of integer literal syntax, type inference rules, and different numeric representations\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/literal-expr.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n123;                               // type i32\n123i32;                            // type i32\n123u32;                            // type u32\n123_u32;                           // type u32\nlet a: u64 = 123;                  // type u64\n\n0xff;                              // type i32\n0xff_u8;                           // type u8\n\n0o70;                              // type i32\n0o70_i16;                          // type i16\n\n0b1111_1111_1001_0000;             // type i32\n0b1111_1111_1001_0000i64;          // type i64\n\n0usize;                            // type usize\n```\n\n----------------------------------------\n\nTITLE: Reference Binding in Pattern Matching\nDESCRIPTION: Demonstrates how to use `ref` and `ref mut` to bind references in pattern matching, showing different binding strategies\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nmatch a {\n    None => (),\n    Some(value) => (),\n}\n\nmatch a {\n    None => (),\n    Some(ref value) => (),\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Associated Trait Items in Rust\nDESCRIPTION: Example of declaring associated trait items with and without default implementations, including constants, types, and methods.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/traits.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Examples of associated trait items with and without definitions.\ntrait Example {\n    const CONST_NO_DEFAULT: i32;\n    const CONST_WITH_DEFAULT: i32 = 99;\n    type TypeNoDefault;\n    fn method_without_default(&self);\n    fn method_with_default(&self) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Using Range Expressions in For Loops in Rust\nDESCRIPTION: Demonstrates how to use a range expression in a for loop in Rust to iterate over a sequence of numbers.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/range-expr.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfor i in 1..11 {\n    println!(\"{}\", i);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Range Expression Types in Rust\nDESCRIPTION: Shows examples of different range expression types in Rust, including std::ops::Range, RangeFrom, RangeTo, RangeFull, RangeInclusive, and RangeToInclusive.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/range-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n1..2;   // std::ops::Range\n3..;    // std::ops::RangeFrom\n..4;    // std::ops::RangeTo\n..;     // std::ops::RangeFull\n5..=6;  // std::ops::RangeInclusive\n..=7;   // std::ops::RangeToInclusive\n```\n\n----------------------------------------\n\nTITLE: Coercion Example in Function Return Type in Rust\nDESCRIPTION: This code snippet demonstrates type coercion in a function's return value. The `x` variable, of type `&u32`, is coerced to `&dyn Display` when returned from the `foo` function, because the function's return type is declared as `&dyn Display`.  The return value is coerced to the declared return type.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/type-coercions.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n  use std::fmt::Display;\n  fn foo(x: &u32) -> &dyn Display {\n      x\n  }\n  ```\n```\n\n----------------------------------------\n\nTITLE: Defining Method Call Expression Syntax in Rust\nDESCRIPTION: Grammar definition for method call expressions in Rust. It shows that a method call consists of an expression, followed by a dot, a path expression segment, and parentheses containing optional call parameters.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/method-call-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nMethodCallExpression -> Expression `.` PathExprSegment `(`CallParams? `)`\n```\n\n----------------------------------------\n\nTITLE: Using Constant Values in Inline Assembly - Rust\nDESCRIPTION: This snippet demonstrates how to pass a constant value into inline assembly. It specifically showcases the usage of a constant expression to provide an immediate for an assembly instruction.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(target_arch = \"x86_64\")] {\n// swizzle [0, 1, 2, 3] => [3, 2, 0, 1]\nconst SHUFFLE: u8 = 0b01_00_10_11;\nlet x: core::arch::x86_64::__m128 = unsafe { core::mem::transmute([0u32, 1u32, 2u32, 3u32]) };\nlet y: core::arch::x86_64::__m128;\n// Pass a constant value into an instruction that expects an immediate like `pshufd`\nsafe {\n    core::arch::asm!(\"pshufd {xmm}, {xmm}, {shuffle}\",\n        xmm = inlateout(xmm_reg) x=>y,\n        shuffle = const SHUFFLE\n    );\n}\nlet y: [u32; 4] = unsafe { core::mem::transmute(y) };\nassert_eq!(y, [3, 2, 0, 1]);\n# }\n```\n\n----------------------------------------\n\nTITLE: Basic Function Call Examples\nDESCRIPTION: Demonstrates basic function call syntax including a regular function call and an immediately invoked closure.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/call-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# fn add(x: i32, y: i32) -> i32 { 0 }\nlet three: i32 = add(1i32, 2i32);\nlet name: &'static str = (|| \"Rust\")();\n```\n\n----------------------------------------\n\nTITLE: Associated Constant with Default Value Example in Rust\nDESCRIPTION: This code demonstrates the use of default values for associated constants in Rust traits. It defines a trait `ConstantIdDefault` with a default value for the associated constant `ID`. It implements the trait for two structs, `Struct` (using the default value) and `OtherStruct` (overriding the default value). The `main` function asserts the values of `Struct::ID` and `OtherStruct::ID`.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n```rust\ntrait ConstantIdDefault {\n    const ID: i32 = 1;\n}\n\nstruct Struct;\nstruct OtherStruct;\n\nimpl ConstantIdDefault for Struct {}\n\nimpl ConstantIdDefault for OtherStruct {\n    const ID: i32 = 5;\n}\n\nfn main() {\n    assert_eq!(1, Struct::ID);\n    assert_eq!(5, OtherStruct::ID);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using Slice Types in Rust with Box and References\nDESCRIPTION: Example demonstrating how to use slices in Rust through common pointer types. Shows creating a boxed slice and borrowing a shared slice from it.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/slice.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// A heap-allocated array, coerced to a slice\nlet boxed_array: Box<[i32]> = Box::new([1, 2, 3]);\n\n// A (shared) slice into an array\nlet slice: &[i32] = &boxed_array[..];\n```\n\n----------------------------------------\n\nTITLE: Borrow Operator Example\nDESCRIPTION: Demonstrates usage of shared and mutable borrow operators in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n{\n    // a temporary with value 7 is created that lasts for this scope.\n    let shared_reference = &7;\n}\nlet mut array = [-2, 3, 9];\n{\n    // Mutably borrows `array` for this scope.\n    // `array` may only be used through `mutable_reference`.\n    let mutable_reference = &mut array;\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Temporary Lifetime Extension in Rust Static Items\nDESCRIPTION: This example demonstrates how temporary lifetime extension applies to static items in Rust. The Vec created in the initializer expression is extended to have a 'static lifetime, preventing a dangling reference.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/destructors.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nconst C: &Vec<i32> = &Vec::new();\n// Usually this would be a dangling reference as the `Vec` would only\n// exist inside the initializer expression of `C`, but instead the\n// borrow gets lifetime-extended so it effectively has `'static` lifetime.\nprintln!(\"{:?}\", C);\n```\n\n----------------------------------------\n\nTITLE: Turbofish Syntax Example in Rust\nDESCRIPTION: Illustrates the use of turbofish `::<>` syntax in paths for generic collections and method calls. This syntax is used to specify explicit generic type parameters.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/paths.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n(0..10).collect::<Vec<_>>();\nVec::<u8>::with_capacity(1024);\n```\n\n----------------------------------------\n\nTITLE: Using Inline Assembly with Register Aliases in Rust\nDESCRIPTION: This snippet demonstrates using inline assembly in Rust for the x86_64 architecture, leveraging register aliases. Here, `rax` is used as an alias for `eax` and `ax`. The code sets a 64-bit integer to zero and uses the `asm!` macro for manipulating registers. This requires Rust's nightly feature for inline assembly and the core library.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(target_arch = \"x86_64\")] {\nlet z = 0i64;\n// rax is an alias for eax and ax\nunsafe { core::arch::asm!(\"\", in(\"rax\") z); }\n# }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Inherent Implementations in Rust\nDESCRIPTION: Shows how to create inherent implementations for a Color struct, including associated constants and functions in different modules.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/implementations.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub mod color {\n    pub struct Color(pub u8, pub u8, pub u8);\n\n    impl Color {\n        pub const WHITE: Color = Color(255, 255, 255);\n    }\n}\n\nmod values {\n    use super::color::Color;\n    impl Color {\n        pub fn red() -> Color {\n            Color(255, 0, 0)\n        }\n    }\n}\n\npub use self::color::Color;\nfn main() {\n    // Actual path to the implementing type and impl in the same module.\n    color::Color::WHITE;\n\n    // Impl blocks in different modules are still accessed through a path to the type.\n    color::Color::red();\n\n    // Re-exported paths to the implementing type also work.\n    Color::red();\n\n    // Does not work, because use in `values` is not pub.\n    // values::Color::red();\n}\n```\n\n----------------------------------------\n\nTITLE: Literal Pattern Matching in Rust\nDESCRIPTION: Shows pattern matching with various literal types, including integers and signed numbers, demonstrating multiple match arms\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfor i in -2..5 {\n    match i {\n        -1 => println!(\"It's minus one\"),\n        1 => println!(\"It's a one\"),\n        2|4 => println!(\"It's either a two or a four\"),\n        _ => println!(\"Matched none of the arms\"),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Vector Clone Function in Rust\nDESCRIPTION: A recursive function that clones elements from a slice into a new vector. The function uses type parameter A with Clone trait bound to create a generic implementation that works with any cloneable type.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/parameters.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn to_vec<A: Clone>(xs: &[A]) -> Vec<A> {\n    if xs.is_empty() {\n        return vec![];\n    }\n    let first: A = xs[0].clone();\n    let mut rest: Vec<A> = to_vec(&xs[1..]);\n    rest.insert(0, first);\n    rest\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Loop Expression Grammar in Rust\nDESCRIPTION: This code snippet defines the grammar for different types of loop expressions in Rust, including infinite loops, predicate loops, predicate pattern loops, iterator loops, and labelled block expressions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/loop-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nLoopExpression ->\n    LoopLabel? (\n        InfiniteLoopExpression\n      | PredicateLoopExpression\n      | PredicatePatternLoopExpression\n      | IteratorLoopExpression\n      | LabelBlockExpression\n    )\n```\n\n----------------------------------------\n\nTITLE: Diagnostic On Unimplemented Trait in Rust\nDESCRIPTION: Illustrates using the diagnostic::on_unimplemented attribute to customize error messages for traits that aren't implemented. The snippet shows how to place and utilize this attribute in a trait declaration. A Rust environment is needed to see the formatted error messages when the trait requirements are not met.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/diagnostics.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n#[diagnostic::on_unimplemented(\n    message = \"My Message for `ImportantTrait<{A}>` implemented for `{Self}`\",\n    label = \"My Label\",\n    note = \"Note 1\",\n    note = \"Note 2\"\n)]\ntrait ImportantTrait<A> {}\n\nfn use_my_trait(_: impl ImportantTrait<i32>) {}\n\nfn main() {\n    use_my_trait(String::new());\n}\n```\n\n----------------------------------------\n\nTITLE: Return Expression Example in Function\nDESCRIPTION: Practical example demonstrating the use of return expressions in a function that returns the maximum of two integers. Shows early return pattern with conditional logic.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/return-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn max(a: i32, b: i32) -> i32 {\n    if a > b {\n        return a;\n    }\n    return b;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Modules and HashMaps in Rust\nDESCRIPTION: This Rust code demonstrates the use of 'use' declarations to import modules and create hash maps. It shows how to declare and utilize elements from the 'std::collections::hash_map' namespace and emphasizes that 'use' statements can occur inside functions to bring specific items into scope. Key functions like 'foo' and 'bar' make use of imported types.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/use-declarations.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::hash_map::{self, HashMap};\n\nfn foo<T>(_: T){}\nfn bar(map1: HashMap<String, usize>, map2: hash_map::HashMap<String, usize>){}\n\nfn main() {\n    // use declarations can also exist inside of functions\n    use std::option::Option::{Some, None};\n\n    // Equivalent to 'foo(vec![std::option::Option::Some(1.0f64),\n    // std::option::Option::None]);'\n    foo(vec![Some(1.0f64), None]);\n\n    // Both `hash_map` and `HashMap` are in scope.\n    let map1 = HashMap::new();\n    let map2 = hash_map::HashMap::new();\n    bar(map1, map2);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lint Level Attributes in Rust\nDESCRIPTION: This snippet shows how different lint level attributes (allow, warn, deny) affect the reporting of missing documentation in a Rust module.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/diagnostics.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub mod m1 {\n    // Missing documentation is ignored here\n    #[allow(missing_docs)]\n    pub fn undocumented_one() -> i32 { 1 }\n\n    // Missing documentation signals a warning here\n    #[warn(missing_docs)]\n    pub fn undocumented_too() -> i32 { 2 }\n\n    // Missing documentation signals an error here\n    #[deny(missing_docs)]\n    pub fn undocumented_end() -> i32 { 3 }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Lazy Boolean Operators in Rust\nDESCRIPTION: This snippet presents examples demonstrating the usage of lazy boolean operators in Rust. The examples highlight short-circuiting behavior when evaluating expressions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nlet x = false || true; // true\nlet y = false && panic!(); // false, doesn't evaluate `panic!()`\n```\n\n----------------------------------------\n\nTITLE: Defining Expression Statement Syntax in Rust Grammar\nDESCRIPTION: This grammar definition outlines the syntax for expression statements in Rust, highlighting how they may consist of an expression without or with a block and the requirement of a semicolon.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/statements.md#2025-04-21_snippet_4\n\nLANGUAGE: grammar\nCODE:\n```\nExpressionStatement ->\n      ExpressionWithoutBlock `;`\n    | ExpressionWithBlock `;`?\n```\n\n----------------------------------------\n\nTITLE: Question Mark Operator with Result Example\nDESCRIPTION: Shows how the question mark operator works with Result types.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n# use std::num::ParseIntError;\nfn try_to_parse() -> Result<i32, ParseIntError> {\n    let x: i32 = \"123\".parse()?; // x = 123\n    let y: i32 = \"24a\".parse()?; // returns an Err() immediately\n    Ok(x + y)                    // Doesn't run.\n}\n\nlet res = try_to_parse();\nprintln!(\"{:?}\", res);\n# assert!(res.is_err())\n```\n\n----------------------------------------\n\nTITLE: Defining Static Allocation in Rust\nDESCRIPTION: Explains the concept of static allocation for program items in Rust. Items are functions, modules, and types that are calculated at compile-time and stored uniquely in the memory image of the Rust process.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/memory-allocation-and-lifetime.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nr[alloc.static]\n```\n\n----------------------------------------\n\nTITLE: Assigning Explicit Discriminants to Enum Variants in Rust\nDESCRIPTION: Demonstrates how to assign explicit discriminant values to enum variants when using a primitive representation.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/enumerations.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(u8)]\nenum Enum {\n    Unit = 3,\n    Tuple(u16),\n    Struct {\n        a: u8,\n        b: u16,\n    } = 1,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Mutable Static Variables in Rust\nDESCRIPTION: Demonstrates the use of mutable static variables in Rust, including unsafe access and a safe alternative using atomic operations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/static-items.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# fn atomic_add(_: *mut u32, _: u32) -> u32 { 2 }\n\nstatic mut LEVELS: u32 = 0;\n\n// This violates the idea of no shared state, and this doesn't internally\n// protect against races, so this function is `unsafe`\nunsafe fn bump_levels_unsafe() -> u32 {\n    unsafe {\n        let ret = LEVELS;\n        LEVELS += 1;\n        return ret;\n    }\n}\n\n// As an alternative to `bump_levels_unsafe`, this function is safe, assuming\n// that we have an atomic_add function which returns the old value. This\n// function is safe only if no other code accesses the static in a non-atomic\n// fashion. If such accesses are possible (such as in `bump_levels_unsafe`),\n// then this would need to be `unsafe` to indicate to the caller that they\n// must still guard against concurrent access.\nfn bump_levels_safe() -> u32 {\n    unsafe {\n        return atomic_add(&raw mut LEVELS, 1);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Implementations in Rust\nDESCRIPTION: Shows how to create generic implementations for traits and structs, demonstrating different ways generic parameters can constrain an implementation.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/implementations.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nimpl<T> Seq<T> for Vec<T> {\n    /* ... */\n}\nimpl Seq<bool> for u32 {\n    /* Treat the integer as a sequence of bits */\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n// T constrains by being an argument to GenericTrait.\nimpl<T> GenericTrait<T> for i32 { /* ... */ }\n\n// T constrains by being an argument to GenericStruct\nimpl<T> Trait for GenericStruct<T> { /* ... */ }\n\n// Likewise, N constrains by being an argument to ConstGenericStruct\nimpl<const N: usize> Trait for ConstGenericStruct<N> { /* ... */ }\n\n// T constrains by being in an associated type in a bound for type `U` which is\n// itself a generic parameter constraining the trait.\nimpl<T, U> GenericTrait<U> for u32 where U: HasAssocType<Ty = T> { /* ... */ }\n\n// Like previous, except the type is `(U, isize)`. `U` appears inside the type\n// that includes `T`, and is not the type itself.\nimpl<T, U> GenericStruct<U> where (U, isize): HasAssocType<Ty = T> { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: Using a Function-Like Procedural Macro (Rust)\nDESCRIPTION: This snippet shows how to use a function-like procedural macro defined in another crate. The `make_answer!()` invocation is expanded at compile time by the procedural macro, which generates the `answer` function. This generated function is then called within `main`.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/procedural-macros.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nextern crate proc_macro_examples;\nuse proc_macro_examples::make_answer;\n\nmake_answer!();\n\nfn main() {\n    println!(\"{}\", answer());\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Panic Handler in Rust\nDESCRIPTION: This code snippet demonstrates how to define a custom panic handler in Rust that logs panic details and halts execution. The panic handler is set with the appropriate attribute and utilizes core components for logging the panic info. It requires `no_std` and `core::fmt`, and it's limited by the function signature `fn(&PanicInfo) -> !`.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/panic.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![no_std]\n\nuse core::fmt::{self, Write};\nuse core::panic::PanicInfo;\n\nstruct Sink {\n    // ..\n#    _0: (),\n}\n#\n# impl Sink {\n#     fn new() -> Sink { Sink { _0: () }}\n# }\n#\n# impl fmt::Write for Sink {\n#     fn write_str(&mut self, _: &str) -> fmt::Result { Ok(()) }\n# }\n\n#[panic_handler]\nfn panic(info: &PanicInfo) -> ! {\n    let mut sink = Sink::new();\n\n    // logs \"panicked at '$reason', src/main.rs:27:4\" to some `sink`\n    let _ = writeln!(sink, \"{}\", info);\n\n    loop {}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Unit-Only Enum with Explicit Discriminants in Rust\nDESCRIPTION: Demonstrates a unit-only enum where all variants are unit-like and have explicit discriminant values assigned.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/enumerations.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nenum Enum {\n    Foo = 3,\n    Bar = 2,\n    Baz = 1,\n}\n```\n\n----------------------------------------\n\nTITLE: Qualified Path Usage in Rust\nDESCRIPTION: Demonstrates fully qualified paths to disambiguate trait implementations in Rust. Shows how traits and inherent methods can be accessed using qualified paths.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/paths.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nstruct S;\nimpl S {\n    fn f() { println!(\"S\"); }\n}\ntrait T1 {\n    fn f() { println!(\"T1 f\"); }\n}\nimpl T1 for S {}\ntrait T2 {\n    fn f() { println!(\"T2 f\"); }\n}\nimpl T2 for S {}\nS::f();  // Calls the inherent impl.\n<S as T1>::f();  // Calls the T1 trait function.\n<S as T2>::f();  // Calls the T2 trait function.\n```\n\n----------------------------------------\n\nTITLE: Using OR Patterns with If Let in Rust\nDESCRIPTION: Example of using multiple patterns with the OR operator (|) in if let expressions, allowing multiple patterns to match and execute the same block of code.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/if-expr.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nenum E {\n    X(u8),\n    Y(u8),\n    Z(u8),\n}\nlet v = E::Y(12);\nif let E::X(n) | E::Y(n) = v {\n    assert_eq!(n, 12);\n}\n```\n\n----------------------------------------\n\nTITLE: Binding References Automatically in Pattern Matching\nDESCRIPTION: Demonstrates how reference values are automatically treated as ref bindings when matched by non-reference patterns, providing better ergonomics for handling references.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet x: &Option<i32> = &Some(3);\nif let Some(y) = x {\n    // y was converted to `ref y` and its type is &i32\n}\n```\n\n----------------------------------------\n\nTITLE: Implied Lifetime Bounds Example in Rust\nDESCRIPTION: This code illustrates implied lifetime bounds in Rust, where lifetime requirements are inferred based on the function signature. The `requires_t_outlives_a` function implies that `T: 'a` because the function takes a parameter of type `&'a T`.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/trait-bounds.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n\"fn requires_t_outlives_a<'a, T>(x: &'a T) {}\"\n```\n\nLANGUAGE: rust\nCODE:\n```\n\"fn requires_t_outlives_a_not_implied<'a, T: 'a>() {}\n\nfn requires_t_outlives_a<'a, T>(x: &'a T) {\n    // This compiles, because `T: 'a` is implied by\n    // the reference type `&'a T`.\n    requires_t_outlives_a_not_implied::<'a, T>();\n}\"\n```\n\nLANGUAGE: rust,compile_fail,E0309\nCODE:\n```\n\"# fn requires_t_outlives_a_not_implied<'a, T: 'a>() {}\nfn not_implied<'a, T>() {\n    // This errors, because `T: 'a` is not implied by\n    // the function signature.\n    requires_t_outlives_a_not_implied::<'a, T>();\n}\"\n```\n\n----------------------------------------\n\nTITLE: Function Call Disambiguation Example\nDESCRIPTION: Illustrates various ways to disambiguate function calls when multiple traits implement the same method name, showing fully qualified syntax patterns.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/call-expr.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait Pretty {\n    fn print(&self);\n}\n\ntrait Ugly {\n    fn print(&self);\n}\n\nstruct Foo;\nimpl Pretty for Foo {\n    fn print(&self) {}\n}\n\nstruct Bar;\nimpl Pretty for Bar {\n    fn print(&self) {}\n}\nimpl Ugly for Bar {\n    fn print(&self) {}\n}\n\nfn main() {\n    let f = Foo;\n    let b = Bar;\n\n    // we can do this because we only have one item called `print` for `Foo`s\n    f.print();\n    // more explicit, and, in the case of `Foo`, not necessary\n    Foo::print(&f);\n    // if you're not into the whole brevity thing\n    <Foo as Pretty>::print(&f);\n\n    // b.print(); // Error: multiple 'print' found\n    // Bar::print(&b); // Still an error: multiple `print` found\n\n    // necessary because of in-scope items defining `print`\n    <Bar as Pretty>::print(&b);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Type Casting in Rust\nDESCRIPTION: This snippet shows an example of using the `as` operator for type casting in Rust, effectively converting an integer length into a floating-point value for division.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\n# fn sum(values: &[f64]) -> f64 { 0.0 }\n# fn len(values: &[f64]) -> i32 { 0 }\nfn average(values: &[f64]) -> f64 {\n    let sum: f64 = sum(values);\n    let size: f64 = len(values) as f64;\n    sum / size\n}\n```\n\n----------------------------------------\n\nTITLE: Re-export Visibility Example\nDESCRIPTION: Shows how to re-export items and modify their visibility using pub use statements.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/visibility-and-privacy.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub use self::implementation::api;\n\nmod implementation {\n    pub mod api {\n        pub fn f() {}\n    }\n}\n\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Underscore Expressions in Rust Assignments\nDESCRIPTION: Illustrates various uses of underscore expressions in Rust, including tuple destructuring, struct destructuring, and ignoring function results. Also shows the difference between underscore expressions and wildcard patterns in let-bindings.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/underscore-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet p = (1, 2);\nlet mut a = 0;\n(_, a) = p;\n\nstruct Position {\n    x: u32,\n    y: u32,\n}\n\nPosition { x: a, y: _ } = Position{ x: 2, y: 3 };\n\n// unused result, assignment to `_` used to declare intent and remove a warning\n_ = 2 + 2;\n// triggers unused_must_use warning\n// 2 + 2;\n\n// equivalent technique using a wildcard pattern in a let-binding\nlet _ = 2 + 2;\n```\n\n----------------------------------------\n\nTITLE: Defining If Expression Syntax in Rust Grammar\nDESCRIPTION: Grammar specification for the if expression syntax in Rust, showing the basic structure with conditional expression followed by a block and optional else clauses.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/if-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nIfExpression ->\n    `if` Expression _except [StructExprStruct]_ BlockExpression\n    (`else` ( BlockExpression | IfExpression | IfLetExpression ) )?\n```\n\n----------------------------------------\n\nTITLE: Using Tags with Unions via FFI in Rust\nDESCRIPTION: This snippet demonstrates how to combine unions and enums to implement a tagged union in Rust. It uses a structure to hold a tag and a union, allowing safe pattern matching based on the tag.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/unions.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(u32)]\nenum Tag { I, F }\n\n#[repr(C)]\nunion U {\n    i: i32,\n    f: f32,\n}\n\n#[repr(C)]\nstruct Value {\n    tag: Tag,\n    u: U,\n}\n\nfn is_zero(v: Value) -> bool {\n    unsafe {\n        match v {\n            Value { tag: Tag::I, u: U { i: 0 } } => true,\n            Value { tag: Tag::F, u: U { f: num } } if num == 0.0 => true,\n            _ => false,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Block Expression Types in Rust\nDESCRIPTION: Shows examples of block expressions with different return types, including unit type and integer type.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/block-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# fn fn_call() {}\nlet _: () = {\n    fn_call();\n};\n\nlet five: i32 = {\n    fn_call();\n    5\n};\n\nassert_eq!(5, five);\n```\n\n----------------------------------------\n\nTITLE: Examples of Let Statements in Rust\nDESCRIPTION: This Rust code illustrates the usage of let statements, including mutable and immutable bindings, refutable patterns with else blocks, and irrefutable patterns. The behavior of the else block and the divergence of execution flow is also demonstrated.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/statements.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet (mut v, w) = (vec![1, 2, 3], 42); // The bindings may be mut or const\nlet Some(t) = v.pop() else { // Refutable patterns require an else block\n    panic!(); // The else block must diverge\n};\nlet [u, v] = [v[0], v[1]] else { // This pattern is irrefutable, so the compiler\n                                 // will lint as the else block is redundant.\n    panic!();\n};\n```\n\n----------------------------------------\n\nTITLE: Numeric Integer Casting in Rust\nDESCRIPTION: Demonstrates integer casting between same size types and truncation behavior when casting between different sizes. Shows how Rust handles 2's complement and sign extension.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nassert_eq!(42i8 as u8, 42u8);\nassert_eq!(-1i8 as u8, 255u8);\nassert_eq!(255u8 as i8, -1i8);\nassert_eq!(-1i16 as u16, 65535u16);\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Drop Behavior with PrintOnDrop Example\nDESCRIPTION: Demonstrates the Drop trait implementation and various drop scenarios including variable overwriting, tuples, moved values, uninitialized values, and partial moves. Shows the order and conditions under which destructors are called.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/destructors.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct PrintOnDrop(&'static str);\n\nimpl Drop for PrintOnDrop {\n    fn drop(&mut self) {\n        println!(\"{}\", self.0);\n    }\n}\n\nlet mut overwritten = PrintOnDrop(\"drops when overwritten\");\noverwritten = PrintOnDrop(\"drops when scope ends\");\n\nlet tuple = (PrintOnDrop(\"Tuple first\"), PrintOnDrop(\"Tuple second\"));\n\nlet moved;\n// No destructor run on assignment.\nmoved = PrintOnDrop(\"Drops when moved\");\n// Drops now, but is then uninitialized.\nmoved;\n\n// Uninitialized does not drop.\nlet uninitialized: PrintOnDrop;\n\n// After a partial move, only the remaining fields are dropped.\nlet mut partial_move = (PrintOnDrop(\"first\"), PrintOnDrop(\"forgotten\"));\n// Perform a partial move, leaving only `partial_move.0` initialized.\ncore::mem::forget(partial_move.1);\n// When partial_move's scope ends, only the first field is dropped.\n```\n\n----------------------------------------\n\nTITLE: Calling Extern Functions from Foreign Code in Rust\nDESCRIPTION: This example shows how to declare and use a function with the C ABI. The function `new_i32` is defined to return an integer initialized to zero.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/functions.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// Declares a function with the \"C\" ABI\nextern \"C\" fn new_i32() -> i32 { 0 }\n\n```\n\n----------------------------------------\n\nTITLE: Async Closure Usage Example in Rust\nDESCRIPTION: Demonstrates the usage of async closures with a callback function, showing how to create and await async closures.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/closure-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nasync fn takes_async_callback(f: impl AsyncFn(u64)) {\n    f(0).await;\n    f(1).await;\n}\n\nasync fn example() {\n    takes_async_callback(async |i| {\n        core::future::ready(i).await;\n        println!(\"done with {i}.\");\n    }).await;\n}\n```\n\n----------------------------------------\n\nTITLE: Higher-Ranked Trait Bounds Example in Rust\nDESCRIPTION: This example shows how higher-ranked trait bounds (HRTBs) can be used to specify that a bound is true for all lifetimes. The `call_on_ref_zero` function takes a function `F` that must be able to accept a reference to `i32` with any lifetime.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/trait-bounds.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n\"# struct T;\nimpl<'a> PartialEq<i32> for &'a T {\n    // ...\n#    fn eq(&self, other: &i32) -> bool {true}\n}\"\n```\n\nLANGUAGE: rust\nCODE:\n```\n\"fn call_on_ref_zero<F>(f: F) where for<'a> F: Fn(&'a i32) {\n    let zero = 0;\n    f(&zero);\n}\"\n```\n\nLANGUAGE: rust\nCODE:\n```\n\"fn call_on_ref_zero<F>(f: F) where F: for<'a> Fn(&'a i32) {\n    let zero = 0;\n    f(&zero);\n}\"\n```\n\n----------------------------------------\n\nTITLE: Capturing References in Move Closures in Rust\nDESCRIPTION: Example demonstrating how move closures capture references, stopping at the prefix before the first dereference and moving the reference itself into the closure.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nstruct T(String, String);\n\nlet mut t = T(String::from(\"foo\"), String::from(\"bar\"));\nlet t_mut_ref = &mut t;\nlet mut c = move || {\n    t_mut_ref.0.push_str(\"123\"); // captures `t_mut_ref` ByValue\n};\nc();\n```\n\n----------------------------------------\n\nTITLE: Coercion Example in Struct Instantiation in Rust\nDESCRIPTION: This code snippet demonstrates type coercion during struct instantiation. The `&mut 42` expression is coerced to `&i8` when initializing the `x` field of the `Foo` struct, as the field is defined to be of type `&i8`.  The value being assigned is coerced to the type of the struct field.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/type-coercions.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n  struct Foo<'a> { x: &'a i8 }\n\n  fn main() {\n      Foo { x: &mut 42 };\n  }\n  ```\n```\n\n----------------------------------------\n\nTITLE: Using the pure Option in Inline Assembly\nDESCRIPTION: Example of using the pure option to inform the compiler that assembly has no side effects, allowing it to be optimized. Must be combined with either nomem or readonly.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_30\n\nLANGUAGE: rust\nCODE:\n```\nlet x: i32 = 0;\nlet z: i32;\n// pure can be used to optimize by assuming the assembly has no side effects\nunsafe { core::arch::asm!(\"inc {}\", inout(reg) x => z, options(pure, nomem)); }\nassert_eq!(z, 1);\n```\n\n----------------------------------------\n\nTITLE: Initialization Requirement for Wildcard Patterns in Rust Closures\nDESCRIPTION: Example showing that even with wildcard patterns, the captured variables must be initialized before the closure is created.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nlet x: i32;\nlet c = || {\n    let _ = x; // ERROR: used binding `x` isn't initialized\n};\n```\n\n----------------------------------------\n\nTITLE: Desugaring Destructuring Assignments in Rust\nDESCRIPTION: Illustrates the desugaring process of destructuring assignments involving tuples, arrays, and structs. The code shows how assignments are translated into a pattern match followed by sequential assignments. The desugared patterns must be irrefutable. Knowledge of Rust struct and tuple syntax is required.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_33\n\nLANGUAGE: rust\nCODE:\n```\n# struct Struct { x: u32, y: u32 }\n# let (mut a, mut b) = (0, 0);\n(a, b) = (3, 4);\n\n[a, b] = [3, 4];\n\nStruct { x: a, y: b } = Struct { x: 3, y: 4};\n\n// desugars to:\n\n{\n    let (_a, _b) = (3, 4);\n    a = _a;\n    b = _b;\n}\n\n{\n    let [_a, _b] = [3, 4];\n    a = _a;\n    b = _b;\n}\n\n{\n    let Struct { x: _a, y: _b } = Struct { x: 3, y: 4};\n    a = _a;\n    b = _b;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuration Predicate Grammar Definition\nDESCRIPTION: Formal grammar specification for Rust's configuration predicates used in conditional compilation. Defines the syntax for options, all(), any(), not() predicates and literal values.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/conditional-compilation.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nConfigurationPredicate ->\n      ConfigurationOption\n    | ConfigurationAll\n    | ConfigurationAny\n    | ConfigurationNot\n    | `true`\n    | `false`\n\nConfigurationOption ->\n    IDENTIFIER ( `=` ( STRING_LITERAL | RAW_STRING_LITERAL ) )?\n\nConfigurationAll ->\n    `all` `(` ConfigurationPredicateList? `)`\n\nConfigurationAny ->\n    `any` `(` ConfigurationPredicateList? `)`\n\nConfigurationNot ->\n    `not` `(` ConfigurationPredicate `)`\n\nConfigurationPredicateList ->\n    ConfigurationPredicate (`,` ConfigurationPredicate)* `,`?\n```\n\n----------------------------------------\n\nTITLE: Loop Label Scoping in Rust\nDESCRIPTION: This example demonstrates the scoping rules for loop labels in Rust, showing how labels can be used to break out of nested loops and how they shadow outer labels.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/names/scopes.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n'a: for n in 0..3 {\n    if n % 2 == 0 {\n        break 'a;\n    }\n    fn inner() {\n        // Using 'a here would be an error.\n        // break 'a;\n    }\n}\n\n// The label is in scope for the expression of `while` loops.\n'a: while break 'a {}         // Loop does not run.\n'a: while let _ = break 'a {} // Loop does not run.\n\n// The label is not in scope in the defining `for` loop:\n'a: for outer in 0..5 {\n    // This will break the outer loop, skipping the inner loop and stopping\n    // the outer loop.\n    'a: for inner in { break 'a; 0..1 } {\n        println!(\"{}\", inner); // This does not run.\n    }\n    println!(\"{}\", outer); // This does not run, either.\n}\n\n```\n\n----------------------------------------\n\nTITLE: Instantiating Different Enum Variants in Rust\nDESCRIPTION: Shows various ways to instantiate enum variants, including unit-like, tuple-like, and struct-like variants.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/enumerations.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nenum Examples {\n    UnitLike,\n    TupleLike(i32),\n    StructLike { value: i32 },\n}\n\nuse Examples::*; // Creates aliases to all variants.\nlet x = UnitLike; // Path expression of the const item.\nlet x = UnitLike {}; // Struct expression.\nlet y = TupleLike(123); // Call expression.\nlet y = TupleLike { 0: 123 }; // Struct expression using integer field names.\nlet z = StructLike { value: 123 }; // Struct expression.\n```\n\n----------------------------------------\n\nTITLE: Complex Module Visibility Example\nDESCRIPTION: Comprehensive example showing module hierarchy, private helpers, public APIs, and testing patterns with visibility rules.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/visibility-and-privacy.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// This module is private, meaning that no external crate can access this\n// module. Because it is private at the root of this current crate, however, any\n// module in the crate may access any publicly visible item in this module.\nmod crate_helper_module {\n\n    // This function can be used by anything in the current crate\n    pub fn crate_helper() {}\n\n    // This function *cannot* be used by anything else in the crate. It is not\n    // publicly visible outside of the `crate_helper_module`, so only this\n    // current module and its descendants may access it.\n    fn implementation_detail() {}\n}\n\n// This function is \"public to the root\" meaning that it's available to external\n// crates linking against this one.\npub fn public_api() {}\n\n// Similarly to 'public_api', this module is public so external crates may look\n// inside of it.\npub mod submodule {\n    use crate::crate_helper_module;\n\n    pub fn my_method() {\n        // Any item in the local crate may invoke the helper module's public\n        // interface through a combination of the two rules above.\n        crate_helper_module::crate_helper();\n    }\n\n    // This function is hidden to any module which is not a descendant of\n    // `submodule`\n    fn my_implementation() {}\n\n    #[cfg(test)]\n    mod test {\n\n        #[test]\n        fn test_my_implementation() {\n            // Because this module is a descendant of `submodule`, it's allowed\n            // to access private items inside of `submodule` without a privacy\n            // violation.\n            super::my_implementation();\n        }\n    }\n}\n\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Defining an External ABI\nDESCRIPTION: The snippet demonstrates how to define an external block with a specific ABI (Application Binary Interface) to interface with external libraries, particularly using the C ABI standard. This is crucial for cross-language function calls.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/external-blocks.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(any(windows, target_arch = \"x86\"))]\n// Interface to the Windows API\nunsafe extern \"stdcall\" { }\n```\n\n----------------------------------------\n\nTITLE: Diverging Function Example with Never Type in Rust\nDESCRIPTION: Demonstrates a function that never returns by using the Never type (`!`) as its return type. The function calls panic!, which terminates execution without returning normally.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/never.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> ! {\n    panic!(\"This call never returns.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Simulated Closure Invocation in Rust\nDESCRIPTION: Demonstrates how a closure call would be translated if the closure's anonymous type were explicitly defined as a struct.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nf(Closure{ left_top: &mut rect.left_top, right_bottom_x: &mut rect.right_bottom.x });\n```\n\n----------------------------------------\n\nTITLE: Precedence Control with Parentheses in Rust\nDESCRIPTION: Demonstrates how parentheses affect operator precedence in arithmetic expressions. Shows the difference between parenthesized and non-parenthesized expressions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/grouped-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet x: i32 = 2 + 3 * 4; // not parenthesized\nlet y: i32 = (2 + 3) * 4; // parenthesized\nassert_eq!(x, 14);\nassert_eq!(y, 20);\n```\n\n----------------------------------------\n\nTITLE: Defining Implementation Grammar in Rust\nDESCRIPTION: Specifies the grammar for inherent and trait implementations in Rust, including generic parameters, associated items, and optional unsafe keyword for traits.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/implementations.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nImplementation -> InherentImpl | TraitImpl\n\nInherentImpl ->\n    `impl` GenericParams? Type WhereClause? `{`\n        InnerAttribute*\n        AssociatedItem*\n    `}`\n\nTraitImpl ->\n    `unsafe`? `impl` GenericParams? `!`? TypePath `for` Type\n    WhereClause?\n    `{`\n        InnerAttribute*\n        AssociatedItem*\n    `}`\n```\n\n----------------------------------------\n\nTITLE: Using a Derive Macro (Rust)\nDESCRIPTION: This snippet shows how to use a derive macro. The `#[derive(AnswerFn)]` attribute on the `Struct` triggers the execution of the `derive_answer_fn` macro, which then generates the `answer` function in the same scope. The `assert_eq!` verifies that the generated function returns the expected value.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/procedural-macros.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nextern crate proc_macro_examples;\nuse proc_macro_examples::AnswerFn;\n\n#[derive(AnswerFn)]\nstruct Struct;\n\nfn main() {\n    assert_eq!(42, answer());\n}\n\n```\n\n----------------------------------------\n\nTITLE: Function with Pattern Matching Parameters in Rust\nDESCRIPTION: This snippet illustrates how to define a function that uses pattern matching for its parameters. The function `first` takes a tuple as its argument, destructuring it to extract the first value.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/functions.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn first((value, _): (i32, i32)) -> i32 { value }\n```\n\n----------------------------------------\n\nTITLE: Byte String Literal Expressions in Rust\nDESCRIPTION: Describes the syntax and processing of byte string literals, including escape sequence handling and static array creation\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/literal-expr.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nb\"foo\"; br\"foo\";                     // foo\nb\"\\\"foo\\\"\"; br#\"\"foo\"\"#;             // \"foo\"\n\nb\"foo #\\\"# bar\";\nbr##\"foo #\"# bar\"##;                 // foo #\"# bar\n\nb\"\\x52\"; b\"R\"; br\"R\";                // R\nb\"\\\\x52\"; br\"\\x52\";                  // \\x52\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Inline Assembly with Directives in Rust x86_64\nDESCRIPTION: This code snippet demonstrates the use of inline assembly with directives in Rust on x86_64 architecture. It uses assembly directives to embed a string literal (\"Hello World!\") directly in the assembly code, then retrieves a pointer to this string and its length using LEA instruction.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_47\n\nLANGUAGE: rust\nCODE:\n```\nlet bytes: *const u8;\nlet len: usize;\nunsafe {\n    core::arch::asm!(\n        \"jmp 3f\", \"2: .ascii \\\"Hello World!\\\"\",\n        \"3: lea {bytes}, [2b+rip]\",\n        \"mov {len}, 12\",\n        bytes = out(reg) bytes,\n        len = out(reg) len\n    );\n}\n\nlet s = unsafe { core::str::from_utf8_unchecked(core::slice::from_raw_parts(bytes, len)) };\n\nassert_eq!(s, \"Hello World!\");\n```\n\n----------------------------------------\n\nTITLE: Matching Struct Patterns in Rust\nDESCRIPTION: Demonstrates various ways to match struct patterns in Rust, including field matching, binding, and wildcards.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nmatch struct_value {\n    Struct{a: 10, b: 'X', c: false} => (),\n    Struct{a: 10, b: 'X', ref c} => (),\n    Struct{a: 10, b: 'X', ref mut c} => (),\n    Struct{a: 10, b: 'X', c: _} => (),\n    Struct{a: _, b: _, c: _} => (),\n}\n```\n\n----------------------------------------\n\nTITLE: Markdown Table of Contents for Rust Reference Manual\nDESCRIPTION: A hierarchical markdown document structure outlining the complete Rust language reference documentation with organized sections and subsections for all language features.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/SUMMARY.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# The Rust Reference\n\n[Introduction](introduction.md)\n\n- [Notation](notation.md)\n\n- [Lexical structure](lexical-structure.md)\n    - [Input format](input-format.md)\n    - [Keywords](keywords.md)\n    - [Identifiers](identifiers.md)\n    - [Comments](comments.md)\n    - [Whitespace](whitespace.md)\n    - [Tokens](tokens.md)\n\n- [Macros](macros.md)\n    - [Macros By Example](macros-by-example.md)\n    - [Procedural Macros](procedural-macros.md)\n\n[...additional sections omitted for brevity...]\n```\n\n----------------------------------------\n\nTITLE: Defining Struct Expression Grammar in Rust\nDESCRIPTION: Specifies the grammar for struct expressions in Rust, including struct, tuple, and unit expressions, as well as field definitions and struct base syntax.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/struct-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nStructExpression ->\n      StructExprStruct\n    | StructExprTuple\n    | StructExprUnit\n\nStructExprStruct ->\n    PathInExpression `{` (StructExprFields | StructBase)? `}`\n\nStructExprFields ->\n    StructExprField (`,` StructExprField)* (`,` StructBase | `,`?)\n\nStructExprField ->\n    OuterAttribute*\n    (\n        IDENTIFIER\n      | (IDENTIFIER | TUPLE_INDEX) `:` Expression\n    )\n\nStructBase -> `..` Expression\n\nStructExprTuple ->\n    PathInExpression `(`\n      ( Expression (`,` Expression)* `,`? )?\n    `)`\n\nStructExprUnit -> PathInExpression\n```\n\n----------------------------------------\n\nTITLE: Scoped Visibility Examples\nDESCRIPTION: Demonstrates various scoped visibility modifiers including pub(in path), pub(crate), pub(super), and pub(self).\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/visibility-and-privacy.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub mod outer_mod {\n    pub mod inner_mod {\n        // This function is visible within `outer_mod`\n        pub(in crate::outer_mod) fn outer_mod_visible_fn() {}\n        // Same as above, this is only valid in the 2015 edition.\n        pub(in outer_mod) fn outer_mod_visible_fn_2015() {}\n\n        // This function is visible to the entire crate\n        pub(crate) fn crate_visible_fn() {}\n\n        // This function is visible within `outer_mod`\n        pub(super) fn super_mod_visible_fn() {\n            // This function is visible since we're in the same `mod`\n            inner_mod_visible_fn();\n        }\n\n        // This function is visible only within `inner_mod`,\n        // which is the same as leaving it private.\n        pub(self) fn inner_mod_visible_fn() {}\n    }\n    pub fn foo() {\n        inner_mod::outer_mod_visible_fn();\n        inner_mod::crate_visible_fn();\n        inner_mod::super_mod_visible_fn();\n\n        // This function is no longer visible since we're outside of `inner_mod`\n        // Error! `inner_mod_visible_fn` is private\n        //inner_mod::inner_mod_visible_fn();\n    }\n}\n\nfn bar() {\n    // This function is still visible since we're in the same crate\n    outer_mod::inner_mod::crate_visible_fn();\n\n    // This function is no longer visible since we're outside of `outer_mod`\n    // Error! `super_mod_visible_fn` is private\n    //outer_mod::inner_mod::super_mod_visible_fn();\n\n    // This function is no longer visible since we're outside of `outer_mod`\n    // Error! `outer_mod_visible_fn` is private\n    //outer_mod::inner_mod::outer_mod_visible_fn();\n\n    outer_mod::foo();\n}\n\nfn main() { bar() }\n```\n\n----------------------------------------\n\nTITLE: Defining a Derive Macro (Rust)\nDESCRIPTION: This snippet demonstrates how to define a derive macro. The `#[proc_macro_derive(AnswerFn)]` attribute marks the function as a derive macro that handles the `#[derive(AnswerFn)]` attribute. The function receives the token stream of the struct, enum, or union being derived, and must return a token stream of new items to be added to the module.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/procedural-macros.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# #![crate_type = \"proc-macro\"]\nextern crate proc_macro;\nuse proc_macro::TokenStream;\n\n#[proc_macro_derive(AnswerFn)]\npub fn derive_answer_fn(_item: TokenStream) -> TokenStream {\n    \"fn answer() -> u32 { 42 }\".parse().unwrap()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining External Module File Structure in Rust\nDESCRIPTION: This code snippet provides information on how module paths influence the physical organization of Rust source files. It shows the relationship between crate and filesystem structure, demonstrating how modules can be represented in directory formats.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/modules.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nModule Path               | Filesystem Path  | File Contents\n------------------------- | ---------------  | -------------\n`crate`                   | `lib.rs`         | `mod util;`\n`crate::util`             | `util.rs`        | `mod config;`\n`crate::util::config`     | `util/config.rs` |\n```\n\n----------------------------------------\n\nTITLE: Deriving PartialEq and Clone for a Struct in Rust\nDESCRIPTION: This example demonstrates how to use the derive attribute to automatically implement PartialEq and Clone traits for a struct named Foo with a generic type parameter T.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/derive.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(PartialEq, Clone)]\nstruct Foo<T> {\n    a: i32,\n    b: T,\n}\n```\n\n----------------------------------------\n\nTITLE: Match Expression with Guards in Rust\nDESCRIPTION: Illustrates the use of match guards to add additional conditions to pattern matching.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/match-expr.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# let maybe_digit = Some(0);\n# fn process_digit(i: i32) { }\n# fn process_other(i: i32) { }\nlet message = match maybe_digit {\n    Some(x) if x < 10 => process_digit(x),\n    Some(x) => process_other(x),\n    None => panic!(),\n};\n```\n\n----------------------------------------\n\nTITLE: Capturing Copy Values in Rust Closures\nDESCRIPTION: Example showing how Rust closures capture values that implement Copy trait using the ImmBorrow mode, even when they appear to be moved.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet x = [0; 1024];\nlet c = || {\n    let y = x; // x captured by ImmBorrow\n};\n```\n\n----------------------------------------\n\nTITLE: Operator Expression Grammar Definition\nDESCRIPTION: Defines the grammar syntax for all operator expressions in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nOperatorExpression ->\n      BorrowExpression\n    | DereferenceExpression\n    | ErrorPropagationExpression\n    | NegationExpression\n    | ArithmeticOrLogicalExpression\n    | ComparisonExpression\n    | LazyBooleanExpression\n    | TypeCastExpression\n    | AssignmentExpression\n    | CompoundAssignmentExpression\n```\n\n----------------------------------------\n\nTITLE: Applying Packed and Aligned Representation in Rust\nDESCRIPTION: This code snippet shows how to manipulate struct layout using the `packed` and `align` modifiers in Rust. The `PackedStruct` lowers alignment to 2 bytes using `repr(packed(2))`, while `AlignedStruct` raises alignment to 8 bytes using `repr(C, align(8))`. These attributes help control memory layout for efficiency or compatibility purposes. Both structs demonstrate how the alignment and padding of memory representation can be altered from the default settings.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/type-layout.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Default representation, alignment lowered to 2.\n#[repr(packed(2))]\nstruct PackedStruct {\n    first: i16,\n    second: i8,\n    third: i32\n}\n\n// C representation, alignment raised to 8\n#[repr(C, align(8))]\nstruct AlignedStruct {\n    first: i16,\n    second: i8,\n    third: i32\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Template Strings in Rust Inline Assembly\nDESCRIPTION: Shows how multiple template strings can be used in a single asm! invocation, effectively treating them as separate lines of assembly code.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nlet x: i64;\nlet y: i64;\n// We can separate multiple strings as if they were written together\nunsafe { core::arch::asm!(\"mov eax, 5\", \"mov ecx, eax\", out(\"rax\") x, out(\"rcx\") y); }\nassert_eq!(x, y);\n```\n\n----------------------------------------\n\nTITLE: Early Exit Impact on Operand Drop Order\nDESCRIPTION: Shows how operands to expressions are dropped when evaluation is interrupted (like with a break statement). Operands are stored in temporaries and dropped in reverse order when the expression doesn't complete evaluation.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/destructors.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# struct PrintOnDrop(&'static str);\n# impl Drop for PrintOnDrop {\n#     fn drop(&mut self) {\n#         println!(\"drop({})\", self.0);\n#     }\n# }\nloop {\n    // Tuple expression doesn't finish evaluating so operands drop in reverse order\n    (\n        PrintOnDrop(\"Outer tuple first\"),\n        PrintOnDrop(\"Outer tuple second\"),\n        (\n            PrintOnDrop(\"Inner tuple first\"),\n            PrintOnDrop(\"Inner tuple second\"),\n            break,\n        ),\n        PrintOnDrop(\"Never created\"),\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Pattern Grammar and Examples\nDESCRIPTION: Grammar rules and examples for matching struct patterns in Rust, including field matching and destructuring.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_16\n\nLANGUAGE: grammar\nCODE:\n```\nStructPattern ->\n    PathInExpression `{`\n        StructPatternElements ?\n    `}`\n\nStructPatternElements ->\n      StructPatternFields (`,` | `,` StructPatternEtCetera)?\n    | StructPatternEtCetera\n\nStructPatternFields ->\n    StructPatternField (`,` StructPatternField)*\n\nStructPatternField ->\n    OuterAttribute*\n    (\n        TUPLE_INDEX `:` Pattern\n      | IDENTIFIER `:` Pattern\n      | `ref`? `mut`? IDENTIFIER\n    )\n\nStructPatternEtCetera -> `..`\n```\n\nLANGUAGE: rust\nCODE:\n```\nmatch s {\n    Point {x: 10, y: 20} => (),\n    Point {y: 10, x: 20} => (),    // order doesn't matter\n    Point {x: 10, ..} => (),\n    Point {..} => (),\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Invalid Values for Boolean Type in Rust\nDESCRIPTION: Specifies that a boolean value in Rust must be either false (0) or true (1). Any other value is considered invalid and results in undefined behavior.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/behavior-considered-undefined.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n* A [`bool`] value must be `false` (`0`) or `true` (`1`).\n```\n\n----------------------------------------\n\nTITLE: Generic Associated Types with Where Clauses in Rust\nDESCRIPTION: Showcases generic associated types (GATs) with lifetime parameters and where clauses. Demonstrates implementation of a Lend trait that uses a generic associated type to provide a reference-borrowing pattern.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nstruct ArrayLender<'a, T>(&'a mut [T; 16]);\n\ntrait Lend {\n    // Generic associated type declaration\n    type Lender<'a> where Self: 'a;\n    fn lend<'a>(&'a mut self) -> Self::Lender<'a>;\n}\n\nimpl<T> Lend for [T; 16] {\n    // Generic associated type definition\n    type Lender<'a> = ArrayLender<'a, T> where Self: 'a;\n\n    fn lend<'a>(&'a mut self) -> Self::Lender<'a> {\n        ArrayLender(self)\n    }\n}\n\nfn borrow<'a, T: Lend>(array: &'a mut T) -> <T as Lend>::Lender<'a> {\n    array.lend()\n}\n\nfn main() {\n    let mut array = [0usize; 16];\n    let lender = borrow(&mut array);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Self in Paths Example in Rust\nDESCRIPTION: Demonstrates using `self` and `Self` in paths to resolve functions and methods in Rust. `self` resolves to the current module while `Self` is used in trait and implementation contexts.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/paths.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {}\nfn bar() {\n    self::foo();\n}\nstruct S(bool);\nimpl S {\n  fn baz(self) {\n        self.0;\n    }\n}\n# fn main() {}\n```\n\nLANGUAGE: rust\nCODE:\n```\ntrait T {\n    type Item;\n    const C: i32;\n    // `Self` will be whatever type that implements `T`.\n    fn new() -> Self;\n    // `Self::Item` will be the type alias in the implementation.\n    fn f(&self) -> Self::Item;\n}\nstruct S;\nimpl T for S {\n    type Item = i32;\n    const C: i32 = 9;\n    fn new() -> Self {           // `Self` is the type `S`.\n        S\n    }\n    fn f(&self) -> Self::Item {  // `Self::Item` is the type `i32`.\n        Self::C                  // `Self::C` is the constant value `9`.\n    }\n}\n\n// `Self` is in scope within the generics of a trait definition,\n// to refer to the type being defined.\ntrait Add<Rhs = Self> {\n    type Output;\n    // `Self` can also reference associated items of the\n    // type being implemented.\n    fn add(self, rhs: Rhs) -> Self::Output;\n}\n\nstruct NonEmptyList<T> {\n    head: T,\n    // A struct can reference itself (as long as it is not\n    // infinitely recursive).\n    tail: Option<Box<Self>>,\n}\n```\n\n----------------------------------------\n\nTITLE: Range Pattern Examples in Rust\nDESCRIPTION: Examples demonstrating the usage of range patterns in Rust including character ranges, numeric ranges, and constant path ranges.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nlet valid_variable = match c {\n    'a'..='z' => true,\n    'A'..='Z' => true,\n    'α'..='ω' => true,\n    _ => false,\n};\n\nprintln!(\"{}\", match ph {\n    0..7 => \"acid\",\n    7 => \"neutral\",\n    8..=14 => \"base\",\n    _ => unreachable!(),\n});\n\nmatch uint {\n    0 => \"zero!\",\n    1.. => \"positive number!\",\n};\n```\n\n----------------------------------------\n\nTITLE: Using Generics vs. `impl Trait` - Rust\nDESCRIPTION: Compares the usage of a generic type parameter with `impl Trait` as an argument in function definitions. It highlights that both can specify types that implement a trait while `impl Trait` makes the type anonymous.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/impl-trait.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {}\n\n// generic type parameter\nfn with_generic_type<T: Trait>(arg: T) {\n}\n\n// impl Trait in argument position\nfn with_impl_trait(arg: impl Trait) {\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Unaligned Fields in Packed Structs in Rust\nDESCRIPTION: Demonstrates safe ways to work with unaligned fields in packed structs, including copying values, using braces for temporary copies, and using unaligned read/write methods.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/type-layout.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(packed)]\nstruct Packed {\n    f1: u8,\n    f2: u16,\n}\nlet mut e = Packed { f1: 1, f2: 2 };\n// Instead of creating a reference to a field, copy the value to a local variable.\nlet x = e.f2;\n// Or in situations like `println!` which creates a reference, use braces\n// to change it to a copy of the value.\nprintln!(\"{}\", {e.f2});\n// Or if you need a pointer, use the unaligned methods for reading and writing\n// instead of dereferencing the pointer directly.\nlet ptr: *const u16 = &raw const e.f2;\nlet value = unsafe { ptr.read_unaligned() };\nlet mut_ptr: *mut u16 = &raw mut e.f2;\nunsafe { mut_ptr.write_unaligned(3) }\n```\n\n----------------------------------------\n\nTITLE: Using Loop Labels in Rust\nDESCRIPTION: This code demonstrates the use of loop labels in Rust. It shows how labels can be used to break out of nested loops and how they follow hygiene and shadowing rules.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/loop-expr.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n'a: loop {\n    'a: loop {\n        break 'a;\n    }\n    print!(\"outer loop\");\n    break 'a;\n}\n```\n\n----------------------------------------\n\nTITLE: Field Borrowing Examples\nDESCRIPTION: Demonstration of borrowing rules for struct fields, showing how different fields can be borrowed independently and moved out of.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/field-expr.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstruct A { f1: String, f2: String, f3: String }\nlet mut x: A;\n# x = A {\n#     f1: \"f1\".to_string(),\n#     f2: \"f2\".to_string(),\n#     f3: \"f3\".to_string()\n# };\nlet a: &mut String = &mut x.f1; // x.f1 borrowed mutably\nlet b: &String = &x.f2;         // x.f2 borrowed immutably\nlet c: &String = &x.f2;         // Can borrow again\nlet d: String = x.f3;           // Move out of x.f3\n```\n\n----------------------------------------\n\nTITLE: Defining a Stack-Allocated Array in Rust\nDESCRIPTION: This snippet demonstrates the declaration and initialization of a stack-allocated array of integers with a fixed size. The syntax follows the Rust language format for defining an array type.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/array.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// A stack-allocated array\nlet array: [i32; 3] = [1, 2, 3];\n```\n\n----------------------------------------\n\nTITLE: Function Pointer Type Grammar Definition in Rust\nDESCRIPTION: Formal grammar specification for function pointer types in Rust, including syntax for type qualifiers, parameters, return types, and variadic functions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/function-pointer.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nBareFunctionType ->\n    ForLifetimes? FunctionTypeQualifiers `fn`\n       `(` FunctionParametersMaybeNamedVariadic? `)` BareFunctionReturnType?\n\nFunctionTypeQualifiers -> `unsafe`? (`extern` Abi?)?\n\nBareFunctionReturnType -> `->` TypeNoBounds\n\nFunctionParametersMaybeNamedVariadic ->\n    MaybeNamedFunctionParameters | MaybeNamedFunctionParametersVariadic\n\nMaybeNamedFunctionParameters ->\n    MaybeNamedParam ( `,` MaybeNamedParam )* `,`?\n\nMaybeNamedParam ->\n    OuterAttribute* ( ( IDENTIFIER | `_` ) `:` )? Type\n\nMaybeNamedFunctionParametersVariadic ->\n    ( MaybeNamedParam `,` )* MaybeNamedParam `,` OuterAttribute* `...`\n```\n\n----------------------------------------\n\nTITLE: Reference Pattern in Struct Matching\nDESCRIPTION: Shows how to correctly use `ref` when matching struct fields to bind references\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nif let Person { name: ref person_name, age: 18..=150 } = value { }\n```\n\n----------------------------------------\n\nTITLE: Returning Abstract Types with `impl Trait` - Rust\nDESCRIPTION: Illustrates how to use `impl Trait` in function return types, which allows for returning abstract types while still promising that they implement a specific trait. It describes the benefits over using boxed trait objects.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/impl-trait.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn returns_closure() -> impl Fn(i32) -> i32 {\n    |x| x + 1\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Heap-Allocated Array in Rust\nDESCRIPTION: This snippet illustrates how to create a heap-allocated array using the Box type in Rust. The Box type allows for dynamic memory allocation and is coerced into a slice for usage.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/array.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// A heap-allocated array, coerced to a slice\nlet boxed_array: Box<[i32]> = Box::new([1, 2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Unit-like Struct in Rust\nDESCRIPTION: Example of defining a unit-like struct 'Cookie' without fields and creating instances of it in an array.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/structs.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstruct Cookie;\nlet c = [Cookie, Cookie {}, Cookie, Cookie {}];\n```\n\n----------------------------------------\n\nTITLE: Defining If Let Expression Syntax in Rust Grammar\nDESCRIPTION: Grammar specification for the if let expression syntax in Rust, showing the pattern matching structure with a pattern, assignment operator, scrutinee expression, and optional else clauses.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/if-expr.md#2025-04-21_snippet_2\n\nLANGUAGE: grammar\nCODE:\n```\nIfLetExpression ->\n    `if` `let` Pattern `=` Scrutinee _except [LazyBooleanExpression]_ BlockExpression\n    (`else` ( BlockExpression | IfExpression | IfLetExpression ) )?\n```\n\n----------------------------------------\n\nTITLE: Swapping Bytes with xchg in Rust Assembly (x86_64)\nDESCRIPTION: Demonstrates the use of the `xchg` instruction within Rust inline assembly to swap bytes in a 16-bit unsigned integer. It highlights the use of template modifiers to access sub-registers effectively. The example shows how to use the `inout` operand to swap the lower and higher bytes of a register, ensuring the value transformation.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(target_arch = \"x86_64\")] {\nlet mut x = 0x10u16;\n\n// u16::swap_bytes using `xchg`\n// low half of `{x}` is referred to by `{x:l}`, and the high half by `{x:h}`\nunsafe { core::arch::asm!(\"xchg {x:l}, {x:h}\", x = inout(reg_abcd) x); }\nassert_eq!(x, 0x1000u16);\n# }\n```\n\n----------------------------------------\n\nTITLE: Illustrating Method Lookup Behavior in Rust\nDESCRIPTION: This code demonstrates a surprising result in method lookup due to the order in which receiver types are considered. It shows how a trait method can be called instead of a struct method due to the lookup order.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/method-call-expr.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {}\n\ntrait Bar {\n  fn bar(&self);\n}\n\nimpl Foo {\n  fn bar(&mut self) {\n    println!(\"In struct impl!\")\n  }\n}\n\nimpl Bar for Foo {\n  fn bar(&self) {\n    println!(\"In trait impl!\")\n  }\n}\n\nfn main() {\n  let mut f = Foo{};\n  f.bar();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Tuple Type Syntax in Rust\nDESCRIPTION: Grammar specification for tuple types in Rust. Defines the syntax for empty tuples and tuples with one or more elements, where multiple elements are separated by commas.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/tuple.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nTupleType ->\n      `(` `)` \n    | `(` ( Type `,` )+ Type? `)`\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Namespace Usage in Rust\nDESCRIPTION: This code snippet illustrates how overlapping names in different namespaces can be used unambiguously in Rust. It demonstrates the use of the type, value, macro, lifetime, and label namespaces.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/names/namespaces.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Foo introduces a type in the type namespace and a constructor in the value\n// namespace.\nstruct Foo(u32);\n\n// The `Foo` macro is declared in the macro namespace.\nmacro_rules! Foo {\n    () => {};\n}\n\n// `Foo` in the `f` parameter type refers to `Foo` in the type namespace.\n// `'Foo` introduces a new lifetime in the lifetime namespace.\nfn example<'Foo>(f: Foo) {\n    // `Foo` refers to the `Foo` constructor in the value namespace.\n    let ctor = Foo;\n    // `Foo` refers to the `Foo` macro in the macro namespace.\n    Foo!{}\n    // `'Foo` introduces a label in the label namespace.\n    'Foo: loop {\n        // `'Foo` refers to the `'Foo` lifetime parameter, and `Foo`\n        // refers to the type namespace.\n        let x: &'Foo Foo;\n        // `'Foo` refers to the label.\n        break 'Foo;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: LUB Coercion Examples in Rust\nDESCRIPTION: This code snippet showcases examples of Least Upper Bound (LUB) coercion in Rust, used to find a common type for different branches or elements. The examples include LUB coercion for `if` branches, `match` arms, array elements, closure return statements, and function return statements, all involving types `a`, `b`, and `c` which are all i32.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/type-coercions.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n# let (a, b, c) = (0, 1, 2);\n// For if branches\nlet bar = if true {\n    a\n} else if false {\n    b\n} else {\n    c\n};\n\n// For match arms\nlet baw = match 42 {\n    0 => a,\n    1 => b,\n    _ => c,\n};\n\n// For array elements\nlet bax = [a, b, c];\n\n// For closure with multiple return statements\nlet clo = || {\n    if true {\n        a\n    } else if false {\n        b\n    } else {\n        c\n    }\n};\nlet baz = clo();\n\n// For type checking of function with multiple return statements\nfn foo() -> i32 {\n    let (a, b, c) = (0, 1, 2);\n    match 42 {\n        0 => a,\n        1 => b,\n        _ => c,\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Comparison Operators in Rust\nDESCRIPTION: This snippet describes the syntax of various comparison operators in Rust, including equality checks and relational operators. It highlights the requirements for parentheses when chaining comparison expressions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_15\n\nLANGUAGE: grammar,expressions\nCODE:\n```\nComparisonExpression ->\n      Expression `==` Expression\n    | Expression `!=` Expression\n    | Expression `>` Expression\n    | Expression `<` Expression\n    | Expression `>=` Expression\n    | Expression `<=` Expression\n```\n\n----------------------------------------\n\nTITLE: Associated Type with Bounds and Where Clauses in Rust\nDESCRIPTION: Demonstrates the relationship between bounds directly on an associated type and where clauses on its parameters. The Output type must implement Ord while its type parameter T must implement Debug.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n# use std::fmt::Debug;\ntrait Example {\n    type Output<T>: Ord where T: Debug;\n}\n```\n\n----------------------------------------\n\nTITLE: Destructuring Struct in Rust\nDESCRIPTION: Shows how to destructure all fields of a struct into separate variables using pattern matching.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nlet Struct{a: x, b: y, c: z} = struct_value;          // destructure all fields\n```\n\n----------------------------------------\n\nTITLE: Return Expression Grammar Definition\nDESCRIPTION: Formal grammar syntax definition for return expressions in Rust, showing optional Expression component.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/return-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nReturnExpression -> `return` Expression?\n```\n\n----------------------------------------\n\nTITLE: Implementing Dyn-Compatible Methods in Rust\nDESCRIPTION: Examples of methods that are compatible with trait objects (dyn), demonstrating various receiver types and lifetime parameters.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/traits.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# use std::rc::Rc;\n# use std::sync::Arc;\n# use std::pin::Pin;\n// Examples of dyn compatible methods.\ntrait TraitMethods {\n    fn by_ref(self: &Self) {}\n    fn by_ref_mut(self: &mut Self) {}\n    fn by_box(self: Box<Self>) {}\n    fn by_rc(self: Rc<Self>) {}\n    fn by_arc(self: Arc<Self>) {}\n    fn by_pin(self: Pin<&Self>) {}\n    fn with_lifetime<'a>(self: &'a Self) {}\n    fn nested_pin(self: Pin<Arc<Self>>) {}\n}\n# struct S;\n# impl TraitMethods for S {}\n# let t: Box<dyn TraitMethods> = Box::new(S);\n```\n\n----------------------------------------\n\nTITLE: Qualified Path Syntax Definition\nDESCRIPTION: Defines grammar for fully qualified paths in expressions and type specifications. Qualified paths allow for disambiguation of trait implementations and use of canonical paths.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/paths.md#2025-04-21_snippet_4\n\nLANGUAGE: grammar\nCODE:\n```\nQualifiedPathInExpression -> QualifiedPathType (`::` PathExprSegment)+\n\nQualifiedPathType -> `<` Type (`as` TypePath)? `>`\n\nQualifiedPathInType -> QualifiedPathType (`::` TypePathSegment)+\n```\n\n----------------------------------------\n\nTITLE: Pointer Address Arithmetic in Rust\nDESCRIPTION: Demonstrates safe pointer address arithmetic using casting between pointers and integers.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_31\n\nLANGUAGE: rust\nCODE:\n```\nlet mut values: [i32; 2] = [1, 2];\nlet p1: *mut i32 = values.as_mut_ptr();\nlet first_address = p1 as usize;\nlet second_address = first_address + 4; // 4 == size_of::<i32>()\nlet p2 = second_address as *mut i32;\nunsafe {\n    *p2 += 1;\n}\nassert_eq!(values[1], 3);\n```\n\n----------------------------------------\n\nTITLE: Simple Path Example in Rust\nDESCRIPTION: Shows an example of a simple path usage in a Rust module declaration and use statement. Demonstrates the use of module paths and visibility annotations within a nested module.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/paths.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io::{self, Write};\nmod m {\n    #[clippy::cyclomatic_complexity = \"0\"]\n    pub (in super) fn f1() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Capturing Packed Struct Address in Rust Closures\nDESCRIPTION: Shows how taking the address of an unaligned field in a packed struct captures the entire struct, causing borrowing conflicts.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(packed)]\nstruct T(String, String);\n\nlet mut t = T(String::new(), String::new());\nlet c = || {\n    let a = std::ptr::addr_of!(t.1); // captures `t` with ImmBorrow\n};\nlet a = t.0; // ERROR: cannot move out of `t.0` because it is borrowed\nc();\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Range Expression Equivalence in Rust\nDESCRIPTION: Illustrates the equivalence between a manually constructed std::ops::Range and a range expression in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/range-expr.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet x = std::ops::Range {start: 0, end: 10};\nlet y = 0..10;\n\nassert_eq!(x, y);\n```\n\n----------------------------------------\n\nTITLE: Rest Pattern Examples in Slices and Tuples\nDESCRIPTION: Demonstrates the use of the rest pattern (..) in slice and tuple patterns to match variable-length elements, with examples of binding the matched elements.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n# let words = vec![\"a\", \"b\", \"c\"];\n# let slice = &words[..];\nmatch slice {\n    [] => println!(\"slice is empty\"),\n    [one] => println!(\"single element {}\", one),\n    [head, tail @ ..] => println!(\"head={} tail={:?}\", head, tail),\n}\n\nmatch slice {\n    // Ignore everything but the last element, which must be \"!\".\n    [.., \"!\"] => println!(\"!!!\"),\n\n    // `start` is a slice of everything except the last element, which must be \"z\".\n    [start @ .., \"z\"] => println!(\"starts with: {:?}\", start),\n\n    // `end` is a slice of everything but the first element, which must be \"a\".\n    [\"a\", end @ ..] => println!(\"ends with: {:?}\", end),\n\n    // 'whole' is the entire slice and `last` is the final element\n    whole @ [.., last] => println!(\"the last element of {:?} is {}\", whole, last),\n\n    rest => println!(\"{:?}\", rest),\n}\n\nif let [.., penultimate, _] = slice {\n    println!(\"next to last is {}\", penultimate);\n}\n\n# let tuple = (1, 2, 3, 4, 5);\n// Rest patterns may also be used in tuple and tuple struct patterns.\nmatch tuple {\n    (1, .., y, z) => println!(\"y={} z={}\", y, z),\n    (.., 5) => println!(\"tail must be 5\"),\n    (..) => println!(\"matches everything else\"),\n}\n```\n\n----------------------------------------\n\nTITLE: Capturing Nested Fields in Rust Closures\nDESCRIPTION: Example demonstrating how a Rust closure captures a nested field of a struct with precise path capture.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nstruct SomeStruct {\n    f1: (i32, i32),\n}\nlet s = SomeStruct { f1: (1, 2) };\n\nlet c = || {\n    let x = s.f1.1; // s.f1.1 captured by ImmBorrow\n};\nc();\n```\n\n----------------------------------------\n\nTITLE: Defining Invalid Values for References and Box<T> in Rust\nDESCRIPTION: Specifies that references and Box<T> in Rust must be aligned, non-null, non-dangling, and point to valid values. It notes ongoing debate about pointing to valid values for dynamically sized types.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/behavior-considered-undefined.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n* A reference or [`Box<T>`] must be aligned and non-null, it cannot be [dangling], and it must point to a valid value\n  (in case of dynamically sized types, using the actual dynamic type of the\n  pointee as determined by the metadata).\n  Note that the last point (about pointing to a valid value) remains a subject of some debate.\n```\n\n----------------------------------------\n\nTITLE: Defining Attribute Grammar in Rust\nDESCRIPTION: Specifies the grammar for inner and outer attributes in Rust, including the syntax for attribute input.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nInnerAttribute -> `#` `!` `[` Attr `]`\n\nOuterAttribute -> `#` `[` Attr `]`\n\nAttr ->\n      SimplePath AttrInput?\n    | `unsafe` `(` SimplePath AttrInput? `)`\n\nAttrInput ->\n      DelimTokenTree\n    | `=` Expression\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Various Comment Types in Rust\nDESCRIPTION: This code snippet showcases different types of comments in Rust, including inner and outer doc comments, nested comments, and degenerate cases. It demonstrates how comments are used in module declarations and various syntactical situations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/comments.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n//! A doc comment that applies to the implicit anonymous module of this crate\n\npub mod outer_module {\n\n    //!  - Inner line doc\n    //!! - Still an inner line doc (but with a bang at the beginning)\n\n    /*!  - Inner block doc */\n    /*!! - Still an inner block doc (but with a bang at the beginning) */\n\n    //   - Only a comment\n    ///  - Outer line doc (exactly 3 slashes)\n    //// - Only a comment\n\n    /*   - Only a comment */\n    /**  - Outer block doc (exactly) 2 asterisks */\n    /*** - Only a comment */\n\n    pub mod inner_module {}\n\n    pub mod nested_comments {\n        /* In Rust /* we can /* nest comments */ */ */\n\n        // All three types of block comments can contain or be nested inside\n        // any other type:\n\n        /*   /* */  /** */  /*! */  */\n        /*!  /* */  /** */  /*! */  */\n        /**  /* */  /** */  /*! */  */\n        pub mod dummy_item {}\n    }\n\n    pub mod degenerate_cases {\n        // empty inner line doc\n        //!\n\n        // empty inner block doc\n        /*!*/\n\n        // empty line comment\n        //\n\n        // empty outer line doc\n        ///\n\n        // empty block comment\n        /**/\n\n        pub mod dummy_item {}\n\n        // empty 2-asterisk block isn't a doc block, it is a block comment\n        /***/\n\n    }\n\n    /* The next one isn't allowed because outer doc comments\n       require an item that will receive the doc */\n\n    /// Where is my item?\n#   mod boo {}\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Derive Attribute on Generic Parameter in Rust\nDESCRIPTION: Example showing how to apply a custom derive attribute 'my_flexible_clone' to modify a generic type parameter H in a struct definition. The example demonstrates the use of an attribute on a generic parameter, though it requires a proc macro derive implementation to be functional.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/generics.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n// Assume that the derive for MyFlexibleClone declared `my_flexible_clone` as\n// an attribute it understands.\n#[derive(MyFlexibleClone)]\nstruct Foo<#[my_flexible_clone(unbounded)] H> {\n    a: *const H\n}\n```\n\n----------------------------------------\n\nTITLE: Coercion Example with Let Statement in Rust\nDESCRIPTION: This code snippet demonstrates type coercion in a `let` statement where an explicit type is given.  The `&mut 42` expression is coerced to the type `&i8` because the variable is explicitly typed as `&i8`. This is a coercion site as the desired type is explicit.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/type-coercions.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n   let _: &i8 = &mut 42;\n   ```\n```\n\n----------------------------------------\n\nTITLE: Defining Fieldless Enum in Rust\nDESCRIPTION: Illustrates the creation of a fieldless enum, which includes variants without any fields.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/enumerations.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nenum Fieldless {\n    Tuple(),\n    Struct{},\n    Unit,\n}\n```\n\n----------------------------------------\n\nTITLE: Deref Coercion Example in Rust\nDESCRIPTION: This code snippet demonstrates Deref coercion in Rust, where a type implementing the `Deref` trait is coerced to its target type. `&mut CharContainer` is coerced to `&char` because `CharContainer` implements `Deref<Target = char>`. This allows the `foo` function, which expects a `&char`, to be called with a `&mut CharContainer`.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/type-coercions.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n  use std::ops::Deref;\n\n  struct CharContainer {\n      value: char,\n  }\n\n  impl Deref for CharContainer {\n      type Target = char;\n\n      fn deref<'a>(&'a self) -> &'a char {\n          &self.value\n      }\n  }\n\n  fn foo(arg: &char) {}\n\n  fn main() {\n      let x = &mut CharContainer { value: 'y' };\n      foo(x); //&mut CharContainer is coerced to &char.\n  }\n  ```\n```\n\n----------------------------------------\n\nTITLE: Illustrating Move Semantics in Block Expressions\nDESCRIPTION: Demonstrates how block expressions can be used to force moving a value, causing a compilation error when the moved value is used again.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/block-expr.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Struct;\n\nimpl Struct {\n    fn consume_self(self) {}\n    fn borrow_self(&self) {}\n}\n\nfn move_by_block_expression() {\n    let s = Struct;\n\n    // Move the value out of `s` in the block expression.\n    (&{ s }).borrow_self();\n\n    // Fails to execute because `s` is moved out of.\n    s.consume_self();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Static Item Syntax in Rust\nDESCRIPTION: Specifies the grammar for declaring static items in Rust, including optional safety qualifiers, mutability, identifier, type, and optional initialization.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/static-items.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nStaticItem ->\n    ItemSafety?[^extern-safety] `static` `mut`? IDENTIFIER `:` Type ( `=` Expression )? `;`\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Trait Bound Errors in Rust\nDESCRIPTION: This code snippet showcases examples of invalid trait bounds in Rust, causing compilation errors. It illustrates errors related to implementing `Iterator` for a concrete type (`i32`), using `Copy` for mutable references, and using `Sized` for dynamically sized types like slices.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/trait-bounds.md#2025-04-21_snippet_2\n\nLANGUAGE: rust,compile_fail\nCODE:\n```\n\"struct A<'a, T>\nwhere\n    i32: Default,           // Allowed, but not useful\n    i32: Iterator,          // Error: `i32` is not an iterator\n    &'a mut T: Copy,        // (at use) Error: the trait bound is not satisfied\n    [T]: Sized,             // (at use) Error: size cannot be known at compilation\n{\n    f: &'a T,\n}\nstruct UsesA<'a, T>(A<'a, T>);\"\n```\n\n----------------------------------------\n\nTITLE: Rust Tuple Type Examples\nDESCRIPTION: Examples demonstrating various tuple type declarations in Rust, including unit type, 1-ary tuple, and multi-field tuples with different type combinations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/tuple.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n()              // unit\n(i32,)          // 1-ary tuple\n(f64, f64)\n(String, i32)\n(i32, String)    // different type from the previous example\n(i32, f64, Vec<String>, Option<bool>)\n```\n\n----------------------------------------\n\nTITLE: Using Wrapping Newtype in Rust\nDESCRIPTION: This snippet introduces the Wrapping<T> newtype provided by the standard library, which ensures all standard arithmetic operations for T have wrapping semantics.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/behavior-not-considered-unsafe.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nWrapping<T>\n```\n\n----------------------------------------\n\nTITLE: Creating Ignored Test with Reason in Rust\nDESCRIPTION: Demonstrates how to create an ignored test using the @ignore attribute with a reason string. The test will be compiled but not executed by default unless specifically included.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/testing.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[test]\n#[ignore = \"not yet implemented\"]\nfn mytest() {\n    // …\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Match Expression Syntax in Rust\nDESCRIPTION: Grammar definition for match expressions in Rust, including scrutinee, match arms, and arm guards.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/match-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nMatchExpression ->\n    `match` Scrutinee `{`\n        InnerAttribute*\n        MatchArms?\n    `}`\n\nScrutinee -> Expression _except [StructExprStruct]_\n\nMatchArms ->\n    ( MatchArm `=>` ( ExpressionWithoutBlock `,` | ExpressionWithBlock `,`? ) )*\n    MatchArm `=>` Expression `,`?\n\nMatchArm -> OuterAttribute* Pattern MatchArmGuard?\n\nMatchArmGuard -> `if` Expression\n```\n\n----------------------------------------\n\nTITLE: Using the cfg Macro in Rust for Runtime Checks\nDESCRIPTION: Demonstrates the usage of the built-in cfg macro in Rust for performing configuration checks at runtime, such as determining the operating system.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/conditional-compilation.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet machine_kind = if cfg!(unix) {\n  \"unix\"\n} else if cfg!(windows) {\n  \"windows\"\n} else {\n  \"unknown\"\n};\n\nprintln!(\"I'm running on a {} machine!\", machine_kind);\n```\n\n----------------------------------------\n\nTITLE: Using link_name attribute in extern block\nDESCRIPTION: Demonstrates how to use the link_name attribute to specify the actual symbol name to import for a function in an extern block, allowing the Rust code to use a different name than the external symbol.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/external-blocks.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nunsafe extern {\n    #[link_name = \"actual_symbol_name\"]\n    safe fn name_in_rust();\n}\n```\n\n----------------------------------------\n\nTITLE: Closure Type Definition (Edition 2018 and Before)\nDESCRIPTION: This snippet illustrates the structure of a closure type in Rust Edition 2018 and before. It captures the entire `Rectangle` struct by mutable reference. The closure modifies the `x` fields of the `left_top` and `right_bottom` members and returns a formatted string of the `left_top` member.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\n```rust,ignore\nstruct Closure<'a> {\n    rect : &'a mut Rectangle,\n}\n\nimpl<'a> FnOnce<()> for Closure<'a> {\n    type Output = String;\n    extern \"rust-call\" fn call_once(self, args: ()) -> String {\n        self.rect.left_top.x += 1;\n        self.rect.right_bottom.x += 1;\n        format!(\"{:?}\", self.rect.left_top)\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Local Variable Drop Scope Demonstration\nDESCRIPTION: Shows how local variables declared in different scopes are dropped in reverse order of declaration within their respective scopes. Variables in inner blocks are dropped before outer blocks.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/destructors.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# struct PrintOnDrop(&'static str);\n# impl Drop for PrintOnDrop {\n#     fn drop(&mut self) {\n#         println!(\"drop({})\", self.0);\n#     }\n# }\nlet declared_first = PrintOnDrop(\"Dropped last in outer scope\");\n{\n    let declared_in_block = PrintOnDrop(\"Dropped in inner scope\");\n}\nlet declared_last = PrintOnDrop(\"Dropped first in outer scope\");\n```\n\n----------------------------------------\n\nTITLE: Defining Expression Grammar in Rust\nDESCRIPTION: Defines the grammar for Rust expressions, including ExpressionWithoutBlock and ExpressionWithBlock types. This grammar outlines the various forms of expressions in Rust, from literal and path expressions to block and control flow expressions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nExpression ->\n      ExpressionWithoutBlock\n    | ExpressionWithBlock\n\nExpressionWithoutBlock ->\n    OuterAttribute*\n    (\n        LiteralExpression\n      | PathExpression\n      | OperatorExpression\n      | GroupedExpression\n      | ArrayExpression\n      | AwaitExpression\n      | IndexExpression\n      | TupleExpression\n      | TupleIndexingExpression\n      | StructExpression\n      | CallExpression\n      | MethodCallExpression\n      | FieldExpression\n      | ClosureExpression\n      | AsyncBlockExpression\n      | ContinueExpression\n      | BreakExpression\n      | RangeExpression\n      | ReturnExpression\n      | UnderscoreExpression\n      | MacroInvocation\n    )\n\nExpressionWithBlock ->\n    OuterAttribute*\n    (\n        BlockExpression\n      | ConstBlockExpression\n      | UnsafeBlockExpression\n      | LoopExpression\n      | IfExpression\n      | IfLetExpression\n      | MatchExpression\n    )\n```\n\n----------------------------------------\n\nTITLE: Using Const Blocks with Generic Parameters in Rust\nDESCRIPTION: Demonstrates how const blocks can reference generic parameters and their equivalent desugared form.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/block-expr.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T>() -> usize {\n    const { std::mem::size_of::<T>() + 1 }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tuple Struct Expressions in Rust\nDESCRIPTION: Shows how tuple struct expressions are equivalent to call expressions to the tuple struct's constructor. It also demonstrates how a tuple struct can be used as a function.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/struct-expr.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nstruct Position(i32, i32, i32);\nPosition(0, 0, 0);  // Typical way of creating a tuple struct.\nlet c = Position;  // `c` is a function that takes 3 arguments.\nlet pos = c(8, 6, 7);  // Creates a `Position` value.\n```\n\n----------------------------------------\n\nTITLE: External Crate Macro Import Example\nDESCRIPTION: Demonstrates importing macros from external crates using the macro_use attribute with optional specific macro selection.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros-by-example.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n#[macro_use(lazy_static)] // Or #[macro_use] to import all macros.\nextern crate lazy_static;\n\nlazy_static!{}\n// self::lazy_static!{} // Error: lazy_static is not defined in `self`\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Macro Ambiguity in Rust\nDESCRIPTION: Shows an example of a macro definition that causes a compilation error due to ambiguity in parsing the macro invocation.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros-by-example.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! ambiguity {\n    ($($i:ident)* $j:ident) => { };\n}\n\nambiguity!(error); // Error: local ambiguity\n```\n\n----------------------------------------\n\nTITLE: Question Mark Operator with Option Example\nDESCRIPTION: Demonstrates using the question mark operator with Option types.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nfn try_option_some() -> Option<u8> {\n    let val = Some(1)?;\n    Some(val)\n}\nassert_eq!(try_option_some(), Some(1));\n\nfn try_option_none() -> Option<u8> {\n    let val = None?;\n    Some(val)\n}\nassert_eq!(try_option_none(), None);\n```\n\n----------------------------------------\n\nTITLE: Defining Invalid Values for Scalar Types in Rust\nDESCRIPTION: Specifies that integer, floating-point, and raw pointer values in Rust must be initialized. Obtaining these values from uninitialized memory is invalid.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/behavior-considered-undefined.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n* An integer (`i*`/`u*`), floating point value (`f*`), or raw pointer must be\n  initialized, i.e., must not be obtained from uninitialized memory.\n```\n\n----------------------------------------\n\nTITLE: Declaring Variadic Functions\nDESCRIPTION: This snippet shows how to declare variadic functions within an external block, which allows for a variable number of arguments. It emphasizes the use of the `...` syntax in the parameter list for variadic functions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/external-blocks.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nunsafe extern \"C\" {\n    safe fn foo(...);\n    unsafe fn bar(x: i32, ...);\n    unsafe fn with_name(format: *const u8, args: ...);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Closure Expression Grammar in Rust\nDESCRIPTION: Formal grammar specification for closure expressions in Rust, including support for async, move, parameters, and return types.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/closure-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nClosureExpression ->\n    `async`?\n    `move`?\n    ( `||` | `|` ClosureParameters? `|` )\n    (Expression | `->` TypeNoBounds BlockExpression)\n\nClosureParameters -> ClosureParam (`,` ClosureParam)* `,`?\n\nClosureParam -> OuterAttribute* PatternNoTopAlt ( `:` Type )?\n```\n\n----------------------------------------\n\nTITLE: Defining Arithmetic and Logical Operators in Rust\nDESCRIPTION: This snippet outlines the syntax for arithmetic and logical binary operators in Rust. The operators include addition, subtraction, multiplication, division, and more, with their corresponding grammar structures.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_13\n\nLANGUAGE: grammar,expressions\nCODE:\n```\nArithmeticOrLogicalExpression ->\n      Expression `+` Expression\n    | Expression `-` Expression\n    | Expression `*` Expression\n    | Expression `/` Expression\n    | Expression `%` Expression\n    | Expression `&` Expression\n    | Expression `|` Expression\n    | Expression `^` Expression\n    | Expression `<<` Expression\n    | Expression `>>` Expression\n```\n\n----------------------------------------\n\nTITLE: Trait Item Visibility with Macro Usage\nDESCRIPTION: Example demonstrating how trait items can syntactically include visibility annotations through macros, even though such annotations are rejected during validation. This allows for unified syntax across different contexts.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/traits.md#2025-04-21_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! create_method {\n    ($vis:vis $name:ident) => {\n        $vis fn $name(&self) {}\n    };\n}\n\ntrait T1 {\n    // Empty `vis` is allowed.\n    create_method! { method_of_t1 }\n}\n\nstruct S;\n\nimpl S {\n    // Visibility is allowed here.\n    create_method! { pub method_of_s }\n}\n\nimpl T1 for S {}\n\nfn main() {\n    let s = S;\n    s.method_of_t1();\n    s.method_of_s();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Sized Trait Incompatibility with Dyn in Rust\nDESCRIPTION: Example showing that traits with a 'Self: Sized' bound are not compatible with trait objects.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/traits.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n// `Self: Sized` traits are dyn-incompatible.\ntrait TraitWithSize where Self: Sized {}\n\nstruct S;\nimpl TraitWithSize for S {}\nlet obj: Box<dyn TraitWithSize> = Box::new(S); // ERROR\n```\n\n----------------------------------------\n\nTITLE: Restricted Parameter Patterns in Rust 2015 Edition\nDESCRIPTION: Example showing that in Rust 2015 edition, parameter patterns in trait associated functions with bodies were limited to simple patterns. This restriction was removed in the 2018 edition.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/traits.md#2025-04-21_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n// 2015 Edition\ntrait T {\n    fn f1((a, b): (i32, i32)) {} // ERROR: pattern not allowed\n}\n```\n\n----------------------------------------\n\nTITLE: Optional Parameter Patterns in Rust 2015 Edition\nDESCRIPTION: Example showing that in Rust 2015 edition, parameter identifiers in trait associated functions were optional. This behavior was changed in the 2018 edition.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/traits.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n// 2015 Edition\ntrait T {\n    fn f(i32); // OK: parameter identifiers are not required\n}\n```\n\n----------------------------------------\n\nTITLE: Negation Expression Grammar\nDESCRIPTION: Defines the syntax for negation expressions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_11\n\nLANGUAGE: grammar\nCODE:\n```\nNegationExpression ->\n      `-` Expression\n    | `!` Expression\n```\n\n----------------------------------------\n\nTITLE: Using Inferred Type in Generic Vector Collection\nDESCRIPTION: An example of using the inferred type in the generic argument of a Vec when collecting a range. The compiler infers the appropriate type based on the context.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/inferred.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet x: Vec<_> = (0..10).collect();\n```\n\n----------------------------------------\n\nTITLE: Implementing Trait Method Using Qualified Syntax in Rust\nDESCRIPTION: This snippet illustrates the implementation of a trait with an associated function and how to call this function using qualified paths. The 'from_i32' method is defined in the 'Num' trait and is instantiated for the f64 type, enabling various calling conventions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Num {\n    fn from_i32(n: i32) -> Self;\n}\n\nimpl Num for f64 {\n    fn from_i32(n: i32) -> f64 { n as f64 }\n}\n\n// These 4 are all equivalent in this case.\nlet _: f64 = Num::from_i32(42);\nlet _: f64 = <_ as Num>::from_i32(42);\nlet _: f64 = <f64 as Num>::from_i32(42);\nlet _: f64 = f64::from_i32(42);\n```\n\n----------------------------------------\n\nTITLE: Trait Bounds Must Be Explicit in Rust\nDESCRIPTION: This example demonstrates that trait bounds must be explicitly specified in Rust. The code shows that a function using a struct with a type parameter that requires `Debug` will fail to compile if the function signature doesn't explicitly specify that the type parameter implements `Debug`.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/trait-bounds.md#2025-04-21_snippet_6\n\nLANGUAGE: rust,compile_fail,E0277\nCODE:\n```\n\"use std::fmt::Debug;\nstruct IsDebug<T: Debug>(T);\n// error[E0277]: `T` doesn't implement `Debug`\nfn doesnt_specify_t_debug<T>(x: IsDebug<T>) {}\"\n```\n\n----------------------------------------\n\nTITLE: Restrictions on global_asm! in Rust - Rust\nDESCRIPTION: This snippet demonstrates the restrictions on the operands that can be used with `global_asm!`. It showcases the permitted operand types when global assembly is defined outside a function.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n# fn main() {}\nlet x = 5;\n// register operands aren't allowed, since we aren't in a function\n# #[cfg(target_arch = \"x86_64\")]\ncore::arch::global_asm!(\"\", in(reg) 5);\n// ERROR: the `in` operand cannot be used with `global_asm!`\n# #[cfg(not(target_arch = \"x86_64\"))] core::compile_error!(\"Test not supported on this arch\");\n```\n\n----------------------------------------\n\nTITLE: Defining Crate Grammar Structure\nDESCRIPTION: Grammar definition showing that a crate consists of inner attributes followed by items.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/crates-and-source-files.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\n@root Crate ->\n    InnerAttribute*\n    Item*\n```\n\n----------------------------------------\n\nTITLE: Global Path Resolution Example in Rust\nDESCRIPTION: Shows how global paths are resolved with the `::` qualifier in different Rust editions. Highlights how paths are interpreted as crate roots or via extern prelude.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/paths.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\npub fn foo() {\n    // In the 2018 edition, this accesses `std` via the extern prelude.\n    // In the 2015 edition, this accesses `std` via the crate root.\n    let now = ::std::time::Instant::now();\n    println!(\"{:?}\", now);\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n// 2015 Edition\nmod a {\n    pub fn foo() {}\n}\nmod b {\n    pub fn foo() {\n        ::a::foo(); // call `a`'s foo function\n        // In Rust 2018, `::a` would be interpreted as the crate `a`.\n    }\n}\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Integer to Float Casting in Rust\nDESCRIPTION: Demonstrates integer to float casting with rounding behavior and overflow handling.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\nassert_eq!(1337i32 as f32, 1337f32);\nassert_eq!(123_456_789i32 as f32, 123_456_790f32, \"Rounded\");\nassert_eq!(0xffffffff_ffffffff_ffffffff_ffffffff_u128 as f32, std::f32::INFINITY);\n```\n\n----------------------------------------\n\nTITLE: Local Inner Macros Example\nDESCRIPTION: Shows the local_inner_macros attribute usage for automatically prefixing macro invocations with $crate.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros-by-example.md#2025-04-21_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n#[macro_export(local_inner_macros)]\nmacro_rules! helped {\n    () => { helper!() } // Automatically converted to $crate::helper!().\n}\n\n#[macro_export]\nmacro_rules! helper {\n    () => { () }\n}\n```\n\n----------------------------------------\n\nTITLE: Crate-level Attribute Examples\nDESCRIPTION: Demonstrates common crate-level attributes for specifying crate name, output type, and compiler warnings.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/crates-and-source-files.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Specify the crate name.\n#![crate_name = \"projx\"]\n\n// Specify the type of output artifact.\n#![crate_type = \"lib\"]\n\n// Turn on a warning.\n// This can be done in any module, not just the anonymous crate module.\n#![warn(non_camel_case_types)]\n```\n\n----------------------------------------\n\nTITLE: Accessing Union Fields in an Unsafe Block\nDESCRIPTION: This snippet illustrates how to access a field of a union using unsafe Rust. Accessing fields requires an unsafe block to ensure the appropriate safety guarantees are met.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/unions.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# union MyUnion { f1: u32, f2: f32 }\n# let u = MyUnion { f1: 1 };\n\nunsafe {\n    let f = u.f1;\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Union Fields in Rust\nDESCRIPTION: This snippet provides an example of how to use pattern matching on union fields within an unsafe block. It demonstrates a function that matches a union on its fields and performs actions based on the match.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/unions.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# union MyUnion { f1: u32, f2: f32 }\n#\nfn f(u: MyUnion) {\n    unsafe {\n        match u {\n            MyUnion { f1: 10 } => { println!(\"ten\"); }\n            MyUnion { f2 } => { println!(\"{}\", f2); }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating non_exhaustive attribute limitations in external crates\nDESCRIPTION: This code snippet illustrates the limitations of using non_exhaustive types outside the defining crate. It shows how construction and pattern matching are restricted to preserve backwards compatibility.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/type_system.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// These are types defined in an upstream crate that have been annotated as\n// `#[non_exhaustive]`.\nuse upstream::{Config, Token, Id, Error, Message};\n\n// Cannot construct an instance of `Config`; if new fields were added in\n// a new version of `upstream` then this would fail to compile, so it is\n// disallowed.\nlet config = Config { window_width: 640, window_height: 480 };\n\n// Cannot construct an instance of `Token`; if new fields were added, then\n// it would not be a unit-like struct any more, so the same-named constant\n// created by it being a unit-like struct is not public outside the crate;\n// this code fails to compile.\nlet token = Token;\n\n// Cannot construct an instance of `Id`; if new fields were added, then\n// its constructor function signature would change, so its constructor\n// function is not public outside the crate; this code fails to compile.\nlet id = Id(5);\n\n// Can construct an instance of `Error`; new variants being introduced would\n// not result in this failing to compile.\nlet error = Error::Message(\"foo\".to_string());\n\n// Cannot construct an instance of `Message::Send` or `Message::Reaction`;\n// if new fields were added in a new version of `upstream` then this would\n// fail to compile, so it is disallowed.\nlet message = Message::Send { from: 0, to: 1, contents: \"foo\".to_string(), };\nlet message = Message::Reaction(0);\n\n// Cannot construct an instance of `Message::Quit`; if this were converted to\n// a tuple-variant `upstream` then this would fail to compile.\nlet message = Message::Quit;\n```\n\n----------------------------------------\n\nTITLE: Unsafe Borrowing from Unions in Rust\nDESCRIPTION: This snippet demonstrates a situation where borrowing one field of a union can lead to conflicts due to shared storage. It highlights Rust's compile-time checks and the need for unsafe blocks.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/unions.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# union MyUnion { f1: u32, f2: f32 }\n// ERROR: cannot borrow `u` (via `u.f2`) as mutable more than once at a time\nfn test() {\n    let mut u = MyUnion { f1: 1 };\n    unsafe {\n        let b1 = &mut u.f1;\n//                    ---- first mutable borrow occurs here (via `u.f1`)\n        let b2 = &mut u.f2;\n//                    ^^^^ second mutable borrow occurs here (via `u.f2`)\n        *b1 = 5;\n    }\n//  - first borrow ends here\n    assert_eq!(unsafe { u.f1 }, 5);\n}\n```\n\n----------------------------------------\n\nTITLE: Const and Static Function/Closure References in Rust\nDESCRIPTION: This snippet shows examples of how function and closure references are resolved in `const` declarations in Rust. The compiler applies standard elision rules first, and if unable to resolve lifetimes, it results in an error.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/lifetime-elision.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n# struct Foo;\n# struct Bar;\n# struct Baz;\n# fn somefunc(a: &Foo, b: &Bar, c: &Baz) -> usize {42}\n// Resolved as `for<'a> fn(&'a str) -> &'a str`.\nconst RESOLVED_SINGLE: fn(&str) -> &str = |x| x;\n\n// Resolved as `for<'a, 'b, 'c> Fn(&'a Foo, &'b Bar, &'c Baz) -> usize`.\nconst RESOLVED_MULTIPLE: &dyn Fn(&Foo, &Bar, &Baz) -> usize = &somefunc;\n```\n```\n\n----------------------------------------\n\nTITLE: Approximate Desugaring of Await Expressions in Rust\nDESCRIPTION: A non-normative desugaring of await expressions in Rust, showing the equivalent loop structure for polling a future until it's ready.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/await-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmatch operand.into_future() {\n    mut pinned => loop {\n        let mut pin = unsafe { Pin::new_unchecked(&mut pinned) };\n        match Pin::future::poll(Pin::borrow(&mut pin), &mut current_context) {\n            Poll::Ready(r) => break r,\n            Poll::Pending => yield Poll::Pending,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Closure Implementation Representation in Rust\nDESCRIPTION: A simplified illustration of how the Rust compiler internally represents a closure as a struct with captured references and implements the FnOnce trait.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Note: This is not exactly how it is translated, this is only for\n// illustration.\n\nstruct Closure<'a> {\n    left_top : &'a mut Point,\n    right_bottom_x : &'a mut i32,\n}\n\nimpl<'a> FnOnce<()> for Closure<'a> {\n    type Output = String;\n    extern \"rust-call\" fn call_once(self, args: ()) -> String {\n        self.left_top.x += 1;\n        *self.right_bottom_x += 1;\n        format!(\"{:?}\", self.left_top)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Comment Syntax in Rust using Grammar\nDESCRIPTION: This code snippet defines the grammar for various types of comments in Rust, including line comments, block comments, and doc comments (both inner and outer).\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/comments.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\n@root LINE_COMMENT ->\n      `//` (~[`/` `!` LF] | `//`) ~LF*\n    | `//`\n\nBLOCK_COMMENT ->\n      `/*`\n        ( ~[`*` `!`] | `**` | BlockCommentOrDoc )\n        ( BlockCommentOrDoc | ~`*/` )*\n      `*/`\n    | `/**/`\n    | `/***/`\n\n@root INNER_LINE_DOC ->\n    `//!` ~[LF CR]*\n\nINNER_BLOCK_DOC ->\n    `/*!` ( BlockCommentOrDoc | ~[`*/` CR] )* `*/`\n\n@root OUTER_LINE_DOC ->\n    `///` (~`/` ~[LF CR]*)?\n\nOUTER_BLOCK_DOC ->\n    `/**`\n      ( ~`*` | BlockCommentOrDoc )\n      ( BlockCommentOrDoc | ~[`*/` CR] )*\n    `*/`\n\nBlockCommentOrDoc ->\n      BLOCK_COMMENT\n    | OUTER_BLOCK_DOC\n    | INNER_BLOCK_DOC\n```\n\n----------------------------------------\n\nTITLE: Defining Grammar Productions in Markdown\nDESCRIPTION: Shows how to properly format a grammar production inside a markdown code block with the appropriate language tag and category.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/docs/grammar.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```grammar,items\nProductionName -> SomeExpression\n```\n```\n\n----------------------------------------\n\nTITLE: Unsafe Function Calls in Rust\nDESCRIPTION: Specification that calling unsafe functions, intrinsics, or foreign functions requires unsafe context in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/unsafety.md#2025-04-21_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n- Calling an unsafe function (including an intrinsic or foreign function).\n```\n\n----------------------------------------\n\nTITLE: Defining Invalid Values for Enums in Rust\nDESCRIPTION: Specifies that an enum in Rust must have a valid discriminant, and all fields of the indicated variant must be valid for their respective types.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/behavior-considered-undefined.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n* An `enum` must have a valid discriminant, and all fields of the variant indicated by that discriminant must be valid at their respective type.\n```\n\n----------------------------------------\n\nTITLE: Desugaring Async Functions in Rust\nDESCRIPTION: Illustrates the desugaring process of async functions to a structure returning a Future. The initial async function captures arguments and translates into a form using `async move` blocks. The desugar process maintains argument lifetime and parameter order, mimicking the behavior of non-async counterparts.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/functions.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nasync fn example(x: &str) -> usize {\n    x.len()\n}\n\n```\n\nLANGUAGE: rust\nCODE:\n```\n# use std::future::Future;\n// Desugared\nfn example<'a>(x: &'a str) -> impl Future<Output = usize> + 'a {\n    async move { x.len() }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Struct with C Representation in Rust\nDESCRIPTION: This snippet demonstrates how to define a struct with `C` representation in Rust using the `repr` attribute. The `C` representation is useful for ensuring compatibility with C language data structures by controlling memory layout alignment and order of fields. Required dependencies include the Rust standard library. The struct is represented as `ThreeInts` with fields of different types, and the overall alignment and padding adhere to C standards.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/type-layout.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(C)]\nstruct ThreeInts {\n    first: i16,\n    second: i8,\n    third: i32\n}\n```\n\n----------------------------------------\n\nTITLE: Type Alias Constructor Error\nDESCRIPTION: Demonstrates a case where a type alias cannot be used to qualify a constructor of a struct. The code shows that while using a `use` alias for the struct works for calling its constructor, using a `type` alias does not.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/type-aliases.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n\"struct MyStruct(u32);\n\nuse MyStruct as UseAlias;\ntype TypeAlias = MyStruct;\n\nlet _ = UseAlias(5); // OK\nlet _ = TypeAlias(5); // Doesn't work\"\n```\n\n----------------------------------------\n\nTITLE: Trait Object Lifetime Elision in Rust\nDESCRIPTION: This snippet illustrates how default lifetime bounds are applied to trait objects in Rust. It shows that if the trait object is used as a type argument of a generic type, the containing type is used to infer a bound.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/lifetime-elision.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n// For the following trait...\ntrait Foo { }\n\n// These two are the same because Box<T> has no lifetime bound on T\ntype T1 = Box<dyn Foo>;\ntype T2 = Box<dyn Foo + 'static>;\n\n// ...and so are these:\nimpl dyn Foo {}\nimpl dyn Foo + 'static {}\n\n// ...so are these, because &'a T requires T: 'a\ntype T3<'a> = &'a dyn Foo;\ntype T4<'a> = &'a (dyn Foo + 'a);\n\n// std::cell::Ref<'a, T> also requires T: 'a, so these are the same\ntype T5<'a> = std::cell::Ref<'a, dyn Foo>;\ntype T6<'a> = std::cell::Ref<'a, dyn Foo + 'a>;\n```\n```\n\n----------------------------------------\n\nTITLE: Unsafe Union Access in Rust\nDESCRIPTION: Documentation specifying that accessing union fields, except for assignment operations, is considered unsafe in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/unsafety.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n- Accessing a field of a [`union`], other than to assign to it.\n```\n\n----------------------------------------\n\nTITLE: Full Box Capture in Move Rust Closures\nDESCRIPTION: Demonstrates how reading the contents of a Box in a move closure captures the entire Box.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nstruct S(i32);\n\nlet b = Box::new(S(10));\nlet c_box = move || {\n    let x = (*b).0; // captures `b` with ByValue\n};\n```\n\n----------------------------------------\n\nTITLE: Implied Lifetime Bounds in Struct and Enum Definitions in Rust\nDESCRIPTION: This snippet shows how lifetime bounds are inferred for type definitions and impl blocks. The `Struct` and `Enum` definitions require `T: 'a` due to the presence of `&'a T` fields, which is automatically inferred by the compiler.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/trait-bounds.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n\"struct Struct<'a, T> {\n    // This requires `T: 'a` to be well-formed\n    // which is inferred by the compiler.\n    field: &'a T,\n}\n\nenum Enum<'a, T> {\n    // This requires `T: 'a` to be well-formed,\n    // which is inferred by the compiler.\n    //\n    // Note that `T: 'a` is required even when only\n    // using `Enum::OtherVariant`.\n    SomeVariant(&'a T),\n    OtherVariant,\n}\n\ntrait Trait<'a, T: 'a> {}\n\n// This would error because `T: 'a` is not implied by any type\n// in the impl header.\n//     impl<'a, T> Trait<'a, T> for () {}\n\n// This compiles as `T: 'a` is implied by the self type `&'a T`.\nimpl<'a, T> Trait<'a, T> for &'a T {}\"\n```\n\n----------------------------------------\n\nTITLE: Rust Whitespace Character Literals\nDESCRIPTION: List of Unicode whitespace characters that Rust recognizes as valid whitespace, including common escape sequences like \\t and \\n.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/whitespace.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n'\\t'  // U+0009 (horizontal tab)\n'\\n'  // U+000A (line feed)\n'\\r'  // U+000D (carriage return)\n' '   // U+0020 (space)\n```\n\n----------------------------------------\n\nTITLE: Implementing Token Stream Attribute Macro in Rust\nDESCRIPTION: Shows implementation of a basic procedural macro attribute that prints the attribute and item token streams. The macro takes TokenStream parameters and returns a TokenStream.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/procedural-macros.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n#[proc_macro_attribute]\npub fn show_streams(attr: TokenStream, item: TokenStream) -> TokenStream {\n    println!(\"attr: \\\"{attr}\\\"\");\n    println!(\"item: \\\"{item}\\\"\");\n    item\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating cfg Attribute Usage in Rust Functions\nDESCRIPTION: Provides examples of using the cfg attribute on Rust functions to conditionally include them based on various configuration predicates such as target OS, defined features, and architecture.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/conditional-compilation.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// The function is only included in the build when compiling for macOS\n#[cfg(target_os = \"macos\")]\nfn macos_only() {\n  // ...\n}\n\n// This function is only included when either foo or bar is defined\n#[cfg(any(foo, bar))]\nfn needs_foo_or_bar() {\n  // ...\n}\n\n// This function is only included when compiling for a unixish OS with a 32-bit\n// architecture\n#[cfg(all(unix, target_pointer_width = \"32\"))]\nfn on_32bit_unix() {\n  // ...\n}\n\n// This function is only included when foo is not defined\n#[cfg(not(foo))]\nfn needs_not_foo() {\n  // ...\n}\n\n// This function is only included when the panic strategy is set to unwind\n#[cfg(panic = \"unwind\")]\nfn when_unwinding() {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Self Imports in Rust\nDESCRIPTION: This example showcases using the 'self' keyword in 'use' statements within Rust, illustrating how to bind a parent entity under its own name. It also explains namespace limitations where 'self' imports only the mod, not value namespace items, demonstrating with a compile-failing example.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/use-declarations.md#2025-04-21_snippet_5\n\nLANGUAGE: rust,compile_fail\nCODE:\n```\nmod bar {\n    pub mod foo {}\n    pub fn foo() {}\n}\n\n// This only imports the module `foo`. The function `foo` lives in\n// the value namespace and is not imported.\nuse bar::foo::{self};\n\nfn main() {\n    foo(); //~ ERROR `foo` is a module\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Rust Nightly Toolchain\nDESCRIPTION: Command to install the nightly version of the Rust compiler, which is required for running tests in the Rust Language Reference project.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nrustup toolchain install nightly\n```\n\n----------------------------------------\n\nTITLE: Building and Opening Rust Reference Locally\nDESCRIPTION: Command to build the Rust Language Reference locally and open it in a web browser. The SPEC_RELATIVE environment variable is set to use absolute URLs for standard library links.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/README.md#2025-04-21_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nSPEC_RELATIVE=0 mdbook build --open\n```\n\n----------------------------------------\n\nTITLE: Disambiguating Type Boundaries with Parentheses in Rust\nDESCRIPTION: Demonstrates how to use parentheses to disambiguate type expressions, particularly for reference types with trait boundaries where the scope of the boundary might be unclear.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use std::any::Any;\ntype T<'a> = &'a (dyn Any + Send);\n```\n\n----------------------------------------\n\nTITLE: Using inout to Modify Values in Register - Rust\nDESCRIPTION: This code snippet demonstrates the use of the `inout` operand to modify a value stored in a register directly. A mutable initialized expression is modified in-place by incrementing its value through assembly.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(target_arch = \"x86_64\")] {\nlet mut x: i64 = 4;\n// `inout` can be used to modify values in-register\nunsafe { core::arch::asm!(\"inc {}\", inout(reg) x); }\nassert_eq!(x, 5);\n# }\n```\n\n----------------------------------------\n\nTITLE: Using Inert Helper Attributes with Procedural Macros in Rust\nDESCRIPTION: This example shows how to use inert helper attributes on function parameters that can be processed by procedural macro attributes. The proc macro is responsible for detecting and removing these inert attributes from the output token stream.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/functions.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n#[some_proc_macro_attribute]\nfn foo_oof(#[some_inert_attribute] arg: u8) {\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Local Binding Shadowing in Rust\nDESCRIPTION: This example illustrates how local bindings can shadow item declarations in Rust. It shows a function where a local closure shadows a function with the same name.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/names/scopes.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn shadow_example() {\n    // Since there are no local variables in scope yet, this resolves to the function.\n    foo(); // prints `function`\n    let foo = || println!(\"closure\");\n    fn foo() { println!(\"function\"); }\n    // This resolves to the local closure since it shadows the item.\n    foo(); // prints `closure`\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Attribute Macro (Rust)\nDESCRIPTION: This snippet demonstrates how to define an attribute macro.  The `#[proc_macro_attribute]` attribute marks the function as an attribute macro. It receives two `TokenStream`s: the first is the tokens inside the attribute (if any), and the second is the item the attribute is attached to.  This example simply returns the item as is, making it a no-op.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/procedural-macros.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n# #![crate_type = \"proc-macro\"]\n# extern crate proc_macro;\n# use proc_macro::TokenStream;\n\n#[proc_macro_attribute]\npub fn return_as_is(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    item\n}\n\n```\n\n----------------------------------------\n\nTITLE: Field Expression Usage with Method Call\nDESCRIPTION: Example demonstrating how to properly use field expressions when calling functions stored in fields, showing invalid and valid syntax patterns.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/field-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# struct HoldsCallable<F: Fn()> { callable: F }\nlet holds_callable = HoldsCallable { callable: || () };\n\n// Invalid: Parsed as calling the method \"callable\"\n// holds_callable.callable();\n\n// Valid\n(holds_callable.callable)();\n```\n\n----------------------------------------\n\nTITLE: Associated Constants Evaluation in Rust\nDESCRIPTION: Demonstrates that associated constant definitions are only evaluated when referenced. Shows examples of both non-generic and generic associated constants with panic conditions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nstruct Struct;\nstruct GenericStruct<const ID: i32>;\n\nimpl Struct {\n    // Definition not immediately evaluated\n    const PANIC: () = panic!(\"compile-time panic\");\n}\n\nimpl<const ID: i32> GenericStruct<ID> {\n    // Definition not immediately evaluated\n    const NON_ZERO: () = if ID == 0 {\n        panic!(\"contradiction\")\n    };\n}\n\nfn main() {\n    // Referencing Struct::PANIC causes compilation error\n    let _ = Struct::PANIC;\n\n    // Fine, ID is not 0\n    let _ = GenericStruct::<1>::NON_ZERO;\n\n    // Compilation error from evaluating NON_ZERO with ID=0\n    let _ = GenericStruct::<0>::NON_ZERO;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Enum Discriminants via Pointer Casting in Rust\nDESCRIPTION: Demonstrates how to access discriminant values of enums with primitive representation using unsafe pointer casting.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/enumerations.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(u8)]\nenum Enum {\n    Unit,\n    Tuple(bool),\n    Struct{a: bool},\n}\n\nimpl Enum {\n    fn discriminant(&self) -> u8 {\n        unsafe { *(self as *const Self as *const u8) }\n    }\n}\n\nlet unit_like = Enum::Unit;\nlet tuple_like = Enum::Tuple(true);\nlet struct_like = Enum::Struct{a: false};\n\nassert_eq!(0, unit_like.discriminant());\nassert_eq!(1, tuple_like.discriminant());\nassert_eq!(2, struct_like.discriminant());\n```\n\n----------------------------------------\n\nTITLE: Enabling Procedural Macro Crate in Cargo Manifest (TOML)\nDESCRIPTION: This snippet shows how to define a crate as a procedural macro crate in a Cargo.toml manifest file.  The `proc-macro = true` setting under the `[lib]` section tells Cargo that this crate should be compiled as a procedural macro library, which is necessary for defining custom macros.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/procedural-macros.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n\n[lib]\nproc-macro = true\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating numeric casting restrictions with non_exhaustive enums\nDESCRIPTION: This code snippet illustrates that numeric casting is not allowed on enums containing non-exhaustive variants when used outside the defining crate.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/type_system.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[non_exhaustive]\npub enum Example {\n    First,\n    Second\n}\n\n#[non_exhaustive]\npub enum EnumWithNonExhaustiveVariants {\n    First,\n    #[non_exhaustive]\n    Second\n}\n\nuse othercrate::EnumWithNonExhaustiveVariants;\n\n// Error: cannot cast an enum with a non-exhaustive variant when it's defined in another crate\nlet _ = EnumWithNonExhaustiveVariants::First as u8;\n```\n\n----------------------------------------\n\nTITLE: Float to Integer Casting in Rust\nDESCRIPTION: Shows float to integer casting behavior including rounding towards zero, NaN handling, and value saturation at bounds.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\nassert_eq!(42.9f32 as i32, 42);\nassert_eq!(-42.9f32 as i32, -42);\nassert_eq!(42_000_000f32 as i32, 42_000_000);\nassert_eq!(std::f32::NAN as i32, 0);\nassert_eq!(1_000_000_000_000_000f32 as i32, 0x7fffffffi32);\nassert_eq!(std::f32::NEG_INFINITY as i32, -0x80000000i32);\n```\n\n----------------------------------------\n\nTITLE: Using Super in Paths Example in Rust\nDESCRIPTION: Illustrates how `super` can be used in Rust paths to access parent modules. Multiple `super` segments can be used to traverse up the module hierarchy.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/paths.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nmod a {\n    pub fn foo() {}\n}\nmod b {\n    pub fn foo() {\n        super::a::foo(); // call a's foo function\n    }\n}\n# fn main() {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nmod a {\n    fn foo() {}\n\n    mod b {\n        mod c {\n            fn foo() {\n                super::super::foo(); // call a's foo function\n                self::super::super::foo(); // call a's foo function\n            }\n        }\n    }\n}\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Macro Fragment Forwarding Restrictions in Rust\nDESCRIPTION: Demonstrates the restrictions when forwarding matched fragments to another macro, showing that literal tokens cannot be used to match forwarded fragments except for ident, lifetime, and tt types.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros-by-example.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! foo {\n    ($l:expr) => { bar!($l); }\n// ERROR:               ^^ no rules expected this token in macro call\n}\n\nmacro_rules! bar {\n    (3) => {}\n}\n\nfoo!(3);\n```\n\n----------------------------------------\n\nTITLE: Declaring Brace Syntax Use Statements in Rust\nDESCRIPTION: This snippet demonstrates the use of brace syntax in 'use' declarations to import multiple items from a namespace in Rust. It shows how to cleanly import types such as 'BTreeSet' and sub-modules like 'hash_map' and 'HashMap' using nested braces for hierarchical namespaces.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/use-declarations.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// Creates bindings to:\n// - `std::collections::BTreeSet`\n// - `std::collections::hash_map`\n// - `std::collections::hash_map::HashMap`\nuse std::collections::{BTreeSet, hash_map::{self, HashMap}};\n```\n\n----------------------------------------\n\nTITLE: Const and Static Lifetime Elision in Rust\nDESCRIPTION: This snippet demonstrates implicit `'static` lifetimes in `const` and `static` declarations of reference types in Rust. If an explicit lifetime is not specified, the compiler automatically assigns the `'static` lifetime.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/lifetime-elision.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n// STRING: &'static str\nconst STRING: &str = \"bitstring\";\n\nstruct BitsNStrings<'a> {\n    mybits: [u32; 2],\n    mystring: &'a str,\n}\n\n// BITS_N_STRINGS: BitsNStrings<'static>\nconst BITS_N_STRINGS: BitsNStrings<'_> = BitsNStrings {\n    mybits: [1, 2],\n    mystring: STRING,\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Local Function Macro Scope in Rust\nDESCRIPTION: Demonstrates how macros can be defined and used locally within functions, following similar scoping rules as module-level macros.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros-by-example.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {\n    // m!(); // Error: m is not in scope.\n    macro_rules! m {\n        () => {};\n    }\n    m!();\n}\n\n// m!(); // Error: m is not in scope.\n```\n\n----------------------------------------\n\nTITLE: Declaring a Union in Rust\nDESCRIPTION: This snippet demonstrates how to declare a union named 'MyUnion' with two fields. The declaration uses the #[repr(C)] attribute to ensure a compatible layout with C structures.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/unions.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(C)]\nunion MyUnion {\n    f1: u32,\n    f2: f32,\n}\n```\n\n----------------------------------------\n\nTITLE: Expression Path Syntax Definition\nDESCRIPTION: Defines the grammar for paths in expressions, including the use of generic arguments and special path identifiers. It explains the `turbofish` syntax used in Rust to distinguish between generics and operators.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/paths.md#2025-04-21_snippet_2\n\nLANGUAGE: grammar\nCODE:\n```\nPathInExpression ->\n    `::`? PathExprSegment (`::` PathExprSegment)*\n\nPathExprSegment ->\n    PathIdentSegment (`::` GenericArgs)?\n\nPathIdentSegment ->\n    IDENTIFIER | `super` | `self` | `Self` | `crate` | `$crate`\n\nGenericArgs ->\n      `<` `>`\n    | `<` ( GenericArg `,` )* GenericArg `,`? `>`\n\nGenericArg ->\n    Lifetime | Type | GenericArgsConst | GenericArgsBinding | GenericArgsBounds\n\nGenericArgsConst ->\n      BlockExpression\n    | LiteralExpression\n    | `-` LiteralExpression\n    | SimplePathSegment\n\nGenericArgsBinding ->\n    IDENTIFIER GenericArgs? `=` Type\n\nGenericArgsBounds ->\n    IDENTIFIER GenericArgs? `:` TypeParamBounds\n```\n\n----------------------------------------\n\nTITLE: Creating Unit Struct Expressions in Rust\nDESCRIPTION: Demonstrates two ways of creating unit struct expressions in Rust: using the path to the unit struct item and using a fieldless struct expression.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/struct-expr.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nstruct Gamma;\nlet a = Gamma;  // Gamma unit value.\nlet b = Gamma{};  // Exact same value as `a`.\n```\n\n----------------------------------------\n\nTITLE: Variance Computation in Tuples and Function Pointers\nDESCRIPTION: This snippet showcases how variance is evaluated separately in tuples and function pointers in Rust. It implies no specific dependencies but requires a comprehension of variance mechanics. The inputs involve tuple and function pointer manipulations, outputting results based on how variance allows for shrinking or extending lifetimes in separate contexts.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/subtyping.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# use std::cell::UnsafeCell;\nfn generic_tuple<'short, 'long: 'short>(\n    // 'long is used inside of a tuple in both a co- and invariant position.\n    x: (&'long u32, UnsafeCell<&'long u32>),\n) {\n    // As the variance at these positions is computed separately,\n    // we can freely shrink 'long in the covariant position.\n    let _: (&'short u32, UnsafeCell<&'long u32>) = x;\n}\n\nfn takes_fn_ptr<'short, 'middle: 'short>(\n    // 'middle is used in both a co- and contravariant position.\n    f: fn(&'middle ()) -> &'middle (),\n) {\n    // As the variance at these positions is computed separately,\n    // we can freely shrink 'middle in the covariant position\n    // and extend it in the contravariant position.\n    let _: fn(&'static ()) -> &'short () = f;\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Crate Type as Binary in Rust\nDESCRIPTION: Demonstrates how to specify a crate type as a binary executable using either a command-line flag or a crate attribute. This produces a runnable executable that includes all Rust and native dependencies.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/linkage.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n--crate-type=bin\n```\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_type = \"bin\"]\n```\n\n----------------------------------------\n\nTITLE: Integer Extension Casting in Rust\nDESCRIPTION: Demonstrates zero-extension for unsigned integers and sign-extension for signed integers when casting to larger sizes.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\nassert_eq!(42i8 as i16, 42i16);\nassert_eq!(-17i8 as i16, -17i16);\nassert_eq!(0b1000_1010u8 as u16, 0b0000_0000_1000_1010u16, \"Zero-extend\");\nassert_eq!(0b0000_1010i8 as i16, 0b0000_0000_0000_1010i16, \"Sign-extend 0\");\nassert_eq!(0b1000_1010u8 as i8 as i16, 0b1111_1111_1000_1010u16 as i16, \"Sign-extend 1\");\n```\n\n----------------------------------------\n\nTITLE: Equivalent Manual Implementation of PartialEq for Foo Struct in Rust\nDESCRIPTION: This snippet shows the equivalent manual implementation of the PartialEq trait for the Foo struct, which is automatically generated by the derive attribute.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/derive.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# struct Foo<T> { a: i32, b: T }\nimpl<T: PartialEq> PartialEq for Foo<T> {\n    fn eq(&self, other: &Foo<T>) -> bool {\n        self.a == other.a && self.b == other.b\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Labelled Block Expressions in Rust\nDESCRIPTION: This code demonstrates the use of labelled block expressions in Rust. It shows how to use break with labels to exit the block early and return different values based on conditions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/loop-expr.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet result = 'block: {\n    do_thing();\n    if condition_not_met() {\n        break 'block 1;\n    }\n    do_next_thing();\n    if condition_not_met() {\n        break 'block 2;\n    }\n    do_last_thing();\n    3\n};\n```\n\n----------------------------------------\n\nTITLE: Or-pattern type mismatch error example in Rust\nDESCRIPTION: This example demonstrates a compile-time error that occurs when there is a type mismatch between the same variable `x` in different subpatterns of an or-pattern. This ensures type consistency across the or-pattern.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_23\n\nLANGUAGE: Rust\nCODE:\n```\n\"&A(x) | B(x)\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating recursion_limit attribute in Rust\nDESCRIPTION: This example shows how the recursion_limit attribute restricts macro expansion depth. It sets the limit to 4 and demonstrates a macro that fails to expand due to exceeding this limit.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/limits.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![recursion_limit = \"4\"]\n\nmacro_rules! a {\n    () => { a!(1); };\n    (1) => { a!(2); };\n    (2) => { a!(3); };\n    (3) => { a!(4); };\n    (4) => { };\n}\n\n// This fails to expand because it requires a recursion depth greater than 4.\na!{}\n```\n\n----------------------------------------\n\nTITLE: Compound Assignment Expressions Syntax in Rust\nDESCRIPTION: Provides the grammar for compound assignment expressions combining arithmetic and logical operators with assignments. These expressions modify a variable using an operator and `=` in a single step. Prerequisites include familiarity with Rust's expression syntax and operators.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_34\n\nLANGUAGE: expressions\nCODE:\n```\nCompoundAssignmentExpression ->\n      Expression `+=` Expression\n    | Expression `-=` Expression\n    | Expression `*=` Expression\n    | Expression `/=` Expression\n    | Expression `%=` Expression\n    | Expression `&=` Expression\n    | Expression `|=` Expression\n    | Expression `^=` Expression\n    | Expression `<<=` Expression\n    | Expression `>>=` Expression\n```\n\n----------------------------------------\n\nTITLE: Static Lifetime Usage in Generic Associated Types in Rust\nDESCRIPTION: Demonstrates that explicit uses of 'static lifetime in functions using GATs don't affect the required bounds on the GAT declaration.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\ntrait StaticReturn {\n    type Y<'a>;\n    fn foo(&self) -> Self::Y<'static>;\n}\n```\n\n----------------------------------------\n\nTITLE: Macro Hygiene Example\nDESCRIPTION: Demonstrates mixed-site hygiene in macros, showing how variable lookup differs between definition and invocation sites.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros-by-example.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 1;\nfn func() {\n    unreachable!(\"this is never called\")\n}\n\nmacro_rules! check {\n    () => {\n        assert_eq!(x, 1); // Uses `x` from the definition site.\n        func();           // Uses `func` from the invocation site.\n    };\n}\n\n{\n    let x = 2;\n    fn func() { /* does not panic */ }\n    check!();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Range Expression Grammar in Rust\nDESCRIPTION: Specifies the grammar for different types of range expressions in Rust, including RangeExpr, RangeFromExpr, RangeToExpr, RangeFullExpr, RangeInclusiveExpr, and RangeToInclusiveExpr.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/range-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nRangeExpression ->\n      RangeExpr\n    | RangeFromExpr\n    | RangeToExpr\n    | RangeFullExpr\n    | RangeInclusiveExpr\n    | RangeToInclusiveExpr\n\nRangeExpr -> Expression `..` Expression\n\nRangeFromExpr -> Expression `..`\n\nRangeToExpr -> `..` Expression\n\nRangeFullExpr -> `..`\n\nRangeInclusiveExpr -> Expression `..=` Expression\n\nRangeToInclusiveExpr -> `..=` Expression\n```\n\n----------------------------------------\n\nTITLE: Using Underscore Imports with Macros in Rust\nDESCRIPTION: This example shows how macros can safely emit multiple references to underscore imports without producing errors. The macro m! expands to duplicate 'use std as _;' statements, which is valid because underscore imports create unique, unnameable symbols after macro expansion.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/use-declarations.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! m {\n    ($item: item) => { $item $item }\n}\n\nm!(use std as _;);\n// This expands to:\n// use std as _;\n// use std as _;\n```\n\n----------------------------------------\n\nTITLE: Representing Enums with Fields as #[repr(C)] in Rust\nDESCRIPTION: This Rust code snippet demonstrates how enums with fields, marked with #[repr(C)], are structured as a tagged union in C. This representation involves using enums for discriminants and unions for encapsulating variant fields. It serves to maintain compatibility with C ABIs, facilitating interoperability between Rust and C.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/type-layout.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// This Enum has the same representation as ...\n#[repr(C)]\nenum MyEnum {\n    A(u32),\n    B(f32, u64),\n    C { x: u32, y: u8 },\n    D,\n }\n\n// ... this struct.\n#[repr(C)]\nstruct MyEnumRepr {\n    tag: MyEnumDiscriminant,\n    payload: MyEnumFields,\n}\n\n// This is the discriminant enum.\n#[repr(C)]\nenum MyEnumDiscriminant { A, B, C, D }\n\n// This is the variant union.\n#[repr(C)]\nunion MyEnumFields {\n    A: MyAFields,\n    B: MyBFields,\n    C: MyCFields,\n    D: MyDFields,\n}\n\n#[repr(C)]\n#[derive(Copy, Clone)]\nstruct MyAFields(u32);\n\n#[repr(C)]\n#[derive(Copy, Clone)]\nstruct MyBFields(f32, u64);\n\n#[repr(C)]\n#[derive(Copy, Clone)]\nstruct MyCFields { x: u32, y: u8 }\n\n// This struct could be omitted (it is a zero-sized type), and it must be in\n// C/C++ headers.\n#[repr(C)]\n#[derive(Copy, Clone)]\nstruct MyDFields;\n```\n\n----------------------------------------\n\nTITLE: Coercion from function items to function pointers\nDESCRIPTION: This example shows how function items can be coerced to function pointers when explicitly expected or when different function item types with the same signature meet in different branches of control flow.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/function-item.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# let want_i32 = false;\n# fn foo<T>() { }\n\n// `foo_ptr_1` has function pointer type `fn()` here\nlet foo_ptr_1: fn() = foo::<i32>;\n\n// ... and so does `foo_ptr_2` - this type-checks.\nlet foo_ptr_2 = if want_i32 {\n    foo::<i32>\n} else {\n    foo::<u32>\n};\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Non-Dispatchable Trait Methods in Rust\nDESCRIPTION: Examples of trait methods that cannot be dispatched on trait objects, including non-methods, Self return types, and generic methods.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/traits.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// This trait is dyn compatible, but these methods cannot be dispatched on a trait object.\ntrait NonDispatchable {\n    // Non-methods cannot be dispatched.\n    fn foo() where Self: Sized {}\n    // Self type isn't known until runtime.\n    fn returns(&self) -> Self where Self: Sized;\n    // `other` may be a different concrete type of the receiver.\n    fn param(&self, other: Self) where Self: Sized {}\n    // Generics are not compatible with vtables.\n    fn typed<T>(&self, x: T) where Self: Sized {}\n}\n\nstruct S;\nimpl NonDispatchable for S {\n    fn returns(&self) -> Self where Self: Sized { S }\n}\nlet obj: Box<dyn NonDispatchable> = Box::new(S);\nobj.returns(); // ERROR: cannot call with Self return\nobj.param(S);  // ERROR: cannot call with Self parameter\nobj.typed(1);  // ERROR: cannot call with generic type\n```\n\n----------------------------------------\n\nTITLE: Char Type Definition in Rust\nDESCRIPTION: Defines char type as a 32-bit Unicode scalar value, storing code points in ranges 0x0000-0xD7FF or 0xE000-0x10FFFF. Equivalent to UCS-4/UTF-32 character.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/textual.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nchar\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Compile-Time Evaluation of Constants in Rust\nDESCRIPTION: Example showing how free constants are evaluated at compile-time in Rust, surfacing panics even within unused functions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/constant-items.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// Compile-time panic\\nconst PANIC: () = std::unimplemented!();\\n\\nfn unused_generic_function<T>() {\\n    // A failing compile-time assertion\\n    const _: () = assert!(usize::BITS == 0);\\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Operand Types for Inline Assembly - Rust\nDESCRIPTION: This code snippet discusses the allowed types for operands in Rust's inline assembly. It lists integer types, floating-point numbers, pointers, and SIMD vectors while showing correct usage examples.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(target_arch = \"x86_64\")] {\nextern \"C\" fn foo() {}\n\n// Integers are allowed...\nlet y: i64 = 5;\nsafe { core::arch::asm!(\"/* {} */\", in(reg) y); }\n\n// and pointers...\nlet py = &raw const y;\nsafe { core::arch::asm!(\"/* {} */\", in(reg) py); }\n\n// floats as well...\nlet f = 1.0f32;\nsafe { core::arch::asm!(\"/* {} */\", in(xmm_reg) f); }\n\n// even function pointers and simd vectors.\nlet func: extern \"C\" fn() = foo;\nsafe { core::arch::asm!(\"/* {} */\", in(reg) func); }\n\nlet z = unsafe { core::arch::x86_64::_mm_set_epi64x(1, 0) };\nsafe { core::arch::asm!(\"/* {} */\", in(xmm_reg) z); }\n# }\n```\n\n----------------------------------------\n\nTITLE: Call Expression Grammar Definition\nDESCRIPTION: Formal grammar definition for call expressions in Rust, showing the syntax structure for function calls with optional parameters.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/call-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nCallExpression -> Expression `(` CallParams? `)`\n\nCallParams -> Expression ( `,` Expression )* `,`?\n```\n\n----------------------------------------\n\nTITLE: Struct Variance Analysis in Rust\nDESCRIPTION: This code demonstrates how variance is determined within a custom struct in Rust. It highlights how lifetimes and type parameters affect the struct's variance. Key parameters include the field types and their effect on the struct's variance, with no specific external dependencies. The output illustrates how variance can make the struct invariant due to specific type uses.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/subtyping.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cell::UnsafeCell;\nstruct Variance<'a, 'b, 'c, T, U: 'a> {\n    x: &'a U,               // This makes `Variance` covariant in 'a, and would\n                            // make it covariant in U, but U is used later\n    y: *const T,            // Covariant in T\n    z: UnsafeCell<&'b f64>, // Invariant in 'b\n    w: *mut U,              // Invariant in U, makes the whole struct invariant\n\n    f: fn(&'c ()) -> &'c () // Both co- and contravariant, makes 'c invariant\n                            // in the struct.\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Function Example with Scope\nDESCRIPTION: This Rust code demonstrates scope rules for variable declarations within nested functions. The inner function attempts to access the outer variable, which is not in scope, highlighting Rust's scope restrictions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/statements.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn outer() {\n  let outer_var = true;\n\n  fn inner() { /* outer_var is not in scope here */ }\n\n  inner();\n}\n```\n\n----------------------------------------\n\nTITLE: Reference Type Grammar Syntax in Rust\nDESCRIPTION: Grammar definition for reference types in Rust, showing how references are formed with optional lifetime annotations and mutability modifiers.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/pointer.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nReferenceType -> `&` Lifetime? `mut`? TypeNoBounds\n```\n\n----------------------------------------\n\nTITLE: String Literal Examples in Rust\nDESCRIPTION: Shows different ways to create string literals in Rust, including regular strings, raw strings, escaped characters, and how string escape sequences work compared to raw strings.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/literal-expr.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n\"foo\"; r\"foo\";                     // foo\n\"\\\"foo\\\"\"; r#\"\"foo\"\"#;             // \"foo\"\n\n\"foo #\\\"# bar\";\nr##\"foo #\"# bar\"##;                // foo #\"# bar\n\n\"\\x52\"; \"R\"; r\"R\";                 // R\n\"\\\\x52\"; r\"\\x52\";                  // \\x52\n```\n\n----------------------------------------\n\nTITLE: Using Macros with Unnamed Constants in Rust\nDESCRIPTION: Demonstration of how macros can safely emit the same unnamed constant multiple times in the same scope without producing errors.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/constant-items.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! m {\\n    ($item: item) => { $item $item }\\n}\\n\\nm!(const _: () = (););\\n// This expands to:\\n// const _: () = ();\\n// const _: () = ();\n```\n\n----------------------------------------\n\nTITLE: Coercion Example in Function Arguments in Rust\nDESCRIPTION: This code snippet demonstrates type coercion when passing arguments to a function. The `&mut 42` expression is coerced to `&i8` when passed as an argument to the `bar` function, as the function expects an argument of type `&i8`. The actual parameter is coerced to the type of the formal parameter.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/type-coercions.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n  fn bar(_: &i8) { }\n\n  fn main() {\n      bar(&mut 42);\n  }\n  ```\n```\n\n----------------------------------------\n\nTITLE: Using Path Attribute with External Module in Rust\nDESCRIPTION: This snippet shows how to use the path attribute to specify dependencies for a module `c` in Rust. The module is defined to load from an external source file with a specified relative location depending on the source file positioning.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/modules.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[path = \"foo.rs\"]\nmod c;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating cfg_attr Attribute Usage in Rust\nDESCRIPTION: Provides examples of using the cfg_attr attribute in Rust to conditionally include attributes based on configuration predicates, such as target OS-specific file paths.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/conditional-compilation.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg_attr(target_os = \"linux\", path = \"linux.rs\")]\n#[cfg_attr(windows, path = \"windows.rs\")]\nmod os;\n```\n\n----------------------------------------\n\nTITLE: Wildcard Pattern Examples\nDESCRIPTION: Shows various uses of the wildcard pattern (_) to ignore values in different contexts, including destructuring, function parameters, and match statements.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n# let x = 20;\nlet (a, _) = (10, x);   // the x is always matched by _\n# assert_eq!(a, 10);\n\n// ignore a function/closure param\nlet real_part = |a: f64, _: f64| { a };\n\n// ignore a field from a struct\n# struct RGBA {\n#    r: f32,\n#    g: f32,\n#    b: f32,\n#    a: f32,\n# }\n# let color = RGBA{r: 0.4, g: 0.1, b: 0.9, a: 0.5};\nlet RGBA{r: red, g: green, b: blue, a: _} = color;\n# assert_eq!(color.r, red);\n# assert_eq!(color.g, green);\n# assert_eq!(color.b, blue);\n\n// accept any Some, with any value\n# let x = Some(10);\nif let Some(_) = x {}\n```\n\n----------------------------------------\n\nTITLE: Macro Use Attribute Module Example\nDESCRIPTION: Shows how the macro_use attribute can extend a module's macro scope beyond its closure point.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros-by-example.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n#[macro_use]\nmod inner {\n    macro_rules! m {\n        () => {};\n    }\n}\n\nm!();\n```\n\n----------------------------------------\n\nTITLE: Output Operands in Rust Inline Assembly\nDESCRIPTION: Shows how to use output operands in Rust's inline assembly to pass values from assembly back to Rust code.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\nlet x: i64;\nunsafe { core::arch::asm!(\"/* {} */\", out(reg) x); }\n```\n\n----------------------------------------\n\nTITLE: Defining an External Block with Syntax\nDESCRIPTION: This snippet defines the syntax for an external block, specifying the structure required for declarations like functions and statics within the block. It requires the `unsafe` keyword for proper usage in Rust FFI context.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/external-blocks.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nExternBlock ->\n    `unsafe`?[^unsafe-2024] `extern` Abi? `{`\n        InnerAttribute*\n        ExternalItem*\n    `}`\n\nExternalItem ->\n    OuterAttribute* (\n        MacroInvocationSemi\n      | Visibility? StaticItem\n      | Visibility? Function\n    )\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with AVX2 Target Feature in Rust\nDESCRIPTION: This snippet demonstrates how to use the 'target_feature' attribute to enable the AVX2 (Advanced Vector Extensions 2) feature for a specific function. This allows the function to use AVX2 instructions when compiled for compatible platforms.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/codegen.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(target_feature = \"avx2\")]\n#[target_feature(enable = \"avx2\")]\nfn foo_avx2() {}\n```\n\n----------------------------------------\n\nTITLE: Higher-Ranked Lifetimes Example\nDESCRIPTION: This snippet provides an example of a struct that employs higher-ranked lifetimes using the `where` clause feature in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/generics.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nstruct A<T>\nwhere\n    T: Iterator,            // Could use A<T: Iterator> instead\n    T::Item: Copy,          // Bound on an associated type\n    String: PartialEq<T>,   // Bound on `String`, using the type parameter\n    i32: Default,           // Allowed, but not useful\n{\n    f: T,\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Raw Pointer Type Grammar Syntax in Rust\nDESCRIPTION: Grammar definition for raw pointer types in Rust, showing how they are formed with either `mut` or `const` qualifiers followed by a type.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/pointer.md#2025-04-21_snippet_1\n\nLANGUAGE: grammar\nCODE:\n```\nRawPointerType -> `*` ( `mut` | `const` ) TypeNoBounds\n```\n\n----------------------------------------\n\nTITLE: Unresolved Lifetime Elision Error in Rust Const Function\nDESCRIPTION: This snippet demonstrates a compile-time error arising from insufficient information to bound the return reference lifetime in a const function, relative to the argument lifetimes. The compiler cannot determine whether the return type is borrowed from the first or second argument.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/lifetime-elision.md#2025-04-21_snippet_7\n\nLANGUAGE: rust,compile_fail\nCODE:\n```\n```rust,compile_fail\n# struct Foo;\n# struct Bar;\n# struct Baz;\n# fn somefunc<'a,'b>(a: &'a Foo, b: &'b Bar) -> &'a Baz {unimplemented!()}\n// There is insufficient information to bound the return reference lifetime\n// relative to the argument lifetimes, so this is an error.\nconst RESOLVED_STATIC: &dyn Fn(&Foo, &Bar) -> &Baz = &somefunc;\n//                                            ^\n// this function's return type contains a borrowed value, but the signature\n// does not say whether it is borrowed from argument 1 or argument 2\n```\n```\n\n----------------------------------------\n\nTITLE: Size Comparison of Enums with Different Representations in Rust\nDESCRIPTION: Compares the sizes of enums with different representations (repr(C), repr(C, u8), repr(C, u16)) to illustrate how primitive representations can affect enum sizes.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/type-layout.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(C)]\nenum EnumC {\n    Variant0(u8),\n    Variant1,\n}\n\n#[repr(C, u8)]\nenum Enum8 {\n    Variant0(u8),\n    Variant1,\n}\n\n#[repr(C, u16)]\nenum Enum16 {\n    Variant0(u8),\n    Variant1,\n}\n\n// The size of the C representation is platform dependent\nassert_eq!(std::mem::size_of::<EnumC>(), 8);\n// One byte for the discriminant and one byte for the value in Enum8::Variant0\nassert_eq!(std::mem::size_of::<Enum8>(), 2);\n// Two bytes for the discriminant and one byte for the value in Enum16::Variant0\n// plus one byte of padding.\nassert_eq!(std::mem::size_of::<Enum16>(), 4);\n```\n\n----------------------------------------\n\nTITLE: Using Lint Groups in Rust\nDESCRIPTION: This snippet demonstrates how to use named lint groups to adjust the level of related lints together, and how individual lints can be overridden within a group.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/diagnostics.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(unused)]\n#[deny(unused_must_use)]\nfn example() {\n    let x = 1;\n    std::fs::remove_file(\"some_file\"); // ERROR: unused `Result` that must be used\n}\n```\n\n----------------------------------------\n\nTITLE: Examples of Extended Temporary Scopes in Rust\nDESCRIPTION: This code block shows various examples where expressions have extended temporary scopes in Rust. It demonstrates different syntactic structures that trigger temporary lifetime extension.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/destructors.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n# fn temp() {}\n# trait Use { fn use_temp(&self) -> &Self { self } }\n# impl Use for () {}\n// The temporary that stores the result of `temp()` lives in the same scope\n// as x in these cases.\nlet x = &temp();\nlet x = &temp() as &dyn Send;\nlet x = (&*&temp(),);\nlet x = { [Some { 0: &temp(), }] };\nlet ref x = temp();\nlet ref x = *&temp();\n# x;\n```\n\n----------------------------------------\n\nTITLE: Reference Pattern Grammar and Examples\nDESCRIPTION: Grammar definition and examples showing how reference patterns work in Rust with pointer dereferencing.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_15\n\nLANGUAGE: grammar\nCODE:\n```\nReferencePattern -> (`&`|`&&`) `mut`? PatternWithoutRange\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet int_reference = &3;\n\nlet a = match *int_reference { 0 => \"zero\", _ => \"some\" };\nlet b = match int_reference { &0 => \"zero\", _ => \"some\" };\n\nassert_eq!(a, b);\n```\n\n----------------------------------------\n\nTITLE: Specifying Crate Type as Library in Rust\nDESCRIPTION: Shows how to specify a crate type as a library using either a command-line flag or a crate attribute. This produces a Rust library in the compiler-recommended style.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/linkage.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n--crate-type=lib\n```\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_type = \"lib\"]\n```\n\n----------------------------------------\n\nTITLE: Late Output Operands in Rust Inline Assembly\nDESCRIPTION: Illustrates the use of late output operands in Rust's inline assembly, which allows register reuse and is useful when the output doesn't depend on input values.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\nlet x: i64;\nunsafe { core::arch::asm!(\"mov {}, 5\", lateout(reg) x); }\nassert_eq!(x, 5)\n```\n\n----------------------------------------\n\nTITLE: Precise Capture of Box Contents in Non-Move Rust Closures\nDESCRIPTION: Illustrates how the contents of a Box are precisely captured in a non-move closure when not moved, contrasting with other Deref implementations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nstruct S(String);\n\nlet b = Box::new(S(String::new()));\nlet c_box = || {\n    let x = &(*b).0; // captures `(*b).0` by ImmBorrow\n};\nc_box();\n\n// Contrast `Box` with another type that implements Deref:\nlet r = std::rc::Rc::new(S(String::new()));\nlet c_rc = || {\n    let x = &(*r).0; // captures `r` by ImmBorrow\n};\nc_rc();\n```\n\n----------------------------------------\n\nTITLE: Specifying Crate Type as C-Compatible Dynamic Library in Rust\nDESCRIPTION: Shows how to specify a crate type as a C-compatible dynamic system library using either a command-line flag or a crate attribute. This is used for creating libraries loadable from other languages.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/linkage.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n--crate-type=cdylib\n```\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_type = \"cdylib\"]\n```\n\n----------------------------------------\n\nTITLE: Using Path Attributes for Inline Modules in Rust\nDESCRIPTION: This snippet illustrates the use of path attributes to define an inline module called `thread` in Rust. The inner module `local_data` is specified to be loaded from a relative file path. The example highlights how inline modules can influence file loading based on their location.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/modules.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[path = \"thread_files\"]\nmod thread {\n    // Load the `local_data` module from `thread_files/tls.rs` relative to\n    // this source file's directory.\n    #[path = \"tls.rs\"]\n    mod local_data;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Slice Type Syntax in Rust\nDESCRIPTION: Grammar specification for slice types in Rust, showing that a slice type is written as a type enclosed in square brackets.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/slice.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nSliceType -> `[` Type `]`\n```\n\n----------------------------------------\n\nTITLE: Using the 'link_section' attribute in Rust\nDESCRIPTION: Demonstrates using the #[unsafe(link_section)] attribute to specify the section in the object file where a static variable's content will be placed.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/abi.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[unsafe(no_mangle)]\n#[unsafe(link_section = \".example_section\")]\npub static VAR1: u32 = 1;\n```\n\n----------------------------------------\n\nTITLE: Using the 'used' attribute in Rust\nDESCRIPTION: Demonstrates how the #[used] attribute forces the compiler to keep static items in the output object file even if they're unused. Contrasts with variables that are removed when unused.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/abi.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// foo.rs\n\n// This is kept because of `#[used]`:\n#[used]\nstatic FOO: u32 = 0;\n\n// This is removable because it is unused:\n#[allow(dead_code)]\nstatic BAR: u32 = 0;\n\n// This is kept because it is publicly reachable:\npub static BAZ: u32 = 0;\n\n// This is kept because it is referenced by a public, reachable function:\nstatic QUUX: u32 = 0;\n\npub fn quux() -> &'static u32 {\n    &QUUX\n}\n\n// This is removable because it is referenced by a private, unused (dead) function:\nstatic CORGE: u32 = 0;\n\n#[allow(dead_code)]\nfn corge() -> &'static u32 {\n    &CORGE\n}\n```\n\n----------------------------------------\n\nTITLE: Container Trait Example with Associated Types in Rust\nDESCRIPTION: Shows how associated types can be used in method signatures within a trait. Defines a Container trait with an associated type E representing the element type.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\ntrait Container {\n    type E;\n    fn empty() -> Self;\n    fn insert(&mut self, elem: Self::E);\n}\n```\n\n----------------------------------------\n\nTITLE: Async Closure Trait Implementation in Rust\nDESCRIPTION: Demonstrates the restrictions on FnMut and Fn trait implementations for async closures based on their capturing behavior.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\nfn takes_callback<Fut: Future>(c: impl FnMut() -> Fut) {}\n\nfn f() {\n    let mut x = 1i32;\n    let c = async || {\n        x = 2;  // x captured with MutBorrow\n    };\n    takes_callback(c);  // ERROR: async closure does not implement `FnMut`\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn takes_callback<Fut: Future>(c: impl Fn() -> Fut) {}\n\nfn f() {\n    let x = &1i32;\n    let c = async move || {\n        let a = x + 2;  // x captured ByValue\n    };\n    takes_callback(c);  // ERROR: async closure does not implement `Fn`\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn takes_callback<Fut: Future>(c: impl Fn() -> Fut) {}\n\nfn f() {\n    let x = &1i32;\n    let c = async move || {\n        let a = *x + 2;\n    };\n    takes_callback(c);  // OK: implements `Fn`\n}\n```\n\n----------------------------------------\n\nTITLE: Temporary Scope and Drop Order Examples\nDESCRIPTION: Demonstrates the various temporary scopes in Rust and when temporaries are dropped. Shows behavior in conditions, match expressions, lazy boolean operations, and if-let expressions with edition-specific rules.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/destructors.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# struct PrintOnDrop(&'static str);\n# impl Drop for PrintOnDrop {\n#     fn drop(&mut self) {\n#         println!(\"drop({})\", self.0);\n#     }\n# }\nlet local_var = PrintOnDrop(\"local var\");\n\n// Dropped once the condition has been evaluated\nif PrintOnDrop(\"If condition\").0 == \"If condition\" {\n    // Dropped at the end of the block\n    PrintOnDrop(\"If body\").0\n} else {\n    unreachable!()\n};\n\nif let \"if let scrutinee\" = PrintOnDrop(\"if let scrutinee\").0 {\n    PrintOnDrop(\"if let consequent\").0\n    // `if let consequent` dropped here\n}\n// `if let scrutinee` is dropped here\nelse {\n    PrintOnDrop(\"if let else\").0\n    // `if let else` dropped here\n};\n\n// Dropped before the first ||\n(PrintOnDrop(\"first operand\").0 == \"\"\n// Dropped before the )\n|| PrintOnDrop(\"second operand\").0 == \"\")\n// Dropped before the ;\n|| PrintOnDrop(\"third operand\").0 == \"\";\n\n// Scrutinee is dropped at the end of the function, before local variables\n// (because this is the tail expression of the function body block).\nmatch PrintOnDrop(\"Matched value in final expression\") {\n    // Dropped once the condition has been evaluated\n    _ if PrintOnDrop(\"guard condition\").0 == \"\" => (),\n    _ => (),\n}\n```\n\n----------------------------------------\n\nTITLE: Field Expression Grammar Definition\nDESCRIPTION: Formal grammar definition for field access expressions in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/field-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nFieldExpression -> Expression `.` IDENTIFIER\n```\n\n----------------------------------------\n\nTITLE: Basic Rust Literal Examples\nDESCRIPTION: Demonstrates basic usage of string, character, and integer literals in Rust, showing the different types of literals and their type associations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/literal-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n\"hello\";   // string type\n'5';       // character type\n5;         // integer type\n```\n\n----------------------------------------\n\nTITLE: Using inout-arrow to Move Values to Different Places - Rust\nDESCRIPTION: This snippet illustrates the `inout` with an arrow operator, which allows for the movement of an initial value into a register, and then captures the output into another variable via an output expression.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(target_arch = \"x86_64\")] {\nlet x: i64;\n// `inout` can also move values to different places\nunsafe { core::arch::asm!(\"inc {}\", inout(reg) 4u64=>x); }\nassert_eq!(x, 5);\n# }\n```\n\n----------------------------------------\n\nTITLE: Examples of Expression Statements in Rust\nDESCRIPTION: This Rust code provides examples of expression statements, illustrating how they operate, including scenarios where trailing semicolons can be omitted, and the types of expressions involved.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/statements.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# let mut v = vec![1, 2, 3];\nv.pop();          // Ignore the element returned from pop\nif v.is_empty() {\n    v.push(5);\n} else {\n    v.remove(0);\n}                 // Semicolon can be omitted.\n[1];              // Separate expression statement, not an indexing expression.\n```\n\n----------------------------------------\n\nTITLE: Generic Parameter Scoping in Rust\nDESCRIPTION: These examples demonstrate the scoping rules for generic parameters in Rust, showing how parameters can be referenced before they are declared in the generic parameter list.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/names/scopes.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// The 'b bound is referenced before it is declared.\nfn params_scope<'a: 'b, 'b>() {}\n\n# trait SomeTrait<const Z: usize> {}\n// The const N is referenced in the trait bound before it is declared.\nfn f<T: SomeTrait<N>, const N: usize>() {}\n```\n\n----------------------------------------\n\nTITLE: Defining Constant Items Syntax in Rust\nDESCRIPTION: The grammar syntax for defining constant items in Rust, specifying the structure including optional identifier, type, and expression.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/constant-items.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nConstantItem ->\\n    `const` ( IDENTIFIER | `_` ) `:` Type ( `=` Expression )? `;`\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Valid Integer Literals in Rust\nDESCRIPTION: This code snippet shows examples of valid integer literals in Rust, including different bases and suffixes.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(overflowing_literals)]\n123;\n123i32;\n123u32;\n123_u32;\n\n0xff;\n0xff_u8;\n0x01_f32; // integer 7986, not floating-point 1.0\n0x01_e3;  // integer 483, not floating-point 1000.0\n\n0o70;\n0o70_i16;\n\n0b1111_1111_1001_0000;\n0b1111_1111_1001_0000i64;\n0b________1;\n\n0usize;\n\n// These are too big for their type, but are accepted as literal expressions.\n128_i8;\n256_u8;\n\n// This is an integer literal, accepted as a floating-point literal expression.\n5f32;\n```\n\n----------------------------------------\n\nTITLE: Target Feature Safety Restrictions in Rust\nDESCRIPTION: Documentation of safety requirements when calling functions with target_feature attributes from contexts without matching features.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/unsafety.md#2025-04-21_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n- Calling a safe function marked with a [`target_feature`][attributes.codegen.target_feature] from a function that does not have a `target_feature` attribute enabling the same features (see [attributes.codegen.target_feature.safety-restrictions]).\n```\n\n----------------------------------------\n\nTITLE: Generic Parameter Shadowing Rules in Rust Functions\nDESCRIPTION: This code demonstrates that items declared within functions are allowed to shadow generic parameter names from the function in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/names/scopes.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn example<'a, T, const N: usize>() {\n    // Items within functions are allowed to shadow generic parameter in scope.\n    fn inner_lifetime<'a>() {} // OK\n    fn inner_type<T>() {} // OK\n    fn inner_const<const N: usize>() {} // OK\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Associated Types in Rust\nDESCRIPTION: Illustrates the syntax forms for declaring associated types in Rust traits. These declarations can include various combinations of parameters, bounds, and where clauses.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\ntype Assoc;\ntype Assoc: Bounds;\ntype Assoc<Params>;\ntype Assoc<Params>: Bounds;\ntype Assoc<Params> where WhereBounds;\ntype Assoc<Params>: Bounds where WhereBounds;\n```\n\n----------------------------------------\n\nTITLE: Grammar Definition for Literal Expressions in Rust\nDESCRIPTION: Defines the grammar syntax for various types of literal expressions in Rust, including character literals, string literals, byte literals, and numeric literals.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/literal-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nLiteralExpression ->\n      CHAR_LITERAL\n    | STRING_LITERAL\n    | RAW_STRING_LITERAL\n    | BYTE_LITERAL\n    | BYTE_STRING_LITERAL\n    | RAW_BYTE_STRING_LITERAL\n    | C_STRING_LITERAL\n    | RAW_C_STRING_LITERAL\n    | INTEGER_LITERAL\n    | FLOAT_LITERAL\n    | `true`\n    | `false`\n```\n\n----------------------------------------\n\nTITLE: Extern Function Definition in Rust\nDESCRIPTION: This snippet presents the syntax for an `extern` function in Rust, which specifies how a function can be called with a specific ABI.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/functions.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nextern \"ABI\" fn foo() { /* ... */ }\n\n```\n\n----------------------------------------\n\nTITLE: Using Label in Inline Assembly - Rust\nDESCRIPTION: This snippet illustrates the use of the `label` operand to define a block of code within inline assembly. It demonstrates how to jump to a labeled section within the assembly.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(target_arch = \"x86_64\")]\nunsafe {\n    core::arch::asm!(\"jmp {}\", label {\n        println!(\"Hello from inline assembly label\");\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UseDeclaration Grammar in Rust\nDESCRIPTION: This code snippet defines the grammar for use declarations in Rust. It outlines the structure of UseDeclaration and UseTree, which include the use of the '::' separator and various forms such as wildcards and aliases. Understanding this grammar is essential for correctly implementing use declarations in Rust code.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/use-declarations.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nUseDeclaration -> `use` UseTree `;`\n\nUseTree ->\n      (SimplePath? `::`)? `*`\n    | (SimplePath? `::`)? `{` (UseTree ( `,`  UseTree )* `,`?)? `}`\n    | SimplePath ( `as` ( IDENTIFIER | `_` ) )?\n```\n\n----------------------------------------\n\nTITLE: Defining Lazy Boolean Operators in Rust\nDESCRIPTION: This snippet outlines the lazy boolean operators, `||` (logical 'or') and `&&` (logical 'and'), including their syntax and how their evaluation differs from standard logical operators.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_17\n\nLANGUAGE: grammar,expressions\nCODE:\n```\nLazyBooleanExpression ->\n      Expression `||` Expression\n    | Expression `&&` Expression\n```\n\n----------------------------------------\n\nTITLE: Using Crate in Paths Example in Rust\nDESCRIPTION: Shows how `crate` keyword in paths resolves them relative to the current crate and highlights how it is used in module references to access or call items defined in the crate root.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/paths.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {}\nmod a {\n    fn bar() {\n        crate::foo();\n    }\n}\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: C String Literal Examples\nDESCRIPTION: Demonstrates various C string literal syntax including Unicode characters and raw strings.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nc\"foo\"; cr\"foo\";                     // foo\nc\"\\\"foo\\\"\"; cr#\"\"foo\"\"#;             // \"foo\"\n\nc\"foo #\\\"# bar\";\ncr##\"foo #\"# bar\"##;                 // foo #\"# bar\n\nc\"\\x52\"; c\"R\"; cr\"R\";                // R\nc\"\\\\x52\"; cr\"\\x52\";                  // \\x52\n```\n\n----------------------------------------\n\nTITLE: Using global_asm! Macro for Global Assembly in Rust\nDESCRIPTION: Illustrates the use of the global_asm! macro to embed assembly code at the global scope in Rust. This allows for writing entire functions in assembly.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\ncore::arch::global_asm!(\"/* {} */\", const 0);\n```\n\n----------------------------------------\n\nTITLE: Examples of Non-Extended Temporary Scopes in Rust\nDESCRIPTION: This code snippet illustrates cases where expressions don't have extended temporary scopes in Rust. These examples result in errors due to the temporary values being dropped at the end of the let statement.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/destructors.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n# fn temp() {}\n# trait Use { fn use_temp(&self) -> &Self { self } }\n# impl Use for () {}\n// The temporary that stores the result of `temp()` only lives until the\n// end of the let statement in these cases.\n\nlet x = Some(&temp());         // ERROR\nlet x = (&temp()).use_temp();  // ERROR\n# x;\n```\n\n----------------------------------------\n\nTITLE: Raw Pointer Creation Example\nDESCRIPTION: Demonstrates creating raw pointers for unaligned access in packed structs.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(packed)]\nstruct Packed {\n    f1: u8,\n    f2: u16,\n}\n\nlet packed = Packed { f1: 1, f2: 2 };\n// `&packed.f2` would create an unaligned reference, and thus be undefined behavior!\nlet raw_f2 = &raw const packed.f2;\nassert_eq!(unsafe { raw_f2.read_unaligned() }, 2);\n```\n\n----------------------------------------\n\nTITLE: Using Wrapping Arithmetic in Rust\nDESCRIPTION: This snippet demonstrates the use of explicit wrapping arithmetic in Rust using the inherent methods provided by integral types, such as i32::wrapping_add for two's complement, wrapping addition.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/behavior-not-considered-unsafe.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ni32::wrapping_add\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Evaluation Order in Rust\nDESCRIPTION: Illustrates the evaluation order of operands in Rust expressions using an iterator example. This snippet shows that method calls on the same object are evaluated from left to right as they appear in the source code.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet mut one_two = vec![1, 2].into_iter();\nassert_eq!(\n    (1, 2),\n    (one_two.next().unwrap(), one_two.next().unwrap())\n);\n```\n\n----------------------------------------\n\nTITLE: Path Expression Grammar Definition\nDESCRIPTION: Formal grammar specification for path expressions in Rust, defining the syntax for both regular path expressions and qualified path expressions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/path-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nPathExpression ->\n      PathInExpression\n    | QualifiedPathInExpression\n```\n\n----------------------------------------\n\nTITLE: Where Clauses Syntax\nDESCRIPTION: This snippet outlines the syntax for defining where clauses in Rust, used to specify bounds on type and lifetime parameters.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/generics.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n```grammar,items\nWhereClause -> `where` ( WhereClauseItem `,` )* WhereClauseItem ?\n\nWhereClauseItem ->\n      LifetimeWhereClauseItem\n    | TypeBoundWhereClauseItem\n\nLifetimeWhereClauseItem -> Lifetime `:` LifetimeBounds\n\nTypeBoundWhereClauseItem -> ForLifetimes? Type `:` TypeParamBounds?\n```\n```\n\n----------------------------------------\n\nTITLE: Calling External Functions in Inline Assembly (x86_64)\nDESCRIPTION: Example of calling an external function from inline assembly using the sym operand and clobber_abi to inform the compiler about affected registers.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\nextern \"C\" fn foo() -> i32 { 0 }\n\nlet z: i32;\n// To call a function, we have to inform the compiler that we're clobbering\n// callee saved registers\nunsafe { core::arch::asm!(\"call {}\", sym foo, out(\"rax\") z, clobber_abi(\"C\")); }\nassert_eq!(z, 0);\n```\n\n----------------------------------------\n\nTITLE: Shared Prefix Capture Mode Resolution in Rust Closures\nDESCRIPTION: Example showing how multiple capture paths with shared ancestors resolve to the highest capture mode among them, following the order ImmBorrow < UniqueImmBorrow < MutBorrow < ByValue.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// In this example, there are three different capture paths with a shared ancestor:\n# fn move_value<T>(_: T){}\nlet s = String::from(\"S\");\nlet t = (s, String::from(\"T\"));\nlet mut u = (t, String::from(\"U\"));\n\nlet c = || {\n    println!(\"{:?}\", u); // u captured by ImmBorrow\n    u.1.truncate(0); // u.0 captured by MutBorrow\n    move_value(u.0.0); // u.0.0 captured by ByValue\n};\nc();\n```\n\n----------------------------------------\n\nTITLE: Examples of Floating-Point Literal Expressions in Rust\nDESCRIPTION: Demonstrates various forms of floating-point literals in Rust, including different notations and explicit type suffixes. Shows how literals can be typed as f32 or f64 through suffixes or type inference.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/literal-expr.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n123.0f64;        // type f64\n0.1f64;          // type f64\n0.1f32;          // type f32\n12E+99_f64;      // type f64\n5f32;            // type f32\nlet x: f64 = 2.; // type f64\n```\n\n----------------------------------------\n\nTITLE: Using Underscore Imports to Avoid Name Conflicts in Rust\nDESCRIPTION: This example demonstrates importing a trait with underscore syntax to avoid name conflicts. A trait called Zoo is imported as _ which allows using its methods on types without causing conflicts with a local struct that's also named Zoo.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/use-declarations.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n    pub trait Zoo {\n        fn zoo(&self) {}\n    }\n\n    impl<T> Zoo for T {}\n}\n\nuse self::foo::Zoo as _;\nstruct Zoo;  // Underscore import avoids name conflict with this item.\n\nfn main() {\n    let z = Zoo;\n    z.zoo();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Block Expression Grammar in Rust\nDESCRIPTION: Specifies the grammar for block expressions in Rust, including statements and inner attributes.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/block-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nBlockExpression ->\n    `{`\n        InnerAttribute*\n        Statements?\n    `}`\n\nStatements ->\n      Statement+\n    | Statement+ ExpressionWithoutBlock\n    | ExpressionWithoutBlock\n```\n\n----------------------------------------\n\nTITLE: Subtyping with Higher-Ranked Lifetimes in Function Pointers and Trait Objects\nDESCRIPTION: Illustrates subtyping relations involving higher-ranked lifetimes with function pointers and trait objects. It requires understanding of Rust's lifetime substitution mechanics. By substituting higher-ranked lifetimes, different lifetime constraints are observed in function pointers and trait objects. The examples manipulate lifetimes to show valid subtype and supertype relations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/subtyping.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Here 'a is substituted for 'static\nlet subtype: &(for<'a> fn(&'a i32) -> &'a i32) = &((|x| x) as fn(&_) -> &_);\nlet supertype: &(fn(&'static i32) -> &'static i32) = subtype;\n\n// This works similarly for trait objects\nlet subtype: &(dyn for<'a> Fn(&'a i32) -> &'a i32) = &|x| x;\nlet supertype: &(dyn Fn(&'static i32) -> &'static i32) = subtype;\n\n// We can also substitute one higher-ranked lifetime for another\nlet subtype: &(for<'a, 'b> fn(&'a i32, &'b i32)) = &((|x, y| {}) as fn(&_, &_));\nlet supertype: &for<'c> fn(&'c i32, &'c i32) = subtype;\n```\n\n----------------------------------------\n\nTITLE: Float Narrowing Cast in Rust\nDESCRIPTION: Demonstrates f64 to f32 casting with rounding and special value handling.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\nassert_eq!(1_234.5f64 as f32, 1_234.5f32);\nassert_eq!(1_234_567_891.123f64 as f32, 1_234_567_890f32, \"Rounded\");\nassert_eq!(std::f64::INFINITY as f32, std::f32::INFINITY);\nassert!((std::f64::NAN as f32).is_nan());\n```\n\n----------------------------------------\n\nTITLE: u8 to char Casting in Rust\nDESCRIPTION: Shows casting from u8 to char using Unicode code points.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_30\n\nLANGUAGE: rust\nCODE:\n```\nassert_eq!(65u8 as char, 'A');\nassert_eq!(214u8 as char, 'Ö');\n```\n\n----------------------------------------\n\nTITLE: Dropping Fields of a Tuple Captured by a Closure\nDESCRIPTION: This code demonstrates how a closure captures a field of a tuple by value, causing the captured field to be dropped when the closure is dropped. The remaining fields of the tuple are dropped later, demonstrating that disjoint fields of composite types can be dropped at different times when captured by a closure.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n{\n    let tuple =\n      (String::from(\"foo\"), String::from(\"bar\")); // --+\n    { //                                               |\n        let c = || { // ----------------------------+  |\n            // tuple.0 is captured into the closure |  |\n            drop(tuple.0); //                       |  |\n        }; //                                       |  |\n    } // 'c' and 'tuple.0' dropped here ------------+  |\n} // tuple.1 dropped here -----------------------------+\n```\n```\n\n----------------------------------------\n\nTITLE: Match Guard Side Effects in Rust\nDESCRIPTION: Demonstrates how match guards with side effects can execute multiple times when used with the | operator.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/match-expr.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# use std::cell::Cell;\nlet i : Cell<i32> = Cell::new(0);\nmatch 1 {\n    1 | _ if { i.set(i.get() + 1); false } => {}\n    _ => {}\n}\nassert_eq!(i.get(), 2);\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Glob Imports for the Same Item in Rust\nDESCRIPTION: This code demonstrates that multiple glob imports are allowed to import the same name if they refer to the same item (possibly through re-exports). The visibility of the resulting name is the maximum visibility of all the imports.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/use-declarations.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n    pub struct Qux;\n}\n\nmod bar {\n    pub use super::foo::Qux;\n}\n\n// These both import the same `Qux`. The visibility of `Qux`\n// is `pub` because that is the maximum visibility between\n// these two `use` declarations.\npub use bar::*;\nuse foo::*;\n\nfn main() {\n    let _: Qux = Qux;\n}\n```\n\n----------------------------------------\n\nTITLE: Template String Arguments in Rust Inline Assembly\nDESCRIPTION: Demonstrates different ways of using template string arguments in Rust's inline assembly, including positional, indexed, and named arguments.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nlet x: i64;\nlet y: i64;\nlet z: i64;\n// This\nunsafe { core::arch::asm!(\"mov {}, {}\", out(reg) x, in(reg) 5); }\n// ... this\nunsafe { core::arch::asm!(\"mov {0}, {1}\", out(reg) y, in(reg) 5); }\n// ... and this\nunsafe { core::arch::asm!(\"mov {out}, {in}\", out = out(reg) z, in = in(reg) 5); }\n// all have the same behavior\nassert_eq!(x, y);\nassert_eq!(y, z);\n```\n\n----------------------------------------\n\nTITLE: Creating Should-Panic Test with Expected Message in Rust\nDESCRIPTION: Shows how to create a test that expects a panic with a specific error message. The test will only pass if it panics and the panic message contains the expected string.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/testing.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[test]\n#[should_panic(expected = \"values don't match\")]\nfn mytest() {\n    assert_eq!(1, 2, \"values don't match\");\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Crate Type as Procedural Macro in Rust\nDESCRIPTION: Demonstrates how to specify a crate type as a procedural macro using either a command-line flag or a crate attribute. This is used for creating crates that export procedural macros.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/linkage.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n--crate-type=proc-macro\n```\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_type = \"proc-macro\"]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Valid Floating-Point Literals in Rust\nDESCRIPTION: This code snippet shows examples of valid floating-point literals in Rust, including different representations and suffixes.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n123.0f64;\n0.1f64;\n0.1f32;\n12E+99_f64;\nlet x: f64 = 2.;\n```\n\n----------------------------------------\n\nTITLE: Defining Struct Syntax in Rust Grammar\nDESCRIPTION: Formal grammar definition for struct syntax in Rust, including StructStruct, TupleStruct, and their components.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/structs.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nStruct ->\n      StructStruct\n    | TupleStruct\n\nStructStruct ->\n    `struct` IDENTIFIER GenericParams? WhereClause? ( `{` StructFields? `}` | `;` )\n\nTupleStruct ->\n    `struct` IDENTIFIER GenericParams? `(` TupleFields? `)` WhereClause? `;`\n\nStructFields -> StructField (`,` StructField)* `,`?\n\nStructField -> OuterAttribute* Visibility? IDENTIFIER `:` Type\n\nTupleFields -> TupleField (`,` TupleField)* `,`?\n\nTupleField -> OuterAttribute* Visibility? Type\n```\n\n----------------------------------------\n\nTITLE: Trait Object Lifetime Elision with Innermost Type in Rust\nDESCRIPTION: This snippet illustrates how the innermost object sets the lifetime bound in Rust. Even when nested within other references or containers, the innermost trait object's lifetime is used to determine the default bound.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/lifetime-elision.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n// For the following trait...\ntrait Bar<'a>: 'a { }\n\n// ...these two are the same:\ntype T1<'a> = Box<dyn Bar<'a>>;\ntype T2<'a> = Box<dyn Bar<'a> + 'a>;\n\n// ...and so are these:\nimpl<'a> dyn Bar<'a> {}\nimpl<'a> dyn Bar<'a> + 'a {}\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Assertions in Rust\nDESCRIPTION: This snippet shows the usage of debug_assert! for enabling dynamic checks that panic on overflow in non-optimized builds.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/behavior-not-considered-unsafe.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ndebug_assert!\n```\n\n----------------------------------------\n\nTITLE: Dereference Operator Example\nDESCRIPTION: Demonstrates usage of the dereference operator with different pointer types.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet x = &7;\nassert_eq!(*x, 7);\nlet y = &mut 9;\n*y = 11;\nassert_eq!(*y, 11);\n```\n\n----------------------------------------\n\nTITLE: Using Token Stream Attribute Macro Examples in Rust\nDESCRIPTION: Demonstrates various usage patterns of the show_streams attribute macro, including basic function decoration, attribute with input parameters, and different token formats.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/procedural-macros.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n// src/lib.rs\nextern crate my_macro;\n\nuse my_macro::show_streams;\n\n// Example: Basic function\n#[show_streams]\nfn invoke1() {}\n// out: attr: \"\"\n// out: item: \"fn invoke1() {}\"\n\n// Example: Attribute with input\n#[show_streams(bar)]\nfn invoke2() {}\n// out: attr: \"bar\"\n// out: item: \"fn invoke2() {}\"\n\n// Example: Multiple tokens in the input\n#[show_streams(multiple => tokens)]\nfn invoke3() {}\n// out: attr: \"multiple => tokens\"\n// out: item: \"fn invoke3() {}\"\n\n// Example:\n#[show_streams { delimiters }]\nfn invoke4() {}\n// out: attr: \"delimiters\"\n// out: item: \"fn invoke4() {}\"\n```\n\n----------------------------------------\n\nTITLE: Partial Capture with Struct Destructuring in Rust Closures\nDESCRIPTION: Example demonstrating how Rust closures selectively capture struct fields during destructuring, moving only the specific fields that are actually used.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nstruct Example {\n    f1: String,\n    f2: String,\n}\n\nlet e = Example {\n    f1: String::from(\"first\"),\n    f2: String::from(\"second\"),\n};\nlet c = || {\n    let Example { f2, .. } = e; // captures `e.f2` ByValue\n};\n// Field f2 cannot be accessed since it is moved into the closure.\n// Field f1 is still accessible.\nprintln!(\"{:?}\", e.f1);\nc();\n```\n\n----------------------------------------\n\nTITLE: String Continuation with Line Breaks in Rust\nDESCRIPTION: Demonstrates string continuation escape sequences in Rust, showing how backslash followed by newline allows a string to span multiple lines while skipping whitespace and newlines.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/literal-expr.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet a = \"foobar\";\nlet b = \"foo\\\n         bar\";\nlet c = \"foo\\\n\n     bar\";\n\nassert_eq!(a, b);\nassert_eq!(b, c);\n```\n\n----------------------------------------\n\nTITLE: Accessing Enum Discriminants via Casting in Rust\nDESCRIPTION: Shows how to access discriminant values of unit-only enums through numeric casting.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/enumerations.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nenum Enum {\n    Foo,\n    Bar,\n    Baz,\n}\n\nassert_eq!(0, Enum::Foo as isize);\nassert_eq!(1, Enum::Bar as isize);\nassert_eq!(2, Enum::Baz as isize);\n```\n\n----------------------------------------\n\nTITLE: Implementing AsExpression Trait with Do Not Recommend Example\nDESCRIPTION: Demonstrates how the #[diagnostic::do_not_recommend] attribute affects compiler error messages when implementing the AsExpression trait. Shows the difference in error messages with and without the attribute when attempting to use incompatible types.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/diagnostics.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nimpl<T, ST> AsExpression<ST> for T\nwhere\n    T: Expression<SqlType = ST>,\n{\n    type Expression = T;\n}\n```\n\n----------------------------------------\n\nTITLE: Integer Truncation Casting in Rust\nDESCRIPTION: Shows how Rust handles casting from larger integers to smaller integers, demonstrating truncation behavior.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nassert_eq!(42u16 as u8, 42u8);\nassert_eq!(1234u16 as u8, 210u8);\nassert_eq!(0xabcdu16 as u8, 0xcdu8);\n\nassert_eq!(-42i16 as i8, -42i8);\nassert_eq!(1234u16 as i8, -46i8);\nassert_eq!(0xabcdi32 as i8, -51i8);\n```\n\n----------------------------------------\n\nTITLE: Invalid Refutable Patterns in Associated Functions With Body\nDESCRIPTION: Example of invalid parameter patterns in trait functions with bodies. Refutable patterns (patterns that might not match) are not allowed in trait function implementations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/traits.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\ntrait T {\n    fn f1(123: i32) {} // ERROR: pattern is refutable\n    fn f2(Some(x): Option<i32>) {} // ERROR: pattern is refutable\n}\n```\n\n----------------------------------------\n\nTITLE: Required Where Clauses on Generic Associated Types in Rust\nDESCRIPTION: Shows a lending iterator pattern that requires where clauses on the generic associated type. The Item type uses a lifetime parameter with a bound that Self outlives that lifetime.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\ntrait LendingIterator {\n    type Item<'x> where Self: 'x;\n    fn next<'a>(&'a mut self) -> Self::Item<'a>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Tuple Expression Syntax in Rust\nDESCRIPTION: Grammar definition for tuple expressions in Rust, showing the structure of tuple elements.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/tuple-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nTupleExpression -> `(` TupleElements? `)`\n\nTupleElements -> ( Expression `,` )+ Expression?\n```\n\n----------------------------------------\n\nTITLE: Borrow Expression Grammar\nDESCRIPTION: Defines the syntax for borrow expressions including shared, mutable, and raw borrows.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: grammar\nCODE:\n```\nBorrowExpression ->\n      (`&`|`&&`) Expression\n    | (`&`|`&&`) `mut` Expression\n    | (`&`|`&&`) `raw` `const` Expression\n    | (`&`|`&&`) `raw` `mut` Expression\n```\n\n----------------------------------------\n\nTITLE: Defining a Boolean in Rust\nDESCRIPTION: This snippet demonstrates how to declare a variable of type boolean in Rust, initializing it with a literal value of true. It serves as a basic example of using the boolean type in Rust programs.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/boolean.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet b: bool = true;\n```\n\n----------------------------------------\n\nTITLE: Partial Capture with Tuple Destructuring in Rust Closures\nDESCRIPTION: Example showing how Rust closures selectively capture fields when destructuring tuples, capturing only the fields that are actually used and not those matched with rest patterns.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet x = (String::from(\"a\"), String::from(\"b\"));\nlet c = || {\n    let (first, ..) = x;  // captures `x.0` ByValue\n};\n// The first tuple field has been moved into the closure.\n// The second tuple field is still accessible.\nprintln!(\"{:?}\", x.1);\nc();\n```\n\n----------------------------------------\n\nTITLE: Determining Struct Memory Layout using #[repr(C)] in Rust\nDESCRIPTION: This pseudocode snippet describes an algorithm to determine the size and memory alignment of a struct in Rust when it is marked with the #[repr(C)] attribute. The algorithm calculates padding based on field alignments to ensure the struct's size is aligned according to its most-aligned field. The pseudocode is a basic representation and does not handle integer overflow. Memory layout computations in actual code should use the Layout API instead.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/type-layout.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n/// Returns the amount of padding needed after `offset` to ensure that the\n/// following address will be aligned to `alignment`.\nfn padding_needed_for(offset: usize, alignment: usize) -> usize {\n    let misalignment = offset % alignment;\n    if misalignment > 0 {\n        // round up to next multiple of `alignment`\n        alignment - misalignment\n    } else {\n        // already a multiple of `alignment`\n        0\n    }\n}\n\nstruct.alignment = struct.fields().map(|field| field.alignment).max();\n\nlet current_offset = 0;\n\nfor field in struct.fields_in_declaration_order() {\n    // Increase the current offset so that it's a multiple of the alignment\n    // of this field. For the first field, this will always be zero.\n    // The skipped bytes are called padding bytes.\n    current_offset += padding_needed_for(current_offset, field.alignment);\n\n    struct[field].offset = current_offset;\n\n    current_offset += field.size;\n}\n\nstruct.size = current_offset + padding_needed_for(current_offset, struct.alignment);\n```\n\n----------------------------------------\n\nTITLE: Loop Label Shadowing in Rust\nDESCRIPTION: This example shows how loop labels can shadow labels of the same name in outer scopes in Rust, and how references to a label refer to the closest definition.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/names/scopes.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n// Loop label shadowing example.\n'a: for outer in 0..5 {\n    'a: for inner in 0..5 {\n        // This terminates the inner loop, but the outer loop continues to run.\n        break 'a;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Common Grammar Productions in Rust\nDESCRIPTION: This snippet defines common character representations in the grammar, mapping Unicode scalar values to their respective character descriptions. It serves as a foundational setup recognized by the lexer for character processing. The snippet relies on a lexer and DFA for operational context.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/notation.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\n@root CHAR -> <a Unicode scalar value>\n\nNUL -> U+0000\n\nTAB -> U+0009\n\nLF -> U+000A\n\nCR -> U+000D\n```\n\n----------------------------------------\n\nTITLE: Using allow Attribute with Reason in Rust\nDESCRIPTION: This snippet demonstrates using the allow attribute with a reason parameter, which acts as documentation for the reader explaining why a particular lint is being allowed.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/diagnostics.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::path::PathBuf;\n\npub fn get_path() -> PathBuf {\n    // The `reason` parameter on `allow` attributes acts as documentation for the reader.\n    #[allow(unused_mut, reason = \"this is only modified on some platforms\")]\n    let mut file_name = PathBuf::from(\"git\");\n\n    #[cfg(target_os = \"windows\")]\n    file_name.set_extension(\"exe\");\n\n    file_name\n}\n```\n\n----------------------------------------\n\nTITLE: Defining #[repr(C)] Union in Rust\nDESCRIPTION: This Rust code showcases the definition of a #[repr(C)] union type to ensure it has the same memory layout as a C union on the target platform. The example checks the size and alignment of the union using the Rust standard library's memory functions to ensure correctness.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/type-layout.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(C)]\nunion Union {\n    f1: u16,\n    f2: [u8; 4],\n}\n\nassert_eq!(std::mem::size_of::<Union>(), 4);  // From f2\nassert_eq!(std::mem::align_of::<Union>(), 2); // From f1\n\n#[repr(C)]\nunion SizeRoundedUp {\n   a: u32,\n   b: [u16; 3],\n}\n\nassert_eq!(std::mem::size_of::<SizeRoundedUp>(), 8);  // Size of 6 from b,\n                                                      // rounded up to 8 from\n                                                      // alignment of a.\nassert_eq!(std::mem::align_of::<SizeRoundedUp>(), 4); // From a\n```\n\n----------------------------------------\n\nTITLE: Using the Link Attribute\nDESCRIPTION: This snippet shows the syntax for using the `link` attribute within an extern block to specify the name of a native library that the Rust compiler should link with. It includes examples for linking dynamic, static, and framework libraries.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/external-blocks.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[link(name = \"crypto\")]\nunsafe extern {\n    // …\n}\n\n#[link(name = \"CoreFoundation\", kind = \"framework\")]\nunsafe extern {\n    // …\n}\n\n#[link(wasm_import_module = \"foo\")]\nunsafe extern {\n    // …\n}\n```\n\n----------------------------------------\n\nTITLE: Type Expression Grammar Definition in Rust\nDESCRIPTION: Defines the grammar rules for Rust type expressions, showing the syntax for different type forms including bounded types, parenthesized types, trait types, and more.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nType ->\n      TypeNoBounds\n    | ImplTraitType\n    | TraitObjectType\n\nTypeNoBounds ->\n      ParenthesizedType\n    | ImplTraitTypeOneBound\n    | TraitObjectTypeOneBound\n    | TypePath\n    | TupleType\n    | NeverType\n    | RawPointerType\n    | ReferenceType\n    | ArrayType\n    | SliceType\n    | InferredType\n    | QualifiedPathInType\n    | BareFunctionType\n    | MacroInvocation\n```\n\n----------------------------------------\n\nTITLE: Defining Tuple Indexing Expression Syntax in Rust\nDESCRIPTION: Grammar definition for tuple indexing expressions in Rust, showing how to access tuple elements.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/tuple-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: grammar\nCODE:\n```\nTupleIndexingExpression -> Expression `.` TUPLE_INDEX\n```\n\n----------------------------------------\n\nTITLE: Type Alias Grammar\nDESCRIPTION: Defines the grammar for type aliases in Rust, showing the syntax for declaring type aliases with optional generic parameters, type parameter bounds, and where clauses.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/type-aliases.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\n\"TypeAlias ->\n    `type` IDENTIFIER GenericParams? ( `:` TypeParamBounds )?\n        WhereClause?\n        ( `=` Type WhereClause?)? `;`\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lint Groups and Expectations in Rust\nDESCRIPTION: This example shows how lint groups work and how individual lints within a group are expected. It also demonstrates the behavior of multiple lint expectations in a single attribute.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/diagnostics.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n#[expect(unused)]\npub fn thoughts() {\n    let unused = \"I'm running out of examples\";\n}\n\npub fn another_example() {\n    #[expect(unused_mut, unused_variables)]\n    let mut link = \"https://www.rust-lang.org/\";\n\n    println!(\"Welcome to our community: {link}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using the 'export_name' attribute in Rust\nDESCRIPTION: Shows how to use the #[unsafe(export_name)] attribute to specify a custom name for an exported symbol. This attribute is unsafe as it could lead to symbol collisions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/abi.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[unsafe(export_name = \"exported_symbol_name\")]\npub fn name_in_rust() { }\n```\n\n----------------------------------------\n\nTITLE: Using inlateout for Late Output of Registers - Rust\nDESCRIPTION: This example demonstrates the `inlateout` operand, which is similar to `inout` but allows the register allocator to reuse registers. This can be useful when the initial value of the input is known to equal the value written last.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(target_arch = \"x86_64\")] {\nlet mut x: i64 = 4;\n// `inlateout` is `inout` using `lateout`\nunsafe { core::arch::asm!(\"inc {}\", inlateout(reg) x); }\nassert_eq!(x, 5);\n# }\n```\n\n----------------------------------------\n\nTITLE: Using Compound Assignments with Primitive Types in Rust\nDESCRIPTION: Shows the use of compound assignment expressions in Rust with primitive types. The example illustrates increasing a mutable integer variable by one and asserting the result. For primitive types, the right operand is evaluated before the left one. This requires understanding of Rust's mutability and assert macros.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_35\n\nLANGUAGE: rust\nCODE:\n```\nlet mut x = 5;\nx += 1;\nassert!(x == 6);\n```\n\n----------------------------------------\n\nTITLE: Unsafe Trait Implementation in Rust\nDESCRIPTION: Documentation specifying that implementing unsafe traits requires unsafe context in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/unsafety.md#2025-04-21_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n- Implementing an [unsafe trait].\n```\n\n----------------------------------------\n\nTITLE: Implicit Discriminant Assignment in Rust Enums\nDESCRIPTION: Illustrates how discriminant values are implicitly assigned when not explicitly specified for enum variants.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/enumerations.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nenum Foo {\n    Bar,            // 0\n    Baz = 123,      // 123\n    Quux,           // 124\n}\n\nlet baz_discriminant = Foo::Baz as u32;\nassert_eq!(baz_discriminant, 123);\n```\n\n----------------------------------------\n\nTITLE: Lint Expectation Fulfillment in Rust Functions\nDESCRIPTION: This snippet illustrates how lint expectations are fulfilled or remain unfulfilled based on different lint level modifications within a function scope.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/diagnostics.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[expect(unused_variables)]\nfn select_song() {\n    #[warn(unused_variables)]\n    let song_name = \"Crab Rave\";\n\n    #[allow(unused_variables)]\n    let song_creator = \"Noisestorm\";\n\n    #[expect(unused_variables)]\n    let song_version = \"Monstercat Release\";\n}\n```\n\n----------------------------------------\n\nTITLE: Union Memory Layout Configuration in Rust\nDESCRIPTION: Union memory layout is undefined by default with no guarantee of field positioning. The #[repr(...)] attribute can be used to specify a particular memory layout for the union.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/union.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(C)]\nunion DefinedLayout {\n    // Fields will have a defined layout based on repr attribute\n    field1: Type1,\n    field2: Type2\n}\n```\n\n----------------------------------------\n\nTITLE: Using alloc crate in Rust\nDESCRIPTION: Demonstrates how to bring the alloc crate into scope using an extern crate declaration and use its Rc type.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/names/preludes.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nextern crate alloc;\nuse alloc::rc::Rc;\n```\n\n----------------------------------------\n\nTITLE: Const Parameter Restrictions\nDESCRIPTION: This snippet describes the restrictions on using const parameters in Rust, highlighting contexts where they cannot be combined with other expressions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/generics.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n```rust,compile_fail\n// Examples where const parameters may not be used.\n\n// Not allowed to combine in other expressions in types, such as the\n// arithmetic expression in the return type here.\nfn bad_function<const N: usize>() -> [u8; {N + 1}] {\n    // Similarly not allowed for array repeat expressions.\n    [1; {N + 1}]\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Pattern Grammar Definition in Rust\nDESCRIPTION: Formal grammar specification for pattern matching syntax in Rust, defining the structure and types of patterns that can be used in pattern matching expressions\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nPattern -> `|`? PatternNoTopAlt  ( `|` PatternNoTopAlt )*\n\nPatternNoTopAlt ->\n      PatternWithoutRange\n    | RangePattern\n\nPatternWithoutRange ->\n      LiteralPattern\n    | IdentifierPattern\n    | WildcardPattern\n    | RestPattern\n    | ReferencePattern\n    | StructPattern\n    | TupleStructPattern\n    | TuplePattern\n    | GroupedPattern\n    | SlicePattern\n    | PathPattern\n    | MacroInvocation\n```\n\n----------------------------------------\n\nTITLE: Simple Path Syntax Definition\nDESCRIPTION: Defines the syntax for simple paths in Rust, indicating segments using identifiers and special qualifiers like `super`, `self`, `crate`, and `$crate`. These are commonly used for defining visibility and module references.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/paths.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nSimplePath ->\n    `::`? SimplePathSegment (`::` SimplePathSegment)*\n\nSimplePathSegment ->\n    IDENTIFIER | `super` | `self` | `crate` | `$crate`\n```\n\n----------------------------------------\n\nTITLE: Trait Object Lifetime Elision Error Example in Rust\nDESCRIPTION: This snippet shows an example of a compile-time error caused by ambiguous lifetime bounds when using trait objects in Rust. The error occurs when the lifetime bound for the object type cannot be deduced from the context.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/lifetime-elision.md#2025-04-21_snippet_3\n\nLANGUAGE: rust,compile_fail\nCODE:\n```\n```rust,compile_fail\n// This is an example of an error.\n# trait Foo { }\nstruct TwoBounds<'a, 'b, T: ?Sized + 'a + 'b> {\n    f1: &'a i32,\n    f2: &'b i32,\n    f3: T,\n}\ntype T7<'a, 'b> = TwoBounds<'a, 'b, dyn Foo>;\n//                                  ^^^^^^^\n// Error: the lifetime bound for this object type cannot be deduced from context\n```\n```\n\n----------------------------------------\n\nTITLE: Mixed Move and Reference Bindings\nDESCRIPTION: Demonstrates how to mix move bindings and reference bindings in a single pattern, resulting in a partial move of the matched object.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n# struct Person {\n#    name: String,\n#    age: u8,\n# }\n# let person = Person{ name: String::from(\"John\"), age: 23 };\n// `name` is moved from person and `age` referenced\nlet Person { name, ref age } = person;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Safe and Unsafe Calls to Target-Specific Functions in Rust\nDESCRIPTION: This code snippet illustrates the safety rules for calling functions with target-specific features. It shows when it's safe to call such functions directly and when unsafe blocks are required, based on the caller's context and enabled features.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/codegen.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(target_feature = \"sse2\")] {\n#[target_feature(enable = \"sse\")]\nfn foo_sse() {}\n\nfn bar() {\n    // Calling `foo_sse` here is unsafe, as we must ensure that SSE is\n    // available first, even if `sse` is enabled by default on the target\n    // platform or manually enabled as compiler flags.\n    unsafe {\n        foo_sse();\n    }\n}\n\n#[target_feature(enable = \"sse\")]\nfn bar_sse() {\n    // Calling `foo_sse` here is safe.\n    foo_sse();\n    || foo_sse();\n}\n\n#[target_feature(enable = \"sse2\")]\nfn bar_sse2() {\n    // Calling `foo_sse` here is safe because `sse2` implies `sse`.\n    foo_sse();\n}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Unsafe Block Expression Grammar in Rust\nDESCRIPTION: Specifies the grammar for unsafe block expressions in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/block-expr.md#2025-04-21_snippet_7\n\nLANGUAGE: grammar\nCODE:\n```\nUnsafeBlockExpression -> `unsafe` BlockExpression\n```\n\n----------------------------------------\n\nTITLE: Enum Discriminant Casting in Rust\nDESCRIPTION: Shows how enums are cast to their discriminant values.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\nenum Enum { A, B, C }\nassert_eq!(Enum::A as i32, 0);\nassert_eq!(Enum::B as i32, 1);\nassert_eq!(Enum::C as i32, 2);\n```\n\n----------------------------------------\n\nTITLE: Using the 'warnings' Lint Group in Rust\nDESCRIPTION: This example shows the usage of the special 'warnings' group which includes all lints at the 'warn' level, and how it interacts with other lint attributes regardless of order.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/diagnostics.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n#[deny(warnings)]\n#[warn(unsafe_code)]\nfn example_err() {\n    unsafe { an_unsafe_fn() } // ERROR: usage of `unsafe` block\n}\n```\n\n----------------------------------------\n\nTITLE: Inner Attributes on Functions in Rust\nDESCRIPTION: Demonstrates the use of inner attributes within a function body block in Rust. Inner attributes are placed directly after the opening bracket of the function body, affecting the entire function implementation. This example shows documentation as an inner attribute, which is less common compared to outer attributes.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/functions.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn documented() {\n    #![doc = \"Example\"]\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining cfg_attr Attribute Syntax in Rust\nDESCRIPTION: Specifies the grammar for the cfg_attr attribute in Rust, which is used for conditionally including attributes based on configuration predicates.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/conditional-compilation.md#2025-04-21_snippet_3\n\nLANGUAGE: grammar\nCODE:\n```\nCfgAttrAttribute -> `cfg_attr` `(` ConfigurationPredicate `,` CfgAttrs? `)`\n\nCfgAttrs -> Attr (`,` Attr)* `,`?\n```\n\n----------------------------------------\n\nTITLE: Function Pointer Access with Parentheses in Rust\nDESCRIPTION: Shows how parentheses are used to disambiguate between method calls and function pointer field access in structs.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/grouped-expr.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# struct A {\n#    f: fn() -> &'static str\n# }\n# impl A {\n#    fn f(&self) -> &'static str {\n#        \"The method f\"\n#    }\n# }\n# let a = A{f: || \"The field f\"};\n#\nassert_eq!( a.f (), \"The method f\");\nassert_eq!((a.f)(), \"The field f\");\n```\n\n----------------------------------------\n\nTITLE: Defining Meta Item Attribute Grammar in Rust\nDESCRIPTION: Specifies the grammar for meta item attributes in Rust, including MetaItem, MetaSeq, and MetaItemInner rules.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes.md#2025-04-21_snippet_2\n\nLANGUAGE: grammar\nCODE:\n```\nMetaItem ->\n      SimplePath\n    | SimplePath `=` Expression\n    | SimplePath `(` MetaSeq? `)`\n\nMetaSeq ->\n    MetaItemInner ( `,` MetaItemInner )* `,`?\n\nMetaItemInner ->\n      MetaItem\n    | Expression\n```\n\n----------------------------------------\n\nTITLE: Defining Statement Syntax in Rust Grammar\nDESCRIPTION: This grammar definition specifies the syntax rules for statements in Rust. It outlines the various forms a statement can take, which include Item, LetStatement, ExpressionStatement, and MacroInvocationSemi.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/statements.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nStatement ->\n      `;`\n    | Item\n    | LetStatement\n    | ExpressionStatement\n    | MacroInvocationSemi\n```\n\n----------------------------------------\n\nTITLE: Attempting to Use Reserved Registers in Rust Inline Assembly (x86_64)\nDESCRIPTION: Illustrates the compilation error encountered when trying to use reserved registers such as `bp` in inline assembly for the x86_64 architecture. This demonstrates the inline asm error where the frame pointer is not allowed as an operand.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(target_arch = \"x86_64\")] {\n// bp is reserved\nunsafe { core::arch::asm!(\"\", in(\"bp\") 5i32); }\n// ERROR: invalid register `bp`: the frame pointer cannot be used as an operand for inline asm\n# }\n# #[cfg(not(target_arch = \"x86_64\"))] core::compile_error!(\"Test not supported on this arch\");\n```\n\n----------------------------------------\n\nTITLE: Passing Closure to f (Edition 2018 and Before)\nDESCRIPTION: This snippet shows how a closure, defined as `Closure { rect: rect }`, is passed to a function `f` in Rust Edition 2018 and before.  The closure captures the `rect` variable, which is a mutable reference to a `Rectangle` struct.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\n```rust,ignore\nf(Closure { rect: rect });\n```\n```\n\n----------------------------------------\n\nTITLE: Invalid Function Lifetime Elision in Rust\nDESCRIPTION: This snippet demonstrates examples of invalid lifetime elision in Rust function signatures. It highlights cases where the compiler cannot infer the lifetimes due to missing parameters or ambiguity, resulting in compilation errors.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/lifetime-elision.md#2025-04-21_snippet_1\n\nLANGUAGE: rust,compile_fail\nCODE:\n```\n```rust,compile_fail\n// The following examples show situations where it is not allowed to elide the\n// lifetime parameter.\n\n# trait Example {\n// Cannot infer, because there are no parameters to infer from.\nfn get_str() -> &str;                                 // ILLEGAL\n\n// Cannot infer, ambiguous if it is borrowed from the first or second parameter.\nfn frob(s: &str, t: &str) -> &str;                    // ILLEGAL\n# }\n```\n```\n\n----------------------------------------\n\nTITLE: Overriding Lint Levels in Nested Rust Modules\nDESCRIPTION: This example demonstrates how lint attributes can override previous levels in nested modules, showing the interaction between allow and warn attributes for missing documentation.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/diagnostics.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[warn(missing_docs)]\npub mod m2 {\n    #[allow(missing_docs)]\n    pub mod nested {\n        // Missing documentation is ignored here\n        pub fn undocumented_one() -> i32 { 1 }\n\n        // Missing documentation signals a warning here,\n        // despite the allow above.\n        #[warn(missing_docs)]\n        pub fn undocumented_two() -> i32 { 2 }\n    }\n\n    // Missing documentation signals a warning here\n    pub fn undocumented_too() -> i32 { 3 }\n}\n```\n\n----------------------------------------\n\nTITLE: Using $crate Qualifier in Macros in Rust\nDESCRIPTION: A demonstration of how the $crate qualifier works in macro definitions to reference items from the defining crate. The example shows a macro that references a function defined in the same crate, ensuring it works correctly regardless of where the macro is invoked.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/paths.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\npub fn increment(x: u32) -> u32 {\n    x + 1\n}\n\n#[macro_export]\nmacro_rules! inc {\n    ($x:expr) => ( $crate::increment($x) )\n}\n# fn main() { }\n```\n\n----------------------------------------\n\nTITLE: Using Unsafe Blocks in Rust\nDESCRIPTION: Demonstrates the use of unsafe blocks to perform unsafe operations like raw pointer manipulation.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/block-expr.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nunsafe {\n    let b = [13u8, 17u8];\n    let a = &b[0] as *const u8;\n    assert_eq!(*a, 13);\n    assert_eq!(*a.offset(1), 17);\n}\n\n# unsafe fn an_unsafe_fn() -> i32 { 10 }\nlet a = unsafe { an_unsafe_fn() };\n```\n\n----------------------------------------\n\nTITLE: Using the 'no_mangle' attribute in Rust\nDESCRIPTION: Example of using the #[unsafe(no_mangle)] attribute to disable symbol name mangling. This attribute is unsafe as it could lead to symbol collisions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/abi.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[unsafe(no_mangle)]\nextern \"C\" fn foo() {}\n```\n\n----------------------------------------\n\nTITLE: Conditional Block Attributes for Platform-Specific Behavior in Rust\nDESCRIPTION: This function uses conditional compilation attributes on block expressions to return different values based on the target platform. It returns true for Unix platforms and false for others.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/block-expr.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn is_unix_platform() -> bool {\n    #[cfg(unix)] { true }\n    #[cfg(not(unix))] { false }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Unnamed Constants in Rust\nDESCRIPTION: Example of creating unnamed constants in Rust using an underscore instead of a name, demonstrating how they can be used to avoid naming conflicts.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/constant-items.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nconst _: () =  { struct _SameNameTwice; };\\n\\n// OK although it is the same name as above:\\nconst _: () =  { struct _SameNameTwice; };\n```\n\n----------------------------------------\n\nTITLE: Unsafe Pointer Dereferencing in Rust\nDESCRIPTION: Documentation explaining that dereferencing raw pointers is considered an unsafe operation in Rust that can violate memory safety guarantees.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/unsafety.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- Dereferencing a [raw pointer].\n```\n\n----------------------------------------\n\nTITLE: Defining Common Meta Item Syntax in Rust\nDESCRIPTION: Specifies the grammar for common meta item syntax patterns used in built-in attributes in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes.md#2025-04-21_snippet_3\n\nLANGUAGE: grammar\nCODE:\n```\n@root MetaWord ->\n    IDENTIFIER\n\nMetaNameValueStr ->\n    IDENTIFIER `=` (STRING_LITERAL | RAW_STRING_LITERAL)\n\n@root MetaListPaths ->\n    IDENTIFIER `(` ( SimplePath (`,` SimplePath)* `,`? )? `)`\n\n@root MetaListIdents ->\n    IDENTIFIER `(` ( IDENTIFIER (`,` IDENTIFIER)* `,`? )? `)`\n\n@root MetaListNameValueStr ->\n    IDENTIFIER `(` ( MetaNameValueStr (`,` MetaNameValueStr)* `,`? )? `)`\n```\n\n----------------------------------------\n\nTITLE: Defining Macro Rules Grammar in Rust\nDESCRIPTION: Specifies the grammar for defining macros using macro_rules! in Rust, including syntax for matchers, transcribers, and various macro components.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros-by-example.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nMacroRulesDefinition ->\n    `macro_rules` `!` IDENTIFIER MacroRulesDef\n\nMacroRulesDef ->\n      `(` MacroRules `)` `;`\n    | `[` MacroRules `]` `;`\n    | `{` MacroRules `}`\n\nMacroRules ->\n    MacroRule ( `;` MacroRule )* `;`?\n\nMacroRule ->\n    MacroMatcher `=>` MacroTranscriber\n\nMacroMatcher ->\n      `(` MacroMatch* `)`\n    | `[` MacroMatch* `]`\n    | `{` MacroMatch* `}`\n\nMacroMatch ->\n      Token _except `$` and [delimiters][lex.token.delim]_\n    | MacroMatcher\n    | `$` ( IDENTIFIER_OR_KEYWORD _except `crate`_ | RAW_IDENTIFIER | `_` ) `:` MacroFragSpec\n    | `$` `(` MacroMatch+ `)` MacroRepSep? MacroRepOp\n\nMacroFragSpec ->\n      `block` | `expr` | `expr_2021` | `ident` | `item` | `lifetime` | `literal`\n    | `meta` | `pat` | `pat_param` | `path` | `stmt` | `tt` | `ty` | `vis`\n\nMacroRepSep -> Token _except [delimiters][lex.token.delim] and [MacroRepOp]_\n\nMacroRepOp -> `*` | `+` | `?`\n\nMacroTranscriber -> DelimTokenTree\n```\n\n----------------------------------------\n\nTITLE: Error Message Without Do Not Recommend Attribute\nDESCRIPTION: Shows the compiler error message when attempting to use a string with SelectInt.check() without the do_not_recommend attribute. The message includes potentially confusing information about trait bounds.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/diagnostics.md#2025-04-21_snippet_15\n\nLANGUAGE: text\nCODE:\n```\nerror[E0277]: the trait bound `&str: Expression` is not satisfied\n  --> src/main.rs:53:15\n   |\n53 |     SelectInt.check(\"bar\");\n   |               ^^^^^ the trait `Expression` is not implemented for `&str`\n   |\n   = help: the following other types implement trait `Expression`:\n             Bound<T>\n             SelectInt\nnote: required for `&str` to implement `AsExpression<Integer>`\n  --> src/main.rs:45:13\n   |\n45 | impl<T, ST> AsExpression<ST> for T\n   |             ^^^^^^^^^^^^^^^^     ^\n46 | where\n47 |     T: Expression<SqlType = ST>,\n   |        ------------------------ unsatisfied trait bound introduced here\n```\n\n----------------------------------------\n\nTITLE: Dropping a Tuple Captured by a Closure (Edition 2018 and Before)\nDESCRIPTION: This code shows that in older editions of Rust, if a closure captures any part of a composite type, the whole type is captured. This means that the entire tuple is dropped when the closure is dropped, even if only one element of the tuple is explicitly used within the closure.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n{\n    let tuple =\n      (String::from(\"foo\"), String::from(\"bar\"));\n    {\n        let c = || { // --------------------------+\n            // tuple is captured into the closure |\n            drop(tuple.0); //                     |\n        }; //                                     |\n    } // 'c' and 'tuple' dropped here ------------+\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using Tool Lints in Rust\nDESCRIPTION: Demonstrates the usage of tool lints in Rust to control warnings and errors for specific linters like Clippy. Tool lints only activate when the associated tool is active and behave like regular lint attributes. Dependencies include a Rust environment with Clippy installed.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/diagnostics.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n#![warn(clippy::pedantic)]\n#![allow(clippy::filter_map)]\n\nfn main() {\n    // ...\n}\n\n#[allow(clippy::cmp_nan)]\nfn foo() {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Crate Reference in Macros Example\nDESCRIPTION: Demonstrates using $crate for referring to items within the macro's defining crate, ensuring proper scope resolution.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros-by-example.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\npub mod inner {\n    #[macro_export]\n    macro_rules! call_foo {\n        () => { $crate::inner::foo() };\n    }\n\n    pub fn foo() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Container Trait for Vec<T> in Rust\nDESCRIPTION: Demonstrates how to implement a trait with an associated type for an existing type. Shows Vec<T> implementing Container with its associated type E defined as T.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n# trait Container {\n#     type E;\n#     fn empty() -> Self;\n#     fn insert(&mut self, elem: Self::E);\n# }\nimpl<T> Container for Vec<T> {\n    type E = T;\n    fn empty() -> Vec<T> { Vec::new() }\n    fn insert(&mut self, x: T) { self.push(x); }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Invalid Values for Function Pointers in Rust\nDESCRIPTION: States that a function pointer in Rust must be non-null. Null function pointers are invalid and lead to undefined behavior.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/behavior-considered-undefined.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n* A `fn` pointer value must be non-null.\n```\n\n----------------------------------------\n\nTITLE: Union Field Access Capture in Rust Closures\nDESCRIPTION: Examples showing how union field accesses are handled in closures, where the closure captures only up to the union itself since accessing union fields is unsafe.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nunion U {\n    a: (i32, i32),\n    b: bool,\n}\nlet u = U { a: (123, 456) };\n\nlet c = || {\n    let x = unsafe { u.a.0 }; // captures `u` ByValue\n};\nc();\n\n// This also includes writing to fields.\nlet mut u = U { a: (123, 456) };\n\nlet mut c = || {\n    u.b = true; // captures `u` with MutBorrow\n};\nc();\n```\n\n----------------------------------------\n\nTITLE: Defining Async Block Expression Grammar in Rust\nDESCRIPTION: Specifies the grammar for async block expressions in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/block-expr.md#2025-04-21_snippet_3\n\nLANGUAGE: grammar\nCODE:\n```\nAsyncBlockExpression -> `async` `move`? BlockExpression\n```\n\n----------------------------------------\n\nTITLE: Defining Zero-Variant Enum in Rust\nDESCRIPTION: Shows the declaration of a zero-variant enum, which has no valid values and cannot be instantiated.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/enumerations.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nenum ZeroVariants {}\n```\n\n----------------------------------------\n\nTITLE: Parenthesized Type Grammar in Rust\nDESCRIPTION: Defines the grammar rule for parenthesized types in Rust, which are used to disambiguate type expressions when the combination of types may be unclear.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types.md#2025-04-21_snippet_1\n\nLANGUAGE: grammar\nCODE:\n```\nParenthesizedType -> `(` Type `)`\n```\n\n----------------------------------------\n\nTITLE: Grouped Expression Grammar Definition\nDESCRIPTION: Formal grammar definition for grouped/parenthesized expressions in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/grouped-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nGroupedExpression -> `(` Expression `)`\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mutually Exclusive Options Error\nDESCRIPTION: Shows a compile-time error when attempting to use the mutually exclusive nomem and readonly options together. The nomem option is strictly stronger than readonly, and they cannot be specified together.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_42\n\nLANGUAGE: rust\nCODE:\n```\n// nomem is strictly stronger than readonly, they can't be specified together\nunsafe { core::arch::asm!(\"\", options(nomem, readonly)); }\n// ERROR: the `nomem` and `readonly` options are mutually exclusive\n```\n\n----------------------------------------\n\nTITLE: C String Literal Expressions in Rust\nDESCRIPTION: Explains the creation and representation of C-style string literals with UTF-8 encoding and null-byte termination\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/literal-expr.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nc\"foo\"; cr\"foo\";                     // foo\nc\"\\\"foo\\\"\"; cr#\"\"foo\"\"#;             // \"foo\"\n\nc\"foo #\\\"# bar\";\ncr##\"foo #\"# bar\"##;                 // foo #\"# bar\n\nc\"\\x52\"; c\"R\"; cr\"R\";                // R\nc\"\\\\x52\"; cr\"\\x52\";                  // \\x52\n\nc\"æ\";                                // LATIN SMALL LETTER AE (U+00E6)\nc\"\\u{00E6}\";                         // LATIN SMALL LETTER AE (U+00E6)\nc\"\\xC3\\xA6\";                         // LATIN SMALL LETTER AE (U+00E6)\n\nc\"\\xE6\".to_bytes();                  // [230]\nc\"\\u{00E6}\".to_bytes();              // [195, 166]\n```\n\n----------------------------------------\n\nTITLE: Defining a Derive Macro with Helper Attributes (Rust)\nDESCRIPTION: This snippet shows how to define a derive macro that uses helper attributes. The `attributes(helper)` argument in `#[proc_macro_derive(HelperAttr, attributes(helper))]` declares that the `HelperAttr` derive macro can receive the `#[helper]` attribute on fields of the struct it derives.  However, this example doesn't actually do anything with the helper attribute.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/procedural-macros.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# #![crate_type=\"proc-macro\"]\n# extern crate proc_macro;\n# use proc_macro::TokenStream;\n\n#[proc_macro_derive(HelperAttr, attributes(helper))]\npub fn derive_helper_attr(_item: TokenStream) -> TokenStream {\n    TokenStream::new()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using Lint Reasons in Rust Attributes\nDESCRIPTION: This example shows how to add a reason parameter to lint attributes, providing context for why a certain attribute was added. The reason is displayed as part of the lint message.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/diagnostics.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#![deny(\n    keyword_idents,\n    reason = \"we want to avoid these idents to be future compatible\"\n)]\n\n// This name was allowed in Rust's 2015 edition. We still aim to avoid\n// this to be future compatible and not confuse end users.\nfn dyn() {}\n```\n\n----------------------------------------\n\nTITLE: Negation Operators Example\nDESCRIPTION: Shows usage of arithmetic and logical negation operators.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 6;\nassert_eq!(-x, -6);\nassert_eq!(!x, -7);\nassert_eq!(true, !false);\n```\n\n----------------------------------------\n\nTITLE: Implementing Primitive Representation of Enums in Rust\nDESCRIPTION: This Rust snippet shows how to implement a primitive representation of enums with fields, mirroring C layout using #[repr(u8)]. It uses a union containing structs for each variant, each of which starts with an enum discriminant followed by the variant fields. The representation aids interfacing with C by aligning to its ABI standards.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/type-layout.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// This enum has the same representation as ...\n#[repr(u8)]\nenum MyEnum {\n    A(u32),\n    B(f32, u64),\n    C { x: u32, y: u8 },\n    D,\n }\n\n// ... this union.\n#[repr(C)]\nunion MyEnumRepr {\n    A: MyVariantA,\n    B: MyVariantB,\n    C: MyVariantC,\n    D: MyVariantD,\n}\n\n// This is the discriminant enum.\n#[repr(u8)]\n#[derive(Copy, Clone)]\nenum MyEnumDiscriminant { A, B, C, D }\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct MyVariantA(MyEnumDiscriminant, u32);\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct MyVariantB(MyEnumDiscriminant, f32, u64);\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct MyVariantC { tag: MyEnumDiscriminant, x: u32, y: u8 }\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct MyVariantD(MyEnumDiscriminant);\n```\n\n----------------------------------------\n\nTITLE: Using link_ordinal attribute with raw-dylib linking\nDESCRIPTION: Shows how to use the link_ordinal attribute to specify a numeric ordinal for symbol lookup in a dynamic library on Windows. This is used specifically with the raw-dylib linking kind to find symbols by their ordinal rather than by name.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/external-blocks.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(all(windows, target_arch = \"x86\"))]\n#[link(name = \"exporter\", kind = \"raw-dylib\")]\nunsafe extern \"stdcall\" {\n    #[link_ordinal(15)]\n    safe fn imported_function_stdcall(i: i32);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Glob Import Ambiguities in Rust\nDESCRIPTION: This example shows that glob imports are allowed to import conflicting names as long as the ambiguous name is not used. Two modules with the same struct name Qux can be imported with glob syntax without errors until the ambiguous name is actually referenced.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/use-declarations.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n    pub struct Qux;\n}\n\nmod bar {\n    pub struct Qux;\n}\n\nuse foo::*;\nuse bar::*; //~ OK, no name conflict.\n\nfn main() {\n    // This would be an error, due to the ambiguity.\n    //let x = Qux;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Visibility Grammar in Rust\nDESCRIPTION: Grammar specification for Rust's visibility modifiers including pub, pub(crate), pub(self), pub(super), and pub(in path).\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/visibility-and-privacy.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nVisibility ->\n      `pub`\n    | `pub` `(` `crate` `)`\n    | `pub` `(` `self` `)`\n    | `pub` `(` `super` `)`\n    | `pub` `(` `in` SimplePath `)`\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation for Dynamically Sized Types\nDESCRIPTION: Documentation detailing dynamically sized types in Rust, including their definition, usage restrictions, and implementation patterns. Covers core concepts like pointer types, generic parameters with ?Sized bound, trait implementations, and struct fields containing DSTs.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/dynamically-sized-types.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Dynamically Sized Types\n\nMost types have a fixed size that is known at compile time and implement the\ntrait [`Sized`][sized]. A type with a size that is known only at run-time is\ncalled a _dynamically sized type_ (_DST_) or, informally, an unsized type.\n[Slices] and [trait objects] are two examples of <abbr title=\"dynamically sized\ntypes\">DSTs</abbr>.\n\nSuch types can only be used in certain cases:\n\n* [Pointer types] to <abbr title=\"dynamically sized types\">DSTs</abbr> are\n  sized but have twice the size of pointers to sized types\n    * Pointers to slices also store the number of elements of the slice.\n    * Pointers to trait objects also store a pointer to a vtable.\n\n* <abbr title=\"dynamically sized types\">DSTs</abbr> can be provided as\n  type arguments to generic type parameters having the special `?Sized` bound.\n  They can also be used for associated type definitions when the corresponding associated type declaration has a `?Sized` bound.\n  By default, any type parameter or associated type has a `Sized` bound, unless it is relaxed using `?Sized`.\n\n* Traits may be implemented for <abbr title=\"dynamically sized\n  types\">DSTs</abbr>.\n  Unlike with generic type parameters, `Self: ?Sized` is the default in trait definitions.\n\n* Structs may contain a <abbr title=\"dynamically sized type\">DST</abbr> as the\n  last field; this makes the struct itself a\n  <abbr title=\"dynamically sized type\">DST</abbr>.\n```\n\n----------------------------------------\n\nTITLE: Field Access Expression Examples\nDESCRIPTION: Various examples of field access expressions including direct field access, method chaining, and struct literal field access.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/field-expr.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nmystruct.myfield;\nfoo().x;\n(Struct {a: 10, b: 20}).a;\n(mystruct.function_field)() // Call expression containing a field expression\n```\n\n----------------------------------------\n\nTITLE: Reading Memory with readonly Option\nDESCRIPTION: Example demonstrating that assembly code with readonly can still read from outside memory, just not modify it.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_35\n\nLANGUAGE: rust\nCODE:\n```\nlet x: i64 = 0;\nlet z: i64;\n// We can still read from it, though\nunsafe {\n    core::arch::asm!(\"mov {x}, qword ptr [{x}]\",\n        x = inout(reg) &x => z,\n        options(readonly)\n    );\n}\nassert_eq!(z, 0);\n```\n\n----------------------------------------\n\nTITLE: Char Array Type Reference in Rust\nDESCRIPTION: Reference to char array type, used in explaining char as effectively a single-character UTF-32 string.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/textual.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n[char]\n```\n\n----------------------------------------\n\nTITLE: Capturing Non-Packed Struct Field Address in Rust Closures\nDESCRIPTION: Demonstrates how capturing the address of a field in a non-packed struct allows for precise field captures without borrowing conflicts.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nstruct T(String, String);\n\nlet mut t = T(String::new(), String::new());\nlet c = || {\n    let a = std::ptr::addr_of!(t.1); // captures `t.1` with ImmBorrow\n};\n// The move here is allowed.\nlet a = t.0;\nc();\n```\n\n----------------------------------------\n\nTITLE: Multiple Borrow Syntax Example\nDESCRIPTION: Shows how double ampersand syntax works in borrow expressions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// same meanings:\nlet a = &&  10;\nlet a = & & 10;\n\n// same meanings:\nlet a = &&&&  mut 10;\nlet a = && && mut 10;\nlet a = & & & & mut 10;\n```\n\n----------------------------------------\n\nTITLE: Union Type Definition and Characteristics in Rust\nDESCRIPTION: Union types in Rust are nominal, heterogeneous C-like unions that require unsafe blocks for field access and have specific type constraints. They provide no concept of an 'active field' and perform transmutation when accessing fields.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/union.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Example union structure (implicit)\nunion Example {\n    // Fields must be types that never need dropping\n    field1: Type1,\n    field2: Type2\n}\n\n// Accessing union fields requires unsafe\nunsafe {\n    // Access transmutes memory to field type\n    let value = union_instance.field1;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Allowed and Disallowed Unconstraining Lifetime Parameters in Rust\nDESCRIPTION: Shows an example of an allowed unconstraining lifetime parameter and a disallowed case where the lifetime is used in an associated type.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/implementations.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'a> Struct {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'a> HasAssocType for Struct {\n    type Ty = &'a Struct;\n}\n```\n\n----------------------------------------\n\nTITLE: Combining repr(C) with Primitive Representation for Enums in Rust\nDESCRIPTION: Demonstrates how to combine repr(C) with a primitive representation (u8) for an enum with fields. This changes the representation of the discriminant enum to the chosen primitive type.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/type-layout.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(C, u8)] // `u8` was added\nenum MyEnum {\n    A(u32),\n    B(f32, u64),\n    C { x: u32, y: u8 },\n    D,\n }\n\n// ...\n\n#[repr(u8)] // So `u8` is used here instead of `C`\nenum MyEnumDiscriminant { A, B, C, D }\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Showing Correct Macro Fragment Forwarding in Rust\nDESCRIPTION: Illustrates how tokens can be directly matched after matching a tt fragment in macro forwarding.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros-by-example.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// compiles OK\nmacro_rules! foo {\n    ($l:tt) => { bar!($l); }\n}\n\nmacro_rules! bar {\n    (3) => {}\n}\n\nfoo!(3);\n```\n\n----------------------------------------\n\nTITLE: Using forbid Attribute to Disallow Lint Level Changes in Rust\nDESCRIPTION: This snippet illustrates how the forbid attribute prevents subsequent attempts to change the lint level for missing documentation, resulting in a compilation error.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/diagnostics.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[forbid(missing_docs)]\npub mod m3 {\n    // Attempting to toggle warning signals an error here\n    #[allow(missing_docs)]\n    /// Returns 2.\n    pub fn undocumented_too() -> i32 { 2 }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Reserved Number-Like Forms Grammar in Rust\nDESCRIPTION: This grammar defines the syntax for reserved forms that are similar to number literals in Rust but are not valid.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_11\n\nLANGUAGE: grammar\nCODE:\n```\nRESERVED_NUMBER ->\n      BIN_LITERAL [`2`-`9`]\n    | OCT_LITERAL [`8`-`9`]\n    | ( BIN_LITERAL | OCT_LITERAL | HEX_LITERAL ) `.` _not immediately followed by `.`, `_` or an XID_Start character_\n    | ( BIN_LITERAL | OCT_LITERAL ) (`e`|`E`)\n    | `0b` `_`* <end of input or not BIN_DIGIT>\n    | `0o` `_`* <end of input or not OCT_DIGIT>\n    | `0x` `_`* <end of input or not HEX_DIGIT>\n    | DEC_LITERAL ( `.` DEC_LITERAL )? (`e` | `E`) (`+` | `-`)? <end of input or not DEC_DIGIT>\n```\n\n----------------------------------------\n\nTITLE: Unsigned Integer Types in Rust\nDESCRIPTION: Specification of unsigned integer types (u8, u16, u32, u64, u128) with their minimum and maximum values. Each type represents unsigned integers with different bit widths.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/numeric.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nType   | Minimum | Maximum\n-------|---------|-------------------\n`u8`   | 0       | 2<sup>8</sup>-1\n`u16`  | 0       | 2<sup>16</sup>-1\n`u32`  | 0       | 2<sup>32</sup>-1\n`u64`  | 0       | 2<sup>64</sup>-1\n`u128` | 0       | 2<sup>128</sup>-1\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Macro Scoping and Lookup in Rust\nDESCRIPTION: Shows how macros are looked up using textual and path-based scoping, and how imports affect macro resolution.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros-by-example.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse lazy_static::lazy_static; // Path-based import.\n\nmacro_rules! lazy_static { // Textual definition.\n    (lazy) => {};\n}\n\nlazy_static!{lazy} // Textual lookup finds our macro first.\nself::lazy_static!{} // Path-based lookup ignores our macro, finds imported one.\n```\n\n----------------------------------------\n\nTITLE: Illustrating recursion_limit for auto-dereference in Rust\nDESCRIPTION: This snippet demonstrates how the recursion_limit attribute affects auto-dereferencing. It sets the limit to 1 and shows a case where two recursive steps are required, causing a compilation failure.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/limits.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![recursion_limit = \"1\"]\n\n// This fails because it requires two recursive steps to auto-dereference.\n(|_: &u8| {})(&&&1);\n```\n\n----------------------------------------\n\nTITLE: Raw Pointer Dereference Capture in Rust Closures\nDESCRIPTION: Example showing how raw pointer dereferences are handled in closures, where the closure captures only up to the pointer itself since dereferencing raw pointers is unsafe.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nstruct T(String, String);\n\nlet t = T(String::from(\"foo\"), String::from(\"bar\"));\nlet t_ptr = &t as *const T;\n\nlet c = || unsafe {\n    println!(\"{}\", (*t_ptr).0); // captures `t_ptr` by ImmBorrow\n};\nc();\n```\n\n----------------------------------------\n\nTITLE: Using a Derive Macro with a Helper Attribute (Rust)\nDESCRIPTION: This snippet shows how to use the derive macro with a helper attribute. The `#[helper]` attribute is placed on the `field` of the `Struct`. The derive macro defined previously, `HelperAttr`, is expected to process or use this attribute, even though the example macro does nothing with it.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/procedural-macros.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(HelperAttr)]\nstruct Struct {\n    #[helper] field: ()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Wildcard Pattern Binding in Rust Closures\nDESCRIPTION: Examples demonstrating that variables bound with wildcard patterns are not captured by closures since they are not considered as read.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet x = String::from(\"hello\");\nlet c = || {\n    let _ = x;  // x is not captured\n};\nc();\n\nlet c = || match x {  // x is not captured\n    _ => println!(\"Hello World!\")\n};\nc();\n```\n\n----------------------------------------\n\nTITLE: Borrowing into a Local Variable for Capture\nDESCRIPTION: This example demonstrates how to borrow a field into a local variable to allow a closure to capture it without capturing the entire struct.  This technique is necessary when other fields of the struct are already borrowed.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n# use std::collections::HashSet;\n#\nstruct SetVec {\n    set: HashSet<u32>,\n    vec: Vec<u32>\n}\n\nimpl SetVec {\n    fn populate(&mut self) {\n        let vec = &mut self.vec;\n        self.set.iter().for_each(|&n| {\n            vec.push(n);\n        })\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Illustrating Self Type Parameter Incompatibility with Dyn in Rust\nDESCRIPTION: Example demonstrating that traits using 'Self' as a type argument in supertraits are not compatible with trait objects.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/traits.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n// Dyn-incompatible if `Self` is a type argument.\ntrait Super<A> {}\ntrait WithSelf: Super<Self> where Self: Sized {}\n\nstruct S;\nimpl<A> Super<A> for S {}\nimpl WithSelf for S {}\nlet obj: Box<dyn WithSelf> = Box::new(S); // ERROR: cannot use `Self` type parameter\n```\n\n----------------------------------------\n\nTITLE: Intersection of Bounds for Generic Associated Types in Rust\nDESCRIPTION: Demonstrates how bounds are determined when multiple functions use a GAT. Only bounds that can be proven in all usages are required on the GAT definition.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\ntrait Check<T> {\n    type Checker<'x>;\n    fn create_checker<'a>(item: &'a T) -> Self::Checker<'a>;\n    fn do_check(checker: Self::Checker<'_>);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Extern Crate Declaration Syntax in Rust\nDESCRIPTION: This grammar snippet defines the syntax for extern crate declarations in Rust, including the optional 'as' clause for renaming.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/extern-crates.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nExternCrate -> `extern` `crate` CrateRef AsClause? `;`\n\nCrateRef -> IDENTIFIER | `self`\n\nAsClause -> `as` ( IDENTIFIER | `_` )\n```\n\n----------------------------------------\n\nTITLE: Edition 2015 Use Path Handling in Rust\nDESCRIPTION: For Rust 2015 edition, this snippet shows how 'use' paths resolve from the crate root and emphasizes the difference introduced in the 2018 edition, where 'use' paths are relative to the current scope. It exemplifies how explicit and implicit root resolution is handled in 'use' declarations before the 2018 changes.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/use-declarations.md#2025-04-21_snippet_3\n\nLANGUAGE: rust,edition2015\nCODE:\n```\nmod foo {\n    pub mod example { pub mod iter {} }\n    pub mod baz { pub fn foobaz() {} }\n}\nmod bar {\n    // Resolves `foo` from the crate root.\n    use foo::example::iter;\n    // The `::` prefix explicitly resolves `foo`\n    // from the crate root.\n    use ::foo::baz::foobaz;\n}\n\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Temporary Lifetime Extension in Rust Let Statements\nDESCRIPTION: This code snippet shows how temporary lifetime extension works in Rust let statements. The temporary value created for '0' is extended to live until the end of the block, allowing the reference to remain valid.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/destructors.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet x = &mut 0;\n// Usually a temporary would be dropped by now, but the temporary for `0` lives\n// to the end of the block.\nprintln!(\"{}\", x);\n```\n\n----------------------------------------\n\nTITLE: Byte Literal Grammar Definition\nDESCRIPTION: Defines the grammar rules for byte literals in Rust, including ASCII character and escape sequence syntax.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nBYTE_LITERAL ->\n    `b'` ( ASCII_FOR_CHAR | BYTE_ESCAPE )  `'` SUFFIX?\n\nASCII_FOR_CHAR ->\n    <any ASCII (i.e. 0x00 to 0x7F) except `'`, `\\`, LF, CR, or TAB>\n\nBYTE_ESCAPE ->\n      `\\x` HEX_DIGIT HEX_DIGIT\n    | `\\n` | `\\r` | `\\t` | `\\\\` | `\\0` | `\\'` | `\\\"`\n```\n\n----------------------------------------\n\nTITLE: Demonstrating non_exhaustive attribute usage in Rust\nDESCRIPTION: This code snippet shows how to apply the non_exhaustive attribute to structs, enums, and enum variants. It also demonstrates how these types can be constructed and matched within the defining crate, where non_exhaustive has no effect.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/type_system.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[non_exhaustive]\npub struct Config {\n    pub window_width: u16,\n    pub window_height: u16,\n}\n\n#[non_exhaustive]\npub struct Token;\n\n#[non_exhaustive]\npub struct Id(pub u64);\n\n#[non_exhaustive]\npub enum Error {\n    Message(String),\n    Other,\n}\n\npub enum Message {\n    #[non_exhaustive] Send { from: u32, to: u32, contents: String },\n    #[non_exhaustive] Reaction(u32),\n    #[non_exhaustive] Quit,\n}\n\n// Non-exhaustive structs can be constructed as normal within the defining crate.\nlet config = Config { window_width: 640, window_height: 480 };\nlet token = Token;\nlet id = Id(4);\n\n// Non-exhaustive structs can be matched on exhaustively within the defining crate.\nlet Config { window_width, window_height } = config;\nlet Token = token;\nlet Id(id_number) = id;\n\nlet error = Error::Other;\nlet message = Message::Reaction(3);\n\n// Non-exhaustive enums can be matched on exhaustively within the defining crate.\nmatch error {\n    Error::Message(ref s) => { },\n    Error::Other => { },\n}\n\nmatch message {\n    // Non-exhaustive variants can be matched on exhaustively within the defining crate.\n    Message::Send { from, to, contents } => { },\n    Message::Reaction(id) => { },\n    Message::Quit => { },\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Uninhabited Types in Rust\nDESCRIPTION: This snippet demonstrates the concept of uninhabited types in Rust, which are types that have no constructors and can never be instantiated. It shows an example of an uninhabited enum type.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/glossary.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum Never { }\n```\n\n----------------------------------------\n\nTITLE: Defining Punctuation Tokens in Rust\nDESCRIPTION: This grammar snippet lists the punctuation tokens recognized by the Rust language. These tokens represent operators and separators commonly used in expressions and declarations. The list includes both single-character and multi-character tokens like `=`, `&&`, and `->`.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_13\n\nLANGUAGE: grammar,lexer\nCODE:\n```\nPUNCTUATION ->\n      `=`\n    | `<`\n    | `<=`\n    | `==`\n    | `!=`\n    | `>=`\n    | `>`\n    | `&&`\n    | `||`\n    | `!`\n    | `~`\n    | `+`\n    | `-`\n    | `*`\n    | `/`\n    | `%`\n    | `^`\n    | `&`\n    | `|`\n    | `<<`\n    | `>>`\n    | `+=`\n    | `-=`\n    | `*=`\n    | `/=`\n    | `%=`\n    | `^=`\n    | `&=`\n    | `|=`\n    | `<<=`\n    | `>>=`\n    | `@`\n    | `.`\n    | `..`\n    | `...`\n    | `..=`\n    | `,`\n    | `;`\n    | `:`\n    | `::`\n    | `->`\n    | `<-`\n    | `=>`\n    | `#`\n    | `$`\n    | `?`\n    | `_`\n    | `{`\n    | `}`\n    | `[` \n    | `]`\n    | `(`\n    | `)`\n```\n\n----------------------------------------\n\nTITLE: Generic Parameter Bounds and Where Clauses in Rust\nDESCRIPTION: This code demonstrates how generic parameters are in scope for type bounds and where clauses in Rust function declarations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/names/scopes.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# trait SomeTrait<'a, T> {}\n// The <'a, U> for `SomeTrait` refer to the 'a and U parameters of `bounds_scope`.\nfn bounds_scope<'a, T: SomeTrait<'a, U>, U>() {}\n\nfn where_scope<'a, T, U>()\n    where T: SomeTrait<'a, U>\n{}\n```\n\n----------------------------------------\n\nTITLE: Implementing Constants with Destructors in Rust\nDESCRIPTION: Demonstration of creating constants with destructors in Rust, showing how the destructor is called when the constant goes out of scope.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/constant-items.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct TypeWithDestructor(i32);\\n\\nimpl Drop for TypeWithDestructor {\\n    fn drop(&mut self) {\\n        println!(\"Dropped. Held {}.\", self.0);\\n    }\\n}\\n\\nconst ZERO_WITH_DESTRUCTOR: TypeWithDestructor = TypeWithDestructor(0);\\n\\nfn create_and_drop_zero_with_destructor() {\\n    let x = ZERO_WITH_DESTRUCTOR;\\n    // x gets dropped at end of function, calling drop.\\n    // prints \"Dropped. Held 0.\".\\n}\n```\n\n----------------------------------------\n\nTITLE: Understanding Operand Evaluation Order - Rust\nDESCRIPTION: This example shows how operand expressions are evaluated from left to right. It points out the significance of this order especially when multiple values are being written to the same location.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(target_arch = \"x86_64\")] {\nlet mut y: i64;\n// y gets its value from the second output, rather than the first\nunsafe { core::arch::asm!(\"mov {}, 0\", \"mov {}, 1\", out(reg) y, out(reg) y); }\nassert_eq!(y, 1);\n# }\n```\n\n----------------------------------------\n\nTITLE: Rightmost Shared Reference Truncation in Rust Closures\nDESCRIPTION: Example demonstrating how Rust closures can have static lifetimes by truncating capture paths at the rightmost dereference of a shared reference.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nstruct Int(i32);\nstruct B<'a>(&'a i32);\n\nstruct MyStruct<'a> {\n   a: &'static Int,\n   b: B<'a>,\n}\n\nfn foo<'a, 'b>(m: &'a MyStruct<'b>) -> impl FnMut() + 'static {\n    let c = || drop(&m.a.0);\n    c\n}\n```\n\n----------------------------------------\n\nTITLE: Input Operands in Rust Inline Assembly\nDESCRIPTION: Demonstrates the use of input operands in Rust's inline assembly, allowing values to be passed from Rust code into assembly.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nunsafe { core::arch::asm!(\"/* {} */\", in(reg) 5); }\n```\n\n----------------------------------------\n\nTITLE: Specifying Crate Type as Dynamic Library in Rust\nDESCRIPTION: Illustrates how to specify a crate type as a dynamic library using either a command-line flag or a crate attribute. This forces dynamic library generation, creating platform-specific files (.so, .dylib, or .dll).\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/linkage.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n--crate-type=dylib\n```\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_type = \"dylib\"]\n```\n\n----------------------------------------\n\nTITLE: Byte String Literal Examples\nDESCRIPTION: Demonstrates various byte string literal syntax including escaped quotes and raw strings.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nb\"foo\"; br\"foo\";                     // foo\nb\"\\\"foo\\\"\"; br#\"\"foo\"\"#;             // \"foo\"\n\nb\"foo #\\\"# bar\";\nbr##\"foo #\"# bar\"##;                 // foo #\"# bar\n\nb\"\\x52\"; b\"R\"; br\"R\";                // R\nb\"\\\\x52\"; br\"\\x52\";                  // \\x52\n```\n\n----------------------------------------\n\nTITLE: Grammar Specification Syntax Definition\nDESCRIPTION: Complete BNF-like grammar definition for the reference documentation grammar syntax. This meta-grammar defines the structure and rules for writing grammar productions, including terminals, non-terminals, repetition operators, and other expression types.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/docs/grammar.md#2025-04-21_snippet_1\n\nLANGUAGE: grammar\nCODE:\n```\nGrammar -> Production+\n\nBACKTICK -> U+0060\n\nLF -> U+000A\n\nProduction -> `@root`? Name ` ->` Expression\n\nName -> <Alphanumeric or `_`>+\n\nExpression -> Sequence (` `* `|` ` `* Sequence)*\n\nSequence -> (` `* AdornedExpr)+\n\nAdornedExpr -> ExprRepeat Suffix? Footnote?\n\nSuffix -> ` _` <not underscore, unless in backtick>* `_`\n\nFootnote -> `[^` ~[`]` LF]+ `]`\n\nExprRepeat ->\n      Expr1 `?`\n    | Expr1 `*?`\n    | Expr1 `*`\n    | Expr1 `+?`\n    | Expr1 `+`\n    | Expr1 `{` Range? `..` Range? `}`\n\nRange -> [0-9]+\n\nExpr1 ->\n      Unicode\n    | NonTerminal\n    | Break\n    | Terminal\n    | Charset\n    | Prose\n    | Group\n    | NegativeExpression\n\nUnicode -> `U+` [`A`-`Z` `0`-`9`]4..4\n\nNonTerminal -> Name\n\nBreak -> LF ` `+\n\nTerminal -> BACKTICK ~[LF]+ BACKTICK\n\nCharset -> `[` (` `* Characters)+ ` `* `]`\n\nCharacters ->\n      CharacterRange\n    | CharacterTerminal\n    | CharacterName\n\nCharacterRange -> BACKTICK <any char> BACKTICK `-` BACKTICK <any char> BACKTICK\n\nCharacterTerminal -> Terminal\n\nCharacterName -> Name\n\nProse -> `<` ~[`>` LF]+ `>`\n\nGroup -> `(` ` `* Expression ` `* `)`\n\nNegativeExpression -> `~` ( Charset | Terminal | NonTerminal )\n```\n\n----------------------------------------\n\nTITLE: Array Capture Limitation in Rust Closures\nDESCRIPTION: Example demonstrating that arrays and slices are always captured in their entirety by Rust closures, even when using partial pattern matching or indexing.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nstruct Example;\nlet x = [Example, Example];\n\nlet c = || {\n    let [first, _] = x; // captures all of `x` ByValue\n};\nc();\nprintln!(\"{:?}\", x[1]); // ERROR: borrow of moved value: `x`\n```\n\n----------------------------------------\n\nTITLE: Struct Memory Layout Attribute Reference in Rust\nDESCRIPTION: References the 'repr' attribute which can be used to control the memory layout of structs in Rust. By default, struct memory layout is undefined to allow compiler optimizations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/struct.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n`repr` attribute\n```\n\n----------------------------------------\n\nTITLE: Referencing Symbol in Inline Assembly - Rust\nDESCRIPTION: The snippet shows how to refer to a function using the `sym` operand in inline assembly. It demonstrates calling an external function safely within inline assembly.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(target_arch = \"x86_64\")] {\nextern \"C\" fn foo() {\n    println!(\"Hello from inline assembly\")\n}\n// `sym` can be used to refer to a function (even if it doesn't have an\n// external name we can directly write)\nsafe { core::arch::asm!(\"call {}\", sym foo, clobber_abi(\"C\")); }\n# }\n```\n\n----------------------------------------\n\nTITLE: Grammar Definition for Never Type in Rust\nDESCRIPTION: Defines the syntax grammar for the Never type in Rust, which is represented by the exclamation mark (`!`).\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/never.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nNeverType -> `!`\n```\n\n----------------------------------------\n\nTITLE: Defining Item Syntax in Rust\nDESCRIPTION: This code snippet defines the grammar for items in Rust, including visibility, various types of items, and macro items. It specifies the structure and components of different item types in Rust's syntax.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nItem ->\n    OuterAttribute* ( VisItem | MacroItem )\n\nVisItem ->\n    Visibility?\n    (\n        Module\n      | ExternCrate\n      | UseDeclaration\n      | Function\n      | TypeAlias\n      | Struct\n      | Enumeration\n      | Union\n      | ConstantItem\n      | StaticItem\n      | Trait\n      | Implementation\n      | ExternBlock\n    )\n\nMacroItem ->\n      MacroInvocationSemi\n    | MacroRulesDefinition\n```\n\n----------------------------------------\n\nTITLE: Full Box Capture in Non-Move Rust Closures\nDESCRIPTION: Shows how moving the contents of a Box into a non-move closure results in capturing the entire Box to minimize moved data.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nstruct S(String);\n\nlet b = Box::new(S(String::new()));\nlet c_box = || {\n    let x = (*b).0; // captures `b` with ByValue\n};\nc_box();\n```\n\n----------------------------------------\n\nTITLE: Uninitialized Memory Raw Pointer Example\nDESCRIPTION: Shows how to safely create and use raw pointers with uninitialized memory.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse std::mem::MaybeUninit;\n\nstruct Demo {\n    field: bool,\n}\n\nlet mut uninit = MaybeUninit::<Demo>::uninit();\n// `&uninit.as_mut().field` would create a reference to an uninitialized `bool`,\n// and thus be undefined behavior!\nlet f1_ptr = unsafe { &raw mut (*uninit.as_mut_ptr()).field };\nunsafe { f1_ptr.write(true); }\nlet init = unsafe { uninit.assume_init() };\n```\n\n----------------------------------------\n\nTITLE: Generic Parameter Shadowing Error in Rust\nDESCRIPTION: This example shows that it's an error for items declared inside a function to refer to a generic parameter from their outer scope in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/names/scopes.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn example<T>() {\n    fn inner(x: T) {} // ERROR: can't use generic parameters from outer function\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Static C Runtime Linkage in Rust\nDESCRIPTION: Command line example showing how to enable static runtime linkage using rustc's target-feature flag\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/linkage.md#2025-04-21_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\nrustc -C target-feature=+crt-static foo.rs\n```\n\n----------------------------------------\n\nTITLE: Crate Name Attribute Example\nDESCRIPTION: Shows how to specify a custom crate name using the crate_name attribute.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/crates-and-source-files.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_name = \"mycrate\"]\n```\n\n----------------------------------------\n\nTITLE: Handling Ambiguous Lazy Boolean Operators with If Let in Rust\nDESCRIPTION: Examples showing how to handle potentially ambiguous lazy boolean expressions in if let patterns by using parentheses to clarify intention and avoid conflicts with if-let chains.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/if-expr.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n// Before...\nif let PAT = EXPR && EXPR { .. }\n\n// After...\nif let PAT = ( EXPR && EXPR ) { .. }\n\n// Before...\nif let PAT = EXPR || EXPR { .. }\n\n// After...\nif let PAT = ( EXPR || EXPR ) { .. }\n```\n\n----------------------------------------\n\nTITLE: Defining Inferred Type Grammar in Rust\nDESCRIPTION: The grammar definition for Rust's inferred type, which is represented by a single underscore character.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/inferred.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nInferredType -> `_`\n```\n\n----------------------------------------\n\nTITLE: String Slice Type Definition in Rust\nDESCRIPTION: Defines str type as a UTF-8 encoded string slice, represented internally as [u8] but with UTF-8 validity guarantees. Must be accessed through pointer types like &str.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/textual.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstr\n```\n\n----------------------------------------\n\nTITLE: Defining Reserved Tokens in Rust\nDESCRIPTION: This grammar segment outlines token forms reserved for future extensions of the Rust language. As of now, these tokens cannot appear in the source code. Examples include `RESERVED_GUARDED_STRING_LITERAL` and `RESERVED_NUMBER`.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_14\n\nLANGUAGE: grammar,lexer\nCODE:\n```\nRESERVED_TOKEN ->\n      RESERVED_GUARDED_STRING_LITERAL\n    | RESERVED_NUMBER\n    | RESERVED_POUNDS\n    | RESERVED_RAW_IDENTIFIER\n    | RESERVED_RAW_LIFETIME\n    | RESERVED_TOKEN_DOUBLE_QUOTE\n    | RESERVED_TOKEN_LIFETIME\n    | RESERVED_TOKEN_POUND\n    | RESERVED_TOKEN_SINGLE_QUOTE\n```\n\n----------------------------------------\n\nTITLE: Expanding Multiple Attributes with cfg_attr in Rust\nDESCRIPTION: Demonstrates how cfg_attr can expand to multiple separate attributes when the configuration predicate is true.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/conditional-compilation.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg_attr(feature = \"magic\", sparkles, crackles)]\nfn bewitched() {}\n\n// When the `magic` feature flag is enabled, the above will expand to:\n#[sparkles]\n#[crackles]\nfn bewitched() {}\n```\n\n----------------------------------------\n\nTITLE: Defining Macro Invocation Syntax in Rust\nDESCRIPTION: Specifies the grammar for macro invocation in Rust, including the structure of DelimTokenTree and TokenTree.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nMacroInvocation ->\n    SimplePath `!` DelimTokenTree\n\nDelimTokenTree ->\n      `(` TokenTree* `)`\n    | `[` TokenTree* `]`\n    | `{` TokenTree* `}`\n\nTokenTree ->\n    Token _except [delimiters][lex.token.delim]_ | DelimTokenTree\n\nMacroInvocationSemi ->\n      SimplePath `!` `(` TokenTree* `)` `;`\n    | SimplePath `!` `[` TokenTree* `]` `;`\n    | SimplePath `!` `{` TokenTree* `}`\n```\n\n----------------------------------------\n\nTITLE: Correct Stack Memory Usage with nomem Option\nDESCRIPTION: Example showing that assembly code with nomem can still use its own stack memory (through push/pop), just not access outside memory.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_33\n\nLANGUAGE: rust\nCODE:\n```\nlet x: i32 = 0;\nlet z: i32;\n// If we allocate our own memory, such as via `push`, however.\n// we can still use it\nunsafe {\n    core::arch::asm!(\"push {x}\", \"add qword ptr [rsp], 1\", \"pop {x}\",\n        x = inout(reg) x => z,\n        options(nomem)\n    );\n}\nassert_eq!(z, 1);\n```\n\n----------------------------------------\n\nTITLE: Using Multiple ABI Clobbers in Inline Assembly (x86_64)\nDESCRIPTION: Example demonstrating how to call multiple functions with different calling conventions in inline assembly, using clobber_abi to handle register usage correctly.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\nextern \"sysv64\" fn foo() -> i32 { 0 }\nextern \"win64\" fn bar(x: i32) -> i32 { x + 1}\n\nlet z: i32;\n// We can even call multiple functions with different conventions and\n// different saved registers\nunsafe {\n    core::arch::asm!(\n        \"call {}\",\n        \"mov ecx, eax\",\n        \"call {}\",\n        sym foo,\n        sym bar,\n        out(\"rax\") z,\n        clobber_abi(\"C\")\n    );\n}\nassert_eq!(z, 1);\n```\n\n----------------------------------------\n\nTITLE: Raw C String Literal Grammar Definition\nDESCRIPTION: Defines the grammar for raw C string literals that don't process escape sequences.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_5\n\nLANGUAGE: grammar\nCODE:\n```\nRAW_C_STRING_LITERAL ->\n    `cr` RAW_C_STRING_CONTENT SUFFIX?\n\nRAW_C_STRING_CONTENT ->\n      `\"` ( ~[CR NUL] )*? `\"`\n    | `#` RAW_C_STRING_CONTENT `#`\n```\n\n----------------------------------------\n\nTITLE: Detecting C Runtime Linkage in Rust Code\nDESCRIPTION: Rust code example showing how to conditionally compile code based on C runtime linkage using cfg attributes\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/linkage.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(target_feature = \"crt-static\")]\nfn foo() {\n    println!(\"the C runtime should be statically linked\");\n}\n\n#[cfg(not(target_feature = \"crt-static\"))]\nfn foo() {\n    println!(\"the C runtime should be dynamically linked\");\n}\n```\n\n----------------------------------------\n\nTITLE: Unsafe External Function with Never Type in Rust\nDESCRIPTION: Declares an unsafe external C function with the Never type (`!`) as its return type, indicating that the function never returns to the caller.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/never.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nunsafe extern \"C\" {\n    pub safe fn no_return_extern_func() -> !;\n}\n```\n\n----------------------------------------\n\nTITLE: Describing Dynamic Heap Allocation in Rust\nDESCRIPTION: Details the concept of heap allocation in Rust, particularly for boxes. It explains the lifetime characteristics of heap allocations and their relationship to box values.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/memory-allocation-and-lifetime.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nr[alloc.dynamic]\n```\n\n----------------------------------------\n\nTITLE: Multiplying with Shifts and Adds using Inline Assembly in Rust\nDESCRIPTION: Demonstrates using inline assembly to multiply a number by 6 using shifts and adds. The code uses the asm! macro to embed x86_64 assembly instructions within Rust code.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::arch::asm;\n\n// Multiply x by 6 using shifts and adds\nlet mut x: u64 = 4;\nunsafe {\n    asm!(\n        \"mov {tmp}, {x}\",\n        \"shl {tmp}, 1\",\n        \"shl {x}, 2\",\n        \"add {x}, {tmp}\",\n        x = inout(reg) x,\n        tmp = out(reg) _,\n    );\n}\nassert_eq!(x, 4 * 6);\n```\n\n----------------------------------------\n\nTITLE: Error Propagation Expression Grammar\nDESCRIPTION: Defines the syntax for the question mark operator used in error propagation.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_8\n\nLANGUAGE: grammar\nCODE:\n```\nErrorPropagationExpression -> Expression `?`\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Static Items in Generic Contexts in Rust\nDESCRIPTION: Illustrates how static items behave when defined in generic scopes, showing that only one static item is created regardless of the number of monomorphizations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/static-items.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\ntrait Tr {\n    fn default_impl() {\n        static COUNTER: AtomicUsize = AtomicUsize::new(0);\n        println!(\"default_impl: counter was {}\", COUNTER.fetch_add(1, Ordering::Relaxed));\n    }\n\n    fn blanket_impl();\n}\n\nstruct Ty1 {}\nstruct Ty2 {}\n\nimpl<T> Tr for T {\n    fn blanket_impl() {\n        static COUNTER: AtomicUsize = AtomicUsize::new(0);\n        println!(\"blanket_impl: counter was {}\", COUNTER.fetch_add(1, Ordering::Relaxed));\n    }\n}\n\nfn main() {\n    <Ty1 as Tr>::default_impl();\n    <Ty2 as Tr>::default_impl();\n    <Ty1 as Tr>::blanket_impl();\n    <Ty2 as Tr>::blanket_impl();\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting AArch64 Target Features in Markdown\nDESCRIPTION: A markdown table listing AArch64 target features, their implicit dependencies, and corresponding ARM architecture feature names. It includes information on SIMD, cryptography, and various ARM-specific extensions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/codegen.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nFeature        | Implicitly Enables | Feature Name\n-------        | ------------------ | ------------\n`aes`          | `neon`             | FEAT_AES & FEAT_PMULL --- Advanced <abbr title=\"Single Instruction Multiple Data\">SIMD</abbr> AES & PMULL instructions\n`bf16`         |                    | FEAT_BF16 --- BFloat16 instructions\n`bti`          |                    | FEAT_BTI --- Branch Target Identification\n`crc`          |                    | FEAT_CRC --- CRC32 checksum instructions\n`dit`          |                    | FEAT_DIT  --- Data Independent Timing instructions\n`dotprod`      | `neon`             | FEAT_DotProd --- Advanced SIMD Int8 dot product instructions\n`dpb`          |                    | FEAT_DPB --- Data cache clean to point of persistence\n`dpb2`         | `dpb`              | FEAT_DPB2 --- Data cache clean to point of deep persistence\n`f32mm`        | `sve`              | FEAT_F32MM --- SVE single-precision FP matrix multiply instruction\n`f64mm`        | `sve`              | FEAT_F64MM --- SVE double-precision FP matrix multiply instruction\n`fcma`         | `neon`             | FEAT_FCMA --- Floating point complex number support\n`fhm`          | `fp16`             | FEAT_FHM --- Half-precision FP FMLAL instructions\n`flagm`        |                    | FEAT_FLAGM --- Conditional flag manipulation\n`fp16`         | `neon`             | FEAT_FP16 --- Half-precision FP data processing\n`frintts`      |                    | FEAT_FRINTTS --- Floating-point to int helper instructions\n`i8mm`         |                    | FEAT_I8MM --- Int8 Matrix Multiplication\n`jsconv`       | `neon`             | FEAT_JSCVT --- JavaScript conversion instruction\n`lor`          |                    | FEAT_LOR --- Limited Ordering Regions extension\n`lse`          |                    | FEAT_LSE --- Large System Extensions\n`mte`          |                    | FEAT_MTE & FEAT_MTE2 --- Memory Tagging Extension\n`neon`         |                    | FEAT_AdvSimd & FEAT_FP --- Floating Point and Advanced SIMD extension\n`paca`         |                    | FEAT_PAUTH --- Pointer Authentication (address authentication)\n`pacg`         |                    | FEAT_PAUTH --- Pointer Authentication (generic authentication)\n`pan`          |                    | FEAT_PAN --- Privileged Access-Never extension\n`pmuv3`        |                    | FEAT_PMUv3 --- Performance Monitors extension (v3)\n`rand`         |                    | FEAT_RNG --- Random Number Generator\n`ras`          |                    | FEAT_RAS & FEAT_RASv1p1 --- Reliability, Availability and Serviceability extension\n`rcpc`         |                    | FEAT_LRCPC --- Release consistent Processor Consistent\n`rcpc2`        | `rcpc`             | FEAT_LRCPC2 --- RcPc with immediate offsets\n`rdm`          | `neon`             | FEAT_RDM --- Rounding Double Multiply accumulate\n`sb`           |                    | FEAT_SB --- Speculation Barrier\n`sha2`         | `neon`             | FEAT_SHA1 & FEAT_SHA256 --- Advanced SIMD SHA instructions\n`sha3`         | `sha2`             | FEAT_SHA512 & FEAT_SHA3 --- Advanced SIMD SHA instructions\n`sm4`          | `neon`             | FEAT_SM3 & FEAT_SM4 --- Advanced SIMD SM3/4 instructions\n`spe`          |                    | FEAT_SPE --- Statistical Profiling Extension\n`ssbs`         |                    | FEAT_SSBS & FEAT_SSBS2 --- Speculative Store Bypass Safe\n`sve`          | `neon`             | FEAT_SVE --- Scalable Vector Extension\n`sve2`         | `sve`              | FEAT_SVE2 --- Scalable Vector Extension 2\n`sve2-aes`     | `sve2`, `aes`      | FEAT_SVE_AES & FEAT_SVE_PMULL128 --- SVE AES instructions\n`sve2-bitperm` | `sve2`             | FEAT_SVE2_BitPerm --- SVE Bit Permute\n`sve2-sha3`    | `sve2`, `sha3`     | FEAT_SVE2_SHA3 --- SVE SHA3 instructions\n`sve2-sm4`     | `sve2`, `sm4`      | FEAT_SVE2_SM4 --- SVE SM4 instructions\n`tme`          |                    | FEAT_TME --- Transactional Memory Extension\n`vh`           |                    | FEAT_VHE --- Virtualization Host Extensions\n```\n\n----------------------------------------\n\nTITLE: Installing mdbook for Rust Documentation\nDESCRIPTION: Command to install mdbook, a tool for creating online books, which is used to build the Rust Language Reference.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/README.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncargo install --locked mdbook\n```\n\n----------------------------------------\n\nTITLE: Error demonstration: Function item types are distinct\nDESCRIPTION: This code snippet demonstrates that function item types of the same function with different generic parameters are distinct types, and attempting to assign one to another results in a type error.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/function-item.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T>() { }\nlet x = &mut foo::<i32>;\n*x = foo::<u32>; //~ ERROR mismatched types\n```\n\n----------------------------------------\n\nTITLE: Type Path Syntax Definition\nDESCRIPTION: Describes the syntax for type paths in Rust, showing how types, generics, and function types are organized in paths used in type definitions and bounds.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/paths.md#2025-04-21_snippet_6\n\nLANGUAGE: grammar\nCODE:\n```\nTypePath -> `::`? TypePathSegment (`::` TypePathSegment)*\n\nTypePathSegment -> PathIdentSegment (`::`? (GenericArgs | TypePathFn))?\n\nTypePathFn -> `(` TypePathFnInputs? `)` (`->` TypeNoBounds)?\n\nTypePathFnInputs -> Type (`,` Type)* `,`?\n```\n\n----------------------------------------\n\nTITLE: Incorrect Memory Modification with readonly Option\nDESCRIPTION: Example showing that modifying outside memory when readonly is specified leads to undefined behavior.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_34\n\nLANGUAGE: rust\nCODE:\n```\nlet mut x = 0;\n// We cannot modify outside memory when `readonly` is specified\nunsafe {\n    core::arch::asm!(\"mov dword ptr[{}], 1\", in(reg) &mut x, options(readonly))\n}\n```\n\n----------------------------------------\n\nTITLE: Using Stack with readonly Option\nDESCRIPTION: Example showing that assembly code with readonly can still use its own stack memory, similar to the nomem case.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_36\n\nLANGUAGE: rust\nCODE:\n```\nlet x: i64 = 0;\nlet z: i64;\n// Same exception applies as with nomem.\nunsafe {\n    core::arch::asm!(\"push {x}\", \"add qword ptr [rsp], 1\", \"pop {x}\",\n        x = inout(reg) x => z,\n        options(readonly)\n    );\n}\nassert_eq!(z, 1);\n```\n\n----------------------------------------\n\nTITLE: Raw Byte String Literal Grammar Definition\nDESCRIPTION: Defines the grammar for raw byte string literals that don't process escape sequences.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_2\n\nLANGUAGE: grammar\nCODE:\n```\nRAW_BYTE_STRING_LITERAL ->\n    `br` RAW_BYTE_STRING_CONTENT SUFFIX?\n\nRAW_BYTE_STRING_CONTENT ->\n      `\"` ASCII_FOR_RAW*? `\"`\n    | `#` RAW_BYTE_STRING_CONTENT `#`\n\nASCII_FOR_RAW ->\n    <any ASCII (i.e. 0x00 to 0x7F) except CR>\n```\n\n----------------------------------------\n\nTITLE: Configuring Windows Subsystem in Rust\nDESCRIPTION: Demonstrates setting the Windows subsystem attribute to specify application console behavior during startup. Used primarily by GUI applications to prevent console window display.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/runtime.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![windows_subsystem = \"windows\"]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Infinite Loop in Rust\nDESCRIPTION: This code snippet shows an example of an infinite loop in Rust using the 'loop' keyword. The loop will continue to print 'I live.' indefinitely unless broken.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/loop-expr.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nloop { println!(\"I live.\"); }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Textual Macro Scope in Rust\nDESCRIPTION: Shows how macro scope is based on source file order and module boundaries. Demonstrates that macros are only available after their definition within the same scope.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros-by-example.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n//// src/lib.rs\nmod has_macro {\n    // m!{} // Error: m is not in scope.\n\n    macro_rules! m {\n        () => {};\n    }\n    m!{} // OK: appears after declaration of m.\n\n    mod uses_macro;\n}\n\n// m!{} // Error: m is not in scope.\n\n//// src/has_macro/uses_macro.rs\n\nm!{} // OK: appears after declaration of m in src/lib.rs\n```\n\n----------------------------------------\n\nTITLE: Register Size Handling Example\nDESCRIPTION: Demonstrates behavior when using smaller values in larger registers and potential undefined behavior.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nlet mut x: i64;\n// Moving a 32-bit value into a 64-bit value, oops.\n#[allow(asm_sub_register)] // rustc warns about this behavior\nunsafe { core::arch::asm!(\"mov {}, {}\", lateout(reg) x, in(reg) 4i32); }\n// top 32-bits are indeterminate\nassert_eq!(x, 4); // This assertion is not guaranteed to succeed\nassert_eq!(x & 0xFFFFFFFF, 4); // However, this one will succeed\n```\n\n----------------------------------------\n\nTITLE: Defining Invalid Values for Character Type in Rust\nDESCRIPTION: Specifies that a char value in Rust must not be a surrogate (not in the range 0xD800..=0xDFFF) and must be equal to or less than char::MAX.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/behavior-considered-undefined.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n* A `char` value must not be a surrogate (i.e., must not be in the range `0xD800..=0xDFFF`) and must be equal to or less than `char::MAX`.\n```\n\n----------------------------------------\n\nTITLE: Using Const Generic Parameters\nDESCRIPTION: This snippet demonstrates the usage of const generic parameters in function signatures and structures in Rust, including valid contexts where they can appear.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/generics.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n// Examples where const generic parameters can be used.\n\n// Used in the signature of the item itself.\nfn foo<const N: usize>(arr: [i32; N]) {\n    // Used as a type within a function body.\n    let x: [i32; N];\n    // Used as an expression.\n    println!(\"{}\", N * 2);\n}\n\n// Used as a field of a struct.\nstruct Foo<const N: usize>([i32; N]);\n\nimpl<const N: usize> Foo<N> {\n    // Used as an associated constant.\n    const CONST: usize = N * 4;\n}\n\ntrait Trait {\n    type Output;\n}\n\nimpl<const N: usize> Trait for Foo<N> {\n    // Used as an associated type.\n    type Output = [i32; N];\n}\n```\n```\n\nLANGUAGE: rust\nCODE:\n```\n```rust,compile_fail\n// Examples where const generic parameters cannot be used.\nfn foo<const N: usize>() {\n    // Cannot use in item definitions within a function body.\n    const BAD_CONST: [usize; N] = [1; N];\n    static BAD_STATIC: [usize; N] = [1; N];\n    fn inner(bad_arg: [usize; N]) {\n        let bad_value = N * 2;\n    }\n    type BadAlias = [usize; N];\n    struct BadStruct([usize; N]);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Matching Tuple Patterns in Rust\nDESCRIPTION: Demonstrates how to use tuple patterns to match and destructure tuple values in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nlet pair = (10, \"ten\");\nlet (a, b) = pair;\n\nassert_eq!(a, 10);\nassert_eq!(b, \"ten\");\n```\n\n----------------------------------------\n\nTITLE: Using Labels with noreturn Option\nDESCRIPTION: Example showing that assembly code with noreturn can still jump to label blocks, which may return.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_39\n\nLANGUAGE: rust\nCODE:\n```\nlet _: () = unsafe {\n    // You may still jump to a `label` block\n    core::arch::asm!(\"jmp {}\", label {\n        println!();\n    }, options(noreturn));\n};\n```\n\n----------------------------------------\n\nTITLE: Using noreturn Option in Inline Assembly\nDESCRIPTION: Example of using the noreturn option to indicate that assembly code never returns normally (e.g., traps or halts execution).\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_37\n\nLANGUAGE: rust\nCODE:\n```\nfn main() -> ! {\n    // We can use an instruction to trap execution inside of a noreturn block\n    unsafe { core::arch::asm!(\"ud2\", options(noreturn)); }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Register Type Example\nDESCRIPTION: Shows an invalid attempt to use __m128i type with reg register class, resulting in compilation error.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nlet z = unsafe { core::arch::x86_64::_mm_set_epi64x(1, 0) };\n// We can't pass an `__m128i` to a `reg` input\nunsafe { core::arch::asm!(\"/* {} */\", in(reg) z); }\n// ERROR: type `__m128i` cannot be used with this register class\n```\n\n----------------------------------------\n\nTITLE: Examples of Extern Crate Declarations in Rust\nDESCRIPTION: This code snippet demonstrates three examples of extern crate declarations in Rust, including a standard import, importing the standard library, and renaming an import.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/extern-crates.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nextern crate pcre;\n\nextern crate std; // equivalent to: extern crate std as std;\n\nextern crate std as ruststd; // linking to 'std' under another name\n```\n\n----------------------------------------\n\nTITLE: Implementing Natvis Debugger Visualization in Rust\nDESCRIPTION: Example demonstrating how to use the debugger_visualizer attribute with a Natvis file for Windows debuggers. Shows implementation of a FancyRect struct with custom visualization rules.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/debugger.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![debugger_visualizer(natvis_file = \"Rectangle.natvis\")]\n\nstruct FancyRect {\n    x: f32,\n    y: f32,\n    dx: f32,\n    dy: f32,\n}\n\nfn main() {\n    let fancy_rect = FancyRect { x: 10.0, y: 10.0, dx: 5.0, dy: 5.0 };\n    println!(\"set breakpoint here\");\n}\n```\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<AutoVisualizer xmlns=\"http://schemas.microsoft.com/vstudio/debugger/natvis/2010\">\n    <Type Name=\"foo::FancyRect\">\n      <DisplayString>({x},{y}) + ({dx}, {dy})</DisplayString>\n      <Expand>\n        <Synthetic Name=\"LowerLeft\">\n          <DisplayString>({x}, {y})</DisplayString>\n        </Synthetic>\n        <Synthetic Name=\"UpperLeft\">\n          <DisplayString>({x}, {y + dy})</DisplayString>\n        </Synthetic>\n        <Synthetic Name=\"UpperRight\">\n          <DisplayString>({x + dx}, {y + dy})</DisplayString>\n        </Synthetic>\n        <Synthetic Name=\"LowerRight\">\n          <DisplayString>({x + dx}, {y})</DisplayString>\n        </Synthetic>\n      </Expand>\n    </Type>\n</AutoVisualizer>\n```\n\n----------------------------------------\n\nTITLE: Javascript for redirect\nDESCRIPTION: This Javascript code snippet is designed to redirect the page to a new URL based on the hash fragment in the current URL. It uses a lookup table `fragments` to map specific hash fragments to their corresponding target URLs. If a match is found, it constructs the new URL and redirects the browser.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/lifetime-elision.md#2025-04-21_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\n<script>\n(function() {\n    var fragments = {\n        \"#static-lifetime-elision\": \"lifetime-elision.html#const-and-static-elision\",\n    };\n    var target = fragments[window.location.hash];\n    if (target) {\n        var url = window.location.toString();\n        var base = url.substring(0, url.lastIndexOf('/'));\n        window.location.replace(base + \"/\" + target);\n    }\n})();\n</script>\n```\n```\n\n----------------------------------------\n\nTITLE: Incorrect Memory Access with nomem Option\nDESCRIPTION: Example demonstrating that accessing outside memory when nomem is specified is incorrect and leads to undefined behavior.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_32\n\nLANGUAGE: rust\nCODE:\n```\nlet mut x = 0i32;\nlet z: i32;\n// Accessing outside memory from assembly when `nomem` is\n// specified is disallowed\nunsafe {\n    core::arch::asm!(\"mov {val:e}, dword ptr [{ptr}]\",\n        ptr = in(reg) &mut x,\n        val = lateout(reg) z,\n        options(nomem)\n    )\n}\n\n// Writing to outside memory from assembly when `nomem` is\n// specified is also undefined behaviour\nunsafe {\n    core::arch::asm!(\"mov  dword ptr [{ptr}], {val:e}\",\n        ptr = in(reg) &mut x,\n        val = in(reg) z,\n        options(nomem)\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tool Attributes in Rust\nDESCRIPTION: Provides examples of tool attributes in Rust, including rustfmt and clippy attributes.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// Tells the rustfmt tool to not format the following element.\n#[rustfmt::skip]\nstruct S {\n}\n\n// Controls the \"cyclomatic complexity\" threshold for the clippy tool.\n#[clippy::cyclomatic_complexity = \"100\"]\npub fn f() {}\n```\n\n----------------------------------------\n\nTITLE: Initializing a Union in Rust\nDESCRIPTION: This snippet shows how to create an instance of the union 'MyUnion' by initializing it with one of its fields. The storage is initialized with field 'f1'.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/unions.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# union MyUnion { f1: u32, f2: f32 }\n#\nlet u = MyUnion { f1: 1 };\n```\n\n----------------------------------------\n\nTITLE: Function Lifetime Elision Examples in Rust\nDESCRIPTION: This snippet showcases various examples of lifetime elision in function signatures in Rust. It demonstrates both elided and expanded versions of function declarations, illustrating how the compiler infers lifetimes.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/lifetime-elision.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n# trait T {}\n# trait ToCStr {}\n# struct Thing<'a> {f: &'a i32}\n# struct Command;\n#\n# trait Example {\nfn print1(s: &str);                                   // elided\nfn print2(s: &'_ str);                                // also elided\nfn print3<'a>(s: &'a str);                            // expanded\n\nfn debug1(lvl: usize, s: &str);                       // elided\nfn debug2<'a>(lvl: usize, s: &'a str);                // expanded\n\nfn substr1(s: &str, until: usize) -> &str;            // elided\nfn substr2<'a>(s: &'a str, until: usize) -> &'a str;  // expanded\n\nfn get_mut1(&mut self) -> &mut dyn T;                 // elided\nfn get_mut2<'a>(&'a mut self) -> &'a mut dyn T;       // expanded\n\nfn args1<T: ToCStr>(&mut self, args: &[T]) -> &mut Command;                  // elided\nfn args2<'a, 'b, T: ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command; // expanded\n\nfn other_args1<'a>(arg: &str) -> &'a str;             // elided\nfn other_args2<'a, 'b>(arg: &'b str) -> &'a str;      // expanded\n\nfn new1(buf: &mut [u8]) -> Thing<'_>;                 // elided - preferred\nfn new2(buf: &mut [u8]) -> Thing;                     // elided\nfn new3<'a>(buf: &'a mut [u8]) -> Thing<'a>;          // expanded\n# }\n\ntype FunPtr1 = fn(&str) -> &str;                      // elided\ntype FunPtr2 = for<'a> fn(&'a str) -> &'a str;        // expanded\n\ntype FunTrait1 = dyn Fn(&str) -> &str;                // elided\ntype FunTrait2 = dyn for<'a> Fn(&'a str) -> &'a str;  // expanded\n```\n```\n\n----------------------------------------\n\nTITLE: Invalid Reference Pattern Example\nDESCRIPTION: Shows a reference pattern that is rejected in Rust 2024 edition because it appears when the default binding mode is not \"move\".\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nlet [&x] = &[&()]; //~ ERROR\n```\n\n----------------------------------------\n\nTITLE: Incorrect Stack Usage with nostack Option\nDESCRIPTION: Example demonstrating that using stack operations (push/pop) with the nostack option leads to undefined behavior.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_40\n\nLANGUAGE: rust\nCODE:\n```\n// `push` and `pop` are UB when used with nostack\nunsafe { core::arch::asm!(\"push rax\", \"pop rax\", options(nostack)); }\n```\n\n----------------------------------------\n\nTITLE: Register Type Validation Example\nDESCRIPTION: Demonstrates valid register class usage for different types (i32, i8, __m128i) in x86_64 assembly.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 5i32;\nlet y = -1i8;\nlet z = unsafe { core::arch::x86_64::_mm_set_epi64x(1, 0) };\n\n// reg is valid for `i32`, `reg_byte` is valid for `i8`, and xmm_reg is valid for `__m128i`\n// We can't use `tmm0` as an input or output, but we can clobber it.\nunsafe { core::arch::asm!(\"/* {} {} {} */\", in(reg) x, in(reg_byte) y, in(xmm_reg) z, out(\"tmm0\") _); }\n```\n\n----------------------------------------\n\nTITLE: Generic Parameter Shadowing Errors in Rust Traits\nDESCRIPTION: This example illustrates that it's an error to shadow generic parameters in trait definitions in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/names/scopes.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\ntrait SomeTrait<'a, T, const N: usize> {\n    fn example_lifetime<'a>() {} // ERROR: 'a is already in use\n    fn example_type<T>() {} // ERROR: T is already in use\n    fn example_const<const N: usize>() {} // ERROR: N is already in use\n    fn example_mixed<const T: usize>() {} // ERROR: T is already in use\n}\n```\n\n----------------------------------------\n\nTITLE: No_std attribute usage in Rust\nDESCRIPTION: Shows the use of the no_std attribute at the crate level to prevent the std crate from being automatically added to the scope.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/names/preludes.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![no_std]\n```\n\n----------------------------------------\n\nTITLE: Invalid Binding Mode Examples\nDESCRIPTION: Shows patterns that are rejected in Rust 2024 edition because they explicitly specify binding modes when the default binding mode is not \"move\".\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet [mut x] = &[()]; //~ ERROR\nlet [ref x] = &[()]; //~ ERROR\nlet [ref mut x] = &mut [()]; //~ ERROR\n```\n\n----------------------------------------\n\nTITLE: Example of FIRST and LAST Sets in Tree Structure\nDESCRIPTION: A detailed example showing how FIRST sets are composed for a complex macro pattern. The example demonstrates how analysis of each component builds up to the final FIRST set for the entire matcher pattern.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macro-ambiguity.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g\n            ~~~~~~~~   ~~~~~~~                ~\n                |         |                   |\nFIRST:   { $d:ident }  { $e:expr }          { h }\n\n\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+\n            ~~~~~~~~~~~~~~~~~~             ~~~~~~~           ~~~\n                        |                      |               |\nFIRST:          { $d:ident }               { h, ε }         { f }\n\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~    ~~~~~~~~~   ~\n                        |                       |              |       |\nFIRST:        { $d:ident, ε }            {  h, ε, ;  }      { f }   { g }\n\n\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                                        |\nFIRST:                       { $d:ident, h, ;,  f }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pure Option Requirement Error\nDESCRIPTION: Shows a compile-time error when using the pure option without any outputs. Pure assembly blocks must have at least one non-discarded output.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_43\n\nLANGUAGE: rust\nCODE:\n```\n// pure blocks need at least one output\nunsafe { core::arch::asm!(\"\", options(pure)); }\n// ERROR: asm with the `pure` option must have at least one output\n```\n\n----------------------------------------\n\nTITLE: Grammar for Type Parameter Bounds in Rust\nDESCRIPTION: This snippet defines the grammar for specifying type parameter bounds in Rust, including trait bounds, lifetime bounds, and use bounds. It shows how these bounds are combined using the `+` operator and how optional bounds are indicated with `?`.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/trait-bounds.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar,miscellaneous\nCODE:\n```\n\"TypeParamBounds -> TypeParamBound ( `+` TypeParamBound )* `+`?\\n\\nTypeParamBound -> Lifetime | TraitBound | UseBound\\n\\nTraitBound ->\n      ( `?` | ForLifetimes )? TypePath\n    | `(` ( `?` | ForLifetimes )? TypePath `)`\\n\\nLifetimeBounds -> ( Lifetime `+` )* Lifetime?\\n\\nLifetime ->\n      LIFETIME_OR_LABEL\n    | `'static`\n    | `'_`\\n\\nUseBound -> `use` UseBoundGenericArgs\\n\\nUseBoundGenericArgs ->\n      `<` `>`\n    | `<` ( UseBoundGenericArg `,`)* UseBoundGenericArg `,`? `>`\\n\\nUseBoundGenericArg ->\n      Lifetime\n    | IDENTIFIER\n    | `Self`\"\n```\n\n----------------------------------------\n\nTITLE: Type Path with Turbofish Example in Rust\nDESCRIPTION: Provides an example of using type paths in Rust with and without the turbofish syntax, highlighting usage within trait and type implementations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/paths.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n# mod ops {\n#     pub struct Range<T> {f1: T}\n#     pub trait Index<T> {}\n#     pub struct Example<'a> {f1: &'a i32}\n# }\n# struct S;\nimpl ops::Index<ops::Range<usize>> for S { /*...*/ }\nfn i<'a>() -> impl Iterator<Item = ops::Example<'a>> {\n    // ...\n#    const EXAMPLE: Vec<ops::Example<'static>> = Vec::new();\n#    EXAMPLE.into_iter()\n}\ntype G = std::boxed::Box<dyn std::ops::FnOnce(isize) -> isize>;\n```\n\n----------------------------------------\n\nTITLE: Dereference Expression Grammar\nDESCRIPTION: Defines the syntax for dereference expressions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_6\n\nLANGUAGE: grammar\nCODE:\n```\nDereferenceExpression -> `*` Expression\n```\n\n----------------------------------------\n\nTITLE: Defining Invalid Values for String Slices in Rust\nDESCRIPTION: States that a str value in Rust is treated like a byte slice ([u8]) and must be initialized. Uninitialized string slices are invalid.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/behavior-considered-undefined.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n* A `str` value is treated like `[u8]`, i.e. it must be initialized.\n```\n\n----------------------------------------\n\nTITLE: Parameter Patterns in Associated Functions Without Body\nDESCRIPTION: Example of allowed parameter patterns in trait associated functions without implementation bodies. Only identifiers and wildcards are permitted in these function declarations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/traits.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\ntrait T {\n    fn f1(&self);\n    fn f2(x: Self, _: i32);\n}\n```\n\n----------------------------------------\n\nTITLE: Path-Based Macro Scope Example\nDESCRIPTION: Shows how macro_export enables path-based scope for macros, making them available in the crate root scope.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros-by-example.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nself::m!();\nm!(); // OK: Path-based lookup finds m in the current module.\n\nmod inner {\n    super::m!();\n    crate::m!();\n}\n\nmod mac {\n    #[macro_export]\n    macro_rules! m {\n        () => {};\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Invalid Values for Unions in Rust\nDESCRIPTION: Explains that the exact validity requirements for unions in Rust are not fully decided. It mentions that all values creatable in safe code are valid, and unions with zero-sized fields consider all values valid.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/behavior-considered-undefined.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n* For a `union`, the exact validity requirements are not decided yet.\n  Obviously, all values that can be created entirely in safe code are valid.\n  If the union has a zero-sized field, then every possible value is valid.\n  Further details are [still being debated](https://github.com/rust-lang/unsafe-code-guidelines/issues/438).\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Markdown Link Formatting in Rust Reference\nDESCRIPTION: Shows the preferred style for creating reference links in Markdown, including shortcut links and reference links with labels. Link definitions are placed at the bottom of the file or section.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/docs/authoring.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nExample of shortcut link: [enumerations]\nExample of reference link with label: [block expression][block]\n\n[block]: expressions/block-expr.md\n[enumerations]: types/enum.md\n```\n\n----------------------------------------\n\nTITLE: Defining Invalid Values for Wide Pointers in Rust\nDESCRIPTION: Explains the validity requirements for metadata of wide references, Box<T>, and raw pointers in Rust. It covers requirements for trait objects and slices, including size limitations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/behavior-considered-undefined.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n* The metadata of a wide reference, [`Box<T>`], or raw pointer must match\n  the type of the unsized tail:\n  * `dyn Trait` metadata must be a pointer to a compiler-generated vtable for `Trait`.\n    (For raw pointers, this requirement remains a subject of some debate.)\n  * Slice (`[T]`) metadata must be a valid `usize`.\n    Furthermore, for wide references and [`Box<T>`], slice metadata is invalid\n    if it makes the total size of the pointed-to value bigger than `isize::MAX`.\n```\n\n----------------------------------------\n\nTITLE: Complex x87 FPU Operation with Stack Clobbering\nDESCRIPTION: Demonstrates a floating-point addition using x87 FPU instructions while properly clobbering the entire x87 register stack. This example follows the rule that if all x87 registers are clobbered, assembly code must ensure the x87 register stack is empty when exiting.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_46\n\nLANGUAGE: rust\nCODE:\n```\npub fn fadd(x: f64, y: f64) -> f64 {\n  let mut out = 0f64;\n  let mut top = 0u16;\n  // we can do complex stuff with x87 if we clobber the entire x87 stack\n  unsafe { core::arch::asm!(\n    \"fld qword ptr [{x}]\",\n    \"fld qword ptr [{y}])\",\n    \"faddp\",\n    \"fstp qword ptr [{out}]\",\n    \"xor eax, eax\",\n    \"fstsw ax\",\n    \"shl eax, 11\",\n    x = in(reg) &x,\n    y = in(reg) &y,\n    out = in(reg) &mut out,\n    out(\"st(0)\") _, out(\"st(1)\") _, out(\"st(2)\") _, out(\"st(3)\") _,\n    out(\"st(4)\") _, out(\"st(5)\") _, out(\"st(6)\") _, out(\"st(7)\") _,\n    out(\"eax\") top\n  );}\n\n  assert_eq!(top & 0x7, 0);\n  out\n}\n\npub fn main() {\n  assert_eq!(fadd(1.0, 1.0), 2.0);\n```\n\n----------------------------------------\n\nTITLE: Range Pattern Grammar Definition\nDESCRIPTION: Formal grammar specification for Rust's range pattern syntax including exclusive, inclusive, from, and to patterns.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_13\n\nLANGUAGE: grammar\nCODE:\n```\nRangePattern ->\n      RangeExclusivePattern\n    | RangeInclusivePattern\n    | RangeFromPattern\n    | RangeToExclusivePattern\n    | RangeToInclusivePattern\n    | ObsoleteRangePattern\n\nRangeExclusivePattern ->\n      RangePatternBound `..` RangePatternBound\n\nRangeInclusivePattern ->\n      RangePatternBound `..=` RangePatternBound\n\nRangeFromPattern ->\n      RangePatternBound `..`\n\nRangeToExclusivePattern ->\n      `..` RangePatternBound\n\nRangeToInclusivePattern ->\n      `..=` RangePatternBound\n\nObsoleteRangePattern ->\n    RangePatternBound `...` RangePatternBound\n\nRangePatternBound ->\n      CHAR_LITERAL\n    | BYTE_LITERAL\n    | `-`? INTEGER_LITERAL\n    | `-`? FLOAT_LITERAL\n    | PathExpression\n```\n\n----------------------------------------\n\nTITLE: Unsafe Static Variable Operations in Rust\nDESCRIPTION: Specification that reading or writing mutable or external static variables is considered unsafe in Rust's memory model.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/unsafety.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n- Reading or writing a [mutable] or [external] static variable.\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated Attributes in Rust\nDESCRIPTION: Illustrates the use of the deprecated attribute in Rust to mark functions as deprecated. Includes syntax options for adding custom messages and versioning information. The example requires a Rust compiler to observe compiler warnings when deprecated items are used.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/diagnostics.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n#[deprecated(since = \"5.2.0\", note = \"foo was rarely used. Users should instead use bar\")]\npub fn foo() {}\n\npub fn bar() {}\n```\n\n----------------------------------------\n\nTITLE: Float Widening Cast in Rust\nDESCRIPTION: Shows lossless casting from f32 to f64 including special values.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\nassert_eq!(1_234.5f32 as f64, 1_234.5f64);\nassert_eq!(std::f32::INFINITY as f64, std::f64::INFINITY);\nassert!((std::f32::NAN as f64).is_nan());\n```\n\n----------------------------------------\n\nTITLE: Defining Invalid Values for Custom Range Types in Rust\nDESCRIPTION: Specifies that types with custom valid value ranges in Rust must contain values within that range to be considered valid. It mentions NonNull<T> and NonZero<T> as examples from the standard library.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/behavior-considered-undefined.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n* If a type has a custom range of a valid values, then a valid value must be in that range.\n  In the standard library, this affects [`NonNull<T>`] and [`NonZero<T>`].\n\n  > [!NOTE]\n  > `rustc` achieves this with the unstable `rustc_layout_scalar_valid_range_*` attributes.\n```\n\n----------------------------------------\n\nTITLE: Specifying Crate Type as Rust Library File in Rust\nDESCRIPTION: Illustrates how to specify a crate type as a Rust library file using either a command-line flag or a crate attribute. This creates an intermediate artifact used by the compiler for future linkage.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/linkage.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n--crate-type=rlib\n```\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_type = \"rlib\"]\n```\n\n----------------------------------------\n\nTITLE: Function Parameter Drop Order in Rust\nDESCRIPTION: Illustrates how drop order works for function parameters with patterns. Function parameters are dropped after the function body in reverse order of declaration, with nested bindings dropped before their containing parameter.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/destructors.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# struct PrintOnDrop(&'static str);\n# impl Drop for PrintOnDrop {\n#     fn drop(&mut self) {\n#         println!(\"drop({})\", self.0);\n#     }\n# }\n// Drops `y`, then the second parameter, then `x`, then the first parameter\nfn patterns_in_parameters(\n    (x, _): (PrintOnDrop, PrintOnDrop),\n    (_, y): (PrintOnDrop, PrintOnDrop),\n) {}\n\n// drop order is 3 2 0 1\npatterns_in_parameters(\n    (PrintOnDrop(\"0\"), PrintOnDrop(\"1\")),\n    (PrintOnDrop(\"2\"), PrintOnDrop(\"3\")),\n);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Control Flow in Async Blocks\nDESCRIPTION: Shows an example of illegal use of the 'break' keyword inside an async block.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/block-expr.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nloop {\n    async move {\n        break; // error[E0267]: `break` inside of an `async` block\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: JavaScript Redirect for Hash Fragments\nDESCRIPTION: This JavaScript code handles redirects based on hash fragments in the URL. It's used to maintain compatibility with older links that may use different URL structures.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/glossary.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n(function() {\n    var fragments = {\n        \"#object-safe-traits\": \"glossary.html#dyn-compatible-traits\",\n    };\n    var target = fragments[window.location.hash];\n    if (target) {\n        var url = window.location.toString();\n        var base = url.substring(0, url.lastIndexOf('/'));\n        window.location.replace(base + \"/\" + target);\n    }\n})();\n```\n\n----------------------------------------\n\nTITLE: Specifying Reserved Prefixes in Rust Syntax\nDESCRIPTION: This grammar rule defines reserved prefixes that are ignored or used in future language updates, like reserved double and single quote tokens and pound tokens. These prefixes are blocked or divided into multiple tokens starting from the 2021 edition of Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_15\n\nLANGUAGE: grammar,lexer\nCODE:\n```\nRESERVED_TOKEN_DOUBLE_QUOTE ->\n    ( IDENTIFIER_OR_KEYWORD _except `b` or `c` or `r` or `br` or `cr`_ | `_` ) `\"`\n\nRESERVED_TOKEN_SINGLE_QUOTE ->\n    ( IDENTIFIER_OR_KEYWORD _except `b`_ | `_` ) `'`\n\nRESERVED_TOKEN_POUND ->\n    ( IDENTIFIER_OR_KEYWORD _except `r` or `br` or `cr`_ | `_` ) `#`\n\nRESERVED_TOKEN_LIFETIME ->\n    `'` ( IDENTIFIER_OR_KEYWORD _except `r`_ | `_` ) `#`\n```\n\n----------------------------------------\n\nTITLE: Defining Invalid Values for Never Type in Rust\nDESCRIPTION: States that a value of the never type (!) must never exist in Rust. This type is used to represent computations that never complete.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/behavior-considered-undefined.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n* A `!` value must never exist.\n```\n\n----------------------------------------\n\nTITLE: Macro Variable Scope Example\nDESCRIPTION: Shows how macro-defined variables are not shared between invocations, resulting in compilation errors.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros-by-example.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! m {\n    (define) => {\n        let x = 1;\n    };\n    (refer) => {\n        dbg!(x);\n    };\n}\n\nm!(define);\nm!(refer);\n```\n\n----------------------------------------\n\nTITLE: Using Struct Field Init Shorthand in Rust\nDESCRIPTION: Illustrates the use of struct field init shorthand syntax in Rust, which allows for more compact struct initialization when variable names match field names.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/struct-expr.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# struct Point3d { x: i32, y: i32, z: i32 }\n# let x = 0;\n# let y_value = 0;\n# let z = 0;\nPoint3d { x: x, y: y_value, z: z };\nPoint3d { x, y: y_value, z };\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic C Runtime Linkage in Rust\nDESCRIPTION: Command line example showing how to enable dynamic runtime linkage using rustc's target-feature flag\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/linkage.md#2025-04-21_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nrustc -C target-feature=-crt-static foo.rs\n```\n\n----------------------------------------\n\nTITLE: Byte String Literal Grammar Definition\nDESCRIPTION: Specifies the grammar rules for byte string literals, including ASCII characters and escape sequences.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_1\n\nLANGUAGE: grammar\nCODE:\n```\nBYTE_STRING_LITERAL ->\n    `b\"` ( ASCII_FOR_STRING | BYTE_ESCAPE | STRING_CONTINUE )* `\"` SUFFIX?\n\nASCII_FOR_STRING ->\n    <any ASCII (i.e 0x00 to 0x7F) except `\"`, `\\`, or CR>\n```\n\n----------------------------------------\n\nTITLE: Defining Floating-Point Literal Grammar in Rust\nDESCRIPTION: This grammar defines the syntax for floating-point literals in Rust, including decimal and exponential representations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_9\n\nLANGUAGE: grammar\nCODE:\n```\nFLOAT_LITERAL ->\n      DEC_LITERAL `.` _not immediately followed by `.`, `_` or an XID_Start character_\n    | DEC_LITERAL `.` DEC_LITERAL SUFFIX_NO_E?\n    | DEC_LITERAL (`.` DEC_LITERAL)? FLOAT_EXPONENT SUFFIX?\n\nFLOAT_EXPONENT ->\n    (`e`|`E`) (`+`|`-`)? (DEC_DIGIT|`_`)* DEC_DIGIT (DEC_DIGIT|`_`)*\n```\n\n----------------------------------------\n\nTITLE: Byte Literal Expressions in Rust\nDESCRIPTION: Defines the rules for parsing and representing single byte character literals with their Unicode scalar value representation\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/literal-expr.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nb'R';                              // 82\nb'\\'';                             // 39\nb'\\x52';                           // 82\nb'\\xA0';                           // 160\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Shebang Removal in Rust\nDESCRIPTION: This code snippet shows an example of a Rust file with a shebang line. The shebang line would be ignored during processing, allowing the main function to be executed normally.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/input-format.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#!/usr/bin/env rustx\n\nfn main() {\n    println!(\"Hello!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Markdown Header for Appendices Section\nDESCRIPTION: A top-level markdown header marking the beginning of the appendices section in the Rust language reference documentation.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/appendices.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Appendices\n```\n\n----------------------------------------\n\nTITLE: Lifetime Bound Demonstration in Rust\nDESCRIPTION: This snippet demonstrates how lifetime bounds ensure that one lifetime outlives another. It shows that if `'a: 'b`, then `&'a i32` is a subtype of `&'b i32`, and a reference `&'b &'a i32` is well-formed because `'a` outlives `'b`.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/trait-bounds.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n\"fn f<'a, 'b>(x: &'a i32, mut y: &'b i32) where 'a: 'b {\n    y = x;                      // &'a i32 is a subtype of &'b i32 because 'a: 'b\n    let r: &'b &'a i32 = &&0;   // &'b &'a i32 is well formed because 'a: 'b\n}\"\n```\n\n----------------------------------------\n\nTITLE: Defining Invalid Values for Structs, Tuples, and Arrays in Rust\nDESCRIPTION: States that all fields or elements of a struct, tuple, or array in Rust must be valid for their respective types. Invalid field values make the entire structure invalid.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/behavior-considered-undefined.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n* A `struct`, tuple, and array requires all fields/elements to be valid at their respective type.\n```\n\n----------------------------------------\n\nTITLE: Macro Export Visibility Example\nDESCRIPTION: Shows how $crate affects macro resolution but not visibility rules for referenced items.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros-by-example.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n#[macro_export]\nmacro_rules! call_foo {\n    () => { $crate::foo() };\n}\n\nfn foo() {}\n```\n\n----------------------------------------\n\nTITLE: Unsafe Attribute Application in Rust\nDESCRIPTION: Documentation specifying that applying unsafe attributes to items is considered an unsafe operation.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/unsafety.md#2025-04-21_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n- Applying an [unsafe attribute] to an item.\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of noreturn Option\nDESCRIPTION: Example demonstrating undefined behavior when noreturn is specified but the assembly code does fall through.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_38\n\nLANGUAGE: rust\nCODE:\n```\n// You are responsible for not falling past the end of a noreturn asm block\nunsafe { core::arch::asm!(\"\", options(noreturn)); }\n```\n\n----------------------------------------\n\nTITLE: Defining a Macro-by-Example in Rust\nDESCRIPTION: Example of defining a macro-by-example (MBE) in Rust, demonstrating matcher syntax, simple and complex non-terminals, and delimited sequences.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macro-ambiguity.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! i_am_an_mbe {\n    (start $foo:expr $($i:ident),* end) => ($foo)\n}\n```\n\n----------------------------------------\n\nTITLE: Macro Handling of Reserved Prefixes in Rust 2021 Edition\nDESCRIPTION: These examples demonstrate how macros interpret reserved prefixes differently across language editions in Rust. Starting from the 2021 edition, specific identifiers followed directly by `#`, `'`, or `\"` are flagged as errors, preventing their passage to macros. The code illustrates macros that function prior to 2021 but are rejected afterward.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_16\n\nLANGUAGE: rust,edition2018\nCODE:\n```\nmacro_rules! lexes {($($_:tt)*) => {}}\nlexes!{a#foo}\nlexes!{continue'foo}\nlexes!{match\"...\" {}}\nlexes!{'prefix#lt}\n```\n\n----------------------------------------\n\nTITLE: Defining Underscore Expression Syntax in Rust\nDESCRIPTION: Specifies the grammar for underscore expressions in Rust, which are represented by a single underscore character.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/underscore-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nUnderscoreExpression -> `_`\n```\n\n----------------------------------------\n\nTITLE: Defining cfg Attribute Syntax in Rust\nDESCRIPTION: Specifies the grammar for the cfg attribute in Rust, which is used for conditional compilation based on configuration predicates.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/conditional-compilation.md#2025-04-21_snippet_1\n\nLANGUAGE: grammar\nCODE:\n```\nCfgAttribute -> `cfg` `(` ConfigurationPredicate `)`\n```\n\n----------------------------------------\n\nTITLE: Compile-Time Errors with Overlapping Registers - Rust\nDESCRIPTION: This example details the compile-time errors that occur when overlapping registers are specified for input and output operands in inline assembly, emphasizing the need for unique register references.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(target_arch = \"x86_64\")] {\nlet x = 5;\n// al overlaps with ax, so we can't name both of them.\nunsafe { core::arch::asm!(\"\", in(\"ax\") 5, in(\"al\") 4i8); }\n// ERROR: register `al` conflicts with register `ax`\n# }\n# #[cfg(not(target_arch = \"x86_64\"))] core::compile_error!(\"Test not supported on this arch\");\n```\n\n----------------------------------------\n\nTITLE: Serving Rust Reference with Live Reload\nDESCRIPTION: Command to serve the Rust Language Reference with a live webserver that automatically rebuilds and reloads on source file changes. The SPEC_RELATIVE environment variable is set for absolute standard library links.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/README.md#2025-04-21_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nSPEC_RELATIVE=0 mdbook serve --open\n```\n\n----------------------------------------\n\nTITLE: Capturing Unaligned Struct Fields in Rust Closures\nDESCRIPTION: Demonstrates how closures capture unaligned fields in packed structs, showing that the entire struct is captured to avoid undefined behavior.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(packed)]\nstruct T(i32, i32);\n\nlet t = T(2, 5);\nlet c = || {\n    let a = t.0; // captures `t` with ImmBorrow\n};\n// Copies out of `t` are ok.\nlet (a, b) = (t.0, t.1);\nc();\n```\n\n----------------------------------------\n\nTITLE: Noting Uninitialized Memory Invalidity in Rust\nDESCRIPTION: Explains that uninitialized memory is implicitly invalid for types with restricted valid value sets in Rust. Reading uninitialized memory is only permitted inside unions and in padding between fields.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/behavior-considered-undefined.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n**Note:** Uninitialized memory is also implicitly invalid for any type that has\na restricted set of valid values. In other words, the only cases in which\nreading uninitialized memory is permitted are inside `union`s and in \"padding\"\n(the gaps between the fields of a type).\n```\n\n----------------------------------------\n\nTITLE: Admonition Block Examples in Markdown\nDESCRIPTION: Examples of GitHub-flavored markdown admonitions for warnings and notes, which are styled using reference.css and transformed using mdbook-spec.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/docs/authoring.md#2025-04-21_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n> [!WARNING]\n> This is a warning.\n\n> [!NOTE]\n> This is a note.\n```\n\n----------------------------------------\n\nTITLE: Defining Reserved Guards Grammar in Rust's Lexical Syntax\nDESCRIPTION: Grammar definition for reserved guard tokens in Rust, including reserved guarded string literals (one or more # followed by a string literal) and reserved pounds (two or more # characters).\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_17\n\nLANGUAGE: grammar\nCODE:\n```\nRESERVED_GUARDED_STRING_LITERAL -> `#`+ STRING_LITERAL\n\nRESERVED_POUNDS -> `#`{2..}\n```\n\n----------------------------------------\n\nTITLE: Implementing GDB Pretty Printer in Rust\nDESCRIPTION: Example showing how to use the debugger_visualizer attribute with a GDB pretty printer script. Demonstrates custom visualization of a Person struct in GDB.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/debugger.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![debugger_visualizer(gdb_script_file = \"printer.py\")]\n\nstruct Person {\n    name: String,\n    age: i32,\n}\n\nfn main() {\n    let bob = Person { name: String::from(\"Bob\"), age: 10 };\n    println!(\"set breakpoint here\");\n}\n```\n\nLANGUAGE: python\nCODE:\n```\nimport gdb\n\nclass PersonPrinter:\n    \"Print a Person\"\n\n    def __init__(self, val):\n        self.val = val\n        self.name = val[\"name\"]\n        self.age = int(val[\"age\"])\n\n    def to_string(self):\n        return \"{} is {} years old.\".format(self.name, self.age)\n\ndef lookup(val):\n    lookup_tag = val.type.tag\n    if lookup_tag is None:\n        return None\n    if \"foo::Person\" == lookup_tag:\n        return PersonPrinter(val)\n\n    return None\n\ngdb.current_objfile().pretty_printers.append(lookup)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating pattern matching limitations with non_exhaustive types\nDESCRIPTION: This code snippet shows the restrictions on pattern matching when using non_exhaustive types outside the defining crate. It illustrates the need for wildcard patterns and the inability to match exhaustively.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/type_system.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// These are types defined in an upstream crate that have been annotated as\n// `#[non_exhaustive]`.\nuse upstream::{Config, Token, Id, Error, Message};\n\n// Cannot match on a non-exhaustive enum without including a wildcard arm.\nmatch error {\n  Error::Message(ref s) => { },\n  Error::Other => { },\n  // would compile with: `_ => {},`\n}\n\n// Cannot match on a non-exhaustive struct without a wildcard.\nif let Ok(Config { window_width, window_height }) = config {\n    // would compile with: `..`\n}\n\n// Cannot match a non-exhaustive unit-like or tuple struct except by using\n// braced struct syntax with a wildcard.\n// This would compile as `let Token { .. } = token;`\nlet Token = token;\n// This would compile as `let Id { 0: id_number, .. } = id;`\nlet Id(id_number) = id;\n\nmatch message {\n  // Cannot match on a non-exhaustive struct enum variant without including a wildcard.\n  Message::Send { from, to, contents } => { },\n  // Cannot match on a non-exhaustive tuple or unit enum variant.\n  Message::Reaction(type) => { },\n  Message::Quit => { },\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Type Conversion Example\nDESCRIPTION: Demonstrates invalid attempt to reinterpret between i32 and f32 types in assembly.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nlet x: i32 = 0;\nlet y: f32;\n// But we can't reinterpret an `i32` to an `f32` like this\nunsafe { core::arch::asm!(\"/* {} */\", inout(reg) x=>y); }\n// ERROR: incompatible types for asm inout argument\n```\n\n----------------------------------------\n\nTITLE: Listing Influences on Rust in Markdown\nDESCRIPTION: A markdown-formatted list detailing the programming languages, concepts, and technologies that have influenced Rust's design. Each item includes the source and the specific features or concepts adopted or inspired by Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/influences.md#2025-04-21_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n* SML, OCaml: algebraic data types, pattern matching, type inference,\n  semicolon statement separation\n* C++: references, RAII, smart pointers, move semantics, monomorphization,\n  memory model\n* ML Kit, Cyclone: region based memory management\n* Haskell (GHC): typeclasses, type families\n* Newsqueak, Alef, Limbo: channels, concurrency\n* Erlang: message passing, thread failure, <strike>linked thread failure</strike>,\n  <strike>lightweight concurrency</strike>\n* Swift: optional bindings\n* Scheme: hygienic macros\n* C#: attributes\n* Ruby: closure syntax, <strike>block syntax</strike>\n* NIL, Hermes: <strike>typestate</strike>\n* [Unicode Annex #31](http://www.unicode.org/reports/tr31/): identifier and\n  pattern syntax\n```\n\n----------------------------------------\n\nTITLE: Defining Const Block Expression Grammar in Rust\nDESCRIPTION: Specifies the grammar for const block expressions in Rust.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/block-expr.md#2025-04-21_snippet_5\n\nLANGUAGE: grammar\nCODE:\n```\nConstBlockExpression -> `const` BlockExpression\n```\n\n----------------------------------------\n\nTITLE: Character Literal Examples in Rust\nDESCRIPTION: Shows different ways to represent characters in Rust, including regular characters, escaped characters, hexadecimal representation, and Unicode characters.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/literal-expr.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n'R';                               // R\n'\\'';                              // '\n'\\x52';                            // R\n'\\u{00E6}';                        // LATIN SMALL LETTER AE (U+00E6)\n```\n\n----------------------------------------\n\nTITLE: Cloning Rust Language Reference Repository\nDESCRIPTION: Git command to clone the Rust Language Reference repository from GitHub to the local machine.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/README.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ngit clone https://github.com/rust-lang/reference.git\n```\n\n----------------------------------------\n\nTITLE: Explaining type_length_limit attribute usage in Rust\nDESCRIPTION: This example illustrates the type_length_limit attribute, which restricts the number of type substitutions during monomorphization. It sets the limit to 4 and shows a case where this limit is exceeded.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/limits.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![type_length_limit = \"4\"]\n\nfn f<T>(x: T) {}\n\n// This fails to compile because monomorphizing to\n// `f::<((((i32,), i32), i32), i32)>` requires more than 4 type elements.\nf(((((1,), 2), 3), 4));\n```\n\n----------------------------------------\n\nTITLE: Implementing collapse_debuginfo Attribute in Rust\nDESCRIPTION: Example showing how to use the collapse_debuginfo attribute to control debug information generation for macro definitions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/debugger.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[collapse_debuginfo(yes)]\nmacro_rules! example {\n    () => {\n        println!(\"hello!\");\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Crate Type as Static Library in Rust\nDESCRIPTION: Demonstrates how to specify a crate type as a static system library using either a command-line flag or a crate attribute. This creates a static library containing all local crate code and upstream dependencies.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/linkage.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n--crate-type=staticlib\n```\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_type = \"staticlib\"]\n```\n\n----------------------------------------\n\nTITLE: Failing Example of pure Option Without Memory Constraints\nDESCRIPTION: Example showing that the pure option must be combined with either nomem or readonly to specify memory access behavior.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_31\n\nLANGUAGE: rust\nCODE:\n```\nlet x: i32 = 0;\nlet z: i32;\n// Either nomem or readonly must be satisfied, to indicate whether or not\n// memory is allowed to be read\nunsafe { core::arch::asm!(\"inc {}\", inout(reg) x => z, options(pure)); }\n// ERROR: the `pure` option must be combined with either `nomem` or `readonly`\nassert_eq!(z, 0);\n```\n\n----------------------------------------\n\nTITLE: Markdown Redirect Notice\nDESCRIPTION: A markdown formatted message informing users about the relocation of the Rust Reference documentation to a new structure with multiple chapters.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/reference.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n% The Rust Reference has moved\n\nWe've split up the reference into chapters. Please find it at its new\nhome [here](reference/index.html).\n```\n\n----------------------------------------\n\nTITLE: Documenting RISC-V Target Features in Markdown\nDESCRIPTION: A markdown table listing RISC-V target features for both riscv32 and riscv64 architectures. It includes feature names, implicit dependencies, and brief descriptions, covering various RISC-V extensions like atomic instructions, bit manipulation, and cryptography.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/codegen.md#2025-04-21_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\nFeature     | Implicitly Enables  | Description\n------------|---------------------|-------------------\n`a`         |                     | [A][rv-a] --- Atomic instructions\n`c`         |                     | [C][rv-c] --- Compressed instructions\n`m`         |                     | [M][rv-m] --- Integer Multiplication and Division instructions\n`zb`        | `zba`, `zbc`, `zbs` | [Zb][rv-zb] --- Bit Manipulation instructions\n`zba`       |                     | [Zba][rv-zb-zba] --- Address Generation instructions\n`zbb`       |                     | [Zbb][rv-zb-zbb] --- Basic bit-manipulation\n`zbc`       |                     | [Zbc][rv-zb-zbc] --- Carry-less multiplication\n`zbkb`      |                     | [Zbkb][rv-zb-zbkb] --- Bit Manipulation Instructions for Cryptography\n`zbkc`      |                     | [Zbkc][rv-zb-zbc] --- Carry-less multiplication for Cryptography\n`zbkx`      |                     | [Zbkx][rv-zb-zbkx] --- Crossbar permutations\n`zbs`       |                     | [Zbs][rv-zb-zbs] --- Single-bit instructions\n`zk`        | `zkn`, `zkr`, `zks`, `zkt`, `zbkb`, `zbkc`, `zkbx` | [Zk][rv-zk] --- Scalar Cryptography\n`zkn`       | `zknd`, `zkne`, `zknh`, `zbkb`, `zbkc`, `zkbx`     | [Zkn][rv-zkn] --- NIST Algorithm suite extension\n`zknd`      |                                                    | [Zknd][rv-zknd] --- NIST Suite: AES Decryption\n`zkne`      |                                                    | [Zkne][rv-zkne] --- NIST Suite: AES Encryption\n`zknh`      |                                                    | [Zknh][rv-zknh] --- NIST Suite: Hash Function Instructions\n`zkr`       |                                                    | [Zkr][rv-zkr] --- Entropy Source Extension\n`zks`       | `zksed`, `zksh`, `zbkb`, `zbkc`, `zkbx`            | [Zks][rv-zks] --- ShangMi Algorithm Suite\n`zksed`     |                                                    | [Zksed][rv-zksed] --- ShangMi Suite: SM4 Block Cipher Instructions\n`zksh`      |                                                    | [Zksh][rv-zksh] --- ShangMi Suite: SM3 Hash Function Instructions\n`zkt`       |                                                    | [Zkt][rv-zkt] --- Data Independent Execution Latency Subset\n```\n\n----------------------------------------\n\nTITLE: Let Statement Syntax in Rust Grammar\nDESCRIPTION: This grammar definition captures the structure of a let statement in Rust, detailing its components such as attributes, patterns, type annotations, and initializer expressions.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/statements.md#2025-04-21_snippet_2\n\nLANGUAGE: grammar\nCODE:\n```\nLetStatement ->\n    OuterAttribute* `let` PatternNoTopAlt ( `:` Type )?\n    (\n          `=` Expression\n        | `=` Expression _except [LazyBooleanExpression] or end with a `}`_ `else` BlockExpression\n    )? `;`\n```\n\n----------------------------------------\n\nTITLE: Using Template Modifiers in Rust Inline Assembly\nDESCRIPTION: This snippet highlights the rule that only a single template modifier can be specified per placeholder in Rust inline assembly. Specifically, it demonstrates the compilation error that occurs when attempting to use both `r` and `e` modifiers simultaneously in a macro.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(target_arch = \"x86_64\")] {\n// We can\\'t specify both `r` and `e` at the same time.\nunsafe { core::arch::asm!(\"/* {:er}\", in(reg) 5i32); }\n// ERROR: asm template modifier must be a single character\n# }\n# #[cfg(not(target_arch = \"x86_64\"))] core::compile_error!(\"Test not supported on this arch\");\n```\n\n----------------------------------------\n\nTITLE: Importing a Hyphenated Cargo Package in Rust\nDESCRIPTION: This example shows how to import a Cargo package with a hyphenated name in Rust, where hyphens are automatically replaced with underscores.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/extern-crates.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Importing the Cargo package hello-world\nextern crate hello_world; // hyphen replaced with an underscore\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Non-Constraining Generic Parameters in Rust\nDESCRIPTION: Illustrates invalid cases where generic parameters do not constrain an implementation, resulting in compilation errors.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/implementations.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// The rest of these are errors, since they have type or const parameters that\n// do not constrain.\n\n// T does not constrain since it does not appear at all.\nimpl<T> Struct { /* ... */ }\n\n// N does not constrain for the same reason.\nimpl<const N: usize> Struct { /* ... */ }\n\n// Usage of T inside the implementation does not constrain the impl.\nimpl<T> Struct {\n    fn uses_t(t: &T) { /* ... */ }\n}\n\n// T is used as an associated type in the bounds for U, but U does not constrain.\nimpl<T, U> Struct where U: HasAssocType<Ty = T> { /* ... */ }\n\n// T is used in the bounds, but not as an associated type, so it does not constrain.\nimpl<T, U> GenericTrait<U> for u32 where U: GenericTrait<T> {}\n```\n\n----------------------------------------\n\nTITLE: Placeholder for Rust Grammar Summary\nDESCRIPTION: This code block is a placeholder that will be replaced with the actual grammar summary. It likely includes production rules for various Rust language constructs.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/grammar.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n{{ grammar-summary }}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Option for global_asm! Macro\nDESCRIPTION: Shows a compile-time error when trying to use options that are not supported in global_asm!. Only att_syntax and raw options are valid for global-scope assembly.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_45\n\nLANGUAGE: rust\nCODE:\n```\n// nomem is useless on global_asm!\ncore::arch::global_asm!(\"\", options(nomem));\n```\n\n----------------------------------------\n\nTITLE: Unsafe Extern Block Declaration in Rust\nDESCRIPTION: Documentation of extern block declarations being considered unsafe, with a note about pre-2024 edition behavior.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/unsafety.md#2025-04-21_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n- Declaring an [`extern`] block[^extern-2024].\n```\n\n----------------------------------------\n\nTITLE: Illustrating Rust Code Block in Markdown\nDESCRIPTION: Demonstrates how to properly format a Rust code example in Markdown, including the language specification for syntax highlighting.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/docs/authoring.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n```rust\nprintln!(\"Hello!\");\n```\n```\n\n----------------------------------------\n\nTITLE: Main Function Import Example\nDESCRIPTION: Demonstrates how to import a function to serve as the main function from a module.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/crates-and-source-files.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n    pub fn bar() {\n        println!(\"Hello, world!\");\n    }\n}\nuse foo::bar as main;\n```\n\n----------------------------------------\n\nTITLE: Changing to Rust Reference Working Directory\nDESCRIPTION: Command to change the current directory to the cloned Rust Language Reference repository.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/README.md#2025-04-21_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ncd reference\n```\n\n----------------------------------------\n\nTITLE: Bound Propagation in Associated Types in Rust\nDESCRIPTION: Shows how where clauses propagate when one associated type references another. The bound on Item propagates to Iterator because Iterator uses Item in its bounds.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/associated-items.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\ntrait Iterable {\n    type Item<'a> where Self: 'a;\n    type Iterator<'a>: Iterator<Item = Self::Item<'a>> where Self: 'a;\n    fn iter<'a>(&'a self) -> Self::Iterator<'a>;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Self Type and Constructor Usage in Rust\nDESCRIPTION: Shows different ways of using the Self keyword in Rust, including recursive struct definitions, generic parameters with Self bounds, and Self constructor usage in implementations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/names/scopes.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n// Self type within struct definition.\nstruct Recursive {\n    f1: Option<Box<Self>>\n}\n\n// Self type within generic parameters.\nstruct SelfGeneric<T: Into<Self>>(T);\n\n// Self value constructor within an implementation.\nstruct ImplExample();\nimpl ImplExample {\n    fn example() -> Self { // Self type\n        Self() // Self value constructor\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Irrefutable Patterns in Associated Functions With Body\nDESCRIPTION: Example of allowed parameter patterns in trait associated functions with implementation bodies. Only irrefutable patterns (patterns that always match) are permitted.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/traits.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\ntrait T {\n    fn f1((a, b): (i32, i32)) {} // OK: is irrefutable\n}\n```\n\n----------------------------------------\n\nTITLE: Unique Immutable Borrows in Rust Closure Captures\nDESCRIPTION: Illustrates the use of unique immutable borrows in closures when modifying the referent of a mutable reference.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/closure.md#2025-04-21_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nlet mut b = false;\nlet x = &mut b;\nlet mut c = || {\n    // An ImmBorrow and a MutBorrow of `x`.\n    let a = &x;\n    *x = true; // `x` captured by UniqueImmBorrow\n};\n// The following line is an error:\n// let y = &x;\nc();\n// However, the following is OK.\nlet z = &x;\n```\n\n----------------------------------------\n\nTITLE: Macro Shadowing Behavior in Rust\nDESCRIPTION: Illustrates how multiple macro definitions interact through shadowing, where newer definitions override previous ones within their scope.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/macros-by-example.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! m {\n    (1) => {};\n}\n\nm!(1);\n\nmod inner {\n    m!(1);\n\n    macro_rules! m {\n        (2) => {};\n    }\n    // m!(1); // Error: no rule matches '1'\n    m!(2);\n\n    macro_rules! m {\n        (3) => {};\n    }\n    m!(3);\n}\n\nm!(1);\n```\n\n----------------------------------------\n\nTITLE: Instruction Set Attribute Example for ARM in Rust\nDESCRIPTION: This code showcases how to use the `#[instruction_set]` attribute to specify the instruction set for functions targeting ARM architectures. It demonstrates function generation for both A32 and T32 instruction sets.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/codegen.md#2025-04-21_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\n#[instruction_set(arm::a32)]\nfn foo_arm_code() {}\n\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#[instruction_set(arm::t32)]\nfn bar_thumb_code() {}\n\n```\n\n----------------------------------------\n\nTITLE: Unsigned Byte Array Type in Rust\nDESCRIPTION: Reference to unsigned 8-bit byte array type, used in explaining str's internal representation.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/textual.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n[u8]\n```\n\n----------------------------------------\n\nTITLE: Defining Type Cast Expressions in Rust\nDESCRIPTION: This snippet describes the syntax for type casting expressions in Rust, using the `as` operator to convert values from one type to another. It specifies the expression structure and type compatibility.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_19\n\nLANGUAGE: grammar,expressions\nCODE:\n```\nTypeCastExpression -> Expression `as` TypeNoBounds\n```\n\n----------------------------------------\n\nTITLE: Error Message With Do Not Recommend Attribute\nDESCRIPTION: Shows the improved compiler error message when using the do_not_recommend attribute. The message is more concise and clearer about the type mismatch issue.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/diagnostics.md#2025-04-21_snippet_16\n\nLANGUAGE: text\nCODE:\n```\nerror[E0277]: the trait bound `&str: AsExpression<Integer>` is not satisfied\n  --> src/main.rs:53:15\n   |\n53 |     SelectInt.check(\"bar\");\n   |               ^^^^^ the trait `AsExpression<Integer>` is not implemented for `&str`\n   |\n   = help: the trait `AsExpression<Integer>` is not implemented for `&str`\n           but trait `AsExpression<Text>` is implemented for it\n   = help: for that trait implementation, expected `Text`, found `Integer`\n```\n\n----------------------------------------\n\nTITLE: Implementing Result-returning Test Function in Rust\nDESCRIPTION: Example of a test function that returns an io::Result<()>. Shows proper error handling with the ? operator and demonstrates how to structure a test that performs setup and execution steps.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/testing.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# use std::io;\n# fn setup_the_thing() -> io::Result<i32> { Ok(1) }\n# fn do_the_thing(s: &i32) -> io::Result<()> { Ok(()) }\n#[test]\nfn test_the_thing() -> io::Result<()> {\n    let state = setup_the_thing()?; // expected to succeed\n    do_the_thing(&state)?;          // expected to succeed\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Required Explicit Registers with clobber_abi (Failing Example)\nDESCRIPTION: Example showing that generic register class outputs are disallowed when using clobber_abi - all outputs must specify explicit registers to avoid conflicts.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_29\n\nLANGUAGE: rust\nCODE:\n```\nextern \"C\" fn foo(x: i32) -> i32 { 0 }\n\nlet z: i32;\n// explicit registers must be used to not accidentally overlap.\nunsafe {\n    core::arch::asm!(\n        \"mov eax, {:e}\",\n        \"call {}\",\n        out(reg) z,\n        sym foo,\n        clobber_abi(\"C\")\n    );\n    // ERROR: asm with `clobber_abi` must specify explicit registers for outputs\n}\nassert_eq!(z, 0);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Alias Restriction with Rust Enum Variants\nDESCRIPTION: This code illustrates the restriction that use paths cannot refer to enum variants through a type alias. While using the enum name directly to access a variant is valid, accessing it through a type alias results in a compile error.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/use-declarations.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nenum MyEnum {\n    MyVariant\n}\ntype TypeAlias = MyEnum;\n\nuse MyEnum::MyVariant; //~ OK\nuse TypeAlias::MyVariant; //~ ERROR\n```\n\n----------------------------------------\n\nTITLE: Primitive to Integer Casting in Rust\nDESCRIPTION: Demonstrates casting bool and char types to integers.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/operator-expr.md#2025-04-21_snippet_29\n\nLANGUAGE: rust\nCODE:\n```\nassert_eq!(false as i32, 0);\nassert_eq!(true as i32, 1);\nassert_eq!('A' as i32, 65);\nassert_eq!('Ö' as i32, 214);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Turbofish Syntax in Rust\nDESCRIPTION: This code snippet shows examples of turbofish syntax in Rust, where generic parameters in expressions must be prefixed with '::' to disambiguate from comparison operators. It demonstrates the syntax with Result and iterator collection examples.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/glossary.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet ok_num = Ok::<_, ()>(5);\nlet vec = [1, 2, 3].iter().map(|n| n * 2).collect::<Vec<_>>();\n```\n\n----------------------------------------\n\nTITLE: Using ATT Syntax Option with Register Operands in x86 Assembly\nDESCRIPTION: Demonstrates using the att_syntax option which causes the assembler to use the .att_syntax prefix mode. This example moves a value from one register to another, with register operands using the leading % prefix as required by AT&T syntax.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_41\n\nLANGUAGE: rust\nCODE:\n```\nlet x: i32;\nlet y = 1i32;\n// We need to use AT&T Syntax here. src, dest order for operands\nunsafe {\n    core::arch::asm!(\"mov {y:e}, {x:e}\",\n        x = lateout(reg) x,\n        y = in(reg) y,\n        options(att_syntax)\n    );\n}\nassert_eq!(x, y);\n```\n\n----------------------------------------\n\nTITLE: Type Mixing in Assembly\nDESCRIPTION: Shows valid and invalid cases of mixing different types in assembly operands.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nlet x: isize = 0;\nlet y: *mut ();\n// Transmute an `isize` to a `*mut ()`, using inline assembly magic\nunsafe { core::arch::asm!(\"/*{}*/\", inout(reg) x=>y); }\nassert!(y.is_null()); // Extremely roundabout way to make a null pointer\n```\n\n----------------------------------------\n\nTITLE: Specifying Rule Syntax in Markdown for Rust Reference\nDESCRIPTION: Shows how to define a rule in the Markdown source using the mdbook-spec extension. Rules are used to precede most clauses and can be linked to from anywhere in the book.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/docs/authoring.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nr[foo.bar]\n```\n\n----------------------------------------\n\nTITLE: Or-pattern binding error example in Rust\nDESCRIPTION: This example demonstrates a compile-time error that occurs when a variable `x` is not bound in all subpatterns of an or-pattern. This ensures that variables are consistently bound across all possible matches.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/patterns.md#2025-04-21_snippet_22\n\nLANGUAGE: Rust\nCODE:\n```\n\"x @ A(..) | B(..)\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Noreturn Option with Outputs Error\nDESCRIPTION: Shows a compile-time error when using the noreturn option with outputs. Assembly blocks marked as noreturn cannot have outputs since they never return control to the caller.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/inline-assembly.md#2025-04-21_snippet_44\n\nLANGUAGE: rust\nCODE:\n```\nlet z: i32;\n// noreturn can't have outputs\nunsafe { core::arch::asm!(\"mov {:e}, 1\", out(reg) z, options(noreturn)); }\n// ERROR: asm outputs are not allowed with the `noreturn` option\n```\n\n----------------------------------------\n\nTITLE: Examining object file symbols after compilation\nDESCRIPTION: Shows how to use the nm utility to inspect which static variables were kept in the compiled object file, demonstrating the effects of the #[used] attribute.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/abi.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ rustc -O --emit=obj --crate-type=rlib foo.rs\n\n$ nm -C foo.o\n0000000000000000 R foo::BAZ\n0000000000000000 r foo::FOO\n0000000000000000 R foo::QUUX\n0000000000000000 T foo::quux\n```\n\n----------------------------------------\n\nTITLE: Defining Trait Syntax in Rust\nDESCRIPTION: Grammar definition for trait syntax in Rust, including optional unsafe keyword, trait name, generic parameters, trait bounds, and associated items.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/traits.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nTrait ->\n    `unsafe`? `trait` IDENTIFIER GenericParams? ( `:` TypeParamBounds? )? WhereClause?\n    `{`\n        InnerAttribute*\n        AssociatedItem*\n    `}`\n```\n\n----------------------------------------\n\nTITLE: Invalid Parameter Patterns in Associated Functions Without Body\nDESCRIPTION: Example of invalid parameter pattern in a trait function without a body. Pattern matching in parameter position is not allowed for trait function declarations without implementations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/traits.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\ntrait T {\n    fn f2(&x: &i32); // ERROR: patterns aren't allowed in functions without bodies\n}\n```\n\n----------------------------------------\n\nTITLE: Edition Conditional Block Example in Markdown\nDESCRIPTION: Example showing how to document edition-specific changes using conditional blocks in the reference documentation.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/docs/authoring.md#2025-04-21_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\nr[foo.bar.edition2021]\n> [!EDITION-2021]\n> Describe what changed in 2021.\n```\n\n----------------------------------------\n\nTITLE: Defining a Function-Like Procedural Macro (Rust)\nDESCRIPTION: This snippet demonstrates how to define a function-like procedural macro in Rust. The `#[proc_macro]` attribute marks the function as a procedural macro.  The macro takes a `TokenStream` as input and returns a `TokenStream` as output, effectively transforming Rust syntax.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/procedural-macros.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# #![crate_type = \"proc-macro\"]\nextern crate proc_macro;\nuse proc_macro::TokenStream;\n\n#[proc_macro]\npub fn make_answer(_item: TokenStream) -> TokenStream {\n    \"fn answer() -> u32 { 42 }\".parse().unwrap()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Equivalent Code for Unit-like Struct in Rust\nDESCRIPTION: Demonstration of how a unit-like struct definition is equivalent to a struct with an empty body and a constant of its type.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/items/structs.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nstruct Cookie {}\nconst Cookie: Cookie = Cookie {};\nlet c = [Cookie, Cookie {}, Cookie, Cookie {}];\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Use of 'static as a Lifetime Parameter in Rust\nDESCRIPTION: This code snippet illustrates that 'static cannot be used as a generic lifetime parameter, resulting in a compilation error. It demonstrates the restriction on the weak keyword 'static.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/keywords.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// error[E0262]: invalid lifetime parameter name: `'static`\nfn invalid_lifetime_parameter<'static>(s: &'static str) -> &'static str { s }\n```\n\n----------------------------------------\n\nTITLE: Defining Await Expression Syntax in Rust\nDESCRIPTION: Grammar definition for await expressions in Rust. An await expression consists of an expression followed by a dot and the 'await' keyword.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/expressions/await-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nAwaitExpression -> Expression `.` `await`\n```\n\n----------------------------------------\n\nTITLE: Trait Object Grammar Specification\nDESCRIPTION: Formal grammar rules defining the syntax of trait objects in Rust, including optional dyn keyword and type parameter bounds.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/types/trait-object.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nTraitObjectType -> `dyn`? TypeParamBounds\n\nTraitObjectTypeOneBound -> `dyn`? TraitBound\n```\n\n----------------------------------------\n\nTITLE: Testing Rust Reference Code Examples\nDESCRIPTION: Command to run tests on all code examples in the Rust Language Reference using mdbook.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/README.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nmdbook test\n```\n\n----------------------------------------\n\nTITLE: Defining Lifetime and Loop Label Grammar in Rust\nDESCRIPTION: This grammar defines the syntax for lifetime parameters and loop labels in Rust, including raw lifetimes.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_12\n\nLANGUAGE: grammar\nCODE:\n```\nLIFETIME_TOKEN ->\n      `'` IDENTIFIER_OR_KEYWORD _not immediately followed by `'`_\n    | `'_` _not immediately followed by `'`_\n    | RAW_LIFETIME\n\nLIFETIME_OR_LABEL ->\n      `'` NON_KEYWORD_IDENTIFIER _not immediately followed by `'`_\n    | RAW_LIFETIME\n\nRAW_LIFETIME ->\n    `'r#` IDENTIFIER_OR_KEYWORD _except `crate`, `self`, `super`, `Self` and not immediately followed by `'`_\n\nRESERVED_RAW_LIFETIME -> `'r#_` _not immediately followed by `'`_\n```\n\n----------------------------------------\n\nTITLE: C String Literal Grammar Definition\nDESCRIPTION: Specifies the grammar rules for C string literals including Unicode escapes and string continuation.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_4\n\nLANGUAGE: grammar\nCODE:\n```\nC_STRING_LITERAL ->\n    `c\"` (\n        ~[`\"` `\\` CR NUL]\n      | BYTE_ESCAPE _except `\\0` or `\\x00`_\n      | UNICODE_ESCAPE _except `\\u{0}`, `\\u{00}`, …, `\\u{000000}`_\n      | STRING_CONTINUE\n    )* `\"` SUFFIX?\n```\n\n----------------------------------------\n\nTITLE: Defining Integer Literal Grammar in Rust\nDESCRIPTION: This grammar defines the syntax for integer literals in Rust, including decimal, binary, octal, and hexadecimal representations.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/tokens.md#2025-04-21_snippet_7\n\nLANGUAGE: grammar\nCODE:\n```\nINTEGER_LITERAL ->\n    ( DEC_LITERAL | BIN_LITERAL | OCT_LITERAL | HEX_LITERAL ) SUFFIX_NO_E?\n\nDEC_LITERAL -> DEC_DIGIT (DEC_DIGIT|`_`)*\n\nBIN_LITERAL -> `0b` (BIN_DIGIT|`_`)* BIN_DIGIT (BIN_DIGIT|`_`)*\n\nOCT_LITERAL -> `0o` (OCT_DIGIT|`_`)* OCT_DIGIT (OCT_DIGIT|`_`)*\n\nHEX_LITERAL -> `0x` (HEX_DIGIT|`_`)* HEX_DIGIT (HEX_DIGIT|`_`)*\n\nBIN_DIGIT -> [`0`-`1`]\n\nOCT_DIGIT -> [`0`-`7`]\n\nDEC_DIGIT -> [`0`-`9`]\n\nHEX_DIGIT -> [`0`-`9` `a`-`f` `A`-`F`]\n```\n\n----------------------------------------\n\nTITLE: Detecting C Runtime Linkage in Cargo Build Scripts\nDESCRIPTION: Rust build script example showing how to detect C runtime linkage using environment variables\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/linkage.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\n\nfn main() {\n    let linkage = env::var(\"CARGO_CFG_TARGET_FEATURE\").unwrap_or(String::new());\n\n    if linkage.contains(\"crt-static\") {\n        println!(\"the C runtime will be statically linked\");\n    } else {\n        println!(\"the C runtime will be dynamically linked\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using RUSTFLAGS for Static Linking on Windows MSVC\nDESCRIPTION: Command line example showing how to compile a statically linked binary on Windows MSVC using Cargo and RUSTFLAGS\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/linkage.md#2025-04-21_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\nRUSTFLAGS='-C target-feature=+crt-static' cargo build --target x86_64-pc-windows-msvc\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation for Rust Reference Review Process\nDESCRIPTION: Comprehensive guidelines for reviewing different types of changes to the Rust Language Reference, including policy changes, content modifications, and tooling updates. Includes a detailed review process flowchart with key questions for evaluating pull requests.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/docs/review-policy.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## Policy changes\n\n- Significant changes to the policy of how the team operates, such as changes to this document, should have agreement of the team without any blocking objections.\n- Minor changes to something like the style enforcement can be made with the review of a team member, as long as there is high confidence that it is unlikely any team member would object (for example, codifying a guideline that is already in practice), and that the change can be easily reversed.\n\n## Meaningful content addition or changes\n\n- When adding or changing content in the spec, the reviewer should consult with appropriate experts to validate the changes. This may not be required if the reviewer has high confidence that the changes are correct, and consider themselves well-versed enough in the topic to understand it, or the relevant experts are the author or have been heavily involved in the process. It is up to the reviewer to use their best judgement when to consult.\n- Content should always follow the guidelines from the [authoring guide].\n\n## Minor content changes\n- Minor content changes, such as small cleanups or wording fixes, can be made with the review from a team member without further consultation.\n\n## Tooling changes\n- Minor changes to the tooling may be made with a review from a team member. This includes bug fixes, minor additions that are unlikely to have objections, and additions that have already been discussed.\n- Major changes, such as a change in how content is authored, or major changes to how the tooling works should be approved by the team without blocking objections.\n```\n\n----------------------------------------\n\nTITLE: Standard Library Link Examples in Markdown\nDESCRIPTION: Examples showing how to properly link to standard library items using rustdoc intra-doc links with various formats including generics, shortened paths, and namespace disambiguation.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/docs/authoring.md#2025-04-21_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n[`std::option::Option`]\n```\n\nLANGUAGE: markdown\nCODE:\n```\n[`std::option::Option<T>`]\n```\n\nLANGUAGE: markdown\nCODE:\n```\n[`Option`](std::option::Option)\n```\n\nLANGUAGE: markdown\nCODE:\n```\n[`alloc::vec!`]\n```\n\nLANGUAGE: markdown\nCODE:\n```\n[`std::vec`](mod@std::vec)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating #[expect] Attribute Usage in Rust\nDESCRIPTION: This example shows how the #[expect] attribute creates lint expectations. It demonstrates both fulfilled and unfulfilled expectations for the unused_variables lint.\nSOURCE: https://github.com/rust-lang/reference.git/blob/master/src/attributes/diagnostics.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    #[expect(unused_variables)]\n    let question = \"who lives in a pineapple under the sea?\";\n    println!(\"{question}\");\n\n    #[expect(unused_variables)]\n    let answer = \"SpongeBob SquarePants!\";\n}\n```"
  }
]